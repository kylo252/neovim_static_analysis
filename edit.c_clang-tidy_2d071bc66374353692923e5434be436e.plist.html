<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/edit.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * edit.c: functions for Insert mode\n */\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/ascii.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/typval.h\"\n#include \"nvim/event/loop.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/extmark.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/path.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/popupmnu.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/state.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/tag.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/window.h\"\n\n// Definitions used for CTRL-X submode.\n// Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[]\n// and ctrl_x_mode_names[].\n\n#define CTRL_X_WANT_IDENT       0x100\n\n#define CTRL_X_NORMAL           0  ///< CTRL-N CTRL-P completion, default\n#define CTRL_X_NOT_DEFINED_YET  1\n#define CTRL_X_SCROLL           2\n#define CTRL_X_WHOLE_LINE       3\n#define CTRL_X_FILES            4\n#define CTRL_X_TAGS             (5 + CTRL_X_WANT_IDENT)\n#define CTRL_X_PATH_PATTERNS    (6 + CTRL_X_WANT_IDENT)\n#define CTRL_X_PATH_DEFINES     (7 + CTRL_X_WANT_IDENT)\n#define CTRL_X_FINISHED         8\n#define CTRL_X_DICTIONARY       (9 + CTRL_X_WANT_IDENT)\n#define CTRL_X_THESAURUS        (10 + CTRL_X_WANT_IDENT)\n#define CTRL_X_CMDLINE          11\n#define CTRL_X_FUNCTION         12\n#define CTRL_X_OMNI             13\n#define CTRL_X_SPELL            14\n#define CTRL_X_LOCAL_MSG        15  ///< only used in \"ctrl_x_msgs\"\n#define CTRL_X_EVAL             16  ///< for builtin function complete()\n#define CTRL_X_CMDLINE_CTRL_X   17  ///< CTRL-X typed in CTRL_X_CMDLINE\n\n#define CTRL_X_MSG(i) ctrl_x_msgs[(i) & ~CTRL_X_WANT_IDENT]\n#define CTRL_X_MODE_LINE_OR_EVAL(m) \\\n  ((m) == CTRL_X_WHOLE_LINE || (m) == CTRL_X_EVAL)\n\n// Message for CTRL-X mode, index is ctrl_x_mode.\nstatic char *ctrl_x_msgs[] =\n{\n  N_(\" Keyword completion (^N^P)\"),  // CTRL_X_NORMAL, ^P/^N compl.\n  N_(\" ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)\"),\n  NULL,  // CTRL_X_SCROLL: depends on state\n  N_(\" Whole line completion (^L^N^P)\"),\n  N_(\" File name completion (^F^N^P)\"),\n  N_(\" Tag completion (^]^N^P)\"),\n  N_(\" Path pattern completion (^N^P)\"),\n  N_(\" Definition completion (^D^N^P)\"),\n  NULL,  // CTRL_X_FINISHED\n  N_(\" Dictionary completion (^K^N^P)\"),\n  N_(\" Thesaurus completion (^T^N^P)\"),\n  N_(\" Command-line completion (^V^N^P)\"),\n  N_(\" User defined completion (^U^N^P)\"),\n  N_(\" Omni completion (^O^N^P)\"),\n  N_(\" Spelling suggestion (s^N^P)\"),\n  N_(\" Keyword Local completion (^N^P)\"),\n  NULL,  // CTRL_X_EVAL doesn't use msg.\n  N_(\" Command-line completion (^V^N^P)\"),\n};\n\nstatic char *ctrl_x_mode_names[] = {\n  \"keyword\",\n  \"ctrl_x\",\n  \"unknown\",          // CTRL_X_SCROLL\n  \"whole_line\",\n  \"files\",\n  \"tags\",\n  \"path_patterns\",\n  \"path_defines\",\n  \"unknown\",          // CTRL_X_FINISHED\n  \"dictionary\",\n  \"thesaurus\",\n  \"cmdline\",\n  \"function\",\n  \"omni\",\n  \"spell\",\n  NULL,               // CTRL_X_LOCAL_MSG only used in \"ctrl_x_msgs\"\n  \"eval\",\n  \"cmdline\",\n};\n\nstatic char e_hitend[] = N_(\"Hit end of paragraph\");\nstatic char e_complwin[] = N_(\"E839: Completion function changed window\");\nstatic char e_compldel[] = N_(\"E840: Completion function deleted text\");\n\n/*\n * Structure used to store one match for insert completion.\n */\ntypedef struct compl_S compl_T;\nstruct compl_S {\n  compl_T *cp_next;\n  compl_T *cp_prev;\n  char_u *cp_str;          // matched text\n  char_u *(cp_text[CPT_COUNT]);    // text for the menu\n  typval_T    cp_user_data;\n  char_u *cp_fname;        // file containing the match, allocated when\n                           // cp_flags has CP_FREE_FNAME\n  int cp_flags;                 // CP_ values\n  int cp_number;                // sequence number\n};\n\n/*\n * All the current matches are stored in a list.\n * \"compl_first_match\" points to the start of the list.\n * \"compl_curr_match\" points to the currently selected entry.\n * \"compl_shown_match\" is different from compl_curr_match during\n * ins_compl_get_exp().\n */\nstatic compl_T *compl_first_match = NULL;\nstatic compl_T *compl_curr_match = NULL;\nstatic compl_T *compl_shown_match = NULL;\nstatic compl_T *compl_old_match = NULL;\n\n/* After using a cursor key <Enter> selects a match in the popup menu,\n * otherwise it inserts a line break. */\nstatic int compl_enter_selects = FALSE;\n\n/* When \"compl_leader\" is not NULL only matches that start with this string\n * are used. */\nstatic char_u *compl_leader = NULL;\n\nstatic bool compl_get_longest = false;          // put longest common string in compl_leader\n\nstatic int compl_no_insert = FALSE;             /* FALSE: select & insert\n                                                   TRUE: noinsert */\nstatic int compl_no_select = FALSE;             /* FALSE: select & insert\n                                                   TRUE: noselect */\n\nstatic bool compl_used_match;       // Selected one of the matches.\n                                    // When false the match was edited or using\n                                    // the longest common string.\n\nstatic int compl_was_interrupted = FALSE;         /* didn't finish finding\n                                                     completions. */\n\nstatic bool compl_restarting = false;           // don't insert match\n\n// When the first completion is done \"compl_started\" is set.  When it's\n// false the word to be completed must be located.\nstatic bool compl_started = false;\n\n// Which Ctrl-X mode are we in?\nstatic int ctrl_x_mode = CTRL_X_NORMAL;\n\nstatic int compl_matches = 0;\nstatic char_u *compl_pattern = NULL;\nstatic Direction compl_direction = FORWARD;\nstatic Direction compl_shows_dir = FORWARD;\nstatic int compl_pending = 0;               // > 1 for postponed CTRL-N\nstatic pos_T compl_startpos;\nstatic colnr_T compl_col = 0;               /* column where the text starts\n                                             * that is being completed */\nstatic char_u *compl_orig_text = NULL;  /* text as it was before\n                                         * completion started */\nstatic int compl_cont_mode = 0;\nstatic expand_T compl_xp;\n\nstatic bool compl_opt_refresh_always = false;\n\nstatic int pum_selected_item = -1;\n\n/// state for pum_ext_select_item.\nstruct {\n  bool active;\n  int item;\n  bool insert;\n  bool finish;\n} pum_want;\n\ntypedef struct insert_state {\n  VimState state;\n  cmdarg_T *ca;\n  int mincol;\n  int cmdchar;\n  int startln;\n  long count;\n  int c;\n  int lastc;\n  int i;\n  bool did_backspace;                // previous char was backspace\n  bool line_is_white;                // line is empty before insert\n  linenr_T old_topline;              // topline before insertion\n  int old_topfill;\n  int inserted_space;                // just inserted a space\n  int replaceState;\n  int did_restart_edit;              // remember if insert mode was restarted\n                                     // after a ctrl+o\n  bool nomove;\n  char_u *ptr;\n} InsertState;\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"edit.c.generated.h\"\n#endif\n#define BACKSPACE_CHAR              1\n#define BACKSPACE_WORD              2\n#define BACKSPACE_WORD_NOT_SPACE    3\n#define BACKSPACE_LINE              4\n\nstatic size_t spell_bad_len = 0;   // length of located bad word\n\nstatic colnr_T Insstart_textlen;        // length of line when insert started\nstatic colnr_T Insstart_blank_vcol;     // vcol for first inserted blank\nstatic bool update_Insstart_orig = true;  // set Insstart_orig to Insstart\n\nstatic char_u *last_insert = NULL;    // the text of the previous insert,\n                                      // K_SPECIAL and CSI are escaped\nstatic int last_insert_skip;      // nr of chars in front of previous insert\nstatic int new_insert_skip;       // nr of chars in front of current insert\nstatic int did_restart_edit;            // \"restart_edit\" when calling edit()\n\nstatic bool can_cindent;                // may do cindenting on this line\n\nstatic int old_indent = 0;              // for ^^D command in insert mode\n\nstatic int revins_on;                   // reverse insert mode on\nstatic int revins_chars;                // how much to skip after edit\nstatic int revins_legal;                // was the last char 'legal'?\nstatic int revins_scol;                 // start column of revins session\n\nstatic bool ins_need_undo;              // call u_save() before inserting a\n                                        // char.  Set when edit() is called.\n                                        // after that arrow_used is used.\n\nstatic bool did_add_space = false;      // auto_format() added an extra space\n                                        // under the cursor\nstatic TriState dont_sync_undo = kFalse;  // CTRL-G U prevents syncing undo\n                                          // for the next left/right cursor key\n\nstatic linenr_T o_lnum = 0;\n\nstatic void insert_enter(InsertState *s)\n{\n  s->did_backspace = true;\n  s->old_topfill = -1;\n  s->replaceState = REPLACE;\n  // Remember whether editing was restarted after CTRL-O\n  did_restart_edit = restart_edit;\n  // sleep before redrawing, needed for \"CTRL-O :\" that results in an\n  // error message\n  check_for_delay(true);\n  // set Insstart_orig to Insstart\n  update_Insstart_orig = true;\n\n  ins_compl_clear();        // clear stuff for CTRL-X mode\n\n  // Trigger InsertEnter autocommands.  Do not do this for \"r<CR>\" or \"grx\".\n  if (s->cmdchar != 'r' && s->cmdchar != 'v') {\n    pos_T save_cursor = curwin->w_cursor;\n\n    if (s->cmdchar == 'R') {\n      s->ptr = (char_u *)\"r\";\n    } else if (s->cmdchar == 'V') {\n      s->ptr = (char_u *)\"v\";\n    } else {\n      s->ptr = (char_u *)\"i\";\n    }\n\n    set_vim_var_string(VV_INSERTMODE, (char *)s->ptr, 1);\n    set_vim_var_string(VV_CHAR, NULL, -1);\n    ins_apply_autocmds(EVENT_INSERTENTER);\n\n    // Check for changed highlighting, e.g. for ModeMsg.\n    if (need_highlight_changed) {\n      highlight_changed();\n    }\n\n    // Make sure the cursor didn't move.  Do call check_cursor_col() in\n    // case the text was modified.  Since Insert mode was not started yet\n    // a call to check_cursor_col() may move the cursor, especially with\n    // the \"A\" command, thus set State to avoid that. Also check that the\n    // line number is still valid (lines may have been deleted).\n    // Do not restore if v:char was set to a non-empty string.\n    if (!equalpos(curwin->w_cursor, save_cursor)\n        && *get_vim_var_str(VV_CHAR) == NUL\n        && save_cursor.lnum <= curbuf->b_ml.ml_line_count) {\n      int save_state = State;\n\n      curwin->w_cursor = save_cursor;\n      State = INSERT;\n      check_cursor_col();\n      State = save_state;\n    }\n  }\n\n  // When doing a paste with the middle mouse button, Insstart is set to\n  // where the paste started.\n  if (where_paste_started.lnum != 0) {\n    Insstart = where_paste_started;\n  } else {\n    Insstart = curwin->w_cursor;\n    if (s->startln) {\n      Insstart.col = 0;\n    }\n  }\n\n  Insstart_textlen = (colnr_T)linetabsize(get_cursor_line_ptr());\n  Insstart_blank_vcol = MAXCOL;\n\n  if (!did_ai) {\n    ai_col = 0;\n  }\n\n  if (s->cmdchar != NUL && restart_edit == 0) {\n    ResetRedobuff();\n    AppendNumberToRedobuff(s->count);\n    if (s->cmdchar == 'V' || s->cmdchar == 'v') {\n      // \"gR\" or \"gr\" command\n      AppendCharToRedobuff('g');\n      AppendCharToRedobuff((s->cmdchar == 'v') ? 'r' : 'R');\n    } else {\n      AppendCharToRedobuff(s->cmdchar);\n      if (s->cmdchar == 'g') {          // \"gI\" command\n        AppendCharToRedobuff('I');\n      } else if (s->cmdchar == 'r') {  // \"r<CR>\" command\n        s->count = 1;                  // insert only one <CR>\n      }\n    }\n  }\n\n  if (s->cmdchar == 'R') {\n    State = REPLACE;\n  } else if (s->cmdchar == 'V' || s->cmdchar == 'v') {\n    State = VREPLACE;\n    s->replaceState = VREPLACE;\n    orig_line_count = curbuf->b_ml.ml_line_count;\n    vr_lines_changed = 1;\n  } else {\n    State = INSERT;\n  }\n\n  stop_insert_mode = false;\n\n  // Need to recompute the cursor position, it might move when the cursor is\n  // on a TAB or special character.\n  curs_columns(curwin, true);\n\n  // Enable langmap or IME, indicated by 'iminsert'.\n  // Note that IME may enabled/disabled without us noticing here, thus the\n  // 'iminsert' value may not reflect what is actually used.  It is updated\n  // when hitting <Esc>.\n  if (curbuf->b_p_iminsert == B_IMODE_LMAP) {\n    State |= LANGMAP;\n  }\n\n  setmouse();\n  clear_showcmd();\n  // there is no reverse replace mode\n  revins_on = (State == INSERT && p_ri);\n  if (revins_on) {\n    undisplay_dollar();\n  }\n  revins_chars = 0;\n  revins_legal = 0;\n  revins_scol = -1;\n\n  // Handle restarting Insert mode.\n  // Don't do this for \"CTRL-O .\" (repeat an insert): we get here with\n  // restart_edit non-zero, and something in the stuff buffer.\n  if (restart_edit != 0 && stuff_empty()) {\n    // After a paste we consider text typed to be part of the insert for\n    // the pasted text. You can backspace over the pasted text too.\n    if (where_paste_started.lnum) {\n      arrow_used = false;\n    } else {\n      arrow_used = true;\n    }\n    restart_edit = 0;\n\n    // If the cursor was after the end-of-line before the CTRL-O and it is\n    // now at the end-of-line, put it after the end-of-line (this is not\n    // correct in very rare cases).\n    // Also do this if curswant is greater than the current virtual\n    // column.  Eg after \"^O$\" or \"^O80|\".\n    validate_virtcol();\n    update_curswant();\n    if (((ins_at_eol && curwin->w_cursor.lnum == o_lnum)\n         || curwin->w_curswant > curwin->w_virtcol)\n        && *(s->ptr = get_cursor_line_ptr() + curwin->w_cursor.col) != NUL) {\n      if (s->ptr[1] == NUL) {\n        curwin->w_cursor.col++;\n      } else {\n        s->i = utfc_ptr2len(s->ptr);\n        if (s->ptr[s->i] == NUL) {\n          curwin->w_cursor.col += s->i;\n        }\n      }\n    }\n    ins_at_eol = false;\n  } else {\n    arrow_used = false;\n  }\n\n  // we are in insert mode now, don't need to start it anymore\n  need_start_insertmode = false;\n\n  // Need to save the line for undo before inserting the first char.\n  ins_need_undo = true;\n\n  where_paste_started.lnum = 0;\n  can_cindent = true;\n  // The cursor line is not in a closed fold, unless 'insertmode' is set or\n  // restarting.\n  if (!p_im && did_restart_edit == 0) {\n    foldOpenCursor();\n  }\n\n  // If 'showmode' is set, show the current (insert/replace/..) mode.\n  // A warning message for changing a readonly file is given here, before\n  // actually changing anything.  It's put after the mode, if any.\n  s->i = 0;\n  if (p_smd && msg_silent == 0) {\n    s->i = showmode();\n  }\n\n  if (!p_im && did_restart_edit == 0) {\n    change_warning(curbuf, s->i == 0 ? 0 : s->i + 1);\n  }\n\n  ui_cursor_shape();            // may show different cursor shape\n  do_digraph(-1);               // clear digraphs\n\n  // Get the current length of the redo buffer, those characters have to be\n  // skipped if we want to get to the inserted characters.\n  s->ptr = get_inserted();\n  if (s->ptr == NULL) {\n    new_insert_skip = 0;\n  } else {\n    new_insert_skip = (int)STRLEN(s->ptr);\n    xfree(s->ptr);\n  }\n\n  old_indent = 0;\n\n  do {\n    state_enter(&s->state);\n    // If s->count != 0, `ins_esc` will prepare the redo buffer for reprocessing\n    // and return false, causing `state_enter` to be called again.\n  } while (!ins_esc(&s->count, s->cmdchar, s->nomove));\n\n  // Always update o_lnum, so that a \"CTRL-O .\" that adds a line\n  // still puts the cursor back after the inserted text.\n  if (ins_at_eol) {\n    o_lnum = curwin->w_cursor.lnum;\n  }\n\n  pum_check_clear();\n\n  foldUpdateAfterInsert();\n  // When CTRL-C was typed got_int will be set, with the result\n  // that the autocommands won't be executed. When mapped got_int\n  // is not set, but let's keep the behavior the same.\n  if (s->cmdchar != 'r' && s->cmdchar != 'v' && s->c != Ctrl_C) {\n    ins_apply_autocmds(EVENT_INSERTLEAVE);\n  }\n  did_cursorhold = false;\n}\n\nstatic int insert_check(VimState *state)\n{\n  InsertState *s = (InsertState *)state;\n\n  // If typed something may trigger CursorHoldI again.\n  if (s->c != K_EVENT\n      // but not in CTRL-X mode, a script can't restore the state\n      && ctrl_x_mode == CTRL_X_NORMAL) {\n    did_cursorhold = false;\n  }\n\n  // If the cursor was moved we didn't just insert a space */\n  if (arrow_used) {\n    s->inserted_space = false;\n  }\n\n  if (can_cindent\n      && cindent_on()\n      && ctrl_x_mode == CTRL_X_NORMAL\n      && !compl_started) {\n    insert_do_cindent(s);\n  }\n\n  if (!revins_legal) {\n    revins_scol = -1;     // reset on illegal motions\n  } else {\n    revins_legal = 0;\n  }\n\n  if (arrow_used) {       // don't repeat insert when arrow key used\n    s->count = 0;\n  }\n\n  if (update_Insstart_orig) {\n    Insstart_orig = Insstart;\n  }\n\n  if (stop_insert_mode && !pum_visible()) {\n    // \":stopinsert\" used or 'insertmode' reset\n    s->count = 0;\n    return 0;  // exit insert mode\n  }\n\n  // set curwin->w_curswant for next K_DOWN or K_UP\n  if (!arrow_used) {\n    curwin->w_set_curswant = true;\n  }\n\n  // If there is no typeahead may check for timestamps (e.g., for when a\n  // menu invoked a shell command).\n  if (stuff_empty()) {\n    did_check_timestamps = false;\n    if (need_check_timestamps) {\n      check_timestamps(false);\n    }\n  }\n\n  // When emsg() was called msg_scroll will have been set.\n  msg_scroll = false;\n\n\n  // Open fold at the cursor line, according to 'foldopen'.\n  if (fdo_flags & FDO_INSERT) {\n    foldOpenCursor();\n  }\n\n  // Close folds where the cursor isn't, according to 'foldclose'\n  if (!char_avail()) {\n    foldCheckClose();\n  }\n\n  if (bt_prompt(curbuf)) {\n    init_prompt(s->cmdchar);\n  }\n\n  // If we inserted a character at the last position of the last line in the\n  // window, scroll the window one line up. This avoids an extra redraw.  This\n  // is detected when the cursor column is smaller after inserting something.\n  // Don't do this when the topline changed already, it has already been\n  // adjusted (by insertchar() calling open_line())).\n  if (curbuf->b_mod_set\n      && curwin->w_p_wrap\n      && !s->did_backspace\n      && curwin->w_topline == s->old_topline\n      && curwin->w_topfill == s->old_topfill) {\n    s->mincol = curwin->w_wcol;\n    validate_cursor_col();\n\n    if (\n        curwin->w_wcol < s->mincol - tabstop_at(get_nolist_virtcol(),\n                                                curbuf->b_p_ts,\n                                                curbuf->b_p_vts_array)\n        && curwin->w_wrow == curwin->w_winrow\n        + curwin->w_height_inner - 1 - get_scrolloff_value(curwin)\n        && (curwin->w_cursor.lnum != curwin->w_topline\n            || curwin->w_topfill > 0)) {\n      if (curwin->w_topfill > 0) {\n        --curwin->w_topfill;\n      } else if (hasFolding(curwin->w_topline, NULL, &s->old_topline)) {\n        set_topline(curwin, s->old_topline + 1);\n      } else {\n        set_topline(curwin, curwin->w_topline + 1);\n      }\n    }\n  }\n\n  // May need to adjust w_topline to show the cursor.\n  update_topline(curwin);\n\n  s->did_backspace = false;\n\n  validate_cursor();                  // may set must_redraw\n\n  // Redraw the display when no characters are waiting.\n  // Also shows mode, ruler and positions cursor.\n  ins_redraw(true);\n\n  if (curwin->w_p_scb) {\n    do_check_scrollbind(true);\n  }\n\n  if (curwin->w_p_crb) {\n    do_check_cursorbind();\n  }\n\n  update_curswant();\n  s->old_topline = curwin->w_topline;\n  s->old_topfill = curwin->w_topfill;\n  s->lastc = s->c;   // remember previous char for CTRL-D\n\n  // After using CTRL-G U the next cursor key will not break undo.\n  if (dont_sync_undo == kNone) {\n    dont_sync_undo = kTrue;\n  } else {\n    dont_sync_undo = kFalse;\n  }\n\n  return 1;\n}\n\nstatic int insert_execute(VimState *state, int key)\n{\n  if (key == K_IGNORE || key == K_NOP) {\n    return -1;  // get another key\n  }\n  InsertState *s = (InsertState *)state;\n  s->c = key;\n\n  // Don't want K_EVENT with cursorhold for the second key, e.g., after CTRL-V.\n  if (key != K_EVENT) {\n    did_cursorhold = true;\n  }\n\n  if (p_hkmap && KeyTyped) {\n    s->c = hkmap(s->c);  // Hebrew mode mapping\n  }\n\n  // Special handling of keys while the popup menu is visible or wanted\n  // and the cursor is still in the completed word.  Only when there is\n  // a match, skip this when no matches were found.\n  if (compl_started\n      && pum_wanted()\n      && curwin->w_cursor.col >= compl_col\n      && (compl_shown_match == NULL\n          || compl_shown_match != compl_shown_match->cp_next)) {\n    // BS: Delete one character from \"compl_leader\".\n    if ((s->c == K_BS || s->c == Ctrl_H)\n        && curwin->w_cursor.col > compl_col\n        && (s->c = ins_compl_bs()) == NUL) {\n      return 1;  // continue\n    }\n\n    // When no match was selected or it was edited.\n    if (!compl_used_match) {\n      // CTRL-L: Add one character from the current match to\n      // \"compl_leader\".  Except when at the original match and\n      // there is nothing to add, CTRL-L works like CTRL-P then.\n      if (s->c == Ctrl_L\n          && (!CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)\n              || (compl_shown_match != NULL\n                  && compl_shown_match->cp_str != NULL\n                  && (int)STRLEN(compl_shown_match->cp_str)\n                  > curwin->w_cursor.col - compl_col))) {\n        ins_compl_addfrommatch();\n        return 1;  // continue\n      }\n\n      // A non-white character that fits in with the current\n      // completion: Add to \"compl_leader\".\n      if (ins_compl_accept_char(s->c)) {\n        // Trigger InsertCharPre.\n        char_u *str = do_insert_char_pre(s->c);\n        char_u *p;\n\n        if (str != NULL) {\n          for (p = str; *p != NUL; MB_PTR_ADV(p)) {\n            ins_compl_addleader(PTR2CHAR(p));\n          }\n          xfree(str);\n        } else {\n          ins_compl_addleader(s->c);\n        }\n        return 1;  // continue\n      }\n\n      // Pressing CTRL-Y selects the current match.  When\n      // compl_enter_selects is set the Enter key does the same.\n      if ((s->c == Ctrl_Y\n           || (compl_enter_selects\n               && (s->c == CAR || s->c == K_KENTER || s->c == NL)))\n          && stop_arrow() == OK) {\n        ins_compl_delete();\n        ins_compl_insert(false);\n      }\n    }\n  }\n\n  // Prepare for or stop CTRL-X mode. This doesn't do completion, but it does\n  // fix up the text when finishing completion.\n  compl_get_longest = false;\n  if (ins_compl_prep(s->c)) {\n    return 1;  // continue\n  }\n\n  // CTRL-\\ CTRL-N goes to Normal mode,\n  // CTRL-\\ CTRL-G goes to mode selected with 'insertmode',\n  // CTRL-\\ CTRL-O is like CTRL-O but without moving the cursor\n  if (s->c == Ctrl_BSL) {\n    // may need to redraw when no more chars available now\n    ins_redraw(false);\n    no_mapping++;\n    s->c = plain_vgetc();\n    no_mapping--;\n    if (s->c != Ctrl_N && s->c != Ctrl_G && s->c != Ctrl_O) {\n      // it's something else\n      vungetc(s->c);\n      s->c = Ctrl_BSL;\n    } else if (s->c == Ctrl_G && p_im) {\n      return 1;  // continue\n    } else {\n      if (s->c == Ctrl_O) {\n        ins_ctrl_o();\n        ins_at_eol = false;  // cursor keeps its column\n        s->nomove = true;\n      }\n      s->count = 0;\n      return 0;\n    }\n  }\n\n  s->c = do_digraph(s->c);\n\n  if ((s->c == Ctrl_V || s->c == Ctrl_Q)\n      && (ctrl_x_mode == CTRL_X_CMDLINE || ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X)) {\n    insert_do_complete(s);\n    return 1;\n  }\n\n  if (s->c == Ctrl_V || s->c == Ctrl_Q) {\n    ins_ctrl_v();\n    s->c = Ctrl_V;       // pretend CTRL-V is last typed character\n    return 1;  // continue\n  }\n\n  if (cindent_on()\n      && ctrl_x_mode == 0) {\n    // A key name preceded by a bang means this key is not to be\n    // inserted.  Skip ahead to the re-indenting below.\n    // A key name preceded by a star means that indenting has to be\n    // done before inserting the key.\n    s->line_is_white = inindent(0);\n    if (in_cinkeys(s->c, '!', s->line_is_white)) {\n      insert_do_cindent(s);\n      return 1;  // continue\n    }\n\n    if (can_cindent && in_cinkeys(s->c, '*', s->line_is_white)\n        && stop_arrow() == OK) {\n      do_c_expr_indent();\n    }\n  }\n\n  if (curwin->w_p_rl) {\n    switch (s->c) {\n    case K_LEFT:\n      s->c = K_RIGHT; break;\n    case K_S_LEFT:\n      s->c = K_S_RIGHT; break;\n    case K_C_LEFT:\n      s->c = K_C_RIGHT; break;\n    case K_RIGHT:\n      s->c = K_LEFT; break;\n    case K_S_RIGHT:\n      s->c = K_S_LEFT; break;\n    case K_C_RIGHT:\n      s->c = K_C_LEFT; break;\n    }\n  }\n\n  // If 'keymodel' contains \"startsel\", may start selection.  If it\n  // does, a CTRL-O and c will be stuffed, we need to get these\n  // characters.\n  if (ins_start_select(s->c)) {\n    return 1;  // continue\n  }\n\n  return insert_handle_key(s);\n}\n\nstatic int insert_handle_key(InsertState *s)\n{\n  // The big switch to handle a character in insert mode.\n  // TODO(tarruda): This could look better if a lookup table is used.\n  // (similar to normal mode `nv_cmds[]`)\n  switch (s->c) {\n  case ESC:           // End input mode\n    if (echeck_abbr(ESC + ABBR_OFF)) {\n      break;\n    }\n    FALLTHROUGH;\n\n  case Ctrl_C:        // End input mode\n    if (s->c == Ctrl_C && cmdwin_type != 0) {\n      // Close the cmdline window. */\n      cmdwin_result = K_IGNORE;\n      got_int = false;         // don't stop executing autocommands et al\n      s->nomove = true;\n      return 0;  // exit insert mode\n    }\n    if (s->c == Ctrl_C && bt_prompt(curbuf)) {\n      if (invoke_prompt_interrupt()) {\n        if (!bt_prompt(curbuf)) {\n          // buffer changed to a non-prompt buffer, get out of\n          // Insert mode\n          return 0;\n        }\n        break;\n      }\n    }\n\n    // when 'insertmode' set, and not halfway through a mapping, don't leave\n    // Insert mode\n    if (goto_im()) {\n      if (got_int) {\n        (void)vgetc();                        // flush all buffers\n        got_int = false;\n      } else {\n        vim_beep(BO_IM);\n      }\n      break;\n    }\n    return 0;  // exit insert mode\n\n  case Ctrl_Z:        // suspend when 'insertmode' set\n    if (!p_im) {\n      goto normalchar;                // insert CTRL-Z as normal char\n    }\n    do_cmdline_cmd(\"stop\");\n    ui_cursor_shape();  // may need to update cursor shape\n    break;\n\n  case Ctrl_O:        // execute one command\n    if (ctrl_x_mode == CTRL_X_OMNI) {\n      insert_do_complete(s);\n      break;\n    }\n\n    if (echeck_abbr(Ctrl_O + ABBR_OFF)) {\n      break;\n    }\n\n    ins_ctrl_o();\n\n    // don't move the cursor left when 'virtualedit' has \"onemore\".\n    if (ve_flags & VE_ONEMORE) {\n      ins_at_eol = false;\n      s->nomove = true;\n    }\n\n    s->count = 0;\n    return 0;  // exit insert mode\n\n  case K_INS:         // toggle insert/replace mode\n  case K_KINS:\n    ins_insert(s->replaceState);\n    break;\n\n  case K_SELECT:      // end of Select mode mapping - ignore\n    break;\n\n\n  case K_HELP:        // Help key works like <ESC> <Help>\n  case K_F1:\n  case K_XF1:\n    stuffcharReadbuff(K_HELP);\n    if (p_im) {\n      need_start_insertmode = true;\n    }\n    return 0;  // exit insert mode\n\n\n  case ' ':\n    if (mod_mask != MOD_MASK_CTRL) {\n      goto normalchar;\n    }\n    FALLTHROUGH;\n  case K_ZERO:        // Insert the previously inserted text.\n  case NUL:\n  case Ctrl_A:\n    // For ^@ the trailing ESC will end the insert, unless there is an\n    // error.\n    if (stuff_inserted(NUL, 1L, (s->c == Ctrl_A)) == FAIL\n        && s->c != Ctrl_A && !p_im) {\n      return 0;  // exit insert mode\n    }\n    s->inserted_space = false;\n    break;\n\n  case Ctrl_R:        // insert the contents of a register\n    ins_reg();\n    auto_format(false, true);\n    s->inserted_space = false;\n    break;\n\n  case Ctrl_G:        // commands starting with CTRL-G\n    ins_ctrl_g();\n    break;\n\n  case Ctrl_HAT:      // switch input mode and/or langmap\n    ins_ctrl_hat();\n    break;\n\n  case Ctrl__:        // switch between languages\n    if (!p_ari) {\n      goto normalchar;\n    }\n    ins_ctrl_();\n    break;\n\n  case Ctrl_D:        // Make indent one shiftwidth smaller.\n    if (ctrl_x_mode == CTRL_X_PATH_DEFINES) {\n      insert_do_complete(s);\n      break;\n    }\n    FALLTHROUGH;\n\n  case Ctrl_T:        // Make indent one shiftwidth greater.\n    if (s->c == Ctrl_T && ctrl_x_mode == CTRL_X_THESAURUS) {\n      if (check_compl_option(false)) {\n        insert_do_complete(s);\n      }\n      break;\n    }\n    ins_shift(s->c, s->lastc);\n    auto_format(false, true);\n    s->inserted_space = false;\n    break;\n\n  case K_DEL:         // delete character under the cursor\n  case K_KDEL:\n    ins_del();\n    auto_format(false, true);\n    break;\n\n  case K_BS:          // delete character before the cursor\n  case Ctrl_H:\n    s->did_backspace = ins_bs(s->c, BACKSPACE_CHAR, &s->inserted_space);\n    auto_format(false, true);\n    break;\n\n  case Ctrl_W:        // delete word before the cursor\n    s->did_backspace = ins_bs(s->c, BACKSPACE_WORD, &s->inserted_space);\n    auto_format(false, true);\n    break;\n\n  case Ctrl_U:        // delete all inserted text in current line\n    // CTRL-X CTRL-U completes with 'completefunc'.\n    if (ctrl_x_mode == CTRL_X_FUNCTION) {\n      insert_do_complete(s);\n    } else {\n      s->did_backspace = ins_bs(s->c, BACKSPACE_LINE, &s->inserted_space);\n      auto_format(false, true);\n      s->inserted_space = false;\n    }\n    break;\n\n  case K_LEFTMOUSE:     // mouse keys\n  case K_LEFTMOUSE_NM:\n  case K_LEFTDRAG:\n  case K_LEFTRELEASE:\n  case K_LEFTRELEASE_NM:\n  case K_MOUSEMOVE:\n  case K_MIDDLEMOUSE:\n  case K_MIDDLEDRAG:\n  case K_MIDDLERELEASE:\n  case K_RIGHTMOUSE:\n  case K_RIGHTDRAG:\n  case K_RIGHTRELEASE:\n  case K_X1MOUSE:\n  case K_X1DRAG:\n  case K_X1RELEASE:\n  case K_X2MOUSE:\n  case K_X2DRAG:\n  case K_X2RELEASE:\n    ins_mouse(s->c);\n    break;\n\n  case K_MOUSEDOWN:   // Default action for scroll wheel up: scroll up\n    ins_mousescroll(MSCR_DOWN);\n    break;\n\n  case K_MOUSEUP:     // Default action for scroll wheel down: scroll down\n    ins_mousescroll(MSCR_UP);\n    break;\n\n  case K_MOUSELEFT:   // Scroll wheel left\n    ins_mousescroll(MSCR_LEFT);\n    break;\n\n  case K_MOUSERIGHT:  // Scroll wheel right\n    ins_mousescroll(MSCR_RIGHT);\n    break;\n\n  case K_IGNORE:      // Something mapped to nothing\n    break;\n\n  case K_EVENT:       // some event\n    state_handle_k_event();\n    goto check_pum;\n\n  case K_COMMAND:       // some command\n    do_cmdline(NULL, getcmdkeycmd, NULL, 0);\n\ncheck_pum:\n    // TODO(bfredl): Not entirely sure this indirection is necessary\n    // but doing like this ensures using nvim_select_popupmenu_item is\n    // equivalent to selecting the item with a typed key.\n    if (pum_want.active) {\n      if (pum_visible()) {\n        insert_do_complete(s);\n        if (pum_want.finish) {\n          // accept the item and stop completion\n          ins_compl_prep(Ctrl_Y);\n        }\n      }\n      pum_want.active = false;\n    }\n    break;\n\n  case K_HOME:        // <Home>\n  case K_KHOME:\n  case K_S_HOME:\n  case K_C_HOME:\n    ins_home(s->c);\n    break;\n\n  case K_END:         // <End>\n  case K_KEND:\n  case K_S_END:\n  case K_C_END:\n    ins_end(s->c);\n    break;\n\n  case K_LEFT:        // <Left>\n    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) {\n      ins_s_left();\n    } else {\n      ins_left();\n    }\n    break;\n\n  case K_S_LEFT:      // <S-Left>\n  case K_C_LEFT:\n    ins_s_left();\n    break;\n\n  case K_RIGHT:       // <Right>\n    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)) {\n      ins_s_right();\n    } else {\n      ins_right();\n    }\n    break;\n\n  case K_S_RIGHT:     // <S-Right>\n  case K_C_RIGHT:\n    ins_s_right();\n    break;\n\n  case K_UP:          // <Up>\n    if (pum_visible()) {\n      insert_do_complete(s);\n    } else if (mod_mask & MOD_MASK_SHIFT) {\n      ins_pageup();\n    } else {\n      ins_up(false);\n    }\n    break;\n\n  case K_S_UP:        // <S-Up>\n  case K_PAGEUP:\n  case K_KPAGEUP:\n    if (pum_visible()) {\n      insert_do_complete(s);\n    } else {\n      ins_pageup();\n    }\n    break;\n\n  case K_DOWN:        // <Down>\n    if (pum_visible()) {\n      insert_do_complete(s);\n    } else if (mod_mask & MOD_MASK_SHIFT) {\n      ins_pagedown();\n    } else {\n      ins_down(false);\n    }\n    break;\n\n  case K_S_DOWN:      // <S-Down>\n  case K_PAGEDOWN:\n  case K_KPAGEDOWN:\n    if (pum_visible()) {\n      insert_do_complete(s);\n    } else {\n      ins_pagedown();\n    }\n    break;\n\n\n  case K_S_TAB:       // When not mapped, use like a normal TAB\n    s->c = TAB;\n    FALLTHROUGH;\n\n  case TAB:           // TAB or Complete patterns along path\n    if (ctrl_x_mode == CTRL_X_PATH_PATTERNS) {\n      insert_do_complete(s);\n      break;\n    }\n    s->inserted_space = false;\n    if (ins_tab()) {\n      goto normalchar;                // insert TAB as a normal char\n    }\n    auto_format(false, true);\n    break;\n\n  case K_KENTER:      // <Enter>\n    s->c = CAR;\n    FALLTHROUGH;\n  case CAR:\n  case NL:\n    // In a quickfix window a <CR> jumps to the error under the\n    // cursor.\n    if (bt_quickfix(curbuf) && s->c == CAR) {\n      if (curwin->w_llist_ref == NULL) {          // quickfix window\n        do_cmdline_cmd(\".cc\");\n      } else {                                    // location list window\n        do_cmdline_cmd(\".ll\");\n      }\n      break;\n    }\n    if (cmdwin_type != 0) {\n      // Execute the command in the cmdline window.\n      cmdwin_result = CAR;\n      return 0;\n    }\n    if (bt_prompt(curbuf)) {\n      invoke_prompt_callback();\n      if (!bt_prompt(curbuf)) {\n        // buffer changed to a non-prompt buffer, get out of\n        // Insert mode\n        return 0;\n      }\n      break;\n    }\n    if (!ins_eol(s->c) && !p_im) {\n      return 0;  // out of memory\n    }\n    auto_format(false, false);\n    s->inserted_space = false;\n    break;\n\n  case Ctrl_K:        // digraph or keyword completion\n    if (ctrl_x_mode == CTRL_X_DICTIONARY) {\n      if (check_compl_option(true)) {\n        insert_do_complete(s);\n      }\n      break;\n    }\n\n    s->c = ins_digraph();\n    if (s->c == NUL) {\n      break;\n    }\n    goto normalchar;\n\n  case Ctrl_X:        // Enter CTRL-X mode\n    ins_ctrl_x();\n    break;\n\n  case Ctrl_RSB:      // Tag name completion after ^X\n    if (ctrl_x_mode != CTRL_X_TAGS) {\n      goto normalchar;\n    } else {\n      insert_do_complete(s);\n    }\n    break;\n\n  case Ctrl_F:        // File name completion after ^X\n    if (ctrl_x_mode != CTRL_X_FILES) {\n      goto normalchar;\n    } else {\n      insert_do_complete(s);\n    }\n    break;\n\n  case 's':           // Spelling completion after ^X\n  case Ctrl_S:\n    if (ctrl_x_mode != CTRL_X_SPELL) {\n      goto normalchar;\n    } else {\n      insert_do_complete(s);\n    }\n    break;\n\n  case Ctrl_L:        // Whole line completion after ^X\n    if (ctrl_x_mode != CTRL_X_WHOLE_LINE) {\n      // CTRL-L with 'insertmode' set: Leave Insert mode\n      if (p_im) {\n        if (echeck_abbr(Ctrl_L + ABBR_OFF)) {\n          break;\n        }\n        return 0;  // exit insert mode\n      }\n      goto normalchar;\n    }\n    FALLTHROUGH;\n\n  case Ctrl_P:        // Do previous/next pattern completion\n  case Ctrl_N:\n    // if 'complete' is empty then plain ^P is no longer special,\n    // but it is under other ^X modes\n    if (*curbuf->b_p_cpt == NUL\n        && (ctrl_x_mode == CTRL_X_NORMAL\n            || ctrl_x_mode == CTRL_X_WHOLE_LINE)\n        && !(compl_cont_status & CONT_LOCAL)) {\n      goto normalchar;\n    }\n\n    insert_do_complete(s);\n    break;\n\n  case Ctrl_Y:        // copy from previous line or scroll down\n  case Ctrl_E:        // copy from next line or scroll up\n    s->c = ins_ctrl_ey(s->c);\n    break;\n\n  default:\n\nnormalchar:\n    // Insert a normal character.\n\n    if (!p_paste) {\n      // Trigger InsertCharPre.\n      char_u *str = do_insert_char_pre(s->c);\n      char_u *p;\n\n      if (str != NULL) {\n        if (*str != NUL && stop_arrow() != FAIL) {\n          // Insert the new value of v:char literally.\n          for (p = str; *p != NUL; MB_PTR_ADV(p)) {\n            s->c = PTR2CHAR(p);\n            if (s->c == CAR || s->c == K_KENTER || s->c == NL) {\n              ins_eol(s->c);\n            } else {\n              ins_char(s->c);\n            }\n          }\n          AppendToRedobuffLit(str, -1);\n        }\n        xfree(str);\n        s->c = NUL;\n      }\n\n      // If the new value is already inserted or an empty string\n      // then don't insert any character.\n      if (s->c == NUL) {\n        break;\n      }\n    }\n    // Try to perform smart-indenting.\n    ins_try_si(s->c);\n\n    if (s->c == ' ') {\n      s->inserted_space = true;\n      if (inindent(0)) {\n        can_cindent = false;\n      }\n      if (Insstart_blank_vcol == MAXCOL\n          && curwin->w_cursor.lnum == Insstart.lnum) {\n        Insstart_blank_vcol = get_nolist_virtcol();\n      }\n    }\n\n    // Insert a normal character and check for abbreviations on a\n    // special character.  Let CTRL-] expand abbreviations without\n    // inserting it.\n    if (vim_iswordc(s->c)\n        // Add ABBR_OFF for characters above 0x100, this is\n        // what check_abbr() expects.\n        || (!echeck_abbr((s->c >= 0x100) ? (s->c + ABBR_OFF) : s->c)\n            && s->c != Ctrl_RSB)) {\n      insert_special(s->c, false, false);\n      revins_legal++;\n      revins_chars++;\n    }\n\n    auto_format(false, true);\n\n    // When inserting a character the cursor line must never be in a\n    // closed fold.\n    foldOpenCursor();\n    break;\n  }       // end of switch (s->c)\n\n  return 1;  // continue\n}\n\nstatic void insert_do_complete(InsertState *s)\n{\n  compl_busy = true;\n  if (ins_complete(s->c, true) == FAIL) {\n    compl_cont_status = 0;\n  }\n  compl_busy = false;\n}\n\nstatic void insert_do_cindent(InsertState *s)\n{\n  // Indent now if a key was typed that is in 'cinkeys'.\n  if (in_cinkeys(s->c, ' ', s->line_is_white)) {\n    if (stop_arrow() == OK) {\n      // re-indent the current line\n      do_c_expr_indent();\n    }\n  }\n}\n\n/// edit(): Start inserting text.\n///\n/// \"cmdchar\" can be:\n/// 'i' normal insert command\n/// 'a' normal append command\n/// 'R' replace command\n/// 'r' \"r<CR>\" command: insert one <CR>.\n///     Note: count can be > 1, for redo, but still only one <CR> is inserted.\n///           <Esc> is not used for redo.\n/// 'g' \"gI\" command.\n/// 'V' \"gR\" command for Virtual Replace mode.\n/// 'v' \"gr\" command for single character Virtual Replace mode.\n///\n/// This function is not called recursively.  For CTRL-O commands, it returns\n/// and lets the caller handle the Normal-mode command.\n///\n/// @param  cmdchar  command that started the insert\n/// @param  startln  if true, insert at start of line\n/// @param  count    repeat count for the command\n///\n/// @return true if a CTRL-O command caused the return (insert mode pending).\nbool edit(int cmdchar, bool startln, long count)\n{\n  if (curbuf->terminal) {\n    if (ex_normal_busy) {\n      // Do not enter terminal mode from ex_normal(), which would cause havoc\n      // (such as terminal-mode recursiveness). Instead set a flag to force-set\n      // the value of `restart_edit` before `ex_normal` returns.\n      restart_edit = 'i';\n      force_restart_edit = true;\n    } else {\n      terminal_enter();\n    }\n    return false;\n  }\n\n  // Don't allow inserting in the sandbox.\n  if (sandbox != 0) {\n    EMSG(_(e_sandbox));\n    return false;\n  }\n\n  // Don't allow changes in the buffer while editing the cmdline.  The\n  // caller of getcmdline() may get confused.\n  if (textlock != 0) {\n    EMSG(_(e_secure));\n    return false;\n  }\n\n  // Don't allow recursive insert mode when busy with completion.\n  if (compl_started || compl_busy || pum_visible()) {\n    EMSG(_(e_secure));\n    return false;\n  }\n\n  InsertState state, *s = &state;\n  memset(s, 0, sizeof(InsertState));\n  s->state.execute = insert_execute;\n  s->state.check = insert_check;\n  s->cmdchar = cmdchar;\n  s->startln = startln;\n  s->count = count;\n  insert_enter(s);\n  return s->c == Ctrl_O;\n}\n\n/// Redraw for Insert mode.\n/// This is postponed until getting the next character to make '$' in the 'cpo'\n/// option work correctly.\n/// Only redraw when there are no characters available.  This speeds up\n/// inserting sequences of characters (e.g., for CTRL-R).\n///\n/// @param ready  not busy with something\nstatic void ins_redraw(bool ready)\n{\n  bool conceal_cursor_moved = false;\n\n  if (char_avail()) {\n    return;\n  }\n\n  // Trigger CursorMoved if the cursor moved.  Not when the popup menu is\n  // visible, the command might delete it.\n  if (ready && (has_event(EVENT_CURSORMOVEDI) || curwin->w_p_cole > 0)\n      && !equalpos(curwin->w_last_cursormoved, curwin->w_cursor)\n      && !pum_visible()) {\n    // Need to update the screen first, to make sure syntax\n    // highlighting is correct after making a change (e.g., inserting\n    // a \"(\".  The autocommand may also require a redraw, so it's done\n    // again below, unfortunately.\n    if (syntax_present(curwin) && must_redraw) {\n      update_screen(0);\n    }\n    if (has_event(EVENT_CURSORMOVEDI)) {\n      // Make sure curswant is correct, an autocommand may call\n      // getcurpos()\n      update_curswant();\n      ins_apply_autocmds(EVENT_CURSORMOVEDI);\n    }\n    conceal_cursor_moved = true;\n    curwin->w_last_cursormoved = curwin->w_cursor;\n  }\n\n  // Trigger TextChangedI if changedtick differs.\n  if (ready && has_event(EVENT_TEXTCHANGEDI)\n      && curbuf->b_last_changedtick != buf_get_changedtick(curbuf)\n      && !pum_visible()) {\n    aco_save_T aco;\n    varnumber_T tick = buf_get_changedtick(curbuf);\n\n    // save and restore curwin and curbuf, in case the autocmd changes them\n    aucmd_prepbuf(&aco, curbuf);\n    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, false, curbuf);\n    aucmd_restbuf(&aco);\n    curbuf->b_last_changedtick = buf_get_changedtick(curbuf);\n    if (tick != buf_get_changedtick(curbuf)) {  // see ins_apply_autocmds()\n      u_save(curwin->w_cursor.lnum,\n             (linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n  }\n\n  // Trigger TextChangedP if changedtick differs. When the popupmenu closes\n  // TextChangedI will need to trigger for backwards compatibility, thus use\n  // different b_last_changedtick* variables.\n  if (ready && has_event(EVENT_TEXTCHANGEDP)\n      && curbuf->b_last_changedtick_pum != buf_get_changedtick(curbuf)\n      && pum_visible()) {\n    aco_save_T aco;\n    varnumber_T tick = buf_get_changedtick(curbuf);\n\n    // save and restore curwin and curbuf, in case the autocmd changes them\n    aucmd_prepbuf(&aco, curbuf);\n    apply_autocmds(EVENT_TEXTCHANGEDP, NULL, NULL, false, curbuf);\n    aucmd_restbuf(&aco);\n    curbuf->b_last_changedtick_pum = buf_get_changedtick(curbuf);\n    if (tick != buf_get_changedtick(curbuf)) {  // see ins_apply_autocmds()\n      u_save(curwin->w_cursor.lnum,\n             (linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n  }\n\n  // Trigger Scroll if viewport changed.\n  if (ready && has_event(EVENT_WINSCROLLED)\n      && win_did_scroll(curwin)) {\n    do_autocmd_winscrolled(curwin);\n  }\n\n  // Trigger BufModified if b_changed_invalid is set.\n  if (ready && has_event(EVENT_BUFMODIFIEDSET)\n      && curbuf->b_changed_invalid == true\n      && !pum_visible()) {\n    apply_autocmds(EVENT_BUFMODIFIEDSET, NULL, NULL, false, curbuf);\n    curbuf->b_changed_invalid = false;\n  }\n\n  if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin)\n      && conceal_cursor_moved) {\n    redrawWinline(curwin, curwin->w_cursor.lnum);\n  }\n\n  pum_check_clear();\n  if (must_redraw) {\n    update_screen(0);\n  } else if (clear_cmdline || redraw_cmdline) {\n    showmode();  // clear cmdline and show mode\n  }\n  showruler(false);\n  setcursor();\n  emsg_on_display = false;      // may remove error message now\n}\n\n/*\n * Handle a CTRL-V or CTRL-Q typed in Insert mode.\n */\nstatic void ins_ctrl_v(void)\n{\n  int c;\n  bool did_putchar = false;\n\n  // may need to redraw when no more chars available now\n  ins_redraw(false);\n\n  if (redrawing() && !char_avail()) {\n    edit_putchar('^', true);\n    did_putchar = true;\n  }\n  AppendToRedobuff(CTRL_V_STR);\n\n  add_to_showcmd_c(Ctrl_V);\n\n  c = get_literal();\n  if (did_putchar) {\n    // when the line fits in 'columns' the '^' is at the start of the next\n    // line and will not removed by the redraw\n    edit_unputchar();\n  }\n  clear_showcmd();\n  insert_special(c, true, true);\n  revins_chars++;\n  revins_legal++;\n}\n\n/*\n * Put a character directly onto the screen.  It's not stored in a buffer.\n * Used while handling CTRL-K, CTRL-V, etc. in Insert mode.\n */\nstatic int pc_status;\n#define PC_STATUS_UNSET 0       // pc_bytes was not set\n#define PC_STATUS_RIGHT 1       // right halve of double-wide char\n#define PC_STATUS_LEFT  2       // left halve of double-wide char\n#define PC_STATUS_SET   3       // pc_bytes was filled\nstatic char_u pc_bytes[MB_MAXBYTES + 1];  // saved bytes\nstatic int pc_attr;\nstatic int pc_row;\nstatic int pc_col;\n\nvoid edit_putchar(int c, bool highlight)\n{\n  int attr;\n\n  if (curwin->w_grid_alloc.chars != NULL || default_grid.chars != NULL) {\n    update_topline(curwin);  // just in case w_topline isn't valid\n    validate_cursor();\n    if (highlight) {\n      attr = HL_ATTR(HLF_8);\n    } else {\n      attr = 0;\n    }\n    pc_row = curwin->w_wrow;\n    pc_col = 0;\n    pc_status = PC_STATUS_UNSET;\n    if (curwin->w_p_rl) {\n      pc_col += curwin->w_grid.Columns - 1 - curwin->w_wcol;\n      const int fix_col = grid_fix_col(&curwin->w_grid, pc_col, pc_row);\n\n      if (fix_col != pc_col) {\n        grid_putchar(&curwin->w_grid, ' ', pc_row, fix_col, attr);\n        curwin->w_wcol--;\n        pc_status = PC_STATUS_RIGHT;\n      }\n    } else {\n      pc_col += curwin->w_wcol;\n      if (grid_lefthalve(&curwin->w_grid, pc_row, pc_col)) {\n        pc_status = PC_STATUS_LEFT;\n      }\n    }\n\n    // save the character to be able to put it back\n    if (pc_status == PC_STATUS_UNSET) {\n      grid_getbytes(&curwin->w_grid, pc_row, pc_col, pc_bytes, &pc_attr);\n      pc_status = PC_STATUS_SET;\n    }\n    grid_putchar(&curwin->w_grid, c, pc_row, pc_col, attr);\n  }\n}\n\n/// Return the effective prompt for the specified buffer.\nchar_u *buf_prompt_text(const buf_T *const buf)\n    FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (buf->b_prompt_text == NULL) {\n    return (char_u *)\"% \";\n  }\n  return buf->b_prompt_text;\n}\n\n// Return the effective prompt for the current buffer.\nchar_u *prompt_text(void) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf_prompt_text(curbuf);\n}\n\n// Prepare for prompt mode: Make sure the last line has the prompt text.\n// Move the cursor to this line.\nstatic void init_prompt(int cmdchar_todo)\n{\n  char_u *prompt = prompt_text();\n  char_u *text;\n\n  curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n  text = get_cursor_line_ptr();\n  if (STRNCMP(text, prompt, STRLEN(prompt)) != 0) {\n    // prompt is missing, insert it or append a line with it\n    if (*text == NUL) {\n      ml_replace(curbuf->b_ml.ml_line_count, prompt, true);\n    } else {\n      ml_append(curbuf->b_ml.ml_line_count, prompt, 0, false);\n    }\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance(MAXCOL);\n    changed_bytes(curbuf->b_ml.ml_line_count, 0);\n  }\n  if (cmdchar_todo == 'A') {\n    coladvance(MAXCOL);\n  }\n  if (cmdchar_todo == 'I' || curwin->w_cursor.col <= (int)STRLEN(prompt)) {\n    curwin->w_cursor.col = STRLEN(prompt);\n  }\n  // Make sure the cursor is in a valid position.\n  check_cursor();\n}\n\n/// @return  true if the cursor is in the editable position of the prompt line.\nbool prompt_curpos_editable(void)\n{\n  return curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count\n         && curwin->w_cursor.col >= (int)STRLEN(prompt_text());\n}\n\n/*\n * Undo the previous edit_putchar().\n */\nvoid edit_unputchar(void)\n{\n  if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled) {\n    if (pc_status == PC_STATUS_RIGHT) {\n      curwin->w_wcol++;\n    }\n    if (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT) {\n      redrawWinline(curwin, curwin->w_cursor.lnum);\n    } else {\n      grid_puts(&curwin->w_grid, pc_bytes, pc_row - msg_scrolled, pc_col,\n                pc_attr);\n    }\n  }\n}\n\n/*\n * Called when p_dollar is set: display a '$' at the end of the changed text\n * Only works when cursor is in the line that changes.\n */\nvoid display_dollar(colnr_T col)\n{\n  colnr_T save_col;\n\n  if (!redrawing()) {\n    return;\n  }\n\n  save_col = curwin->w_cursor.col;\n  curwin->w_cursor.col = col;\n\n  // If on the last byte of a multi-byte move to the first byte.\n  char_u *p = get_cursor_line_ptr();\n  curwin->w_cursor.col -= utf_head_off(p, p + col);\n  curs_columns(curwin, false);              // Recompute w_wrow and w_wcol\n  if (curwin->w_wcol < curwin->w_grid.Columns) {\n    edit_putchar('$', false);\n    dollar_vcol = curwin->w_virtcol;\n  }\n  curwin->w_cursor.col = save_col;\n}\n\n/*\n * Call this function before moving the cursor from the normal insert position\n * in insert mode.\n */\nstatic void undisplay_dollar(void)\n{\n  if (dollar_vcol >= 0) {\n    dollar_vcol = -1;\n    redrawWinline(curwin, curwin->w_cursor.lnum);\n  }\n}\n\n/// Insert an indent (for <Tab> or CTRL-T) or delete an indent (for CTRL-D).\n/// Keep the cursor on the same character.\n/// type == INDENT_INC   increase indent (for CTRL-T or <Tab>)\n/// type == INDENT_DEC   decrease indent (for CTRL-D)\n/// type == INDENT_SET   set indent to \"amount\"\n///\n/// @param round               if TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).\n/// @param replaced            replaced character, put on replace stack\n/// @param call_changed_bytes  call changed_bytes()\nvoid change_indent(int type, int amount, int round, int replaced, int call_changed_bytes)\n{\n  int vcol;\n  int last_vcol;\n  int insstart_less;                    // reduction for Insstart.col\n  int new_cursor_col;\n  int i;\n  char_u *ptr;\n  int save_p_list;\n  int start_col;\n  colnr_T vc;\n  colnr_T orig_col = 0;                 // init for GCC\n  char_u *new_line, *orig_line = NULL;     // init for GCC\n\n  // VREPLACE mode needs to know what the line was like before changing\n  if (State & VREPLACE_FLAG) {\n    orig_line = vim_strsave(get_cursor_line_ptr());   // Deal with NULL below\n    orig_col = curwin->w_cursor.col;\n  }\n\n  // for the following tricks we don't want list mode\n  save_p_list = curwin->w_p_list;\n  curwin->w_p_list = FALSE;\n  vc = getvcol_nolist(&curwin->w_cursor);\n  vcol = vc;\n\n  /*\n   * For Replace mode we need to fix the replace stack later, which is only\n   * possible when the cursor is in the indent.  Remember the number of\n   * characters before the cursor if it's possible.\n   */\n  start_col = curwin->w_cursor.col;\n\n  // determine offset from first non-blank\n  new_cursor_col = curwin->w_cursor.col;\n  beginline(BL_WHITE);\n  new_cursor_col -= curwin->w_cursor.col;\n\n  insstart_less = curwin->w_cursor.col;\n\n  /*\n   * If the cursor is in the indent, compute how many screen columns the\n   * cursor is to the left of the first non-blank.\n   */\n  if (new_cursor_col < 0) {\n    vcol = get_indent() - vcol;\n  }\n\n  if (new_cursor_col > 0) {         // can't fix replace stack\n    start_col = -1;\n  }\n\n  /*\n   * Set the new indent.  The cursor will be put on the first non-blank.\n   */\n  if (type == INDENT_SET) {\n    (void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n  } else {\n    int save_State = State;\n\n    // Avoid being called recursively.\n    if (State & VREPLACE_FLAG) {\n      State = INSERT;\n    }\n    shift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n    State = save_State;\n  }\n  insstart_less -= curwin->w_cursor.col;\n\n  /*\n   * Try to put cursor on same character.\n   * If the cursor is at or after the first non-blank in the line,\n   * compute the cursor column relative to the column of the first\n   * non-blank character.\n   * If we are not in insert mode, leave the cursor on the first non-blank.\n   * If the cursor is before the first non-blank, position it relative\n   * to the first non-blank, counted in screen columns.\n   */\n  if (new_cursor_col >= 0) {\n    /*\n     * When changing the indent while the cursor is touching it, reset\n     * Insstart_col to 0.\n     */\n    if (new_cursor_col == 0) {\n      insstart_less = MAXCOL;\n    }\n    new_cursor_col += curwin->w_cursor.col;\n  } else if (!(State & INSERT)) {\n    new_cursor_col = curwin->w_cursor.col;\n  } else {\n    /*\n     * Compute the screen column where the cursor should be.\n     */\n    vcol = get_indent() - vcol;\n    curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n    /*\n     * Advance the cursor until we reach the right screen column.\n     */\n    vcol = last_vcol = 0;\n    new_cursor_col = -1;\n    ptr = get_cursor_line_ptr();\n    while (vcol <= (int)curwin->w_virtcol) {\n      last_vcol = vcol;\n      if (new_cursor_col >= 0) {\n        new_cursor_col += utfc_ptr2len(ptr + new_cursor_col);\n      } else {\n        new_cursor_col++;\n      }\n      vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n    }\n    vcol = last_vcol;\n\n    /*\n     * May need to insert spaces to be able to position the cursor on\n     * the right screen column.\n     */\n    if (vcol != (int)curwin->w_virtcol) {\n      curwin->w_cursor.col = (colnr_T)new_cursor_col;\n      i = (int)curwin->w_virtcol - vcol;\n      ptr = xmallocz(i);\n      memset(ptr, ' ', i);\n      new_cursor_col += i;\n      ins_str(ptr);\n      xfree(ptr);\n    }\n\n    /*\n     * When changing the indent while the cursor is in it, reset\n     * Insstart_col to 0.\n     */\n    insstart_less = MAXCOL;\n  }\n\n  curwin->w_p_list = save_p_list;\n\n  if (new_cursor_col <= 0) {\n    curwin->w_cursor.col = 0;\n  } else {\n    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n  }\n  curwin->w_set_curswant = TRUE;\n  changed_cline_bef_curs();\n\n  /*\n   * May have to adjust the start of the insert.\n   */\n  if (State & INSERT) {\n    if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0) {\n      if ((int)Insstart.col <= insstart_less) {\n        Insstart.col = 0;\n      } else {\n        Insstart.col -= insstart_less;\n      }\n    }\n    if ((int)ai_col <= insstart_less) {\n      ai_col = 0;\n    } else {\n      ai_col -= insstart_less;\n    }\n  }\n\n  /*\n   * For REPLACE mode, may have to fix the replace stack, if it's possible.\n   * If the number of characters before the cursor decreased, need to pop a\n   * few characters from the replace stack.\n   * If the number of characters before the cursor increased, need to push a\n   * few NULs onto the replace stack.\n   */\n  if (REPLACE_NORMAL(State) && start_col >= 0) {\n    while (start_col > (int)curwin->w_cursor.col) {\n      replace_join(0);              // remove a NUL from the replace stack\n      start_col--;\n    }\n    while (start_col < (int)curwin->w_cursor.col || replaced) {\n      replace_push(NUL);\n      if (replaced) {\n        replace_push(replaced);\n        replaced = NUL;\n      }\n      ++start_col;\n    }\n  }\n\n  /*\n   * For VREPLACE mode, we also have to fix the replace stack.  In this case\n   * it is always possible because we backspace over the whole line and then\n   * put it back again the way we wanted it.\n   */\n  if (State & VREPLACE_FLAG) {\n    // Save new line\n    new_line = vim_strsave(get_cursor_line_ptr());\n\n    // We only put back the new line up to the cursor\n    new_line[curwin->w_cursor.col] = NUL;\n    int new_col = curwin->w_cursor.col;\n\n    // Put back original line\n    ml_replace(curwin->w_cursor.lnum, orig_line, false);\n    curwin->w_cursor.col = orig_col;\n\n    curbuf_splice_pending++;\n\n    // Backspace from cursor to start of line\n    backspace_until_column(0);\n\n    // Insert new stuff into line again\n    ins_bytes(new_line);\n\n    xfree(new_line);\n\n    curbuf_splice_pending--;\n\n    // TODO(bfredl): test for crazy edge cases, like we stand on a TAB or\n    // something? does this even do the right text change then?\n    int delta = orig_col - new_col;\n    extmark_splice_cols(curbuf, curwin->w_cursor.lnum-1, new_col,\n                        delta < 0 ? -delta : 0,\n                        delta > 0 ? delta : 0,\n                        kExtmarkUndo);\n  }\n}\n\n/*\n * Truncate the space at the end of a line.  This is to be used only in an\n * insert mode.  It handles fixing the replace stack for REPLACE and VREPLACE\n * modes.\n */\nvoid truncate_spaces(char_u *line)\n{\n  int i;\n\n  // find start of trailing white space\n  for (i = (int)STRLEN(line) - 1; i >= 0 && ascii_iswhite(line[i]); i--) {\n    if (State & REPLACE_FLAG) {\n      replace_join(0);              // remove a NUL from the replace stack\n    }\n  }\n  line[i + 1] = NUL;\n}\n\n/*\n * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE\n * modes correctly.  May also be used when not in insert mode at all.\n * Will attempt not to go before \"col\" even when there is a composing\n * character.\n */\nvoid backspace_until_column(int col)\n{\n  while ((int)curwin->w_cursor.col > col) {\n    curwin->w_cursor.col--;\n    if (State & REPLACE_FLAG) {\n      replace_do_bs(col);\n    } else if (!del_char_after_col(col)) {\n      break;\n    }\n  }\n}\n\n/// Like del_char(), but make sure not to go before column \"limit_col\".\n/// Only matters when there are composing characters.\n///\n/// @param  limit_col  only delete the character if it is after this column\n//\n/// @return true when something was deleted.\nstatic bool del_char_after_col(int limit_col)\n{\n  if (limit_col >= 0) {\n    colnr_T ecol = curwin->w_cursor.col + 1;\n\n    // Make sure the cursor is at the start of a character, but\n    // skip forward again when going too far back because of a\n    // composing character.\n    mb_adjust_cursor();\n    while (curwin->w_cursor.col < (colnr_T)limit_col) {\n      int l = utf_ptr2len(get_cursor_pos_ptr());\n\n      if (l == 0) {  // end of line\n        break;\n      }\n      curwin->w_cursor.col += l;\n    }\n    if (*get_cursor_pos_ptr() == NUL || curwin->w_cursor.col == ecol) {\n      return false;\n    }\n    del_bytes(ecol - curwin->w_cursor.col, false, true);\n  } else {\n    del_char(false);\n  }\n  return true;\n}\n\n/*\n * CTRL-X pressed in Insert mode.\n */\nstatic void ins_ctrl_x(void)\n{\n  if (ctrl_x_mode != CTRL_X_CMDLINE && ctrl_x_mode != CTRL_X_CMDLINE_CTRL_X) {\n    // if the next ^X<> won't ADD nothing, then reset compl_cont_status\n    if (compl_cont_status & CONT_N_ADDS) {\n      compl_cont_status |= CONT_INTRPT;\n    } else {\n      compl_cont_status = 0;\n    }\n    // We're not sure which CTRL-X mode it will be yet\n    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n    edit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n    edit_submode_pre = NULL;\n    showmode();\n  } else {\n    // CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X\n    // CTRL-V look like CTRL-N\n    ctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;\n  }\n}\n\n// Whether other than default completion has been selected.\nbool ctrl_x_mode_not_default(void)\n{\n  return ctrl_x_mode != CTRL_X_NORMAL;\n}\n\n// Whether CTRL-X was typed without a following character,\n// not including when in CTRL-X CTRL-V mode.\nbool ctrl_x_mode_not_defined_yet(void)\n{\n  return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;\n}\n\n\n/// Check that the \"dict\" or \"tsr\" option can be used.\n///\n/// @param  dict_opt  check \"dict\" when true, \"tsr\" when false.\nstatic bool check_compl_option(bool dict_opt)\n{\n  if (dict_opt\n      ? (*curbuf->b_p_dict == NUL && *p_dict == NUL && !curwin->w_p_spell)\n      : (*curbuf->b_p_tsr == NUL && *p_tsr == NUL)) {\n    ctrl_x_mode = CTRL_X_NORMAL;\n    edit_submode = NULL;\n    msg_attr((dict_opt\n              ? _(\"'dictionary' option is empty\")\n              : _(\"'thesaurus' option is empty\")), HL_ATTR(HLF_E));\n    if (emsg_silent == 0) {\n      vim_beep(BO_COMPL);\n      setcursor();\n      ui_flush();\n      os_delay(2004L, false);\n    }\n    return false;\n  }\n  return true;\n}\n\n/// Check that the character \"c\" a valid key to go to or keep us in CTRL-X mode?\n/// This depends on the current mode.\n///\n/// @param  c  character to check\nbool vim_is_ctrl_x_key(int c)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Always allow ^R - let its results then be checked\n  if (c == Ctrl_R) {\n    return true;\n  }\n\n  // Accept <PageUp> and <PageDown> if the popup menu is visible.\n  if (ins_compl_pum_key(c)) {\n    return true;\n  }\n\n  switch (ctrl_x_mode) {\n  case 0:  // Not in any CTRL-X mode\n    return c == Ctrl_N || c == Ctrl_P || c == Ctrl_X;\n  case CTRL_X_NOT_DEFINED_YET:\n  case CTRL_X_CMDLINE_CTRL_X:\n    return c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E\n           || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB\n           || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P\n           || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V\n           || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O\n           || c == Ctrl_S || c == Ctrl_K || c == 's'\n           || c == Ctrl_Z;\n  case CTRL_X_SCROLL:\n    return c == Ctrl_Y || c == Ctrl_E;\n  case CTRL_X_WHOLE_LINE:\n    return c == Ctrl_L || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_FILES:\n    return c == Ctrl_F || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_DICTIONARY:\n    return c == Ctrl_K || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_THESAURUS:\n    return c == Ctrl_T || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_TAGS:\n    return c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_PATH_PATTERNS:\n    return c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_PATH_DEFINES:\n    return c == Ctrl_D || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_CMDLINE:\n    return c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N\n           || c == Ctrl_X;\n  case CTRL_X_FUNCTION:\n    return c == Ctrl_U || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_OMNI:\n    return c == Ctrl_O || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_SPELL:\n    return c == Ctrl_S || c == Ctrl_P || c == Ctrl_N;\n  case CTRL_X_EVAL:\n    return (c == Ctrl_P || c == Ctrl_N);\n  }\n  internal_error(\"vim_is_ctrl_x_key()\");\n  return false;\n}\n\n/// Check that character \"c\" is part of the item currently being\n/// completed.  Used to decide whether to abandon complete mode when the menu\n/// is visible.\n///\n/// @param  c  character to check\nstatic bool ins_compl_accept_char(int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (ctrl_x_mode & CTRL_X_WANT_IDENT) {\n    // When expanding an identifier only accept identifier chars.\n    return vim_isIDc(c);\n  }\n\n  switch (ctrl_x_mode) {\n  case CTRL_X_FILES:\n    // When expanding file name only accept file name chars. But not\n    // path separators, so that \"proto/<Tab>\" expands files in\n    // \"proto\", not \"proto/\" as a whole\n    return vim_isfilec(c) && !vim_ispathsep(c);\n\n  case CTRL_X_CMDLINE:\n  case CTRL_X_CMDLINE_CTRL_X:\n  case CTRL_X_OMNI:\n    // Command line and Omni completion can work with just about any\n    // printable character, but do stop at white space.\n    return vim_isprintc(c) && !ascii_iswhite(c);\n\n  case CTRL_X_WHOLE_LINE:\n    // For while line completion a space can be part of the line.\n    return vim_isprintc(c);\n  }\n  return vim_iswordc(c);\n}\n\n/// This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the\n/// case of the originally typed text is used, and the case of the completed\n/// text is inferred, ie this tries to work out what case you probably wanted\n/// the rest of the word to be in -- webb\n///\n/// @param[in]  cont_s_ipos  next ^X<> will set initial_pos\nint ins_compl_add_infercase(char_u *str_arg, int len, bool icase, char_u *fname, Direction dir,\n                            bool cont_s_ipos)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  char_u *str = str_arg;\n  int i, c;\n  int actual_len;                       // Take multi-byte characters\n  int actual_compl_length;              // into account.\n  int min_len;\n  bool has_lower = false;\n  bool was_letter = false;\n  int flags = 0;\n\n  if (p_ic && curbuf->b_p_inf && len > 0) {\n    // Infer case of completed part.\n\n    // Find actual length of completion.\n    {\n      const char_u *p = str;\n      actual_len = 0;\n      while (*p != NUL) {\n        MB_PTR_ADV(p);\n        actual_len++;\n      }\n    }\n\n    // Find actual length of original text.\n    {\n      const char_u *p = compl_orig_text;\n      actual_compl_length = 0;\n      while (*p != NUL) {\n        MB_PTR_ADV(p);\n        actual_compl_length++;\n      }\n    }\n\n    /* \"actual_len\" may be smaller than \"actual_compl_length\" when using\n     * thesaurus, only use the minimum when comparing. */\n    min_len = actual_len < actual_compl_length\n              ? actual_len : actual_compl_length;\n\n    // Allocate wide character array for the completion and fill it.\n    int *const wca = xmalloc(actual_len * sizeof(*wca));\n    {\n      const char_u *p = str;\n      for (i = 0; i < actual_len; i++) {\n        wca[i] = mb_ptr2char_adv(&p);\n      }\n    }\n\n    // Rule 1: Were any chars converted to lower?\n    {\n      const char_u *p = compl_orig_text;\n      for (i = 0; i < min_len; i++) {\n        c = mb_ptr2char_adv(&p);\n        if (mb_islower(c)) {\n          has_lower = true;\n          if (mb_isupper(wca[i])) {\n            // Rule 1 is satisfied.\n            for (i = actual_compl_length; i < actual_len; i++) {\n              wca[i] = mb_tolower(wca[i]);\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    /*\n     * Rule 2: No lower case, 2nd consecutive letter converted to\n     * upper case.\n     */\n    if (!has_lower) {\n      const char_u *p = compl_orig_text;\n      for (i = 0; i < min_len; i++) {\n        c = mb_ptr2char_adv(&p);\n        if (was_letter && mb_isupper(c) && mb_islower(wca[i])) {\n          // Rule 2 is satisfied.\n          for (i = actual_compl_length; i < actual_len; i++) {\n            wca[i] = mb_toupper(wca[i]);\n          }\n          break;\n        }\n        was_letter = mb_islower(c) || mb_isupper(c);\n      }\n    }\n\n    // Copy the original case of the part we typed.\n    {\n      const char_u *p = compl_orig_text;\n      for (i = 0; i < min_len; i++) {\n        c = mb_ptr2char_adv(&p);\n        if (mb_islower(c)) {\n          wca[i] = mb_tolower(wca[i]);\n        } else if (mb_isupper(c)) {\n          wca[i] = mb_toupper(wca[i]);\n        }\n      }\n    }\n\n    // Generate encoding specific output from wide character array.\n    // Multi-byte characters can occupy up to five bytes more than\n    // ASCII characters, and we also need one byte for NUL, so stay\n    // six bytes away from the edge of IObuff.\n    {\n      char_u *p = IObuff;\n      i = 0;\n      while (i < actual_len && (p - IObuff + 6) < IOSIZE) {\n        p += utf_char2bytes(wca[i++], p);\n      }\n      *p = NUL;\n    }\n\n    xfree(wca);\n\n    str = IObuff;\n  }\n  if (cont_s_ipos) {\n    flags |= CP_CONT_S_IPOS;\n  }\n  if (icase) {\n    flags |= CP_ICASE;\n  }\n\n  return ins_compl_add(str, len, fname, NULL, false, NULL, dir, flags, false);\n}\n\n/// Add a match to the list of matches\n///\n/// @param[in]  str  Match to add.\n/// @param[in]  len  Match length, -1 to use #STRLEN.\n/// @param[in]  fname  File name match comes from. May be NULL.\n/// @param[in]  cptext  Extra text for popup menu. May be NULL. If not NULL,\n///                     must have exactly #CPT_COUNT items.\n/// @param[in]  cptext_allocated  If true, will not copy cptext strings.\n///\n///                               @note Will free strings in case of error.\n///                                     cptext itself will not be freed.\n/// @param[in]  cdir  Completion direction.\n/// @param[in]  adup  True if duplicate matches are to be accepted.\n///\n/// @return NOTDONE if the given string is already in the list of completions,\n///         otherwise it is added to the list and  OK is returned. FAIL will be\n///         returned in case of error.\nstatic int ins_compl_add(char_u *const str, int len, char_u *const fname,\n                         char_u *const *const cptext, const bool cptext_allocated,\n                         typval_T *user_data, const Direction cdir, int flags_arg, const bool adup)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  compl_T *match;\n  const Direction dir = (cdir == kDirectionNotSet ? compl_direction : cdir);\n  int flags = flags_arg;\n\n  if (flags & CP_FAST) {\n    fast_breakcheck();\n  } else {\n    os_breakcheck();\n  }\n#define FREE_CPTEXT(cptext, cptext_allocated) \\\n  do { \\\n    if (cptext != NULL && cptext_allocated) { \\\n      for (size_t i = 0; i < CPT_COUNT; i++) { \\\n        xfree(cptext[i]); \\\n      } \\\n    } \\\n  } while (0)\n  if (got_int) {\n    FREE_CPTEXT(cptext, cptext_allocated);\n    return FAIL;\n  }\n  if (len < 0) {\n    len = (int)STRLEN(str);\n  }\n\n  /*\n   * If the same match is already present, don't add it.\n   */\n  if (compl_first_match != NULL && !adup) {\n    match = compl_first_match;\n    do {\n      if (!(match->cp_flags & CP_ORIGINAL_TEXT)\n          && STRNCMP(match->cp_str, str, len) == 0\n          && match->cp_str[len] == NUL) {\n        FREE_CPTEXT(cptext, cptext_allocated);\n        return NOTDONE;\n      }\n      match = match->cp_next;\n    } while (match != NULL && match != compl_first_match);\n  }\n\n  // Remove any popup menu before changing the list of matches.\n  ins_compl_del_pum();\n\n  /*\n   * Allocate a new match structure.\n   * Copy the values to the new match structure.\n   */\n  match = xcalloc(1, sizeof(compl_T));\n  match->cp_number = -1;\n  if (flags & CP_ORIGINAL_TEXT) {\n    match->cp_number = 0;\n  }\n  match->cp_str = vim_strnsave(str, len);\n\n  // match-fname is:\n  // - compl_curr_match->cp_fname if it is a string equal to fname.\n  // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.\n  // - NULL otherwise.  --Acevedo\n  if (fname != NULL\n      && compl_curr_match != NULL\n      && compl_curr_match->cp_fname != NULL\n      && STRCMP(fname, compl_curr_match->cp_fname) == 0) {\n    match->cp_fname = compl_curr_match->cp_fname;\n  } else if (fname != NULL) {\n    match->cp_fname = vim_strsave(fname);\n    flags |= CP_FREE_FNAME;\n  } else {\n    match->cp_fname = NULL;\n  }\n  match->cp_flags = flags;\n\n  if (cptext != NULL) {\n    int i;\n\n    for (i = 0; i < CPT_COUNT; i++) {\n      if (cptext[i] == NULL) {\n        continue;\n      }\n      if (*cptext[i] != NUL) {\n        match->cp_text[i] = (cptext_allocated\n                             ? cptext[i]\n                             : (char_u *)xstrdup((char *)cptext[i]));\n      } else if (cptext_allocated) {\n        xfree(cptext[i]);\n      }\n    }\n  }\n\n  if (user_data != NULL) {\n    match->cp_user_data = *user_data;\n  }\n\n  /*\n   * Link the new match structure in the list of matches.\n   */\n  if (compl_first_match == NULL) {\n    match->cp_next = match->cp_prev = NULL;\n  } else if (dir == FORWARD) {\n    match->cp_next = compl_curr_match->cp_next;\n    match->cp_prev = compl_curr_match;\n  } else {    // BACKWARD\n    match->cp_next = compl_curr_match;\n    match->cp_prev = compl_curr_match->cp_prev;\n  }\n  if (match->cp_next) {\n    match->cp_next->cp_prev = match;\n  }\n  if (match->cp_prev) {\n    match->cp_prev->cp_next = match;\n  } else {        // if there's nothing before, it is the first match\n    compl_first_match = match;\n  }\n  compl_curr_match = match;\n\n  /*\n   * Find the longest common string if still doing that.\n   */\n  if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0) {\n    ins_compl_longest_match(match);\n  }\n\n  return OK;\n}\n\n/// Check that \"str[len]\" matches with \"match->cp_str\", considering\n/// \"match->cp_flags\".\n///\n/// @param  match  completion match\n/// @param  str    character string to check\n/// @param  len    length of \"str\"\nstatic bool ins_compl_equal(compl_T *match, char_u *str, size_t len)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (match->cp_flags & CP_EQUAL) {\n    return true;\n  }\n  if (match->cp_flags & CP_ICASE) {\n    return STRNICMP(match->cp_str, str, len) == 0;\n  }\n  return STRNCMP(match->cp_str, str, len) == 0;\n}\n\n/*\n * Reduce the longest common string for match \"match\".\n */\nstatic void ins_compl_longest_match(compl_T *match)\n{\n  char_u *p, *s;\n  int c1, c2;\n  int had_match;\n\n  if (compl_leader == NULL) {\n    // First match, use it as a whole.\n    compl_leader = vim_strsave(match->cp_str);\n    had_match = (curwin->w_cursor.col > compl_col);\n    ins_compl_delete();\n    ins_bytes(compl_leader + ins_compl_len());\n    ins_redraw(FALSE);\n\n    /* When the match isn't there (to avoid matching itself) remove it\n     * again after redrawing. */\n    if (!had_match) {\n      ins_compl_delete();\n    }\n    compl_used_match = false;\n  } else {\n    // Reduce the text if this match differs from compl_leader.\n    p = compl_leader;\n    s = match->cp_str;\n    while (*p != NUL) {\n      c1 = utf_ptr2char(p);\n      c2 = utf_ptr2char(s);\n\n      if ((match->cp_flags & CP_ICASE)\n          ? (mb_tolower(c1) != mb_tolower(c2))\n          : (c1 != c2)) {\n        break;\n      }\n      MB_PTR_ADV(p);\n      MB_PTR_ADV(s);\n    }\n\n    if (*p != NUL) {\n      // Leader was shortened, need to change the inserted text.\n      *p = NUL;\n      had_match = (curwin->w_cursor.col > compl_col);\n      ins_compl_delete();\n      ins_bytes(compl_leader + ins_compl_len());\n      ins_redraw(FALSE);\n\n      /* When the match isn't there (to avoid matching itself) remove it\n       * again after redrawing. */\n      if (!had_match) {\n        ins_compl_delete();\n      }\n    }\n\n    compl_used_match = false;\n  }\n}\n\n/*\n * Add an array of matches to the list of matches.\n * Frees matches[].\n */\nstatic void ins_compl_add_matches(int num_matches, char_u **matches, int icase)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int add_r = OK;\n  Direction dir = compl_direction;\n\n  for (int i = 0; i < num_matches && add_r != FAIL; i++) {\n    if ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, false, NULL, dir,\n                               CP_FAST | (icase ? CP_ICASE : 0),\n                               false)) == OK) {\n      // If dir was BACKWARD then honor it just once.\n      dir = FORWARD;\n    }\n  }\n  FreeWild(num_matches, matches);\n}\n\n/* Make the completion list cyclic.\n * Return the number of matches (excluding the original).\n */\nstatic int ins_compl_make_cyclic(void)\n{\n  compl_T *match;\n  int count = 0;\n\n  if (compl_first_match != NULL) {\n    /*\n     * Find the end of the list.\n     */\n    match = compl_first_match;\n    // there's always an entry for the compl_orig_text, it doesn't count.\n    while (match->cp_next != NULL && match->cp_next != compl_first_match) {\n      match = match->cp_next;\n      ++count;\n    }\n    match->cp_next = compl_first_match;\n    compl_first_match->cp_prev = match;\n  }\n  return count;\n}\n\n// Set variables that store noselect and noinsert behavior from the\n// 'completeopt' value.\nvoid completeopt_was_set(void)\n{\n  compl_no_insert = false;\n  compl_no_select = false;\n  if (strstr((char *)p_cot, \"noselect\") != NULL) {\n    compl_no_select = true;\n  }\n  if (strstr((char *)p_cot, \"noinsert\") != NULL) {\n    compl_no_insert = true;\n  }\n}\n\n\n/*\n * Start completion for the complete() function.\n * \"startcol\" is where the matched text starts (1 is first column).\n * \"list\" is the list of matches.\n */\nvoid set_completion(colnr_T startcol, list_T *list)\n{\n  int flags = CP_ORIGINAL_TEXT;\n\n  // If already doing completions stop it.\n  if (ctrl_x_mode != CTRL_X_NORMAL) {\n    ins_compl_prep(' ');\n  }\n  ins_compl_clear();\n  ins_compl_free();\n\n  compl_direction = FORWARD;\n  if (startcol > curwin->w_cursor.col) {\n    startcol = curwin->w_cursor.col;\n  }\n  compl_col = startcol;\n  compl_length = (int)curwin->w_cursor.col - (int)startcol;\n  // compl_pattern doesn't need to be set\n  compl_orig_text = vim_strnsave(get_cursor_line_ptr() + compl_col,\n                                 compl_length);\n  if (p_ic) {\n    flags |= CP_ICASE;\n  }\n  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,\n                    flags | CP_FAST, false) != OK) {\n    return;\n  }\n\n  ctrl_x_mode = CTRL_X_EVAL;\n\n  ins_compl_add_list(list);\n  compl_matches = ins_compl_make_cyclic();\n  compl_started = true;\n  compl_used_match = true;\n  compl_cont_status = 0;\n  int save_w_wrow = curwin->w_wrow;\n  int save_w_leftcol = curwin->w_leftcol;\n\n  compl_curr_match = compl_first_match;\n  if (compl_no_insert || compl_no_select) {\n    ins_complete(K_DOWN, false);\n    if (compl_no_select) {\n      ins_complete(K_UP, false);\n    }\n  } else {\n    ins_complete(Ctrl_N, false);\n  }\n  compl_enter_selects = compl_no_insert;\n\n  // Lazily show the popup menu, unless we got interrupted.\n  if (!compl_interrupted) {\n    show_pum(save_w_wrow, save_w_leftcol);\n  }\n\n  ui_flush();\n}\n\n\n/* \"compl_match_array\" points the currently displayed list of entries in the\n * popup menu.  It is NULL when there is no popup menu. */\nstatic pumitem_T *compl_match_array = NULL;\nstatic int compl_match_arraysize;\n\n\n/*\n * Remove any popup menu.\n */\nstatic void ins_compl_del_pum(void)\n{\n  if (compl_match_array != NULL) {\n    pum_undisplay(false);\n    XFREE_CLEAR(compl_match_array);\n  }\n}\n\n/// Check if the popup menu should be displayed.\nstatic bool pum_wanted(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // \"completeopt\" must contain \"menu\" or \"menuone\"\n  return vim_strchr(p_cot, 'm') != NULL;\n}\n\n/// Check that there are two or more matches to be shown in the popup menu.\n/// One if \"completopt\" contains \"menuone\".\nstatic bool pum_enough_matches(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Don't display the popup menu if there are no matches or there is only\n  // one (ignoring the original text).\n  compl_T *comp = compl_first_match;\n  int i = 0;\n  do {\n    if (comp == NULL\n        || ((comp->cp_flags & CP_ORIGINAL_TEXT) == 0 && ++i == 2)) {\n      break;\n    }\n    comp = comp->cp_next;\n  } while (comp != compl_first_match);\n\n  if (strstr((char *)p_cot, \"menuone\") != NULL) {\n    return i >= 1;\n  }\n  return i >= 2;\n}\n\nstatic void trigger_complete_changed_event(int cur)\n{\n  static bool recursive = false;\n\n  if (recursive) {\n    return;\n  }\n\n  dict_T *v_event = get_vim_var_dict(VV_EVENT);\n  if (cur < 0) {\n    tv_dict_add_dict(v_event, S_LEN(\"completed_item\"), tv_dict_alloc());\n  } else {\n    dict_T *item = ins_compl_dict_alloc(compl_curr_match);\n    tv_dict_add_dict(v_event, S_LEN(\"completed_item\"), item);\n  }\n  pum_set_event_info(v_event);\n  tv_dict_set_keys_readonly(v_event);\n\n  recursive = true;\n  textlock++;\n  apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, false, curbuf);\n  textlock--;\n  recursive = false;\n\n  tv_dict_clear(v_event);\n}\n\n/// Show the popup menu for the list of matches.\n/// Also adjusts \"compl_shown_match\" to an entry that is actually displayed.\nvoid ins_compl_show_pum(void)\n{\n  compl_T *compl;\n  compl_T *shown_compl = NULL;\n  bool did_find_shown_match = false;\n  bool shown_match_ok = false;\n  int i;\n  int cur = -1;\n  colnr_T col;\n  int lead_len = 0;\n  bool array_changed = false;\n\n  if (!pum_wanted() || !pum_enough_matches()) {\n    return;\n  }\n\n  // Dirty hard-coded hack: remove any matchparen highlighting.\n  do_cmdline_cmd(\"if exists('g:loaded_matchparen')|3match none|endif\");\n\n  // Update the screen before drawing the popup menu over it.\n  update_screen(0);\n\n  if (compl_match_array == NULL) {\n    array_changed = true;\n    // Need to build the popup menu list.\n    compl_match_arraysize = 0;\n    compl = compl_first_match;\n    //\n    // If it's user complete function and refresh_always,\n    // do not use \"compl_leader\" as prefix filter.\n    //\n    if (ins_compl_need_restart()) {\n      XFREE_CLEAR(compl_leader);\n    }\n    if (compl_leader != NULL) {\n      lead_len = (int)STRLEN(compl_leader);\n    }\n    do {\n      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0\n          && (compl_leader == NULL\n              || ins_compl_equal(compl, compl_leader, lead_len))) {\n        compl_match_arraysize++;\n      }\n      compl = compl->cp_next;\n    } while (compl != NULL && compl != compl_first_match);\n    if (compl_match_arraysize == 0) {\n      return;\n    }\n\n    assert(compl_match_arraysize >= 0);\n    compl_match_array = xcalloc(compl_match_arraysize, sizeof(pumitem_T));\n    /* If the current match is the original text don't find the first\n     * match after it, don't highlight anything. */\n    if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) {\n      shown_match_ok = true;\n    }\n\n    i = 0;\n    compl = compl_first_match;\n    do {\n      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0\n          && (compl_leader == NULL\n              || ins_compl_equal(compl, compl_leader, lead_len))) {\n        if (!shown_match_ok) {\n          if (compl == compl_shown_match || did_find_shown_match) {\n            /* This item is the shown match or this is the\n             * first displayed item after the shown match. */\n            compl_shown_match = compl;\n            did_find_shown_match = true;\n            shown_match_ok = true;\n          } else {\n            // Remember this displayed match for when the\n            // shown match is just below it.\n            shown_compl = compl;\n          }\n          cur = i;\n        }\n\n        if (compl->cp_text[CPT_ABBR] != NULL) {\n          compl_match_array[i].pum_text =\n            compl->cp_text[CPT_ABBR];\n        } else {\n          compl_match_array[i].pum_text = compl->cp_str;\n        }\n        compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];\n        compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];\n        if (compl->cp_text[CPT_MENU] != NULL) {\n          compl_match_array[i++].pum_extra =\n            compl->cp_text[CPT_MENU];\n        } else {\n          compl_match_array[i++].pum_extra = compl->cp_fname;\n        }\n      }\n\n      if (compl == compl_shown_match) {\n        did_find_shown_match = true;\n\n        /* When the original text is the shown match don't set\n         * compl_shown_match. */\n        if (compl->cp_flags & CP_ORIGINAL_TEXT) {\n          shown_match_ok = true;\n        }\n\n        if (!shown_match_ok && shown_compl != NULL) {\n          /* The shown match isn't displayed, set it to the\n           * previously displayed match. */\n          compl_shown_match = shown_compl;\n          shown_match_ok = true;\n        }\n      }\n      compl = compl->cp_next;\n    } while (compl != NULL && compl != compl_first_match);\n\n    if (!shown_match_ok) {        // no displayed match at all\n      cur = -1;\n    }\n  } else {\n    // popup menu already exists, only need to find the current item.\n    for (i = 0; i < compl_match_arraysize; i++) {\n      if (compl_match_array[i].pum_text == compl_shown_match->cp_str\n          || compl_match_array[i].pum_text\n          == compl_shown_match->cp_text[CPT_ABBR]) {\n        cur = i;\n        break;\n      }\n    }\n  }\n\n  // In Replace mode when a $ is displayed at the end of the line only\n  // part of the screen would be updated.  We do need to redraw here.\n  dollar_vcol = -1;\n\n  // Compute the screen column of the start of the completed text.\n  // Use the cursor to get all wrapping and other settings right.\n  col = curwin->w_cursor.col;\n  curwin->w_cursor.col = compl_col;\n  pum_selected_item = cur;\n  pum_display(compl_match_array, compl_match_arraysize, cur, array_changed, 0);\n  curwin->w_cursor.col = col;\n\n  if (has_event(EVENT_COMPLETECHANGED)) {\n    trigger_complete_changed_event(cur);\n  }\n}\n\n#define DICT_FIRST      (1)     // use just first element in \"dict\"\n#define DICT_EXACT      (2)     // \"dict\" is the exact name of a file\n\n/// Add any identifiers that match the given pattern in the list of dictionary\n/// files \"dict_start\" to the list of completions.\n///\n/// @param flags      DICT_FIRST and/or DICT_EXACT\n/// @param thesaurus  Thesaurus completion\nstatic void ins_compl_dictionaries(char_u *dict_start, char_u *pat, int flags, int thesaurus)\n{\n  char_u *dict = dict_start;\n  char_u *ptr;\n  char_u *buf;\n  regmatch_T regmatch;\n  char_u **files;\n  int count;\n  int save_p_scs;\n  Direction dir = compl_direction;\n\n  if (*dict == NUL) {\n    /* When 'dictionary' is empty and spell checking is enabled use\n     * \"spell\". */\n    if (!thesaurus && curwin->w_p_spell) {\n      dict = (char_u *)\"spell\";\n    } else {\n      return;\n    }\n  }\n\n  buf = xmalloc(LSIZE);\n  regmatch.regprog = NULL;      // so that we can goto theend\n\n  // If 'infercase' is set, don't use 'smartcase' here\n  save_p_scs = p_scs;\n  if (curbuf->b_p_inf) {\n    p_scs = FALSE;\n  }\n\n  /* When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern\n   * to only match at the start of a line.  Otherwise just match the\n   * pattern. Also need to double backslashes. */\n  if (CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)) {\n    char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)\"\\\\\");\n\n    size_t len = STRLEN(pat_esc) + 10;\n    ptr = xmalloc(len);\n    vim_snprintf((char *)ptr, len, \"^\\\\s*\\\\zs\\\\V%s\", pat_esc);\n    regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);\n    xfree(pat_esc);\n    xfree(ptr);\n  } else {\n    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);\n    if (regmatch.regprog == NULL) {\n      goto theend;\n    }\n  }\n\n  // ignore case depends on 'ignorecase', 'smartcase' and \"pat\"\n  regmatch.rm_ic = ignorecase(pat);\n  while (*dict != NUL && !got_int && !compl_interrupted) {\n    // copy one dictionary file name into buf\n    if (flags == DICT_EXACT) {\n      count = 1;\n      files = &dict;\n    } else {\n      /* Expand wildcards in the dictionary name, but do not allow\n       * backticks (for security, the 'dict' option may have been set in\n       * a modeline). */\n      copy_option_part(&dict, buf, LSIZE, \",\");\n      if (!thesaurus && STRCMP(buf, \"spell\") == 0) {\n        count = -1;\n      } else if (vim_strchr(buf, '`') != NULL\n                 || expand_wildcards(1, &buf, &count, &files,\n                                     EW_FILE|EW_SILENT) != OK) {\n        count = 0;\n      }\n    }\n\n    if (count == -1) {\n      /* Complete from active spelling.  Skip \"\\<\" in the pattern, we\n       * don't use it as a RE. */\n      if (pat[0] == '\\\\' && pat[1] == '<') {\n        ptr = pat + 2;\n      } else {\n        ptr = pat;\n      }\n      spell_dump_compl(ptr, regmatch.rm_ic, &dir, 0);\n    } else if (count > 0) {  // avoid warning for using \"files\" uninit\n      ins_compl_files(count, files, thesaurus, flags,\n                      &regmatch, buf, &dir);\n      if (flags != DICT_EXACT) {\n        FreeWild(count, files);\n      }\n    }\n    if (flags != 0) {\n      break;\n    }\n  }\n\ntheend:\n  p_scs = save_p_scs;\n  vim_regfree(regmatch.regprog);\n  xfree(buf);\n}\n\nstatic void ins_compl_files(int count, char_u **files, int thesaurus, int flags,\n                            regmatch_T *regmatch, char_u *buf, Direction *dir)\n  FUNC_ATTR_NONNULL_ARG(2, 7)\n{\n  char_u *ptr;\n  int i;\n  FILE *fp;\n  int add_r;\n\n  for (i = 0; i < count && !got_int && !compl_interrupted; i++) {\n    fp = os_fopen((char *)files[i], \"r\");  // open dictionary file\n    if (flags != DICT_EXACT) {\n      msg_hist_off = true;  // reset in msg_trunc_attr()\n      vim_snprintf((char *)IObuff, IOSIZE,\n                   _(\"Scanning dictionary: %s\"), (char *)files[i]);\n      (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));\n    }\n\n    if (fp == NULL) {\n      continue;\n    }\n    /*\n     * Read dictionary file line by line.\n     * Check each line for a match.\n     */\n    while (!got_int && !compl_interrupted\n           && !vim_fgets(buf, LSIZE, fp)) {\n      ptr = buf;\n      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf))) {\n        ptr = regmatch->startp[0];\n        if (CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)) {\n          ptr = find_line_end(ptr);\n        } else {\n          ptr = find_word_end(ptr);\n        }\n        add_r = ins_compl_add_infercase(regmatch->startp[0],\n                                        (int)(ptr - regmatch->startp[0]),\n                                        p_ic, files[i], *dir, false);\n        if (thesaurus) {\n          char_u *wstart;\n\n          /*\n           * Add the other matches on the line\n           */\n          ptr = buf;\n          while (!got_int) {\n            /* Find start of the next word.  Skip white\n             * space and punctuation. */\n            ptr = find_word_start(ptr);\n            if (*ptr == NUL || *ptr == NL) {\n              break;\n            }\n            wstart = ptr;\n\n            // Find end of the word.\n            // Japanese words may have characters in\n            // different classes, only separate words\n            // with single-byte non-word characters.\n            while (*ptr != NUL) {\n              const int l = utfc_ptr2len(ptr);\n\n              if (l < 2 && !vim_iswordc(*ptr)) {\n                break;\n              }\n              ptr += l;\n            }\n\n            // Add the word. Skip the regexp match.\n            if (wstart != regmatch->startp[0]) {\n              add_r = ins_compl_add_infercase(wstart, (int)(ptr - wstart),\n                                              p_ic, files[i], *dir, false);\n            }\n          }\n        }\n        if (add_r == OK) {\n          // if dir was BACKWARD then honor it just once\n          *dir = FORWARD;\n        } else if (add_r == FAIL) {\n          break;\n        }\n        // avoid expensive call to vim_regexec() when at end\n        // of line\n        if (*ptr == '\\n' || got_int) {\n          break;\n        }\n      }\n      line_breakcheck();\n      ins_compl_check_keys(50, false);\n    }\n    fclose(fp);\n  }\n}\n\n/*\n * Find the start of the next word.\n * Returns a pointer to the first char of the word.  Also stops at a NUL.\n */\nchar_u *find_word_start(char_u *ptr)\n{\n  while (*ptr != NUL && *ptr != '\\n' && mb_get_class(ptr) <= 1) {\n    ptr += utfc_ptr2len(ptr);\n  }\n  return ptr;\n}\n\n/*\n * Find the end of the word.  Assumes it starts inside a word.\n * Returns a pointer to just after the word.\n */\nchar_u *find_word_end(char_u *ptr)\n{\n  const int start_class = mb_get_class(ptr);\n  if (start_class > 1) {\n    while (*ptr != NUL) {\n      ptr += utfc_ptr2len(ptr);\n      if (mb_get_class(ptr) != start_class) {\n        break;\n      }\n    }\n  }\n  return ptr;\n}\n\n/*\n * Find the end of the line, omitting CR and NL at the end.\n * Returns a pointer to just after the line.\n */\nstatic char_u *find_line_end(char_u *ptr)\n{\n  char_u *s;\n\n  s = ptr + STRLEN(ptr);\n  while (s > ptr && (s[-1] == CAR || s[-1] == NL)) {\n    --s;\n  }\n  return s;\n}\n\n/*\n * Free the list of completions\n */\nstatic void ins_compl_free(void)\n{\n  compl_T *match;\n\n  XFREE_CLEAR(compl_pattern);\n  XFREE_CLEAR(compl_leader);\n\n  if (compl_first_match == NULL) {\n    return;\n  }\n\n  ins_compl_del_pum();\n  pum_clear();\n\n  compl_curr_match = compl_first_match;\n  do {\n    match = compl_curr_match;\n    compl_curr_match = compl_curr_match->cp_next;\n    xfree(match->cp_str);\n    // several entries may use the same fname, free it just once.\n    if (match->cp_flags & CP_FREE_FNAME) {\n      xfree(match->cp_fname);\n    }\n    for (int i = 0; i < CPT_COUNT; i++) {\n      xfree(match->cp_text[i]);\n    }\n    tv_clear(&match->cp_user_data);\n    xfree(match);\n  } while (compl_curr_match != NULL && compl_curr_match != compl_first_match);\n  compl_first_match = compl_curr_match = NULL;\n  compl_shown_match = NULL;\n  compl_old_match = NULL;\n}\n\nstatic void ins_compl_clear(void)\n{\n  compl_cont_status = 0;\n  compl_started = false;\n  compl_matches = 0;\n  XFREE_CLEAR(compl_pattern);\n  XFREE_CLEAR(compl_leader);\n  edit_submode_extra = NULL;\n  XFREE_CLEAR(compl_orig_text);\n  compl_enter_selects = false;\n  // clear v:completed_item\n  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));\n}\n\n/// Check that Insert completion is active.\nbool ins_compl_active(void)\n  FUNC_ATTR_PURE\n{\n  return compl_started;\n}\n\nstatic void ins_compl_update_sequence_numbers(void)\n{\n  int number = 0;\n  compl_T *match;\n\n  if (compl_direction == FORWARD) {\n    // search backwards for the first valid (!= -1) number.\n    // This should normally succeed already at the first loop\n    // cycle, so it's fast!\n    for (match = compl_curr_match->cp_prev;\n         match != NULL && match != compl_first_match;\n         match = match->cp_prev) {\n      if (match->cp_number != -1) {\n        number = match->cp_number;\n        break;\n      }\n    }\n    if (match != NULL) {\n      // go up and assign all numbers which are not assigned yet\n      for (match = match->cp_next;\n           match != NULL && match->cp_number == -1;\n           match = match->cp_next) {\n        match->cp_number = ++number;\n      }\n    }\n  } else {  // BACKWARD\n    assert(compl_direction == BACKWARD);\n    // search forwards (upwards) for the first valid (!= -1)\n    // number.  This should normally succeed already at the\n    // first loop cycle, so it's fast!\n    for (match = compl_curr_match->cp_next;\n         match != NULL && match != compl_first_match;\n         match = match->cp_next) {\n      if (match->cp_number != -1) {\n        number = match->cp_number;\n        break;\n      }\n    }\n    if (match != NULL) {\n      // go down and assign all numbers which are not\n      // assigned yet\n      for (match = match->cp_prev;\n           match && match->cp_number == -1;\n           match = match->cp_prev) {\n        match->cp_number = ++number;\n      }\n    }\n  }\n}\n\n// Get complete information\nvoid get_complete_info(list_T *what_list, dict_T *retdict)\n{\n#define CI_WHAT_MODE            0x01\n#define CI_WHAT_PUM_VISIBLE     0x02\n#define CI_WHAT_ITEMS           0x04\n#define CI_WHAT_SELECTED        0x08\n#define CI_WHAT_INSERTED        0x10\n#define CI_WHAT_ALL             0xff\n  int what_flag;\n\n  if (what_list == NULL) {\n    what_flag = CI_WHAT_ALL;\n  } else {\n    what_flag = 0;\n    for (listitem_T *item = tv_list_first(what_list)\n         ; item != NULL\n         ; item = TV_LIST_ITEM_NEXT(what_list, item)) {\n      const char *what = tv_get_string(TV_LIST_ITEM_TV(item));\n\n      if (STRCMP(what, \"mode\") == 0) {\n        what_flag |= CI_WHAT_MODE;\n      } else if (STRCMP(what, \"pum_visible\") == 0) {\n        what_flag |= CI_WHAT_PUM_VISIBLE;\n      } else if (STRCMP(what, \"items\") == 0) {\n        what_flag |= CI_WHAT_ITEMS;\n      } else if (STRCMP(what, \"selected\") == 0) {\n        what_flag |= CI_WHAT_SELECTED;\n      } else if (STRCMP(what, \"inserted\") == 0) {\n        what_flag |= CI_WHAT_INSERTED;\n      }\n    }\n  }\n\n  int ret = OK;\n  if (what_flag & CI_WHAT_MODE) {\n    ret = tv_dict_add_str(retdict, S_LEN(\"mode\"),\n                          (char *)ins_compl_mode());\n  }\n\n  if (ret == OK && (what_flag & CI_WHAT_PUM_VISIBLE)) {\n    ret = tv_dict_add_nr(retdict, S_LEN(\"pum_visible\"), pum_visible());\n  }\n\n  if (ret == OK && (what_flag & CI_WHAT_ITEMS)) {\n    list_T *li = tv_list_alloc(ins_compl_len());\n\n    ret = tv_dict_add_list(retdict, S_LEN(\"items\"), li);\n    if (ret == OK && compl_first_match != NULL) {\n      compl_T *match = compl_first_match;\n      do {\n        if (!(match->cp_flags & CP_ORIGINAL_TEXT)) {\n          dict_T *di = tv_dict_alloc();\n\n          tv_list_append_dict(li, di);\n          tv_dict_add_str(di, S_LEN(\"word\"),\n                          (char *)EMPTY_IF_NULL(match->cp_str));\n          tv_dict_add_str(di, S_LEN(\"abbr\"),\n                          (char *)EMPTY_IF_NULL(match->cp_text[CPT_ABBR]));\n          tv_dict_add_str(di, S_LEN(\"menu\"),\n                          (char *)EMPTY_IF_NULL(match->cp_text[CPT_MENU]));\n          tv_dict_add_str(di, S_LEN(\"kind\"),\n                          (char *)EMPTY_IF_NULL(match->cp_text[CPT_KIND]));\n          tv_dict_add_str(di, S_LEN(\"info\"),\n                          (char *)EMPTY_IF_NULL(match->cp_text[CPT_INFO]));\n          if (match->cp_user_data.v_type == VAR_UNKNOWN) {\n            tv_dict_add_str(di, S_LEN(\"user_data\"), \"\");\n          } else {\n            tv_dict_add_tv(di, S_LEN(\"user_data\"), &match->cp_user_data);\n          }\n        }\n        match = match->cp_next;\n      } while (match != NULL && match != compl_first_match);\n    }\n  }\n\n  if (ret == OK && (what_flag & CI_WHAT_SELECTED)) {\n    if (compl_curr_match != NULL && compl_curr_match->cp_number == -1) {\n      ins_compl_update_sequence_numbers();\n    }\n    ret = tv_dict_add_nr(retdict, S_LEN(\"selected\"),\n                         (compl_curr_match != NULL)\n                         ? compl_curr_match->cp_number - 1 : -1);\n  }\n\n  (void)ret;\n  // TODO(vim):\n  // if (ret == OK && (what_flag & CI_WHAT_INSERTED))\n}\n\n// Return Insert completion mode name string\nstatic char_u * ins_compl_mode(void)\n{\n  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET || compl_started) {\n    return (char_u *)ctrl_x_mode_names[ctrl_x_mode & ~CTRL_X_WANT_IDENT];\n  }\n  return (char_u *)\"\";\n}\n\n\n/*\n * Delete one character before the cursor and show the subset of the matches\n * that match the word that is now before the cursor.\n * Returns the character to be used, NUL if the work is done and another char\n * to be got from the user.\n */\nstatic int ins_compl_bs(void)\n{\n  char_u *line;\n  char_u *p;\n\n  line = get_cursor_line_ptr();\n  p = line + curwin->w_cursor.col;\n  MB_PTR_BACK(line, p);\n\n  // Stop completion when the whole word was deleted.  For Omni completion\n  // allow the word to be deleted, we won't match everything.\n  // Respect the 'backspace' option.\n  if ((int)(p - line) - (int)compl_col < 0\n      || ((int)(p - line) - (int)compl_col == 0 && ctrl_x_mode != CTRL_X_OMNI)\n      || ctrl_x_mode == CTRL_X_EVAL\n      || (!can_bs(BS_START) && (int)(p - line) - (int)compl_col\n          - compl_length < 0)) {\n    return K_BS;\n  }\n\n  /* Deleted more than what was used to find matches or didn't finish\n   * finding all matches: need to look for matches all over again. */\n  if (curwin->w_cursor.col <= compl_col + compl_length\n      || ins_compl_need_restart()) {\n    ins_compl_restart();\n  }\n\n  xfree(compl_leader);\n  compl_leader = vim_strnsave(line + compl_col, (int)(p - line) - compl_col);\n  ins_compl_new_leader();\n  if (compl_shown_match != NULL) {\n    // Make sure current match is not a hidden item.\n    compl_curr_match = compl_shown_match;\n  }\n\n  return NUL;\n}\n\n/// Check that we need to find matches again, ins_compl_restart() is to\n/// be called.\nstatic bool ins_compl_need_restart(void)\n  FUNC_ATTR_PURE\n{\n  // Return true if we didn't complete finding matches or when the\n  // \"completefunc\" returned \"always\" in the \"refresh\" dictionary item.\n  return compl_was_interrupted\n         || ((ctrl_x_mode == CTRL_X_FUNCTION || ctrl_x_mode == CTRL_X_OMNI)\n             && compl_opt_refresh_always);\n}\n\n/*\n * Called after changing \"compl_leader\".\n * Show the popup menu with a different set of matches.\n * May also search for matches again if the previous search was interrupted.\n */\nstatic void ins_compl_new_leader(void)\n{\n  ins_compl_del_pum();\n  ins_compl_delete();\n  ins_bytes(compl_leader + ins_compl_len());\n  compl_used_match = false;\n\n  if (compl_started) {\n    ins_compl_set_original_text(compl_leader);\n  } else {\n    spell_bad_len = 0;  // need to redetect bad word\n    // Matches were cleared, need to search for them now.\n    // Set \"compl_restarting\" to avoid that the first match is inserted.\n    compl_restarting = true;\n    if (ins_complete(Ctrl_N, true) == FAIL) {\n      compl_cont_status = 0;\n    }\n    compl_restarting = false;\n  }\n\n  compl_enter_selects = !compl_used_match;\n\n  // Show the popup menu with a different set of matches.\n  ins_compl_show_pum();\n\n  /* Don't let Enter select the original text when there is no popup menu.\n   * Don't let Enter select when use user function and refresh_always is set */\n  if (compl_match_array == NULL || ins_compl_need_restart()) {\n    compl_enter_selects = FALSE;\n  }\n}\n\n/*\n * Return the length of the completion, from the completion start column to\n * the cursor column.  Making sure it never goes below zero.\n */\nstatic int ins_compl_len(void)\n{\n  int off = (int)curwin->w_cursor.col - (int)compl_col;\n\n  if (off < 0) {\n    return 0;\n  }\n  return off;\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\nstatic void ins_compl_addleader(int c)\n{\n  int cc;\n\n  if (stop_arrow() == FAIL) {\n    return;\n  }\n  if ((cc = utf_char2len(c)) > 1) {\n    char_u buf[MB_MAXBYTES + 1];\n\n    utf_char2bytes(c, buf);\n    buf[cc] = NUL;\n    ins_char_bytes(buf, cc);\n  } else {\n    ins_char(c);\n  }\n\n  // If we didn't complete finding matches we must search again.\n  if (ins_compl_need_restart()) {\n    ins_compl_restart();\n  }\n\n  xfree(compl_leader);\n  compl_leader = vim_strnsave(get_cursor_line_ptr() + compl_col,\n                              curwin->w_cursor.col - compl_col);\n  ins_compl_new_leader();\n}\n\n/*\n * Setup for finding completions again without leaving CTRL-X mode.  Used when\n * BS or a key was typed while still searching for matches.\n */\nstatic void ins_compl_restart(void)\n{\n  /* update screen before restart.\n   * so if complete is blocked,\n   * will stay to the last popup menu and reduce flicker */\n  update_screen(0);\n  ins_compl_free();\n  compl_started = false;\n  compl_matches = 0;\n  compl_cont_status = 0;\n  compl_cont_mode = 0;\n}\n\n/*\n * Set the first match, the original text.\n */\nstatic void ins_compl_set_original_text(char_u *str)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Replace the original text entry.\n  // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly be\n  // at the last item for backward completion\n  if (compl_first_match->cp_flags & CP_ORIGINAL_TEXT) {  // safety check\n    xfree(compl_first_match->cp_str);\n    compl_first_match->cp_str = vim_strsave(str);\n  } else if (compl_first_match->cp_prev != NULL\n             && (compl_first_match->cp_prev->cp_flags & CP_ORIGINAL_TEXT)) {\n    xfree(compl_first_match->cp_prev->cp_str);\n    compl_first_match->cp_prev->cp_str = vim_strsave(str);\n  }\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\nstatic void ins_compl_addfrommatch(void)\n{\n  char_u *p;\n  int len = (int)curwin->w_cursor.col - (int)compl_col;\n  int c;\n  compl_T *cp;\n  assert(compl_shown_match != NULL);\n  p = compl_shown_match->cp_str;\n  if ((int)STRLEN(p) <= len) {   // the match is too short\n    // When still at the original match use the first entry that matches\n    // the leader.\n    if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) {\n      p = NULL;\n      for (cp = compl_shown_match->cp_next; cp != NULL\n           && cp != compl_first_match; cp = cp->cp_next) {\n        if (compl_leader == NULL\n            || ins_compl_equal(cp, compl_leader,\n                               (int)STRLEN(compl_leader))) {\n          p = cp->cp_str;\n          break;\n        }\n      }\n      if (p == NULL || (int)STRLEN(p) <= len) {\n        return;\n      }\n    } else {\n      return;\n    }\n  }\n  p += len;\n  c = PTR2CHAR(p);\n  ins_compl_addleader(c);\n}\n\n/// Prepare for Insert mode completion, or stop it.\n/// Called just after typing a character in Insert mode.\n///\n/// @param  c  character that was typed\n///\n/// @return true when the character is not to be inserted;\nstatic bool ins_compl_prep(int c)\n{\n  char_u *ptr;\n  bool retval = false;\n  const int prev_mode = ctrl_x_mode;\n\n  /* Forget any previous 'special' messages if this is actually\n   * a ^X mode key - bar ^R, in which case we wait to see what it gives us.\n   */\n  if (c != Ctrl_R && vim_is_ctrl_x_key(c)) {\n    edit_submode_extra = NULL;\n  }\n\n  // Ignore end of Select mode mapping and mouse scroll buttons.\n  if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP\n      || c == K_MOUSELEFT || c == K_MOUSERIGHT || c == K_EVENT\n      || c == K_COMMAND) {\n    return retval;\n  }\n\n  if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X && c != Ctrl_X) {\n    if (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)\n        || !vim_is_ctrl_x_key(c)) {\n      // Not starting another completion mode.\n      ctrl_x_mode = CTRL_X_CMDLINE;\n\n      // CTRL-X CTRL-Z should stop completion without inserting anything\n      if (c == Ctrl_Z) {\n        retval = true;\n      }\n    } else {\n      ctrl_x_mode = CTRL_X_CMDLINE;\n\n      // Other CTRL-X keys first stop completion, then start another\n      // completion mode.\n      ins_compl_prep(' ');\n      ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n    }\n  }\n\n  // Set \"compl_get_longest\" when finding the first matches.\n  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET\n      || (ctrl_x_mode == CTRL_X_NORMAL && !compl_started)) {\n    compl_get_longest = (strstr((char *)p_cot, \"longest\") != NULL);\n    compl_used_match = true;\n  }\n\n  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET) {\n    /*\n     * We have just typed CTRL-X and aren't quite sure which CTRL-X mode\n     * it will be yet.  Now we decide.\n     */\n    switch (c) {\n    case Ctrl_E:\n    case Ctrl_Y:\n      ctrl_x_mode = CTRL_X_SCROLL;\n      if (!(State & REPLACE_FLAG)) {\n        edit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");\n      } else {\n        edit_submode = (char_u *)_(\" (replace) Scroll (^E/^Y)\");\n      }\n      edit_submode_pre = NULL;\n      showmode();\n      break;\n    case Ctrl_L:\n      ctrl_x_mode = CTRL_X_WHOLE_LINE;\n      break;\n    case Ctrl_F:\n      ctrl_x_mode = CTRL_X_FILES;\n      break;\n    case Ctrl_K:\n      ctrl_x_mode = CTRL_X_DICTIONARY;\n      break;\n    case Ctrl_R:\n      // Simply allow ^R to happen without affecting ^X mode\n      break;\n    case Ctrl_T:\n      ctrl_x_mode = CTRL_X_THESAURUS;\n      break;\n    case Ctrl_U:\n      ctrl_x_mode = CTRL_X_FUNCTION;\n      break;\n    case Ctrl_O:\n      ctrl_x_mode = CTRL_X_OMNI;\n      break;\n    case 's':\n    case Ctrl_S:\n      ctrl_x_mode = CTRL_X_SPELL;\n      emsg_off++;               // Avoid getting the E756 error twice.\n      spell_back_to_badword();\n      emsg_off--;\n      break;\n    case Ctrl_RSB:\n      ctrl_x_mode = CTRL_X_TAGS;\n      break;\n    case Ctrl_I:\n    case K_S_TAB:\n      ctrl_x_mode = CTRL_X_PATH_PATTERNS;\n      break;\n    case Ctrl_D:\n      ctrl_x_mode = CTRL_X_PATH_DEFINES;\n      break;\n    case Ctrl_V:\n    case Ctrl_Q:\n      ctrl_x_mode = CTRL_X_CMDLINE;\n      break;\n    case Ctrl_Z:\n      ctrl_x_mode = CTRL_X_NORMAL;\n      edit_submode = NULL;\n      showmode();\n      retval = true;\n      break;\n    case Ctrl_P:\n    case Ctrl_N:\n      /* ^X^P means LOCAL expansion if nothing interrupted (eg we\n       * just started ^X mode, or there were enough ^X's to cancel\n       * the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)\n       * do normal expansion when interrupting a different mode (say\n       * ^X^F^X^P or ^P^X^X^P, see below)\n       * nothing changes if interrupting mode 0, (eg, the flag\n       * doesn't change when going to ADDING mode  -- Acevedo */\n      if (!(compl_cont_status & CONT_INTRPT)) {\n        compl_cont_status |= CONT_LOCAL;\n      } else if (compl_cont_mode != 0) {\n        compl_cont_status &= ~CONT_LOCAL;\n      }\n      FALLTHROUGH;\n    default:\n      /* If we have typed at least 2 ^X's... for modes != 0, we set\n       * compl_cont_status = 0 (eg, as if we had just started ^X\n       * mode).\n       * For mode 0, we set \"compl_cont_mode\" to an impossible\n       * value, in both cases ^X^X can be used to restart the same\n       * mode (avoiding ADDING mode).\n       * Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start\n       * 'complete' and local ^P expansions respectively.\n       * In mode 0 an extra ^X is needed since ^X^P goes to ADDING\n       * mode  -- Acevedo */\n      if (c == Ctrl_X) {\n        if (compl_cont_mode != 0) {\n          compl_cont_status = 0;\n        } else {\n          compl_cont_mode = CTRL_X_NOT_DEFINED_YET;\n        }\n      }\n      ctrl_x_mode = CTRL_X_NORMAL;\n      edit_submode = NULL;\n      showmode();\n      break;\n    }\n  } else if (ctrl_x_mode != CTRL_X_NORMAL) {\n    // We're already in CTRL-X mode, do we stay in it?\n    if (!vim_is_ctrl_x_key(c)) {\n      if (ctrl_x_mode == CTRL_X_SCROLL) {\n        ctrl_x_mode = CTRL_X_NORMAL;\n      } else {\n        ctrl_x_mode = CTRL_X_FINISHED;\n      }\n      edit_submode = NULL;\n    }\n    showmode();\n  }\n\n  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {\n    /* Show error message from attempted keyword completion (probably\n     * 'Pattern not found') until another key is hit, then go back to\n     * showing what mode we are in. */\n    showmode();\n    if ((ctrl_x_mode == CTRL_X_NORMAL\n         && c != Ctrl_N\n         && c != Ctrl_P\n         && c != Ctrl_R\n         && !ins_compl_pum_key(c))\n        || ctrl_x_mode == CTRL_X_FINISHED) {\n      /* Get here when we have finished typing a sequence of ^N and\n       * ^P or other completion characters in CTRL-X mode.  Free up\n       * memory that was used, and make sure we can redo the insert. */\n      if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {\n        /*\n         * If any of the original typed text has been changed, eg when\n         * ignorecase is set, we must add back-spaces to the redo\n         * buffer.  We add as few as necessary to delete just the part\n         * of the original text that has changed.\n         * When using the longest match, edited the match or used\n         * CTRL-E then don't use the current match.\n         */\n        if (compl_curr_match != NULL && compl_used_match && c != Ctrl_E) {\n          ptr = compl_curr_match->cp_str;\n        } else {\n          ptr = NULL;\n        }\n        ins_compl_fixRedoBufForLeader(ptr);\n      }\n\n      bool want_cindent = (can_cindent && cindent_on());\n      // When completing whole lines: fix indent for 'cindent'.\n      // Otherwise, break line if it's too long.\n      if (compl_cont_mode == CTRL_X_WHOLE_LINE) {\n        // re-indent the current line\n        if (want_cindent) {\n          do_c_expr_indent();\n          want_cindent = false;                 // don't do it again\n        }\n      } else {\n        int prev_col = curwin->w_cursor.col;\n\n        // put the cursor on the last char, for 'tw' formatting\n        if (prev_col > 0) {\n          dec_cursor();\n        }\n\n        if (!arrow_used && !ins_need_undo && c != Ctrl_E) {\n          insertchar(NUL, 0, -1);\n        }\n\n        if (prev_col > 0\n            && get_cursor_line_ptr()[curwin->w_cursor.col] != NUL) {\n          inc_cursor();\n        }\n      }\n\n      // If the popup menu is displayed pressing CTRL-Y means accepting\n      // the selection without inserting anything.  When\n      // compl_enter_selects is set the Enter key does the same.\n      if ((c == Ctrl_Y || (compl_enter_selects\n                           && (c == CAR || c == K_KENTER || c == NL)))\n          && pum_visible()) {\n        retval = true;\n      }\n\n      // CTRL-E means completion is Ended, go back to the typed text.\n      // but only do this, if the Popup is still visible\n      if (c == Ctrl_E) {\n        ins_compl_delete();\n        if (compl_leader != NULL) {\n          ins_bytes(compl_leader + ins_compl_len());\n        } else if (compl_first_match != NULL) {\n          ins_bytes(compl_orig_text + ins_compl_len());\n        }\n        retval = true;\n      }\n\n      auto_format(false, true);\n\n      // Trigger the CompleteDonePre event to give scripts a chance to\n      // act upon the completion before clearing the info, and restore\n      // ctrl_x_mode, so that complete_info() can be used.\n      ctrl_x_mode = prev_mode;\n      ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n\n      ins_compl_free();\n      compl_started = false;\n      compl_matches = 0;\n      if (!shortmess(SHM_COMPLETIONMENU)) {\n        msg_clr_cmdline();                // necessary for \"noshowmode\"\n      }\n      ctrl_x_mode = CTRL_X_NORMAL;\n      compl_enter_selects = false;\n      if (edit_submode != NULL) {\n        edit_submode = NULL;\n        showmode();\n      }\n\n      // Avoid the popup menu remains displayed when leaving the\n      // command line window.\n      if (c == Ctrl_C && cmdwin_type != 0) {\n        update_screen(0);\n      }\n\n      /*\n       * Indent now if a key was typed that is in 'cinkeys'.\n       */\n      if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0))) {\n        do_c_expr_indent();\n      }\n      // Trigger the CompleteDone event to give scripts a chance to act\n      // upon the end of completion.\n      ins_apply_autocmds(EVENT_COMPLETEDONE);\n    }\n  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {\n    /* Trigger the CompleteDone event to give scripts a chance to act\n     * upon the (possibly failed) completion. */\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n  }\n\n  /* reset continue_* if we left expansion-mode, if we stay they'll be\n   * (re)set properly in ins_complete() */\n  if (!vim_is_ctrl_x_key(c)) {\n    compl_cont_status = 0;\n    compl_cont_mode = 0;\n  }\n\n  return retval;\n}\n\n/*\n * Fix the redo buffer for the completion leader replacing some of the typed\n * text.  This inserts backspaces and appends the changed text.\n * \"ptr\" is the known leader text or NUL.\n */\nstatic void ins_compl_fixRedoBufForLeader(char_u *ptr_arg)\n{\n  int len;\n  char_u *p;\n  char_u *ptr = ptr_arg;\n\n  if (ptr == NULL) {\n    if (compl_leader != NULL) {\n      ptr = compl_leader;\n    } else {\n      return;        // nothing to do\n    }\n  }\n  if (compl_orig_text != NULL) {\n    p = compl_orig_text;\n    for (len = 0; p[len] != NUL && p[len] == ptr[len]; len++) {}\n    if (len > 0) {\n      len -= utf_head_off(p, p + len);\n    }\n    for (p += len; *p != NUL; MB_PTR_ADV(p)) {\n      AppendCharToRedobuff(K_BS);\n    }\n  } else {\n    len = 0;\n  }\n  AppendToRedobuffLit(ptr + len, -1);\n}\n\n/*\n * Loops through the list of windows, loaded-buffers or non-loaded-buffers\n * (depending on flag) starting from buf and looking for a non-scanned\n * buffer (other than curbuf).  curbuf is special, if it is called with\n * buf=curbuf then it has to be the first call for a given flag/expansion.\n *\n * Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo\n */\nstatic buf_T *ins_compl_next_buf(buf_T *buf, int flag)\n{\n  static win_T *wp = NULL;\n\n  if (flag == 'w') {            // just windows\n    if (buf == curbuf || wp == NULL) {  // first call for this flag/expansion\n      wp = curwin;\n    }\n    assert(wp);\n    while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin\n           && wp->w_buffer->b_scanned) {\n      ;\n    }\n    buf = wp->w_buffer;\n  } else {\n    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'\n     * (unlisted buffers)\n     * When completing whole lines skip unloaded buffers. */\n    while ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf\n           && ((flag == 'U'\n                ? buf->b_p_bl\n                : (!buf->b_p_bl\n                   || (buf->b_ml.ml_mfp == NULL) != (flag == 'u')))\n               || buf->b_scanned)) {\n      ;\n    }\n  }\n  return buf;\n}\n\n\n/// Execute user defined complete function 'completefunc' or 'omnifunc', and\n/// get matches in \"matches\".\n///\n/// @param type  CTRL_X_OMNI or CTRL_X_FUNCTION\nstatic void expand_by_function(int type, char_u *base)\n{\n  list_T *matchlist = NULL;\n  dict_T *matchdict = NULL;\n  char_u *funcname;\n  pos_T pos;\n  win_T *curwin_save;\n  buf_T *curbuf_save;\n  typval_T rettv;\n  const int save_State = State;\n\n  assert(curbuf != NULL);\n  funcname = (type == CTRL_X_FUNCTION) ? curbuf->b_p_cfu : curbuf->b_p_ofu;\n  if (*funcname == NUL) {\n    return;\n  }\n\n  // Call 'completefunc' to obtain the list of matches.\n  typval_T args[3];\n  args[0].v_type = VAR_NUMBER;\n  args[1].v_type = VAR_STRING;\n  args[2].v_type = VAR_UNKNOWN;\n  args[0].vval.v_number = 0;\n  args[1].vval.v_string = base != NULL ? base : (char_u *)\"\";\n\n  pos = curwin->w_cursor;\n  curwin_save = curwin;\n  curbuf_save = curbuf;\n\n  // Call a function, which returns a list or dict.\n  if (call_vim_function(funcname, 2, args, &rettv) == OK) {\n    switch (rettv.v_type) {\n    case VAR_LIST:\n      matchlist = rettv.vval.v_list;\n      break;\n    case VAR_DICT:\n      matchdict = rettv.vval.v_dict;\n      break;\n    case VAR_SPECIAL:\n      FALLTHROUGH;\n    default:\n      // TODO(brammool): Give error message?\n      tv_clear(&rettv);\n      break;\n    }\n  }\n\n  if (curwin_save != curwin || curbuf_save != curbuf) {\n    EMSG(_(e_complwin));\n    goto theend;\n  }\n  curwin->w_cursor = pos;       // restore the cursor position\n  validate_cursor();\n  if (!equalpos(curwin->w_cursor, pos)) {\n    EMSG(_(e_compldel));\n    goto theend;\n  }\n\n  if (matchlist != NULL) {\n    ins_compl_add_list(matchlist);\n  } else if (matchdict != NULL) {\n    ins_compl_add_dict(matchdict);\n  }\n\ntheend:\n  // Restore State, it might have been changed.\n  State = save_State;\n\n  if (matchdict != NULL) {\n    tv_dict_unref(matchdict);\n  }\n  if (matchlist != NULL) {\n    tv_list_unref(matchlist);\n  }\n}\n\n/*\n * Add completions from a list.\n */\nstatic void ins_compl_add_list(list_T *const list)\n{\n  Direction dir = compl_direction;\n\n  // Go through the List with matches and add each of them.\n  TV_LIST_ITER(list, li, {\n    if (ins_compl_add_tv(TV_LIST_ITEM_TV(li), dir, true) == OK) {\n      // If dir was BACKWARD then honor it just once.\n      dir = FORWARD;\n    } else if (did_emsg) {\n      break;\n    }\n  });\n}\n\n/*\n * Add completions from a dict.\n */\nstatic void ins_compl_add_dict(dict_T *dict)\n{\n  dictitem_T *di_refresh;\n  dictitem_T *di_words;\n\n  // Check for optional \"refresh\" item.\n  compl_opt_refresh_always = false;\n  di_refresh = tv_dict_find(dict, S_LEN(\"refresh\"));\n  if (di_refresh != NULL && di_refresh->di_tv.v_type == VAR_STRING) {\n    const char *v = (const char *)di_refresh->di_tv.vval.v_string;\n\n    if (v != NULL && strcmp(v, \"always\") == 0) {\n      compl_opt_refresh_always = true;\n    }\n  }\n\n  // Add completions from a \"words\" list.\n  di_words = tv_dict_find(dict, S_LEN(\"words\"));\n  if (di_words != NULL && di_words->di_tv.v_type == VAR_LIST) {\n    ins_compl_add_list(di_words->di_tv.vval.v_list);\n  }\n}\n\n/// Add a match to the list of matches from VimL object\n///\n/// @param[in]  tv  Object to get matches from.\n/// @param[in]  dir  Completion direction.\n/// @param[in]  fast  use fast_breakcheck() instead of os_breakcheck().\n///\n/// @return NOTDONE if the given string is already in the list of completions,\n///         otherwise it is added to the list and  OK is returned. FAIL will be\n///         returned in case of error.\nint ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char *word;\n  bool dup = false;\n  bool empty = false;\n  int flags = fast ? CP_FAST : 0;\n  char *(cptext[CPT_COUNT]);\n  typval_T user_data;\n\n  user_data.v_type = VAR_UNKNOWN;\n  if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL) {\n    word = tv_dict_get_string(tv->vval.v_dict, \"word\", false);\n    cptext[CPT_ABBR] = tv_dict_get_string(tv->vval.v_dict, \"abbr\", true);\n    cptext[CPT_MENU] = tv_dict_get_string(tv->vval.v_dict, \"menu\", true);\n    cptext[CPT_KIND] = tv_dict_get_string(tv->vval.v_dict, \"kind\", true);\n    cptext[CPT_INFO] = tv_dict_get_string(tv->vval.v_dict, \"info\", true);\n    tv_dict_get_tv(tv->vval.v_dict, \"user_data\", &user_data);\n\n    if (tv_dict_get_number(tv->vval.v_dict, \"icase\")) {\n      flags |= CP_ICASE;\n    }\n    dup = (bool)tv_dict_get_number(tv->vval.v_dict, \"dup\");\n    empty = (bool)tv_dict_get_number(tv->vval.v_dict, \"empty\");\n    if (tv_dict_get_string(tv->vval.v_dict, \"equal\", false) != NULL\n        && tv_dict_get_number(tv->vval.v_dict, \"equal\")) {\n      flags |= CP_EQUAL;\n    }\n  } else {\n    word = tv_get_string_chk(tv);\n    memset(cptext, 0, sizeof(cptext));\n  }\n  if (word == NULL || (!empty && *word == NUL)) {\n    for (size_t i = 0; i < CPT_COUNT; i++) {\n      xfree(cptext[i]);\n    }\n    return FAIL;\n  }\n  return ins_compl_add((char_u *)word, -1, NULL,\n                       (char_u **)cptext, true, &user_data, dir, flags, dup);\n}\n\n// Get the next expansion(s), using \"compl_pattern\".\n// The search starts at position \"ini\" in curbuf and in the direction\n// compl_direction.\n// When \"compl_started\" is false start at that position, otherwise continue\n// where we stopped searching before.\n// This may return before finding all the matches.\n// Return the total number of matches or -1 if still unknown -- Acevedo\nstatic int ins_compl_get_exp(pos_T *ini)\n{\n  static pos_T first_match_pos;\n  static pos_T last_match_pos;\n  static char_u *e_cpt = (char_u *)\"\";   // curr. entry in 'complete'\n  static bool found_all = false;         // Found all matches of a\n                                         // certain type.\n  static buf_T *ins_buf = NULL;          // buffer being scanned\n\n  pos_T *pos;\n  char_u **matches;\n  int save_p_scs;\n  bool save_p_ws;\n  int save_p_ic;\n  int i;\n  int num_matches;\n  int len;\n  int found_new_match;\n  int type = ctrl_x_mode;\n  char_u *ptr;\n  char_u *dict = NULL;\n  int dict_f = 0;\n  bool set_match_pos;\n  pos_T prev_pos = { 0, 0, 0 };\n  int l_ctrl_x_mode = ctrl_x_mode;\n\n  assert(curbuf != NULL);\n\n  if (!compl_started) {\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_scanned = false;\n    }\n    found_all = false;\n    ins_buf = curbuf;\n    e_cpt = (compl_cont_status & CONT_LOCAL)\n            ? (char_u *)\".\" : curbuf->b_p_cpt;\n    last_match_pos = first_match_pos = *ini;\n  } else if (ins_buf != curbuf && !buf_valid(ins_buf)) {\n    ins_buf = curbuf;  // In case the buffer was wiped out.\n  }\n\n  compl_old_match = compl_curr_match;   // remember the last current match\n  pos = (compl_direction == FORWARD) ? &last_match_pos : &first_match_pos;\n\n  // For ^N/^P loop over all the flags/windows/buffers in 'complete'\n  for (;; ) {\n    found_new_match = FAIL;\n    set_match_pos = false;\n\n    assert(l_ctrl_x_mode == ctrl_x_mode);\n\n    // For ^N/^P pick a new entry from e_cpt if compl_started is off,\n    // or if found_all says this entry is done.  For ^X^L only use the\n    // entries from 'complete' that look in loaded buffers.\n    if ((l_ctrl_x_mode == CTRL_X_NORMAL\n         || CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode))\n        && (!compl_started || found_all)) {\n      found_all = false;\n      while (*e_cpt == ',' || *e_cpt == ' ') {\n        e_cpt++;\n      }\n      if (*e_cpt == '.' && !curbuf->b_scanned) {\n        ins_buf = curbuf;\n        first_match_pos = *ini;\n        // Move the cursor back one character so that ^N can match the\n        // word immediately after the cursor.\n        if (ctrl_x_mode == CTRL_X_NORMAL && dec(&first_match_pos) < 0) {\n          // Move the cursor to after the last character in the\n          // buffer, so that word at start of buffer is found\n          // correctly.\n          first_match_pos.lnum = ins_buf->b_ml.ml_line_count;\n          first_match_pos.col = (colnr_T)STRLEN(ml_get(first_match_pos.lnum));\n        }\n        last_match_pos = first_match_pos;\n        type = 0;\n\n        // Remember the first match so that the loop stops when we\n        // wrap and come back there a second time.\n        set_match_pos = true;\n      } else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL\n                 && (ins_buf =\n                       ins_compl_next_buf(ins_buf, *e_cpt)) != curbuf) {\n        // Scan a buffer, but not the current one.\n        if (ins_buf->b_ml.ml_mfp != NULL) {         // loaded buffer\n          compl_started = true;\n          first_match_pos.col = last_match_pos.col = 0;\n          first_match_pos.lnum = ins_buf->b_ml.ml_line_count + 1;\n          last_match_pos.lnum = 0;\n          type = 0;\n        } else {      // unloaded buffer, scan like dictionary\n          found_all = true;\n          if (ins_buf->b_fname == NULL) {\n            continue;\n          }\n          type = CTRL_X_DICTIONARY;\n          dict = ins_buf->b_fname;\n          dict_f = DICT_EXACT;\n        }\n        msg_hist_off = true;  // reset in msg_trunc_attr()\n        vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),\n                     ins_buf->b_fname == NULL\n                     ? buf_spname(ins_buf)\n                     : ins_buf->b_sfname == NULL\n                     ? ins_buf->b_fname\n                     : ins_buf->b_sfname);\n        (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));\n      } else if (*e_cpt == NUL) {\n        break;\n      } else {\n        if (CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode)) {\n          type = -1;\n        } else if (*e_cpt == 'k' || *e_cpt == 's') {\n          if (*e_cpt == 'k') {\n            type = CTRL_X_DICTIONARY;\n          } else {\n            type = CTRL_X_THESAURUS;\n          }\n          if (*++e_cpt != ',' && *e_cpt != NUL) {\n            dict = e_cpt;\n            dict_f = DICT_FIRST;\n          }\n        } else if (*e_cpt == 'i') {\n          type = CTRL_X_PATH_PATTERNS;\n        } else if (*e_cpt == 'd') {\n          type = CTRL_X_PATH_DEFINES;\n        } else if (*e_cpt == ']' || *e_cpt == 't') {\n          msg_hist_off = true;  // reset in msg_trunc_attr()\n          type = CTRL_X_TAGS;\n          vim_snprintf((char *)IObuff, IOSIZE, \"%s\", _(\"Scanning tags.\"));\n          (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));\n        } else {\n          type = -1;\n        }\n\n        // in any case e_cpt is advanced to the next entry\n        (void)copy_option_part(&e_cpt, IObuff, IOSIZE, \",\");\n\n        found_all = true;\n        if (type == -1) {\n          continue;\n        }\n      }\n    }\n\n    // If complete() was called then compl_pattern has been reset.\n    // The following won't work then, bail out.\n    if (compl_pattern == NULL) {\n      break;\n    }\n\n    switch (type) {\n    case -1:\n      break;\n    case CTRL_X_PATH_PATTERNS:\n    case CTRL_X_PATH_DEFINES:\n      find_pattern_in_path(compl_pattern, compl_direction,\n                           STRLEN(compl_pattern), FALSE, FALSE,\n                           ((type == CTRL_X_PATH_DEFINES\n                             && !(compl_cont_status & CONT_SOL))\n                            ? FIND_DEFINE\n                            : FIND_ANY),\n                           1L, ACTION_EXPAND, 1, MAXLNUM);\n      break;\n\n    case CTRL_X_DICTIONARY:\n    case CTRL_X_THESAURUS:\n      ins_compl_dictionaries(dict != NULL ? dict\n                                          : (type == CTRL_X_THESAURUS\n             ? (*curbuf->b_p_tsr == NUL\n                ? p_tsr\n                : curbuf->b_p_tsr)\n                : (*curbuf->b_p_dict == NUL\n                ? p_dict\n                : curbuf->b_p_dict)),\n                             compl_pattern,\n                             dict != NULL ? dict_f\n                                          : 0, type == CTRL_X_THESAURUS);\n      dict = NULL;\n      break;\n\n    case CTRL_X_TAGS:\n      // set p_ic according to p_ic, p_scs and pat for find_tags().\n      save_p_ic = p_ic;\n      p_ic = ignorecase(compl_pattern);\n\n      // Find up to TAG_MANY matches.  Avoids that an enormous number\n      // of matches is found when compl_pattern is empty\n      g_tag_at_cursor = true;\n      if (find_tags(compl_pattern, &num_matches, &matches,\n                    TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP\n                    | (l_ctrl_x_mode != CTRL_X_NORMAL ? TAG_VERBOSE : 0),\n                    TAG_MANY, curbuf->b_ffname) == OK && num_matches > 0) {\n        ins_compl_add_matches(num_matches, matches, p_ic);\n      }\n      g_tag_at_cursor = false;\n      p_ic = save_p_ic;\n      break;\n\n    case CTRL_X_FILES:\n      if (expand_wildcards(1, &compl_pattern, &num_matches, &matches,\n                           EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) == OK) {\n        // May change home directory back to \"~\".\n        tilde_replace(compl_pattern, num_matches, matches);\n#ifdef BACKSLASH_IN_FILENAME\n        if (curbuf->b_p_csl[0] != NUL) {\n          for (int i = 0; i < num_matches; i++) {\n            char_u *ptr = matches[i];\n            while (*ptr != NUL) {\n              if (curbuf->b_p_csl[0] == 's' && *ptr == '\\\\') {\n                *ptr = '/';\n              } else if (curbuf->b_p_csl[0] == 'b' && *ptr == '/') {\n                *ptr = '\\\\';\n              }\n              ptr += utfc_ptr2len(ptr);\n            }\n          }\n        }\n#endif\n        ins_compl_add_matches(num_matches, matches, p_fic || p_wic);\n      }\n      break;\n\n    case CTRL_X_CMDLINE:\n    case CTRL_X_CMDLINE_CTRL_X:\n      if (expand_cmdline(&compl_xp, compl_pattern,\n                         (int)STRLEN(compl_pattern),\n                         &num_matches, &matches) == EXPAND_OK) {\n        ins_compl_add_matches(num_matches, matches, false);\n      }\n      break;\n\n    case CTRL_X_FUNCTION:\n    case CTRL_X_OMNI:\n      expand_by_function(type, compl_pattern);\n      break;\n\n    case CTRL_X_SPELL:\n      num_matches = expand_spelling(first_match_pos.lnum,\n                                    compl_pattern, &matches);\n      if (num_matches > 0) {\n        ins_compl_add_matches(num_matches, matches, p_ic);\n      }\n      break;\n\n    default:            // normal ^P/^N and ^X^L\n      // If 'infercase' is set, don't use 'smartcase' here\n      save_p_scs = p_scs;\n      assert(ins_buf);\n      if (ins_buf->b_p_inf) {\n        p_scs = FALSE;\n      }\n\n      // Buffers other than curbuf are scanned from the beginning or the\n      // end but never from the middle, thus setting nowrapscan in this\n      // buffers is a good idea, on the other hand, we always set\n      // wrapscan for curbuf to avoid missing matches -- Acevedo,Webb\n      save_p_ws = p_ws;\n      if (ins_buf != curbuf) {\n        p_ws = false;\n      } else if (*e_cpt == '.') {\n        p_ws = true;\n      }\n      bool looped_around = false;\n      for (;; ) {\n        bool cont_s_ipos = false;\n\n        msg_silent++;          // Don't want messages for wrapscan.\n        // CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode) || word-wise search that\n        // has added a word that was at the beginning of the line.\n        if (CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode)\n            || (compl_cont_status & CONT_SOL)) {\n          found_new_match = search_for_exact_line(ins_buf, pos,\n                                                  compl_direction,\n                                                  compl_pattern);\n        } else {\n          found_new_match = searchit(NULL, ins_buf, pos, NULL,\n                                     compl_direction,\n                                     compl_pattern, 1L,\n                                     SEARCH_KEEP + SEARCH_NFMSG,\n                                     RE_LAST, NULL);\n        }\n        msg_silent--;\n        if (!compl_started || set_match_pos) {\n          // set \"compl_started\" even on fail\n          compl_started = true;\n          first_match_pos = *pos;\n          last_match_pos = *pos;\n          set_match_pos = false;\n        } else if (first_match_pos.lnum == last_match_pos.lnum\n                   && first_match_pos.col == last_match_pos.col) {\n          found_new_match = FAIL;\n        } else if ((compl_direction == FORWARD)\n                   && (prev_pos.lnum > pos->lnum\n                       || (prev_pos.lnum == pos->lnum\n                           && prev_pos.col >= pos->col))) {\n          if (looped_around) {\n            found_new_match = FAIL;\n          } else {\n            looped_around = true;\n          }\n        } else if ((compl_direction != FORWARD)\n                   && (prev_pos.lnum < pos->lnum\n                       || (prev_pos.lnum == pos->lnum\n                           && prev_pos.col <= pos->col))) {\n          if (looped_around) {\n            found_new_match = FAIL;\n          } else {\n            looped_around = true;\n          }\n        }\n        prev_pos = *pos;\n        if (found_new_match == FAIL) {\n          if (ins_buf == curbuf) {\n            found_all = true;\n          }\n          break;\n        }\n\n        // when ADDING, the text before the cursor matches, skip it\n        if ((compl_cont_status & CONT_ADDING) && ins_buf == curbuf\n            && ini->lnum == pos->lnum\n            && ini->col  == pos->col) {\n          continue;\n        }\n        ptr = ml_get_buf(ins_buf, pos->lnum, false) + pos->col;\n        if (CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode)) {\n          if (compl_cont_status & CONT_ADDING) {\n            if (pos->lnum >= ins_buf->b_ml.ml_line_count) {\n              continue;\n            }\n            ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);\n            if (!p_paste) {\n              ptr = skipwhite(ptr);\n            }\n          }\n          len = (int)STRLEN(ptr);\n        } else {\n          char_u *tmp_ptr = ptr;\n\n          if (compl_cont_status & CONT_ADDING) {\n            tmp_ptr += compl_length;\n            // Skip if already inside a word.\n            if (vim_iswordp(tmp_ptr)) {\n              continue;\n            }\n            // Find start of next word.\n            tmp_ptr = find_word_start(tmp_ptr);\n          }\n          // Find end of this word.\n          tmp_ptr = find_word_end(tmp_ptr);\n          len = (int)(tmp_ptr - ptr);\n\n          if ((compl_cont_status & CONT_ADDING)\n              && len == compl_length) {\n            if (pos->lnum < ins_buf->b_ml.ml_line_count) {\n              // Try next line, if any. the new word will be \"join\" as if the\n              // normal command \"J\" was used. IOSIZE is always greater than\n              // compl_length, so the next STRNCPY always works -- Acevedo\n              STRNCPY(IObuff, ptr, len);\n              ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);\n              tmp_ptr = ptr = skipwhite(ptr);\n              // Find start of next word.\n              tmp_ptr = find_word_start(tmp_ptr);\n              // Find end of next word.\n              tmp_ptr = find_word_end(tmp_ptr);\n              if (tmp_ptr > ptr) {\n                if (*ptr != ')' && IObuff[len - 1] != TAB) {\n                  if (IObuff[len - 1] != ' ') {\n                    IObuff[len++] = ' ';\n                  }\n                  // IObuf =~ \"\\k.* \", thus len >= 2\n                  if (p_js\n                      && (IObuff[len - 2] == '.'\n                          || IObuff[len - 2] == '?'\n                          || IObuff[len - 2] == '!')) {\n                    IObuff[len++] = ' ';\n                  }\n                }\n                // copy as much as possible of the new word\n                if (tmp_ptr - ptr >= IOSIZE - len) {\n                  tmp_ptr = ptr + IOSIZE - len - 1;\n                }\n                STRLCPY(IObuff + len, ptr, IOSIZE - len);\n                len += (int)(tmp_ptr - ptr);\n                cont_s_ipos = true;\n              }\n              IObuff[len] = NUL;\n              ptr = IObuff;\n            }\n            if (len == compl_length) {\n              continue;\n            }\n          }\n        }\n        if (ins_compl_add_infercase(ptr, len, p_ic, ins_buf == curbuf ? NULL : ins_buf->b_sfname,\n                                    0, cont_s_ipos) != NOTDONE) {\n          found_new_match = OK;\n          break;\n        }\n      }\n      p_scs = save_p_scs;\n      p_ws = save_p_ws;\n    }\n\n    // check if compl_curr_match has changed, (e.g. other type of\n    // expansion added something)\n    if (type != 0 && compl_curr_match != compl_old_match) {\n      found_new_match = OK;\n    }\n\n    // break the loop for specialized modes (use 'complete' just for the\n    // generic l_ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new match\n    if ((l_ctrl_x_mode != CTRL_X_NORMAL\n         && !CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode))\n        || found_new_match != FAIL) {\n      if (got_int) {\n        break;\n      }\n      // Fill the popup menu as soon as possible.\n      if (type != -1) {\n        ins_compl_check_keys(0, false);\n      }\n\n      if ((l_ctrl_x_mode != CTRL_X_NORMAL\n           && !CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode))\n          || compl_interrupted) {\n        break;\n      }\n      compl_started = true;\n    } else {\n      // Mark a buffer scanned when it has been scanned completely\n      if (type == 0 || type == CTRL_X_PATH_PATTERNS) {\n        assert(ins_buf);\n        ins_buf->b_scanned = true;\n      }\n\n      compl_started = false;\n    }\n  }\n  compl_started = true;\n\n  if ((l_ctrl_x_mode == CTRL_X_NORMAL\n       || CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode))\n      && *e_cpt == NUL) {  // Got to end of 'complete'\n    found_new_match = FAIL;\n  }\n\n  i = -1;               // total of matches, unknown\n  if (found_new_match == FAIL\n      || (l_ctrl_x_mode != CTRL_X_NORMAL\n          && !CTRL_X_MODE_LINE_OR_EVAL(l_ctrl_x_mode))) {\n    i = ins_compl_make_cyclic();\n  }\n\n  if (compl_old_match != NULL) {\n    // If several matches were added (FORWARD) or the search failed and has\n    // just been made cyclic then we have to move compl_curr_match to the\n    // next or previous entry (if any) -- Acevedo\n    compl_curr_match = compl_direction == FORWARD\n                        ? compl_old_match->cp_next\n                        : compl_old_match->cp_prev;\n    if (compl_curr_match == NULL) {\n      compl_curr_match = compl_old_match;\n    }\n  }\n  return i;\n}\n\n// Delete the old text being completed.\nstatic void ins_compl_delete(void)\n{\n  int col;\n\n  // In insert mode: Delete the typed part.\n  // In replace mode: Put the old characters back, if any.\n  col = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);\n  if ((int)curwin->w_cursor.col > col) {\n    if (stop_arrow() == FAIL) {\n      return;\n    }\n    backspace_until_column(col);\n  }\n\n  // TODO(vim): is this sufficient for redrawing?  Redrawing everything\n  // causes flicker, thus we can't do that.\n  changed_cline_bef_curs();\n  // clear v:completed_item\n  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));\n}\n\n// Insert the new text being completed.\n// \"in_compl_func\" is TRUE when called from complete_check().\nstatic void ins_compl_insert(int in_compl_func)\n{\n  ins_bytes(compl_shown_match->cp_str + ins_compl_len());\n  compl_used_match = !(compl_shown_match->cp_flags & CP_ORIGINAL_TEXT);\n\n  dict_T *dict = ins_compl_dict_alloc(compl_shown_match);\n  set_vim_var_dict(VV_COMPLETED_ITEM, dict);\n  if (!in_compl_func) {\n    compl_curr_match = compl_shown_match;\n  }\n}\n\n// Convert to complete item dict\nstatic dict_T *ins_compl_dict_alloc(compl_T *match)\n{\n  // { word, abbr, menu, kind, info }\n  dict_T *dict = tv_dict_alloc_lock(VAR_FIXED);\n  tv_dict_add_str(dict, S_LEN(\"word\"),\n                  (const char *)EMPTY_IF_NULL(match->cp_str));\n  tv_dict_add_str(dict, S_LEN(\"abbr\"),\n                  (const char *)EMPTY_IF_NULL(match->cp_text[CPT_ABBR]));\n  tv_dict_add_str(dict, S_LEN(\"menu\"),\n                  (const char *)EMPTY_IF_NULL(match->cp_text[CPT_MENU]));\n  tv_dict_add_str(dict, S_LEN(\"kind\"),\n                  (const char *)EMPTY_IF_NULL(match->cp_text[CPT_KIND]));\n  tv_dict_add_str(dict, S_LEN(\"info\"),\n                  (const char *)EMPTY_IF_NULL(match->cp_text[CPT_INFO]));\n  if (match->cp_user_data.v_type == VAR_UNKNOWN) {\n    tv_dict_add_str(dict, S_LEN(\"user_data\"), \"\");\n  } else {\n    tv_dict_add_tv(dict, S_LEN(\"user_data\"), &match->cp_user_data);\n  }\n  return dict;\n}\n\n/// Fill in the next completion in the current direction.\n/// If \"allow_get_expansion\" is TRUE, then we may call ins_compl_get_exp() to\n/// get more completions.  If it is FALSE, then we just do nothing when there\n/// are no more completions in a given direction.  The latter case is used when\n/// we are still in the middle of finding completions, to allow browsing\n/// through the ones found so far.\n/// @return  the total number of matches, or -1 if still unknown -- webb.\n///\n/// compl_curr_match is currently being used by ins_compl_get_exp(), so we use\n/// compl_shown_match here.\n///\n/// Note that this function may be called recursively once only.  First with\n/// \"allow_get_expansion\" TRUE, which calls ins_compl_get_exp(), which in turn\n/// calls this function with \"allow_get_expansion\" FALSE.\n///\n/// @param count          Repeat completion this many times; should be at least 1\n/// @param insert_match   Insert the newly selected match\n/// @param in_compl_func  Called from complete_check()\nstatic int ins_compl_next(int allow_get_expansion, int count, int insert_match, int in_compl_func)\n{\n  int num_matches = -1;\n  int todo = count;\n  compl_T *found_compl = NULL;\n  bool found_end = false;\n  const bool started = compl_started;\n\n  /* When user complete function return -1 for findstart which is next\n   * time of 'always', compl_shown_match become NULL. */\n  if (compl_shown_match == NULL) {\n    return -1;\n  }\n\n  if (compl_leader != NULL\n      && (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0) {\n    // Set \"compl_shown_match\" to the actually shown match, it may differ\n    // when \"compl_leader\" is used to omit some of the matches.\n    while (!ins_compl_equal(compl_shown_match,\n                            compl_leader, STRLEN(compl_leader))\n           && compl_shown_match->cp_next != NULL\n           && compl_shown_match->cp_next != compl_first_match) {\n      compl_shown_match = compl_shown_match->cp_next;\n    }\n\n    /* If we didn't find it searching forward, and compl_shows_dir is\n     * backward, find the last match. */\n    if (compl_shows_dir == BACKWARD\n        && !ins_compl_equal(compl_shown_match,\n                            compl_leader, (int)STRLEN(compl_leader))\n        && (compl_shown_match->cp_next == NULL\n            || compl_shown_match->cp_next == compl_first_match)) {\n      while (!ins_compl_equal(compl_shown_match,\n                              compl_leader, (int)STRLEN(compl_leader))\n             && compl_shown_match->cp_prev != NULL\n             && compl_shown_match->cp_prev != compl_first_match) {\n        compl_shown_match = compl_shown_match->cp_prev;\n      }\n    }\n  }\n\n  if (allow_get_expansion && insert_match\n      && (!(compl_get_longest || compl_restarting) || compl_used_match)) {\n    // Delete old text to be replaced\n    ins_compl_delete();\n  }\n\n  // When finding the longest common text we stick at the original text,\n  // don't let CTRL-N or CTRL-P move to the first match.\n  bool advance = count != 1 || !allow_get_expansion || !compl_get_longest;\n\n  // When restarting the search don't insert the first match either.\n  if (compl_restarting) {\n    advance = false;\n    compl_restarting = false;\n  }\n\n  /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap\n   * around. */\n  while (--todo >= 0) {\n    if (compl_shows_dir == FORWARD && compl_shown_match->cp_next != NULL) {\n      compl_shown_match = compl_shown_match->cp_next;\n      found_end = (compl_first_match != NULL\n                   && (compl_shown_match->cp_next == compl_first_match\n                       || compl_shown_match == compl_first_match));\n    } else if (compl_shows_dir == BACKWARD\n               && compl_shown_match->cp_prev != NULL) {\n      found_end = (compl_shown_match == compl_first_match);\n      compl_shown_match = compl_shown_match->cp_prev;\n      found_end |= (compl_shown_match == compl_first_match);\n    } else {\n      if (!allow_get_expansion) {\n        if (advance) {\n          if (compl_shows_dir == BACKWARD) {\n            compl_pending -= todo + 1;\n          } else {\n            compl_pending += todo + 1;\n          }\n        }\n        return -1;\n      }\n\n      if (!compl_no_select && advance) {\n        if (compl_shows_dir == BACKWARD) {\n          --compl_pending;\n        } else {\n          ++compl_pending;\n        }\n      }\n\n      // Find matches.\n      num_matches = ins_compl_get_exp(&compl_startpos);\n\n      // handle any pending completions\n      while (compl_pending != 0 && compl_direction == compl_shows_dir\n             && advance) {\n        if (compl_pending > 0 && compl_shown_match->cp_next != NULL) {\n          compl_shown_match = compl_shown_match->cp_next;\n          --compl_pending;\n        }\n        if (compl_pending < 0 && compl_shown_match->cp_prev != NULL) {\n          compl_shown_match = compl_shown_match->cp_prev;\n          ++compl_pending;\n        } else {\n          break;\n        }\n      }\n      found_end = false;\n    }\n    if ((compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0\n        && compl_leader != NULL\n        && !ins_compl_equal(compl_shown_match,\n                            compl_leader, STRLEN(compl_leader))) {\n      todo++;\n    } else {\n      // Remember a matching item.\n      found_compl = compl_shown_match;\n    }\n\n    // Stop at the end of the list when we found a usable match.\n    if (found_end) {\n      if (found_compl != NULL) {\n        compl_shown_match = found_compl;\n        break;\n      }\n      todo = 1;             // use first usable match after wrapping around\n    }\n  }\n\n  // Insert the text of the new completion, or the compl_leader.\n  if (compl_no_insert && !started) {\n    ins_bytes(compl_orig_text + ins_compl_len());\n    compl_used_match = false;\n  } else if (insert_match) {\n    if (!compl_get_longest || compl_used_match) {\n      ins_compl_insert(in_compl_func);\n    } else {\n      ins_bytes(compl_leader + ins_compl_len());\n    }\n  } else {\n    compl_used_match = false;\n  }\n\n  if (!allow_get_expansion) {\n    // redraw to show the user what was inserted\n    update_screen(0);\n\n    // display the updated popup menu\n    ins_compl_show_pum();\n\n    // Delete old text to be replaced, since we're still searching and\n    // don't want to match ourselves!\n    ins_compl_delete();\n  }\n\n  /* Enter will select a match when the match wasn't inserted and the popup\n   * menu is visible. */\n  if (compl_no_insert && !started) {\n    compl_enter_selects = TRUE;\n  } else {\n    compl_enter_selects = !insert_match && compl_match_array != NULL;\n  }\n\n  /*\n   * Show the file name for the match (if any)\n   * Truncate the file name to avoid a wait for return.\n   */\n  if (compl_shown_match->cp_fname != NULL) {\n    char *lead = _(\"match in file\");\n    int space = sc_col - vim_strsize((char_u *)lead) - 2;\n    char_u *s;\n    char_u *e;\n\n    if (space > 0) {\n      // We need the tail that fits.  With double-byte encoding going\n      // back from the end is very slow, thus go from the start and keep\n      // the text that fits in \"space\" between \"s\" and \"e\".\n      for (s = e = compl_shown_match->cp_fname; *e != NUL; MB_PTR_ADV(e)) {\n        space -= ptr2cells(e);\n        while (space < 0) {\n          space += ptr2cells(s);\n          MB_PTR_ADV(s);\n        }\n      }\n      msg_hist_off = true;\n      vim_snprintf((char *)IObuff, IOSIZE, \"%s %s%s\", lead,\n                   s > compl_shown_match->cp_fname ? \"<\" : \"\", s);\n      msg(IObuff);\n      msg_hist_off = false;\n      redraw_cmdline = false;     // don't overwrite!\n    }\n  }\n\n  return num_matches;\n}\n\nvoid pum_ext_select_item(int item, bool insert, bool finish)\n{\n  if (!pum_visible() || item < -1 || item >= compl_match_arraysize) {\n    return;\n  }\n  pum_want.active = true;\n  pum_want.item = item;\n  pum_want.insert = insert;\n  pum_want.finish = finish;\n}\n\n// Call this while finding completions, to check whether the user has hit a key\n// that should change the currently displayed completion, or exit completion\n// mode.  Also, when compl_pending is not zero, show a completion as soon as\n// possible. -- webb\n// \"frequency\" specifies out of how many calls we actually check.\n// \"in_compl_func\" is TRUE when called from complete_check(), don't set\n// compl_curr_match.\nvoid ins_compl_check_keys(int frequency, int in_compl_func)\n{\n  static int count = 0;\n\n  // Don't check when reading keys from a script, :normal or feedkeys().\n  // That would break the test scripts.  But do check for keys when called\n  // from complete_check().\n  if (!in_compl_func && (using_script() || ex_normal_busy)) {\n    return;\n  }\n\n  // Only do this at regular intervals\n  if (++count < frequency) {\n    return;\n  }\n  count = 0;\n\n  /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()\n   * can't do its work correctly. */\n  int c = vpeekc_any();\n  if (c != NUL) {\n    if (vim_is_ctrl_x_key(c) && c != Ctrl_X && c != Ctrl_R) {\n      c = safe_vgetc();         // Eat the character\n      compl_shows_dir = ins_compl_key2dir(c);\n      (void)ins_compl_next(false, ins_compl_key2count(c),\n                           c != K_UP && c != K_DOWN, in_compl_func);\n    } else {\n      /* Need to get the character to have KeyTyped set.  We'll put it\n       * back with vungetc() below.  But skip K_IGNORE. */\n      c = safe_vgetc();\n      if (c != K_IGNORE) {\n        /* Don't interrupt completion when the character wasn't typed,\n         * e.g., when doing @q to replay keys. */\n        if (c != Ctrl_R && KeyTyped) {\n          compl_interrupted = TRUE;\n        }\n\n        vungetc(c);\n      }\n    }\n  }\n  if (compl_pending != 0 && !got_int && !compl_no_insert) {\n    int todo = compl_pending > 0 ? compl_pending : -compl_pending;\n\n    compl_pending = 0;\n    (void)ins_compl_next(false, todo, true, in_compl_func);\n  }\n}\n\n/*\n * Decide the direction of Insert mode complete from the key typed.\n * Returns BACKWARD or FORWARD.\n */\nstatic int ins_compl_key2dir(int c)\n{\n  if (c == K_EVENT || c == K_COMMAND) {\n    return pum_want.item < pum_selected_item ? BACKWARD : FORWARD;\n  }\n  if (c == Ctrl_P || c == Ctrl_L\n      || c == K_PAGEUP || c == K_KPAGEUP\n      || c == K_S_UP || c == K_UP) {\n    return BACKWARD;\n  }\n  return FORWARD;\n}\n\n/// Check that \"c\" is a valid completion key only while the popup menu is shown\n///\n/// @param  c  character to check\nstatic bool ins_compl_pum_key(int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP\n                           || c == K_PAGEDOWN || c == K_KPAGEDOWN\n                           || c == K_S_DOWN || c == K_UP || c == K_DOWN);\n}\n\n/*\n * Decide the number of completions to move forward.\n * Returns 1 for most keys, height of the popup menu for page-up/down keys.\n */\nstatic int ins_compl_key2count(int c)\n{\n  int h;\n\n  if (c == K_EVENT || c == K_COMMAND) {\n    int offset = pum_want.item - pum_selected_item;\n    return abs(offset);\n  }\n\n  if (ins_compl_pum_key(c) && c != K_UP && c != K_DOWN) {\n    h = pum_get_height();\n    if (h > 3) {\n      h -= 2;       // keep some context\n    }\n    return h;\n  }\n  return 1;\n}\n\n/// Check that completion with \"c\" should insert the match, false if only\n/// to change the currently selected completion.\n///\n/// @param  c  character to check\nstatic bool ins_compl_use_match(int c)\n  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  switch (c) {\n  case K_UP:\n  case K_DOWN:\n  case K_PAGEDOWN:\n  case K_KPAGEDOWN:\n  case K_S_DOWN:\n  case K_PAGEUP:\n  case K_KPAGEUP:\n  case K_S_UP:\n    return false;\n  case K_EVENT:\n  case K_COMMAND:\n    return pum_want.active && pum_want.insert;\n  }\n  return true;\n}\n\n/*\n * Do Insert mode completion.\n * Called when character \"c\" was typed, which has a meaning for completion.\n * Returns OK if completion was done, FAIL if something failed.\n */\nstatic int ins_complete(int c, bool enable_pum)\n{\n  char_u *line;\n  int startcol = 0;                 // column where searched text starts\n  colnr_T curs_col;                 // cursor column\n  int n;\n  int save_w_wrow;\n  int save_w_leftcol;\n  int insert_match;\n  const bool save_did_ai = did_ai;\n  int flags = CP_ORIGINAL_TEXT;\n\n  compl_direction = ins_compl_key2dir(c);\n  insert_match = ins_compl_use_match(c);\n\n  if (!compl_started) {\n    // First time we hit ^N or ^P (in a row, I mean)\n\n    did_ai = false;\n    did_si = false;\n    can_si = false;\n    can_si_back = false;\n    if (stop_arrow() == FAIL) {\n      return FAIL;\n    }\n\n    line = ml_get(curwin->w_cursor.lnum);\n    curs_col = curwin->w_cursor.col;\n    compl_pending = 0;\n\n    /* If this same ctrl_x_mode has been interrupted use the text from\n     * \"compl_startpos\" to the cursor as a pattern to add a new word\n     * instead of expand the one before the cursor, in word-wise if\n     * \"compl_startpos\" is not in the same line as the cursor then fix it\n     * (the line has been split because it was longer than 'tw').  if SOL\n     * is set then skip the previous pattern, a word at the beginning of\n     * the line has been inserted, we'll look for that  -- Acevedo. */\n    if ((compl_cont_status & CONT_INTRPT) == CONT_INTRPT\n        && compl_cont_mode == ctrl_x_mode) {\n      /*\n       * it is a continued search\n       */\n      compl_cont_status &= ~CONT_INTRPT;        // remove INTRPT\n      if (ctrl_x_mode == CTRL_X_NORMAL\n          || ctrl_x_mode == CTRL_X_PATH_PATTERNS\n          || ctrl_x_mode == CTRL_X_PATH_DEFINES) {\n        if (compl_startpos.lnum != curwin->w_cursor.lnum) {\n          /* line (probably) wrapped, set compl_startpos to the\n           * first non_blank in the line, if it is not a wordchar\n           * include it to get a better pattern, but then we don't\n           * want the \"\\\\<\" prefix, check it bellow */\n          compl_col = (colnr_T)getwhitecols(line);\n          compl_startpos.col = compl_col;\n          compl_startpos.lnum = curwin->w_cursor.lnum;\n          compl_cont_status &= ~CONT_SOL;             // clear SOL if present\n        } else {\n          /* S_IPOS was set when we inserted a word that was at the\n           * beginning of the line, which means that we'll go to SOL\n           * mode but first we need to redefine compl_startpos */\n          if (compl_cont_status & CONT_S_IPOS) {\n            compl_cont_status |= CONT_SOL;\n            compl_startpos.col = (colnr_T)(skipwhite(line + compl_length\n                                                     + compl_startpos.col) - line);\n          }\n          compl_col = compl_startpos.col;\n        }\n        compl_length = curwin->w_cursor.col - (int)compl_col;\n        /* IObuff is used to add a \"word from the next line\" would we\n         * have enough space?  just being paranoid */\n#define MIN_SPACE 75\n        if (compl_length > (IOSIZE - MIN_SPACE)) {\n          compl_cont_status &= ~CONT_SOL;\n          compl_length = (IOSIZE - MIN_SPACE);\n          compl_col = curwin->w_cursor.col - compl_length;\n        }\n        compl_cont_status |= CONT_ADDING | CONT_N_ADDS;\n        if (compl_length < 1) {\n          compl_cont_status &= CONT_LOCAL;\n        }\n      } else if (CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)) {\n        compl_cont_status = CONT_ADDING | CONT_N_ADDS;\n      } else {\n        compl_cont_status = 0;\n      }\n    } else {\n      compl_cont_status &= CONT_LOCAL;\n    }\n\n    if (!(compl_cont_status & CONT_ADDING)) {   // normal expansion\n      compl_cont_mode = ctrl_x_mode;\n      if (ctrl_x_mode != CTRL_X_NORMAL) {\n        // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL\n        compl_cont_status = 0;\n      }\n      compl_cont_status |= CONT_N_ADDS;\n      compl_startpos = curwin->w_cursor;\n      startcol = (int)curs_col;\n      compl_col = 0;\n    }\n\n    // Work out completion pattern and original text -- webb\n    if (ctrl_x_mode == CTRL_X_NORMAL || (ctrl_x_mode & CTRL_X_WANT_IDENT)) {\n      if ((compl_cont_status & CONT_SOL)\n          || ctrl_x_mode == CTRL_X_PATH_DEFINES) {\n        if (!(compl_cont_status & CONT_ADDING)) {\n          while (--startcol >= 0 && vim_isIDc(line[startcol])) {\n            ;\n          }\n          compl_col += ++startcol;\n          compl_length = curs_col - startcol;\n        }\n        if (p_ic) {\n          compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);\n        } else {\n          compl_pattern = vim_strnsave(line + compl_col, compl_length);\n        }\n      } else if (compl_cont_status & CONT_ADDING) {\n        char_u *prefix = (char_u *)\"\\\\<\";\n\n        // we need up to 2 extra chars for the prefix\n        compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,\n                                           compl_length) + 2);\n        if (!vim_iswordp(line + compl_col)\n            || (compl_col > 0\n                && (\n                    vim_iswordp(mb_prevptr(line, line + compl_col))\n                    ))) {\n          prefix = (char_u *)\"\";\n        }\n        STRCPY((char *)compl_pattern, prefix);\n        (void)quote_meta(compl_pattern + STRLEN(prefix),\n                         line + compl_col, compl_length);\n      } else if (--startcol < 0\n                 || !vim_iswordp(mb_prevptr(line, line + startcol + 1))) {\n        // Match any word of at least two chars\n        compl_pattern = vim_strsave((char_u *)\"\\\\<\\\\k\\\\k\");\n        compl_col += curs_col;\n        compl_length = 0;\n      } else {\n        // Search the point of change class of multibyte character\n        // or not a word single byte character backward.\n        startcol -= utf_head_off(line, line + startcol);\n        int base_class = mb_get_class(line + startcol);\n        while (--startcol >= 0) {\n          int head_off = utf_head_off(line, line + startcol);\n          if (base_class != mb_get_class(line + startcol - head_off)) {\n            break;\n          }\n          startcol -= head_off;\n        }\n        compl_col += ++startcol;\n        compl_length = (int)curs_col - startcol;\n        if (compl_length == 1) {\n          /* Only match word with at least two chars -- webb\n           * there's no need to call quote_meta,\n           * xmalloc(7) is enough  -- Acevedo\n           */\n          compl_pattern = xmalloc(7);\n          STRCPY((char *)compl_pattern, \"\\\\<\");\n          (void)quote_meta(compl_pattern + 2, line + compl_col, 1);\n          STRCAT((char *)compl_pattern, \"\\\\k\");\n        } else {\n          compl_pattern = xmalloc(quote_meta(NULL, line + compl_col,\n                                             compl_length) + 2);\n          STRCPY((char *)compl_pattern, \"\\\\<\");\n          (void)quote_meta(compl_pattern + 2, line + compl_col,\n                           compl_length);\n        }\n      }\n    } else if (CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)) {\n      compl_col = (colnr_T)getwhitecols(line);\n      compl_length = (int)curs_col - (int)compl_col;\n      if (compl_length < 0) {           // cursor in indent: empty pattern\n        compl_length = 0;\n      }\n      if (p_ic) {\n        compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);\n      } else {\n        compl_pattern = vim_strnsave(line + compl_col, compl_length);\n      }\n    } else if (ctrl_x_mode == CTRL_X_FILES) {\n      // Go back to just before the first filename character.\n      if (startcol > 0) {\n        char_u *p = line + startcol;\n\n        MB_PTR_BACK(line, p);\n        while (p > line && vim_isfilec(PTR2CHAR(p))) {\n          MB_PTR_BACK(line, p);\n        }\n        if (p == line && vim_isfilec(PTR2CHAR(p))) {\n          startcol = 0;\n        } else {\n          startcol = (int)(p - line) + 1;\n        }\n      }\n\n      compl_col += startcol;\n      compl_length = (int)curs_col - startcol;\n      compl_pattern = addstar(line + compl_col, compl_length, EXPAND_FILES);\n    } else if (ctrl_x_mode == CTRL_X_CMDLINE || ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X) {\n      compl_pattern = vim_strnsave(line, curs_col);\n      set_cmd_context(&compl_xp, compl_pattern,\n                      (int)STRLEN(compl_pattern), curs_col, false);\n      if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL\n          || compl_xp.xp_context == EXPAND_NOTHING) {\n        // No completion possible, use an empty pattern to get a\n        // \"pattern not found\" message.\n        compl_col = curs_col;\n      } else {\n        compl_col = (int)(compl_xp.xp_pattern - compl_pattern);\n      }\n      compl_length = curs_col - compl_col;\n    } else if (ctrl_x_mode == CTRL_X_FUNCTION || ctrl_x_mode ==\n               CTRL_X_OMNI) {\n      /*\n       * Call user defined function 'completefunc' with \"a:findstart\"\n       * set to 1 to obtain the length of text to use for completion.\n       */\n      char_u *funcname;\n      pos_T pos;\n      win_T *curwin_save;\n      buf_T *curbuf_save;\n      const int save_State = State;\n\n      /* Call 'completefunc' or 'omnifunc' and get pattern length as a\n       * string */\n      funcname = ctrl_x_mode == CTRL_X_FUNCTION\n                 ? curbuf->b_p_cfu : curbuf->b_p_ofu;\n      if (*funcname == NUL) {\n        EMSG2(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION\n            ? \"completefunc\" : \"omnifunc\");\n        // restore did_ai, so that adding comment leader works\n        did_ai = save_did_ai;\n        return FAIL;\n      }\n\n      typval_T args[3];\n      args[0].v_type = VAR_NUMBER;\n      args[1].v_type = VAR_STRING;\n      args[2].v_type = VAR_UNKNOWN;\n      args[0].vval.v_number = 1;\n      args[1].vval.v_string = (char_u *)\"\";\n\n      pos = curwin->w_cursor;\n      curwin_save = curwin;\n      curbuf_save = curbuf;\n      int col = call_func_retnr(funcname, 2, args);\n\n      State = save_State;\n      if (curwin_save != curwin || curbuf_save != curbuf) {\n        EMSG(_(e_complwin));\n        return FAIL;\n      }\n      curwin->w_cursor = pos;           // restore the cursor position\n      validate_cursor();\n      if (!equalpos(curwin->w_cursor, pos)) {\n        EMSG(_(e_compldel));\n        return FAIL;\n      }\n\n      /* Return value -2 means the user complete function wants to\n       * cancel the complete without an error.\n       * Return value -3 does the same as -2 and leaves CTRL-X mode.*/\n      if (col == -2) {\n        return FAIL;\n      }\n      if (col == -3) {\n        ctrl_x_mode = CTRL_X_NORMAL;\n        edit_submode = NULL;\n        if (!shortmess(SHM_COMPLETIONMENU)) {\n          msg_clr_cmdline();\n        }\n        return FAIL;\n      }\n\n      // Reset extended parameters of completion, when start new\n      // completion.\n      compl_opt_refresh_always = false;\n\n      if (col < 0) {\n        col = curs_col;\n      }\n      compl_col = col;\n      if (compl_col > curs_col) {\n        compl_col = curs_col;\n      }\n\n      /* Setup variables for completion.  Need to obtain \"line\" again,\n       * it may have become invalid. */\n      line = ml_get(curwin->w_cursor.lnum);\n      compl_length = curs_col - compl_col;\n      compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    } else if (ctrl_x_mode == CTRL_X_SPELL) {\n      if (spell_bad_len > 0) {\n        assert(spell_bad_len <= INT_MAX);\n        compl_col = curs_col - (int)spell_bad_len;\n      } else {\n        compl_col = spell_word_start(startcol);\n      }\n      if (compl_col >= (colnr_T)startcol) {\n        compl_length = 0;\n        compl_col = curs_col;\n      } else {\n        spell_expand_check_cap(compl_col);\n        compl_length = (int)curs_col - compl_col;\n      }\n      // Need to obtain \"line\" again, it may have become invalid.\n      line = ml_get(curwin->w_cursor.lnum);\n      compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    } else {\n      internal_error(\"ins_complete()\");\n      return FAIL;\n    }\n\n    if (compl_cont_status & CONT_ADDING) {\n      edit_submode_pre = (char_u *)_(\" Adding\");\n      if (CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode)) {\n        // Insert a new line, keep indentation but ignore 'comments'\n        char_u *old = curbuf->b_p_com;\n\n        curbuf->b_p_com = (char_u *)\"\";\n        compl_startpos.lnum = curwin->w_cursor.lnum;\n        compl_startpos.col = compl_col;\n        ins_eol('\\r');\n        curbuf->b_p_com = old;\n        compl_length = 0;\n        compl_col = curwin->w_cursor.col;\n      }\n    } else {\n      edit_submode_pre = NULL;\n      compl_startpos.col = compl_col;\n    }\n\n    if (compl_cont_status & CONT_LOCAL) {\n      edit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);\n    } else {\n      edit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n    }\n\n    /* If any of the original typed text has been changed we need to fix\n     * the redo buffer. */\n    ins_compl_fixRedoBufForLeader(NULL);\n\n    // Always add completion for the original text.\n    xfree(compl_orig_text);\n    compl_orig_text = vim_strnsave(line + compl_col, compl_length);\n    if (p_ic) {\n      flags |= CP_ICASE;\n    }\n    if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,\n                      flags, false) != OK) {\n      XFREE_CLEAR(compl_pattern);\n      XFREE_CLEAR(compl_orig_text);\n      return FAIL;\n    }\n\n    /* showmode might reset the internal line pointers, so it must\n     * be called before line = ml_get(), or when this address is no\n     * longer needed.  -- Acevedo.\n     */\n    edit_submode_extra = (char_u *)_(\"-- Searching...\");\n    edit_submode_highl = HLF_COUNT;\n    showmode();\n    edit_submode_extra = NULL;\n    ui_flush();\n  } else if (insert_match && stop_arrow() == FAIL) {\n    return FAIL;\n  }\n\n  compl_shown_match = compl_curr_match;\n  compl_shows_dir = compl_direction;\n\n  /*\n   * Find next match (and following matches).\n   */\n  save_w_wrow = curwin->w_wrow;\n  save_w_leftcol = curwin->w_leftcol;\n  n = ins_compl_next(true, ins_compl_key2count(c), insert_match, false);\n\n\n  if (n > 1) {          // all matches have been found\n    compl_matches = n;\n  }\n  compl_curr_match = compl_shown_match;\n  compl_direction = compl_shows_dir;\n\n  /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert\n   * mode. */\n  if (got_int && !global_busy) {\n    (void)vgetc();\n    got_int = FALSE;\n  }\n\n  // we found no match if the list has only the \"compl_orig_text\"-entry\n  if (compl_first_match == compl_first_match->cp_next) {\n    edit_submode_extra = (compl_cont_status & CONT_ADDING)\n                         && compl_length > 1\n                         ? (char_u *)_(e_hitend) : (char_u *)_(e_patnotf);\n    edit_submode_highl = HLF_E;\n    /* remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,\n     * because we couldn't expand anything at first place, but if we used\n     * ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word\n     * (such as M in M'exico) if not tried already.  -- Acevedo */\n    if (compl_length > 1\n        || (compl_cont_status & CONT_ADDING)\n        || (ctrl_x_mode != CTRL_X_NORMAL\n            && ctrl_x_mode != CTRL_X_PATH_PATTERNS\n            && ctrl_x_mode != CTRL_X_PATH_DEFINES)) {\n      compl_cont_status &= ~CONT_N_ADDS;\n    }\n  }\n\n  if (compl_curr_match->cp_flags & CP_CONT_S_IPOS) {\n    compl_cont_status |= CONT_S_IPOS;\n  } else {\n    compl_cont_status &= ~CONT_S_IPOS;\n  }\n\n  if (edit_submode_extra == NULL) {\n    if (compl_curr_match->cp_flags & CP_ORIGINAL_TEXT) {\n      edit_submode_extra = (char_u *)_(\"Back at original\");\n      edit_submode_highl = HLF_W;\n    } else if (compl_cont_status & CONT_S_IPOS) {\n      edit_submode_extra = (char_u *)_(\"Word from other line\");\n      edit_submode_highl = HLF_COUNT;\n    } else if (compl_curr_match->cp_next == compl_curr_match->cp_prev) {\n      edit_submode_extra = (char_u *)_(\"The only match\");\n      edit_submode_highl = HLF_COUNT;\n      compl_curr_match->cp_number = 1;\n    } else {\n      // Update completion sequence number when needed.\n      if (compl_curr_match->cp_number == -1) {\n        ins_compl_update_sequence_numbers();\n      }\n\n      /* The match should always have a sequence number now, this is\n       * just a safety check. */\n      if (compl_curr_match->cp_number != -1) {\n        /* Space for 10 text chars. + 2x10-digit no.s = 31.\n         * Translations may need more than twice that. */\n        static char_u match_ref[81];\n\n        if (compl_matches > 0) {\n          vim_snprintf((char *)match_ref, sizeof(match_ref),\n                       _(\"match %d of %d\"),\n                       compl_curr_match->cp_number, compl_matches);\n        } else {\n          vim_snprintf((char *)match_ref, sizeof(match_ref),\n                       _(\"match %d\"),\n                       compl_curr_match->cp_number);\n        }\n        edit_submode_extra = match_ref;\n        edit_submode_highl = HLF_R;\n        if (dollar_vcol >= 0) {\n          curs_columns(curwin, false);\n        }\n      }\n    }\n  }\n\n  // Show a message about what (completion) mode we're in.\n  showmode();\n  if (!shortmess(SHM_COMPLETIONMENU)) {\n    if (edit_submode_extra != NULL) {\n      if (!p_smd) {\n        msg_hist_off = true;\n        msg_attr((const char *)edit_submode_extra,\n                 (edit_submode_highl < HLF_COUNT\n                  ? HL_ATTR(edit_submode_highl) : 0));\n        msg_hist_off = false;\n      }\n    } else {\n      msg_clr_cmdline();  // necessary for \"noshowmode\"\n    }\n  }\n\n  // Show the popup menu, unless we got interrupted.\n  if (enable_pum && !compl_interrupted) {\n    show_pum(save_w_wrow, save_w_leftcol);\n  }\n  compl_was_interrupted = compl_interrupted;\n  compl_interrupted = FALSE;\n\n  return OK;\n}\n\n/*\n * Looks in the first \"len\" chars. of \"src\" for search-metachars.\n * If dest is not NULL the chars. are copied there quoting (with\n * a backslash) the metachars, and dest would be NUL terminated.\n * Returns the length (needed) of dest\n */\nstatic unsigned quote_meta(char_u *dest, char_u *src, int len)\n{\n  unsigned m = (unsigned)len + 1;       // one extra for the NUL\n\n  for (; --len >= 0; src++) {\n    switch (*src) {\n    case '.':\n    case '*':\n    case '[':\n      if (ctrl_x_mode == CTRL_X_DICTIONARY\n          || ctrl_x_mode == CTRL_X_THESAURUS) {\n        break;\n      }\n      FALLTHROUGH;\n    case '~':\n      if (!p_magic) {           // quote these only if magic is set\n        break;\n      }\n      FALLTHROUGH;\n    case '\\\\':\n      if (ctrl_x_mode == CTRL_X_DICTIONARY\n          || ctrl_x_mode == CTRL_X_THESAURUS) {\n        break;\n      }\n      FALLTHROUGH;\n    case '^':                   // currently it's not needed.\n    case '$':\n      m++;\n      if (dest != NULL) {\n        *dest++ = '\\\\';\n      }\n      break;\n    }\n    if (dest != NULL) {\n      *dest++ = *src;\n    }\n    // Copy remaining bytes of a multibyte character.\n    const int mb_len = utfc_ptr2len(src) - 1;\n    if (mb_len > 0 && len >= mb_len) {\n      for (int i = 0; i < mb_len; i++) {\n        len--;\n        src++;\n        if (dest != NULL) {\n          *dest++ = *src;\n        }\n      }\n    }\n  }\n  if (dest != NULL) {\n    *dest = NUL;\n  }\n\n  return m;\n}\n\n/*\n * Next character is interpreted literally.\n * A one, two or three digit decimal number is interpreted as its byte value.\n * If one or two digits are entered, the next character is given to vungetc().\n * For Unicode a character > 255 may be returned.\n */\nint get_literal(void)\n{\n  int cc;\n  int nc;\n  int i;\n  bool hex = false;\n  bool octal = false;\n  int unicode = 0;\n\n  if (got_int) {\n    return Ctrl_C;\n  }\n\n  no_mapping++;                 // don't map the next key hits\n  cc = 0;\n  i = 0;\n  for (;; ) {\n    nc = plain_vgetc();\n    if (!(State & CMDLINE)\n        && MB_BYTE2LEN_CHECK(nc) == 1) {\n      add_to_showcmd(nc);\n    }\n    if (nc == 'x' || nc == 'X') {\n      hex = true;\n    } else if (nc == 'o' || nc == 'O') {\n      octal = true;\n    } else if (nc == 'u' || nc == 'U') {\n      unicode = nc;\n    } else {\n      if (hex\n          || unicode != 0) {\n        if (!ascii_isxdigit(nc)) {\n          break;\n        }\n        cc = cc * 16 + hex2nr(nc);\n      } else if (octal) {\n        if (nc < '0' || nc > '7') {\n          break;\n        }\n        cc = cc * 8 + nc - '0';\n      } else {\n        if (!ascii_isdigit(nc)) {\n          break;\n        }\n        cc = cc * 10 + nc - '0';\n      }\n\n      ++i;\n    }\n\n    if (cc > 255\n        && unicode == 0) {\n      cc = 255;                 // limit range to 0-255\n    }\n    nc = 0;\n\n    if (hex) {                  // hex: up to two chars\n      if (i >= 2) {\n        break;\n      }\n    } else if (unicode) {     // Unicode: up to four or eight chars\n      if ((unicode == 'u' && i >= 4) || (unicode == 'U' && i >= 8)) {\n        break;\n      }\n    } else if (i >= 3) {        // decimal or octal: up to three chars\n      break;\n    }\n  }\n  if (i == 0) {     // no number entered\n    if (nc == K_ZERO) {     // NUL is stored as NL\n      cc = '\\n';\n      nc = 0;\n    } else {\n      cc = nc;\n      nc = 0;\n    }\n  }\n\n  if (cc == 0) {        // NUL is stored as NL\n    cc = '\\n';\n  }\n\n  --no_mapping;\n  if (nc) {\n    vungetc(nc);\n  }\n  got_int = false;          // CTRL-C typed after CTRL-V is not an interrupt\n  return cc;\n}\n\n/// Insert character, taking care of special keys and mod_mask\n///\n/// @param ctrlv `c` was typed after CTRL-V\nstatic void insert_special(int c, int allow_modmask, int ctrlv)\n{\n  char_u *p;\n  int len;\n\n  // Special function key, translate into \"<Key>\". Up to the last '>' is\n  // inserted with ins_str(), so as not to replace characters in replace\n  // mode.\n  // Only use mod_mask for special keys, to avoid things like <S-Space>,\n  // unless 'allow_modmask' is TRUE.\n  if (mod_mask & MOD_MASK_CMD) {  // Command-key never produces a normal key.\n    allow_modmask = true;\n  }\n  if (IS_SPECIAL(c) || (mod_mask && allow_modmask)) {\n    p = get_special_key_name(c, mod_mask);\n    len = (int)STRLEN(p);\n    c = p[len - 1];\n    if (len > 2) {\n      if (stop_arrow() == FAIL) {\n        return;\n      }\n      p[len - 1] = NUL;\n      ins_str(p);\n      AppendToRedobuffLit(p, -1);\n      ctrlv = FALSE;\n    }\n  }\n  if (stop_arrow() == OK) {\n    insertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);\n  }\n}\n\n/*\n * Special characters in this context are those that need processing other\n * than the simple insertion that can be performed here. This includes ESC\n * which terminates the insert, and CR/NL which need special processing to\n * open up a new line. This routine tries to optimize insertions performed by\n * the \"redo\", \"undo\" or \"put\" commands, so it needs to know when it should\n * stop and defer processing to the \"normal\" mechanism.\n * '0' and '^' are special, because they can be followed by CTRL-D.\n */\n# define ISSPECIAL(c)   ((c) < ' ' || (c) >= DEL || (c) == '0' || (c) == '^')\n\n#define WHITECHAR(cc) ( \\\n                        ascii_iswhite(cc) \\\n                        && !utf_iscomposing(utf_ptr2char(get_cursor_pos_ptr() + 1)))\n\n///\n/// \"flags\": INSCHAR_FORMAT - force formatting\n///          INSCHAR_CTRLV  - char typed just after CTRL-V\n///          INSCHAR_NO_FEX - don't use 'formatexpr'\n///\n///   NOTE: passes the flags value straight through to internal_format() which,\n///         beside INSCHAR_FORMAT (above), is also looking for these:\n///          INSCHAR_DO_COM   - format comments\n///          INSCHAR_COM_LIST - format comments with num list or 2nd line indent\n///\n/// @param c              character to insert or NUL\n/// @param flags          INSCHAR_FORMAT, etc.\n/// @param second_indent  indent for second line if >= 0\nvoid insertchar(int c, int flags, int second_indent)\n{\n  char_u *p;\n  int force_format = flags & INSCHAR_FORMAT;\n\n  const int textwidth = comp_textwidth(force_format);\n  const bool fo_ins_blank = has_format_option(FO_INS_BLANK);\n\n  /*\n   * Try to break the line in two or more pieces when:\n   * - Always do this if we have been called to do formatting only.\n   * - Always do this when 'formatoptions' has the 'a' flag and the line\n   *   ends in white space.\n   * - Otherwise:\n   *     - Don't do this if inserting a blank\n   *     - Don't do this if an existing character is being replaced, unless\n   *       we're in VREPLACE mode.\n   *     - Do this if the cursor is not on the line where insert started\n   *     or - 'formatoptions' doesn't have 'l' or the line was not too long\n   *           before the insert.\n   *        - 'formatoptions' doesn't have 'b' or a blank was inserted at or\n   *          before 'textwidth'\n   */\n  if (textwidth > 0\n      && (force_format\n          || (!ascii_iswhite(c)\n              && !((State & REPLACE_FLAG)\n                   && !(State & VREPLACE_FLAG)\n                   && *get_cursor_pos_ptr() != NUL)\n              && (curwin->w_cursor.lnum != Insstart.lnum\n                  || ((!has_format_option(FO_INS_LONG)\n                       || Insstart_textlen <= (colnr_T)textwidth)\n                      && (!fo_ins_blank\n                          || Insstart_blank_vcol <= (colnr_T)textwidth)))))) {\n    // Format with 'formatexpr' when it's set.  Use internal formatting\n    // when 'formatexpr' isn't set or it returns non-zero.\n    bool do_internal = true;\n    colnr_T virtcol = get_nolist_virtcol()\n                      + char2cells(c != NUL ? c : gchar_cursor());\n\n    if (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0\n        && (force_format || virtcol > (colnr_T)textwidth)) {\n      do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);\n      // It may be required to save for undo again, e.g. when setline()\n      // was called.\n      ins_need_undo = true;\n    }\n    if (do_internal) {\n      internal_format(textwidth, second_indent, flags, c == NUL, c);\n    }\n  }\n\n  if (c == NUL) {           // only formatting was wanted\n    return;\n  }\n\n  // Check whether this character should end a comment.\n  if (did_ai && c == end_comment_pending) {\n    char_u *line;\n    char_u lead_end[COM_MAX_LEN];  // end-comment string\n    int middle_len, end_len;\n    int i;\n\n    /*\n     * Need to remove existing (middle) comment leader and insert end\n     * comment leader.  First, check what comment leader we can find.\n     */\n    i = get_leader_len(line = get_cursor_line_ptr(), &p, false, true);\n    if (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL) {  // Just checking\n      // Skip middle-comment string\n      while (*p && p[-1] != ':') {  // find end of middle flags\n        p++;\n      }\n      middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n      // Don't count trailing white space for middle_len\n      while (middle_len > 0 && ascii_iswhite(lead_end[middle_len - 1])) {\n        middle_len--;\n      }\n\n      // Find the end-comment string\n      while (*p && p[-1] != ':') {  // find end of end flags\n        p++;\n      }\n      end_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n      // Skip white space before the cursor\n      i = curwin->w_cursor.col;\n      while (--i >= 0 && ascii_iswhite(line[i])) {\n        ;\n      }\n      i++;\n\n      // Skip to before the middle leader\n      i -= middle_len;\n\n      // Check some expected things before we go on\n      if (i >= 0 && lead_end[end_len - 1] == end_comment_pending) {\n        // Backspace over all the stuff we want to replace\n        backspace_until_column(i);\n\n        // Insert the end-comment string, except for the last\n        // character, which will get inserted as normal later.\n        ins_bytes_len(lead_end, end_len - 1);\n      }\n    }\n  }\n  end_comment_pending = NUL;\n\n  did_ai = false;\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n\n  // If there's any pending input, grab up to INPUT_BUFLEN at once.\n  // This speeds up normal text input considerably.\n  // Don't do this when 'cindent' or 'indentexpr' is set, because we might\n  // need to re-indent at a ':', or any other character (but not what\n  // 'paste' is set)..\n  // Don't do this when there an InsertCharPre autocommand is defined,\n  // because we need to fire the event for every character.\n  // Do the check for InsertCharPre before the call to vpeekc() because the\n  // InsertCharPre autocommand could change the input buffer.\n  if (!ISSPECIAL(c)\n      && (utf_char2len(c) == 1)\n      && !has_event(EVENT_INSERTCHARPRE)\n      && vpeekc() != NUL\n      && !(State & REPLACE_FLAG)\n      && !cindent_on()\n      && !p_ri) {\n#define INPUT_BUFLEN 100\n    char_u buf[INPUT_BUFLEN + 1];\n    int i;\n    colnr_T virtcol = 0;\n\n    buf[0] = c;\n    i = 1;\n    if (textwidth > 0) {\n      virtcol = get_nolist_virtcol();\n    }\n    // Stop the string when:\n    // - no more chars available\n    // - finding a special character (command key)\n    // - buffer is full\n    // - running into the 'textwidth' boundary\n    // - need to check for abbreviation: A non-word char after a word-char\n    while ((c = vpeekc()) != NUL\n           && !ISSPECIAL(c)\n           && MB_BYTE2LEN(c) == 1\n           && i < INPUT_BUFLEN\n           && (textwidth == 0\n               || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)\n           && !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1]))) {\n      c = vgetc();\n      if (p_hkmap && KeyTyped) {\n        c = hkmap(c);                       // Hebrew mode mapping\n      }\n      buf[i++] = c;\n    }\n\n    do_digraph(-1);                     // clear digraphs\n    do_digraph(buf[i-1]);               // may be the start of a digraph\n    buf[i] = NUL;\n    ins_str(buf);\n    if (flags & INSCHAR_CTRLV) {\n      redo_literal(*buf);\n      i = 1;\n    } else {\n      i = 0;\n    }\n    if (buf[i] != NUL) {\n      AppendToRedobuffLit(buf + i, -1);\n    }\n  } else {\n    int cc;\n\n    if ((cc = utf_char2len(c)) > 1) {\n      char_u buf[MB_MAXBYTES + 1];\n\n      utf_char2bytes(c, buf);\n      buf[cc] = NUL;\n      ins_char_bytes(buf, cc);\n      AppendCharToRedobuff(c);\n    } else {\n      ins_char(c);\n      if (flags & INSCHAR_CTRLV) {\n        redo_literal(c);\n      } else {\n        AppendCharToRedobuff(c);\n      }\n    }\n  }\n}\n\n/// Format text at the current insert position.\n///\n/// If the INSCHAR_COM_LIST flag is present, then the value of second_indent\n/// will be the comment leader length sent to open_line().\n///\n/// @param c  character to be inserted (can be NUL)\nstatic void internal_format(int textwidth, int second_indent, int flags, int format_only, int c)\n{\n  int cc;\n  int save_char = NUL;\n  bool haveto_redraw = false;\n  const bool fo_ins_blank = has_format_option(FO_INS_BLANK);\n  const bool fo_multibyte = has_format_option(FO_MBYTE_BREAK);\n  const bool fo_rigor_tw  = has_format_option(FO_RIGOROUS_TW);\n  const bool fo_white_par = has_format_option(FO_WHITE_PAR);\n  bool first_line = true;\n  colnr_T leader_len;\n  bool no_leader = false;\n  int do_comments = (flags & INSCHAR_DO_COM);\n  int has_lbr = curwin->w_p_lbr;\n\n  // make sure win_lbr_chartabsize() counts correctly\n  curwin->w_p_lbr = false;\n\n  /*\n   * When 'ai' is off we don't want a space under the cursor to be\n   * deleted.  Replace it with an 'x' temporarily.\n   */\n  if (!curbuf->b_p_ai\n      && !(State & VREPLACE_FLAG)) {\n    cc = gchar_cursor();\n    if (ascii_iswhite(cc)) {\n      save_char = cc;\n      pchar_cursor('x');\n    }\n  }\n\n  /*\n   * Repeat breaking lines, until the current line is not too long.\n   */\n  while (!got_int) {\n    int startcol;                       // Cursor column at entry\n    int wantcol;                        // column at textwidth border\n    int foundcol;                       // column for start of spaces\n    int end_foundcol = 0;               // column for start of word\n    colnr_T len;\n    colnr_T virtcol;\n    int orig_col = 0;\n    char_u *saved_text = NULL;\n    colnr_T col;\n    colnr_T end_col;\n\n    virtcol = get_nolist_virtcol()\n              + char2cells(c != NUL ? c : gchar_cursor());\n    if (virtcol <= (colnr_T)textwidth) {\n      break;\n    }\n\n    if (no_leader) {\n      do_comments = false;\n    } else if (!(flags & INSCHAR_FORMAT)\n               && has_format_option(FO_WRAP_COMS)) {\n      do_comments = true;\n    }\n\n    // Don't break until after the comment leader\n    if (do_comments) {\n      leader_len = get_leader_len(get_cursor_line_ptr(), NULL, false, true);\n    } else {\n      leader_len = 0;\n    }\n\n    // If the line doesn't start with a comment leader, then don't\n    // start one in a following broken line.  Avoids that a %word\n    // moved to the start of the next line causes all following lines\n    // to start with %.\n    if (leader_len == 0) {\n      no_leader = true;\n    }\n    if (!(flags & INSCHAR_FORMAT)\n        && leader_len == 0\n        && !has_format_option(FO_WRAP)) {\n      break;\n    }\n    if ((startcol = curwin->w_cursor.col) == 0) {\n      break;\n    }\n\n    // find column of textwidth border\n    coladvance((colnr_T)textwidth);\n    wantcol = curwin->w_cursor.col;\n\n    curwin->w_cursor.col = startcol;\n    foundcol = 0;\n    int skip_pos = 0;\n\n    /*\n     * Find position to break at.\n     * Stop at first entered white when 'formatoptions' has 'v'\n     */\n    while ((!fo_ins_blank && !has_format_option(FO_INS_VI))\n           || (flags & INSCHAR_FORMAT)\n           || curwin->w_cursor.lnum != Insstart.lnum\n           || curwin->w_cursor.col >= Insstart.col) {\n      if (curwin->w_cursor.col == startcol && c != NUL) {\n        cc = c;\n      } else {\n        cc = gchar_cursor();\n      }\n      if (WHITECHAR(cc)) {\n        // remember position of blank just before text\n        end_col = curwin->w_cursor.col;\n\n        // find start of sequence of blanks\n        int wcc = 0;  // counter for whitespace chars\n        while (curwin->w_cursor.col > 0 && WHITECHAR(cc)) {\n          dec_cursor();\n          cc = gchar_cursor();\n\n          // Increment count of how many whitespace chars in this\n          // group; we only need to know if it's more than one.\n          if (wcc < 2) {\n            wcc++;\n          }\n        }\n        if (curwin->w_cursor.col == 0 && WHITECHAR(cc)) {\n          break;                        // only spaces in front of text\n        }\n\n        // Don't break after a period when 'formatoptions' has 'p' and\n        // there are less than two spaces.\n        if (has_format_option(FO_PERIOD_ABBR) && cc == '.' && wcc < 2) {\n          continue;\n        }\n\n        // Don't break until after the comment leader\n        if (curwin->w_cursor.col < leader_len) {\n          break;\n        }\n\n        if (has_format_option(FO_ONE_LETTER)) {\n          // do not break after one-letter words\n          if (curwin->w_cursor.col == 0) {\n            break;              // one-letter word at begin\n          }\n          // do not break \"#a b\" when 'tw' is 2\n          if (curwin->w_cursor.col <= leader_len) {\n            break;\n          }\n          col = curwin->w_cursor.col;\n          dec_cursor();\n          cc = gchar_cursor();\n\n          if (WHITECHAR(cc)) {\n            continue;                   // one-letter, continue\n          }\n          curwin->w_cursor.col = col;\n        }\n\n        inc_cursor();\n\n        end_foundcol = end_col + 1;\n        foundcol = curwin->w_cursor.col;\n        if (curwin->w_cursor.col <= (colnr_T)wantcol) {\n          break;\n        }\n      } else if ((cc >= 0x100 || !utf_allow_break_before(cc))\n                 && fo_multibyte) {\n        int ncc;\n        bool allow_break;\n\n        // Break after or before a multi-byte character.\n        if (curwin->w_cursor.col != startcol) {\n          // Don't break until after the comment leader\n          if (curwin->w_cursor.col < leader_len) {\n            break;\n          }\n          col = curwin->w_cursor.col;\n          inc_cursor();\n          ncc = gchar_cursor();\n          allow_break = utf_allow_break(cc, ncc);\n\n          // If we have already checked this position, skip!\n          if (curwin->w_cursor.col != skip_pos && allow_break) {\n            foundcol = curwin->w_cursor.col;\n            end_foundcol = foundcol;\n            if (curwin->w_cursor.col <= (colnr_T)wantcol) {\n              break;\n            }\n          }\n          curwin->w_cursor.col = col;\n        }\n\n        if (curwin->w_cursor.col == 0) {\n          break;\n        }\n\n        ncc = cc;\n        col = curwin->w_cursor.col;\n\n        dec_cursor();\n        cc = gchar_cursor();\n\n        if (WHITECHAR(cc)) {\n          continue;                     // break with space\n        }\n        // Don't break until after the comment leader.\n        if (curwin->w_cursor.col < leader_len) {\n          break;\n        }\n\n        curwin->w_cursor.col = col;\n        skip_pos = curwin->w_cursor.col;\n\n        allow_break = utf_allow_break(cc, ncc);\n\n        // Must handle this to respect line break prohibition.\n        if (allow_break) {\n          foundcol = curwin->w_cursor.col;\n          end_foundcol = foundcol;\n        }\n        if (curwin->w_cursor.col <= (colnr_T)wantcol) {\n          const bool ncc_allow_break = utf_allow_break_before(ncc);\n\n          if (allow_break) {\n            break;\n          }\n          if (!ncc_allow_break && !fo_rigor_tw) {\n            // Enable at most 1 punct hang outside of textwidth.\n            if (curwin->w_cursor.col == startcol) {\n              // We are inserting a non-breakable char, postpone\n              // line break check to next insert.\n              end_foundcol = foundcol = 0;\n              break;\n            }\n\n            // Neither cc nor ncc is NUL if we are here, so\n            // it's safe to inc_cursor.\n            col = curwin->w_cursor.col;\n\n            inc_cursor();\n            cc  = ncc;\n            ncc = gchar_cursor();\n            // handle insert\n            ncc = (ncc != NUL) ? ncc : c;\n\n            allow_break = utf_allow_break(cc, ncc);\n\n            if (allow_break) {\n              // Break only when we are not at end of line.\n              end_foundcol = foundcol = ncc == NUL? 0 : curwin->w_cursor.col;\n              break;\n            }\n            curwin->w_cursor.col = col;\n          }\n        }\n      }\n      if (curwin->w_cursor.col == 0) {\n        break;\n      }\n      dec_cursor();\n    }\n\n    if (foundcol == 0) {                // no spaces, cannot break line\n      curwin->w_cursor.col = startcol;\n      break;\n    }\n\n    // Going to break the line, remove any \"$\" now.\n    undisplay_dollar();\n\n    /*\n     * Offset between cursor position and line break is used by replace\n     * stack functions.  VREPLACE does not use this, and backspaces\n     * over the text instead.\n     */\n    if (State & VREPLACE_FLAG) {\n      orig_col = startcol;              // Will start backspacing from here\n    } else {\n      replace_offset = startcol - end_foundcol;\n    }\n\n    /*\n     * adjust startcol for spaces that will be deleted and\n     * characters that will remain on top line\n     */\n    curwin->w_cursor.col = foundcol;\n    while ((cc = gchar_cursor(), WHITECHAR(cc))\n           && (!fo_white_par || curwin->w_cursor.col < startcol)) {\n      inc_cursor();\n    }\n    startcol -= curwin->w_cursor.col;\n    if (startcol < 0) {\n      startcol = 0;\n    }\n\n    if (State & VREPLACE_FLAG) {\n      /*\n       * In VREPLACE mode, we will backspace over the text to be\n       * wrapped, so save a copy now to put on the next line.\n       */\n      saved_text = vim_strsave(get_cursor_pos_ptr());\n      curwin->w_cursor.col = orig_col;\n      saved_text[startcol] = NUL;\n\n      // Backspace over characters that will move to the next line\n      if (!fo_white_par) {\n        backspace_until_column(foundcol);\n      }\n    } else {\n      // put cursor after pos. to break line\n      if (!fo_white_par) {\n        curwin->w_cursor.col = foundcol;\n      }\n    }\n\n    /*\n     * Split the line just before the margin.\n     * Only insert/delete lines, but don't really redraw the window.\n     */\n    open_line(FORWARD, OPENLINE_DELSPACES + OPENLINE_MARKFIX\n              + (fo_white_par ? OPENLINE_KEEPTRAIL : 0)\n              + (do_comments ? OPENLINE_DO_COM : 0)\n              + ((flags & INSCHAR_COM_LIST) ? OPENLINE_COM_LIST : 0)\n              , ((flags & INSCHAR_COM_LIST) ? second_indent : old_indent));\n    if (!(flags & INSCHAR_COM_LIST)) {\n      old_indent = 0;\n    }\n\n    replace_offset = 0;\n    if (first_line) {\n      if (!(flags & INSCHAR_COM_LIST)) {\n        // This section is for auto-wrap of numeric lists.  When not\n        // in insert mode (i.e. format_lines()), the INSCHAR_COM_LIST\n        // flag will be set and open_line() will handle it (as seen\n        // above).  The code here (and in get_number_indent()) will\n        // recognize comments if needed...\n        if (second_indent < 0 && has_format_option(FO_Q_NUMBER)) {\n          second_indent = get_number_indent(curwin->w_cursor.lnum - 1);\n        }\n        if (second_indent >= 0) {\n          if (State & VREPLACE_FLAG) {\n            change_indent(INDENT_SET, second_indent, false, NUL, true);\n          } else if (leader_len > 0 && second_indent - leader_len > 0) {\n            int padding = second_indent - leader_len;\n\n            // We started at the first_line of a numbered list\n            // that has a comment.  the open_line() function has\n            // inserted the proper comment leader and positioned\n            // the cursor at the end of the split line.  Now we\n            // add the additional whitespace needed after the\n            // comment leader for the numbered list.\n            for (int i = 0; i < padding; i++) {\n              ins_str((char_u *)\" \");\n            }\n            changed_bytes(curwin->w_cursor.lnum, leader_len);\n          } else {\n            (void)set_indent(second_indent, SIN_CHANGED);\n          }\n        }\n      }\n      first_line = false;\n    }\n\n    if (State & VREPLACE_FLAG) {\n      /*\n       * In VREPLACE mode we have backspaced over the text to be\n       * moved, now we re-insert it into the new line.\n       */\n      ins_bytes(saved_text);\n      xfree(saved_text);\n    } else {\n      /*\n       * Check if cursor is not past the NUL off the line, cindent\n       * may have added or removed indent.\n       */\n      curwin->w_cursor.col += startcol;\n      len = (colnr_T)STRLEN(get_cursor_line_ptr());\n      if (curwin->w_cursor.col > len) {\n        curwin->w_cursor.col = len;\n      }\n    }\n\n    haveto_redraw = true;\n    can_cindent = true;\n    // moved the cursor, don't autoindent or cindent now\n    did_ai = false;\n    did_si = false;\n    can_si = false;\n    can_si_back = false;\n    line_breakcheck();\n  }\n\n  if (save_char != NUL) {               // put back space after cursor\n    pchar_cursor(save_char);\n  }\n\n  curwin->w_p_lbr = has_lbr;\n\n  if (!format_only && haveto_redraw) {\n    update_topline(curwin);\n    redraw_curbuf_later(VALID);\n  }\n}\n\n/// Called after inserting or deleting text: When 'formatoptions' includes the\n/// 'a' flag format from the current line until the end of the paragraph.\n/// Keep the cursor at the same position relative to the text.\n/// The caller must have saved the cursor line for undo, following ones will be\n/// saved here.\n///\n/// @param trailblank  when true also format with trailing blank\n/// @param prev_line   may start in previous line\nvoid auto_format(bool trailblank, bool prev_line)\n{\n  pos_T pos;\n  colnr_T len;\n  char_u *old;\n  char_u *new, *pnew;\n  int wasatend;\n  int cc;\n\n  if (!has_format_option(FO_AUTO)) {\n    return;\n  }\n\n  pos = curwin->w_cursor;\n  old = get_cursor_line_ptr();\n\n  // may remove added space\n  check_auto_format(false);\n\n  // Don't format in Insert mode when the cursor is on a trailing blank, the\n  // user might insert normal text next.  Also skip formatting when \"1\" is\n  // in 'formatoptions' and there is a single character before the cursor.\n  // Otherwise the line would be broken and when typing another non-white\n  // next they are not joined back together.\n  wasatend = (pos.col == (colnr_T)STRLEN(old));\n  if (*old != NUL && !trailblank && wasatend) {\n    dec_cursor();\n    cc = gchar_cursor();\n    if (!WHITECHAR(cc) && curwin->w_cursor.col > 0\n        && has_format_option(FO_ONE_LETTER)) {\n      dec_cursor();\n    }\n    cc = gchar_cursor();\n    if (WHITECHAR(cc)) {\n      curwin->w_cursor = pos;\n      return;\n    }\n    curwin->w_cursor = pos;\n  }\n\n  /* With the 'c' flag in 'formatoptions' and 't' missing: only format\n   * comments. */\n  if (has_format_option(FO_WRAP_COMS) && !has_format_option(FO_WRAP)\n      && get_leader_len(old, NULL, false, true) == 0) {\n    return;\n  }\n\n  /*\n   * May start formatting in a previous line, so that after \"x\" a word is\n   * moved to the previous line if it fits there now.  Only when this is not\n   * the start of a paragraph.\n   */\n  if (prev_line && !paragraph_start(curwin->w_cursor.lnum)) {\n    --curwin->w_cursor.lnum;\n    if (u_save_cursor() == FAIL) {\n      return;\n    }\n  }\n\n  /*\n   * Do the formatting and restore the cursor position.  \"saved_cursor\" will\n   * be adjusted for the text formatting.\n   */\n  saved_cursor = pos;\n  format_lines((linenr_T)-1, FALSE);\n  curwin->w_cursor = saved_cursor;\n  saved_cursor.lnum = 0;\n\n  if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {\n    // \"cannot happen\"\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance(MAXCOL);\n  } else {\n    check_cursor_col();\n  }\n\n  // Insert mode: If the cursor is now after the end of the line while it\n  // previously wasn't, the line was broken.  Because of the rule above we\n  // need to add a space when 'w' is in 'formatoptions' to keep a paragraph\n  // formatted.\n  if (!wasatend && has_format_option(FO_WHITE_PAR)) {\n    new = get_cursor_line_ptr();\n    len = (colnr_T)STRLEN(new);\n    if (curwin->w_cursor.col == len) {\n      pnew = vim_strnsave(new, len + 2);\n      pnew[len] = ' ';\n      pnew[len + 1] = NUL;\n      ml_replace(curwin->w_cursor.lnum, pnew, false);\n      // remove the space later\n      did_add_space = true;\n    } else {\n      // may remove added space\n      check_auto_format(false);\n    }\n  }\n\n  check_cursor();\n}\n\n/// When an extra space was added to continue a paragraph for auto-formatting,\n/// delete it now.  The space must be under the cursor, just after the insert\n/// position.\n///\n/// @param end_insert  true when ending Insert mode\nstatic void check_auto_format(bool end_insert)\n{\n  int c = ' ';\n  int cc;\n\n  if (did_add_space) {\n    cc = gchar_cursor();\n    if (!WHITECHAR(cc)) {\n      // Somehow the space was removed already.\n      did_add_space = false;\n    } else {\n      if (!end_insert) {\n        inc_cursor();\n        c = gchar_cursor();\n        dec_cursor();\n      }\n      if (c != NUL) {\n        // The space is no longer at the end of the line, delete it.\n        del_char(false);\n        did_add_space = false;\n      }\n    }\n  }\n}\n\n/// Find out textwidth to be used for formatting:\n///      if 'textwidth' option is set, use it\n///      else if 'wrapmargin' option is set, use curwin->w_width_inner-'wrapmargin'\n///      if invalid value, use 0.\n///      Set default to window width (maximum 79) for \"gq\" operator.\n///\n/// @param ff  force formatting (for \"gq\" command)\nint comp_textwidth(bool ff)\n{\n  int textwidth = curbuf->b_p_tw;\n  if (textwidth == 0 && curbuf->b_p_wm) {\n    // The width is the window width minus 'wrapmargin' minus all the\n    // things that add to the margin.\n    textwidth = curwin->w_width_inner - curbuf->b_p_wm;\n    if (cmdwin_type != 0) {\n      textwidth -= 1;\n    }\n    textwidth -= win_fdccol_count(curwin);\n    textwidth -= win_signcol_count(curwin);\n\n    if (curwin->w_p_nu || curwin->w_p_rnu) {\n      textwidth -= 8;\n    }\n  }\n  if (textwidth < 0) {\n    textwidth = 0;\n  }\n  if (ff && textwidth == 0) {\n    textwidth = curwin->w_width_inner - 1;\n    if (textwidth > 79) {\n      textwidth = 79;\n    }\n  }\n  return textwidth;\n}\n\n/*\n * Put a character in the redo buffer, for when just after a CTRL-V.\n */\nstatic void redo_literal(int c)\n{\n  char buf[10];\n\n  // Only digits need special treatment.  Translate them into a string of\n  // three digits.\n  if (ascii_isdigit(c)) {\n    vim_snprintf(buf, sizeof(buf), \"%03d\", c);\n    AppendToRedobuff(buf);\n  } else {\n    AppendCharToRedobuff(c);\n  }\n}\n\n/// start_arrow() is called when an arrow key is used in insert mode.\n/// For undo/redo it resembles hitting the <ESC> key.\n///\n/// @param end_insert_pos  can be NULL\nstatic void start_arrow(pos_T *end_insert_pos)\n{\n  start_arrow_common(end_insert_pos, true);\n}\n\n/// Like start_arrow() but with end_change argument.\n/// Will prepare for redo of CTRL-G U if \"end_change\" is false.\n///\n/// @param end_insert_pos  can be NULL\n/// @param end_change      end undoable change\nstatic void start_arrow_with_change(pos_T *end_insert_pos, bool end_change)\n{\n  start_arrow_common(end_insert_pos, end_change);\n  if (!end_change) {\n    AppendCharToRedobuff(Ctrl_G);\n    AppendCharToRedobuff('U');\n  }\n}\n\n/// @param end_insert_pos  can be NULL\n/// @param end_change      end undoable change\nstatic void start_arrow_common(pos_T *end_insert_pos, bool end_change)\n{\n  if (!arrow_used && end_change) {  // something has been inserted\n    AppendToRedobuff(ESC_STR);\n    stop_insert(end_insert_pos, false, false);\n    arrow_used = true;  // This means we stopped the current insert.\n  }\n  check_spell_redraw();\n}\n\n/*\n * If we skipped highlighting word at cursor, do it now.\n * It may be skipped again, thus reset spell_redraw_lnum first.\n */\nstatic void check_spell_redraw(void)\n{\n  if (spell_redraw_lnum != 0) {\n    linenr_T lnum = spell_redraw_lnum;\n\n    spell_redraw_lnum = 0;\n    redrawWinline(curwin, lnum);\n  }\n}\n\n/*\n * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly\n * spelled word, if there is one.\n */\nstatic void spell_back_to_badword(void)\n{\n  pos_T tpos = curwin->w_cursor;\n  spell_bad_len = spell_move_to(curwin, BACKWARD, true, true, NULL);\n  if (curwin->w_cursor.col != tpos.col) {\n    start_arrow(&tpos);\n  }\n}\n\n/*\n * stop_arrow() is called before a change is made in insert mode.\n * If an arrow key has been used, start a new insertion.\n * Returns FAIL if undo is impossible, shouldn't insert then.\n */\nint stop_arrow(void)\n{\n  if (arrow_used) {\n    Insstart = curwin->w_cursor;  //new insertion starts here\n    if (Insstart.col > Insstart_orig.col && !ins_need_undo) {\n      // Don't update the original insert position when moved to the\n      // right, except when nothing was inserted yet.\n      update_Insstart_orig = false;\n    }\n    Insstart_textlen = (colnr_T)linetabsize(get_cursor_line_ptr());\n\n    if (u_save_cursor() == OK) {\n      arrow_used = false;\n      ins_need_undo = false;\n    }\n    ai_col = 0;\n    if (State & VREPLACE_FLAG) {\n      orig_line_count = curbuf->b_ml.ml_line_count;\n      vr_lines_changed = 1;\n    }\n    ResetRedobuff();\n    AppendToRedobuff(\"1i\");  // Pretend we start an insertion.\n    new_insert_skip = 2;\n  } else if (ins_need_undo) {\n    if (u_save_cursor() == OK) {\n      ins_need_undo = false;\n    }\n  }\n\n  // Always open fold at the cursor line when inserting something.\n  foldOpenCursor();\n\n  return arrow_used || ins_need_undo ? FAIL : OK;\n}\n\n/// Do a few things to stop inserting.\n/// \"end_insert_pos\" is where insert ended.  It is NULL when we already jumped\n/// to another window/buffer.\n///\n/// @param esc     called by ins_esc()\n/// @param nomove  <c-\\><c-o>, don't move cursor\nstatic void stop_insert(pos_T *end_insert_pos, int esc, int nomove)\n{\n  int cc;\n  char_u *ptr;\n\n  stop_redo_ins();\n  replace_flush();              // abandon replace stack\n\n  /*\n   * Save the inserted text for later redo with ^@ and CTRL-A.\n   * Don't do it when \"restart_edit\" was set and nothing was inserted,\n   * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n   */\n  ptr = get_inserted();\n  if (did_restart_edit == 0 || (ptr != NULL\n                                && (int)STRLEN(ptr) > new_insert_skip)) {\n    xfree(last_insert);\n    last_insert = ptr;\n    last_insert_skip = new_insert_skip;\n  } else {\n    xfree(ptr);\n  }\n\n  if (!arrow_used && end_insert_pos != NULL) {\n    // Auto-format now.  It may seem strange to do this when stopping an\n    // insertion (or moving the cursor), but it's required when appending\n    // a line and having it end in a space.  But only do it when something\n    // was actually inserted, otherwise undo won't work.\n    if (!ins_need_undo && has_format_option(FO_AUTO)) {\n      pos_T tpos = curwin->w_cursor;\n\n      // When the cursor is at the end of the line after a space the\n      // formatting will move it to the following word.  Avoid that by\n      // moving the cursor onto the space.\n      cc = 'x';\n      if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL) {\n        dec_cursor();\n        cc = gchar_cursor();\n        if (!ascii_iswhite(cc)) {\n          curwin->w_cursor = tpos;\n        }\n      }\n\n      auto_format(true, false);\n\n      if (ascii_iswhite(cc)) {\n        if (gchar_cursor() != NUL) {\n          inc_cursor();\n        }\n        /* If the cursor is still at the same character, also keep\n         * the \"coladd\". */\n        if (gchar_cursor() == NUL\n            && curwin->w_cursor.lnum == tpos.lnum\n            && curwin->w_cursor.col == tpos.col) {\n          curwin->w_cursor.coladd = tpos.coladd;\n        }\n      }\n    }\n\n    // If a space was inserted for auto-formatting, remove it now.\n    check_auto_format(true);\n\n    // If we just did an auto-indent, remove the white space from the end\n    // of the line, and put the cursor back.\n    // Do this when ESC was used or moving the cursor up/down.\n    // Check for the old position still being valid, just in case the text\n    // got changed unexpectedly.\n    if (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n                                      && curwin->w_cursor.lnum !=\n                                      end_insert_pos->lnum))\n        && end_insert_pos->lnum <= curbuf->b_ml.ml_line_count) {\n      pos_T tpos = curwin->w_cursor;\n\n      curwin->w_cursor = *end_insert_pos;\n      check_cursor_col();        // make sure it is not past the line\n      for (;; ) {\n        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0) {\n          --curwin->w_cursor.col;\n        }\n        cc = gchar_cursor();\n        if (!ascii_iswhite(cc)) {\n          break;\n        }\n        if (del_char(true) == FAIL) {\n          break;            // should not happen\n        }\n      }\n      if (curwin->w_cursor.lnum != tpos.lnum) {\n        curwin->w_cursor = tpos;\n      } else {\n        // reset tpos, could have been invalidated in the loop above\n        tpos = curwin->w_cursor;\n        tpos.col++;\n        if (cc != NUL && gchar_pos(&tpos) == NUL) {\n          ++curwin->w_cursor.col;         // put cursor back on the NUL\n        }\n      }\n\n      // <C-S-Right> may have started Visual mode, adjust the position for\n      // deleted characters.\n      if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum) {\n        int len = (int)STRLEN(get_cursor_line_ptr());\n\n        if (VIsual.col > len) {\n          VIsual.col = len;\n          VIsual.coladd = 0;\n        }\n      }\n    }\n  }\n  did_ai = false;\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n\n  // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n  // now in a different buffer.\n  if (end_insert_pos != NULL) {\n    curbuf->b_op_start = Insstart;\n    curbuf->b_op_start_orig = Insstart_orig;\n    curbuf->b_op_end = *end_insert_pos;\n  }\n}\n\n/*\n * Set the last inserted text to a single character.\n * Used for the replace command.\n */\nvoid set_last_insert(int c)\n{\n  char_u *s;\n\n  xfree(last_insert);\n  last_insert = xmalloc(MB_MAXBYTES * 3 + 5);\n  s = last_insert;\n  // Use the CTRL-V only when entering a special char\n  if (c < ' ' || c == DEL) {\n    *s++ = Ctrl_V;\n  }\n  s = add_char2buf(c, s);\n  *s++ = ESC;\n  *s++ = NUL;\n  last_insert_skip = 0;\n}\n\n#if defined(EXITFREE)\nvoid free_last_insert(void)\n{\n  XFREE_CLEAR(last_insert);\n  XFREE_CLEAR(compl_orig_text);\n}\n\n#endif\n\n/// Add character \"c\" to buffer \"s\"\n///\n/// Escapes the special meaning of K_SPECIAL and CSI, handles multi-byte\n/// characters.\n///\n/// @param[in]  c  Character to add.\n/// @param[out]  s  Buffer to add to. Must have at least MB_MAXBYTES + 1 bytes.\n///\n/// @return Pointer to after the added bytes.\nchar_u *add_char2buf(int c, char_u *s)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  char_u temp[MB_MAXBYTES + 1];\n  const int len = utf_char2bytes(c, temp);\n  for (int i = 0; i < len; i++) {\n    c = temp[i];\n    // Need to escape K_SPECIAL and CSI like in the typeahead buffer.\n    if (c == K_SPECIAL) {\n      *s++ = K_SPECIAL;\n      *s++ = KS_SPECIAL;\n      *s++ = KE_FILLER;\n    } else {\n      *s++ = c;\n    }\n  }\n  return s;\n}\n\n/*\n * move cursor to start of line\n * if flags & BL_WHITE  move to first non-white\n * if flags & BL_SOL    move to first non-white if startofline is set,\n *                          otherwise keep \"curswant\" column\n * if flags & BL_FIX    don't leave the cursor on a NUL.\n */\nvoid beginline(int flags)\n{\n  if ((flags & BL_SOL) && !p_sol) {\n    coladvance(curwin->w_curswant);\n  } else {\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n\n    if (flags & (BL_WHITE | BL_SOL)) {\n      char_u *ptr;\n\n      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)\n           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr) {\n        ++curwin->w_cursor.col;\n      }\n    }\n    curwin->w_set_curswant = TRUE;\n  }\n}\n\n/*\n * oneright oneleft cursor_down cursor_up\n *\n * Move one char {right,left,down,up}.\n * Doesn't move onto the NUL past the end of the line, unless it is allowed.\n * Return OK when successful, FAIL when we hit a line of file boundary.\n */\n\nint oneright(void)\n{\n  char_u *ptr;\n  int l;\n\n  if (virtual_active()) {\n    pos_T prevpos = curwin->w_cursor;\n\n    // Adjust for multi-wide char (excluding TAB)\n    ptr = get_cursor_pos_ptr();\n    coladvance(getviscol() + ((*ptr != TAB && vim_isprintc(utf_ptr2char(ptr))) ?\n                              ptr2cells(ptr) : 1));\n    curwin->w_set_curswant = true;\n    // Return OK if the cursor moved, FAIL otherwise (at window edge).\n    return (prevpos.col != curwin->w_cursor.col\n            || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n  }\n\n  ptr = get_cursor_pos_ptr();\n  if (*ptr == NUL) {\n    return FAIL;            // already at the very end\n  }\n\n  l = utfc_ptr2len(ptr);\n\n  // move \"l\" bytes right, but don't end up on the NUL, unless 'virtualedit'\n  // contains \"onemore\".\n  if (ptr[l] == NUL\n      && (ve_flags & VE_ONEMORE) == 0) {\n    return FAIL;\n  }\n  curwin->w_cursor.col += l;\n\n  curwin->w_set_curswant = TRUE;\n  return OK;\n}\n\nint oneleft(void)\n{\n  if (virtual_active()) {\n    int width;\n    int v = getviscol();\n\n    if (v == 0) {\n      return FAIL;\n    }\n\n    // We might get stuck on 'showbreak', skip over it.\n    width = 1;\n    for (;; ) {\n      coladvance(v - width);\n      // getviscol() is slow, skip it when 'showbreak' is empty,\n      // 'breakindent' is not set and there are no multi-byte\n      // characters\n      if (getviscol() < v) {\n        break;\n      }\n      width++;\n    }\n\n    if (curwin->w_cursor.coladd == 1) {\n      char_u *ptr;\n\n      // Adjust for multi-wide char (not a TAB)\n      ptr = get_cursor_pos_ptr();\n      if (*ptr != TAB && vim_isprintc(utf_ptr2char(ptr))\n          && ptr2cells(ptr) > 1) {\n        curwin->w_cursor.coladd = 0;\n      }\n    }\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n  }\n\n  if (curwin->w_cursor.col == 0) {\n    return FAIL;\n  }\n\n  curwin->w_set_curswant = TRUE;\n  --curwin->w_cursor.col;\n\n  // if the character on the left of the current cursor is a multi-byte\n  // character, move to its first byte\n  mb_adjust_cursor();\n  return OK;\n}\n\n/// @oaram upd_topline  When TRUE: update topline\nint cursor_up(long n, int upd_topline)\n{\n  linenr_T lnum;\n\n  if (n > 0) {\n    lnum = curwin->w_cursor.lnum;\n\n    // This fails if the cursor is already in the first line.\n    if (lnum <= 1) {\n      return FAIL;\n    }\n    if (n >= lnum) {\n      lnum = 1;\n    } else if (hasAnyFolding(curwin)) {\n      /*\n       * Count each sequence of folded lines as one logical line.\n       */\n      // go to the start of the current fold\n      (void)hasFolding(lnum, &lnum, NULL);\n\n      while (n--) {\n        // move up one line\n        lnum--;\n        if (lnum <= 1) {\n          break;\n        }\n        // If we entered a fold, move to the beginning, unless in\n        // Insert mode or when 'foldopen' contains \"all\": it will open\n        // in a moment.\n        if (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL))) {\n          (void)hasFolding(lnum, &lnum, NULL);\n        }\n      }\n      if (lnum < 1) {\n        lnum = 1;\n      }\n    } else {\n      lnum -= n;\n    }\n    curwin->w_cursor.lnum = lnum;\n  }\n\n  // try to advance to the column we want to be at\n  coladvance(curwin->w_curswant);\n\n  if (upd_topline) {\n    update_topline(curwin);           // make sure curwin->w_topline is valid\n  }\n\n  return OK;\n}\n\n/// Cursor down a number of logical lines.\n///\n/// @param upd_topline  When TRUE: update topline\nint cursor_down(long n, int upd_topline)\n{\n  linenr_T lnum;\n\n  if (n > 0) {\n    lnum = curwin->w_cursor.lnum;\n    // Move to last line of fold, will fail if it's the end-of-file.\n    (void)hasFolding(lnum, NULL, &lnum);\n\n    // This fails if the cursor is already in the last line.\n    if (lnum >= curbuf->b_ml.ml_line_count) {\n      return FAIL;\n    }\n    if (lnum + n >= curbuf->b_ml.ml_line_count) {\n      lnum = curbuf->b_ml.ml_line_count;\n    } else if (hasAnyFolding(curwin)) {\n      linenr_T last;\n\n      // count each sequence of folded lines as one logical line\n      while (n--) {\n        if (hasFolding(lnum, NULL, &last)) {\n          lnum = last + 1;\n        } else {\n          ++lnum;\n        }\n        if (lnum >= curbuf->b_ml.ml_line_count) {\n          break;\n        }\n      }\n      if (lnum > curbuf->b_ml.ml_line_count) {\n        lnum = curbuf->b_ml.ml_line_count;\n      }\n    } else {\n      lnum += n;\n    }\n    curwin->w_cursor.lnum = lnum;\n  }\n\n  // try to advance to the column we want to be at\n  coladvance(curwin->w_curswant);\n\n  if (upd_topline) {\n    update_topline(curwin);           // make sure curwin->w_topline is valid\n  }\n\n  return OK;\n}\n\n/// Stuff the last inserted text in the read buffer.\n/// Last_insert actually is a copy of the redo buffer, so we\n/// first have to remove the command.\n///\n/// @param c       Command character to be inserted\n/// @param count   Repeat this many times\n/// @param no_esc  Don't add an ESC at the end\nint stuff_inserted(int c, long count, int no_esc)\n{\n  char_u *esc_ptr;\n  char_u *ptr;\n  char_u *last_ptr;\n  char_u last = NUL;\n\n  ptr = get_last_insert();\n  if (ptr == NULL) {\n    EMSG(_(e_noinstext));\n    return FAIL;\n  }\n\n  // may want to stuff the command character, to start Insert mode\n  if (c != NUL) {\n    stuffcharReadbuff(c);\n  }\n  if ((esc_ptr = STRRCHR(ptr, ESC)) != NULL) {\n    // remove the ESC.\n    *esc_ptr = NUL;\n  }\n\n  // when the last char is either \"0\" or \"^\" it will be quoted if no ESC\n  // comes after it OR if it will inserted more than once and \"ptr\"\n  // starts with ^D.  -- Acevedo\n  last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;\n  if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')\n      && (no_esc || (*ptr == Ctrl_D && count > 1))) {\n    last = *last_ptr;\n    *last_ptr = NUL;\n  }\n\n  do {\n    stuffReadbuff((const char *)ptr);\n    // A trailing \"0\" is inserted as \"<C-V>048\", \"^\" as \"<C-V>^\".\n    if (last) {\n      stuffReadbuff((last == '0'\n                     ? \"\\026\\060\\064\\070\"\n                     : \"\\026^\"));\n    }\n  } while (--count > 0);\n\n  if (last) {\n    *last_ptr = last;\n  }\n\n  if (esc_ptr != NULL) {\n    *esc_ptr = ESC;         // put the ESC back\n  }\n\n  // may want to stuff a trailing ESC, to get out of Insert mode\n  if (!no_esc) {\n    stuffcharReadbuff(ESC);\n  }\n\n  return OK;\n}\n\nchar_u *get_last_insert(void)\n{\n  if (last_insert == NULL) {\n    return NULL;\n  }\n  return last_insert + last_insert_skip;\n}\n\n/*\n * Get last inserted string, and remove trailing <Esc>.\n * Returns pointer to allocated memory (must be freed) or NULL.\n */\nchar_u *get_last_insert_save(void)\n{\n  char_u *s;\n  int len;\n\n  if (last_insert == NULL) {\n    return NULL;\n  }\n  s = vim_strsave(last_insert + last_insert_skip);\n  len = (int)STRLEN(s);\n  if (len > 0 && s[len - 1] == ESC) {         // remove trailing ESC\n    s[len - 1] = NUL;\n  }\n\n  return s;\n}\n\n/// Check the word in front of the cursor for an abbreviation.\n/// Called when the non-id character \"c\" has been entered.\n/// When an abbreviation is recognized it is removed from the text and\n/// the replacement string is inserted in typebuf.tb_buf[], followed by \"c\".\n///\n/// @param  c  character\n///\n/// @return true if the word is a known abbreviation.\nstatic bool echeck_abbr(int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Don't check for abbreviation in paste mode, when disabled and just\n  // after moving around with cursor keys.\n  if (p_paste || no_abbr || arrow_used) {\n    return false;\n  }\n\n  return check_abbr(c, get_cursor_line_ptr(), curwin->w_cursor.col,\n                    curwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);\n}\n\n/*\n * replace-stack functions\n *\n * When replacing characters, the replaced characters are remembered for each\n * new character.  This is used to re-insert the old text when backspacing.\n *\n * There is a NUL headed list of characters for each character that is\n * currently in the file after the insertion point.  When BS is used, one NUL\n * headed list is put back for the deleted character.\n *\n * For a newline, there are two NUL headed lists.  One contains the characters\n * that the NL replaced.  The extra one stores the characters after the cursor\n * that were deleted (always white space).\n */\n\nstatic char_u *replace_stack = NULL;\nstatic ssize_t replace_stack_nr = 0;           // next entry in replace stack\nstatic ssize_t replace_stack_len = 0;          // max. number of entries\n\n/// Push character that is replaced onto the the replace stack.\n///\n/// replace_offset is normally 0, in which case replace_push will add a new\n/// character at the end of the stack.  If replace_offset is not 0, that many\n/// characters will be left on the stack above the newly inserted character.\n///\n/// @param c character that is replaced (NUL is none)\nvoid replace_push(int c)\n{\n  if (replace_stack_nr < replace_offset) {  // nothing to do\n    return;\n  }\n\n  if (replace_stack_len <= replace_stack_nr) {\n    replace_stack_len += 50;\n    replace_stack = xrealloc(replace_stack, replace_stack_len);\n  }\n  char_u *p = replace_stack + replace_stack_nr - replace_offset;\n  if (replace_offset) {\n    memmove(p + 1, p, replace_offset);\n  }\n  *p = (char_u)c;\n  ++replace_stack_nr;\n}\n\n/*\n * Push a character onto the replace stack.  Handles a multi-byte character in\n * reverse byte order, so that the first byte is popped off first.\n * Return the number of bytes done (includes composing characters).\n */\nint replace_push_mb(char_u *p)\n{\n  int l = (*mb_ptr2len)(p);\n  int j;\n\n  for (j = l - 1; j >= 0; --j) {\n    replace_push(p[j]);\n  }\n  return l;\n}\n\n/// Pop one item from the replace stack.\n///\n/// @return -1 if stack is empty, replaced character or NUL otherwise\nstatic int replace_pop(void)\n{\n  return (replace_stack_nr == 0) ? -1 : (int)replace_stack[--replace_stack_nr];\n}\n\n/// Join the top two items on the replace stack.  This removes to \"off\"'th NUL\n/// encountered.\n///\n/// @param off  offset for which NUL to remove\nstatic void replace_join(int off)\n{\n  int i;\n\n  for (i = replace_stack_nr; --i >= 0; ) {\n    if (replace_stack[i] == NUL && off-- <= 0) {\n      --replace_stack_nr;\n      memmove(replace_stack + i, replace_stack + i + 1,\n              (size_t)(replace_stack_nr - i));\n      return;\n    }\n  }\n}\n\n/*\n * Pop bytes from the replace stack until a NUL is found, and insert them\n * before the cursor.  Can only be used in REPLACE or VREPLACE mode.\n */\nstatic void replace_pop_ins(void)\n{\n  int cc;\n  int oldState = State;\n\n  State = NORMAL;                       // don't want REPLACE here\n  while ((cc = replace_pop()) > 0) {\n    mb_replace_pop_ins(cc);\n    dec_cursor();\n  }\n  State = oldState;\n}\n\n/*\n * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it\n * indicates a multi-byte char, pop the other bytes too.\n */\nstatic void mb_replace_pop_ins(int cc)\n{\n  int n;\n  char_u buf[MB_MAXBYTES + 1];\n  int i;\n  int c;\n\n  if ((n = MB_BYTE2LEN(cc)) > 1) {\n    buf[0] = cc;\n    for (i = 1; i < n; ++i) {\n      buf[i] = replace_pop();\n    }\n    ins_bytes_len(buf, n);\n  } else {\n    ins_char(cc);\n  }\n\n  // Handle composing chars.\n  for (;; ) {\n    c = replace_pop();\n    if (c == -1) {                // stack empty\n      break;\n    }\n    if ((n = MB_BYTE2LEN(c)) == 1) {\n      // Not a multi-byte char, put it back.\n      replace_push(c);\n      break;\n    } else {\n      buf[0] = c;\n      assert(n > 1);\n      for (i = 1; i < n; i++) {\n        buf[i] = replace_pop();\n      }\n      if (utf_iscomposing(utf_ptr2char(buf))) {\n        ins_bytes_len(buf, n);\n      } else {\n        // Not a composing char, put it back.\n        for (i = n - 1; i >= 0; i--) {\n          replace_push(buf[i]);\n        }\n        break;\n      }\n    }\n  }\n}\n\n/*\n * make the replace stack empty\n * (called when exiting replace mode)\n */\nstatic void replace_flush(void)\n{\n  XFREE_CLEAR(replace_stack);\n  replace_stack_len = 0;\n  replace_stack_nr = 0;\n}\n\n/*\n * Handle doing a BS for one character.\n * cc < 0: replace stack empty, just move cursor\n * cc == 0: character was inserted, delete it\n * cc > 0: character was replaced, put cc (first byte of original char) back\n * and check for more characters to be put back\n * When \"limit_col\" is >= 0, don't delete before this column.  Matters when\n * using composing characters, use del_char_after_col() instead of del_char().\n */\nstatic void replace_do_bs(int limit_col)\n{\n  int cc;\n  int orig_len = 0;\n  int ins_len;\n  int orig_vcols = 0;\n  colnr_T start_vcol;\n  char_u *p;\n  int i;\n  int vcol;\n  const int l_State = State;\n\n  cc = replace_pop();\n  if (cc > 0) {\n    if (l_State & VREPLACE_FLAG) {\n      // Get the number of screen cells used by the character we are\n      // going to delete.\n      getvcol(curwin, &curwin->w_cursor, NULL, &start_vcol, NULL);\n      orig_vcols = win_chartabsize(curwin, get_cursor_pos_ptr(), start_vcol);\n    }\n    (void)del_char_after_col(limit_col);\n    if (l_State & VREPLACE_FLAG) {\n      orig_len = (int)STRLEN(get_cursor_pos_ptr());\n    }\n    replace_push(cc);\n    replace_pop_ins();\n\n    if (l_State & VREPLACE_FLAG) {\n      // Get the number of screen cells used by the inserted characters\n      p = get_cursor_pos_ptr();\n      ins_len = (int)STRLEN(p) - orig_len;\n      vcol = start_vcol;\n      for (i = 0; i < ins_len; i++) {\n        vcol += win_chartabsize(curwin, p + i, vcol);\n        i += (*mb_ptr2len)(p) - 1;\n      }\n      vcol -= start_vcol;\n\n      // Delete spaces that were inserted after the cursor to keep the\n      // text aligned.\n      curwin->w_cursor.col += ins_len;\n      while (vcol > orig_vcols && gchar_cursor() == ' ') {\n        del_char(false);\n        orig_vcols++;\n      }\n      curwin->w_cursor.col -= ins_len;\n    }\n\n    // mark the buffer as changed and prepare for displaying\n    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n  } else if (cc == 0) {\n    (void)del_char_after_col(limit_col);\n  }\n}\n\n/// Check that C-indenting is on.\nstatic bool cindent_on(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return !p_paste && (curbuf->b_p_cin || *curbuf->b_p_inde != NUL);\n}\n\n/*\n * Re-indent the current line, based on the current contents of it and the\n * surrounding lines. Fixing the cursor position seems really easy -- I'm very\n * confused what all the part that handles Control-T is doing that I'm not.\n * \"get_the_indent\" should be get_c_indent, get_expr_indent or get_lisp_indent.\n */\nvoid fixthisline(IndentGetter get_the_indent)\n{\n  int amount = get_the_indent();\n\n  if (amount >= 0) {\n    change_indent(INDENT_SET, amount, false, 0, true);\n    if (linewhite(curwin->w_cursor.lnum)) {\n      did_ai = true;  // delete the indent if the line stays empty\n    }\n  }\n}\n\nvoid fix_indent(void) {\n  if (p_paste) {\n    return;\n  }\n  if (curbuf->b_p_lisp && curbuf->b_p_ai) {\n    fixthisline(get_lisp_indent);\n  } else if (cindent_on()) {\n    do_c_expr_indent();\n  }\n}\n\n/// Check that \"cinkeys\" contains the key \"keytyped\",\n/// when == '*': Only if key is preceded with '*' (indent before insert)\n/// when == '!': Only if key is preceded with '!' (don't insert)\n/// when == ' ': Only if key is not preceded with '*' (indent afterwards)\n///\n/// \"keytyped\" can have a few special values:\n/// KEY_OPEN_FORW :\n/// KEY_OPEN_BACK :\n/// KEY_COMPLETE  : Just finished completion.\n///\n/// @param  keytyped       key that was typed\n/// @param  when           condition on when to perform the check\n/// @param  line_is_empty  when true, accept keys with '0' before them.\nbool in_cinkeys(int keytyped, int when, bool line_is_empty)\n{\n  char_u *look;\n  int try_match;\n  int try_match_word;\n  char_u *p;\n  char_u *line;\n  bool icase;\n\n  if (keytyped == NUL) {\n    // Can happen with CTRL-Y and CTRL-E on a short line.\n    return false;\n  }\n\n  if (*curbuf->b_p_inde != NUL) {\n    look = curbuf->b_p_indk;            // 'indentexpr' set: use 'indentkeys'\n  } else {\n    look = curbuf->b_p_cink;            // 'indentexpr' empty: use 'cinkeys'\n  }\n  while (*look) {\n    /*\n     * Find out if we want to try a match with this key, depending on\n     * 'when' and a '*' or '!' before the key.\n     */\n    switch (when) {\n    case '*':\n      try_match = (*look == '*'); break;\n    case '!':\n      try_match = (*look == '!'); break;\n    default:\n      try_match = (*look != '*'); break;\n    }\n    if (*look == '*' || *look == '!') {\n      look++;\n    }\n\n    // If there is a '0', only accept a match if the line is empty.\n    // But may still match when typing last char of a word.\n    if (*look == '0') {\n      try_match_word = try_match;\n      if (!line_is_empty) {\n        try_match = false;\n      }\n      look++;\n    } else {\n      try_match_word = false;\n    }\n\n    // Does it look like a control character?\n    if (*look == '^' && look[1] >= '?' && look[1] <= '_') {\n      if (try_match && keytyped == Ctrl_chr(look[1])) {\n        return true;\n      }\n      look += 2;\n\n      // 'o' means \"o\" command, open forward.\n      // 'O' means \"O\" command, open backward.\n    } else if (*look == 'o') {\n      if (try_match && keytyped == KEY_OPEN_FORW) {\n        return true;\n      }\n      look++;\n    } else if (*look == 'O') {\n      if (try_match && keytyped == KEY_OPEN_BACK) {\n        return true;\n      }\n      look++;\n\n      // 'e' means to check for \"else\" at start of line and just before the\n      // cursor.\n    } else if (*look == 'e') {\n      if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4) {\n        p = get_cursor_line_ptr();\n        if (skipwhite(p) == p + curwin->w_cursor.col - 4\n            && STRNCMP(p + curwin->w_cursor.col - 4, \"else\", 4) == 0) {\n          return true;\n        }\n      }\n      look++;\n\n      // ':' only causes an indent if it is at the end of a label or case\n      // statement, or when it was before typing the ':' (to fix\n      // class::method for C++).\n    } else if (*look == ':') {\n      if (try_match && keytyped == ':') {\n        p = get_cursor_line_ptr();\n        if (cin_iscase(p, false) || cin_isscopedecl(p) || cin_islabel()) {\n          return true;\n        }\n        // Need to get the line again after cin_islabel().\n        p = get_cursor_line_ptr();\n        if (curwin->w_cursor.col > 2\n            && p[curwin->w_cursor.col - 1] == ':'\n            && p[curwin->w_cursor.col - 2] == ':') {\n          p[curwin->w_cursor.col - 1] = ' ';\n          const bool i = cin_iscase(p, false)\n                         || cin_isscopedecl(p)\n                         || cin_islabel();\n          p = get_cursor_line_ptr();\n          p[curwin->w_cursor.col - 1] = ':';\n          if (i) {\n            return true;\n          }\n        }\n      }\n      look++;\n\n      // Is it a key in <>, maybe?\n    } else if (*look == '<') {\n      if (try_match) {\n        // make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>,\n        // <:> and <!> so that people can re-indent on o, O, e, 0, <,\n        // >, *, : and ! keys if they really really want to.\n        if (vim_strchr((char_u *)\"<>!*oOe0:\", look[1]) != NULL\n            && keytyped == look[1]) {\n          return true;\n        }\n\n        if (keytyped == get_special_key_code(look + 1)) {\n          return true;\n        }\n      }\n      while (*look && *look != '>') {\n        look++;\n      }\n      while (*look == '>') {\n        look++;\n      }\n    }\n    /*\n     * Is it a word: \"=word\"?\n     */\n    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {\n      ++look;\n      if (*look == '~') {\n        icase = true;\n        look++;\n      } else {\n        icase = false;\n      }\n      p = vim_strchr(look, ',');\n      if (p == NULL) {\n        p = look + STRLEN(look);\n      }\n      if ((try_match || try_match_word)\n          && curwin->w_cursor.col >= (colnr_T)(p - look)) {\n        bool match = false;\n\n        if (keytyped == KEY_COMPLETE) {\n          char_u *n, *s;\n\n          /* Just completed a word, check if it starts with \"look\".\n           * search back for the start of a word. */\n          line = get_cursor_line_ptr();\n          for (s = line + curwin->w_cursor.col; s > line; s = n) {\n            n = mb_prevptr(line, s);\n            if (!vim_iswordp(n)) {\n              break;\n            }\n          }\n          assert(p >= look && (uintmax_t)(p - look) <= SIZE_MAX);\n          if (s + (p - look) <= line + curwin->w_cursor.col\n              && (icase\n                  ? mb_strnicmp(s, look, (size_t)(p - look))\n                  : STRNCMP(s, look, p - look)) == 0) {\n            match = true;\n          }\n        } else {\n          // TODO(@brammool): multi-byte\n          if (keytyped == (int)p[-1]\n              || (icase && keytyped < 256\n                  && TOLOWER_LOC(keytyped) == TOLOWER_LOC((int)p[-1]))) {\n            line = get_cursor_pos_ptr();\n            assert(p >= look && (uintmax_t)(p - look) <= SIZE_MAX);\n            if ((curwin->w_cursor.col == (colnr_T)(p - look)\n                 || !vim_iswordc(line[-(p - look) - 1]))\n                && (icase\n                    ? mb_strnicmp(line - (p - look), look, (size_t)(p - look))\n                    : STRNCMP(line - (p - look), look, p - look)) == 0) {\n              match = true;\n            }\n          }\n        }\n        if (match && try_match_word && !try_match) {\n          /* \"0=word\": Check if there are only blanks before the\n           * word. */\n          if (getwhitecols_curline() !=\n              (int)(curwin->w_cursor.col - (p - look))) {\n            match = false;\n          }\n        }\n        if (match) {\n          return true;\n        }\n      }\n      look = p;\n\n      // Ok, it's a boring generic character.\n    } else {\n      if (try_match && *look == keytyped) {\n        return true;\n      }\n      if (*look != NUL) {\n        look++;\n      }\n    }\n\n    /*\n     * Skip over \", \".\n     */\n    look = skip_to_option_part(look);\n  }\n  return false;\n}\n\n/*\n * Map Hebrew keyboard when in hkmap mode.\n */\nint hkmap(int c)\n{\n  if (p_hkmapp) {   // phonetic mapping, by Ilya Dogolazky\n    enum {\n      hALEF = 0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,\n      KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,\n      PEIsofit, PEI, ZADIsofit, ZADI, KOF, RESH, hSHIN, TAV\n    };\n    static char_u map[26] =\n    { (char_u)hALEF  /*a*/, (char_u)BET  /*b*/, (char_u)hKAF  /*c*/,\n      (char_u)DALET  /*d*/, (char_u)-1  /*e*/, (char_u)PEIsofit  /*f*/,\n      (char_u)GIMEL  /*g*/, (char_u)HEI  /*h*/, (char_u)IUD  /*i*/,\n      (char_u)HET  /*j*/, (char_u)KOF  /*k*/, (char_u)LAMED  /*l*/,\n      (char_u)MEM  /*m*/, (char_u)NUN  /*n*/, (char_u)SAMEH  /*o*/,\n      (char_u)PEI  /*p*/, (char_u)-1  /*q*/, (char_u)RESH  /*r*/,\n      (char_u)ZAIN  /*s*/, (char_u)TAV  /*t*/, (char_u)TET  /*u*/,\n      (char_u)VAV  /*v*/, (char_u)hSHIN  /*w*/, (char_u)-1  /*x*/,\n      (char_u)AIN  /*y*/, (char_u)ZADI  /*z*/ };\n\n    if (c == 'N' || c == 'M' || c == 'P' || c == 'C' || c == 'Z') {\n      return (int)(map[CharOrd(c)] - 1 + p_aleph);\n    } else if (c == 'x') {  // '-1'='sofit'\n      return 'X';\n    } else if (c == 'q') {\n      return '\\'';       // {geresh}={'}\n    } else if (c == 246) {\n      return ' ';        // \\\"o --> ' ' for a german keyboard\n    } else if (c == 228) {\n      return ' ';        // \\\"a --> ' '      -- / --\n    } else if (c == 252) {\n      return ' ';        // \\\"u --> ' '      -- / --\n    } else if (c >= 'a' && c <= 'z') {\n      // NOTE: islower() does not do the right thing for us on Linux so we\n      // do this the same was as 5.7 and previous, so it works correctly on\n      // all systems.  Specifically, the e.g. Delete and Arrow keys are\n      // munged and won't work if e.g. searching for Hebrew text.\n      return (int)(map[CharOrdLow(c)] + p_aleph);\n    } else {\n      return c;\n    }\n  } else {\n    switch (c) {\n    case '`':\n      return ';';\n    case '/':\n      return '.';\n    case '\\'':\n      return ',';\n    case 'q':\n      return '/';\n    case 'w':\n      return '\\'';\n\n    // Hebrew letters - set offset from 'a'\n    case ',':\n      c = '{'; break;\n    case '.':\n      c = 'v'; break;\n    case ';':\n      c = 't'; break;\n    default: {\n      static char str[] = \"zqbcxlsjphmkwonu ydafe rig\";\n\n      if (c < 'a' || c > 'z') {\n        return c;\n      }\n      c = str[CharOrdLow(c)];\n      break;\n    }\n    }\n\n    return (int)(CharOrdLow(c) + p_aleph);\n  }\n}\n\nstatic void ins_reg(void)\n{\n  bool need_redraw = false;\n  int regname;\n  int literally = 0;\n  int vis_active = VIsual_active;\n\n  /*\n   * If we are going to wait for a character, show a '\"'.\n   */\n  pc_status = PC_STATUS_UNSET;\n  if (redrawing() && !char_avail()) {\n    // may need to redraw when no more chars available now\n    ins_redraw(false);\n\n    edit_putchar('\"', true);\n    add_to_showcmd_c(Ctrl_R);\n  }\n\n\n  /*\n   * Don't map the register name. This also prevents the mode message to be\n   * deleted when ESC is hit.\n   */\n  ++no_mapping;\n  regname = plain_vgetc();\n  LANGMAP_ADJUST(regname, TRUE);\n  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {\n    // Get a third key for literal register insertion\n    literally = regname;\n    add_to_showcmd_c(literally);\n    regname = plain_vgetc();\n    LANGMAP_ADJUST(regname, TRUE);\n  }\n  --no_mapping;\n\n  // Don't call u_sync() while typing the expression or giving an error\n  // message for it. Only call it explicitly.\n  no_u_sync++;\n  if (regname == '=') {\n    pos_T curpos = curwin->w_cursor;\n\n    // Sync undo when evaluating the expression calls setline() or\n    // append(), so that it can be undone separately.\n    u_sync_once = 2;\n\n    regname = get_expr_register();\n\n    // Cursor may be moved back a column.\n    curwin->w_cursor = curpos;\n    check_cursor();\n  }\n  if (regname == NUL || !valid_yank_reg(regname, false)) {\n    vim_beep(BO_REG);\n    need_redraw = true;  // remove the '\"'\n  } else {\n    if (literally == Ctrl_O || literally == Ctrl_P) {\n      // Append the command to the redo buffer.\n      AppendCharToRedobuff(Ctrl_R);\n      AppendCharToRedobuff(literally);\n      AppendCharToRedobuff(regname);\n\n      do_put(regname, NULL, BACKWARD, 1,\n             (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n    } else if (insert_reg(regname, literally) == FAIL) {\n      vim_beep(BO_REG);\n      need_redraw = true;  // remove the '\"'\n    } else if (stop_insert_mode) {\n      // When the '=' register was used and a function was invoked that\n      // did \":stopinsert\" then stuff_empty() returns FALSE but we won't\n      // insert anything, need to remove the '\"'\n      need_redraw = true;\n    }\n  }\n  no_u_sync--;\n  if (u_sync_once == 1) {\n    ins_need_undo = true;\n  }\n  u_sync_once = 0;\n  clear_showcmd();\n\n  // If the inserted register is empty, we need to remove the '\"'\n  if (need_redraw || stuff_empty()) {\n    edit_unputchar();\n  }\n\n  // Disallow starting Visual mode here, would get a weird mode.\n  if (!vis_active && VIsual_active) {\n    end_visual_mode();\n  }\n}\n\n/*\n * CTRL-G commands in Insert mode.\n */\nstatic void ins_ctrl_g(void)\n{\n  int c;\n\n  // Right after CTRL-X the cursor will be after the ruler.\n  setcursor();\n\n  /*\n   * Don't map the second key. This also prevents the mode message to be\n   * deleted when ESC is hit.\n   */\n  ++no_mapping;\n  c = plain_vgetc();\n  --no_mapping;\n  switch (c) {\n  // CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col\n  case K_UP:\n  case Ctrl_K:\n  case 'k':\n    ins_up(true);\n    break;\n\n  // CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col\n  case K_DOWN:\n  case Ctrl_J:\n  case 'j':\n    ins_down(true);\n    break;\n\n  // CTRL-G u: start new undoable edit\n  case 'u':\n    u_sync(true);\n    ins_need_undo = true;\n\n    // Need to reset Insstart, esp. because a BS that joins\n    // a line to the previous one must save for undo.\n    update_Insstart_orig = false;\n    Insstart = curwin->w_cursor;\n    break;\n\n  // CTRL-G U: do not break undo with the next char.\n  case 'U':\n    // Allow one left/right cursor movement with the next char,\n    // without breaking undo.\n    dont_sync_undo = kNone;\n    break;\n\n  // Unknown CTRL-G command, reserved for future expansion.\n  default:\n    vim_beep(BO_CTRLG);\n  }\n}\n\n/*\n * CTRL-^ in Insert mode.\n */\nstatic void ins_ctrl_hat(void)\n{\n  if (map_to_exists_mode(\"\", LANGMAP, false)) {\n    // \":lmap\" mappings exists, Toggle use of \":lmap\" mappings.\n    if (State & LANGMAP) {\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n      State &= ~LANGMAP;\n    } else {\n      curbuf->b_p_iminsert = B_IMODE_LMAP;\n      State |= LANGMAP;\n    }\n  }\n  set_iminsert_global();\n  showmode();\n  // Show/unshow value of 'keymap' in status lines.\n  status_redraw_curbuf();\n}\n\n/// Handle ESC in insert mode.\n///\n/// @param[in,out]  count    repeat count of the insert command\n/// @param          cmdchar  command that started the insert\n/// @param          nomove   when true, don't move the cursor\n///\n/// @return true when leaving insert mode, false when repeating the insert.\nstatic bool ins_esc(long *count, int cmdchar, bool nomove)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  static bool disabled_redraw = false;\n\n  check_spell_redraw();\n\n  int temp = curwin->w_cursor.col;\n  if (disabled_redraw) {\n    RedrawingDisabled--;\n    disabled_redraw = false;\n  }\n  if (!arrow_used) {\n    // Don't append the ESC for \"r<CR>\" and \"grx\".\n    // When 'insertmode' is set only CTRL-L stops Insert mode.  Needed for\n    // when \"count\" is non-zero.\n    if (cmdchar != 'r' && cmdchar != 'v') {\n      AppendToRedobuff(p_im ? \"\\014\" : ESC_STR);\n    }\n\n    /*\n     * Repeating insert may take a long time.  Check for\n     * interrupt now and then.\n     */\n    if (*count > 0) {\n      line_breakcheck();\n      if (got_int) {\n        *count = 0;\n      }\n    }\n\n    if (--*count > 0) {         // repeat what was typed\n      // Vi repeats the insert without replacing characters.\n      if (vim_strchr(p_cpo, CPO_REPLCNT) != NULL) {\n        State &= ~REPLACE_FLAG;\n      }\n\n      (void)start_redo_ins();\n      if (cmdchar == 'r' || cmdchar == 'v') {\n        stuffRedoReadbuff(ESC_STR);  // No ESC in redo buffer\n      }\n      RedrawingDisabled++;\n      disabled_redraw = true;\n      // Repeat the insert\n      return false;\n    }\n    stop_insert(&curwin->w_cursor, TRUE, nomove);\n    undisplay_dollar();\n  }\n\n  if (cmdchar != 'r' && cmdchar != 'v') {\n    ins_apply_autocmds(EVENT_INSERTLEAVEPRE);\n  }\n\n  // When an autoindent was removed, curswant stays after the\n  // indent\n  if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col) {\n    curwin->w_set_curswant = true;\n  }\n\n  // Remember the last Insert position in the '^ mark.\n  if (!cmdmod.keepjumps) {\n    RESET_FMARK(&curbuf->b_last_insert, curwin->w_cursor, curbuf->b_fnum);\n  }\n\n  /*\n   * The cursor should end up on the last inserted character.\n   * Don't do it for CTRL-O, unless past the end of the line.\n   */\n  if (!nomove\n      && (curwin->w_cursor.col != 0\n          || curwin->w_cursor.coladd > 0\n          )\n      && (restart_edit == NUL\n          || (gchar_cursor() == NUL\n              && !VIsual_active\n              ))\n      && !revins_on) {\n    if (curwin->w_cursor.coladd > 0 || ve_flags == VE_ALL) {\n      oneleft();\n      if (restart_edit != NUL) {\n        curwin->w_cursor.coladd++;\n      }\n    } else {\n      curwin->w_cursor.col--;\n      // Correct cursor for multi-byte character.\n      mb_adjust_cursor();\n    }\n  }\n\n\n  State = NORMAL;\n  // need to position cursor again (e.g. when on a TAB )\n  changed_cline_bef_curs();\n\n  setmouse();\n  ui_cursor_shape();            // may show different cursor shape\n\n  // When recording or for CTRL-O, need to display the new mode.\n  // Otherwise remove the mode message.\n  if (reg_recording != 0 || restart_edit != NUL) {\n    showmode();\n  } else if (p_smd) {\n    MSG(\"\");\n  }\n  // Exit Insert mode\n  return true;\n}\n\n/*\n * Toggle language: hkmap and revins_on.\n * Move to end of reverse inserted text.\n */\nstatic void ins_ctrl_(void)\n{\n  if (revins_on && revins_chars && revins_scol >= 0) {\n    while (gchar_cursor() != NUL && revins_chars--) {\n      ++curwin->w_cursor.col;\n    }\n  }\n  p_ri = !p_ri;\n  revins_on = (State == INSERT && p_ri);\n  if (revins_on) {\n    revins_scol = curwin->w_cursor.col;\n    revins_legal++;\n    revins_chars = 0;\n    undisplay_dollar();\n  } else {\n    revins_scol = -1;\n  }\n  p_hkmap = curwin->w_p_rl ^ p_ri;        // be consistent!\n  showmode();\n}\n\n/// If 'keymodel' contains \"startsel\", may start selection.\n///\n/// @param  c  character to check\n//\n/// @return true when a CTRL-O and other keys stuffed.\nstatic bool ins_start_select(int c)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (!km_startsel) {\n    return false;\n  }\n  switch (c) {\n  case K_KHOME:\n  case K_KEND:\n  case K_PAGEUP:\n  case K_KPAGEUP:\n  case K_PAGEDOWN:\n  case K_KPAGEDOWN:\n    if (!(mod_mask & MOD_MASK_SHIFT)) {\n      break;\n    }\n    FALLTHROUGH;\n  case K_S_LEFT:\n  case K_S_RIGHT:\n  case K_S_UP:\n  case K_S_DOWN:\n  case K_S_END:\n  case K_S_HOME:\n    // Start selection right away, the cursor can move with\n    // CTRL-O when beyond the end of the line.\n    start_selection();\n\n    // Execute the key in (insert) Select mode.\n    stuffcharReadbuff(Ctrl_O);\n    if (mod_mask) {\n      const char buf[] = { (char)K_SPECIAL, (char)KS_MODIFIER,\n                           (char)(uint8_t)mod_mask, NUL };\n      stuffReadbuff(buf);\n    }\n    stuffcharReadbuff(c);\n    return true;\n  }\n  return false;\n}\n\n/*\n * <Insert> key in Insert mode: toggle insert/replace mode.\n */\nstatic void ins_insert(int replaceState)\n{\n  set_vim_var_string(VV_INSERTMODE, ((State & REPLACE_FLAG) ? \"i\" :\n                                     replaceState == VREPLACE ? \"v\" :\n                                     \"r\"), 1);\n  ins_apply_autocmds(EVENT_INSERTCHANGE);\n  if (State & REPLACE_FLAG) {\n    State = INSERT | (State & LANGMAP);\n  } else {\n    State = replaceState | (State & LANGMAP);\n  }\n  AppendCharToRedobuff(K_INS);\n  showmode();\n  ui_cursor_shape();            // may show different cursor shape\n}\n\n/*\n * Pressed CTRL-O in Insert mode.\n */\nstatic void ins_ctrl_o(void)\n{\n  if (State & VREPLACE_FLAG) {\n    restart_edit = 'V';\n  } else if (State & REPLACE_FLAG) {\n    restart_edit = 'R';\n  } else {\n    restart_edit = 'I';\n  }\n  if (virtual_active()) {\n    ins_at_eol = false;         // cursor always keeps its column\n  } else {\n    ins_at_eol = (gchar_cursor() == NUL);\n  }\n}\n\n/*\n * If the cursor is on an indent, ^T/^D insert/delete one\n * shiftwidth.  Otherwise ^T/^D behave like a \"<<\" or \">>\".\n * Always round the indent to 'shiftwidth', this is compatible\n * with vi.  But vi only supports ^T and ^D after an\n * autoindent, we support it everywhere.\n */\nstatic void ins_shift(int c, int lastc)\n{\n  if (stop_arrow() == FAIL) {\n    return;\n  }\n  AppendCharToRedobuff(c);\n\n  /*\n   * 0^D and ^^D: remove all indent.\n   */\n  if (c == Ctrl_D && (lastc == '0' || lastc == '^')\n      && curwin->w_cursor.col > 0) {\n    curwin->w_cursor.col--;\n    (void)del_char(false);              // delete the '^' or '0'\n    // In Replace mode, restore the characters that '^' or '0' replaced.\n    if (State & REPLACE_FLAG) {\n      replace_pop_ins();\n    }\n    if (lastc == '^') {\n      old_indent = get_indent();        // remember curr. indent\n    }\n    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);\n  } else {\n    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);\n  }\n\n  if (did_ai && *skipwhite(get_cursor_line_ptr()) != NUL) {\n    did_ai = false;\n  }\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n  can_cindent = false;          // no cindenting after ^D or ^T\n}\n\nstatic void ins_del(void)\n{\n  if (stop_arrow() == FAIL) {\n    return;\n  }\n  if (gchar_cursor() == NUL) {          // delete newline\n    const int temp = curwin->w_cursor.col;\n    if (!can_bs(BS_EOL)  // only if \"eol\" included\n        || do_join(2, false, true, false, false) == FAIL) {\n      vim_beep(BO_BS);\n    } else {\n      curwin->w_cursor.col = temp;\n      // Adjust orig_line_count in case more lines have been deleted than\n      // have been added. That makes sure, that open_line() later\n      // can access all buffer lines correctly\n      if (State & VREPLACE_FLAG\n          && orig_line_count > curbuf->b_ml.ml_line_count) {\n        orig_line_count = curbuf->b_ml.ml_line_count;\n      }\n    }\n  } else if (del_char(false) == FAIL) {  // delete char under cursor\n    vim_beep(BO_BS);\n  }\n  did_ai = false;\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n  AppendCharToRedobuff(K_DEL);\n}\n\n\n/*\n * Delete one character for ins_bs().\n */\nstatic void ins_bs_one(colnr_T *vcolp)\n{\n  dec_cursor();\n  getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);\n  if (State & REPLACE_FLAG) {\n    // Don't delete characters before the insert point when in\n    // Replace mode\n    if (curwin->w_cursor.lnum != Insstart.lnum\n        || curwin->w_cursor.col >= Insstart.col) {\n      replace_do_bs(-1);\n    }\n  } else {\n    (void)del_char(false);\n  }\n}\n\n/// Handle Backspace, delete-word and delete-line in Insert mode.\n///\n/// @param          c                 character that was typed\n/// @param          mode              backspace mode to use\n/// @param[in,out]  inserted_space_p  whether a space was the last\n//                                    character inserted\n///\n/// @return true when backspace was actually used.\nstatic bool ins_bs(int c, int mode, int *inserted_space_p)\n  FUNC_ATTR_NONNULL_ARG(3)\n{\n  linenr_T lnum;\n  int cc;\n  int temp = 0;                     // init for GCC\n  colnr_T save_col;\n  colnr_T mincol;\n  bool did_backspace = false;\n  int in_indent;\n  int oldState;\n  int cpc[MAX_MCO];                 // composing characters\n\n  // can't delete anything in an empty file\n  // can't backup past first character in buffer\n  // can't backup past starting point unless 'backspace' > 1\n  // can backup to a previous line if 'backspace' == 0\n  if (buf_is_empty(curbuf)\n      || (!revins_on\n          && ((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n              || (!can_bs(BS_START)\n                  && (arrow_used\n                      || (curwin->w_cursor.lnum == Insstart_orig.lnum\n                          && curwin->w_cursor.col <= Insstart_orig.col)))\n              || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n                  && curwin->w_cursor.col <= ai_col)\n              || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0)))) {\n    vim_beep(BO_BS);\n    return false;\n  }\n\n  if (stop_arrow() == FAIL) {\n    return false;\n  }\n  in_indent = inindent(0);\n  if (in_indent) {\n    can_cindent = false;\n  }\n  end_comment_pending = NUL;  // After BS, don't auto-end comment\n  if (revins_on) {            // put cursor after last inserted char\n    inc_cursor();\n  }\n  // Virtualedit:\n  //    BACKSPACE_CHAR eats a virtual space\n  //    BACKSPACE_WORD eats all coladd\n  //    BACKSPACE_LINE eats all coladd and keeps going\n  if (curwin->w_cursor.coladd > 0) {\n    if (mode == BACKSPACE_CHAR) {\n      curwin->w_cursor.coladd--;\n      return true;\n    }\n    if (mode == BACKSPACE_WORD) {\n      curwin->w_cursor.coladd = 0;\n      return true;\n    }\n    curwin->w_cursor.coladd = 0;\n  }\n\n  // Delete newline!\n  if (curwin->w_cursor.col == 0) {\n    lnum = Insstart.lnum;\n    if (curwin->w_cursor.lnum == lnum || revins_on) {\n      if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n                 (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL) {\n        return false;\n      }\n      Insstart.lnum--;\n      Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n    }\n    /*\n     * In replace mode:\n     * cc < 0: NL was inserted, delete it\n     * cc >= 0: NL was replaced, put original characters back\n     */\n    cc = -1;\n    if (State & REPLACE_FLAG) {\n      cc = replace_pop();           // returns -1 if NL was inserted\n    }\n    // In replace mode, in the line we started replacing, we only move the\n    // cursor.\n    if ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum) {\n      dec_cursor();\n    } else {\n      if (!(State & VREPLACE_FLAG)\n          || curwin->w_cursor.lnum > orig_line_count) {\n        temp = gchar_cursor();          // remember current char\n        curwin->w_cursor.lnum--;\n\n        // When \"aw\" is in 'formatoptions' we must delete the space at\n        // the end of the line, otherwise the line will be broken\n        // again when auto-formatting.\n        if (has_format_option(FO_AUTO)\n            && has_format_option(FO_WHITE_PAR)) {\n          char_u *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, true);\n          int len;\n\n          len = (int)STRLEN(ptr);\n          if (len > 0 && ptr[len - 1] == ' ') {\n            ptr[len - 1] = NUL;\n          }\n        }\n\n        do_join(2, FALSE, FALSE, FALSE, false);\n        if (temp == NUL && gchar_cursor() != NUL) {\n          inc_cursor();\n        }\n      } else {\n        dec_cursor();\n      }\n\n      /*\n       * In REPLACE mode we have to put back the text that was replaced\n       * by the NL. On the replace stack is first a NUL-terminated\n       * sequence of characters that were deleted and then the\n       * characters that NL replaced.\n       */\n      if (State & REPLACE_FLAG) {\n        /*\n         * Do the next ins_char() in NORMAL state, to\n         * prevent ins_char() from replacing characters and\n         * avoiding showmatch().\n         */\n        oldState = State;\n        State = NORMAL;\n        /*\n         * restore characters (blanks) deleted after cursor\n         */\n        while (cc > 0) {\n          save_col = curwin->w_cursor.col;\n          mb_replace_pop_ins(cc);\n          curwin->w_cursor.col = save_col;\n          cc = replace_pop();\n        }\n        // restore the characters that NL replaced\n        replace_pop_ins();\n        State = oldState;\n      }\n    }\n    did_ai = false;\n  } else {\n    // Delete character(s) before the cursor.\n    if (revins_on) {            // put cursor on last inserted char\n      dec_cursor();\n    }\n    mincol = 0;\n    // keep indent\n    if (mode == BACKSPACE_LINE\n        && (curbuf->b_p_ai\n            || cindent_on()\n            )\n        && !revins_on) {\n      save_col = curwin->w_cursor.col;\n      beginline(BL_WHITE);\n      if (curwin->w_cursor.col < save_col) {\n        mincol = curwin->w_cursor.col;\n      }\n      curwin->w_cursor.col = save_col;\n    }\n\n    /*\n     * Handle deleting one 'shiftwidth' or 'softtabstop'.\n     */\n    if (mode == BACKSPACE_CHAR\n        && ((p_sta && in_indent)\n            || ((get_sts_value() != 0\n                 || tabstop_count(curbuf->b_p_vsts_array))\n                && curwin->w_cursor.col > 0\n                && (*(get_cursor_pos_ptr() - 1) == TAB\n                    || (*(get_cursor_pos_ptr() - 1) == ' '\n                        && (!*inserted_space_p || arrow_used)))))) {\n      int ts;\n      colnr_T vcol;\n      colnr_T want_vcol;\n      colnr_T start_vcol;\n\n      *inserted_space_p = false;\n      // Compute the virtual column where we want to be.  Since\n      // 'showbreak' may get in the way, need to get the last column of\n      // the previous character.\n      getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n      start_vcol = vcol;\n      dec_cursor();\n      getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n      inc_cursor();\n      if (p_sta && in_indent) {\n        ts = get_sw_value(curbuf);\n        want_vcol = (want_vcol / ts) * ts;\n      } else {\n        want_vcol = tabstop_start(want_vcol,\n                                  get_sts_value(),\n                                  curbuf->b_p_vsts_array);\n      }\n\n      // delete characters until we are at or before want_vcol\n      while (vcol > want_vcol\n             && (cc = *(get_cursor_pos_ptr() - 1), ascii_iswhite(cc))) {\n        ins_bs_one(&vcol);\n      }\n\n      // insert extra spaces until we are at want_vcol\n      while (vcol < want_vcol) {\n        // Remember the first char we inserted\n        if (curwin->w_cursor.lnum == Insstart_orig.lnum\n            && curwin->w_cursor.col < Insstart_orig.col) {\n          Insstart_orig.col = curwin->w_cursor.col;\n        }\n\n        if (State & VREPLACE_FLAG) {\n          ins_char(' ');\n        } else {\n          ins_str((char_u *)\" \");\n          if ((State & REPLACE_FLAG)) {\n            replace_push(NUL);\n          }\n        }\n        getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n      }\n\n      // If we are now back where we started delete one character.  Can\n      // happen when using 'sts' and 'linebreak'.\n      if (vcol >= start_vcol) {\n        ins_bs_one(&vcol);\n      }\n    } else {\n      // Delete up to starting point, start of line or previous word.\n      int prev_cclass = 0;\n\n      int cclass = mb_get_class(get_cursor_pos_ptr());\n      do {\n        if (!revins_on) {   // put cursor on char to be deleted\n          dec_cursor();\n        }\n        cc = gchar_cursor();\n        // look multi-byte character class\n        prev_cclass = cclass;\n        cclass = mb_get_class(get_cursor_pos_ptr());\n        if (mode == BACKSPACE_WORD && !ascii_isspace(cc)) {   // start of word?\n          mode = BACKSPACE_WORD_NOT_SPACE;\n          temp = vim_iswordc(cc);\n        } else if (mode == BACKSPACE_WORD_NOT_SPACE\n                   && ((ascii_isspace(cc) || vim_iswordc(cc) != temp)\n                       || prev_cclass != cclass)) {   // end of word?\n          if (!revins_on) {\n            inc_cursor();\n          } else if (State & REPLACE_FLAG) {\n            dec_cursor();\n          }\n          break;\n        }\n        if (State & REPLACE_FLAG) {\n          replace_do_bs(-1);\n        } else {\n          const int l_p_deco = p_deco;\n          if (l_p_deco) {\n            (void)utfc_ptr2char(get_cursor_pos_ptr(), cpc);\n          }\n          (void)del_char(false);\n          // If there are combining characters and 'delcombine' is set\n          // move the cursor back.  Don't back up before the base\n          // character.\n          if (l_p_deco && cpc[0] != NUL) {\n            inc_cursor();\n          }\n          if (revins_chars) {\n            revins_chars--;\n            revins_legal++;\n          }\n          if (revins_on && gchar_cursor() == NUL) {\n            break;\n          }\n        }\n        // Just a single backspace?:\n        if (mode == BACKSPACE_CHAR) {\n          break;\n        }\n      } while (revins_on\n               || (curwin->w_cursor.col > mincol\n                   && (can_bs(BS_NOSTOP)\n                       || (curwin->w_cursor.lnum != Insstart_orig.lnum\n                           || curwin->w_cursor.col != Insstart_orig.col))));\n    }\n    did_backspace = true;\n  }\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n  if (curwin->w_cursor.col <= 1) {\n    did_ai = false;\n  }\n  // It's a little strange to put backspaces into the redo\n  // buffer, but it makes auto-indent a lot easier to deal\n  // with.\n  AppendCharToRedobuff(c);\n\n  // If deleted before the insertion point, adjust it\n  if (curwin->w_cursor.lnum == Insstart_orig.lnum\n      && curwin->w_cursor.col < Insstart_orig.col) {\n    Insstart_orig.col = curwin->w_cursor.col;\n  }\n\n  // vi behaviour: the cursor moves backward but the character that\n  //               was there remains visible\n  // Vim behaviour: the cursor moves backward and the character that\n  //                was there is erased from the screen.\n  // We can emulate the vi behaviour by pretending there is a dollar\n  // displayed even when there isn't.\n  //  --pkv Sun Jan 19 01:56:40 EST 2003\n  if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1) {\n    dollar_vcol = curwin->w_virtcol;\n  }\n\n  // When deleting a char the cursor line must never be in a closed fold.\n  // E.g., when 'foldmethod' is indent and deleting the first non-white\n  // char before a Tab.\n  if (did_backspace) {\n    foldOpenCursor();\n  }\n  return did_backspace;\n}\n\nstatic void ins_mouse(int c)\n{\n  pos_T tpos;\n  win_T *old_curwin = curwin;\n\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (do_mouse(NULL, c, BACKWARD, 1, 0)) {\n    win_T *new_curwin = curwin;\n\n    if (curwin != old_curwin && win_valid(old_curwin)) {\n      // Mouse took us to another window.  We need to go back to the\n      // previous one to stop insert there properly.\n      curwin = old_curwin;\n      curbuf = curwin->w_buffer;\n      if (bt_prompt(curbuf)) {\n        // Restart Insert mode when re-entering the prompt buffer.\n        curbuf->b_prompt_insert = 'A';\n      }\n    }\n    start_arrow(curwin == old_curwin ? &tpos : NULL);\n    if (curwin != new_curwin && win_valid(new_curwin)) {\n      curwin = new_curwin;\n      curbuf = curwin->w_buffer;\n    }\n    can_cindent = true;\n  }\n\n  // redraw status lines (in case another window became active)\n  redraw_statuslines();\n}\n\nstatic void ins_mousescroll(int dir)\n{\n  win_T *const old_curwin = curwin;\n  pos_T tpos = curwin->w_cursor;\n\n  if (mouse_row >= 0 && mouse_col >= 0) {\n    int row = mouse_row, col = mouse_col, grid = mouse_grid;\n\n    // find the window at the pointer coordinates\n    win_T *wp = mouse_find_win(&grid, &row, &col);\n    if (wp == NULL) {\n      return;\n    }\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n  }\n  if (curwin == old_curwin) {\n    undisplay_dollar();\n  }\n\n  // Don't scroll the window in which completion is being done.\n  if (!pum_visible()\n      || curwin != old_curwin) {\n    if (dir == MSCR_DOWN || dir == MSCR_UP) {\n      if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {\n        scroll_redraw(dir,\n                      (curwin->w_botline - curwin->w_topline));\n      } else {\n        scroll_redraw(dir, 3L);\n      }\n    } else {\n      mouse_scroll_horiz(dir);\n    }\n  }\n\n  curwin->w_redr_status = TRUE;\n\n  curwin = old_curwin;\n  curbuf = curwin->w_buffer;\n\n  if (!equalpos(curwin->w_cursor, tpos)) {\n    start_arrow(&tpos);\n    can_cindent = true;\n  }\n}\n\n\n\nstatic void ins_left(void)\n{\n  pos_T tpos;\n  const bool end_change = dont_sync_undo == kFalse;  // end undoable change\n\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (oneleft() == OK) {\n    start_arrow_with_change(&tpos, end_change);\n    if (!end_change) {\n      AppendCharToRedobuff(K_LEFT);\n    }\n    // If exit reversed string, position is fixed\n    if (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol) {\n      revins_legal++;\n    }\n    revins_chars++;\n  } else if (vim_strchr(p_ww, '[') != NULL && curwin->w_cursor.lnum > 1) {\n    // if 'whichwrap' set for cursor in insert mode may go to previous line.\n    // always break undo when moving upwards/downwards, else undo may break\n    start_arrow(&tpos);\n    curwin->w_cursor.lnum--;\n    coladvance(MAXCOL);\n    curwin->w_set_curswant = true;  // so we stay at the end\n  } else {\n    vim_beep(BO_CRSR);\n  }\n  dont_sync_undo = kFalse;\n}\n\nstatic void ins_home(int c)\n{\n  pos_T tpos;\n\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (c == K_C_HOME) {\n    curwin->w_cursor.lnum = 1;\n  }\n  curwin->w_cursor.col = 0;\n  curwin->w_cursor.coladd = 0;\n  curwin->w_curswant = 0;\n  start_arrow(&tpos);\n}\n\nstatic void ins_end(int c)\n{\n  pos_T tpos;\n\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (c == K_C_END) {\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n  }\n  coladvance(MAXCOL);\n  curwin->w_curswant = MAXCOL;\n\n  start_arrow(&tpos);\n}\n\nstatic void ins_s_left(void)\n{\n  const bool end_change = dont_sync_undo == kFalse;  // end undoable change\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  if (curwin->w_cursor.lnum > 1 || curwin->w_cursor.col > 0) {\n    start_arrow_with_change(&curwin->w_cursor, end_change);\n    if (!end_change) {\n      AppendCharToRedobuff(K_S_LEFT);\n    }\n    (void)bck_word(1L, false, false);\n    curwin->w_set_curswant = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n  dont_sync_undo = kFalse;\n}\n\n/// @param end_change      end undoable change\nstatic void ins_right(void)\n{\n  const bool end_change = dont_sync_undo == kFalse;  // end undoable change\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  if (gchar_cursor() != NUL || virtual_active()) {\n    start_arrow_with_change(&curwin->w_cursor, end_change);\n    if (!end_change) {\n      AppendCharToRedobuff(K_RIGHT);\n    }\n    curwin->w_set_curswant = true;\n    if (virtual_active()) {\n      oneright();\n    } else {\n      curwin->w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());\n    }\n\n    revins_legal++;\n    if (revins_chars) {\n      revins_chars--;\n    }\n  } else if (vim_strchr(p_ww, ']') != NULL\n             && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {\n    // if 'whichwrap' set for cursor in insert mode, may move the\n    // cursor to the next line\n    start_arrow(&curwin->w_cursor);\n    curwin->w_set_curswant = true;\n    curwin->w_cursor.lnum++;\n    curwin->w_cursor.col = 0;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n  dont_sync_undo = kFalse;\n}\n\nstatic void ins_s_right(void)\n{\n  const bool end_change = dont_sync_undo == kFalse;  // end undoable change\n  if ((fdo_flags & FDO_HOR) && KeyTyped) {\n    foldOpenCursor();\n  }\n  undisplay_dollar();\n  if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count\n      || gchar_cursor() != NUL) {\n    start_arrow_with_change(&curwin->w_cursor, end_change);\n    if (!end_change) {\n      AppendCharToRedobuff(K_S_RIGHT);\n    }\n    (void)fwd_word(1L, false, 0);\n    curwin->w_set_curswant = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n  dont_sync_undo = kFalse;\n}\n\n/// @param startcol  when true move to Insstart.col\nstatic void ins_up(bool startcol)\n{\n  pos_T tpos;\n  linenr_T old_topline = curwin->w_topline;\n  int old_topfill = curwin->w_topfill;\n\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (cursor_up(1L, TRUE) == OK) {\n    if (startcol) {\n      coladvance(getvcol_nolist(&Insstart));\n    }\n    if (old_topline != curwin->w_topline\n        || old_topfill != curwin->w_topfill) {\n      redraw_later(curwin, VALID);\n    }\n    start_arrow(&tpos);\n    can_cindent = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n}\n\nstatic void ins_pageup(void)\n{\n  pos_T tpos;\n\n  undisplay_dollar();\n\n  if (mod_mask & MOD_MASK_CTRL) {\n    // <C-PageUp>: tab page back\n    if (first_tabpage->tp_next != NULL) {\n      start_arrow(&curwin->w_cursor);\n      goto_tabpage(-1);\n    }\n    return;\n  }\n\n  tpos = curwin->w_cursor;\n  if (onepage(BACKWARD, 1L) == OK) {\n    start_arrow(&tpos);\n    can_cindent = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n}\n\n/// @param startcol  when true move to Insstart.col\nstatic void ins_down(bool startcol)\n{\n  pos_T tpos;\n  linenr_T old_topline = curwin->w_topline;\n  int old_topfill = curwin->w_topfill;\n\n  undisplay_dollar();\n  tpos = curwin->w_cursor;\n  if (cursor_down(1L, TRUE) == OK) {\n    if (startcol) {\n      coladvance(getvcol_nolist(&Insstart));\n    }\n    if (old_topline != curwin->w_topline\n        || old_topfill != curwin->w_topfill) {\n      redraw_later(curwin, VALID);\n    }\n    start_arrow(&tpos);\n    can_cindent = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n}\n\nstatic void ins_pagedown(void)\n{\n  pos_T tpos;\n\n  undisplay_dollar();\n\n  if (mod_mask & MOD_MASK_CTRL) {\n    // <C-PageDown>: tab page forward\n    if (first_tabpage->tp_next != NULL) {\n      start_arrow(&curwin->w_cursor);\n      goto_tabpage(0);\n    }\n    return;\n  }\n\n  tpos = curwin->w_cursor;\n  if (onepage(FORWARD, 1L) == OK) {\n    start_arrow(&tpos);\n    can_cindent = true;\n  } else {\n    vim_beep(BO_CRSR);\n  }\n}\n\n/// Handle TAB in Insert or Replace mode.\n///\n/// @return true when the TAB needs to be inserted like a normal character.\nstatic bool ins_tab(void)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int i;\n  int temp;\n\n  if (Insstart_blank_vcol == MAXCOL && curwin->w_cursor.lnum == Insstart.lnum) {\n    Insstart_blank_vcol = get_nolist_virtcol();\n  }\n  if (echeck_abbr(TAB + ABBR_OFF)) {\n    return false;\n  }\n\n  int ind = inindent(0);\n  if (ind) {\n    can_cindent = false;\n  }\n\n  // When nothing special, insert TAB like a normal character.\n  if (!curbuf->b_p_et\n      && !(\n           p_sta\n           && ind\n           // These five lines mean 'tabstop' != 'shiftwidth'\n           && ((tabstop_count(curbuf->b_p_vts_array) > 1)\n               || (tabstop_count(curbuf->b_p_vts_array) == 1\n                   && tabstop_first(curbuf->b_p_vts_array)\n                   != get_sw_value(curbuf))\n               || (tabstop_count(curbuf->b_p_vts_array) == 0\n                   && curbuf->b_p_ts != get_sw_value(curbuf))))\n      && tabstop_count(curbuf->b_p_vsts_array) == 0 && get_sts_value() == 0) {\n    return true;\n  }\n\n  if (stop_arrow() == FAIL) {\n    return true;\n  }\n\n  did_ai = false;\n  did_si = false;\n  can_si = false;\n  can_si_back = false;\n  AppendToRedobuff(\"\\t\");\n\n  if (p_sta && ind) {  // insert tab in indent, use 'shiftwidth'\n    temp = get_sw_value(curbuf);\n    temp -= get_nolist_virtcol() % temp;\n  } else if (tabstop_count(curbuf->b_p_vsts_array) > 0\n             || curbuf->b_p_sts != 0) {\n    // use 'softtabstop' when set\n    temp = tabstop_padding(get_nolist_virtcol(),\n                           get_sts_value(),\n                           curbuf->b_p_vsts_array);\n  } else {\n    // otherwise use 'tabstop'\n    temp = tabstop_padding(get_nolist_virtcol(),\n                           curbuf->b_p_ts,\n                           curbuf->b_p_vts_array);\n  }\n\n  /*\n   * Insert the first space with ins_char().    It will delete one char in\n   * replace mode.  Insert the rest with ins_str(); it will not delete any\n   * chars.  For VREPLACE mode, we use ins_char() for all characters.\n   */\n  ins_char(' ');\n  while (--temp > 0) {\n    if (State & VREPLACE_FLAG) {\n      ins_char(' ');\n    } else {\n      ins_str((char_u *)\" \");\n      if (State & REPLACE_FLAG) {            // no char replaced\n        replace_push(NUL);\n      }\n    }\n  }\n\n  /*\n   * When 'expandtab' not set: Replace spaces by TABs where possible.\n   */\n  if (!curbuf->b_p_et && (tabstop_count(curbuf->b_p_vsts_array) > 0\n                          || get_sts_value() > 0\n                          || (p_sta && ind))) {\n    char_u *ptr;\n    char_u *saved_line = NULL;         // init for GCC\n    pos_T pos;\n    pos_T fpos;\n    pos_T *cursor;\n    colnr_T want_vcol, vcol;\n    int change_col = -1;\n    int save_list = curwin->w_p_list;\n\n    /*\n     * Get the current line.  For VREPLACE mode, don't make real changes\n     * yet, just work on a copy of the line.\n     */\n    if (State & VREPLACE_FLAG) {\n      pos = curwin->w_cursor;\n      cursor = &pos;\n      saved_line = vim_strsave(get_cursor_line_ptr());\n      ptr = saved_line + pos.col;\n    } else {\n      ptr = get_cursor_pos_ptr();\n      cursor = &curwin->w_cursor;\n    }\n\n    // When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.\n    if (vim_strchr(p_cpo, CPO_LISTWM) == NULL) {\n      curwin->w_p_list = false;\n    }\n\n    // Find first white before the cursor\n    fpos = curwin->w_cursor;\n    while (fpos.col > 0 && ascii_iswhite(ptr[-1])) {\n      --fpos.col;\n      --ptr;\n    }\n\n    // In Replace mode, don't change characters before the insert point.\n    if ((State & REPLACE_FLAG)\n        && fpos.lnum == Insstart.lnum\n        && fpos.col < Insstart.col) {\n      ptr += Insstart.col - fpos.col;\n      fpos.col = Insstart.col;\n    }\n\n    // compute virtual column numbers of first white and cursor\n    getvcol(curwin, &fpos, &vcol, NULL, NULL);\n    getvcol(curwin, cursor, &want_vcol, NULL, NULL);\n\n    // Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'\n    // and 'linebreak' adding extra virtual columns.\n    while (ascii_iswhite(*ptr)) {\n      i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);\n      if (vcol + i > want_vcol) {\n        break;\n      }\n      if (*ptr != TAB) {\n        *ptr = TAB;\n        if (change_col < 0) {\n          change_col = fpos.col;            // Column of first change\n          // May have to adjust Insstart\n          if (fpos.lnum == Insstart.lnum && fpos.col < Insstart.col) {\n            Insstart.col = fpos.col;\n          }\n        }\n      }\n      ++fpos.col;\n      ++ptr;\n      vcol += i;\n    }\n\n    if (change_col >= 0) {\n      int repl_off = 0;\n      char_u *line = ptr;\n\n      // Skip over the spaces we need.\n      while (vcol < want_vcol && *ptr == ' ') {\n        vcol += lbr_chartabsize(line, ptr, vcol);\n        ++ptr;\n        ++repl_off;\n      }\n      if (vcol > want_vcol) {\n        // Must have a char with 'showbreak' just before it.\n        ptr--;\n        repl_off--;\n      }\n      fpos.col += repl_off;\n\n      // Delete following spaces.\n      i = cursor->col - fpos.col;\n      if (i > 0) {\n        STRMOVE(ptr, ptr + i);\n        // correct replace stack.\n        if ((State & REPLACE_FLAG)\n            && !(State & VREPLACE_FLAG)) {\n          for (temp = i; --temp >= 0; ) {\n            replace_join(repl_off);\n          }\n        }\n        if (!(State & VREPLACE_FLAG)) {\n          extmark_splice_cols(curbuf, fpos.lnum - 1, change_col,\n                              cursor->col - change_col, fpos.col - change_col,\n                              kExtmarkUndo);\n        }\n      }\n      cursor->col -= i;\n\n      /*\n       * In VREPLACE mode, we haven't changed anything yet.  Do it now by\n       * backspacing over the changed spacing and then inserting the new\n       * spacing.\n       */\n      if (State & VREPLACE_FLAG) {\n        // Backspace from real cursor to change_col\n        backspace_until_column(change_col);\n\n        // Insert each char in saved_line from changed_col to\n        // ptr-cursor\n        ins_bytes_len(saved_line + change_col,\n                      cursor->col - change_col);\n      }\n    }\n\n    if (State & VREPLACE_FLAG) {\n      xfree(saved_line);\n    }\n    curwin->w_p_list = save_list;\n  }\n\n  return false;\n}\n\n/// Handle CR or NL in insert mode.\n///\n/// @return false when it can't undo.\nstatic bool ins_eol(int c)\n{\n  if (echeck_abbr(c + ABBR_OFF)) {\n    return true;\n  }\n  if (stop_arrow() == FAIL) {\n    return false;\n  }\n  undisplay_dollar();\n\n  /*\n   * Strange Vi behaviour: In Replace mode, typing a NL will not delete the\n   * character under the cursor.  Only push a NUL on the replace stack,\n   * nothing to put back when the NL is deleted.\n   */\n  if ((State & REPLACE_FLAG)\n      && !(State & VREPLACE_FLAG)) {\n    replace_push(NUL);\n  }\n\n  /*\n   * In VREPLACE mode, a NL replaces the rest of the line, and starts\n   * replacing the next line, so we push all of the characters left on the\n   * line onto the replace stack.  This is not done here though, it is done\n   * in open_line().\n   */\n\n  // Put cursor on NUL if on the last char and coladd is 1 (happens after\n  // CTRL-O).\n  if (virtual_active() && curwin->w_cursor.coladd > 0) {\n    coladvance(getviscol());\n  }\n\n  // NL in reverse insert will always start in the end of current line.\n  if (revins_on) {\n    curwin->w_cursor.col += (colnr_T)STRLEN(get_cursor_pos_ptr());\n  }\n\n  AppendToRedobuff(NL_STR);\n  bool i = open_line(FORWARD,\n                     has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0,\n                     old_indent);\n  old_indent = 0;\n  can_cindent = true;\n  // When inserting a line the cursor line must never be in a closed fold.\n  foldOpenCursor();\n\n  return i;\n}\n\n/*\n * Handle digraph in insert mode.\n * Returns character still to be inserted, or NUL when nothing remaining to be\n * done.\n */\nstatic int ins_digraph(void)\n{\n  int c;\n  int cc;\n  bool did_putchar = false;\n\n  pc_status = PC_STATUS_UNSET;\n  if (redrawing() && !char_avail()) {\n    // may need to redraw when no more chars available now\n    ins_redraw(false);\n\n    edit_putchar('?', true);\n    did_putchar = true;\n    add_to_showcmd_c(Ctrl_K);\n  }\n\n\n  // don't map the digraph chars. This also prevents the\n  // mode message to be deleted when ESC is hit\n  no_mapping++;\n  c = plain_vgetc();\n  no_mapping--;\n  if (did_putchar) {\n    // when the line fits in 'columns' the '?' is at the start of the next\n    // line and will not be removed by the redraw\n    edit_unputchar();\n  }\n\n  if (IS_SPECIAL(c) || mod_mask) {          // special key\n    clear_showcmd();\n    insert_special(c, TRUE, FALSE);\n    return NUL;\n  }\n  if (c != ESC) {\n    did_putchar = false;\n    if (redrawing() && !char_avail()) {\n      // may need to redraw when no more chars available now\n      ins_redraw(false);\n\n      if (char2cells(c) == 1) {\n        ins_redraw(false);\n        edit_putchar(c, true);\n        did_putchar = true;\n      }\n      add_to_showcmd_c(c);\n    }\n    no_mapping++;\n    cc = plain_vgetc();\n    no_mapping--;\n    if (did_putchar) {\n      // when the line fits in 'columns' the '?' is at the start of the\n      // next line and will not be removed by a redraw\n      edit_unputchar();\n    }\n    if (cc != ESC) {\n      AppendToRedobuff(CTRL_V_STR);\n      c = getdigraph(c, cc, true);\n      clear_showcmd();\n      return c;\n    }\n  }\n  clear_showcmd();\n  return NUL;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.\n * Returns the char to be inserted, or NUL if none found.\n */\nint ins_copychar(linenr_T lnum)\n{\n  int c;\n  int temp;\n  char_u *ptr, *prev_ptr;\n  char_u *line;\n\n  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) {\n    vim_beep(BO_COPY);\n    return NUL;\n  }\n\n  // try to advance to the cursor column\n  temp = 0;\n  line = ptr = ml_get(lnum);\n  prev_ptr = ptr;\n  validate_virtcol();\n  while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL) {\n    prev_ptr = ptr;\n    temp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);\n  }\n  if ((colnr_T)temp > curwin->w_virtcol) {\n    ptr = prev_ptr;\n  }\n\n  c = utf_ptr2char(ptr);\n  if (c == NUL) {\n    vim_beep(BO_COPY);\n  }\n  return c;\n}\n\n/*\n * CTRL-Y or CTRL-E typed in Insert mode.\n */\nstatic int ins_ctrl_ey(int tc)\n{\n  int c = tc;\n\n  if (ctrl_x_mode == CTRL_X_SCROLL) {\n    if (c == Ctrl_Y) {\n      scrolldown_clamp();\n    } else {\n      scrollup_clamp();\n    }\n    redraw_later(curwin, VALID);\n  } else {\n    c = ins_copychar(curwin->w_cursor.lnum + (c == Ctrl_Y ? -1 : 1));\n    if (c != NUL) {\n      long tw_save;\n\n      // The character must be taken literally, insert like it\n      // was typed after a CTRL-V, and pretend 'textwidth'\n      // wasn't set.  Digits, 'o' and 'x' are special after a\n      // CTRL-V, don't use it for these.\n      if (c < 256 && !isalnum(c)) {\n        AppendToRedobuff(CTRL_V_STR);\n      }\n      tw_save = curbuf->b_p_tw;\n      curbuf->b_p_tw = -1;\n      insert_special(c, TRUE, FALSE);\n      curbuf->b_p_tw = tw_save;\n      revins_chars++;\n      revins_legal++;\n      c = Ctrl_V;       // pretend CTRL-V is last character\n      auto_format(false, true);\n    }\n  }\n  return c;\n}\n\n/*\n * Try to do some very smart auto-indenting.\n * Used when inserting a \"normal\" character.\n */\nstatic void ins_try_si(int c)\n{\n  pos_T *pos, old_pos;\n  char_u *ptr;\n  int i;\n  bool temp;\n\n  /*\n   * do some very smart indenting when entering '{' or '}'\n   */\n  if (((did_si || can_si_back) && c == '{') || (can_si && c == '}')) {\n    /*\n     * for '}' set indent equal to indent of line containing matching '{'\n     */\n    if (c == '}' && (pos = findmatch(NULL, '{')) != NULL) {\n      old_pos = curwin->w_cursor;\n      /*\n       * If the matching '{' has a ')' immediately before it (ignoring\n       * white-space), then line up with the start of the line\n       * containing the matching '(' if there is one.  This handles the\n       * case where an \"if (..\\n..) {\" statement continues over multiple\n       * lines -- webb\n       */\n      ptr = ml_get(pos->lnum);\n      i = pos->col;\n      if (i > 0) {              // skip blanks before '{'\n        while (--i > 0 && ascii_iswhite(ptr[i])) {\n        }\n      }\n      curwin->w_cursor.lnum = pos->lnum;\n      curwin->w_cursor.col = i;\n      if (ptr[i] == ')' && (pos = findmatch(NULL, '(')) != NULL) {\n        curwin->w_cursor = *pos;\n      }\n      i = get_indent();\n      curwin->w_cursor = old_pos;\n      if (State & VREPLACE_FLAG) {\n        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);\n      } else {\n        (void)set_indent(i, SIN_CHANGED);\n      }\n    } else if (curwin->w_cursor.col > 0) {\n      // when inserting '{' after \"O\" reduce indent, but not\n      // more than indent of previous line\n      temp = true;\n      if (c == '{' && can_si_back && curwin->w_cursor.lnum > 1) {\n        old_pos = curwin->w_cursor;\n        i = get_indent();\n        while (curwin->w_cursor.lnum > 1) {\n          ptr = skipwhite(ml_get(--(curwin->w_cursor.lnum)));\n\n          // ignore empty lines and lines starting with '#'.\n          if (*ptr != '#' && *ptr != NUL) {\n            break;\n          }\n        }\n        if (get_indent() >= i) {\n          temp = false;\n        }\n        curwin->w_cursor = old_pos;\n      }\n      if (temp) {\n        shift_line(TRUE, FALSE, 1, TRUE);\n      }\n    }\n  }\n\n  /*\n   * set indent of '#' always to 0\n   */\n  if (curwin->w_cursor.col > 0 && can_si && c == '#') {\n    // remember current indent for next line\n    old_indent = get_indent();\n    (void)set_indent(0, SIN_CHANGED);\n  }\n\n  // Adjust ai_col, the char at this position can be deleted.\n  if (ai_col > curwin->w_cursor.col) {\n    ai_col = curwin->w_cursor.col;\n  }\n}\n\n/*\n * Get the value that w_virtcol would have when 'list' is off.\n * Unless 'cpo' contains the 'L' flag.\n */\ncolnr_T get_nolist_virtcol(void)\n{\n  // check validity of cursor in current buffer\n  if (curwin->w_buffer == NULL || curwin->w_buffer->b_ml.ml_mfp == NULL\n      || curwin->w_cursor.lnum > curwin->w_buffer->b_ml.ml_line_count) {\n    return 0;\n  }\n  if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL) {\n    return getvcol_nolist(&curwin->w_cursor);\n  }\n  validate_virtcol();\n  return curwin->w_virtcol;\n}\n\n/*\n * Handle the InsertCharPre autocommand.\n * \"c\" is the character that was typed.\n * Return a pointer to allocated memory with the replacement string.\n * Return NULL to continue inserting \"c\".\n */\nstatic char_u *do_insert_char_pre(int c)\n{\n  char buf[MB_MAXBYTES + 1];\n  const int save_State = State;\n\n  // Return quickly when there is nothing to do.\n  if (!has_event(EVENT_INSERTCHARPRE)) {\n    return NULL;\n  }\n  buf[utf_char2bytes(c, (char_u *)buf)] = NUL;\n\n  // Lock the text to avoid weird things from happening.\n  textlock++;\n  set_vim_var_string(VV_CHAR, buf, -1);\n\n  char_u *res = NULL;\n  if (ins_apply_autocmds(EVENT_INSERTCHARPRE)) {\n    // Get the value of v:char.  It may be empty or more than one\n    // character.  Only use it when changed, otherwise continue with the\n    // original character to avoid breaking autoindent.\n    if (STRCMP(buf, get_vim_var_str(VV_CHAR)) != 0) {\n      res = vim_strsave(get_vim_var_str(VV_CHAR));\n    }\n  }\n\n  set_vim_var_string(VV_CHAR, NULL, -1);\n  textlock--;\n\n  // Restore the State, it may have been changed.\n  State = save_State;\n\n  return res;\n}\n\n/// Trigger \"event\" and take care of fixing undo.\nstatic int ins_apply_autocmds(event_T event)\n{\n  varnumber_T tick = buf_get_changedtick(curbuf);\n  int r;\n\n  r = apply_autocmds(event, NULL, NULL, false, curbuf);\n\n  // If u_savesub() was called then we are not prepared to start\n  // a new line.  Call u_save() with no contents to fix that.\n  // Except when leaving Insert mode.\n  if (event != EVENT_INSERTLEAVE && tick != buf_get_changedtick(curbuf)) {\n    u_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n  }\n\n  return r;\n}\n\nstatic void show_pum(int prev_w_wrow, int prev_w_leftcol)\n{\n  // RedrawingDisabled may be set when invoked through complete().\n  int n = RedrawingDisabled;\n  RedrawingDisabled = 0;\n\n  // If the cursor moved or the display scrolled we need to remove the pum\n  // first.\n  setcursor();\n  if (prev_w_wrow != curwin->w_wrow || prev_w_leftcol != curwin->w_leftcol) {\n    ins_compl_del_pum();\n  }\n\n  ins_compl_show_pum();\n  setcursor();\n  RedrawingDisabled = n;\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 0, "line": 258}, "message": "insstart_textlen (fixit)"}, {"location": {"col": 16, "file": 0, "line": 258}, "message": "invalid case style for variable 'Insstart_textlen'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "104687c37ca9950ee5a7e1e55a1da30b", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 259}, "message": "insstart_blank_vcol (fixit)"}, {"location": {"col": 16, "file": 0, "line": 259}, "message": "invalid case style for variable 'Insstart_blank_vcol'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "a060f43a48a797d3a0610becb7b2199a", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 260}, "message": "update_insstart_orig (fixit)"}, {"location": {"col": 13, "file": 0, "line": 260}, "message": "invalid case style for variable 'update_Insstart_orig'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "146a8c19d15fbbea4b405d23f1a449ae", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1418}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "bfeb8ab123ad3c43b596e5b9e633617e", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1749}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "59a1c9443f3f6bd2dee044eaf2740752", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1795}, "message": "save_state (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1795}, "message": "invalid case style for variable 'save_State'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "1e56eb431179602cefb7632d4013dde4", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2197}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8be4dc0e3323d47c462f855d4e806a54", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 2352}, "message": "(     ) (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2352}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "a299d767e66924c240fc95066445c6ad", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2352}, "message": "(               ) (fixit)"}, {"location": {"col": 27, "file": 0, "line": 2352}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8ba350c098765d58ce60da284222a3f1", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 0, "line": 2354}, "message": "(     ) (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2354}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "bbad72936ee265a66243898bb581d3e2", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2489}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "d634557b72bf9776c8631335272f8a7a", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2490}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "80c2d4e6e65471fcacb71d277c9e8ec8", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2896}, "message": "function 'ins_compl_dictionaries' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "030bd83a424fa66bc7399b84a0c00dc1", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2993}, "message": "function 'ins_compl_files' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8c026485ffe1b0d95d5425602d0eaf06", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 3558}, "message": "example recursive call chain, starting from function 'ins_compl_prep'"}, {"location": {"col": 7, "file": 0, "line": 3593}, "message": "Frame #1: function 'ins_compl_prep' calls function 'ins_compl_prep' here:"}, {"location": {"col": 7, "file": 0, "line": 3593}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 13, "file": 0, "line": 3558}, "message": "function 'ins_compl_prep' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "ef14075dc3b564712c0aeb82de064008", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 3938}, "message": "save_state (fixit)"}, {"location": {"col": 13, "file": 0, "line": 3938}, "message": "invalid case style for variable 'save_State'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "663cbf8fe17c95930e217cde48fb664e", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4107}, "message": "function 'ins_compl_get_exp' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "49c730106cb9e1c2d913dccaf8d3edeb", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4218}, "message": "end of the original"}, {"location": {"col": 16, "file": 0, "line": 4237}, "message": "clone 1 starts here"}, {"location": {"col": 54, "file": 0, "line": 4216}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "bb26444f3c720a26294b0ca81773c180", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4407}, "message": "end of the original"}, {"location": {"col": 59, "file": 0, "line": 4410}, "message": "clone 1 starts here"}, {"location": {"col": 59, "file": 0, "line": 4401}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "23f9a7602ab34e4c811d1fcf31bd285a", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 0, "line": 4866}, "message": "example recursive call chain, starting from function 'ins_compl_check_keys'"}, {"location": {"col": 13, "file": 0, "line": 4890}, "message": "Frame #1: function 'ins_compl_check_keys' calls function 'ins_compl_next' here:"}, {"location": {"col": 21, "file": 0, "line": 4743}, "message": "Frame #2: function 'ins_compl_next' calls function 'ins_compl_get_exp' here:"}, {"location": {"col": 7, "file": 0, "line": 4273}, "message": "Frame #3: function 'ins_compl_get_exp' calls function 'ins_compl_dictionaries' here:"}, {"location": {"col": 7, "file": 0, "line": 2976}, "message": "Frame #4: function 'ins_compl_dictionaries' calls function 'ins_compl_files' here:"}, {"location": {"col": 7, "file": 0, "line": 3080}, "message": "Frame #5: function 'ins_compl_files' calls function 'ins_compl_check_keys' here:"}, {"location": {"col": 7, "file": 0, "line": 3080}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 12, "file": 0, "line": 4652}, "message": "function 'ins_compl_next' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "0c7e31022094f89251e2694e9389d225", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 0, "line": 4866}, "message": "function 'ins_compl_check_keys' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "654e65c6f03346b13f01fe35fc0b4a49", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5124}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5124}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "3057427c6a6b8eee0a466b01b438060e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5153}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5153}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "cd4b248bb4e2ca5d6dc538a7acb72c2f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 5155}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 5155}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "6e817cfd7c5e53d423d10e3319646e61", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5159}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5159}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "cd4b248bb4e2ca5d6dc538a7acb72c2f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5217}, "message": "save_state (fixit)"}, {"location": {"col": 17, "file": 0, "line": 5217}, "message": "invalid case style for variable 'save_State'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "4c26f182ed50fa1f17a675dca0942766", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5761}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "518124eeb620964279727a0d9e18c5e1", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 6312}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "d400da1a9b3aa8172abbeda47babb987", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7214}, "message": "old_state (fixit)"}, {"location": {"col": 7, "file": 0, "line": 7214}, "message": "invalid case style for variable 'oldState'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "559097f79b6d0d7237245aa5b89d35be", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7255}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "ee596230f326faab7206909ff973f7c8", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 7304}, "message": "l_state (fixit)"}, {"location": {"col": 13, "file": 0, "line": 7304}, "message": "invalid case style for variable 'l_State'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "53823b27d2193b8b39438caf38c95bca", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 0, "line": 7547}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "2e5cdda58076c2d651ac4f7428d057cc", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7620}, "message": "kHAlef (fixit)"}, {"location": {"col": 7, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'hALEF'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8912e516795408151d8f5b78cbeec1f9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 7620}, "message": "kBet (fixit)"}, {"location": {"col": 18, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'BET'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "47eba0c40765d3193ada3a5a796b8509", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 7620}, "message": "kGimel (fixit)"}, {"location": {"col": 23, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'GIMEL'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "5aa03df4fb9b86c3b2f33b6b5d872a74", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 7620}, "message": "kDalet (fixit)"}, {"location": {"col": 30, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'DALET'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "d8e2e1c11b6127afb22a5442e69bf06e", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 7620}, "message": "kHei (fixit)"}, {"location": {"col": 37, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'HEI'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "579c87ab073d091234c3d5d26a2a6ce9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 7620}, "message": "kVav (fixit)"}, {"location": {"col": 42, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'VAV'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "ed727db0cde9c4e44b7c307d8a2575a8", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 7620}, "message": "kZain (fixit)"}, {"location": {"col": 47, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'ZAIN'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "16c6aa321c4a5089d7cbcb0ed767c339", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 7620}, "message": "kHet (fixit)"}, {"location": {"col": 53, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'HET'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "2cc44229dea5ebd782f6cc3b789f982e", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 7620}, "message": "kTet (fixit)"}, {"location": {"col": 58, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'TET'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "702c00837400dcd1d321364823d97b61", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 7620}, "message": "kIud (fixit)"}, {"location": {"col": 63, "file": 0, "line": 7620}, "message": "invalid case style for enum constant 'IUD'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8b7a90628ac2d3ef412ee86e0de52047", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7621}, "message": "kKaFsofit (fixit)"}, {"location": {"col": 7, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'KAFsofit'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "13db68a72a02bd1a474faa6a4504675c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 7621}, "message": "kHKaf (fixit)"}, {"location": {"col": 17, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'hKAF'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "b335092ab5ce274ffcddd97553584024", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 7621}, "message": "kLamed (fixit)"}, {"location": {"col": 23, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'LAMED'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "d480dd4c49d320e5e3327d6790bfca33", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 7621}, "message": "kMeMsofit (fixit)"}, {"location": {"col": 30, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'MEMsofit'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "b36fd7f55c326e5ee70a6c3385cd17a3", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 7621}, "message": "kMem (fixit)"}, {"location": {"col": 40, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'MEM'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "1855b262f5982adb227fadcf4c351262", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 7621}, "message": "kNuNsofit (fixit)"}, {"location": {"col": 45, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'NUNsofit'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8be56180dc26be6e127eaab6d6a68069", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 7621}, "message": "kNun (fixit)"}, {"location": {"col": 55, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'NUN'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "68b7564ac86aa35f7fed159123eeaa4c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 0, "line": 7621}, "message": "kSameh (fixit)"}, {"location": {"col": 60, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'SAMEH'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "bc1095471a03b6227f499b71f97f37b9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 7621}, "message": "kAin (fixit)"}, {"location": {"col": 67, "file": 0, "line": 7621}, "message": "invalid case style for enum constant 'AIN'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "611a7ab4b7cfc37b8ef4de850a4d169b", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7622}, "message": "kPeIsofit (fixit)"}, {"location": {"col": 7, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'PEIsofit'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "e14681cf92be778747f3e45fd6b042d0", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 7622}, "message": "kPei (fixit)"}, {"location": {"col": 17, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'PEI'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "34d42bb2b13ebf624bd392733e7b2018", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 7622}, "message": "kZadIsofit (fixit)"}, {"location": {"col": 22, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'ZADIsofit'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "1fe7590dac7481ead57bbf94951a7eec", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 7622}, "message": "kZadi (fixit)"}, {"location": {"col": 33, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'ZADI'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "0d22050744cd987010ab491ffd747757", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 7622}, "message": "kKof (fixit)"}, {"location": {"col": 39, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'KOF'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "bd7ad646692e6b8457a944319abb50f5", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 7622}, "message": "kResh (fixit)"}, {"location": {"col": 44, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'RESH'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "3bc206effa2cd07bc2e797e6290138b6", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 7622}, "message": "kHShin (fixit)"}, {"location": {"col": 50, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'hSHIN'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "0d0577a685229e835159857a1fbd4363", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 57, "file": 0, "line": 7622}, "message": "kTav (fixit)"}, {"location": {"col": 57, "file": 0, "line": 7622}, "message": "invalid case style for enum constant 'TAV'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "27ecfd1136bb965ccaa2a7a6491cbdb6", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 7637}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "ec99aeab0e6e3fddf44e86fc972d5064", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 0, "line": 7643}, "message": "end of the original"}, {"location": {"col": 26, "file": 0, "line": 7643}, "message": "clone 1 starts here"}, {"location": {"col": 26, "file": 0, "line": 7645}, "message": "clone 2 starts here"}, {"location": {"col": 26, "file": 0, "line": 7641}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "703e4a057186d4975703ebcb3b68ba32", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 11, "file": 0, "line": 7682}, "message": "'signed char' to 'int' conversion; consider casting to 'unsigned char' first."}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "23d908bec793737c228935d24decee5d", "checkerName": "bugprone-signed-char-misuse", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 0, "line": 8194}, "message": "old_state (fixit)"}, {"location": {"col": 7, "file": 0, "line": 8194}, "message": "invalid case style for variable 'oldState'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "7b5950d751e68f24b33d123aa6e1016f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8542}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "8f6af86c9209c9f8984088304c6b63c6", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8919}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "f7035fc61b6c952bca0f00e5284c5d67", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 9175}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "adefaffc8c86d0eb6bdc4281780dda17", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 9248}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "06c5c07550c0c5962012c3082ce28560", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 9355}, "message": "save_state (fixit)"}, {"location": {"col": 13, "file": 0, "line": 9355}, "message": "invalid case style for variable 'save_State'"}], "macros": [], "notes": [], "path": "src/nvim/edit.c", "reportHash": "663cbf8fe17c95930e217cde48fb664e", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
