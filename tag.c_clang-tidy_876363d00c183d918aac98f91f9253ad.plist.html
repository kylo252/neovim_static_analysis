<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/tag.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * Code to handle tags and the tag stack\n */\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/tag.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/if_cscope.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/file_search.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/move.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os/input.h\"\n\n/*\n * Structure to hold pointers to various items in a tag line.\n */\ntypedef struct tag_pointers {\n  // filled in by parse_tag_line():\n  char_u  *tagname;  // start of tag name (skip \"file:\")\n  char_u  *tagname_end;  // char after tag name\n  char_u  *fname;   // first char of file name\n  char_u  *fname_end;  // char after file name\n  char_u  *command;  // first char of command\n  // filled in by parse_match():\n  char_u  *command_end;  // first char after command\n  char_u  *tag_fname;  // file name of the tags file. This is used\n  // when 'tr' is set.\n  char_u  *tagkind;  // \"kind:\" value\n  char_u  *tagkind_end;  // end of tagkind\n  char_u  *user_data;  // user_data string\n  char_u  *user_data_end;  // end of user_data\n  linenr_T tagline;        // \"line:\" value\n} tagptrs_T;\n\n/*\n * Structure to hold info about the tag pattern being used.\n */\ntypedef struct {\n  char_u      *pat;             /* the pattern */\n  int len;                      /* length of pat[] */\n  char_u      *head;            /* start of pattern head */\n  int headlen;                  /* length of head[] */\n  regmatch_T regmatch;          /* regexp program, may be NULL */\n} pat_T;\n\n// The matching tags are first stored in one of the hash tables.  In\n// which one depends on the priority of the match.\n// ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.\n// At the end, the matches from ga_match[] are concatenated, to make a list\n// sorted on priority.\n#define MT_ST_CUR       0               // static match in current file\n#define MT_GL_CUR       1               // global match in current file\n#define MT_GL_OTH       2               // global match in other file\n#define MT_ST_OTH       3               // static match in other file\n#define MT_IC_OFF       4               // add for icase match\n#define MT_RE_OFF       8               // add for regexp match\n#define MT_MASK         7               // mask for printing priority\n#define MT_COUNT        16\n\nstatic char     *mt_names[MT_COUNT/2] =\n{\"FSC\", \"F C\", \"F  \", \"FS \", \" SC\", \"  C\", \"   \", \" S \"};\n\n#define NOTAGFILE       99              /* return value for jumpto_tag */\nstatic char_u   *nofile_fname = NULL;   /* fname for NOTAGFILE error */\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"tag.c.generated.h\"\n#endif\n\nstatic char_u *bottommsg = (char_u *)N_(\"E555: at bottom of tag stack\");\nstatic char_u *topmsg = (char_u *)N_(\"E556: at top of tag stack\");\nstatic char_u *recurmsg\n  = (char_u *)N_(\"E986: cannot modify the tag stack within tagfunc\");\nstatic char_u *tfu_inv_ret_msg\n  = (char_u *)N_(\"E987: invalid return value from tagfunc\");\n\nstatic char_u   *tagmatchname = NULL;   /* name of last used tag */\n\n/*\n * Tag for preview window is remembered separately, to avoid messing up the\n * normal tagstack.\n */\nstatic taggy_T ptag_entry = { NULL, { { 0, 0, 0 }, 0, 0, NULL }, 0, 0, NULL };\n\nstatic int tfu_in_use = false;  // disallow recursive call of tagfunc\n\n// Used instead of NUL to separate tag fields in the growarrays.\n#define TAG_SEP 0x02\n\n/*\n * Jump to tag; handling of tag commands and tag stack\n *\n * *tag != NUL: \":tag {tag}\", jump to new tag, add to tag stack\n *\n * type == DT_TAG:\t\":tag [tag]\", jump to newer position or same tag again\n * type == DT_HELP:\tlike DT_TAG, but don't use regexp.\n * type == DT_POP:\t\":pop\" or CTRL-T, jump to old position\n * type == DT_NEXT:\tjump to next match of same tag\n * type == DT_PREV:\tjump to previous match of same tag\n * type == DT_FIRST:\tjump to first match of same tag\n * type == DT_LAST:\tjump to last match of same tag\n * type == DT_SELECT:\t\":tselect [tag]\", select tag from a list of all matches\n * type == DT_JUMP:\t\":tjump [tag]\", jump to tag or select tag from a list\n * type == DT_CSCOPE:\tuse cscope to find the tag\n * type == DT_LTAG:\tuse location list for displaying tag matches\n * type == DT_FREE:\tfree cached matches\n *\n * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise\n */\nint\ndo_tag(\n    char_u *tag,               // tag (pattern) to jump to\n    int type,\n    int count,\n    int forceit,                    // :ta with !\n    int verbose                    // print \"tag not found\" message\n)\n{\n  taggy_T     *tagstack = curwin->w_tagstack;\n  int tagstackidx = curwin->w_tagstackidx;\n  int tagstacklen = curwin->w_tagstacklen;\n  int cur_match = 0;\n  int cur_fnum = curbuf->b_fnum;\n  int oldtagstackidx = tagstackidx;\n  int prevtagstackidx = tagstackidx;\n  int prev_num_matches;\n  int new_tag = false;\n  int i;\n  int ic;\n  int no_regexp = false;\n  int error_cur_match = 0;\n  int save_pos = false;\n  fmark_T saved_fmark;\n  int jumped_to_tag = false;\n  int new_num_matches;\n  char_u      **new_matches;\n  int use_tagstack;\n  int skip_msg = false;\n  char_u *buf_ffname = curbuf->b_ffname;  // name for priority computation\n  int use_tfu = 1;\n\n  /* remember the matches for the last used tag */\n  static int num_matches = 0;\n  static int max_num_matches = 0;             /* limit used for match search */\n  static char_u       **matches = NULL;\n  static int flags;\n\n  if (tfu_in_use) {\n    EMSG(_(recurmsg));\n    return false;\n  }\n\n#ifdef EXITFREE\n  if (type == DT_FREE) {\n    /* remove the list of matches */\n    FreeWild(num_matches, matches);\n    cs_free_tags();\n    num_matches = 0;\n    return false;\n  }\n#endif\n\n  if (type == DT_HELP) {\n    type = DT_TAG;\n    no_regexp = true;\n    use_tfu = 0;\n  }\n\n  prev_num_matches = num_matches;\n  free_string_option(nofile_fname);\n  nofile_fname = NULL;\n\n  clearpos(&saved_fmark.mark);          /* shutup gcc 4.0 */\n  saved_fmark.fnum = 0;\n\n  // Don't add a tag to the tagstack if 'tagstack' has been reset.\n  assert(tag != NULL);\n  if (!p_tgst && *tag != NUL) {  // -V522\n    use_tagstack = false;\n    new_tag = true;\n    if (g_do_tagpreview != 0) {\n      tagstack_clear_entry(&ptag_entry);\n      ptag_entry.tagname = vim_strsave(tag);\n    }\n  } else {\n    if (g_do_tagpreview != 0) {\n      use_tagstack = false;\n    } else {\n      use_tagstack = true;\n    }\n\n    /* new pattern, add to the tag stack */\n    if (*tag != NUL\n        && (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n            || type == DT_LTAG\n            || type == DT_CSCOPE\n            )) {\n      if (g_do_tagpreview != 0) {\n        if (ptag_entry.tagname != NULL\n            && STRCMP(ptag_entry.tagname, tag) == 0) {\n          /* Jumping to same tag: keep the current match, so that\n           * the CursorHold autocommand example works. */\n          cur_match = ptag_entry.cur_match;\n          cur_fnum = ptag_entry.cur_fnum;\n        } else {\n          tagstack_clear_entry(&ptag_entry);\n          ptag_entry.tagname = vim_strsave(tag);\n        }\n      } else {\n        /*\n         * If the last used entry is not at the top, delete all tag\n         * stack entries above it.\n         */\n        while (tagstackidx < tagstacklen) {\n          tagstack_clear_entry(&tagstack[--tagstacklen]);\n        }\n\n        /* if the tagstack is full: remove oldest entry */\n        if (++tagstacklen > TAGSTACKSIZE) {\n          tagstacklen = TAGSTACKSIZE;\n          tagstack_clear_entry(&tagstack[0]);\n          for (i = 1; i < tagstacklen; i++) {\n            tagstack[i - 1] = tagstack[i];\n          }\n          tagstackidx--;\n        }\n\n        // put the tag name in the tag stack\n        tagstack[tagstackidx].tagname = vim_strsave(tag);\n\n        curwin->w_tagstacklen = tagstacklen;\n\n        save_pos = true;                // save the cursor position below\n      }\n\n      new_tag = true;\n    } else {\n      if (\n          g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n          tagstacklen == 0) {\n        // empty stack\n        EMSG(_(e_tagstack));\n        goto end_do_tag;\n      }\n\n      if (type == DT_POP) {             // go to older position\n        const bool old_KeyTyped = KeyTyped;\n        if ((tagstackidx -= count) < 0) {\n          EMSG(_(bottommsg));\n          if (tagstackidx + count == 0) {\n            // We did [num]^T from the bottom of the stack\n            tagstackidx = 0;\n            goto end_do_tag;\n          }\n          /* We weren't at the bottom of the stack, so jump all the\n           * way to the bottom now.\n           */\n          tagstackidx = 0;\n        } else if (tagstackidx >= tagstacklen)   {      // count == 0?\n          EMSG(_(topmsg));\n          goto end_do_tag;\n        }\n\n        /* Make a copy of the fmark, autocommands may invalidate the\n         * tagstack before it's used. */\n        saved_fmark = tagstack[tagstackidx].fmark;\n        if (saved_fmark.fnum != curbuf->b_fnum) {\n          /*\n           * Jump to other file. If this fails (e.g. because the\n           * file was changed) keep original position in tag stack.\n           */\n          if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n                              GETF_SETMARK, forceit) == FAIL) {\n            tagstackidx = oldtagstackidx;              // back to old posn\n            goto end_do_tag;\n          }\n          /* A BufReadPost autocommand may jump to the '\" mark, but\n           * we don't what that here. */\n          curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n        } else {\n          setpcmark();\n          curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n        }\n        curwin->w_cursor.col = saved_fmark.mark.col;\n        curwin->w_set_curswant = true;\n        check_cursor();\n        if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n          foldOpenCursor();\n\n        // remove the old list of matches\n        FreeWild(num_matches, matches);\n        cs_free_tags();\n        num_matches = 0;\n        tag_freematch();\n        goto end_do_tag;\n      }\n\n      if (type == DT_TAG\n          || type == DT_LTAG\n          ) {\n        if (g_do_tagpreview != 0) {\n          cur_match = ptag_entry.cur_match;\n          cur_fnum = ptag_entry.cur_fnum;\n        } else {\n          // \":tag\" (no argument): go to newer pattern\n          save_pos = true;              // save the cursor position below\n          if ((tagstackidx += count - 1) >= tagstacklen) {\n            /*\n             * Beyond the last one, just give an error message and\n             * go to the last one.  Don't store the cursor\n             * position.\n             */\n            tagstackidx = tagstacklen - 1;\n            EMSG(_(topmsg));\n            save_pos = false;\n          } else if (tagstackidx < 0)   {       // must have been count == 0\n            EMSG(_(bottommsg));\n            tagstackidx = 0;\n            goto end_do_tag;\n          }\n          cur_match = tagstack[tagstackidx].cur_match;\n          cur_fnum = tagstack[tagstackidx].cur_fnum;\n        }\n        new_tag = true;\n      } else {                                // go to other matching tag\n        // Save index for when selection is cancelled.\n        prevtagstackidx = tagstackidx;\n\n        if (g_do_tagpreview != 0) {\n          cur_match = ptag_entry.cur_match;\n          cur_fnum = ptag_entry.cur_fnum;\n        } else {\n          if (--tagstackidx < 0)\n            tagstackidx = 0;\n          cur_match = tagstack[tagstackidx].cur_match;\n          cur_fnum = tagstack[tagstackidx].cur_fnum;\n        }\n        switch (type) {\n        case DT_FIRST: cur_match = count - 1; break;\n        case DT_SELECT:\n        case DT_JUMP:\n        case DT_CSCOPE:\n        case DT_LAST:  cur_match = MAXCOL - 1; break;\n        case DT_NEXT:  cur_match += count; break;\n        case DT_PREV:  cur_match -= count; break;\n        }\n        if (cur_match >= MAXCOL)\n          cur_match = MAXCOL - 1;\n        else if (cur_match < 0) {\n          EMSG(_(\"E425: Cannot go before first matching tag\"));\n          skip_msg = true;\n          cur_match = 0;\n          cur_fnum = curbuf->b_fnum;\n        }\n      }\n    }\n\n    if (g_do_tagpreview != 0) {\n      if (type != DT_SELECT && type != DT_JUMP) {\n        ptag_entry.cur_match = cur_match;\n        ptag_entry.cur_fnum = cur_fnum;\n      }\n    } else {\n      /*\n       * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n       */\n      saved_fmark = tagstack[tagstackidx].fmark;\n      if (save_pos) {\n        tagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n        tagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n      }\n\n      /* Curwin will change in the call to jumpto_tag() if \":stag\" was\n       * used or an autocommand jumps to another window; store value of\n       * tagstackidx now. */\n      curwin->w_tagstackidx = tagstackidx;\n      if (type != DT_SELECT && type != DT_JUMP) {\n        curwin->w_tagstack[tagstackidx].cur_match = cur_match;\n        curwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n      }\n    }\n  }\n\n  /* When not using the current buffer get the name of buffer \"cur_fnum\".\n   * Makes sure that the tag order doesn't change when using a remembered\n   * position for \"cur_match\". */\n  if (cur_fnum != curbuf->b_fnum) {\n    buf_T *buf = buflist_findnr(cur_fnum);\n\n    if (buf != NULL)\n      buf_ffname = buf->b_ffname;\n  }\n\n  /*\n   * Repeat searching for tags, when a file has not been found.\n   */\n  for (;; ) {\n    int other_name;\n    char_u      *name;\n\n    // When desired match not found yet, try to find it (and others).\n    if (use_tagstack) {\n      name = tagstack[tagstackidx].tagname;\n    } else if (g_do_tagpreview != 0) {\n      name = ptag_entry.tagname;\n    } else {\n      name = tag;\n    }\n    other_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n    if (new_tag\n        || (cur_match >= num_matches && max_num_matches != MAXCOL)\n        || other_name) {\n      if (other_name) {\n        xfree(tagmatchname);\n        tagmatchname = vim_strsave(name);\n      }\n\n      if (type == DT_SELECT || type == DT_JUMP\n          || type == DT_LTAG) {\n        cur_match = MAXCOL - 1;\n      }\n      if (type == DT_TAG) {\n        max_num_matches = MAXCOL;\n      } else {\n        max_num_matches = cur_match + 1;\n      }\n\n      // when the argument starts with '/', use it as a regexp\n      if (!no_regexp && *name == '/') {\n        flags = TAG_REGEXP;\n        ++name;\n      } else\n        flags = TAG_NOIC;\n\n      if (type == DT_CSCOPE) {\n        flags = TAG_CSCOPE;\n      }\n      if (verbose) {\n        flags |= TAG_VERBOSE;\n      }\n      if (!use_tfu) {\n        flags |= TAG_NO_TAGFUNC;\n      }\n\n      if (find_tags(name, &new_num_matches, &new_matches, flags,\n                    max_num_matches, buf_ffname) == OK\n          && new_num_matches < max_num_matches) {\n        max_num_matches = MAXCOL;  // If less than max_num_matches\n                                   // found: all matches found.\n      }\n\n      /* If there already were some matches for the same name, move them\n       * to the start.  Avoids that the order changes when using\n       * \":tnext\" and jumping to another file. */\n      if (!new_tag && !other_name) {\n        int         j, k;\n        int         idx = 0;\n        tagptrs_T   tagp, tagp2;\n\n        // Find the position of each old match in the new list.  Need\n        // to use parse_match() to find the tag line.\n        for (j = 0; j < num_matches; j++) {\n          parse_match(matches[j], &tagp);\n          for (i = idx; i < new_num_matches; ++i) {\n            parse_match(new_matches[i], &tagp2);\n            if (STRCMP(tagp.tagname, tagp2.tagname) == 0) {\n              char_u *p = new_matches[i];\n              for (k = i; k > idx; k--) {\n                new_matches[k] = new_matches[k - 1];\n              }\n              new_matches[idx++] = p;\n              break;\n            }\n          }\n        }\n      }\n      FreeWild(num_matches, matches);\n      num_matches = new_num_matches;\n      matches = new_matches;\n    }\n\n    if (num_matches <= 0) {\n      if (verbose)\n        EMSG2(_(\"E426: tag not found: %s\"), name);\n      g_do_tagpreview = 0;\n    } else {\n      bool ask_for_selection = false;\n\n      if (type == DT_CSCOPE && num_matches > 1) {\n        cs_print_tags();\n        ask_for_selection = true;\n      } else if (type == DT_TAG && *tag != NUL) {\n        // If a count is supplied to the \":tag <name>\" command, then\n        // jump to count'th matching tag.\n        cur_match = count > 0 ? count - 1 : 0;\n      } else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1)) {\n        print_tag_list(new_tag, use_tagstack, num_matches, matches);\n        ask_for_selection = true;\n      } else if (type == DT_LTAG)   {\n        if (add_llist_tags(tag, num_matches, matches) == FAIL) {\n          goto end_do_tag;\n        }\n\n        cur_match = 0;                  // Jump to the first tag\n      }\n\n      if (ask_for_selection) {\n        // Ask to select a tag from the list.\n        i = prompt_for_number(NULL);\n        if (i <= 0 || i > num_matches || got_int) {\n          // no valid choice: don't change anything\n          if (use_tagstack) {\n            tagstack[tagstackidx].fmark = saved_fmark;\n            tagstackidx = prevtagstackidx;\n          }\n          cs_free_tags();\n          jumped_to_tag = true;\n          break;\n        }\n        cur_match = i - 1;\n      }\n\n      if (cur_match >= num_matches) {\n        /* Avoid giving this error when a file wasn't found and we're\n         * looking for a match in another file, which wasn't found.\n         * There will be an EMSG(\"file doesn't exist\") below then. */\n        if ((type == DT_NEXT || type == DT_FIRST)\n            && nofile_fname == NULL) {\n          if (num_matches == 1)\n            EMSG(_(\"E427: There is only one matching tag\"));\n          else\n            EMSG(_(\"E428: Cannot go beyond last matching tag\"));\n          skip_msg = true;\n        }\n        cur_match = num_matches - 1;\n      }\n      if (use_tagstack) {\n        tagptrs_T   tagp2;\n\n        tagstack[tagstackidx].cur_match = cur_match;\n        tagstack[tagstackidx].cur_fnum = cur_fnum;\n\n        // store user-provided data originating from tagfunc\n        if (use_tfu && parse_match(matches[cur_match], &tagp2) == OK\n            && tagp2.user_data) {\n          XFREE_CLEAR(tagstack[tagstackidx].user_data);\n          tagstack[tagstackidx].user_data = vim_strnsave(\n              tagp2.user_data, tagp2.user_data_end - tagp2.user_data);\n        }\n\n        tagstackidx++;\n      } else if (g_do_tagpreview != 0)   {\n        ptag_entry.cur_match = cur_match;\n        ptag_entry.cur_fnum = cur_fnum;\n      }\n\n      /*\n       * Only when going to try the next match, report that the previous\n       * file didn't exist.  Otherwise an EMSG() is given below.\n       */\n      if (nofile_fname != NULL && error_cur_match != cur_match)\n        smsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n      ic = (matches[cur_match][0] & MT_IC_OFF);\n      if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n          && type != DT_CSCOPE\n          && (num_matches > 1 || ic)\n          && !skip_msg) {\n        // Give an indication of the number of matching tags\n        snprintf((char *)IObuff, sizeof(IObuff), _(\"tag %d of %d%s\"),\n                 cur_match + 1,\n                 num_matches,\n                 max_num_matches != MAXCOL ? _(\" or more\") : \"\");\n        if (ic) {\n          STRCAT(IObuff, _(\"  Using tag with different case!\"));\n        }\n        if ((num_matches > prev_num_matches || new_tag)\n            && num_matches > 1) {\n          if (ic) {\n            msg_attr((const char *)IObuff, HL_ATTR(HLF_W));\n          } else {\n            msg(IObuff);\n          }\n          msg_scroll = true;  // Don't overwrite this message.\n        } else {\n          give_warning(IObuff, ic);\n        }\n        if (ic && !msg_scrolled && msg_silent == 0) {\n          ui_flush();\n          os_delay(1007L, true);\n        }\n      }\n\n      // Let the SwapExists event know what tag we are jumping to.\n      vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n      set_vim_var_string(VV_SWAPCOMMAND, (char *) IObuff, -1);\n\n      /*\n       * Jump to the desired match.\n       */\n      i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n      set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n\n      if (i == NOTAGFILE) {\n        // File not found: try again with another matching tag\n        if ((type == DT_PREV && cur_match > 0)\n            || ((type == DT_TAG || type == DT_NEXT\n                 || type == DT_FIRST)\n                && (max_num_matches != MAXCOL\n                    || cur_match < num_matches - 1))) {\n          error_cur_match = cur_match;\n          if (use_tagstack)\n            --tagstackidx;\n          if (type == DT_PREV)\n            --cur_match;\n          else {\n            type = DT_NEXT;\n            ++cur_match;\n          }\n          continue;\n        }\n        EMSG2(_(\"E429: File \\\"%s\\\" does not exist\"), nofile_fname);\n      } else {\n        /* We may have jumped to another window, check that\n         * tagstackidx is still valid. */\n        if (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n          tagstackidx = curwin->w_tagstackidx;\n        jumped_to_tag = true;\n      }\n    }\n    break;\n  }\n\nend_do_tag:\n  // Only store the new index when using the tagstack and it's valid.\n  if (use_tagstack && tagstackidx <= curwin->w_tagstacklen) {\n    curwin->w_tagstackidx = tagstackidx;\n  }\n  postponed_split = 0;          // don't split next time\n  g_do_tagpreview = 0;          // don't do tag preview next time\n\n  return jumped_to_tag;\n}\n\n//\n// List all the matching tags.\n//\nstatic void\nprint_tag_list(\n    int         new_tag,\n    int         use_tagstack,\n    int         num_matches,\n    char_u      **matches)\n{\n    taggy_T     *tagstack = curwin->w_tagstack;\n    int         tagstackidx = curwin->w_tagstackidx;\n    int         i;\n    char_u      *p;\n    char_u      *command_end;\n    tagptrs_T   tagp;\n    int         taglen;\n    int         attr;\n\n    // Assume that the first match indicates how long the tags can\n    // be, and align the file names to that.\n    parse_match(matches[0], &tagp);\n    taglen = (int)(tagp.tagname_end - tagp.tagname + 2);\n    if (taglen < 18) {\n        taglen = 18;\n    }\n    if (taglen > Columns - 25) {\n        taglen = MAXCOL;\n    }\n    if (msg_col == 0) {\n        msg_didout = false;     // overwrite previous message\n    }\n    msg_start();\n    msg_puts_attr(_(\"  # pri kind tag\"), HL_ATTR(HLF_T));\n    msg_clr_eos();\n    taglen_advance(taglen);\n    msg_puts_attr(_(\"file\\n\"), HL_ATTR(HLF_T));\n\n    for (i = 0; i < num_matches && !got_int; i++) {\n        parse_match(matches[i], &tagp);\n        if (!new_tag && (\n            (g_do_tagpreview != 0\n             && i == ptag_entry.cur_match)\n            || (use_tagstack\n                && i == tagstack[tagstackidx].cur_match))) {\n            *IObuff = '>';\n        } else {\n            *IObuff = ' ';\n        }\n        vim_snprintf((char *)IObuff + 1, IOSIZE - 1,\n                     \"%2d %s \", i + 1,\n                     mt_names[matches[i][0] & MT_MASK]);\n        msg_puts((char *)IObuff);\n        if (tagp.tagkind != NULL) {\n            msg_outtrans_len(tagp.tagkind,\n                             (int)(tagp.tagkind_end - tagp.tagkind));\n        }\n        msg_advance(13);\n        msg_outtrans_len_attr(tagp.tagname,\n                              (int)(tagp.tagname_end - tagp.tagname),\n                              HL_ATTR(HLF_T));\n        msg_putchar(' ');\n        taglen_advance(taglen);\n\n        // Find out the actual file name. If it is long, truncate\n        // it and put \"...\" in the middle\n        p = tag_full_fname(&tagp);\n        if (p != NULL) {\n            msg_outtrans_attr(p, HL_ATTR(HLF_D));\n            XFREE_CLEAR(p);\n        }\n        if (msg_col > 0) {\n            msg_putchar('\\n');\n        }\n        if (got_int) {\n            break;\n        }\n        msg_advance(15);\n\n        // print any extra fields\n        command_end = tagp.command_end;\n        if (command_end != NULL) {\n            p = command_end + 3;\n            while (*p && *p != '\\r' && *p != '\\n') {\n                while (*p == TAB) {\n                    p++;\n                }\n\n                // skip \"file:\" without a value (static tag)\n                if (STRNCMP(p, \"file:\", 5) == 0 && ascii_isspace(p[5])) {\n                    p += 5;\n                    continue;\n                }\n                // skip \"kind:<kind>\" and \"<kind>\"\n                if (p == tagp.tagkind\n                    || (p + 5 == tagp.tagkind\n                        && STRNCMP(p, \"kind:\", 5) == 0)) {\n                    p = tagp.tagkind_end;\n                    continue;\n                }\n                // print all other extra fields\n                attr = HL_ATTR(HLF_CM);\n                while (*p && *p != '\\r' && *p != '\\n') {\n                    if (msg_col + ptr2cells(p) >= Columns) {\n                        msg_putchar('\\n');\n                        if (got_int) {\n                            break;\n                        }\n                        msg_advance(15);\n                    }\n                    p = msg_outtrans_one(p, attr);\n                    if (*p == TAB) {\n                        msg_puts_attr(\" \", attr);\n                        break;\n                    }\n                    if (*p == ':') {\n                        attr = 0;\n                    }\n                }\n            }\n            if (msg_col > 15) {\n                msg_putchar('\\n');\n                if (got_int) {\n                    break;\n                }\n                msg_advance(15);\n            }\n        } else {\n            for (p = tagp.command;\n                 *p && *p != '\\r' && *p != '\\n';\n                 p++) {\n            }\n            command_end = p;\n        }\n\n        // Put the info (in several lines) at column 15.\n        // Don't display \"/^\" and \"?^\".\n        p = tagp.command;\n        if (*p == '/' || *p == '?') {\n            p++;\n            if (*p == '^') {\n                p++;\n            }\n        }\n        // Remove leading whitespace from pattern\n        while (p != command_end && ascii_isspace(*p)) {\n            p++;\n        }\n\n        while (p != command_end) {\n            if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns) {\n                msg_putchar('\\n');\n            }\n            if (got_int) {\n                break;\n            }\n            msg_advance(15);\n\n            // skip backslash used for escaping a command char or\n            // a backslash\n            if (*p == '\\\\' && (*(p + 1) == *tagp.command\n                               || *(p + 1) == '\\\\')) {\n                p++;\n            }\n\n            if (*p == TAB) {\n                msg_putchar(' ');\n                p++;\n            } else {\n                p = msg_outtrans_one(p, 0);\n            }\n\n            // don't display the \"$/;\\\"\" and \"$?;\\\"\"\n            if (p == command_end - 2 && *p == '$'\n                && *(p + 1) == *tagp.command) {\n                break;\n            }\n            // don't display matching '/' or '?'\n            if (p == command_end - 1 && *p == *tagp.command\n                && (*p == '/' || *p == '?')) {\n                break;\n            }\n        }\n        if (msg_col) {\n            msg_putchar('\\n');\n        }\n        os_breakcheck();\n    }\n    if (got_int) {\n        got_int = false;        // only stop the listing\n    }\n}\n\n//\n// Add the matching tags to the location list for the current\n// window.\n//\nstatic int\nadd_llist_tags(\n    char_u      *tag,\n    int         num_matches,\n    char_u      **matches)\n{\n    list_T      *list;\n    char_u      tag_name[128 + 1];\n    char_u      *fname;\n    char_u      *cmd;\n    int         i;\n    char_u      *p;\n    tagptrs_T   tagp;\n\n    fname = xmalloc(MAXPATHL + 1);\n    cmd = xmalloc(CMDBUFFSIZE + 1);\n    list = tv_list_alloc(0);\n\n    for (i = 0; i < num_matches; i++) {\n        int len, cmd_len;\n        long    lnum;\n        dict_T  *dict;\n\n        parse_match(matches[i], &tagp);\n\n        // Save the tag name\n        len = (int)(tagp.tagname_end - tagp.tagname);\n        if (len > 128) {\n            len = 128;\n        }\n        xstrlcpy((char *)tag_name, (const char *)tagp.tagname, len + 1);\n        tag_name[len] = NUL;\n\n        // Save the tag file name\n        p = tag_full_fname(&tagp);\n        if (p == NULL) {\n            continue;\n        }\n        xstrlcpy((char *)fname, (const char *)p, MAXPATHL);\n        XFREE_CLEAR(p);\n\n        // Get the line number or the search pattern used to locate\n        // the tag.\n        lnum = 0;\n        if (isdigit(*tagp.command)) {\n            // Line number is used to locate the tag\n            lnum = atol((char *)tagp.command);\n        } else {\n            char_u *cmd_start, *cmd_end;\n\n            // Search pattern is used to locate the tag\n\n            // Locate the end of the command\n            cmd_start = tagp.command;\n            cmd_end = tagp.command_end;\n            if (cmd_end == NULL) {\n                for (p = tagp.command;\n                     *p && *p != '\\r' && *p != '\\n'; p++) {\n                }\n                cmd_end = p;\n            }\n\n            // Now, cmd_end points to the character after the\n            // command. Adjust it to point to the last\n            // character of the command.\n            cmd_end--;\n\n            // Skip the '/' and '?' characters at the\n            // beginning and end of the search pattern.\n            if (*cmd_start == '/' || *cmd_start == '?') {\n                cmd_start++;\n            }\n\n            if (*cmd_end == '/' || *cmd_end == '?') {\n                cmd_end--;\n            }\n\n            len = 0;\n            cmd[0] = NUL;\n\n            // If \"^\" is present in the tag search pattern, then\n            // copy it first.\n            if (*cmd_start == '^') {\n                STRCPY(cmd, \"^\");\n                cmd_start++;\n                len++;\n            }\n\n            // Precede the tag pattern with \\V to make it very\n            // nomagic.\n            STRCAT(cmd, \"\\\\V\");\n            len += 2;\n\n            cmd_len = (int)(cmd_end - cmd_start + 1);\n            if (cmd_len > (CMDBUFFSIZE - 5)) {\n                cmd_len = CMDBUFFSIZE - 5;\n            }\n            snprintf((char *)cmd + len, CMDBUFFSIZE + 1 - len,\n                     \"%.*s\", cmd_len, cmd_start);\n            len += cmd_len;\n\n            if (cmd[len - 1] == '$') {\n                // Replace '$' at the end of the search pattern\n                // with '\\$'\n                cmd[len - 1] = '\\\\';\n                cmd[len] = '$';\n                len++;\n            }\n\n            cmd[len] = NUL;\n        }\n\n        dict = tv_dict_alloc();\n        tv_list_append_dict(list, dict);\n\n        tv_dict_add_str(dict, S_LEN(\"text\"), (const char *)tag_name);\n        tv_dict_add_str(dict, S_LEN(\"filename\"), (const char *)fname);\n        tv_dict_add_nr(dict, S_LEN(\"lnum\"), lnum);\n        if (lnum == 0) {\n            tv_dict_add_str(dict, S_LEN(\"pattern\"), (const char *)cmd);\n        }\n    }\n\n    vim_snprintf((char *)IObuff, IOSIZE, \"ltag %s\", tag);\n    set_errorlist(curwin, list, ' ', IObuff, NULL);\n\n    tv_list_free(list);\n    XFREE_CLEAR(fname);\n    XFREE_CLEAR(cmd);\n\n    return OK;\n}\n\n/*\n * Free cached tags.\n */\nvoid tag_freematch(void)\n{\n  XFREE_CLEAR(tagmatchname);\n}\n\nstatic void taglen_advance(int l)\n{\n  if (l == MAXCOL) {\n    msg_putchar('\\n');\n    msg_advance(24);\n  } else\n    msg_advance(13 + l);\n}\n\n/*\n * Print the tag stack\n */\nvoid do_tags(exarg_T *eap)\n{\n  int i;\n  char_u      *name;\n  taggy_T     *tagstack = curwin->w_tagstack;\n  int tagstackidx = curwin->w_tagstackidx;\n  int tagstacklen = curwin->w_tagstacklen;\n\n  /* Highlight title */\n  MSG_PUTS_TITLE(_(\"\\n  # TO tag         FROM line  in file/text\"));\n  for (i = 0; i < tagstacklen; ++i) {\n    if (tagstack[i].tagname != NULL) {\n      name = fm_getname(&(tagstack[i].fmark), 30);\n      if (name == NULL)             /* file name not available */\n        continue;\n\n      msg_putchar('\\n');\n      vim_snprintf((char *)IObuff, IOSIZE, \"%c%2d %2d %-15s %5ld  \",\n                   i == tagstackidx ? '>' : ' ',\n                   i + 1,\n                   tagstack[i].cur_match + 1,\n                   tagstack[i].tagname,\n                   tagstack[i].fmark.mark.lnum);\n      msg_outtrans(IObuff);\n      msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum\n                        ? HL_ATTR(HLF_D) : 0);\n      xfree(name);\n    }\n    ui_flush();                    /* show one line at a time */\n  }\n  if (tagstackidx == tagstacklen)       /* idx at top of stack */\n    MSG_PUTS(\"\\n>\");\n}\n\n\n\n/*\n * Compare two strings, for length \"len\", ignoring case the ASCII way.\n * return 0 for match, < 0 for smaller, > 0 for bigger\n * Make sure case is folded to uppercase in comparison (like for 'sort -f')\n */\nstatic int tag_strnicmp(char_u *s1, char_u *s2, size_t len)\n{\n  int i;\n\n  while (len > 0) {\n    i = TOUPPER_ASC(*s1) - TOUPPER_ASC(*s2);\n    if (i != 0)\n      return i;                         /* this character different */\n    if (*s1 == NUL)\n      break;                            /* strings match until NUL */\n    ++s1;\n    ++s2;\n    --len;\n  }\n  return 0;                             /* strings match */\n}\n\n\n/*\n * Extract info from the tag search pattern \"pats->pat\".\n */\nstatic void prepare_pats(pat_T *pats, int has_re)\n{\n  pats->head = pats->pat;\n  pats->headlen = pats->len;\n  if (has_re) {\n    /* When the pattern starts with '^' or \"\\\\<\", binary searching can be\n     * used (much faster). */\n    if (pats->pat[0] == '^')\n      pats->head = pats->pat + 1;\n    else if (pats->pat[0] == '\\\\' && pats->pat[1] == '<')\n      pats->head = pats->pat + 2;\n    if (pats->head == pats->pat)\n      pats->headlen = 0;\n    else\n      for (pats->headlen = 0; pats->head[pats->headlen] != NUL;\n           ++pats->headlen)\n        if (vim_strchr((char_u *)(p_magic ? \".[~*\\\\$\" : \"\\\\$\"),\n                pats->head[pats->headlen]) != NULL)\n          break;\n    if (p_tl != 0 && pats->headlen > p_tl)      /* adjust for 'taglength' */\n      pats->headlen = p_tl;\n  }\n\n  if (has_re)\n    pats->regmatch.regprog = vim_regcomp(pats->pat, p_magic ? RE_MAGIC : 0);\n  else\n    pats->regmatch.regprog = NULL;\n}\n\n//\n// Call the user-defined function to generate a list of tags used by\n// find_tags().\n//\n// Return OK if at least 1 tag has been successfully found,\n// NOTDONE if the function returns v:null, and FAIL otherwise.\n//\nstatic int find_tagfunc_tags(\n    char_u  *pat,        // pattern supplied to the user-defined function\n    garray_T  *ga,       // the tags will be placed here\n    int   *match_count,  // here the number of tags found will be placed\n    int   flags,         // flags from find_tags (TAG_*)\n    char_u *buf_ffname)  // name of buffer for priority\n{\n  pos_T       save_pos;\n  list_T      *taglist;\n  int         ntags = 0;\n  int         result = FAIL;\n  typval_T  args[4];\n  typval_T  rettv;\n  char_u flagString[4];\n  taggy_T *tag = &curwin->w_tagstack[curwin->w_tagstackidx];\n\n  if (*curbuf->b_p_tfu == NUL) {\n    return FAIL;\n  }\n\n  args[0].v_type = VAR_STRING;\n  args[0].vval.v_string = pat;\n  args[1].v_type = VAR_STRING;\n  args[1].vval.v_string = flagString;\n\n  // create 'info' dict argument\n  dict_T *const d = tv_dict_alloc_lock(VAR_FIXED);\n  if (tag->user_data != NULL) {\n    tv_dict_add_str(d, S_LEN(\"user_data\"), (const char *)tag->user_data);\n  }\n  if (buf_ffname != NULL) {\n    tv_dict_add_str(d, S_LEN(\"buf_ffname\"), (const char *)buf_ffname);\n  }\n\n  d->dv_refcount++;\n  args[2].v_type = VAR_DICT;\n  args[2].vval.v_dict = d;\n\n  args[3].v_type = VAR_UNKNOWN;\n\n  vim_snprintf((char *)flagString, sizeof(flagString),\n               \"%s%s%s\",\n               g_tag_at_cursor      ? \"c\": \"\",\n               flags & TAG_INS_COMP ? \"i\": \"\",\n               flags & TAG_REGEXP   ? \"r\": \"\");\n\n  save_pos = curwin->w_cursor;\n  result = call_vim_function(curbuf->b_p_tfu, 3, args, &rettv);\n  curwin->w_cursor = save_pos;  // restore the cursor position\n  d->dv_refcount--;\n\n  if (result == FAIL) {\n    return FAIL;\n  }\n  if (rettv.v_type == VAR_SPECIAL && rettv.vval.v_special == kSpecialVarNull) {\n    tv_clear(&rettv);\n    return NOTDONE;\n  }\n  if (rettv.v_type != VAR_LIST || !rettv.vval.v_list) {\n    tv_clear(&rettv);\n    EMSG(_(tfu_inv_ret_msg));\n    return FAIL;\n  }\n  taglist = rettv.vval.v_list;\n\n  TV_LIST_ITER_CONST(taglist, li, {\n    char_u    *res_name;\n    char_u    *res_fname;\n    char_u    *res_cmd;\n    char_u    *res_kind;\n    int   has_extra = 0;\n    int   name_only = flags & TAG_NAMES;\n\n    if (TV_LIST_ITEM_TV(li)->v_type != VAR_DICT) {\n      EMSG(_(tfu_inv_ret_msg));\n      break;\n    }\n\n    size_t len = 2;\n    res_name = NULL;\n    res_fname = NULL;\n    res_cmd = NULL;\n    res_kind = NULL;\n\n    TV_DICT_ITER(TV_LIST_ITEM_TV(li)->vval.v_dict, di, {\n      const char_u *dict_key = di->di_key;\n      typval_T *tv = &di->di_tv;\n\n      if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL) {\n        continue;\n      }\n\n      len += STRLEN(tv->vval.v_string) + 1;   // Space for \"\\tVALUE\"\n      if (!STRCMP(dict_key, \"name\")) {\n        res_name = tv->vval.v_string;\n        continue;\n      }\n      if (!STRCMP(dict_key, \"filename\")) {\n        res_fname = tv->vval.v_string;\n        continue;\n      }\n      if (!STRCMP(dict_key, \"cmd\")) {\n        res_cmd = tv->vval.v_string;\n        continue;\n      }\n      has_extra = 1;\n      if (!STRCMP(dict_key, \"kind\")) {\n        res_kind = tv->vval.v_string;\n        continue;\n      }\n      // Other elements will be stored as \"\\tKEY:VALUE\"\n      // Allocate space for the key and the colon\n      len += STRLEN(dict_key) + 1;\n    });\n\n    if (has_extra) {\n      len += 2;  // need space for ;\"\n    }\n\n    if (!res_name || !res_fname || !res_cmd) {\n      EMSG(_(tfu_inv_ret_msg));\n      break;\n    }\n\n    char_u *const mfp = name_only ? vim_strsave(res_name) : xmalloc(len + 2);\n\n    if (!name_only) {\n      char_u *p = mfp;\n\n      *p++ = MT_GL_OTH + 1;   // mtt\n      *p++ = TAG_SEP;     // no tag file name\n\n      STRCPY(p, res_name);\n      p += STRLEN(p);\n\n      *p++ = TAB;\n      STRCPY(p, res_fname);\n      p += STRLEN(p);\n\n      *p++ = TAB;\n      STRCPY(p, res_cmd);\n      p += STRLEN(p);\n\n      if (has_extra) {\n        STRCPY(p, \";\\\"\");\n        p += STRLEN(p);\n\n        if (res_kind) {\n          *p++ = TAB;\n          STRCPY(p, res_kind);\n          p += STRLEN(p);\n        }\n\n        TV_DICT_ITER(TV_LIST_ITEM_TV(li)->vval.v_dict, di, {\n          const char_u *dict_key = di->di_key;\n          typval_T *tv = &di->di_tv;\n          if (tv->v_type != VAR_STRING || tv->vval.v_string == NULL) {\n            continue;\n          }\n\n          if (!STRCMP(dict_key, \"name\")) {\n            continue;\n          }\n          if (!STRCMP(dict_key, \"filename\")) {\n            continue;\n          }\n          if (!STRCMP(dict_key, \"cmd\")) {\n            continue;\n          }\n          if (!STRCMP(dict_key, \"kind\")) {\n            continue;\n          }\n\n          *p++ = TAB;\n          STRCPY(p, dict_key);\n          p += STRLEN(p);\n          STRCPY(p, \":\");\n          p += STRLEN(p);\n          STRCPY(p, tv->vval.v_string);\n          p += STRLEN(p);\n        });\n      }\n    }\n\n    // Add all matches because tagfunc should do filtering.\n    ga_grow(ga, 1);\n    ((char_u **)(ga->ga_data))[ga->ga_len++] = mfp;\n    ntags++;\n    result = OK;\n  });\n\n  tv_clear(&rettv);\n\n  *match_count = ntags;\n  return result;\n}\n\n/*\n * find_tags() - search for tags in tags files\n *\n * Return FAIL if search completely failed (*num_matches will be 0, *matchesp\n * will be NULL), OK otherwise.\n *\n * There is a priority in which type of tag is recognized.\n *\n *  6.\tA static or global tag with a full matching tag for the current file.\n *  5.\tA global tag with a full matching tag for another file.\n *  4.\tA static tag with a full matching tag for another file.\n *  3.\tA static or global tag with an ignore-case matching tag for the\n *\tcurrent file.\n *  2.\tA global tag with an ignore-case matching tag for another file.\n *  1.\tA static tag with an ignore-case matching tag for another file.\n *\n * Tags in an emacs-style tags file are always global.\n *\n * flags:\n * TAG_HELP\t  only search for help tags\n * TAG_NAMES\t  only return name of tag\n * TAG_REGEXP\t  use \"pat\" as a regexp\n * TAG_NOIC\t  don't always ignore case\n * TAG_KEEP_LANG  keep language\n * TAG_CSCOPE\t  use cscope results for tags\n * TAG_NO_TAGFUNC do not call the 'tagfunc' function\n */\nint\nfind_tags(\n    char_u *pat,                       // pattern to search for\n    int *num_matches,               // return: number of matches found\n    char_u ***matchesp,                // return: array of matches found\n    int flags,\n    int mincount,                           /*  MAXCOL: find all matches\n                                             other: minimal number of matches */\n    char_u *buf_ffname                /* name of buffer for priority */\n)\n{\n  FILE       *fp;\n  char_u     *lbuf;                     /* line buffer */\n  int lbuf_size = LSIZE;                /* length of lbuf */\n  char_u     *tag_fname;                /* name of tag file */\n  tagname_T tn;                         /* info for get_tagfname() */\n  int first_file;                       /* trying first tag file */\n  tagptrs_T tagp;\n  bool did_open = false;                // did open a tag file\n  bool stop_searching = false;          // stop when match found or error\n  int retval = FAIL;                    // return value\n  int is_static;                        // current tag line is static\n  int is_current;                       // file name matches\n  bool eof = false;                     // found end-of-file\n  char_u      *p;\n  char_u      *s;\n  int i;\n  int tag_file_sorted = NUL;            // !_TAG_FILE_SORTED value\n  struct tag_search_info {      // Binary search file offsets\n    off_T low_offset;           // offset for first char of first line that\n                                // could match\n    off_T high_offset;          // offset of char after last line that could\n                                // match\n    off_T curr_offset;          // Current file offset in search range\n    off_T curr_offset_used;     // curr_offset used when skipping back\n    off_T match_offset;         // Where the binary search found a tag\n    int low_char;               // first char at low_offset\n    int high_char;              // first char at high_offset\n  } search_info;\n  int tagcmp;\n  off_T offset;\n  int round;\n  enum {\n    TS_START,                   /* at start of file */\n    TS_LINEAR                   /* linear searching forward, till EOF */\n    , TS_BINARY,                /* binary searching */\n    TS_SKIP_BACK,               /* skipping backwards */\n    TS_STEP_FORWARD             /* stepping forwards */\n  }   state;                    /* Current search state */\n\n  int cmplen;\n  int match;                    /* matches */\n  int match_no_ic = 0;          /* matches with rm_ic == FALSE */\n  int match_re;                 /* match with regexp */\n  int matchoff = 0;\n  int save_emsg_off;\n\n\n  char_u *mfp;\n  garray_T ga_match[MT_COUNT];   // stores matches in sequence\n  hashtab_T ht_match[MT_COUNT];  // stores matches by key\n  hash_T hash = 0;\n  int match_count = 0;                          // number of matches found\n  char_u      **matches;\n  int mtt;\n  int help_save;\n  int help_pri = 0;\n  char_u      *help_lang_find = NULL;           // lang to be found\n  char_u help_lang[3];                          // lang of current tags file\n  char_u      *saved_pat = NULL;                // copy of pat[]\n  bool is_txt = false;\n\n  pat_T orgpat;                         /* holds unconverted pattern info */\n  vimconv_T vimconv;\n\n  int findall = (mincount == MAXCOL || mincount == TAG_MANY);\n  // find all matching tags\n  bool sort_error = false;                      // tags file not sorted\n  int linear;                                   // do a linear search\n  bool sortic = false;                          // tag file sorted in nocase\n  bool line_error = false;                      // syntax error\n  int has_re = (flags & TAG_REGEXP);            // regexp used\n  int help_only = (flags & TAG_HELP);\n  int name_only = (flags & TAG_NAMES);\n  int noic = (flags & TAG_NOIC);\n  int get_it_again = FALSE;\n  int use_cscope = (flags & TAG_CSCOPE);\n  int verbose = (flags & TAG_VERBOSE);\n  int use_tfu = ((flags & TAG_NO_TAGFUNC) == 0);\n  int save_p_ic = p_ic;\n\n  // Change the value of 'ignorecase' according to 'tagcase' for the\n  // duration of this function.\n  switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags) {\n    case TC_FOLLOWIC:\n      break;\n    case TC_IGNORE:\n      p_ic = true;\n      break;\n    case TC_MATCH:\n      p_ic = false;\n      break;\n    case TC_FOLLOWSCS:\n      p_ic = ignorecase(pat);\n      break;\n    case TC_SMART:\n      p_ic = ignorecase_opt(pat, true, true);\n      break;\n    default:\n      abort();\n  }\n\n  help_save = curbuf->b_help;\n  orgpat.pat = pat;\n  orgpat.regmatch.regprog = NULL;\n  vimconv.vc_type = CONV_NONE;\n\n  /*\n   * Allocate memory for the buffers that are used\n   */\n  lbuf = xmalloc(lbuf_size);\n  tag_fname = xmalloc(MAXPATHL + 1);\n  for (mtt = 0; mtt < MT_COUNT; mtt++) {\n    ga_init(&ga_match[mtt], sizeof(char_u *), 100);\n    hash_init(&ht_match[mtt]);\n  }\n\n  STRCPY(tag_fname, \"from cscope\");             /* for error messages */\n\n  /*\n   * Initialize a few variables\n   */\n  if (help_only) {                              // want tags from help file\n    curbuf->b_help = true;                      // will be restored later\n  } else if (use_cscope) {\n    // Make sure we don't mix help and cscope, confuses Coverity.\n    help_only = false;\n    curbuf->b_help = false;\n  }\n\n  orgpat.len = (int)STRLEN(pat);\n  if (curbuf->b_help) {\n    /* When \"@ab\" is specified use only the \"ab\" language, otherwise\n     * search all languages. */\n    if (orgpat.len > 3 && pat[orgpat.len - 3] == '@'\n        && ASCII_ISALPHA(pat[orgpat.len - 2])\n        && ASCII_ISALPHA(pat[orgpat.len - 1])) {\n      saved_pat = vim_strnsave(pat, orgpat.len - 3);\n      help_lang_find = &pat[orgpat.len - 2];\n      orgpat.pat = saved_pat;\n      orgpat.len -= 3;\n    }\n  }\n  if (p_tl != 0 && orgpat.len > p_tl)           /* adjust for 'taglength' */\n    orgpat.len = p_tl;\n\n  save_emsg_off = emsg_off;\n  emsg_off = TRUE;    /* don't want error for invalid RE here */\n  prepare_pats(&orgpat, has_re);\n  emsg_off = save_emsg_off;\n  if (has_re && orgpat.regmatch.regprog == NULL)\n    goto findtag_end;\n\n  // This is only to avoid a compiler warning for using search_info\n  // uninitialised.\n  memset(&search_info, 0, 1);  // -V512\n\n  if (*curbuf->b_p_tfu != NUL && use_tfu && !tfu_in_use) {\n    tfu_in_use = true;\n    retval = find_tagfunc_tags(pat, &ga_match[0], &match_count,\n                               flags, buf_ffname);\n    tfu_in_use = false;\n    if (retval != NOTDONE) {\n      goto findtag_end;\n    }\n  }\n\n  /*\n   * When finding a specified number of matches, first try with matching\n   * case, so binary search can be used, and try ignore-case matches in a\n   * second loop.\n   * When finding all matches, 'tagbsearch' is off, or there is no fixed\n   * string to look for, ignore case right away to avoid going though the\n   * tags files twice.\n   * When the tag file is case-fold sorted, it is either one or the other.\n   * Only ignore case when TAG_NOIC not used or 'ignorecase' set.\n   */\n  // Set a flag if the file extension is .txt\n  if ((flags & TAG_KEEP_LANG)\n      && help_lang_find == NULL\n      && curbuf->b_fname != NULL\n      && (i = (int)STRLEN(curbuf->b_fname)) > 4\n      && STRICMP(curbuf->b_fname + i - 4, \".txt\") == 0) {\n    is_txt = true;\n  }\n  orgpat.regmatch.rm_ic = ((p_ic || !noic)\n                           && (findall || orgpat.headlen == 0 || !p_tbs));\n  for (round = 1; round <= 2; ++round) {\n    linear = (orgpat.headlen == 0 || !p_tbs || round == 2);\n\n    // Try tag file names from tags option one by one.\n    for (first_file = true;\n         use_cscope || get_tagfname(&tn, first_file, tag_fname) == OK;\n         first_file = false) {\n      // A file that doesn't exist is silently ignored.  Only when not a\n      // single file is found, an error message is given (further on).\n      if (use_cscope) {\n        fp = NULL;  // avoid GCC warning\n      } else {\n        if (curbuf->b_help) {\n          // Keep en if the file extension is .txt\n          if (is_txt) {\n            STRCPY(help_lang, \"en\");\n          } else {\n            // Prefer help tags according to 'helplang'.  Put the\n            // two-letter language name in help_lang[].\n            i = (int)STRLEN(tag_fname);\n            if (i > 3 && tag_fname[i - 3] == '-') {\n              STRCPY(help_lang, tag_fname + i - 2);\n            } else {\n              STRCPY(help_lang, \"en\");\n            }\n          }\n\n          /* When searching for a specific language skip tags files\n           * for other languages. */\n          if (help_lang_find != NULL\n              && STRICMP(help_lang, help_lang_find) != 0)\n            continue;\n\n          /* For CTRL-] in a help file prefer a match with the same\n           * language. */\n          if ((flags & TAG_KEEP_LANG)\n              && help_lang_find == NULL\n              && curbuf->b_fname != NULL\n              && (i = (int)STRLEN(curbuf->b_fname)) > 4\n              && curbuf->b_fname[i - 1] == 'x'\n              && curbuf->b_fname[i - 4] == '.'\n              && STRNICMP(curbuf->b_fname + i - 3, help_lang, 2) == 0)\n            help_pri = 0;\n          else {\n            help_pri = 1;\n            for (s = p_hlg; *s != NUL; ++s) {\n              if (STRNICMP(s, help_lang, 2) == 0)\n                break;\n              ++help_pri;\n              if ((s = vim_strchr(s, ',')) == NULL)\n                break;\n            }\n            if (s == NULL || *s == NUL) {\n              /* Language not in 'helplang': use last, prefer English,\n               * unless found already. */\n              ++help_pri;\n              if (STRICMP(help_lang, \"en\") != 0)\n                ++help_pri;\n            }\n          }\n        }\n\n        if ((fp = os_fopen((char *)tag_fname, \"r\")) == NULL) {\n          continue;\n        }\n\n        if (p_verbose >= 5) {\n          verbose_enter();\n          smsg(_(\"Searching tags file %s\"), tag_fname);\n          verbose_leave();\n        }\n      }\n      did_open = true;      // remember that we found at least one file\n\n      state = TS_START;     /* we're at the start of the file */\n\n      /*\n       * Read and parse the lines in the file one by one\n       */\n      for (;; ) {\n        // check for CTRL-C typed, more often when jumping around\n        if (state == TS_BINARY || state == TS_SKIP_BACK) {\n          line_breakcheck();\n        } else {\n          fast_breakcheck();\n        }\n        if ((flags & TAG_INS_COMP))     /* Double brackets for gcc */\n          ins_compl_check_keys(30, false);\n        if (got_int || compl_interrupted) {\n          stop_searching = true;\n          break;\n        }\n        /* When mincount is TAG_MANY, stop when enough matches have been\n         * found (for completion). */\n        if (mincount == TAG_MANY && match_count >= TAG_MANY) {\n          stop_searching = true;\n          retval = OK;\n          break;\n        }\n        if (get_it_again)\n          goto line_read_in;\n        /*\n         * For binary search: compute the next offset to use.\n         */\n        if (state == TS_BINARY) {\n          offset = search_info.low_offset + ((search_info.high_offset\n                                              - search_info.low_offset) / 2);\n          if (offset == search_info.curr_offset)\n            break;              /* End the binary search without a match. */\n          else\n            search_info.curr_offset = offset;\n        } else if (state == TS_SKIP_BACK) {\n          // Skipping back (after a match during binary search).\n          search_info.curr_offset -= lbuf_size * 2;\n          if (search_info.curr_offset < 0) {\n            search_info.curr_offset = 0;\n            rewind(fp);\n            state = TS_STEP_FORWARD;\n          }\n        }\n\n        /*\n         * When jumping around in the file, first read a line to find the\n         * start of the next line.\n         */\n        if (state == TS_BINARY || state == TS_SKIP_BACK) {\n          /* Adjust the search file offset to the correct position */\n          search_info.curr_offset_used = search_info.curr_offset;\n          vim_fseek(fp, search_info.curr_offset, SEEK_SET);\n          eof = vim_fgets(lbuf, lbuf_size, fp);\n          if (!eof && search_info.curr_offset != 0) {\n            /* The explicit cast is to work around a bug in gcc 3.4.2\n             * (repeated below). */\n            search_info.curr_offset = vim_ftell(fp);\n            if (search_info.curr_offset == search_info.high_offset) {\n              // oops, gone a bit too far; try from low offset\n              vim_fseek(fp, search_info.low_offset, SEEK_SET);\n              search_info.curr_offset = search_info.low_offset;\n            }\n            eof = vim_fgets(lbuf, lbuf_size, fp);\n          }\n          /* skip empty and blank lines */\n          while (!eof && vim_isblankline(lbuf)) {\n            search_info.curr_offset = vim_ftell(fp);\n            eof = vim_fgets(lbuf, lbuf_size, fp);\n          }\n          if (eof) {\n            /* Hit end of file.  Skip backwards. */\n            state = TS_SKIP_BACK;\n            search_info.match_offset = vim_ftell(fp);\n            search_info.curr_offset = search_info.curr_offset_used;\n            continue;\n          }\n        }\n        /*\n         * Not jumping around in the file: Read the next line.\n         */\n        else {\n          /* skip empty and blank lines */\n          do {\n            eof = use_cscope\n              ? cs_fgets(lbuf, lbuf_size)\n              : vim_fgets(lbuf, lbuf_size, fp);\n          } while (!eof && vim_isblankline(lbuf));\n\n          if (eof) {\n            break;                                  /* end of file */\n          }\n        }\nline_read_in:\n\n        if (vimconv.vc_type != CONV_NONE) {\n          char_u  *conv_line;\n          int len;\n\n          /* Convert every line.  Converting the pattern from 'enc' to\n           * the tags file encoding doesn't work, because characters are\n           * not recognized. */\n          conv_line = string_convert(&vimconv, lbuf, NULL);\n          if (conv_line != NULL) {\n            /* Copy or swap lbuf and conv_line. */\n            len = (int)STRLEN(conv_line) + 1;\n            if (len > lbuf_size) {\n              xfree(lbuf);\n              lbuf = conv_line;\n              lbuf_size = len;\n            } else {\n              STRCPY(lbuf, conv_line);\n              xfree(conv_line);\n            }\n          }\n        }\n\n\n\n        /*\n         * When still at the start of the file, check for Emacs tags file\n         * format, and for \"not sorted\" flag.\n         */\n        if (state == TS_START) {\n          /* The header ends when the line sorts below \"!_TAG_\".  When\n           * case is folded lower case letters sort before \"_\". */\n          if (STRNCMP(lbuf, \"!_TAG_\", 6) <= 0\n              || (lbuf[0] == '!' && ASCII_ISLOWER(lbuf[1]))) {\n            if (STRNCMP(lbuf, \"!_TAG_\", 6) != 0)\n              /* Non-header item before the header, e.g. \"!\" itself.\n               */\n              goto parse_line;\n\n            /*\n             * Read header line.\n             */\n            if (STRNCMP(lbuf, \"!_TAG_FILE_SORTED\\t\", 18) == 0)\n              tag_file_sorted = lbuf[18];\n            if (STRNCMP(lbuf, \"!_TAG_FILE_ENCODING\\t\", 20) == 0) {\n              /* Prepare to convert every line from the specified\n               * encoding to 'encoding'. */\n              for (p = lbuf + 20; *p > ' ' && *p < 127; ++p)\n                ;\n              *p = NUL;\n              convert_setup(&vimconv, lbuf + 20, p_enc);\n            }\n\n            /* Read the next line.  Unrecognized flags are ignored. */\n            continue;\n          }\n\n          /* Headers ends. */\n\n          /*\n           * When there is no tag head, or ignoring case, need to do a\n           * linear search.\n           * When no \"!_TAG_\" is found, default to binary search.  If\n           * the tag file isn't sorted, the second loop will find it.\n           * When \"!_TAG_FILE_SORTED\" found: start binary search if\n           * flag set.\n           * For cscope, it's always linear.\n           */\n          if (linear || use_cscope)\n            state = TS_LINEAR;\n          else if (tag_file_sorted == NUL)\n            state = TS_BINARY;\n          else if (tag_file_sorted == '1')\n            state = TS_BINARY;\n          else if (tag_file_sorted == '2') {\n            state = TS_BINARY;\n            sortic = true;\n            orgpat.regmatch.rm_ic = (p_ic || !noic);\n          } else\n            state = TS_LINEAR;\n\n          if (state == TS_BINARY && orgpat.regmatch.rm_ic && !sortic) {\n            /* Binary search won't work for ignoring case, use linear\n             * search. */\n            linear = TRUE;\n            state = TS_LINEAR;\n          }\n\n          // When starting a binary search, get the size of the file and\n          // compute the first offset.\n          if (state == TS_BINARY) {\n            if (vim_fseek(fp, 0, SEEK_END) != 0) {\n              // can't seek, don't use binary search\n              state = TS_LINEAR;\n            } else {\n              // Get the tag file size.\n              // Don't use lseek(), it doesn't work\n              // properly on MacOS Catalina.\n              const off_T filesize = vim_ftell(fp);\n              vim_fseek(fp, 0, SEEK_SET);\n\n              // Calculate the first read offset in the file.  Start\n              // the search in the middle of the file.\n              search_info.low_offset = 0;\n              search_info.low_char = 0;\n              search_info.high_offset = filesize;\n              search_info.curr_offset = 0;\n              search_info.high_char = 0xff;\n            }\n            continue;\n          }\n        }\n\nparse_line:\n        // When the line is too long the NUL will not be in the\n        // last-but-one byte (see vim_fgets()).\n        // Has been reported for Mozilla JS with extremely long names.\n        // In that case we need to increase lbuf_size.\n        if (lbuf[lbuf_size - 2] != NUL && !use_cscope) {\n          lbuf_size *= 2;\n          xfree(lbuf);\n          lbuf = xmalloc(lbuf_size);\n          // this will try the same thing again, make sure the offset is\n          // different\n          search_info.curr_offset = 0;\n          continue;\n        }\n\n        // Figure out where the different strings are in this line.\n        // For \"normal\" tags: Do a quick check if the tag matches.\n        // This speeds up tag searching a lot!\n        if (orgpat.headlen) {\n          tagp.tagname = lbuf;\n          tagp.tagname_end = vim_strchr(lbuf, TAB);\n          if (tagp.tagname_end == NULL) {\n            // Corrupted tag line.\n            line_error = true;\n            break;\n          }\n\n          /*\n           * Skip this line if the length of the tag is different and\n           * there is no regexp, or the tag is too short.\n           */\n          cmplen = (int)(tagp.tagname_end - tagp.tagname);\n          if (p_tl != 0 && cmplen > p_tl)           /* adjust for 'taglength' */\n            cmplen = p_tl;\n          if (has_re && orgpat.headlen < cmplen)\n            cmplen = orgpat.headlen;\n          else if (state == TS_LINEAR && orgpat.headlen != cmplen)\n            continue;\n\n          if (state == TS_BINARY) {\n            /*\n             * Simplistic check for unsorted tags file.\n             */\n            i = (int)tagp.tagname[0];\n            if (sortic)\n              i = TOUPPER_ASC(tagp.tagname[0]);\n            if (i < search_info.low_char || i > search_info.high_char) {\n              sort_error = true;\n            }\n\n            /*\n             * Compare the current tag with the searched tag.\n             */\n            if (sortic)\n              tagcmp = tag_strnicmp(tagp.tagname, orgpat.head,\n                  (size_t)cmplen);\n            else\n              tagcmp = STRNCMP(tagp.tagname, orgpat.head, cmplen);\n\n            /*\n             * A match with a shorter tag means to search forward.\n             * A match with a longer tag means to search backward.\n             */\n            if (tagcmp == 0) {\n              if (cmplen < orgpat.headlen)\n                tagcmp = -1;\n              else if (cmplen > orgpat.headlen)\n                tagcmp = 1;\n            }\n\n            if (tagcmp == 0) {\n              /* We've located the tag, now skip back and search\n               * forward until the first matching tag is found.\n               */\n              state = TS_SKIP_BACK;\n              search_info.match_offset = search_info.curr_offset;\n              continue;\n            }\n            if (tagcmp < 0) {\n              search_info.curr_offset = vim_ftell(fp);\n              if (search_info.curr_offset < search_info.high_offset) {\n                search_info.low_offset = search_info.curr_offset;\n                if (sortic)\n                  search_info.low_char =\n                    TOUPPER_ASC(tagp.tagname[0]);\n                else\n                  search_info.low_char = tagp.tagname[0];\n                continue;\n              }\n            }\n            if (tagcmp > 0\n                && search_info.curr_offset != search_info.high_offset) {\n              search_info.high_offset = search_info.curr_offset;\n              if (sortic)\n                search_info.high_char =\n                  TOUPPER_ASC(tagp.tagname[0]);\n              else\n                search_info.high_char = tagp.tagname[0];\n              continue;\n            }\n\n            /* No match yet and are at the end of the binary search. */\n            break;\n          } else if (state == TS_SKIP_BACK)   {\n            assert(cmplen >= 0);\n            if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)\n              state = TS_STEP_FORWARD;\n            else\n              /* Have to skip back more.  Restore the curr_offset\n               * used, otherwise we get stuck at a long line. */\n              search_info.curr_offset = search_info.curr_offset_used;\n            continue;\n          } else if (state == TS_STEP_FORWARD)   {\n            assert(cmplen >= 0);\n            if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0) {\n              if ((off_T)vim_ftell(fp) > search_info.match_offset) {\n                break;                  // past last match\n              } else {\n                continue;               // before first match\n              }\n            }\n          } else\n          /* skip this match if it can't match */\n          assert(cmplen >= 0);\n          if (mb_strnicmp(tagp.tagname, orgpat.head, (size_t)cmplen) != 0)\n            continue;\n\n          // Can be a matching tag, isolate the file name and command.\n          tagp.fname = tagp.tagname_end + 1;\n          tagp.fname_end = vim_strchr(tagp.fname, TAB);\n          tagp.command = tagp.fname_end + 1;\n          if (tagp.fname_end == NULL)\n            i = FAIL;\n          else\n            i = OK;\n        } else\n          i = parse_tag_line(lbuf,\n              &tagp);\n        if (i == FAIL) {\n          line_error = true;\n          break;\n        }\n\n        /*\n         * First try matching with the pattern literally (also when it is\n         * a regexp).\n         */\n        cmplen = (int)(tagp.tagname_end - tagp.tagname);\n        if (p_tl != 0 && cmplen > p_tl)             /* adjust for 'taglength' */\n          cmplen = p_tl;\n        /* if tag length does not match, don't try comparing */\n        if (orgpat.len != cmplen)\n          match = FALSE;\n        else {\n          if (orgpat.regmatch.rm_ic) {\n            assert(cmplen >= 0);\n            match = mb_strnicmp(tagp.tagname, orgpat.pat, (size_t)cmplen) == 0;\n            if (match)\n              match_no_ic = (STRNCMP(tagp.tagname, orgpat.pat,\n                                 cmplen) == 0);\n          } else\n            match = (STRNCMP(tagp.tagname, orgpat.pat, cmplen) == 0);\n        }\n\n        /*\n         * Has a regexp: Also find tags matching regexp.\n         */\n        match_re = FALSE;\n        if (!match && orgpat.regmatch.regprog != NULL) {\n          int cc;\n\n          cc = *tagp.tagname_end;\n          *tagp.tagname_end = NUL;\n          match = vim_regexec(&orgpat.regmatch, tagp.tagname, (colnr_T)0);\n          if (match) {\n            matchoff = (int)(orgpat.regmatch.startp[0] - tagp.tagname);\n            if (orgpat.regmatch.rm_ic) {\n              orgpat.regmatch.rm_ic = FALSE;\n              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,\n                  (colnr_T)0);\n              orgpat.regmatch.rm_ic = TRUE;\n            }\n          }\n          *tagp.tagname_end = cc;\n          match_re = TRUE;\n        }\n\n        // If a match is found, add it to ht_match[] and ga_match[].\n        if (match) {\n          int len = 0;\n\n          if (use_cscope) {\n            /* Don't change the ordering, always use the same table. */\n            mtt = MT_GL_OTH;\n          } else {\n            // Decide in which array to store this match.\n            is_current = test_for_current(tagp.fname, tagp.fname_end, tag_fname,\n                                          buf_ffname);\n            is_static = test_for_static(&tagp);\n\n            // Decide in which of the sixteen tables to store this match.\n            if (is_static) {\n              if (is_current)\n                mtt = MT_ST_CUR;\n              else\n                mtt = MT_ST_OTH;\n            } else {\n              if (is_current)\n                mtt = MT_GL_CUR;\n              else\n                mtt = MT_GL_OTH;\n            }\n            if (orgpat.regmatch.rm_ic && !match_no_ic)\n              mtt += MT_IC_OFF;\n            if (match_re)\n              mtt += MT_RE_OFF;\n          }\n\n          // Add the found match in ht_match[mtt] and ga_match[mtt].\n          // Store the info we need later, which depends on the kind of\n          // tags we are dealing with.\n          if (help_only) {\n# define ML_EXTRA 3\n            // Append the help-heuristic number after the tagname, for\n            // sorting it later.  The heuristic is ignored for\n            // detecting duplicates.\n            // The format is {tagname}@{lang}NUL{heuristic}NUL\n            *tagp.tagname_end = NUL;\n            len = (int)(tagp.tagname_end - tagp.tagname);\n            mfp = xmalloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);\n\n            p = mfp;\n            STRCPY(p, tagp.tagname);\n            p[len] = '@';\n            STRCPY(p + len + 1, help_lang);\n            snprintf((char *)p + len + 1 + ML_EXTRA, 10, \"%06d\",\n                     help_heuristic(tagp.tagname,\n                                    match_re ? matchoff : 0, !match_no_ic)\n                     + help_pri);\n\n            *tagp.tagname_end = TAB;\n          } else if (name_only)   {\n            if (get_it_again) {\n              char_u *temp_end = tagp.command;\n\n              if (*temp_end == '/') {\n                while (*temp_end && *temp_end != '\\r'\n                       && *temp_end != '\\n'\n                       && *temp_end != '$') {\n                  temp_end++;\n                }\n              }\n\n              if (tagp.command + 2 < temp_end) {\n                len = (int)(temp_end - tagp.command - 2);\n                mfp = xmalloc(len + 2);\n                STRLCPY(mfp, tagp.command + 2, len + 1);\n              } else {\n                mfp = NULL;\n              }\n              get_it_again = false;\n            } else {\n              len = (int)(tagp.tagname_end - tagp.tagname);\n              mfp = xmalloc(sizeof(char_u) + len + 1);\n              STRLCPY(mfp, tagp.tagname, len + 1);\n\n              // if wanted, re-read line to get long form too\n              if (State & INSERT) {\n                get_it_again = p_sft;\n              }\n            }\n          } else {\n            size_t tag_fname_len = STRLEN(tag_fname);\n            // Save the tag in a buffer.\n            // Use 0x02 to separate fields (Can't use NUL, because the\n            // hash key is terminated by NUL).\n            // Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>\n            // other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>\n            // without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>\n            // Here <mtt> is the \"mtt\" value plus 1 to avoid NUL.\n            len = (int)tag_fname_len + (int)STRLEN(lbuf) + 3;\n            mfp = xmalloc(sizeof(char_u) + len + 1);\n            p = mfp;\n            p[0] = mtt + 1;\n            STRCPY(p + 1, tag_fname);\n#ifdef BACKSLASH_IN_FILENAME\n            // Ignore differences in slashes, avoid adding\n            // both path/file and path\\file.\n            slash_adjust(p + 1);\n#endif\n            p[tag_fname_len + 1] = TAG_SEP;\n            s = p + 1 + tag_fname_len + 1;\n            STRCPY(s, lbuf);\n          }\n\n          if (mfp != NULL) {\n            hashitem_T *hi;\n\n            // Don't add identical matches.\n            // Add all cscope tags, because they are all listed.\n            // \"mfp\" is used as a hash key, there is a NUL byte to end\n            // the part that matters for comparing, more bytes may\n            // follow after it.  E.g. help tags store the priority\n            // after the NUL.\n            if (use_cscope) {\n              hash++;\n            } else {\n              hash = hash_hash(mfp);\n            }\n            hi = hash_lookup(&ht_match[mtt], (const char *)mfp,\n                             STRLEN(mfp), hash);\n            if (HASHITEM_EMPTY(hi)) {\n              hash_add_item(&ht_match[mtt], hi, mfp, hash);\n              ga_grow(&ga_match[mtt], 1);\n              ((char_u **)(ga_match[mtt].ga_data))\n                [ga_match[mtt].ga_len++] = mfp;\n              match_count++;\n            } else {\n              // duplicate tag, drop it\n              xfree(mfp);\n            }\n          }\n        }\n        if (use_cscope && eof)\n          break;\n      }   /* forever */\n\n      if (line_error) {\n        EMSG2(_(\"E431: Format error in tags file \\\"%s\\\"\"), tag_fname);\n        if (!use_cscope) {\n          EMSGN(_(\"Before byte %\" PRId64), vim_ftell(fp));\n        }\n        stop_searching = true;\n        line_error = false;\n      }\n\n      if (!use_cscope)\n        fclose(fp);\n      if (vimconv.vc_type != CONV_NONE)\n        convert_setup(&vimconv, NULL, NULL);\n\n      tag_file_sorted = NUL;\n      if (sort_error) {\n        EMSG2(_(\"E432: Tags file not sorted: %s\"), tag_fname);\n        sort_error = false;\n      }\n\n      /*\n       * Stop searching if sufficient tags have been found.\n       */\n      if (match_count >= mincount) {\n        retval = OK;\n        stop_searching = true;\n      }\n\n      if (stop_searching || use_cscope)\n        break;\n\n    }   /* end of for-each-file loop */\n\n    if (!use_cscope)\n      tagname_free(&tn);\n\n    /* stop searching when already did a linear search, or when TAG_NOIC\n     * used, and 'ignorecase' not set or already did case-ignore search */\n    if (stop_searching || linear || (!p_ic && noic) || orgpat.regmatch.rm_ic)\n      break;\n    if (use_cscope)\n      break;\n    orgpat.regmatch.rm_ic = TRUE;       /* try another time while ignoring case */\n  }\n\n  if (!stop_searching) {\n    if (!did_open && verbose)           /* never opened any tags file */\n      EMSG(_(\"E433: No tags file\"));\n    retval = OK;                /* It's OK even when no tag found */\n  }\n\nfindtag_end:\n  xfree(lbuf);\n  vim_regfree(orgpat.regmatch.regprog);\n  xfree(tag_fname);\n\n  /*\n   * Move the matches from the ga_match[] arrays into one list of\n   * matches.  When retval == FAIL, free the matches.\n   */\n  if (retval == FAIL)\n    match_count = 0;\n\n  if (match_count > 0)\n    matches = xmalloc(match_count * sizeof(char_u *));\n  else\n    matches = NULL;\n  match_count = 0;\n  for (mtt = 0; mtt < MT_COUNT; mtt++) {\n    for (i = 0; i < ga_match[mtt].ga_len; i++) {\n      mfp = ((char_u **)(ga_match[mtt].ga_data))[i];\n      if (matches == NULL) {\n        xfree(mfp);\n      } else {\n        if (!name_only) {\n          // Change mtt back to zero-based.\n          *mfp = *mfp - 1;\n\n          // change the TAG_SEP back to NUL\n          for (p = mfp + 1; *p != NUL; p++) {\n            if (*p == TAG_SEP) {\n              *p = NUL;\n            }\n          }\n        }\n        matches[match_count++] = (char_u *)mfp;\n      }\n    }\n\n    ga_clear(&ga_match[mtt]);\n    hash_clear(&ht_match[mtt]);\n  }\n\n  *matchesp = matches;\n  *num_matches = match_count;\n\n  curbuf->b_help = help_save;\n  xfree(saved_pat);\n\n  p_ic = save_p_ic;\n\n  return retval;\n}\n\nstatic garray_T tag_fnames = GA_EMPTY_INIT_VALUE;\n\n/*\n * Callback function for finding all \"tags\" and \"tags-??\" files in\n * 'runtimepath' doc directories.\n */\nstatic void found_tagfile_cb(char_u *fname, void *cookie)\n{\n  char_u *const tag_fname = vim_strsave(fname);\n\n#ifdef BACKSLASH_IN_FILENAME\n    slash_adjust(tag_fname);\n#endif\n  simplify_filename(tag_fname);\n  GA_APPEND(char_u *, &tag_fnames, tag_fname);\n}\n\n#if defined(EXITFREE)\nvoid free_tag_stuff(void)\n{\n  ga_clear_strings(&tag_fnames);\n  do_tag(NULL, DT_FREE, 0, 0, 0);\n  tag_freematch();\n\n  tagstack_clear_entry(&ptag_entry);\n}\n\n#endif\n\n/*\n * Get the next name of a tag file from the tag file list.\n * For help files, use \"tags\" file only.\n *\n * Return FAIL if no more tag file names, OK otherwise.\n */\nint\nget_tagfname(\n    tagname_T *tnp,       // holds status info\n    int first,              // TRUE when first file name is wanted\n    char_u *buf       // pointer to buffer of MAXPATHL chars\n)\n{\n  char_u              *fname = NULL;\n  char_u              *r_ptr;\n\n  if (first)\n    memset(tnp, 0, sizeof(tagname_T));\n\n  if (curbuf->b_help) {\n    /*\n     * For help files it's done in a completely different way:\n     * Find \"doc/tags\" and \"doc/tags-??\" in all directories in\n     * 'runtimepath'.\n     */\n    if (first) {\n      ga_clear_strings(&tag_fnames);\n      ga_init(&tag_fnames, (int)sizeof(char_u *), 10);\n      do_in_runtimepath((char_u *)\"doc/tags doc/tags-??\", DIP_ALL,\n                        found_tagfile_cb, NULL);\n    }\n\n    if (tnp->tn_hf_idx >= tag_fnames.ga_len) {\n      /* Not found in 'runtimepath', use 'helpfile', if it exists and\n       * wasn't used yet, replacing \"help.txt\" with \"tags\". */\n      if (tnp->tn_hf_idx > tag_fnames.ga_len || *p_hf == NUL)\n        return FAIL;\n      ++tnp->tn_hf_idx;\n      STRCPY(buf, p_hf);\n      STRCPY(path_tail(buf), \"tags\");\n#ifdef BACKSLASH_IN_FILENAME\n      slash_adjust(buf);\n#endif\n      simplify_filename(buf);\n\n      for (int i = 0; i < tag_fnames.ga_len; i++) {\n        if (STRCMP(buf, ((char_u **)(tag_fnames.ga_data))[i]) == 0) {\n          return FAIL;  // avoid duplicate file names\n        }\n      }\n    } else {\n      STRLCPY(buf, ((char_u **)(tag_fnames.ga_data))[tnp->tn_hf_idx++],\n              MAXPATHL);\n    }\n    return OK;\n  }\n\n  if (first) {\n    /* Init.  We make a copy of 'tags', because autocommands may change\n     * the value without notifying us. */\n    tnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)\n        ? curbuf->b_p_tags : p_tags);\n    tnp->tn_np = tnp->tn_tags;\n  }\n\n  /*\n   * Loop until we have found a file name that can be used.\n   * There are two states:\n   * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.\n   * tnp->tn_did_filefind_init == TRUE: find next file in this part.\n   */\n  for (;; ) {\n    if (tnp->tn_did_filefind_init) {\n      fname = vim_findfile(tnp->tn_search_ctx);\n      if (fname != NULL)\n        break;\n\n      tnp->tn_did_filefind_init = FALSE;\n    } else {\n      char_u  *filename = NULL;\n\n      /* Stop when used all parts of 'tags'. */\n      if (*tnp->tn_np == NUL) {\n        vim_findfile_cleanup(tnp->tn_search_ctx);\n        tnp->tn_search_ctx = NULL;\n        return FAIL;\n      }\n\n      /*\n       * Copy next file name into buf.\n       */\n      buf[0] = NUL;\n      (void)copy_option_part(&tnp->tn_np, buf, MAXPATHL - 1, \" ,\");\n\n      r_ptr = vim_findfile_stopdir(buf);\n      /* move the filename one char forward and truncate the\n       * filepath with a NUL */\n      filename = path_tail(buf);\n      STRMOVE(filename + 1, filename);\n      *filename++ = NUL;\n\n      tnp->tn_search_ctx = vim_findfile_init(buf, filename,\n          r_ptr, 100,\n          FALSE,                   /* don't free visited list */\n          FINDFILE_FILE,           /* we search for a file */\n          tnp->tn_search_ctx, TRUE, curbuf->b_ffname);\n      if (tnp->tn_search_ctx != NULL)\n        tnp->tn_did_filefind_init = TRUE;\n    }\n  }\n\n  STRCPY(buf, fname);\n  xfree(fname);\n  return OK;\n}\n\n/*\n * Free the contents of a tagname_T that was filled by get_tagfname().\n */\nvoid tagname_free(tagname_T *tnp)\n{\n  xfree(tnp->tn_tags);\n  vim_findfile_cleanup(tnp->tn_search_ctx);\n  tnp->tn_search_ctx = NULL;\n  ga_clear_strings(&tag_fnames);\n}\n\n/*\n * Parse one line from the tags file. Find start/end of tag name, start/end of\n * file name and start of search pattern.\n *\n * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.\n *\n * Return FAIL if there is a format error in this line, OK otherwise.\n */\nstatic int\nparse_tag_line(\n    char_u *lbuf,              // line to be parsed\n    tagptrs_T *tagp\n)\n{\n  char_u      *p;\n\n  /* Isolate the tagname, from lbuf up to the first white */\n  tagp->tagname = lbuf;\n  p = vim_strchr(lbuf, TAB);\n  if (p == NULL)\n    return FAIL;\n  tagp->tagname_end = p;\n\n  /* Isolate file name, from first to second white space */\n  if (*p != NUL)\n    ++p;\n  tagp->fname = p;\n  p = vim_strchr(p, TAB);\n  if (p == NULL)\n    return FAIL;\n  tagp->fname_end = p;\n\n  /* find start of search command, after second white space */\n  if (*p != NUL)\n    ++p;\n  if (*p == NUL)\n    return FAIL;\n  tagp->command = p;\n\n  return OK;\n}\n\n/*\n * Check if tagname is a static tag\n *\n * Static tags produced by the older ctags program have the format:\n *\t'file:tag  file  /pattern'.\n * This is only recognized when both occurrence of 'file' are the same, to\n * avoid recognizing \"string::string\" or \":exit\".\n *\n * Static tags produced by the new ctags program have the format:\n *\t'tag  file  /pattern/;\"<Tab>file:'\t    \"\n *\n * Return TRUE if it is a static tag and adjust *tagname to the real tag.\n * Return FALSE if it is not a static tag.\n */\nstatic bool test_for_static(tagptrs_T *tagp)\n{\n  char_u *p;\n\n  // Check for new style static tag \":...<Tab>file:[<Tab>...]\"\n  p = tagp->command;\n  while ((p = vim_strchr(p, '\\t')) != NULL) {\n    ++p;\n    if (STRNCMP(p, \"file:\", 5) == 0)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n\n// Returns the length of a matching tag line.\nstatic size_t matching_line_len(const char_u *const lbuf)\n{\n  const char_u *p = lbuf + 1;\n\n  // does the same thing as parse_match()\n  p += STRLEN(p) + 1;\n  return (p - lbuf) + STRLEN(p);\n}\n\n/*\n * Parse a line from a matching tag.  Does not change the line itself.\n *\n * The line that we get looks like this:\n * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>\n * other tag: <mtt><tag_fname><NUL><NUL><lbuf>\n * without Emacs tags: <mtt><tag_fname><NUL><lbuf>\n *\n * Return OK or FAIL.\n */\nstatic int\nparse_match(\n    char_u *lbuf,          // input: matching line\n    tagptrs_T *tagp          // output: pointers into the line\n)\n{\n  int retval;\n  char_u      *p;\n  char_u      *pc, *pt;\n\n  tagp->tag_fname = lbuf + 1;\n  lbuf += STRLEN(tagp->tag_fname) + 2;\n\n  /* Find search pattern and the file name for non-etags. */\n  retval = parse_tag_line(lbuf,\n      tagp);\n\n  tagp->tagkind = NULL;\n  tagp->user_data = NULL;\n  tagp->tagline = 0;\n  tagp->command_end = NULL;\n\n  if (retval == OK) {\n    /* Try to find a kind field: \"kind:<kind>\" or just \"<kind>\"*/\n    p = tagp->command;\n    if (find_extra(&p) == OK) {\n      tagp->command_end = p;\n      if (p > tagp->command && p[-1] == '|') {\n        tagp->command_end = p - 1;  // drop trailing bar\n      }\n      p += 2;  // skip \";\\\"\"\n      if (*p++ == TAB) {\n        // Accept ASCII alphabetic kind characters and any multi-byte\n        // character.\n        while (ASCII_ISALPHA(*p) || utfc_ptr2len(p) > 1) {\n          if (STRNCMP(p, \"kind:\", 5) == 0) {\n            tagp->tagkind = p + 5;\n          } else if (STRNCMP(p, \"user_data:\", 10) == 0) {\n            tagp->user_data = p + 10;\n          } else if (STRNCMP(p, \"line:\", 5) == 0) {\n            tagp->tagline = atoi((char *)p + 5);\n          }\n          if (tagp->tagkind != NULL && tagp->user_data != NULL) {\n            break;\n          }\n\n          pc = vim_strchr(p, ':');\n          pt = vim_strchr(p, '\\t');\n          if (pc == NULL || (pt != NULL && pc > pt)) {\n            tagp->tagkind = p;\n          }\n          if (pt == NULL)\n            break;\n          p = pt;\n          MB_PTR_ADV(p);\n        }\n      }\n    }\n    if (tagp->tagkind != NULL) {\n      for (p = tagp->tagkind;\n           *p && *p != '\\t' && *p != '\\r' && *p != '\\n';\n           MB_PTR_ADV(p)) {\n      }\n      tagp->tagkind_end = p;\n    }\n    if (tagp->user_data != NULL) {\n      for (p = tagp->user_data;\n           *p && *p != '\\t' && *p != '\\r' && *p != '\\n';\n           MB_PTR_ADV(p)) {\n      }\n      tagp->user_data_end = p;\n    }\n  }\n  return retval;\n}\n\n/*\n * Find out the actual file name of a tag.  Concatenate the tags file name\n * with the matching tag file name.\n * Returns an allocated string.\n */\nstatic char_u *tag_full_fname(tagptrs_T *tagp)\n{\n  int c = *tagp->fname_end;\n  *tagp->fname_end = NUL;\n  char_u *fullname = expand_tag_fname(tagp->fname, tagp->tag_fname, false);\n  *tagp->fname_end = c;\n\n  return fullname;\n}\n\n/*\n * Jump to a tag that has been found in one of the tag files\n *\n * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.\n */\nstatic int jumpto_tag(\n    const char_u *lbuf_arg,   // line from the tags file for this tag\n    int forceit,              // :ta with !\n    int keep_help             // keep help flag (FALSE for cscope)\n)\n{\n  int save_magic;\n  bool save_p_ws;\n  int save_p_scs, save_p_ic;\n  linenr_T save_lnum;\n  char_u      *str;\n  char_u      *pbuf;                    /* search pattern buffer */\n  char_u      *pbuf_end;\n  char_u      *tofree_fname = NULL;\n  char_u      *fname;\n  tagptrs_T tagp;\n  int retval = FAIL;\n  int getfile_result = GETFILE_UNUSED;\n  int search_options;\n  win_T       *curwin_save = NULL;\n  char_u      *full_fname = NULL;\n  const bool old_KeyTyped = KeyTyped;       // getting the file may reset it\n  const int l_g_do_tagpreview = g_do_tagpreview;\n  const size_t len = matching_line_len(lbuf_arg) + 1;\n  char_u *lbuf = xmalloc(len);\n  memmove(lbuf, lbuf_arg, len);\n\n  pbuf = xmalloc(LSIZE);\n\n  /* parse the match line into the tagp structure */\n  if (parse_match(lbuf, &tagp) == FAIL) {\n    tagp.fname_end = NULL;\n    goto erret;\n  }\n\n  // truncate the file name, so it can be used as a string\n  *tagp.fname_end = NUL;\n  fname = tagp.fname;\n\n  /* copy the command to pbuf[], remove trailing CR/NL */\n  str = tagp.command;\n  for (pbuf_end = pbuf; *str && *str != '\\n' && *str != '\\r'; ) {\n    *pbuf_end++ = *str++;\n    if (pbuf_end - pbuf + 1 >= LSIZE) {\n      break;\n    }\n  }\n  *pbuf_end = NUL;\n\n  {\n    /*\n     * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here.\n     */\n    str = pbuf;\n    if (find_extra(&str) == OK) {\n      pbuf_end = str;\n      *pbuf_end = NUL;\n    }\n  }\n\n  /*\n   * Expand file name, when needed (for environment variables).\n   * If 'tagrelative' option set, may change file name.\n   */\n  fname = expand_tag_fname(fname, tagp.tag_fname, true);\n  tofree_fname = fname;         // free() it later\n\n  /*\n   * Check if the file with the tag exists before abandoning the current\n   * file.  Also accept a file name for which there is a matching BufReadCmd\n   * autocommand event (e.g., http://sys/file).\n   */\n  if (!os_path_exists(fname)\n      && !has_autocmd(EVENT_BUFREADCMD, fname, NULL)\n      ) {\n    retval = NOTAGFILE;\n    xfree(nofile_fname);\n    nofile_fname = vim_strsave(fname);\n    goto erret;\n  }\n\n  ++RedrawingDisabled;\n\n\n  if (l_g_do_tagpreview != 0) {\n    postponed_split = 0;        /* don't split again below */\n    curwin_save = curwin;       /* Save current window */\n\n    /*\n     * If we are reusing a window, we may change dir when\n     * entering it (autocommands) so turn the tag filename\n     * into a fullpath\n     */\n    if (!curwin->w_p_pvw) {\n      full_fname = (char_u *)FullName_save((char *)fname, FALSE);\n      fname = full_fname;\n\n      /*\n       * Make the preview window the current window.\n       * Open a preview window when needed.\n       */\n      prepare_tagpreview(true);\n    }\n  }\n\n  // If it was a CTRL-W CTRL-] command split window now.  For \":tab tag\"\n  // open a new tab page.\n  if (postponed_split && (swb_flags & (SWB_USEOPEN | SWB_USETAB))) {\n    buf_T *const existing_buf = buflist_findname_exp(fname);\n\n    if (existing_buf != NULL) {\n      const win_T *wp = NULL;\n\n      if (swb_flags & SWB_USEOPEN) {\n        wp = buf_jump_open_win(existing_buf);\n      }\n\n      // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n      // page containing \"existing_buf\" if one exists\n      if (wp == NULL && (swb_flags & SWB_USETAB)) {\n        wp = buf_jump_open_tab(existing_buf);\n      }\n\n      // We've switched to the buffer, the usual loading of the file must\n      // be skipped.\n      if (wp != NULL) {\n        getfile_result = GETFILE_SAME_FILE;\n      }\n    }\n  }\n  if (getfile_result == GETFILE_UNUSED\n      && (postponed_split || cmdmod.tab != 0)) {\n    if (win_split(postponed_split > 0 ? postponed_split : 0,\n                  postponed_split_flags) == FAIL) {\n      RedrawingDisabled--;\n      goto erret;\n    }\n    RESET_BINDING(curwin);\n  }\n\n  if (keep_help) {\n    /* A :ta from a help file will keep the b_help flag set.  For \":ptag\"\n     * we need to use the flag from the window where we came from. */\n    if (l_g_do_tagpreview != 0)\n      keep_help_flag = curwin_save->w_buffer->b_help;\n    else\n      keep_help_flag = curbuf->b_help;\n  }\n\n  if (getfile_result == GETFILE_UNUSED) {\n    // Careful: getfile() may trigger autocommands and call jumpto_tag()\n    // recursively.\n    getfile_result = getfile(0, fname, NULL, true, (linenr_T)0, forceit);\n  }\n  keep_help_flag = false;\n\n  if (GETFILE_SUCCESS(getfile_result)) {    // got to the right file\n    curwin->w_set_curswant = true;\n    postponed_split = 0;\n\n    save_magic = p_magic;\n    p_magic = false;            // always execute with 'nomagic'\n    // Save value of no_hlsearch, jumping to a tag is not a real search\n    const bool save_no_hlsearch = no_hlsearch;\n\n    /*\n     * If 'cpoptions' contains 't', store the search pattern for the \"n\"\n     * command.  If 'cpoptions' does not contain 't', the search pattern\n     * is not stored.\n     */\n    if (vim_strchr(p_cpo, CPO_TAGPAT) != NULL)\n      search_options = 0;\n    else\n      search_options = SEARCH_KEEP;\n\n    /*\n     * If the command is a search, try here.\n     *\n     * Reset 'smartcase' for the search, since the search pattern was not\n     * typed by the user.\n     * Only use do_search() when there is a full search command, without\n     * anything following.\n     */\n    str = pbuf;\n    if (pbuf[0] == '/' || pbuf[0] == '?')\n      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;\n    if (str > pbuf_end - 1) {   /* search command with nothing following */\n      save_p_ws = p_ws;\n      save_p_ic = p_ic;\n      save_p_scs = p_scs;\n      p_ws = true;              /* need 'wrapscan' for backward searches */\n      p_ic = FALSE;             /* don't ignore case now */\n      p_scs = FALSE;\n      save_lnum = curwin->w_cursor.lnum;\n      if (tagp.tagline > 0) {\n        // start search before line from \"line:\" field\n        curwin->w_cursor.lnum = tagp.tagline - 1;\n      } else {\n        // start search before first line\n        curwin->w_cursor.lnum = 0;\n      }\n      if (do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n                    search_options, NULL)) {\n        retval = OK;\n      } else {\n        int found = 1;\n        int cc;\n\n        /*\n         * try again, ignore case now\n         */\n        p_ic = true;\n        if (!do_search(NULL, pbuf[0], pbuf[0], pbuf + 1, (long)1,\n                       search_options, NULL)) {\n          // Failed to find pattern, take a guess: \"^func  (\"\n          found = 2;\n          (void)test_for_static(&tagp);\n          cc = *tagp.tagname_end;\n          *tagp.tagname_end = NUL;\n          snprintf((char *)pbuf, LSIZE, \"^%s\\\\s\\\\*(\", tagp.tagname);\n          if (!do_search(NULL, '/', '/', pbuf, (long)1, search_options, NULL)) {\n            // Guess again: \"^char * \\<func  (\"\n            snprintf((char *)pbuf, LSIZE, \"^\\\\[#a-zA-Z_]\\\\.\\\\*\\\\<%s\\\\s\\\\*(\",\n                     tagp.tagname);\n            if (!do_search(NULL, '/', '/', pbuf, (long)1,\n                           search_options, NULL)) {\n              found = 0;\n            }\n          }\n          *tagp.tagname_end = cc;\n        }\n        if (found == 0) {\n          EMSG(_(\"E434: Can't find tag pattern\"));\n          curwin->w_cursor.lnum = save_lnum;\n        } else {\n          /*\n           * Only give a message when really guessed, not when 'ic'\n           * is set and match found while ignoring case.\n           */\n          if (found == 2 || !save_p_ic) {\n            MSG(_(\"E435: Couldn't find tag, just guessing!\"));\n            if (!msg_scrolled && msg_silent == 0) {\n              ui_flush();\n              os_delay(1010L, true);\n            }\n          }\n          retval = OK;\n        }\n      }\n      p_ws = save_p_ws;\n      p_ic = save_p_ic;  // -V519\n      p_scs = save_p_scs;\n\n      /* A search command may have positioned the cursor beyond the end\n       * of the line.  May need to correct that here. */\n      check_cursor();\n    } else {\n      const int save_secure = secure;\n\n      // Setup the sandbox for executing the command from the tags file.\n      secure = 1;\n      sandbox++;\n      curwin->w_cursor.lnum = 1;  // start command in line 1\n      do_cmdline_cmd((char *)pbuf);\n      retval = OK;\n\n      // When the command has done something that is not allowed make sure\n      // the error message can be seen.\n      if (secure == 2) {\n        wait_return(true);\n      }\n      secure = save_secure;\n      sandbox--;\n    }\n\n    p_magic = save_magic;\n    // restore no_hlsearch when keeping the old search pattern\n    if (search_options) {\n      set_no_hlsearch(save_no_hlsearch);\n    }\n\n    // Return OK if jumped to another file (at least we found the file!).\n    if (getfile_result == GETFILE_OPEN_OTHER) {\n      retval = OK;\n    }\n\n    if (retval == OK) {\n      /*\n       * For a help buffer: Put the cursor line at the top of the window,\n       * the help subject will be below it.\n       */\n      if (curbuf->b_help)\n        set_topline(curwin, curwin->w_cursor.lnum);\n      if ((fdo_flags & FDO_TAG) && old_KeyTyped)\n        foldOpenCursor();\n    }\n\n    if (l_g_do_tagpreview != 0\n        && curwin != curwin_save && win_valid(curwin_save)) {\n      /* Return cursor to where we were */\n      validate_cursor();\n      redraw_later(curwin, VALID);\n      win_enter(curwin_save, true);\n    }\n\n    RedrawingDisabled--;\n  } else {\n    RedrawingDisabled--;\n    if (postponed_split) {              // close the window\n      win_close(curwin, false);\n      postponed_split = 0;\n    }\n  }\n\nerret:\n  g_do_tagpreview = 0;  // For next time\n  xfree(lbuf);\n  xfree(pbuf);\n  xfree(tofree_fname);\n  xfree(full_fname);\n\n  return retval;\n}\n\n// If \"expand\" is true, expand wildcards in fname.\n// If 'tagrelative' option set, change fname (name of file containing tag)\n// according to tag_fname (name of tag file containing fname).\n// Returns a pointer to allocated memory.\nstatic char_u *expand_tag_fname(char_u *fname, char_u *const tag_fname,\n                                const bool expand)\n{\n  char_u      *p;\n  char_u      *expanded_fname = NULL;\n  expand_T xpc;\n\n  /*\n   * Expand file name (for environment variables) when needed.\n   */\n  if (expand && path_has_wildcard(fname)) {\n    ExpandInit(&xpc);\n    xpc.xp_context = EXPAND_FILES;\n    expanded_fname = ExpandOne(&xpc, fname, NULL,\n        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n    if (expanded_fname != NULL)\n      fname = expanded_fname;\n  }\n\n  char_u *retval;\n  if ((p_tr || curbuf->b_help)\n      && !vim_isAbsName(fname)\n      && (p = path_tail(tag_fname)) != tag_fname) {\n    retval = xmalloc(MAXPATHL);\n    STRCPY(retval, tag_fname);\n    STRLCPY(retval + (p - tag_fname), fname,\n        MAXPATHL - (p - tag_fname));\n    /*\n     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\".\n     */\n    simplify_filename(retval);\n  } else\n    retval = vim_strsave(fname);\n\n  xfree(expanded_fname);\n\n  return retval;\n}\n\n/*\n * Check if we have a tag for the buffer with name \"buf_ffname\".\n * This is a bit slow, because of the full path compare in path_full_compare().\n * Return TRUE if tag for file \"fname\" if tag file \"tag_fname\" is for current\n * file.\n */\nstatic int test_for_current(char_u *fname, char_u *fname_end, char_u *tag_fname, char_u *buf_ffname)\n{\n  int c;\n  int retval = FALSE;\n  char_u  *fullname;\n\n  if (buf_ffname != NULL) {     /* if the buffer has a name */\n    {\n      c = *fname_end;\n      *fname_end = NUL;\n    }\n    fullname = expand_tag_fname(fname, tag_fname, true);\n    retval = (path_full_compare(fullname, buf_ffname, true, true)\n              & kEqualFiles);\n    xfree(fullname);\n    *fname_end = c;\n  }\n\n  return retval;\n}\n\n/*\n * Find the end of the tagaddress.\n * Return OK if \";\\\"\" is following, FAIL otherwise.\n */\nstatic int find_extra(char_u **pp)\n{\n  char_u *str = *pp;\n  char_u first_char = **pp;\n\n  // Repeat for addresses separated with ';'\n  for (;; ) {\n    if (ascii_isdigit(*str)) {\n      str = skipdigits(str + 1);\n    } else if (*str == '/' || *str == '?') {\n      str = skip_regexp(str + 1, *str, false, NULL);\n      if (*str != first_char) {\n        str = NULL;\n      } else {\n        str++;\n      }\n    } else {\n      // not a line number or search string, look for terminator.\n      str = (char_u *)strstr((char *)str, \"|;\\\"\");\n      if (str != NULL) {\n        str++;\n        break;\n      }\n    }\n    if (str == NULL || *str != ';'\n        || !(ascii_isdigit(str[1]) || str[1] == '/' || str[1] == '?')) {\n      break;\n    }\n    str++;  // skip ';'\n    first_char = *str;\n  }\n\n  if (str != NULL && STRNCMP(str, \";\\\"\", 2) == 0) {\n    *pp = str;\n    return OK;\n  }\n  return FAIL;\n}\n\n//\n// Free a single entry in a tag stack\n//\nstatic void tagstack_clear_entry(taggy_T *item)\n{\n  XFREE_CLEAR(item->tagname);\n  XFREE_CLEAR(item->user_data);\n}\n\nint \nexpand_tags (\n    int tagnames,                   /* expand tag names */\n    char_u *pat,\n    int *num_file,\n    char_u ***file\n)\n{\n  int i;\n  int extra_flag;\n  char_u *name_buf;\n  size_t name_buf_size = 100;\n  tagptrs_T t_p;\n  int ret;\n\n  name_buf = xmalloc(name_buf_size);\n\n  if (tagnames) {\n    extra_flag = TAG_NAMES;\n  } else {\n    extra_flag = 0;\n  }\n  if (pat[0] == '/') {\n    ret = find_tags(pat + 1, num_file, file,\n                    TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC,\n                    TAG_MANY, curbuf->b_ffname);\n  } else {\n    ret = find_tags(pat, num_file, file,\n                    TAG_REGEXP | extra_flag | TAG_VERBOSE | TAG_NO_TAGFUNC | TAG_NOIC,\n                    TAG_MANY, curbuf->b_ffname);\n  }\n  if (ret == OK && !tagnames) {\n    /* Reorganize the tags for display and matching as strings of:\n     * \"<tagname>\\0<kind>\\0<filename>\\0\"\n     */\n    for (i = 0; i < *num_file; i++) {\n      size_t len;\n\n      parse_match((*file)[i], &t_p);\n      len = t_p.tagname_end - t_p.tagname;\n      if (len > name_buf_size - 3) {\n        char_u *buf;\n\n        name_buf_size = len + 3;\n        buf = xrealloc(name_buf, name_buf_size);\n        name_buf = buf;\n      }\n\n      memmove(name_buf, t_p.tagname, len);\n      name_buf[len++] = 0;\n      name_buf[len++] = (t_p.tagkind != NULL && *t_p.tagkind)\n                                                   ? *t_p.tagkind : 'f';\n      name_buf[len++] = 0;\n      memmove((*file)[i] + len, t_p.fname, t_p.fname_end - t_p.fname);\n      (*file)[i][len + (t_p.fname_end - t_p.fname)] = 0;\n      memmove((*file)[i], name_buf, len);\n    }\n  }\n  xfree(name_buf);\n  return ret;\n}\n\n\n/*\n * Add a tag field to the dictionary \"dict\".\n * Return OK or FAIL.\n */\nstatic int\nadd_tag_field(\n    dict_T *dict,\n    const char *field_name,\n    const char_u *start,          // start of the value\n    const char_u *end             // after the value; can be NULL\n)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  int len = 0;\n  int retval;\n\n  // Check that the field name doesn't exist yet.\n  if (tv_dict_find(dict, field_name, -1) != NULL) {\n    if (p_verbose > 0) {\n      verbose_enter();\n      smsg(_(\"Duplicate field name: %s\"), field_name);\n      verbose_leave();\n    }\n    return FAIL;\n  }\n  char_u *buf = xmalloc(MAXPATHL);\n  if (start != NULL) {\n    if (end == NULL) {\n      end = start + STRLEN(start);\n      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n'))\n        --end;\n    }\n    len = (int)(end - start);\n    if (len > MAXPATHL - 1)\n      len = MAXPATHL - 1;\n    STRLCPY(buf, start, len + 1);\n  }\n  buf[len] = NUL;\n  retval = tv_dict_add_str(dict, field_name, STRLEN(field_name),\n                           (const char *)buf);\n  xfree(buf);\n  return retval;\n}\n\n/// Add the tags matching the specified pattern \"pat\" to the list \"list\"\n/// as a dictionary. Use \"buf_fname\" for priority, unless NULL.\nint get_tags(list_T *list, char_u *pat, char_u *buf_fname)\n{\n  int num_matches, i, ret;\n  char_u      **matches;\n  char_u      *full_fname;\n  dict_T      *dict;\n  tagptrs_T tp;\n  bool is_static;\n\n  ret = find_tags(pat, &num_matches, &matches,\n                  TAG_REGEXP | TAG_NOIC, MAXCOL, buf_fname);\n  if (ret == OK && num_matches > 0) {\n    for (i = 0; i < num_matches; ++i) {\n      int parse_result = parse_match(matches[i], &tp);\n\n      // Avoid an unused variable warning in release builds.\n      (void) parse_result;\n      assert(parse_result == OK);\n\n      is_static = test_for_static(&tp);\n\n      // Skip pseudo-tag lines.\n      if (STRNCMP(tp.tagname, \"!_TAG_\", 6) == 0) {\n        xfree(matches[i]);\n        continue;\n      }\n\n      dict = tv_dict_alloc();\n      tv_list_append_dict(list, dict);\n\n      full_fname = tag_full_fname(&tp);\n      if (add_tag_field(dict, \"name\", tp.tagname, tp.tagname_end) == FAIL\n          || add_tag_field(dict, \"filename\", full_fname, NULL) == FAIL\n          || add_tag_field(dict, \"cmd\", tp.command, tp.command_end) == FAIL\n          || add_tag_field(dict, \"kind\", tp.tagkind,\n                           tp.tagkind ? tp.tagkind_end : NULL) == FAIL\n          || tv_dict_add_nr(dict, S_LEN(\"static\"), is_static) == FAIL) {\n        ret = FAIL;\n      }\n\n      xfree(full_fname);\n\n      if (tp.command_end != NULL) {\n        for (char_u *p = tp.command_end + 3;\n             *p != NUL && *p != '\\n' && *p != '\\r';\n             MB_PTR_ADV(p)) {\n          if (p == tp.tagkind\n              || (p + 5 == tp.tagkind && STRNCMP(p, \"kind:\", 5) == 0)) {\n            // skip \"kind:<kind>\" and \"<kind>\"\n            p = tp.tagkind_end - 1;\n          } else if (STRNCMP(p, \"file:\", 5) == 0) {\n            // skip \"file:\" (static tag)\n            p += 4;\n          } else if (!ascii_iswhite(*p)) {\n            char_u  *s, *n;\n            int len;\n\n            /* Add extra field as a dict entry.  Fields are\n             * separated by Tabs. */\n            n = p;\n            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':')\n              ++p;\n            len = (int)(p - n);\n            if (*p == ':' && len > 0) {\n              s = ++p;\n              while (*p != NUL && *p >= ' ')\n                ++p;\n              n[len] = NUL;\n              if (add_tag_field(dict, (char *)n, s, p) == FAIL)\n                ret = FAIL;\n              n[len] = ':';\n            } else\n              /* Skip field without colon. */\n              while (*p != NUL && *p >= ' ')\n                ++p;\n            if (*p == NUL)\n              break;\n          }\n        }\n      }\n\n      xfree(matches[i]);\n    }\n    xfree(matches);\n  }\n  return ret;\n}\n\n// Return information about 'tag' in dict 'retdict'.\nstatic void get_tag_details(taggy_T *tag, dict_T *retdict)\n{\n  list_T *pos;\n  fmark_T *fmark;\n\n  tv_dict_add_str(retdict, S_LEN(\"tagname\"), (const char *)tag->tagname);\n  tv_dict_add_nr(retdict, S_LEN(\"matchnr\"), tag->cur_match + 1);\n  tv_dict_add_nr(retdict, S_LEN(\"bufnr\"), tag->cur_fnum);\n  if (tag->user_data) {\n    tv_dict_add_str(retdict, S_LEN(\"user_data\"), (const char *)tag->user_data);\n  }\n\n  pos = tv_list_alloc(4);\n  tv_dict_add_list(retdict, S_LEN(\"from\"), pos);\n\n  fmark = &tag->fmark;\n  tv_list_append_number(pos,\n                        (varnumber_T)(fmark->fnum != -1 ? fmark->fnum : 0));\n  tv_list_append_number(pos, (varnumber_T)fmark->mark.lnum);\n  tv_list_append_number(pos, (varnumber_T)(fmark->mark.col == MAXCOL\n                                           ? MAXCOL : fmark->mark.col + 1));\n  tv_list_append_number(pos, (varnumber_T)fmark->mark.coladd);\n}\n\n// Return the tag stack entries of the specified window 'wp' in dictionary\n// 'retdict'.\nvoid get_tagstack(win_T *wp, dict_T *retdict)\n{\n  list_T *l;\n  int i;\n  dict_T *d;\n\n  tv_dict_add_nr(retdict, S_LEN(\"length\"), wp->w_tagstacklen);\n  tv_dict_add_nr(retdict, S_LEN(\"curidx\"), wp->w_tagstackidx + 1);\n  l = tv_list_alloc(2);\n  tv_dict_add_list(retdict, S_LEN(\"items\"), l);\n\n  for (i = 0; i < wp->w_tagstacklen; i++) {\n    d = tv_dict_alloc();\n    tv_list_append_dict(l, d);\n    get_tag_details(&wp->w_tagstack[i], d);\n  }\n}\n\n// Free all the entries in the tag stack of the specified window\nstatic void tagstack_clear(win_T *wp)\n{\n  // Free the current tag stack\n  for (int i = 0; i < wp->w_tagstacklen; i++) {\n    tagstack_clear_entry(&wp->w_tagstack[i]);\n  }\n  wp->w_tagstacklen = 0;\n  wp->w_tagstackidx = 0;\n}\n\n// Remove the oldest entry from the tag stack and shift the rest of\n// the entries to free up the top of the stack.\nstatic void tagstack_shift(win_T *wp)\n{\n  taggy_T *tagstack = wp->w_tagstack;\n  tagstack_clear_entry(&tagstack[0]);\n  for (int i = 1; i < wp->w_tagstacklen; i++) {\n    tagstack[i - 1] = tagstack[i];\n  }\n  wp->w_tagstacklen--;\n}\n\n// Push a new item to the tag stack\nstatic void tagstack_push_item(\n    win_T   *wp,\n    char_u  *tagname,\n    int     cur_fnum,\n    int     cur_match,\n    pos_T   mark,\n    int     fnum,\n    char_u *user_data)\n{\n  taggy_T *tagstack = wp->w_tagstack;\n  int idx = wp->w_tagstacklen;  // top of the stack\n\n  // if the tagstack is full: remove the oldest entry\n  if (idx >= TAGSTACKSIZE) {\n    tagstack_shift(wp);\n    idx = TAGSTACKSIZE - 1;\n  }\n\n  wp->w_tagstacklen++;\n  tagstack[idx].tagname = tagname;\n  tagstack[idx].cur_fnum = cur_fnum;\n  tagstack[idx].cur_match = cur_match;\n  if (tagstack[idx].cur_match < 0) {\n    tagstack[idx].cur_match = 0;\n  }\n  tagstack[idx].fmark.mark = mark;\n  tagstack[idx].fmark.fnum = fnum;\n  tagstack[idx].user_data = user_data;\n}\n\n// Add a list of items to the tag stack in the specified window\nstatic void tagstack_push_items(win_T *wp, list_T *l)\n{\n  listitem_T *li;\n  dictitem_T *di;\n  dict_T *itemdict;\n  char_u *tagname;\n  pos_T mark;\n  int fnum;\n\n  // Add one entry at a time to the tag stack\n  for (li = tv_list_first(l); li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {\n    if (TV_LIST_ITEM_TV(li)->v_type != VAR_DICT\n        || TV_LIST_ITEM_TV(li)->vval.v_dict == NULL) {\n      continue;  // Skip non-dict items\n    }\n    itemdict = TV_LIST_ITEM_TV(li)->vval.v_dict;\n\n    // parse 'from' for the cursor position before the tag jump\n    if ((di = tv_dict_find(itemdict, \"from\", -1)) == NULL) {\n      continue;\n    }\n    if (list2fpos(&di->di_tv, &mark, &fnum, NULL) != OK) {\n      continue;\n    }\n    if ((tagname = (char_u *)tv_dict_get_string(itemdict, \"tagname\", true))\n        == NULL) {\n      continue;\n    }\n\n    if (mark.col > 0) {\n      mark.col--;\n    }\n    tagstack_push_item(\n        wp,\n        tagname,\n        (int)tv_dict_get_number(itemdict, \"bufnr\"),\n        (int)tv_dict_get_number(itemdict, \"matchnr\") - 1,\n        mark, fnum,\n        (char_u *)tv_dict_get_string(itemdict, \"user_data\", true));\n  }\n}\n\n// Set the current index in the tag stack. Valid values are between 0\n// and the stack length (inclusive).\nstatic void tagstack_set_curidx(win_T *wp, int curidx)\n{\n  wp->w_tagstackidx = curidx;\n  if (wp->w_tagstackidx < 0) {  // sanity check\n    wp->w_tagstackidx = 0;\n  }\n  if (wp->w_tagstackidx > wp->w_tagstacklen) {\n    wp->w_tagstackidx = wp->w_tagstacklen;\n  }\n}\n\n// Set the tag stack entries of the specified window.\n// 'action' is set to one of:\n//    'a' for append\n//    'r' for replace\n//    't' for truncate\nint set_tagstack(win_T *wp, const dict_T *d, int action)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  dictitem_T *di;\n  list_T *l = NULL;\n\n  // not allowed to alter the tag stack entries from inside tagfunc\n  if (tfu_in_use) {\n    EMSG(_(recurmsg));\n    return FAIL;\n  }\n\n  if ((di = tv_dict_find(d, \"items\", -1)) != NULL) {\n    if (di->di_tv.v_type != VAR_LIST) {\n      EMSG(_(e_listreq));\n      return FAIL;\n    }\n    l = di->di_tv.vval.v_list;\n  }\n\n  if ((di = tv_dict_find(d, \"curidx\", -1)) != NULL) {\n    tagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n  }\n  if (action == 't') {  // truncate the stack\n    taggy_T *const tagstack = wp->w_tagstack;\n    const int tagstackidx = wp->w_tagstackidx;\n    int tagstacklen = wp->w_tagstacklen;\n    // delete all the tag stack entries above the current entry\n    while (tagstackidx < tagstacklen) {\n      tagstack_clear_entry(&tagstack[--tagstacklen]);\n    }\n    wp->w_tagstacklen = tagstacklen;\n  }\n\n  if (l != NULL) {\n    if (action == 'r') {  // replace the stack\n      tagstack_clear(wp);\n    }\n\n    tagstack_push_items(wp, l);\n    // set the current index after the last entry\n    wp->w_tagstackidx = wp->w_tagstacklen;\n  }\n\n  return OK;\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}, "2": {"id": 2, "path": "src/nvim/eval/typval.h", "content": "#ifndef NVIM_EVAL_TYPVAL_H\n#define NVIM_EVAL_TYPVAL_H\n\n#include <inttypes.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"nvim/types.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/lib/queue.h\"\n#include \"nvim/profile.h\"  // for proftime_T\n#include \"nvim/pos.h\"      // for linenr_T\n#include \"nvim/gettext.h\"\n#include \"nvim/message.h\"\n#include \"nvim/macros.h\"\n#ifdef LOG_LIST_ACTIONS\n# include \"nvim/memory.h\"\n#endif\n\n/// Type used for VimL VAR_NUMBER values\ntypedef int64_t varnumber_T;\ntypedef uint64_t uvarnumber_T;\n\n/// Type used for VimL VAR_FLOAT values\ntypedef double float_T;\n\n/// Refcount for dict or list that should not be freed\nenum { DO_NOT_FREE_CNT = (INT_MAX / 2) };\n\n/// Additional values for tv_list_alloc() len argument\nenum ListLenSpecials {\n  /// List length is not known in advance\n  ///\n  /// To be used when there is neither a way to know how many elements will be\n  /// needed nor are any educated guesses.\n  kListLenUnknown = -1,\n  /// List length *should* be known, but is actually not\n  ///\n  /// All occurrences of this value should be eventually removed. This is for\n  /// the case when the only reason why list length is not known is that it\n  /// would be hard to code without refactoring, but refactoring is needed.\n  kListLenShouldKnow = -2,\n  /// List length may be known in advance, but it requires too much effort\n  ///\n  /// To be used when it looks impractical to determine list length.\n  kListLenMayKnow = -3,\n};\n\n/// Maximal possible value of varnumber_T variable\n#define VARNUMBER_MAX INT64_MAX\n#define UVARNUMBER_MAX UINT64_MAX\n\n/// Minimal possible value of varnumber_T variable\n#define VARNUMBER_MIN INT64_MIN\n\n/// %d printf format specifier for varnumber_T\n#define PRIdVARNUMBER PRId64\n\ntypedef struct listvar_S list_T;\ntypedef struct dictvar_S dict_T;\ntypedef struct partial_S partial_T;\ntypedef struct blobvar_S blob_T;\n\ntypedef struct ufunc ufunc_T;\n\ntypedef enum {\n  kCallbackNone = 0,\n  kCallbackFuncref,\n  kCallbackPartial,\n} CallbackType;\n\ntypedef struct {\n  union {\n    char_u *funcref;\n    partial_T *partial;\n  } data;\n  CallbackType type;\n} Callback;\n#define CALLBACK_NONE ((Callback){ .type = kCallbackNone })\n\n/// Structure holding dictionary watcher\ntypedef struct dict_watcher {\n  Callback callback;\n  char *key_pattern;\n  size_t key_pattern_len;\n  QUEUE node;\n  bool busy;  // prevent recursion if the dict is changed in the callback\n  bool needs_free;\n} DictWatcher;\n\n/// Bool variable values\ntypedef enum {\n  kBoolVarFalse,         ///< v:false\n  kBoolVarTrue,          ///< v:true\n} BoolVarValue;\n\n/// Special variable values\ntypedef enum {\n  kSpecialVarNull,   ///< v:null\n} SpecialVarValue;\n\n/// Variable lock status for typval_T.v_lock\ntypedef enum {\n  VAR_UNLOCKED = 0,  ///< Not locked.\n  VAR_LOCKED = 1,    ///< User lock, can be unlocked.\n  VAR_FIXED = 2,     ///< Locked forever.\n} VarLockStatus;\n\n/// VimL variable types, for use in typval_T.v_type\ntypedef enum {\n  VAR_UNKNOWN = 0,  ///< Unknown (unspecified) value.\n  VAR_NUMBER,       ///< Number, .v_number is used.\n  VAR_STRING,       ///< String, .v_string is used.\n  VAR_FUNC,         ///< Function reference, .v_string is used as function name.\n  VAR_LIST,         ///< List, .v_list is used.\n  VAR_DICT,         ///< Dictionary, .v_dict is used.\n  VAR_FLOAT,        ///< Floating-point value, .v_float is used.\n  VAR_BOOL,         ///< true, false\n  VAR_SPECIAL,      ///< Special value (null), .v_special\n                    ///< is used.\n  VAR_PARTIAL,      ///< Partial, .v_partial is used.\n  VAR_BLOB,         ///< Blob, .v_blob is used.\n} VarType;\n\n/// Structure that holds an internal variable value\ntypedef struct {\n  VarType v_type;  ///< Variable type.\n  VarLockStatus v_lock;  ///< Variable lock status.\n  union typval_vval_union {\n    varnumber_T v_number;  ///< Number, for VAR_NUMBER.\n    BoolVarValue v_bool;        ///< Bool value, for VAR_BOOL\n    SpecialVarValue v_special;  ///< Special value, for VAR_SPECIAL.\n    float_T v_float;  ///< Floating-point number, for VAR_FLOAT.\n    char_u *v_string;  ///< String, for VAR_STRING and VAR_FUNC, can be NULL.\n    list_T *v_list;  ///< List for VAR_LIST, can be NULL.\n    dict_T *v_dict;  ///< Dictionary for VAR_DICT, can be NULL.\n    partial_T *v_partial;  ///< Closure: function with args.\n    blob_T *v_blob;  ///< Blob for VAR_BLOB, can be NULL.\n  }           vval;  ///< Actual value.\n} typval_T;\n\n/// Values for (struct dictvar_S).dv_scope\ntypedef enum {\n  VAR_NO_SCOPE = 0,  ///< Not a scope dictionary.\n  VAR_SCOPE = 1,  ///< Scope dictionary which requires prefix (a:, v:, \u2026).\n  VAR_DEF_SCOPE = 2,  ///< Scope dictionary which may be accessed without prefix\n                      ///< (l:, g:).\n} ScopeType;\n\n/// Structure to hold an item of a list\ntypedef struct listitem_S listitem_T;\n\nstruct listitem_S {\n  listitem_T  *li_next;  ///< Next item in list.\n  listitem_T  *li_prev;  ///< Previous item in list.\n  typval_T li_tv;  ///< Item value.\n};\n\n/// Structure used by those that are using an item in a list\ntypedef struct listwatch_S listwatch_T;\n\nstruct listwatch_S {\n  listitem_T *lw_item;  ///< Item being watched.\n  listwatch_T *lw_next;  ///< Next watcher.\n};\n\n/// Structure to hold info about a list\n/// Order of members is optimized to reduce padding.\nstruct listvar_S {\n  listitem_T *lv_first;  ///< First item, NULL if none.\n  listitem_T *lv_last;  ///< Last item, NULL if none.\n  listwatch_T *lv_watch;  ///< First watcher, NULL if none.\n  listitem_T *lv_idx_item;  ///< When not NULL item at index \"lv_idx\".\n  list_T *lv_copylist;  ///< Copied list used by deepcopy().\n  list_T *lv_used_next;  ///< next list in used lists list.\n  list_T *lv_used_prev;  ///< Previous list in used lists list.\n  int lv_refcount;  ///< Reference count.\n  int lv_len;  ///< Number of items.\n  int lv_idx;  ///< Index of a cached item, used for optimising repeated l[idx].\n  int lv_copyID;  ///< ID used by deepcopy().\n  VarLockStatus lv_lock;  ///< Zero, VAR_LOCKED, VAR_FIXED.\n\n  LuaRef lua_table_ref;\n};\n\n// Static list with 10 items. Use tv_list_init_static10() to initialize.\ntypedef struct {\n  list_T sl_list;  // must be first\n  listitem_T sl_items[10];\n} staticList10_T;\n\n#define TV_LIST_STATIC10_INIT { \\\n    .sl_list = { \\\n      .lv_first = NULL, \\\n      .lv_last = NULL, \\\n      .lv_refcount = 0, \\\n      .lv_len = 0, \\\n      .lv_watch = NULL, \\\n      .lv_idx_item = NULL, \\\n      .lv_lock = VAR_FIXED, \\\n      .lv_used_next = NULL, \\\n      .lv_used_prev = NULL, \\\n    }, \\\n  }\n\n#define TV_DICTITEM_STRUCT(...) \\\n    struct { \\\n      typval_T di_tv;  /* Structure that holds scope dictionary itself. */ \\\n      uint8_t di_flags;  /* Flags. */ \\\n      char_u di_key[__VA_ARGS__];  /* Key value. */ \\\n    }\n\n/// Structure to hold a scope dictionary\n///\n/// @warning Must be compatible with dictitem_T.\n///\n/// For use in find_var_in_ht to pretend that it found dictionary item when it\n/// finds scope dictionary.\ntypedef TV_DICTITEM_STRUCT(1) ScopeDictDictItem;\n\n/// Structure to hold an item of a Dictionary\n///\n/// @warning Must be compatible with ScopeDictDictItem.\n///\n/// Also used for a variable.\ntypedef TV_DICTITEM_STRUCT() dictitem_T;\n\n/// Flags for dictitem_T.di_flags\ntypedef enum {\n  DI_FLAGS_RO = 1,  ///< Read-only value\n  DI_FLAGS_RO_SBX = 2,  ///< Value, read-only in the sandbox\n  DI_FLAGS_FIX = 4,  ///< Fixed value: cannot be :unlet or remove()d.\n  DI_FLAGS_LOCK = 8,  ///< Locked value.\n  DI_FLAGS_ALLOC = 16,  ///< Separately allocated.\n} DictItemFlags;\n\n/// Structure representing a Dictionary\nstruct dictvar_S {\n  VarLockStatus dv_lock;  ///< Whole dictionary lock status.\n  ScopeType dv_scope;     ///< Non-zero (#VAR_SCOPE, #VAR_DEF_SCOPE) if\n                          ///< dictionary represents a scope (i.e. g:, l: \u2026).\n  int dv_refcount;        ///< Reference count.\n  int dv_copyID;          ///< ID used when recursivery traversing a value.\n  hashtab_T dv_hashtab;   ///< Hashtab containing all items.\n  dict_T *dv_copydict;    ///< Copied dict used by deepcopy().\n  dict_T *dv_used_next;   ///< Next dictionary in used dictionaries list.\n  dict_T *dv_used_prev;   ///< Previous dictionary in used dictionaries list.\n  QUEUE watchers;         ///< Dictionary key watchers set by user code.\n\n  LuaRef lua_table_ref;\n};\n\n/// Structure to hold info about a Blob\nstruct blobvar_S {\n  garray_T bv_ga;         ///< Growarray with the data.\n  int bv_refcount;        ///< Reference count.\n  VarLockStatus bv_lock;  ///< VAR_UNLOCKED, VAR_LOCKED, VAR_FIXED.\n};\n\n/// Type used for script ID\ntypedef int scid_T;\n/// Format argument for scid_T\n#define PRIdSCID \"d\"\n\n// SCript ConteXt (SCTX): identifies a script line.\n// When sourcing a script \"sc_lnum\" is zero, \"sourcing_lnum\" is the current\n// line number. When executing a user function \"sc_lnum\" is the line where the\n// function was defined, \"sourcing_lnum\" is the line number inside the\n// function.  When stored with a function, mapping, option, etc. \"sc_lnum\" is\n// the line number in the script \"sc_sid\".\ntypedef struct {\n  scid_T sc_sid;     // script ID\n  int sc_seq;        // sourcing sequence number\n  linenr_T sc_lnum;  // line number\n} sctx_T;\n\n/// Maximum number of function arguments\n#define MAX_FUNC_ARGS   20\n/// Short variable name length\n#define VAR_SHORT_LEN 20\n/// Number of fixed variables used for arguments\n#define FIXVAR_CNT 12\n\n/// Callback interface for C function reference>\n///     Used for managing functions that were registered with |register_cfunc|\ntypedef int (*cfunc_T)(int argcount, typval_T *argvars, typval_T *rettv, void *state);  // NOLINT\n/// Callback to clear cfunc_T and any associated state.\ntypedef void (*cfunc_free_T)(void *state);\n\n// Structure to hold info for a function that is currently being executed.\ntypedef struct funccall_S funccall_T;\n\nstruct funccall_S {\n  ufunc_T *func;  ///< Function being called.\n  int linenr;  ///< Next line to be executed.\n  int returned;  ///< \":return\" used.\n  /// Fixed variables for arguments.\n  TV_DICTITEM_STRUCT(VAR_SHORT_LEN + 1) fixvar[FIXVAR_CNT];\n  dict_T l_vars;  ///< l: local function variables.\n  ScopeDictDictItem l_vars_var;  ///< Variable for l: scope.\n  dict_T l_avars;  ///< a: argument variables.\n  ScopeDictDictItem l_avars_var;  ///< Variable for a: scope.\n  list_T l_varlist;  ///< List for a:000.\n  listitem_T l_listitems[MAX_FUNC_ARGS];  ///< List items for a:000.\n  typval_T *rettv;  ///< Return value.\n  linenr_T breakpoint;  ///< Next line with breakpoint or zero.\n  int dbg_tick;  ///< Debug_tick when breakpoint was set.\n  int level;  ///< Top nesting level of executed function.\n  proftime_T prof_child;  ///< Time spent in a child.\n  funccall_T *caller;  ///< Calling function or NULL; or next funccal in\n                       ///< list pointed to by previous_funccal.\n  int fc_refcount;  ///< Number of user functions that reference this funccall.\n  int fc_copyID;  ///< CopyID used for garbage collection.\n  garray_T fc_funcs;  ///< List of ufunc_T* which keep a reference to \"func\".\n};\n\n/// Structure to hold info for a user function.\nstruct ufunc {\n  int          uf_varargs;       ///< variable nr of arguments\n  int          uf_flags;\n  int          uf_calls;         ///< nr of active calls\n  bool         uf_cleared;       ///< func_clear() was already called\n  garray_T     uf_args;          ///< arguments\n  garray_T     uf_def_args;      ///< default argument expressions\n  garray_T     uf_lines;         ///< function lines\n  int          uf_profiling;     ///< true when func is being profiled\n  int          uf_prof_initialized;\n  // Managing cfuncs\n  cfunc_T      uf_cb;            ///< C function extension callback\n  cfunc_free_T uf_cb_free;       ///< C function extension free callback\n  void        *uf_cb_state;      ///< State of C function extension.\n  // Profiling the function as a whole.\n  int          uf_tm_count;      ///< nr of calls\n  proftime_T   uf_tm_total;      ///< time spent in function + children\n  proftime_T   uf_tm_self;       ///< time spent in function itself\n  proftime_T   uf_tm_children;   ///< time spent in children this call\n  // Profiling the function per line.\n  int         *uf_tml_count;     ///< nr of times line was executed\n  proftime_T  *uf_tml_total;     ///< time spent in a line + children\n  proftime_T  *uf_tml_self;      ///< time spent in a line itself\n  proftime_T   uf_tml_start;     ///< start time for current line\n  proftime_T   uf_tml_children;  ///< time spent in children for this line\n  proftime_T   uf_tml_wait;      ///< start wait time for current line\n  int          uf_tml_idx;       ///< index of line being timed; -1 if none\n  int          uf_tml_execed;    ///< line being timed was executed\n  sctx_T       uf_script_ctx;    ///< SCTX where function was defined,\n                                 ///< used for s: variables\n  int          uf_refcount;      ///< reference count, see func_name_refcount()\n  funccall_T   *uf_scoped;       ///< l: local variables for closure\n  char_u       uf_name[];  ///< Name of function (actual size equals name);\n                           ///< can start with <SNR>123_\n                           ///< (<SNR> is K_SPECIAL KS_EXTRA KE_SNR)\n};\n\nstruct partial_S {\n  int pt_refcount;  ///< Reference count.\n  char_u *pt_name;  ///< Function name; when NULL use pt_func->name.\n  ufunc_T *pt_func;  ///< Function pointer; when NULL lookup function with\n                     ///< pt_name.\n  bool pt_auto;  ///< When true the partial was created by using dict.member\n                 ///< in handle_subscript().\n  int pt_argc;  ///< Number of arguments.\n  typval_T *pt_argv;  ///< Arguments in allocated array.\n  dict_T *pt_dict;  ///< Dict for \"self\".\n};\n\n/// Structure used for explicit stack while garbage collecting hash tables\ntypedef struct ht_stack_S {\n  hashtab_T *ht;\n  struct ht_stack_S *prev;\n} ht_stack_T;\n\n/// Structure used for explicit stack while garbage collecting lists\ntypedef struct list_stack_S {\n  list_T *list;\n  struct list_stack_S *prev;\n} list_stack_T;\n\n/// Structure representing one list item, used for sort array.\ntypedef struct {\n  listitem_T *item;  ///< Sorted list item.\n  int idx;  ///< Sorted list item index.\n} ListSortItem;\n\ntypedef int (*ListSorter)(const void *, const void *);\n\n#ifdef LOG_LIST_ACTIONS\n\n/// List actions log entry\ntypedef struct {\n  uintptr_t l;  ///< List log entry belongs to.\n  uintptr_t li1;  ///< First list item log entry belongs to, if applicable.\n  uintptr_t li2;  ///< Second list item log entry belongs to, if applicable.\n  int len;  ///< List length when log entry was created.\n  const char *action;  ///< Logged action.\n} ListLogEntry;\n\ntypedef struct list_log ListLog;\n\n/// List actions log\nstruct list_log {\n  ListLog *next;  ///< Next chunk or NULL.\n  size_t capacity;  ///< Number of entries in current chunk.\n  size_t size;  ///< Current chunk size.\n  ListLogEntry entries[];  ///< Actual log entries.\n};\n\nextern ListLog *list_log_first;  ///< First list log chunk, NULL if missing\nextern ListLog *list_log_last;  ///< Last list log chunk\n\nstatic inline ListLog *list_log_alloc(const size_t size)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Allocate a new log chunk and update globals\n///\n/// @param[in]  size  Number of entries in a new chunk.\n///\n/// @return [allocated] Newly allocated chunk.\nstatic inline ListLog *list_log_new(const size_t size)\n{\n  ListLog *ret = xmalloc(offsetof(ListLog, entries)\n                         + size * sizeof(ret->entries[0]));\n  ret->size = 0;\n  ret->capacity = size;\n  ret->next = NULL;\n  if (list_log_first == NULL) {\n    list_log_first = ret;\n  } else {\n    list_log_last->next = ret;\n  }\n  list_log_last = ret;\n  return ret;\n}\n\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Add new entry to log\n///\n/// If last chunk was filled it uses twice as much memory to allocate the next\n/// chunk.\n///\n/// @param[in]  l  List to which entry belongs.\n/// @param[in]  li1  List item 1.\n/// @param[in]  li2  List item 2, often used for integers and not list items.\n/// @param[in]  action  Logged action.\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n{\n  ListLog *tgt;\n  if (list_log_first == NULL) {\n    tgt = list_log_new(128);\n  } else if (list_log_last->size == list_log_last->capacity) {\n    tgt = list_log_new(list_log_last->capacity * 2);\n  } else {\n    tgt = list_log_last;\n  }\n  tgt->entries[tgt->size++] = (ListLogEntry) {\n    .l = (uintptr_t)l,\n    .li1 = (uintptr_t)li1,\n    .li2 = (uintptr_t)li2,\n    .len = (l == NULL ? 0 : l->lv_len),\n    .action = action,\n  };\n}\n#else\n# define list_log(...)\n# define list_write_log(...)\n# define list_free_log()\n#endif\n\n// In a hashtab item \"hi_key\" points to \"di_key\" in a dictitem.\n// This avoids adding a pointer to the hashtab item.\n\n/// Convert a hashitem pointer to a dictitem pointer\n#define TV_DICT_HI2DI(hi) \\\n    ((dictitem_T *)((hi)->hi_key - offsetof(dictitem_T, di_key)))\n\nstatic inline void tv_list_ref(list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Increase reference count for a given list\n///\n/// Does nothing for NULL lists.\n///\n/// @param[in,out]  l  List to modify.\nstatic inline void tv_list_ref(list_T *const l)\n{\n  if (l == NULL) {\n    return;\n  }\n  l->lv_refcount++;\n}\n\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a list as the return value.  Increments the reference count.\n///\n/// @param[out]  tv  Object to receive the list\n/// @param[in,out]  l  List to pass to the object\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n{\n  tv->v_type = VAR_LIST;\n  tv->vval.v_list = l;\n  tv_list_ref(l);\n}\n\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get list lock status\n///\n/// Returns VAR_FIXED for NULL lists.\n///\n/// @param[in]  l  List to check.\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n{\n  if (l == NULL) {\n    return VAR_FIXED;\n  }\n  return l->lv_lock;\n}\n\n/// Set list lock status\n///\n/// May only \u201cset\u201d VAR_FIXED for NULL lists.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  lock  New lock status.\nstatic inline void tv_list_set_lock(list_T *const l,\n                                    const VarLockStatus lock)\n{\n  if (l == NULL) {\n    assert(lock == VAR_FIXED);\n    return;\n  }\n  l->lv_lock = lock;\n}\n\n/// Set list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  copyid  New copyID.\nstatic inline void tv_list_set_copyid(list_T *const l,\n                                      const int copyid)\n  FUNC_ATTR_NONNULL_ALL\n{\n  l->lv_copyID = copyid;\n}\n\nstatic inline int tv_list_len(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a list\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_len(const list_T *const l)\n{\n  list_log(l, NULL, NULL, \"len\");\n  if (l == NULL) {\n    return 0;\n  }\n  return l->lv_len;\n}\n\nstatic inline int tv_list_copyid(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_copyid(const list_T *const l)\n{\n  return l->lv_copyID;\n}\n\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get latest list copy\n///\n/// Gets lv_copylist field assigned by tv_list_copy() earlier.\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n{\n  return l->lv_copylist;\n}\n\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Normalize index: that is, return either -1 or non-negative index\n///\n/// @param[in]  l  List to index. Used to get length.\n/// @param[in]  n  List index, possibly negative.\n///\n/// @return -1 or list index in range [0, tv_list_len(l)).\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n{\n  // Negative index is relative to the end.\n  if (n < 0) {\n    n += tv_list_len(l);\n  }\n\n  // Check for index out of range.\n  if (n < 0 || n >= tv_list_len(l)) {\n    return -1;\n  }\n  return n;\n}\n\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check whether list has watchers\n///\n/// E.g. is referenced by a :for loop.\n///\n/// @param[in]  l  List to check.\n///\n/// @return true if there are watchers, false otherwise.\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n{\n  return l && l->lv_watch;\n}\n\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get first list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"first\");\n    return NULL;\n  }\n  list_log(l, l->lv_first, NULL, \"first\");\n  return l->lv_first;\n}\n\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get last list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"last\");\n    return NULL;\n  }\n  list_log(l, l->lv_last, NULL, \"last\");\n  return l->lv_last;\n}\n\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a dictionary as the return value\n///\n/// @param[out]  tv  Object to receive the dictionary\n/// @param[in,out]  d  Dictionary to pass to the object\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n{\n  tv->v_type = VAR_DICT;\n  tv->vval.v_dict = d;\n  if (d != NULL) {\n    d->dv_refcount++;\n  }\n}\n\nstatic inline long tv_dict_len(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a Dictionary\n///\n/// @param[in]  d  Dictionary to check.\nstatic inline long tv_dict_len(const dict_T *const d)\n{\n  if (d == NULL) {\n    return 0L;\n  }\n  return (long)d->dv_hashtab.ht_used;\n}\n\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check if dictionary is watched\n///\n/// @param[in]  d  Dictionary to check.\n///\n/// @return true if there is at least one watcher.\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n{\n  return d && !QUEUE_EMPTY(&d->watchers);\n}\n\nstatic inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a blob as the return value.\n///\n/// Increments the reference count.\n///\n/// @param[out]  tv  Object to receive the blob.\n/// @param[in,out]  b  Blob to pass to the object.\nstatic inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)\n{\n  tv->v_type = VAR_BLOB;\n  tv->vval.v_blob = b;\n  if (b != NULL) {\n    b->bv_refcount++;\n  }\n}\n\nstatic inline int tv_blob_len(const blob_T *const b)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the length of the data in the blob, in bytes.\n///\n/// @param[in]  b  Blob to check.\nstatic inline int tv_blob_len(const blob_T *const b)\n{\n  if (b == NULL) {\n    return 0;\n  }\n  return b->bv_ga.ga_len;\n}\n\nstatic inline char_u tv_blob_get(const blob_T *const b, int idx)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the byte at index `idx` in the blob.\n///\n/// @param[in]  b  Blob to index. Cannot be NULL.\n/// @param[in]  idx  Index in a blob. Must be valid.\n///\n/// @return Byte value at the given index.\nstatic inline char_u tv_blob_get(const blob_T *const b, int idx)\n{\n  return ((char_u *)b->bv_ga.ga_data)[idx];\n}\n\nstatic inline void tv_blob_set(blob_T *const b, int idx, char_u c)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL;\n\n/// Store the byte `c` at index `idx` in the blob.\n///\n/// @param[in]  b  Blob to index. Cannot be NULL.\n/// @param[in]  idx  Index in a blob. Must be valid.\n/// @param[in]  c  Value to store.\nstatic inline void tv_blob_set(blob_T *const b, int idx, char_u c)\n{\n  ((char_u *)b->bv_ga.ga_data)[idx] = c;\n}\n\n/// Initialize VimL object\n///\n/// Initializes to unlocked VAR_UNKNOWN object.\n///\n/// @param[out]  tv  Object to initialize.\nstatic inline void tv_init(typval_T *const tv)\n{\n  if (tv != NULL) {\n    memset(tv, 0, sizeof(*tv));\n  }\n}\n\n#define TV_INITIAL_VALUE \\\n    ((typval_T) { \\\n      .v_type = VAR_UNKNOWN, \\\n      .v_lock = VAR_UNLOCKED, \\\n    })\n\n/// Empty string\n///\n/// Needed for hack which allows not allocating empty string and still not\n/// crashing when freeing it.\nextern const char *const tv_empty_string;\n\n/// Specifies that free_unref_items() function has (not) been entered\nextern bool tv_in_free_unref_items;\n\n/// Iterate over a list\n///\n/// @param  modifier  Modifier: expected to be const or nothing, volatile should\n///                   also work if you have any uses for the volatile list.\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define _TV_LIST_ITER_MOD(modifier, l, li, code) \\\n    do { \\\n      modifier list_T *const l_ = (l); \\\n      list_log(l_, NULL, NULL, \"iter\" #modifier); \\\n      if (l_ != NULL) { \\\n        for (modifier listitem_T *li = l_->lv_first; \\\n             li != NULL; li = li->li_next) { \\\n          code \\\n        } \\\n      } \\\n    } while (0)\n\n/// Iterate over a list\n///\n/// To be used when you need to modify list or values you iterate over, use\n/// #TV_LIST_ITER_CONST if you don\u2019t.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER(l, li, code) \\\n    _TV_LIST_ITER_MOD(, l, li, code)\n\n/// Iterate over a list\n///\n/// To be used when you don\u2019t need to modify list or values you iterate over,\n/// use #TV_LIST_ITER if you do.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER_CONST(l, li, code) \\\n    _TV_LIST_ITER_MOD(const, l, li, code)\n\n// Below macros are macros to avoid duplicating code for functionally identical\n// const and non-const function variants.\n\n/// Get typval_T out of list item\n///\n/// @param[in]  li  List item to get typval_T from, must not be NULL.\n///\n/// @return Pointer to typval_T.\n#define TV_LIST_ITEM_TV(li) (&(li)->li_tv)\n\n/// Get next list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the next item or NULL.\n#define TV_LIST_ITEM_NEXT(l, li) ((li)->li_next)\n\n/// Get previous list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the previous item or NULL.\n#define TV_LIST_ITEM_PREV(l, li) ((li)->li_prev)\n// List argument is not used currently, but it is a must for lists implemented\n// as a pair (size(in list), array) without terminator - basically for lists on\n// top of kvec.\n\n/// Iterate over a dictionary\n///\n/// @param[in]  d  Dictionary to iterate over.\n/// @param  di  Name of the variable with current dictitem_T entry.\n/// @param  code  Cycle body.\n#define TV_DICT_ITER(d, di, code) \\\n    HASHTAB_ITER(&(d)->dv_hashtab, di##hi_, { \\\n      { \\\n        dictitem_T *const di = TV_DICT_HI2DI(di##hi_); \\\n        { \\\n          code \\\n        } \\\n      } \\\n    })\n\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n// FIXME circular dependency, cannot import message.h.\nbool emsgf(const char *const fmt, ...);\n\n/// Get the float value\n///\n/// Raises an error if object is not number or floating-point.\n///\n/// @param[in]  tv  VimL object to get value from.\n/// @param[out]  ret_f  Location where resulting float is stored.\n///\n/// @return true in case of success, false if tv is not a number or float.\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n{\n  if (tv->v_type == VAR_FLOAT) {\n    *ret_f = tv->vval.v_float;\n    return true;\n  }\n  if (tv->v_type == VAR_NUMBER) {\n    *ret_f = (float_T)tv->vval.v_number;\n    return true;\n  }\n  emsgf(\"%s\", _(\"E808: Number or Float required\"));\n  return false;\n}\n\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_NONNULL_RET REAL_FATTR_PURE\n  REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_ALWAYS_INLINE;\n\n/// Compute the `DictWatcher` address from a QUEUE node.\n///\n/// This only exists for .asan-blacklist (ASAN doesn't handle QUEUE_DATA pointer\n/// arithmetic).\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n{\n  return QUEUE_DATA(q, DictWatcher, node);\n}\n\nstatic inline bool tv_is_func(const typval_T tv)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;\n\n/// Check whether given typval_T contains a function\n///\n/// That is, whether it contains VAR_FUNC or VAR_PARTIAL.\n///\n/// @param[in]  tv  Typval to check.\n///\n/// @return True if it is a function or a partial, false otherwise.\nstatic inline bool tv_is_func(const typval_T tv)\n{\n  return tv.v_type == VAR_FUNC || tv.v_type == VAR_PARTIAL;\n}\n\n/// Specify that argument needs to be translated\n///\n/// Used for size_t length arguments to avoid calling gettext() and strlen()\n/// unless needed.\n#define TV_TRANSLATE (SIZE_MAX)\n\n/// Specify that argument is a NUL-terminated C string\n///\n/// Used for size_t length arguments to avoid calling strlen() unless needed.\n#define TV_CSTRING (SIZE_MAX - 1)\n\n#ifdef UNIT_TESTING\n// Do not use enum constants, see commit message.\nEXTERN const size_t kTVCstring INIT(= TV_CSTRING);\nEXTERN const size_t kTVTranslate INIT(= TV_TRANSLATE);\n#endif\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"eval/typval.h.generated.h\"\n#endif\n#endif  // NVIM_EVAL_TYPVAL_H\n"}, "3": {"id": 3, "path": "src/nvim/hashtab.h", "content": "#ifndef NVIM_HASHTAB_H\n#define NVIM_HASHTAB_H\n\n#include <stddef.h>\n\n#include \"nvim/types.h\"\n\n/// Magic number used for hashitem \"hi_key\" value indicating a deleted item\n///\n/// Only the address is used.\nextern char hash_removed;\n\n/// Type for hash number (hash calculation result).\ntypedef size_t hash_T;\n\n/// The address of \"hash_removed\" is used as a magic number\n/// for hi_key to indicate a removed item.\n#define HI_KEY_REMOVED ((char_u *)&hash_removed)\n#define HASHITEM_EMPTY(hi) ((hi)->hi_key == NULL \\\n                            || (hi)->hi_key == (char_u *)&hash_removed)\n\n/// Hashtable item.\n///\n/// Each item has a NUL terminated string key.\n/// A key can appear only once in the table.\n///\n/// A hash number is computed from the key for quick lookup.  When the hashes\n/// of two different keys point to the same entry an algorithm is used to\n/// iterate over other entries in the table until the right one is found.\n/// To make the iteration work removed keys are different from entries where a\n/// key was never present.\n///\n/// Note that this does not contain a pointer to the key and another pointer to\n/// the value. Instead, it is assumed that the key is contained within the\n/// value, so that you can get a pointer to the value subtracting an offset from\n/// the pointer to the key.\n/// This reduces the size of this item by 1/3.\ntypedef struct hashitem_S {\n  /// Cached hash number for hi_key.\n  hash_T hi_hash;\n\n  /// Item key.\n  ///\n  /// Possible values mean the following:\n  /// NULL                      : Item was never used.\n  /// HI_KEY_REMOVED            : Item was removed.\n  /// (Any other pointer value) : Item is currently being used.\n  char_u *hi_key;\n} hashitem_T;\n\n/// Initial size for a hashtable.\n/// Our items are relatively small and growing is expensive, thus start with 16.\n/// Must be a power of 2.\n/// This allows for storing 10 items (2/3 of 16) before a resize is needed.\n#define HT_INIT_SIZE 16\n\n/// An array-based hashtable.\n///\n/// Keys are NUL terminated strings. They cannot be repeated within a table.\n/// Values are of any type.\n///\n/// The hashtable grows to accommodate more entries when needed.\ntypedef struct hashtable_S {\n  hash_T ht_mask;               /// mask used for hash value\n                                /// (nr of items in array is \"ht_mask\" + 1)\n  size_t ht_used;               /// number of items used\n  size_t ht_filled;             /// number of items used or removed\n  int ht_locked;                /// counter for hash_lock()\n  hashitem_T *ht_array;         /// points to the array, allocated when it's\n                                /// not \"ht_smallarray\"\n  hashitem_T ht_smallarray[HT_INIT_SIZE];      /// initial array\n} hashtab_T;\n\n/// Iterate over a hashtab\n///\n/// @param[in]  ht  Hashtab to iterate over.\n/// @param  hi  Name of the variable with current hashtab entry.\n/// @param  code  Cycle body.\n#define HASHTAB_ITER(ht, hi, code) \\\n    do { \\\n      hashtab_T *const hi##ht_ = (ht); \\\n      size_t hi##todo_ = hi##ht_->ht_used; \\\n      for (hashitem_T *hi = hi##ht_->ht_array; hi##todo_; hi++) { \\\n        if (!HASHITEM_EMPTY(hi)) { \\\n          hi##todo_--; \\\n          { \\\n            code \\\n          } \\\n        } \\\n      } \\\n    } while (0)\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"hashtab.h.generated.h\"\n#endif\n\n#endif  // NVIM_HASHTAB_H\n"}}, "reports": [{"events": [{"location": {"col": 20, "file": 0, "line": 284}, "message": "old_key_typed (fixit)"}, {"location": {"col": 20, "file": 0, "line": 284}, "message": "invalid case style for variable 'old_KeyTyped'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7cebdb5c34d8b70934e3a56c52fd0faf", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 324}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 324}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3b3d29edbb97c69648a31209b9531fc9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 324}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 324}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e231d6137a3dabe70a28069c9faf4346", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 370}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 370}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8a44730ff2a672dfaa8cd0b16261363a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 370}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 370}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "258db7e92d5a1659026b45b9e99b9147", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 384}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 384}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4fcde1c66224994d9f1cead2fddb59c5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 384}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 384}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7e0d76b49ca20c8bff9b7be2d063c8d0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 427}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 427}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2350c2abba8ad5fc02ddb845e2f498af", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 427}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 427}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7f7ad8e9d190bfe3ee3bdaa72afafb8b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 469}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 469}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "08377ab48d18cad3f25b3bdec6052021", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 469}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 469}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8ece7d84dbbed3fb8388f8d22b7b21d0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 493}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "bf3c39b89176077b346150b5b135bc70", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 495}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9c6530b5b8dd0217889dc15f857e4384", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 520}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 520}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c61d52eb05f085e1ee873141c47624a2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 520}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 520}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1781b91858ca8c1bc55ba1f5877e7ab9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 566}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 566}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d7f25515a595e0017f56d65fc8ec8c4a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 566}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 566}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4f9f82ec0587f4d71a5b35a04d6d241b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 568}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 568}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "07e132da83412fa75a9763c85a0822d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 568}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 568}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "42986e88a9c733ec94f4a13c50c5f50a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 598}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 598}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ee19ed91901db8d38ad810cef042bfa8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 598}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 598}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "44852284d055b9b224c7b7b0e9ae1c2a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 613}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 613}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "611de58c4c97fb5a310f31f68015b6aa", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b10f726125b7162a95a4a98375cb5ed2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f6c13dfd682d4024b03923b9f1488859", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 653}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 653}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "384f28461cbf84859bf93eaaed550400", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 653}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 653}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0f6d875e8b5a870dbca4eb1a8c8cb9cb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 665}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 665}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8424de71dfac98be99689d748cba4446", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 665}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 665}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "659288d514311f7901a7ca941776b93b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 900}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c52707fffba3200b985e28d61c4f4dce", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 929}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2c389cc0db7dd6b2c191d69a679d5c50", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 17, "file": 0, "line": 964}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 17, "file": 0, "line": 964}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "29efc5284e731dc201b93a3df5715e17", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 13, "file": 0, "line": 971}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 13, "file": 0, "line": 971}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5e0c51908dd9cc782070567dfe7c42fa", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1027}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1027}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "dd066832574bbd5a9c2ef86ddd1da134", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1027}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1027}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b48419a9005907734824816e98f99d0f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1047}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1047}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5d75833614ba4b1a5f561eeaec85a906", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1047}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1047}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "253b0eac1e20ef6581be7ac2724805e3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1064}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1064}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9db82e405a7d31f4255323c669040ce7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1064}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1064}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "728baffc7864a7d92a4148c48b879db7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1081}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7d83f7174b6c4a307e873f208130c1a0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1081}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0241f2914c0a8633a829394b605ccde5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1083}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1083}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2cffd7a9aad4d4005ebc93ea961f70c8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1083}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1083}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "15b7166b83712d63f0e3cfbd724c181a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1103}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ddd621b380f22ef1dfcc0e3ba1bbd003", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1103}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68aa18d7d6aa435e991199b2c477bcae", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 1105}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 1105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7239f211268d1484384e85f7c3c74f72", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 1105}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 1105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ee672a9f9f631bb36aa0fea5e860c7a6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1107}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5ab68cab2cb2fc76cd6c099bff2d71da", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1107}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1107}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8268d084b453efc0bd0201f6c969e617", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1109}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1109}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8ce83afc706544a85c898f50146f7db9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1109}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1109}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8784a97f0f465054ed9eef825c4d1294", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1111}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1111}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1d4830a8256ac0d1f4c340f75a1e0b9e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1111}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1111}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "296d5cf04a787564b9a5f7f38bbd0800", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1113}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3f5c53a97f38b45be8ab6744b8f74bc1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1113}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1113}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ded30251160d427d276743452a720c87", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1115}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e2849235eb77473aeb5bbb69eec16c52", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1115}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1115}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d60792ecb4881ac751a5f6671c7d790a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 1119}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 1119}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "63f48489c87415c0bb28042ffa33c157", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 1119}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 1119}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a782a6b61ece41d781b9ccd19689b97b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1121}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1121}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a6b7b63844d124e946c095a456d8e2b8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1121}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1121}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "58e277406f8f524b08a3d72f730824fd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1145}, "message": "flag_string (fixit)"}, {"location": {"col": 10, "file": 0, "line": 1145}, "message": "invalid case style for variable 'flagString'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "834ef63f4ff708de87f42c753ae07b4f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1264}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1264}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "091de2080f4c7da093f4e0e5dc9c9998", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1268}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1268}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ccda019bb7b425db93cd503bb8a06c4c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1272}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 7, "file": 0, "line": 1272}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "889e0fbb82783e2676a1931d882bc081", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 9, "file": 0, "line": 1276}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 9, "file": 0, "line": 1276}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "01379fa4d374ec871a18a39a8d40cfdc", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1281}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1281}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "790a42ba0f2856619eebaed5099a9399", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1306}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1306}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e556689065bfd5b49298000540e53cab", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1308}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1308}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2d4541f60cf77784c3c4b4f18f7e28f9", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1310}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 2, "line": 890}, "message": "expanded from macro 'TV_DICT_ITER'"}, {"location": {"col": 13, "file": 3, "line": 87}, "message": "expanded from macro 'HASHTAB_ITER'"}, {"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 1310}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "521e538f6d534ace0ce2145ea21141a1", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 1399}, "message": "kTsStart (fixit)"}, {"location": {"col": 5, "file": 0, "line": 1399}, "message": "invalid case style for enum constant 'TS_START'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0863518c9385ef6fe0517b2bc38de0b2", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 1400}, "message": "kTsLinear (fixit)"}, {"location": {"col": 5, "file": 0, "line": 1400}, "message": "invalid case style for enum constant 'TS_LINEAR'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9c4b98e33686ad030356127c58118086", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 1401}, "message": "kTsBinary (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1401}, "message": "invalid case style for enum constant 'TS_BINARY'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "704790d739d6d35fc0a0ce88a7364c27", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1402}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 5, "file": 0, "line": 1402}, "message": "invalid case style for enum constant 'TS_SKIP_BACK'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2a193c5e4c51890e92c6a946a6fa048a", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1403}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 5, "file": 0, "line": 1403}, "message": "invalid case style for enum constant 'TS_STEP_FORWARD'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8a83c476ed2fc80e87e1d1fc1498f51f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 1483}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 1483}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0d68eaae347fddaa2c4a920cd48c2cd0", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1509}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1509}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "54865ccc9c7dc59f5d3edbd9d899de5a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1509}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1509}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0ba22ab8dc39282eeffb225d9beacf3a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1516}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ce15bbc9395002a697e133c4653b2f9a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1516}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "78154f8b7fcc7c8bcd404946b7908ec3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 1568}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 1568}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "411b7ef07086db9cf4aed4d9d118b7bc", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1574}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1574}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "df1e405bef6575578bb93d2e6b455930", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1576}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1576}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "01857d9bc9cc668b1edd870476f7bb16", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 0, "line": 1583}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 1583}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "98e740237f4d5aaea60dc868b15d6368", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 1583}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 1583}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3760aef3c4ce9631c1c2f5fabdfe4034", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 0, "line": 1594}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 0, "line": 1594}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "02d6d92b120fc0cd3f6f09aeb325dab4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 72, "file": 0, "line": 1594}, "message": "{ (fixit)"}, {"location": {"col": 71, "file": 0, "line": 1594}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "16e99648935dbeaa5b9609dd15e52756", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 0, "line": 1599}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 0, "line": 1599}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "73c7ef013f2bd0160b08100e56a8412d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 51, "file": 0, "line": 1599}, "message": "{ (fixit)"}, {"location": {"col": 50, "file": 0, "line": 1599}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "22023947d03e421f764beddb8ed840c8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1602}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1602}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "245d2ab713ae620e54ea54665085462a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1602}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1602}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "787aa8dcc14bdd409109520b35ba322d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1609}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1609}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "151a0e133317dd1ffc2c7a6e55913aed", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1609}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1609}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d68fa787e17326313eeb73acbefaabf9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1639}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1639}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "69abdeedccbc51a3e4e68eb38b6a942a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1639}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1639}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1a014993669d5a09c7ecbcb75836ca32", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1652}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1652}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "759fe0339b78863691948e7b2cb29118", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1652}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1652}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1e149d97935be1e63b49a5efb10cfa7c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1660}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1660}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "74c352fcd5f30d6d809cc135e0c6583c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1660}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1660}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4c4e8059ca02dc0d045e05fd62be65d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 1662}, "message": "search_info.curr_offset = offset (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1662}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "80251c7be0d68c3b6e08e784d3244964", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1662}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "07e132da83412fa75a9763c85a0822d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1662}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "42986e88a9c733ec94f4a13c50c5f50a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1740}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 15, "file": 0, "line": 1740}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3af2b5e91c479909191b51629f0bccc6", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1757}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1757}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4f208bbdfac09b6f10247be78c9d85da", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1757}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1757}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a263d3cc0c9d5c5ade776c584fb98722", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2faa19a9a84838af9dab7df97c0f8117", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1b7ad303641fffa042277d16f2c1edd3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 1770}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 1770}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "cbc70f7632e404149a7f2981f06a9d03", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 1770}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 1770}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8a166159f6bc6d1dc09fb56a37a1a5a4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1791}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3ffbdf00774b76108b98147e325dc3e7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1791}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b132778819f8afd396b96347a1d26a65", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1792}, "message": "end of the original"}, {"location": {"col": 13, "file": 0, "line": 1802}, "message": "clone 1 starts here"}, {"location": {"col": 13, "file": 0, "line": 1792}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6c004789c329763458059b8ae6b1d95e", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1793}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1793}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3e6264e3c526c519efebd0b6087d62c4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1793}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1793}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a9951ed6b4c9d80476bcf1e6b4ab8119", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1794}, "message": "end of the original"}, {"location": {"col": 13, "file": 0, "line": 1796}, "message": "clone 1 starts here"}, {"location": {"col": 13, "file": 0, "line": 1794}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4b8cfec5d2ac8154f09330286faa0e71", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1795}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "16050c57f6683e5fc4dc3314cfc16a73", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1795}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "871610cd637158967578393604328c87", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1801}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1801}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6c12ca86371c988c136b3730f01f1c6e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1801}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1801}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "10e00069922a13a537e191505714dd6d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 1868}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 1868}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "92bfeedb59e2fa89bf79b0cdd9890739", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 1868}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 1868}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0539cd7472f2405025b5e47ec58cf7ca", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1870}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1870}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9385558bbf1dcff7adcb5dfa6628fbfa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1870}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1870}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1227ff1fa2120ce0283a5c3da1dbfd7a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 1872}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 1872}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "97c552e0c1295795e31956a6f64e38f7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 1872}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 1872}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f301b191f60889b1a140eb354dffbb52", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1880}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1880}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "86409f85ac22e162aa8410b2af23a580", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1880}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1880}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c7cfbb4ae6460d6c87fa092e02b56bf6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1889}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1889}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "86409f85ac22e162aa8410b2af23a580", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1889}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1889}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c7cfbb4ae6460d6c87fa092e02b56bf6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1892}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1892}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68254248cca961ff1b722078e6e963ab", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1892}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1892}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c01c16a4a40e99548ce25a8fd48badaf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1900}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1900}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "004e368f36c4c51b43dc6033cf66675b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 1900}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 1900}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0a92e478d33c6974e8f21f33df479516", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 1902}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 1902}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "392ab5e9c544c82d3f575063dcc9e309", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 1902}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 1902}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d8ba77f6e94361e695b067968c1a7958", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1918}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1918}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "575364330717ad750c84d498272fa0f1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1918}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1918}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "bd916b0706f4c17939f382a0b1fa964f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1921}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1921}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ce6f34efcb26848adecc1fd96bfa94d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1921}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1921}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b479acd20991564940865c53fa2519da", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1929}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1929}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "cca649e3f9fc24ca363aff44806f109e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1929}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1929}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4abcf059843e4e058855ee3613abf43f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1932}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1932}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "31af74a5a1daf0183ac5f67fed9b859d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1932}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1932}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68aa660199742a1dfafd6c8e7ad71dc8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 1939}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "681855420719a52a3966fdb233bc6e91", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1941}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 77, "file": 0, "line": 1941}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "076cb900d9d236a8502d16953ed16cb7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1941}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 77, "file": 0, "line": 1941}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ed990a054eebb00de47a33face4a292a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1943}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1943}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68254248cca961ff1b722078e6e963ab", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1943}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1943}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c01c16a4a40e99548ce25a8fd48badaf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1953}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1953}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "cf570e58149038225309002acc498744", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1957}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1957}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6c12ca86371c988c136b3730f01f1c6e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1957}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1957}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "10e00069922a13a537e191505714dd6d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 76, "file": 0, "line": 1960}, "message": "{ (fixit)"}, {"location": {"col": 75, "file": 0, "line": 1960}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f1ef7bbe5364f0385368b19cce2335eb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 76, "file": 0, "line": 1960}, "message": "{ (fixit)"}, {"location": {"col": 75, "file": 0, "line": 1960}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1164356155b052243edcb6e17ac3087a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1967}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1967}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d38d6fe9a3b45f400317d83f963fac15", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1967}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1967}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9b42b2392cfe74c78c741001af771bed", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1969}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1969}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "07e132da83412fa75a9763c85a0822d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1969}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1969}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "42986e88a9c733ec94f4a13c50c5f50a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1971}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1971}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a03de8ff34268897312a258df6c00e1c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1971}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1971}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b37ea08a4fe7018f8fa4e4c4dffcff13", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1984}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1984}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "58a2c5c1c5492838e7bd025a052b7e8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1984}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1984}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "eb9ce8c3c5e822e0014c1df8c8116fca", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1987}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1987}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "da6a250f3e73c187a984faf170340fcd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1987}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1987}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "820bf7cc4e30e7beddcdd581eb912a69", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1993}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1993}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "936f2f39a5e53447ad3c8c42ffeafad9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1993}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1993}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "30f5c09a731450a27ac36621fbe42f53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1996}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1996}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6c12ca86371c988c136b3730f01f1c6e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1996}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1996}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "10e00069922a13a537e191505714dd6d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2038}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2038}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "75eac21a52e78b75c3d46b49b0502159", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2038}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2038}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f3106edc9db71b8fbf764cc542a7949c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2040}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2040}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "31af74a5a1daf0183ac5f67fed9b859d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2040}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2040}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68aa660199742a1dfafd6c8e7ad71dc8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2043}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2043}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "75eac21a52e78b75c3d46b49b0502159", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2043}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2043}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f3106edc9db71b8fbf764cc542a7949c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2045}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2045}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "31af74a5a1daf0183ac5f67fed9b859d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2045}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2045}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "68aa660199742a1dfafd6c8e7ad71dc8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2048}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2048}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f984aae6d10db78cd310d1e2e6730a1d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2048}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2048}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1a0e226bb7f08502d279f457161d3e11", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2050}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2050}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a273db5929065c0091153bb5778ecfe9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2050}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2050}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f3c6d265fd07ae85cc18e5d420f5ecd1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2068}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2068}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "91d5b4f71ef9a363ac26964e784e2cdf", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2070}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2070}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6cbb8cb6a55740c1150e02b2f337899d", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2120}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2120}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5ca6af4775f31a6d9c1ba0c927bceb5b", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2128}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2128}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "870f1fd1b2d12d59637bc7c126b246af", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2159}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "86306372a9d82acb34409010b3c3ea3f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2159}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "d29339ac7a761327ccc2791789b9943d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2172}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6bc4eb27cd16e2cb680b49af5adb8743", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2172}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "37966bedf98524eb6c3b03e8c33242f4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2174}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2174}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "926109cc1c67ad8c12c550c47c30e503", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2174}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2174}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e6b3354ce52f7233fb502168f6908766", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2191}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2191}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a73e4a3f999e482f465969c1d8e37919", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2191}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2191}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "290309e95d5f45f06507b91bb582660a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2196}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2196}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5bce79972bc0cd07be850e7a7266b1fb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2196}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2196}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c1c9fc385bb5b345e12985b016877428", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 0, "line": 2201}, "message": "{ (fixit)"}, {"location": {"col": 78, "file": 0, "line": 2201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3f02e9611e6d88c2d6fc6a6be7870515", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 79, "file": 0, "line": 2201}, "message": "{ (fixit)"}, {"location": {"col": 78, "file": 0, "line": 2201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "0c4244bd692c6bd5a796be89761410ab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 2203}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 2203}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2afab2c7b1d03e2bf3456e3879c820db", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 2203}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 2203}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b94086436f6e7535dd3d51ebdd61ae2d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2209}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5b8dacc037aef5b09430b03b8b30fea6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2209}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e8c6889c8b0d5096e435898e828dfeab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 2223}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 2223}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "823835aef8ed03447bbc8e25b977beea", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 2223}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 2223}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "7273aa0edffe89201ce8118a338bc77c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2226}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2226}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "eab87b61f61cbc7b04805bbae0810779", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2226}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2226}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "786b7bd5e89f24ff867c347632812a77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2228}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a6b7b63844d124e946c095a456d8e2b8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2228}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "58e277406f8f524b08a3d72f730824fd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2248}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "4240ec86d283696546079f3c087424c0", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2312}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "380cb80d8ef2414dea43c53130ed20d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2312}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1ad6f1e3d89807003833df4eaebe9e23", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 2331}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 2331}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "60ad2b056fe9bf251fa7361446c2965b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 2331}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 2331}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "629353a334ce6c691d13f56733307c15", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2334}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2334}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "15fd268522b5c66b482eefa0ed9c1ddb", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2335}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2335}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "17a6dc36d9c9c8378961b83d88acfd1b", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2370}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2370}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b65ec31348cb38ebc2c05c50a7fcc1eb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2370}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2370}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "957864e2c64344c1ddd17388e8497127", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2402}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2402}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "db1215386c1499bc619becf08880e5a1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2402}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2402}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "61ea87b27bb372a9027aae17804fc608", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 2407}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 2407}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "a8f00bd1b48e063d37b653295263a8c6", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2442}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2442}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2ef8e3f2e1b5cbd333c6fe91d3c3271d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2442}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2442}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "bda1d5cd3295524f75794665360fecfd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2447}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2447}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2d29c5be083a0c7f1ea033328a60c958", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2447}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2447}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "887e4b881cd68550a4a1e1fee52202d6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2451}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2451}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2ef8e3f2e1b5cbd333c6fe91d3c3271d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2451}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2451}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "bda1d5cd3295524f75794665360fecfd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2456}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2456}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "2d29c5be083a0c7f1ea033328a60c958", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2456}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2456}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "887e4b881cd68550a4a1e1fee52202d6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2458}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2458}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "61a51e91d8bccb26d9af1df967f7df06", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2458}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2458}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "9f6cfc4aeddfefd5076915cfd1096796", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2487}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "84c8db40870c92685bab4000f5c97194", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2487}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e4efadb2316df56ccd312ec1b947ec8c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2522}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3339c22e1d2dc12d6f067bfe30c345a0", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2565}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2565}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "cb007ff9d0d2bd80e8131d0d7bdbbd30", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2565}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2565}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "09568b48c2bfa74a3e562de4fd5d688f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2618}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "3b699d7637f443568cb247d0fbad0042", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2631}, "message": "old_key_typed (fixit)"}, {"location": {"col": 14, "file": 0, "line": 2631}, "message": "invalid case style for variable 'old_KeyTyped'"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "db2ec135bfca9e6b4e09e1c3b81e1d39", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2753}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2753}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "64758f0d625fab3a384e020c0bdafa25", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2753}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2753}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "6b49e9b61096337c2e218710db0ac02d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2755}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2755}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8ce83afc706544a85c898f50146f7db9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2755}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2755}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8784a97f0f465054ed9eef825c4d1294", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2780}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2780}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "fbd8e2944507f3789d3988757693dbce", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2780}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2780}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b1a8abfddc0bcde997074cb24d1ce4ad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2782}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2782}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8ce83afc706544a85c898f50146f7db9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2782}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2782}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "8784a97f0f465054ed9eef825c4d1294", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2794}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2794}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b7bb08c95441937b50363473999a10c5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2794}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2794}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c7b33091cef35e32e0e1e301b852d2e0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2901}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2901}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "30b8db21ea5b3961a54d8278ba29e562", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2901}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2901}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f542c7e444e841ae2729414919fbeb3b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2903}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2903}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "365377dfbad5c30c99404d9d94b45098", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2903}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2903}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "5efbbb3932bb8a73167998ef14800ead", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2953}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2953}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "825f5de54ba285ec9c8591e4a3e4aacc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2953}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2953}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e78a430b4fb317af5d9b869baee7f7cd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2962}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2962}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "222fd6c5de9dca96fb02b54633cd8512", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2969}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2969}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "dd066832574bbd5a9c2ef86ddd1da134", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2969}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2969}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "b48419a9005907734824816e98f99d0f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 3148}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 3148}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ec20945340afecb06826b9b0c1988120", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 3148}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 3148}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "bfbfaf10089c7bb6791054b4e354a374", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3152}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "423ad2cccf53a15ad817814e722516b4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3152}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c95753dca1008a3f8df8fc0b794a3370", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3167}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "460a13844ca7cd3fadfe02dbb7e97468", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 3219}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "c468faaaeb02060ac70e2878009c8371", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 0, "line": 3225}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 3225}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "23789d0c3bc21b8a304e57fcc3b986d6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 0, "line": 3225}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 3225}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e3bbbf041aefed11d0550ffb394c198c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3230}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3230}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e3713f1f4897226ff906fc6d9be48ea9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3230}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3230}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f3ee659e527e4eb98b2efc6c0698177e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 3233}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 3233}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "932cdc725191633f2903535bf2207277", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 3233}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 3233}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "51cb232634d28c2a8c2569b3743cd02e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 3236}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 3236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "1ed7638ad646e6afa726d08d3ae708a6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 3236}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 3236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "ce0d6e0529a008bb3fabde97c711a4f2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3238}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3238}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "e3713f1f4897226ff906fc6d9be48ea9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3238}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3238}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "f3ee659e527e4eb98b2efc6c0698177e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3240}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3240}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "028b6b2fa80a21a2d993cccf82cd9603", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3240}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3240}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/tag.c", "reportHash": "74e478417543b3282d84b5940696fed9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
