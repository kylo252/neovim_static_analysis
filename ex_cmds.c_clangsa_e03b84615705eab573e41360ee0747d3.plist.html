<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/ex_cmds.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * ex_cmds.c: some functions for command line commands\n */\n\n#include <assert.h>\n#include <float.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include <math.h>\n\n#include \"nvim/api/private/defs.h\"\n#include \"nvim/api/vim.h\"\n#include \"nvim/api/buffer.h\"\n#include \"nvim/log.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/highlight.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/buffer_updates.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/extmark.h\"\n#include \"nvim/decoration.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/tag.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/shell.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/time.h\"\n\n\n/// Case matching style to use for :substitute\ntypedef enum {\n  kSubHonorOptions = 0,  ///< Honor the user's 'ignorecase'/'smartcase' options\n  kSubIgnoreCase,        ///< Ignore case of the search\n  kSubMatchCase,         ///< Match case of the search\n} SubIgnoreType;\n\n/// Flags kept between calls to :substitute.\ntypedef struct {\n  bool do_all;          ///< do multiple substitutions per line\n  bool do_ask;          ///< ask for confirmation\n  bool do_count;        ///< count only\n  bool do_error;        ///< if false, ignore errors\n  bool do_print;        ///< print last line with subs\n  bool do_list;         ///< list last line with subs\n  bool do_number;       ///< list last line with line nr\n  SubIgnoreType do_ic;  ///< ignore case flag\n} subflags_T;\n\n/// Partial result of a substitution during :substitute.\n/// Numbers refer to the buffer _after_ substitution\ntypedef struct {\n  lpos_T start;  // start of the match\n  lpos_T end;    // end of the match\n  linenr_T pre_match;  // where to begin showing lines before the match\n} SubResult;\n\n// Collected results of a substitution for showing them in\n// the preview window\ntypedef struct {\n  kvec_t(SubResult) subresults;\n  linenr_T lines_needed;  // lines needed in the preview window\n} PreviewLines;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"ex_cmds.c.generated.h\"\n#endif\n\nstatic int preview_bufnr = 0;\n\n/// \":ascii\" and \"ga\" implementation\nvoid do_ascii(const exarg_T *const eap)\n{\n  char_u *dig;\n  int cc[MAX_MCO];\n  int c = utfc_ptr2char(get_cursor_pos_ptr(), cc);\n  if (c == NUL) {\n    MSG(\"NUL\");\n    return;\n  }\n\n  size_t iobuff_len = 0;\n\n  int ci = 0;\n  if (c < 0x80) {\n    if (c == NL) {  // NUL is stored as NL.\n      c = NUL;\n    }\n    const int cval = (c == CAR && get_fileformat(curbuf) == EOL_MAC\n                      ? NL  // NL is stored as CR.\n                      : c);\n    char buf1[20];\n    if (vim_isprintc_strict(c) && (c < ' ' || c > '~')) {\n      char_u buf3[7];\n      transchar_nonprint(curbuf, buf3, c);\n      vim_snprintf(buf1, sizeof(buf1), \"  <%s>\", (char *)buf3);\n    } else {\n      buf1[0] = NUL;\n    }\n    char buf2[20];\n    buf2[0] = NUL;\n\n    dig = get_digraph_for_char(cval);\n    if (dig != NULL) {\n        iobuff_len += (\n            vim_snprintf((char *)IObuff + iobuff_len,\n                         sizeof(IObuff) - iobuff_len,\n                         _(\"<%s>%s%s  %d,  Hex %02x,  Oct %03o, Digr %s\"),\n                         transchar(c), buf1, buf2, cval, cval, cval, dig));\n    } else {\n        iobuff_len += (\n            vim_snprintf((char *)IObuff + iobuff_len,\n                         sizeof(IObuff) - iobuff_len,\n                         _(\"<%s>%s%s  %d,  Hex %02x,  Octal %03o\"),\n                         transchar(c), buf1, buf2, cval, cval, cval));\n    }\n\n    c = cc[ci++];\n  }\n\n#define SPACE_FOR_DESC (1 + 1 + 1 + MB_MAXBYTES + 16 + 4 + 3 + 3 + 1)\n  // Space for description:\n  // - 1 byte for separator (starting from second entry)\n  // - 1 byte for \"<\"\n  // - 1 byte for space to draw composing character on (optional, but really\n  //   mostly required)\n  // - up to MB_MAXBYTES bytes for character itself\n  // - 16 bytes for raw text (\"> , Hex , Octal \").\n  // - at least 4 bytes for hexadecimal representation\n  // - at least 3 bytes for decimal representation\n  // - at least 3 bytes for octal representation\n  // - 1 byte for NUL\n  //\n  // Taking into account MAX_MCO and characters which need 8 bytes for\n  // hexadecimal representation, but not taking translation into account:\n  // resulting string will occupy less then 400 bytes (conservative estimate).\n  //\n  // Less then 1000 bytes if translation multiplies number of bytes needed for\n  // raw text by 6, so it should always fit into 1025 bytes reserved for IObuff.\n\n  // Repeat for combining characters, also handle multiby here.\n  while (c >= 0x80 && iobuff_len < sizeof(IObuff) - SPACE_FOR_DESC) {\n    // This assumes every multi-byte char is printable...\n    if (iobuff_len > 0) {\n      IObuff[iobuff_len++] = ' ';\n    }\n    IObuff[iobuff_len++] = '<';\n    if (utf_iscomposing(c)) {\n      IObuff[iobuff_len++] = ' ';  // Draw composing char on top of a space.\n    }\n    iobuff_len += utf_char2bytes(c, IObuff + iobuff_len);\n\n    dig = get_digraph_for_char(c);\n    if (dig != NULL) {\n        iobuff_len += (\n            vim_snprintf((char *)IObuff + iobuff_len,\n                         sizeof(IObuff) - iobuff_len,\n                         (c < 0x10000\n                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")\n                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),\n                         c, c, c, dig));\n    } else {\n        iobuff_len += (\n            vim_snprintf((char *)IObuff + iobuff_len,\n                         sizeof(IObuff) - iobuff_len,\n                         (c < 0x10000\n                          ? _(\"> %d, Hex %04x, Octal %o\")\n                          : _(\"> %d, Hex %08x, Octal %o\")),\n                         c, c, c));\n    }\n    if (ci == MAX_MCO) {\n      break;\n    }\n    c = cc[ci++];\n  }\n  if (ci != MAX_MCO && c != 0) {\n    xstrlcpy((char *)IObuff + iobuff_len, \" ...\", sizeof(IObuff) - iobuff_len);\n  }\n\n  msg(IObuff);\n}\n\n/*\n * \":left\", \":center\" and \":right\": align text.\n */\nvoid ex_align(exarg_T *eap)\n{\n  pos_T save_curpos;\n  int len;\n  int indent = 0;\n  int new_indent;\n  int has_tab;\n  int width;\n\n  if (curwin->w_p_rl) {\n    /* switch left and right aligning */\n    if (eap->cmdidx == CMD_right)\n      eap->cmdidx = CMD_left;\n    else if (eap->cmdidx == CMD_left)\n      eap->cmdidx = CMD_right;\n  }\n\n  width = atoi((char *)eap->arg);\n  save_curpos = curwin->w_cursor;\n  if (eap->cmdidx == CMD_left) {    /* width is used for new indent */\n    if (width >= 0)\n      indent = width;\n  } else {\n    /*\n     * if 'textwidth' set, use it\n     * else if 'wrapmargin' set, use it\n     * if invalid value, use 80\n     */\n    if (width <= 0)\n      width = curbuf->b_p_tw;\n    if (width == 0 && curbuf->b_p_wm > 0) {\n      width = curwin->w_width_inner - curbuf->b_p_wm;\n    }\n    if (width <= 0) {\n      width = 80;\n    }\n  }\n\n  if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)\n    return;\n\n  for (curwin->w_cursor.lnum = eap->line1;\n       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {\n    if (eap->cmdidx == CMD_left)                /* left align */\n      new_indent = indent;\n    else {\n      has_tab = FALSE;          /* avoid uninit warnings */\n      len = linelen(eap->cmdidx == CMD_right ? &has_tab\n          : NULL) - get_indent();\n\n      if (len <= 0)                             /* skip blank lines */\n        continue;\n\n      if (eap->cmdidx == CMD_center)\n        new_indent = (width - len) / 2;\n      else {\n        new_indent = width - len;               /* right align */\n\n        /*\n         * Make sure that embedded TABs don't make the text go too far\n         * to the right.\n         */\n        if (has_tab)\n          while (new_indent > 0) {\n            (void)set_indent(new_indent, 0);\n            if (linelen(NULL) <= width) {\n              /*\n               * Now try to move the line as much as possible to\n               * the right.  Stop when it moves too far.\n               */\n              do\n                (void)set_indent(++new_indent, 0);\n              while (linelen(NULL) <= width);\n              --new_indent;\n              break;\n            }\n            --new_indent;\n          }\n      }\n    }\n    if (new_indent < 0)\n      new_indent = 0;\n    (void)set_indent(new_indent, 0);                    /* set indent */\n  }\n  changed_lines(eap->line1, 0, eap->line2 + 1, 0L, true);\n  curwin->w_cursor = save_curpos;\n  beginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * Get the length of the current line, excluding trailing white space.\n */\nstatic int linelen(int *has_tab)\n{\n  char_u  *line;\n  char_u  *first;\n  char_u  *last;\n  int save;\n  int len;\n\n  // Get the line.  If it's empty bail out early (could be the empty string\n  // for an unloaded buffer).\n  line = get_cursor_line_ptr();\n  if (*line == NUL) {\n    return 0;\n  }\n  // find the first non-blank character\n  first = skipwhite(line);\n\n  // find the character after the last non-blank character\n  for (last = first + STRLEN(first);\n       last > first && ascii_iswhite(last[-1]); last--) {\n  }\n  save = *last;\n  *last = NUL;\n  // Get line length.\n  len = linetabsize(line);\n  // Check for embedded TAB.\n  if (has_tab != NULL) {\n    *has_tab = vim_strchr(first, TAB) != NULL;\n  }\n  *last = save;\n\n  return len;\n}\n\n/* Buffer for two lines used during sorting.  They are allocated to\n * contain the longest line being sorted. */\nstatic char_u   *sortbuf1;\nstatic char_u   *sortbuf2;\n\nstatic int sort_lc;       ///< sort using locale\nstatic int sort_ic;       ///< ignore case\nstatic int sort_nr;       ///< sort on number\nstatic int sort_rx;       ///< sort on regex instead of skipping it\nstatic int sort_flt;      ///< sort on floating number\n\nstatic int sort_abort;    ///< flag to indicate if sorting has been interrupted\n\n/// Struct to store info to be sorted.\ntypedef struct {\n  linenr_T lnum;          ///< line number\n  union {\n    struct {\n      varnumber_T start_col_nr;  ///< starting column number\n      varnumber_T end_col_nr;    ///< ending column number\n    } line;\n    struct {\n      varnumber_T value;         ///< value if sorting by integer\n      bool is_number;            ///< true when line contains a number\n    } num;\n    float_T value_flt;    ///< value if sorting by float\n  } st_u;\n} sorti_T;\n\nstatic int string_compare(const void *s1, const void *s2) FUNC_ATTR_NONNULL_ALL\n{\n  if (sort_lc) {\n    return strcoll((char *)s1, (char *)s2);\n  }\n  return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);\n}\n\nstatic int sort_compare(const void *s1, const void *s2)\n{\n  sorti_T l1 = *(sorti_T *)s1;\n  sorti_T l2 = *(sorti_T *)s2;\n  int result = 0;\n\n  /* If the user interrupts, there's no way to stop qsort() immediately, but\n   * if we return 0 every time, qsort will assume it's done sorting and\n   * exit. */\n  if (sort_abort)\n    return 0;\n  fast_breakcheck();\n  if (got_int)\n    sort_abort = TRUE;\n\n  // When sorting numbers \"start_col_nr\" is the number, not the column\n  // number.\n  if (sort_nr) {\n    if (l1.st_u.num.is_number != l2.st_u.num.is_number) {\n      result = l1.st_u.num.is_number - l2.st_u.num.is_number;\n    } else {\n      result = l1.st_u.num.value == l2.st_u.num.value\n        ? 0\n        : l1.st_u.num.value > l2.st_u.num.value\n          ? 1\n          : -1;\n    }\n  } else if (sort_flt) {\n    result = l1.st_u.value_flt == l2.st_u.value_flt\n             ? 0 : l1.st_u.value_flt > l2.st_u.value_flt\n             ? 1 : -1;\n  } else {\n    // We need to copy one line into \"sortbuf1\", because there is no\n    // guarantee that the first pointer becomes invalid when obtaining the\n    // second one.\n    memcpy(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,\n           l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);\n    sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = NUL;\n    memcpy(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,\n           l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);\n    sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = NUL;\n\n    result = string_compare(sortbuf1, sortbuf2);\n  }\n\n  /* If two lines have the same value, preserve the original line order. */\n  if (result == 0)\n    return (int)(l1.lnum - l2.lnum);\n  return result;\n}\n\n// \":sort\".\nvoid ex_sort(exarg_T *eap)\n{\n  regmatch_T regmatch;\n  int len;\n  linenr_T lnum;\n  long maxlen = 0;\n  size_t count = (size_t)(eap->line2 - eap->line1 + 1);\n  size_t i;\n  char_u      *p;\n  char_u      *s;\n  char_u      *s2;\n  char_u c;                             // temporary character storage\n  bool unique = false;\n  long deleted;\n  colnr_T start_col;\n  colnr_T end_col;\n  int sort_what = 0;\n\n  // Sorting one line is really quick!\n  if (count <= 1) {\n    return;\n  }\n\n  if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL) {\n    return;\n  }\n  sortbuf1 = NULL;\n  sortbuf2 = NULL;\n  regmatch.regprog = NULL;\n  sorti_T *nrs = xmalloc(count * sizeof(sorti_T));\n\n  sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = sort_flt = 0;\n  size_t format_found = 0;\n  bool change_occurred = false;   // Buffer contents changed.\n\n  for (p = eap->arg; *p != NUL; ++p) {\n    if (ascii_iswhite(*p)) {\n    } else if (*p == 'i') {\n      sort_ic = true;\n    } else if (*p == 'l') {\n      sort_lc = true;\n    } else if (*p == 'r') {\n      sort_rx = true;\n    } else if (*p == 'n') {\n      sort_nr = 1;\n      format_found++;\n    } else if (*p == 'f') {\n      sort_flt = 1;\n      format_found++;\n    } else if (*p == 'b') {\n      sort_what = STR2NR_BIN + STR2NR_FORCE;\n      format_found++;\n    } else if (*p == 'o') {\n      sort_what = STR2NR_OCT + STR2NR_FORCE;\n      format_found++;\n    } else if (*p == 'x') {\n      sort_what = STR2NR_HEX + STR2NR_FORCE;\n      format_found++;\n    } else if (*p == 'u') {\n      unique = true;\n    } else if (*p == '\"') {\n      // comment start\n      break;\n    } else if (check_nextcmd(p) != NULL) {\n      eap->nextcmd = check_nextcmd(p);\n      break;\n    } else if (!ASCII_ISALPHA(*p) && regmatch.regprog == NULL) {\n      s = skip_regexp(p + 1, *p, true, NULL);\n      if (*s != *p) {\n        EMSG(_(e_invalpat));\n        goto sortend;\n      }\n      *s = NUL;\n      // Use last search pattern if sort pattern is empty.\n      if (s == p + 1) {\n        if (last_search_pat() == NULL) {\n          EMSG(_(e_noprevre));\n          goto sortend;\n        }\n        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n      } else {\n        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);\n      }\n      if (regmatch.regprog == NULL) {\n        goto sortend;\n      }\n      p = s;                    // continue after the regexp\n      regmatch.rm_ic = p_ic;\n    } else {\n      EMSG2(_(e_invarg2), p);\n      goto sortend;\n    }\n  }\n\n  // Can only have one of 'n', 'b', 'o' and 'x'.\n  if (format_found > 1) {\n    EMSG(_(e_invarg));\n    goto sortend;\n  }\n\n  // From here on \"sort_nr\" is used as a flag for any integer number\n  // sorting.\n  sort_nr += sort_what;\n\n  // Make an array with all line numbers.  This avoids having to copy all\n  // the lines into allocated memory.\n  // When sorting on strings \"start_col_nr\" is the offset in the line, for\n  // numbers sorting it's the number to sort on.  This means the pattern\n  // matching and number conversion only has to be done once per line.\n  // Also get the longest line length for allocating \"sortbuf\".\n  for (lnum = eap->line1; lnum <= eap->line2; ++lnum) {\n    s = ml_get(lnum);\n    len = (int)STRLEN(s);\n    if (maxlen < len) {\n      maxlen = len;\n    }\n\n    start_col = 0;\n    end_col = len;\n    if (regmatch.regprog != NULL && vim_regexec(&regmatch, s, 0)) {\n      if (sort_rx) {\n        start_col = (colnr_T)(regmatch.startp[0] - s);\n        end_col = (colnr_T)(regmatch.endp[0] - s);\n      } else {\n        start_col = (colnr_T)(regmatch.endp[0] - s);\n      }\n    } else if (regmatch.regprog != NULL) {\n      end_col = 0;\n    }\n\n    if (sort_nr || sort_flt) {\n      // Make sure vim_str2nr doesn't read any digits past the end\n      // of the match, by temporarily terminating the string there\n      s2 = s + end_col;\n      c = *s2;\n      *s2 = NUL;\n      // Sorting on number: Store the number itself.\n      p = s + start_col;\n      if (sort_nr) {\n        if (sort_what & STR2NR_HEX) {\n          s = skiptohex(p);\n        } else if (sort_what & STR2NR_BIN) {\n          s = (char_u *)skiptobin((char *)p);\n        } else {\n          s = skiptodigit(p);\n        }\n        if (s > p && s[-1] == '-') {\n          s--;  // include preceding negative sign\n        }\n        if (*s == NUL) {\n          // line without number should sort before any number\n          nrs[lnum - eap->line1].st_u.num.is_number = false;\n          nrs[lnum - eap->line1].st_u.num.value = 0;\n        } else {\n          nrs[lnum - eap->line1].st_u.num.is_number = true;\n          vim_str2nr(s, NULL, NULL, sort_what,\n                     &nrs[lnum - eap->line1].st_u.num.value, NULL, 0);\n        }\n      } else {\n        s = skipwhite(p);\n        if (*s == '+') {\n          s = skipwhite(s + 1);\n        }\n\n        if (*s == NUL) {\n          // empty line should sort before any number\n          nrs[lnum - eap->line1].st_u.value_flt = -DBL_MAX;\n        } else {\n          nrs[lnum - eap->line1].st_u.value_flt = strtod((char *)s, NULL);\n        }\n      }\n      *s2 = c;\n    } else {\n      // Store the column to sort at.\n      nrs[lnum - eap->line1].st_u.line.start_col_nr = start_col;\n      nrs[lnum - eap->line1].st_u.line.end_col_nr = end_col;\n    }\n\n    nrs[lnum - eap->line1].lnum = lnum;\n\n    if (regmatch.regprog != NULL)\n      fast_breakcheck();\n    if (got_int)\n      goto sortend;\n  }\n\n  // Allocate a buffer that can hold the longest line.\n  sortbuf1 = xmalloc(maxlen + 1);\n  sortbuf2 = xmalloc(maxlen + 1);\n\n  // Sort the array of line numbers.  Note: can't be interrupted!\n  qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);\n\n  if (sort_abort)\n    goto sortend;\n\n  bcount_t old_count = 0, new_count = 0;\n\n  // Insert the lines in the sorted order below the last one.\n  lnum = eap->line2;\n  for (i = 0; i < count; i++) {\n    const linenr_T get_lnum = nrs[eap->forceit ? count - i - 1 : i].lnum;\n\n    // If the original line number of the line being placed is not the same\n    // as \"lnum\" (accounting for offset), we know that the buffer changed.\n    if (get_lnum + ((linenr_T)count - 1) != lnum) {\n      change_occurred = true;\n    }\n\n    s = ml_get(get_lnum);\n    size_t bytelen = STRLEN(s) + 1;  // include EOL in bytelen\n    old_count += bytelen;\n    if (!unique || i == 0 || string_compare(s, sortbuf1) != 0) {\n      // Copy the line into a buffer, it may become invalid in\n      // ml_append(). And it's needed for \"unique\".\n      STRCPY(sortbuf1, s);\n      if (ml_append(lnum++, sortbuf1, (colnr_T)0, false) == FAIL) {\n        break;\n      }\n      new_count += bytelen;\n    }\n    fast_breakcheck();\n    if (got_int)\n      goto sortend;\n  }\n\n  // delete the original lines if appending worked\n  if (i == count) {\n    for (i = 0; i < count; ++i) {\n      ml_delete(eap->line1, false);\n    }\n  } else {\n    count = 0;\n  }\n\n  // Adjust marks for deleted (or added) lines and prepare for displaying.\n  deleted = (long)(count - (lnum - eap->line2));\n  if (deleted > 0) {\n    mark_adjust(eap->line2 - deleted, eap->line2, (long)MAXLNUM, -deleted,\n                kExtmarkNOOP);\n    msgmore(-deleted);\n  } else if (deleted < 0) {\n    mark_adjust(eap->line2, MAXLNUM, -deleted, 0L, kExtmarkNOOP);\n  }\n\n  extmark_splice(curbuf, eap->line1-1, 0,\n                 count, 0, old_count,\n                 lnum - eap->line2, 0, new_count, kExtmarkUndo);\n\n  if (change_occurred || deleted != 0) {\n    changed_lines(eap->line1, 0, eap->line2 + 1, -deleted, true);\n  }\n\n  curwin->w_cursor.lnum = eap->line1;\n  beginline(BL_WHITE | BL_FIX);\n\nsortend:\n  xfree(nrs);\n  xfree(sortbuf1);\n  xfree(sortbuf2);\n  vim_regfree(regmatch.regprog);\n  if (got_int) {\n    EMSG(_(e_interr));\n  }\n}\n\n/*\n * \":retab\".\n */\nvoid ex_retab(exarg_T *eap)\n{\n  linenr_T lnum;\n  bool got_tab = false;\n  long num_spaces = 0;\n  long num_tabs;\n  long len;\n  long col;\n  long vcol;\n  long start_col = 0;                   // For start of white-space string\n  long start_vcol = 0;                  // For start of white-space string\n  long old_len;\n  char_u      *ptr;\n  char_u      *new_line = (char_u *)1;  // init to non-NULL\n  int did_undo;                         // called u_save for current line\n  long *new_vts_array = NULL;\n  char_u *new_ts_str;  // string value of tab argument\n\n  int save_list;\n  linenr_T first_line = 0;              /* first changed line */\n  linenr_T last_line = 0;               /* last changed line */\n\n  save_list = curwin->w_p_list;\n  curwin->w_p_list = 0;             /* don't want list mode here */\n\n  new_ts_str = eap->arg;\n  if (!tabstop_set(eap->arg, &new_vts_array)) {\n    return;\n  }\n  while (ascii_isdigit(*(eap->arg)) || *(eap->arg) == ',') {\n    (eap->arg)++;\n  }\n\n  // This ensures that either new_vts_array and new_ts_str are freshly\n  // allocated, or new_vts_array points to an existing array and new_ts_str\n  // is null.\n  if (new_vts_array == NULL) {\n    new_vts_array = curbuf->b_p_vts_array;\n    new_ts_str = NULL;\n  } else {\n    new_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n  }\n  for (lnum = eap->line1; !got_int && lnum <= eap->line2; lnum++) {\n    ptr = ml_get(lnum);\n    col = 0;\n    vcol = 0;\n    did_undo = FALSE;\n    for (;; ) {\n      if (ascii_iswhite(ptr[col])) {\n        if (!got_tab && num_spaces == 0) {\n          /* First consecutive white-space */\n          start_vcol = vcol;\n          start_col = col;\n        }\n        if (ptr[col] == ' ') {\n          num_spaces++;\n        } else {\n          got_tab = true;\n        }\n      } else {\n        if (got_tab || (eap->forceit && num_spaces > 1)) {\n          /* Retabulate this string of white-space */\n\n          /* len is virtual length of white string */\n          len = num_spaces = vcol - start_vcol;\n          num_tabs = 0;\n          if (!curbuf->b_p_et) {\n            int t, s;\n\n            tabstop_fromto(start_vcol, vcol,\n                           curbuf->b_p_ts, new_vts_array, &t, &s);\n            num_tabs = t;\n            num_spaces = s;\n          }\n          if (curbuf->b_p_et || got_tab\n              || (num_spaces + num_tabs < len)) {\n            if (did_undo == false) {\n              did_undo = true;\n              if (u_save((linenr_T)(lnum - 1),\n                         (linenr_T)(lnum + 1)) == FAIL) {\n                new_line = NULL;  // flag out-of-memory\n                break;\n              }\n            }\n\n            /* len is actual number of white characters used */\n            len = num_spaces + num_tabs;\n            old_len = (long)STRLEN(ptr);\n            long new_len = old_len - col + start_col + len + 1;\n            new_line = xmalloc(new_len);\n\n            if (start_col > 0)\n              memmove(new_line, ptr, (size_t)start_col);\n            memmove(new_line + start_col + len,\n                ptr + col, (size_t)(old_len - col + 1));\n            ptr = new_line + start_col;\n            for (col = 0; col < len; col++) {\n              ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n            }\n            if (ml_replace(lnum, new_line, false) == OK) {\n              // \"new_line\" may have been copied\n              new_line = curbuf->b_ml.ml_line_ptr;\n              extmark_splice_cols(curbuf, lnum - 1, 0, (colnr_T)old_len,\n                                  (colnr_T)new_len - 1, kExtmarkUndo);\n            }\n            if (first_line == 0) {\n              first_line = lnum;\n            }\n            last_line = lnum;\n            ptr = new_line;\n            col = start_col + len;\n          }\n        }\n        got_tab = false;\n        num_spaces = 0;\n      }\n      if (ptr[col] == NUL)\n        break;\n      vcol += win_chartabsize(curwin, ptr + col, (colnr_T)vcol);\n      col += utfc_ptr2len(ptr + col);\n    }\n    if (new_line == NULL)                   /* out of memory */\n      break;\n    line_breakcheck();\n  }\n  if (got_int)\n    EMSG(_(e_interr));\n\n  // If a single value was given then it can be considered equal to\n  // either the value of 'tabstop' or the value of 'vartabstop'.\n  if (tabstop_count(curbuf->b_p_vts_array) == 0\n      && tabstop_count(new_vts_array) == 1\n      && curbuf->b_p_ts == tabstop_first(new_vts_array)) {\n    // not changed\n  } else if (tabstop_count(curbuf->b_p_vts_array) > 0\n             && tabstop_eq(curbuf->b_p_vts_array, new_vts_array)) {\n    // not changed\n  } else {\n    redraw_curbuf_later(NOT_VALID);\n  }\n  if (first_line != 0) {\n    changed_lines(first_line, 0, last_line + 1, 0L, true);\n  }\n\n  curwin->w_p_list = save_list;         /* restore 'list' */\n\n  if (new_ts_str != NULL) {  // set the new tabstop\n    // If 'vartabstop' is in use or if the value given to retab has more\n    // than one tabstop then update 'vartabstop'.\n    long *old_vts_ary = curbuf->b_p_vts_array;\n\n    if (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1) {\n      set_string_option_direct(\"vts\", -1, new_ts_str,\n                               OPT_FREE | OPT_LOCAL, 0);\n      curbuf->b_p_vts_array = new_vts_array;\n      xfree(old_vts_ary);\n    } else {\n      // 'vartabstop' wasn't in use and a single value was given to\n      // retab then update 'tabstop'.\n      curbuf->b_p_ts = tabstop_first(new_vts_array);\n      xfree(new_vts_array);\n    }\n    xfree(new_ts_str);\n  }\n  coladvance(curwin->w_curswant);\n\n  u_clearline();\n}\n\n/*\n * :move command - move lines line1-line2 to line dest\n *\n * return FAIL for failure, OK otherwise\n */\nint do_move(linenr_T line1, linenr_T line2, linenr_T dest)\n{\n  char_u      *str;\n  linenr_T l;\n  linenr_T extra;      // Num lines added before line1\n  linenr_T num_lines;  // Num lines moved\n  linenr_T last_line;  // Last line in file after adding new text\n\n  if (dest >= line1 && dest < line2) {\n    EMSG(_(\"E134: Cannot move a range of lines into itself\"));\n    return FAIL;\n  }\n\n  // Do nothing if we are not actually moving any lines.  This will prevent\n  // the 'modified' flag from being set without cause.\n  if (dest == line1 - 1 || dest == line2) {\n    // Move the cursor as if lines were moved (see below) to be backwards\n    // compatible.\n    if (dest >= line1) {\n      curwin->w_cursor.lnum = dest;\n    } else {\n      curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n    }\n    return OK;\n  }\n\n  bcount_t start_byte = ml_find_line_or_offset(curbuf, line1, NULL, true);\n  bcount_t end_byte = ml_find_line_or_offset(curbuf, line2+1, NULL, true);\n  bcount_t extent_byte = end_byte-start_byte;\n  bcount_t dest_byte = ml_find_line_or_offset(curbuf, dest+1, NULL, true);\n\n  num_lines = line2 - line1 + 1;\n\n  /*\n   * First we copy the old text to its new location -- webb\n   * Also copy the flag that \":global\" command uses.\n   */\n  if (u_save(dest, dest + 1) == FAIL)\n    return FAIL;\n  for (extra = 0, l = line1; l <= line2; l++) {\n    str = vim_strsave(ml_get(l + extra));\n    ml_append(dest + l - line1, str, (colnr_T)0, false);\n    xfree(str);\n    if (dest < line1)\n      extra++;\n  }\n\n  /*\n   * Now we must be careful adjusting our marks so that we don't overlap our\n   * mark_adjust() calls.\n   *\n   * We adjust the marks within the old text so that they refer to the\n   * last lines of the file (temporarily), because we know no other marks\n   * will be set there since these line numbers did not exist until we added\n   * our new lines.\n   *\n   * Then we adjust the marks on lines between the old and new text positions\n   * (either forwards or backwards).\n   *\n   * And Finally we adjust the marks we put at the end of the file back to\n   * their final destination at the new text position -- webb\n   */\n  last_line = curbuf->b_ml.ml_line_count;\n  mark_adjust_nofold(line1, line2, last_line - line2, 0L, kExtmarkNOOP);\n  changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines, false);\n  int line_off = 0;\n  bcount_t byte_off = 0;\n  if (dest >= line2) {\n    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L, kExtmarkNOOP);\n    FOR_ALL_TAB_WINDOWS(tab, win) {\n      if (win->w_buffer == curbuf) {\n        foldMoveRange(win, &win->w_folds, line1, line2, dest);\n      }\n    }\n    curbuf->b_op_start.lnum = dest - num_lines + 1;\n    curbuf->b_op_end.lnum = dest;\n    line_off = -num_lines;\n    byte_off = -extent_byte;\n  } else {\n    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L, kExtmarkNOOP);\n    FOR_ALL_TAB_WINDOWS(tab, win) {\n      if (win->w_buffer == curbuf) {\n        foldMoveRange(win, &win->w_folds, dest + 1, line1 - 1, line2);\n      }\n    }\n    curbuf->b_op_start.lnum = dest + 1;\n    curbuf->b_op_end.lnum = dest + num_lines;\n  }\n  curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n  mark_adjust_nofold(last_line - num_lines + 1, last_line,\n                     -(last_line - dest - extra), 0L, kExtmarkNOOP);\n\n  changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra, false);\n\n  // send update regarding the new lines that were added\n  buf_updates_send_changes(curbuf, dest + 1, num_lines, 0, true);\n\n  /*\n   * Now we delete the original text -- webb\n   */\n  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)\n    return FAIL;\n\n  for (l = line1; l <= line2; l++) {\n    ml_delete(line1 + extra, true);\n  }\n  if (!global_busy && num_lines > p_report) {\n    if (num_lines == 1)\n      MSG(_(\"1 line moved\"));\n    else\n      smsg(_(\"%\" PRId64 \" lines moved\"), (int64_t)num_lines);\n  }\n\n  extmark_move_region(curbuf, line1-1, 0, start_byte,\n                      line2-line1+1, 0, extent_byte,\n                      dest+line_off, 0, dest_byte+byte_off,\n                      kExtmarkUndo);\n\n  /*\n   * Leave the cursor on the last of the moved lines.\n   */\n  if (dest >= line1)\n    curwin->w_cursor.lnum = dest;\n  else\n    curwin->w_cursor.lnum = dest + (line2 - line1) + 1;\n\n  if (line1 < dest) {\n    dest += num_lines + 1;\n    last_line = curbuf->b_ml.ml_line_count;\n    if (dest > last_line + 1)\n      dest = last_line + 1;\n    changed_lines(line1, 0, dest, 0L, false);\n  } else {\n    changed_lines(dest + 1, 0, line1 + num_lines, 0L, false);\n  }\n\n  // send nvim_buf_lines_event regarding lines that were deleted\n  buf_updates_send_changes(curbuf, line1 + extra, 0, num_lines, true);\n\n  return OK;\n}\n\n/*\n * \":copy\"\n */\nvoid ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n  linenr_T count;\n  char_u      *p;\n\n  count = line2 - line1 + 1;\n  curbuf->b_op_start.lnum = n + 1;\n  curbuf->b_op_end.lnum = n + count;\n  curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\n  /*\n   * there are three situations:\n   * 1. destination is above line1\n   * 2. destination is between line1 and line2\n   * 3. destination is below line2\n   *\n   * n = destination (when starting)\n   * curwin->w_cursor.lnum = destination (while copying)\n   * line1 = start of source (while copying)\n   * line2 = end of source (while copying)\n   */\n  if (u_save(n, n + 1) == FAIL)\n    return;\n\n  curwin->w_cursor.lnum = n;\n  while (line1 <= line2) {\n    /* need to use vim_strsave() because the line will be unlocked within\n     * ml_append() */\n    p = vim_strsave(ml_get(line1));\n    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, false);\n    xfree(p);\n\n    /* situation 2: skip already copied lines */\n    if (line1 == n)\n      line1 = curwin->w_cursor.lnum;\n    ++line1;\n    if (curwin->w_cursor.lnum < line1)\n      ++line1;\n    if (curwin->w_cursor.lnum < line2)\n      ++line2;\n    ++curwin->w_cursor.lnum;\n  }\n\n  appended_lines_mark(n, count);\n\n  msgmore((long)count);\n}\n\nstatic char_u   *prevcmd = NULL;        /* the previous command */\n\n#if defined(EXITFREE)\nvoid free_prev_shellcmd(void)\n{\n  xfree(prevcmd);\n}\n\n#endif\n\n/*\n * Handle the \":!cmd\" command.\tAlso for \":r !cmd\" and \":w !cmd\"\n * Bangs in the argument are replaced with the previously entered command.\n * Remember the argument.\n */\nvoid do_bang(int addr_count, exarg_T *eap, bool forceit,\n             bool do_in, bool do_out)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *arg = eap->arg;             // command\n  linenr_T line1 = eap->line1;        // start of range\n  linenr_T line2 = eap->line2;        // end of range\n  char_u *newcmd = NULL;              // the new command\n  bool free_newcmd = false;           // need to free() newcmd\n  char_u              *t;\n  char_u              *p;\n  char_u              *trailarg;\n  int len;\n  int scroll_save = msg_scroll;\n\n  //\n  // Disallow shell commands from .exrc and .vimrc in current directory for\n  // security reasons.\n  //\n  if (check_secure()) {\n    return;\n  }\n\n  if (addr_count == 0) {                /* :! */\n    msg_scroll = FALSE;             /* don't scroll here */\n    autowrite_all();\n    msg_scroll = scroll_save;\n  }\n\n  /*\n   * Try to find an embedded bang, like in :!<cmd> ! [args]\n   * (:!! is indicated by the 'forceit' variable)\n   */\n  bool ins_prevcmd = forceit;\n  trailarg = arg;\n  do {\n    len = (int)STRLEN(trailarg) + 1;\n    if (newcmd != NULL)\n      len += (int)STRLEN(newcmd);\n    if (ins_prevcmd) {\n      if (prevcmd == NULL) {\n        EMSG(_(e_noprev));\n        xfree(newcmd);\n        return;\n      }\n      len += (int)STRLEN(prevcmd);\n    }\n    t = xmalloc(len);\n    *t = NUL;\n    if (newcmd != NULL)\n      STRCAT(t, newcmd);\n    if (ins_prevcmd)\n      STRCAT(t, prevcmd);\n    p = t + STRLEN(t);\n    STRCAT(t, trailarg);\n    xfree(newcmd);\n    newcmd = t;\n\n    /*\n     * Scan the rest of the argument for '!', which is replaced by the\n     * previous command.  \"\\!\" is replaced by \"!\" (this is vi compatible).\n     */\n    trailarg = NULL;\n    while (*p) {\n      if (*p == '!') {\n        if (p > newcmd && p[-1] == '\\\\')\n          STRMOVE(p - 1, p);\n        else {\n          trailarg = p;\n          *trailarg++ = NUL;\n          ins_prevcmd = true;\n          break;\n        }\n      }\n      ++p;\n    }\n  } while (trailarg != NULL);\n\n  xfree(prevcmd);\n  prevcmd = newcmd;\n\n  if (bangredo) { /* put cmd in redo buffer for ! command */\n    /* If % or # appears in the command, it must have been escaped.\n     * Reescape them, so that redoing them does not substitute them by the\n     * buffername. */\n    char_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)\"%#\");\n\n    AppendToRedobuffLit(cmd, -1);\n    xfree(cmd);\n    AppendToRedobuff(\"\\n\");\n    bangredo = false;\n  }\n  /*\n   * Add quotes around the command, for shells that need them.\n   */\n  if (*p_shq != NUL) {\n    newcmd = xmalloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);\n    STRCPY(newcmd, p_shq);\n    STRCAT(newcmd, prevcmd);\n    STRCAT(newcmd, p_shq);\n    free_newcmd = true;\n  }\n  if (addr_count == 0) {                /* :! */\n    /* echo the command */\n    msg_start();\n    msg_putchar(':');\n    msg_putchar('!');\n    msg_outtrans(newcmd);\n    msg_clr_eos();\n    ui_cursor_goto(msg_row, msg_col);\n\n    do_shell(newcmd, 0);\n  } else {                            /* :range! */\n    /* Careful: This may recursively call do_bang() again! (because of\n     * autocommands) */\n    do_filter(line1, line2, eap, newcmd, do_in, do_out);\n    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);\n  }\n  if (free_newcmd)\n    xfree(newcmd);\n}\n\n// do_filter: filter lines through a command given by the user\n//\n// We mostly use temp files and the call_shell() routine here. This would\n// normally be done using pipes on a Unix system, but this is more portable\n// to non-Unix systems. The call_shell() routine needs to be able\n// to deal with redirection somehow, and should handle things like looking\n// at the PATH env. variable, and adding reasonable extensions to the\n// command name given by the user. All reasonable versions of call_shell()\n// do this.\n// Alternatively, if on Unix and redirecting input or output, but not both,\n// and the 'shelltemp' option isn't set, use pipes.\n// We use input redirection if do_in is true.\n// We use output redirection if do_out is true.\nstatic void do_filter(\n    linenr_T line1,\n    linenr_T line2,\n    exarg_T *eap,               /* for forced 'ff' and 'fenc' */\n    char_u *cmd,\n    bool do_in,\n    bool do_out)\n{\n  char_u      *itmp = NULL;\n  char_u      *otmp = NULL;\n  linenr_T linecount;\n  linenr_T read_linecount;\n  pos_T cursor_save;\n  char_u      *cmd_buf;\n  buf_T       *old_curbuf = curbuf;\n  int shell_flags = 0;\n  const int stmp = p_stmp;\n\n  if (*cmd == NUL)          /* no filter command */\n    return;\n\n\n  cursor_save = curwin->w_cursor;\n  linecount = line2 - line1 + 1;\n  curwin->w_cursor.lnum = line1;\n  curwin->w_cursor.col = 0;\n  changed_line_abv_curs();\n  invalidate_botline();\n\n  /*\n   * When using temp files:\n   * 1. * Form temp file names\n   * 2. * Write the lines to a temp file\n   * 3.   Run the filter command on the temp file\n   * 4. * Read the output of the command into the buffer\n   * 5. * Delete the original lines to be filtered\n   * 6. * Remove the temp files\n   *\n   * When writing the input with a pipe or when catching the output with a\n   * pipe only need to do 3.\n   */\n\n  if (do_out)\n    shell_flags |= kShellOptDoOut;\n\n  if (!do_in && do_out && !stmp) {\n    // Use a pipe to fetch stdout of the command, do not use a temp file.\n    shell_flags |= kShellOptRead;\n    curwin->w_cursor.lnum = line2;\n  } else if (do_in && !do_out && !stmp) {\n    // Use a pipe to write stdin of the command, do not use a temp file.\n    shell_flags |= kShellOptWrite;\n    curbuf->b_op_start.lnum = line1;\n    curbuf->b_op_end.lnum = line2;\n  } else if (do_in && do_out && !stmp) {\n    // Use a pipe to write stdin and fetch stdout of the command, do not\n    // use a temp file.\n    shell_flags |= kShellOptRead | kShellOptWrite;\n    curbuf->b_op_start.lnum = line1;\n    curbuf->b_op_end.lnum = line2;\n    curwin->w_cursor.lnum = line2;\n  } else if ((do_in && (itmp = vim_tempname()) == NULL)\n      || (do_out && (otmp = vim_tempname()) == NULL)) {\n    EMSG(_(e_notmp));\n    goto filterend;\n  }\n\n  /*\n   * The writing and reading of temp files will not be shown.\n   * Vi also doesn't do this and the messages are not very informative.\n   */\n  ++no_wait_return;             /* don't call wait_return() while busy */\n  if (itmp != NULL && buf_write(curbuf, itmp, NULL, line1, line2, eap,\n                                false, false, false, true) == FAIL) {\n    msg_putchar('\\n');  // Keep message from buf_write().\n    no_wait_return--;\n    if (!aborting()) {\n      EMSG2(_(\"E482: Can't create file %s\"), itmp);  // Will call wait_return.\n    }\n    goto filterend;\n  }\n  if (curbuf != old_curbuf)\n    goto filterend;\n\n  if (!do_out)\n    msg_putchar('\\n');\n\n  /* Create the shell command in allocated memory. */\n  cmd_buf = make_filter_cmd(cmd, itmp, otmp);\n  ui_cursor_goto(Rows - 1, 0);\n\n  if (do_out) {\n    if (u_save((linenr_T)(line2), (linenr_T)(line2 + 1)) == FAIL) {\n      xfree(cmd_buf);\n      goto error;\n    }\n    redraw_curbuf_later(VALID);\n  }\n  read_linecount = curbuf->b_ml.ml_line_count;\n\n  // Pass on the kShellOptDoOut flag when the output is being redirected.\n  call_shell(cmd_buf, kShellOptFilter | shell_flags, NULL);\n  xfree(cmd_buf);\n\n  did_check_timestamps = FALSE;\n  need_check_timestamps = TRUE;\n\n  /* When interrupting the shell command, it may still have produced some\n   * useful output.  Reset got_int here, so that readfile() won't cancel\n   * reading. */\n  os_breakcheck();\n  got_int = FALSE;\n\n  if (do_out) {\n    if (otmp != NULL) {\n      if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n                   READ_FILTER) != OK) {\n        if (!aborting()) {\n          msg_putchar('\\n');\n          EMSG2(_(e_notread), otmp);\n        }\n        goto error;\n      }\n      if (curbuf != old_curbuf)\n        goto filterend;\n    }\n\n    read_linecount = curbuf->b_ml.ml_line_count - read_linecount;\n\n    if (shell_flags & kShellOptRead) {\n      curbuf->b_op_start.lnum = line2 + 1;\n      curbuf->b_op_end.lnum = curwin->w_cursor.lnum;\n      appended_lines_mark(line2, read_linecount);\n    }\n\n    if (do_in) {\n      if (cmdmod.keepmarks || vim_strchr(p_cpo, CPO_REMMARK) == NULL) {\n        // TODO(bfredl): Currently not active for extmarks. What would we\n        // do if columns don't match, assume added/deleted bytes at the\n        // end of each line?\n        if (read_linecount >= linecount) {\n          // move all marks from old lines to new lines\n          mark_adjust(line1, line2, linecount, 0L, kExtmarkNOOP);\n        } else {\n          // move marks from old lines to new lines, delete marks\n          // that are in deleted lines\n          mark_adjust(line1, line1 + read_linecount - 1, linecount, 0L,\n                      kExtmarkNOOP);\n          mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L,\n                      kExtmarkNOOP);\n        }\n      }\n\n      /*\n       * Put cursor on first filtered line for \":range!cmd\".\n       * Adjust '[ and '] (set by buf_write()).\n       */\n      curwin->w_cursor.lnum = line1;\n      del_lines(linecount, true);\n      curbuf->b_op_start.lnum -= linecount;             // adjust '[\n      curbuf->b_op_end.lnum -= linecount;               // adjust ']\n      write_lnum_adjust(-linecount);                    // adjust last line\n                                                        // for next write\n      foldUpdate(curwin, curbuf->b_op_start.lnum, curbuf->b_op_end.lnum);\n    } else {\n      /*\n       * Put cursor on last new line for \":r !cmd\".\n       */\n      linecount = curbuf->b_op_end.lnum - curbuf->b_op_start.lnum + 1;\n      curwin->w_cursor.lnum = curbuf->b_op_end.lnum;\n    }\n\n    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */\n    --no_wait_return;\n\n    if (linecount > p_report) {\n      if (do_in) {\n        vim_snprintf((char *)msg_buf, sizeof(msg_buf),\n            _(\"%\" PRId64 \" lines filtered\"), (int64_t)linecount);\n        if (msg(msg_buf) && !msg_scroll)\n          /* save message to display it after redraw */\n          set_keep_msg(msg_buf, 0);\n      } else\n        msgmore((long)linecount);\n    }\n  } else {\nerror:\n    /* put cursor back in same position for \":w !cmd\" */\n    curwin->w_cursor = cursor_save;\n    --no_wait_return;\n    wait_return(FALSE);\n  }\n\nfilterend:\n\n  if (curbuf != old_curbuf) {\n    --no_wait_return;\n    EMSG(_(\"E135: *Filter* Autocommands must not change current buffer\"));\n  }\n  if (itmp != NULL)\n    os_remove((char *)itmp);\n  if (otmp != NULL)\n    os_remove((char *)otmp);\n  xfree(itmp);\n  xfree(otmp);\n}\n\n// Call a shell to execute a command.\n// When \"cmd\" is NULL start an interactive shell.\nvoid\ndo_shell(\n    char_u *cmd,\n    int flags             // may be SHELL_DOOUT when output is redirected\n)\n{\n  // Disallow shell commands from .exrc and .vimrc in current directory for\n  // security reasons.\n  if (check_secure()) {\n    msg_end();\n    return;\n  }\n\n\n  /*\n   * For autocommands we want to get the output on the current screen, to\n   * avoid having to type return below.\n   */\n  msg_putchar('\\r');                    // put cursor at start of line\n  msg_putchar('\\n');                    // may shift screen one line up\n\n  // warning message before calling the shell\n  if (p_warn\n      && !autocmd_busy\n      && msg_silent == 0) {\n    FOR_ALL_BUFFERS(buf) {\n      if (bufIsChanged(buf)) {\n        MSG_PUTS(_(\"[No write since last change]\\n\"));\n        break;\n      }\n    }\n  }\n\n  // This ui_cursor_goto is required for when the '\\n' resulted in a \"delete line\n  // 1\" command to the terminal.\n  ui_cursor_goto(msg_row, msg_col);\n  (void)call_shell(cmd, flags, NULL);\n  msg_didout = true;\n  did_check_timestamps = false;\n  need_check_timestamps = true;\n\n  // put the message cursor at the end of the screen, avoids wait_return()\n  // to overwrite the text that the external command showed\n  msg_row = Rows - 1;\n  msg_col = 0;\n\n  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);\n}\n\n#if !defined(UNIX)\nstatic char *find_pipe(const char *cmd)\n{\n  bool inquote = false;\n\n  for (const char *p = cmd; *p != NUL; p++) {\n    if (!inquote && *p == '|') {\n      return p;\n    }\n    if (*p == '\"') {\n      inquote = !inquote;\n    } else if (rem_backslash((const char_u *)p)) {\n      p++;\n    }\n  }\n  return NULL;\n}\n#endif\n\n/// Create a shell command from a command string, input redirection file and\n/// output redirection file.\n///\n/// @param cmd  Command to execute.\n/// @param itmp NULL or the input file.\n/// @param otmp NULL or the output file.\n/// @returns an allocated string with the shell command.\nchar_u *make_filter_cmd(char_u *cmd, char_u *itmp, char_u *otmp)\n{\n  bool is_fish_shell =\n#if defined(UNIX)\n    STRNCMP(invocation_path_tail(p_sh, NULL), \"fish\", 4) == 0;\n#else\n    false;\n#endif\n\n  size_t len = STRLEN(cmd) + 1;  // At least enough space for cmd + NULL.\n\n  len += is_fish_shell ?  sizeof(\"begin; \"\"; end\") - 1\n                       :  sizeof(\"(\"\")\") - 1;\n\n  if (itmp != NULL) {\n    len += STRLEN(itmp) + sizeof(\" { \"\" < \"\" } \") - 1;\n  }\n  if (otmp != NULL) {\n    len += STRLEN(otmp) + STRLEN(p_srr) + 2;  // two extra spaces (\"  \"),\n  }\n  char *const buf = xmalloc(len);\n\n#if defined(UNIX)\n  // Put delimiters around the command (for concatenated commands) when\n  // redirecting input and/or output.\n  if (itmp != NULL || otmp != NULL) {\n    char *fmt = is_fish_shell ? \"begin; %s; end\"\n                              :       \"(%s)\";\n    vim_snprintf(buf, len, fmt, (char *)cmd);\n  } else {\n    xstrlcpy(buf, (char *)cmd, len);\n  }\n\n  if (itmp != NULL) {\n    xstrlcat(buf, \" < \", len - 1);\n    xstrlcat(buf, (const char *)itmp, len - 1);\n  }\n#else\n  // For shells that don't understand braces around commands, at least allow\n  // the use of commands in a pipe.\n  xstrlcpy(buf, (char *)cmd, len);\n  if (itmp != NULL) {\n    // If there is a pipe, we have to put the '<' in front of it.\n    // Don't do this when 'shellquote' is not empty, otherwise the\n    // redirection would be inside the quotes.\n    if (*p_shq == NUL) {\n      char *const p = find_pipe(buf);\n      if (p != NULL) {\n        *p = NUL;\n      }\n    }\n    xstrlcat(buf, \" < \", len);\n    xstrlcat(buf, (const char *)itmp, len);\n    if (*p_shq == NUL) {\n      const char *const p = find_pipe((const char *)cmd);\n      if (p != NULL) {\n        xstrlcat(buf, \" \", len - 1);  // Insert a space before the '|' for DOS\n        xstrlcat(buf, p, len - 1);\n      }\n    }\n  }\n#endif\n  if (otmp != NULL) {\n    append_redir(buf, len, (char *) p_srr, (char *) otmp);\n  }\n  return (char_u *) buf;\n}\n\n/// Append output redirection for the given file to the end of the buffer\n///\n/// @param[out]  buf  Buffer to append to.\n/// @param[in]  buflen  Buffer length.\n/// @param[in]  opt  Separator or format string to append: will append\n///                  `printf(' ' . opt, fname)` if `%s` is found in `opt` or\n///                  a space, opt, a space and then fname if `%s` is not found\n///                  there.\n/// @param[in]  fname  File name to append.\nvoid append_redir(char *const buf, const size_t buflen,\n                  const char *const opt, const char *const fname)\n{\n  char *const end = buf + strlen(buf);\n  // find \"%s\"\n  const char *p = opt;\n  for (; (p = strchr(p, '%')) != NULL; p++) {\n    if (p[1] == 's') {  // found %s\n      break;\n    } else if (p[1] == '%') {  // skip %%\n      p++;\n    }\n  }\n  if (p != NULL) {\n    *end = ' ';  // not really needed? Not with sh, ksh or bash\n    vim_snprintf(end + 1, (size_t) (buflen - (end + 1 - buf)), opt, fname);\n  } else {\n    vim_snprintf(end, (size_t) (buflen - (end - buf)), \" %s %s\", opt, fname);\n  }\n}\n\nvoid print_line_no_prefix(linenr_T lnum, int use_number, int list)\n{\n  char numbuf[30];\n\n  if (curwin->w_p_nu || use_number) {\n    vim_snprintf(numbuf, sizeof(numbuf), \"%*\" PRIdLINENR \" \",\n                 number_width(curwin), lnum);\n    msg_puts_attr(numbuf, HL_ATTR(HLF_N));  // Highlight line nrs.\n  }\n  msg_prt_line(ml_get(lnum), list);\n}\n\n/*\n * Print a text line.  Also in silent mode (\"ex -s\").\n */\nvoid print_line(linenr_T lnum, int use_number, int list)\n{\n  int save_silent = silent_mode;\n\n  // apply :filter /pat/\n  if (message_filtered(ml_get(lnum))) {\n    return;\n  }\n\n  msg_start();\n  silent_mode = FALSE;\n  info_message = true;  // use mch_msg(), not mch_errmsg()\n  print_line_no_prefix(lnum, use_number, list);\n  if (save_silent) {\n    msg_putchar('\\n');\n    ui_flush();\n    silent_mode = save_silent;\n  }\n  info_message = false;\n}\n\nint rename_buffer(char_u *new_fname)\n{\n  char_u      *fname, *sfname, *xfname;\n  buf_T       *buf;\n\n  buf = curbuf;\n  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n  /* buffer changed, don't change name now */\n  if (buf != curbuf)\n    return FAIL;\n  if (aborting())           /* autocmds may abort script processing */\n    return FAIL;\n  /*\n   * The name of the current buffer will be changed.\n   * A new (unlisted) buffer entry needs to be made to hold the old file\n   * name, which will become the alternate file name.\n   * But don't set the alternate file name if the buffer didn't have a\n   * name.\n   */\n  fname = curbuf->b_ffname;\n  sfname = curbuf->b_sfname;\n  xfname = curbuf->b_fname;\n  curbuf->b_ffname = NULL;\n  curbuf->b_sfname = NULL;\n  if (setfname(curbuf, new_fname, NULL, true) == FAIL) {\n    curbuf->b_ffname = fname;\n    curbuf->b_sfname = sfname;\n    return FAIL;\n  }\n  curbuf->b_flags |= BF_NOTEDITED;\n  if (xfname != NULL && *xfname != NUL) {\n    buf = buflist_new(fname, xfname, curwin->w_cursor.lnum, 0);\n    if (buf != NULL && !cmdmod.keepalt) {\n      curwin->w_alt_fnum = buf->b_fnum;\n    }\n  }\n  xfree(fname);\n  xfree(sfname);\n  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n  /* Change directories when the 'acd' option is set. */\n  do_autochdir();\n  return OK;\n}\n\n/*\n * \":file[!] [fname]\".\n */\nvoid ex_file(exarg_T *eap)\n{\n  /* \":0file\" removes the file name.  Check for illegal uses \":3file\",\n   * \"0file name\", etc. */\n  if (eap->addr_count > 0\n      && (*eap->arg != NUL\n          || eap->line2 > 0\n          || eap->addr_count > 1)) {\n    EMSG(_(e_invarg));\n    return;\n  }\n\n  if (*eap->arg != NUL || eap->addr_count == 1) {\n    if (rename_buffer(eap->arg) == FAIL) {\n      return;\n    }\n    redraw_tabline = true;\n  }\n\n  // print file name if no argument or 'F' is not in 'shortmess'\n  if (*eap->arg == NUL || !shortmess(SHM_FILEINFO)) {\n    fileinfo(false, false, eap->forceit);\n  }\n}\n\n/*\n * \":update\".\n */\nvoid ex_update(exarg_T *eap)\n{\n  if (curbufIsChanged())\n    (void)do_write(eap);\n}\n\n/*\n * \":write\" and \":saveas\".\n */\nvoid ex_write(exarg_T *eap)\n{\n  if (eap->cmdidx == CMD_saveas) {\n    // :saveas does not take a range, uses all lines.\n    eap->line1 = 1;\n    eap->line2 = curbuf->b_ml.ml_line_count;\n  }\n\n  if (eap->usefilter) {  // input lines to shell command\n    do_bang(1, eap, false, true, false);\n  } else {\n    (void)do_write(eap);\n  }\n}\n\n/*\n * write current buffer to file 'eap->arg'\n * if 'eap->append' is TRUE, append to the file\n *\n * if *eap->arg == NUL write to current file\n *\n * return FAIL for failure, OK otherwise\n */\nint do_write(exarg_T *eap)\n{\n  int other;\n  char_u      *fname = NULL;            /* init to shut up gcc */\n  char_u      *ffname;\n  int retval = FAIL;\n  char_u      *free_fname = NULL;\n  buf_T       *alt_buf = NULL;\n  int          name_was_missing;\n\n  if (not_writing())            /* check 'write' option */\n    return FAIL;\n\n  ffname = eap->arg;\n  if (*ffname == NUL) {\n    if (eap->cmdidx == CMD_saveas) {\n      EMSG(_(e_argreq));\n      goto theend;\n    }\n    other = FALSE;\n  } else {\n    fname = ffname;\n    free_fname = (char_u *)fix_fname((char *)ffname);\n    /*\n     * When out-of-memory, keep unexpanded file name, because we MUST be\n     * able to write the file in this situation.\n     */\n    if (free_fname != NULL)\n      ffname = free_fname;\n    other = otherfile(ffname);\n  }\n\n  /*\n   * If we have a new file, put its name in the list of alternate file names.\n   */\n  if (other) {\n    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL\n        || eap->cmdidx == CMD_saveas)\n      alt_buf = setaltfname(ffname, fname, (linenr_T)1);\n    else\n      alt_buf = buflist_findname(ffname);\n    if (alt_buf != NULL && alt_buf->b_ml.ml_mfp != NULL) {\n      /* Overwriting a file that is loaded in another buffer is not a\n       * good idea. */\n      EMSG(_(e_bufloaded));\n      goto theend;\n    }\n  }\n\n  // Writing to the current file is not allowed in readonly mode\n  // and a file name is required.\n  // \"nofile\" and \"nowrite\" buffers cannot be written implicitly either.\n  if (!other && (bt_dontwrite_msg(curbuf)\n                 || check_fname() == FAIL\n                 || check_readonly(&eap->forceit, curbuf))) {\n    goto theend;\n  }\n\n  if (!other) {\n    ffname = curbuf->b_ffname;\n    fname = curbuf->b_fname;\n    /*\n     * Not writing the whole file is only allowed with '!'.\n     */\n    if (       (eap->line1 != 1\n                || eap->line2 != curbuf->b_ml.ml_line_count)\n               && !eap->forceit\n               && !eap->append\n               && !p_wa) {\n      if (p_confirm || cmdmod.confirm) {\n        if (vim_dialog_yesno(VIM_QUESTION, NULL,\n                (char_u *)_(\"Write partial file?\"), 2) != VIM_YES)\n          goto theend;\n        eap->forceit = TRUE;\n      } else {\n        EMSG(_(\"E140: Use ! to write partial buffer\"));\n        goto theend;\n      }\n    }\n  }\n\n  if (check_overwrite(eap, curbuf, fname, ffname, other) == OK) {\n    if (eap->cmdidx == CMD_saveas && alt_buf != NULL) {\n      buf_T       *was_curbuf = curbuf;\n\n      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);\n      if (curbuf != was_curbuf || aborting()) {\n        /* buffer changed, don't change name now */\n        retval = FAIL;\n        goto theend;\n      }\n      /* Exchange the file names for the current and the alternate\n       * buffer.  This makes it look like we are now editing the buffer\n       * under the new name.  Must be done before buf_write(), because\n       * if there is no file name and 'cpo' contains 'F', it will set\n       * the file name. */\n      fname = alt_buf->b_fname;\n      alt_buf->b_fname = curbuf->b_fname;\n      curbuf->b_fname = fname;\n      fname = alt_buf->b_ffname;\n      alt_buf->b_ffname = curbuf->b_ffname;\n      curbuf->b_ffname = fname;\n      fname = alt_buf->b_sfname;\n      alt_buf->b_sfname = curbuf->b_sfname;\n      curbuf->b_sfname = fname;\n      buf_name_changed(curbuf);\n      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);\n      if (!alt_buf->b_p_bl) {\n        alt_buf->b_p_bl = TRUE;\n        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);\n      }\n      if (curbuf != was_curbuf || aborting()) {\n        /* buffer changed, don't write the file */\n        retval = FAIL;\n        goto theend;\n      }\n\n      // If 'filetype' was empty try detecting it now.\n      if (*curbuf->b_p_ft == NUL) {\n        if (au_has_group((char_u *)\"filetypedetect\")) {\n          (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", true, NULL);\n        }\n        do_modelines(0);\n      }\n\n      /* Autocommands may have changed buffer names, esp. when\n       * 'autochdir' is set. */\n      fname = curbuf->b_sfname;\n    }\n\n    name_was_missing = curbuf->b_ffname == NULL;\n    retval = buf_write(curbuf, ffname, fname, eap->line1, eap->line2,\n        eap, eap->append, eap->forceit, TRUE, FALSE);\n\n    /* After \":saveas fname\" reset 'readonly'. */\n    if (eap->cmdidx == CMD_saveas) {\n      if (retval == OK) {\n        curbuf->b_p_ro = FALSE;\n        redraw_tabline = true;\n      }\n    }\n\n    // Change directories when the 'acd' option is set and the file name\n    // got changed or set.\n    if (eap->cmdidx == CMD_saveas || name_was_missing) {\n      do_autochdir();\n    }\n  }\n\ntheend:\n  xfree(free_fname);\n  return retval;\n}\n\n/*\n * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,\n * BF_NEW or BF_READERR, check for overwriting current file.\n * May set eap->forceit if a dialog says it's OK to overwrite.\n * Return OK if it's OK, FAIL if it is not.\n */\nint\ncheck_overwrite(\n    exarg_T *eap,\n    buf_T *buf,\n    char_u *fname,         // file name to be used (can differ from\n                           //   buf->ffname)\n    char_u *ffname,        // full path version of fname\n    int other              // writing under other name\n)\n{\n  /*\n   * write to other file or b_flags set or not writing the whole file:\n   * overwriting only allowed with '!'\n   */\n  if ((other\n       || (buf->b_flags & BF_NOTEDITED)\n       || ((buf->b_flags & BF_NEW)\n           && vim_strchr(p_cpo, CPO_OVERNEW) == NULL)\n       || (buf->b_flags & BF_READERR))\n      && !p_wa\n      && !bt_nofile(buf)\n      && os_path_exists(ffname)) {\n    if (!eap->forceit && !eap->append) {\n#ifdef UNIX\n      // It is possible to open a directory on Unix.\n      if (os_isdir(ffname)) {\n        EMSG2(_(e_isadir2), ffname);\n        return FAIL;\n      }\n#endif\n      if (p_confirm || cmdmod.confirm) {\n        char_u buff[DIALOG_MSG_SIZE];\n\n        dialog_msg(buff, _(\"Overwrite existing file \\\"%s\\\"?\"), fname);\n        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)\n          return FAIL;\n        eap->forceit = TRUE;\n      } else {\n        EMSG(_(e_exists));\n        return FAIL;\n      }\n    }\n\n    /* For \":w! filename\" check that no swap file exists for \"filename\". */\n    if (other && !emsg_silent) {\n      char_u      *dir;\n      char_u      *p;\n      char_u      *swapname;\n\n      /* We only try the first entry in 'directory', without checking if\n       * it's writable.  If the \".\" directory is not writable the write\n       * will probably fail anyway.\n       * Use 'shortname' of the current buffer, since there is no buffer\n       * for the written file. */\n      if (*p_dir == NUL) {\n        dir = xmalloc(5);\n        STRCPY(dir, \".\");\n      } else {\n        dir = xmalloc(MAXPATHL);\n        p = p_dir;\n        copy_option_part(&p, dir, MAXPATHL, \",\");\n      }\n      swapname = makeswapname(fname, ffname, curbuf, dir);\n      xfree(dir);\n      if (os_path_exists(swapname)) {\n        if (p_confirm || cmdmod.confirm) {\n          char_u buff[DIALOG_MSG_SIZE];\n\n          dialog_msg(buff,\n              _(\"Swap file \\\"%s\\\" exists, overwrite anyway?\"),\n              swapname);\n          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)\n              != VIM_YES) {\n            xfree(swapname);\n            return FAIL;\n          }\n          eap->forceit = TRUE;\n        } else {\n          EMSG2(_(\"E768: Swap file exists: %s (:silent! overrides)\"),\n              swapname);\n          xfree(swapname);\n          return FAIL;\n        }\n      }\n      xfree(swapname);\n    }\n  }\n  return OK;\n}\n\n/*\n * Handle \":wnext\", \":wNext\" and \":wprevious\" commands.\n */\nvoid ex_wnext(exarg_T *eap)\n{\n  int i;\n\n  if (eap->cmd[1] == 'n')\n    i = curwin->w_arg_idx + (int)eap->line2;\n  else\n    i = curwin->w_arg_idx - (int)eap->line2;\n  eap->line1 = 1;\n  eap->line2 = curbuf->b_ml.ml_line_count;\n  if (do_write(eap) != FAIL)\n    do_argfile(eap, i);\n}\n\n/*\n * \":wall\", \":wqall\" and \":xall\": Write all changed files (and exit).\n */\nvoid do_wqall(exarg_T *eap)\n{\n  int error = 0;\n  int save_forceit = eap->forceit;\n\n  if (eap->cmdidx == CMD_xall || eap->cmdidx == CMD_wqall) {\n    exiting = true;\n  }\n\n  FOR_ALL_BUFFERS(buf) {\n    if (exiting\n        && buf->terminal\n        && channel_job_running((uint64_t)buf->b_p_channel)) {\n      no_write_message_nobang(buf);\n      error++;\n    } else if (!bufIsChanged(buf) || bt_dontwrite(buf)) {\n      continue;\n    }\n    /*\n     * Check if there is a reason the buffer cannot be written:\n     * 1. if the 'write' option is set\n     * 2. if there is no file name (even after browsing)\n     * 3. if the 'readonly' is set (even after a dialog)\n     * 4. if overwriting is allowed (even after a dialog)\n     */\n    if (not_writing()) {\n      ++error;\n      break;\n    }\n    if (buf->b_ffname == NULL) {\n      EMSGN(_(\"E141: No file name for buffer %\" PRId64), buf->b_fnum);\n      ++error;\n    } else if (check_readonly(&eap->forceit, buf)\n               || check_overwrite(eap, buf, buf->b_fname, buf->b_ffname,\n                   FALSE) == FAIL) {\n      ++error;\n    } else {\n      bufref_T bufref;\n      set_bufref(&bufref, buf);\n      if (buf_write_all(buf, eap->forceit) == FAIL) {\n        error++;\n      }\n      // An autocommand may have deleted the buffer.\n      if (!bufref_valid(&bufref)) {\n        buf = firstbuf;\n      }\n    }\n    eap->forceit = save_forceit;          /* check_overwrite() may set it */\n  }\n  if (exiting) {\n    if (!error)\n      getout(0);                /* exit Vim */\n    not_exiting();\n  }\n}\n\n/*\n * Check the 'write' option.\n * Return TRUE and give a message when it's not st.\n */\nint not_writing(void)\n{\n  if (p_write)\n    return FALSE;\n  EMSG(_(\"E142: File not written: Writing is disabled by 'write' option\"));\n  return TRUE;\n}\n\n/*\n * Check if a buffer is read-only (either 'readonly' option is set or file is\n * read-only). Ask for overruling in a dialog. Return TRUE and give an error\n * message when the buffer is readonly.\n */\nstatic int check_readonly(int *forceit, buf_T *buf)\n{\n  /* Handle a file being readonly when the 'readonly' option is set or when\n   * the file exists and permissions are read-only. */\n  if (!*forceit && (buf->b_p_ro\n                    || (os_path_exists(buf->b_ffname)\n                        && !os_file_is_writable((char *)buf->b_ffname)))) {\n    if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL) {\n      char_u buff[DIALOG_MSG_SIZE];\n\n      if (buf->b_p_ro)\n        dialog_msg(buff,\n            _(\n                \"'readonly' option is set for \\\"%s\\\".\\nDo you wish to write anyway?\"),\n            buf->b_fname);\n      else\n        dialog_msg(buff,\n            _(\n                \"File permissions of \\\"%s\\\" are read-only.\\nIt may still be possible to write it.\\nDo you wish to try?\"),\n            buf->b_fname);\n\n      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {\n        /* Set forceit, to force the writing of a readonly file */\n        *forceit = TRUE;\n        return FALSE;\n      } else\n        return TRUE;\n    } else if (buf->b_p_ro)\n      EMSG(_(e_readonly));\n    else\n      EMSG2(_(\"E505: \\\"%s\\\" is read-only (add ! to override)\"),\n          buf->b_fname);\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n// Try to abandon the current file and edit a new or existing file.\n// \"fnum\" is the number of the file, if zero use \"ffname_arg\"/\"sfname_arg\".\n// \"lnum\" is the line number for the cursor in the new file (if non-zero).\n//\n// Return:\n// GETFILE_ERROR for \"normal\" error,\n// GETFILE_NOT_WRITTEN for \"not written\" error,\n// GETFILE_SAME_FILE for success\n// GETFILE_OPEN_OTHER for successfully opening another file.\nint getfile(int fnum, char_u *ffname_arg, char_u *sfname_arg, int setpm,\n            linenr_T lnum, int forceit)\n{\n  char_u *ffname = ffname_arg;\n  char_u *sfname = sfname_arg;\n  int other;\n  int retval;\n  char_u      *free_me = NULL;\n\n  if (text_locked()) {\n    return GETFILE_ERROR;\n  }\n  if (curbuf_locked()) {\n    return GETFILE_ERROR;\n  }\n\n  if (fnum == 0) {\n    /* make ffname full path, set sfname */\n    fname_expand(curbuf, &ffname, &sfname);\n    other = otherfile(ffname);\n    free_me = ffname;                   /* has been allocated, free() later */\n  } else\n    other = (fnum != curbuf->b_fnum);\n\n  if (other) {\n    no_wait_return++;               // don't wait for autowrite message\n  }\n  if (other && !forceit && curbuf->b_nwindows == 1 && !buf_hide(curbuf)\n      && curbufIsChanged() && autowrite(curbuf, forceit) == FAIL) {\n    if (p_confirm && p_write) {\n      dialog_changed(curbuf, false);\n    }\n    if (curbufIsChanged()) {\n      no_wait_return--;\n      no_write_message();\n      retval = GETFILE_NOT_WRITTEN;     // File has been changed.\n      goto theend;\n    }\n  }\n  if (other)\n    --no_wait_return;\n  if (setpm)\n    setpcmark();\n  if (!other) {\n    if (lnum != 0) {\n      curwin->w_cursor.lnum = lnum;\n    }\n    check_cursor_lnum();\n    beginline(BL_SOL | BL_FIX);\n    retval = GETFILE_SAME_FILE;     // it's in the same file\n  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,\n                     (buf_hide(curbuf) ? ECMD_HIDE : 0)\n                     + (forceit ? ECMD_FORCEIT : 0), curwin) == OK) {\n    retval = GETFILE_OPEN_OTHER;    // opened another file\n  } else {\n    retval = GETFILE_ERROR;         // error encountered\n  }\n\ntheend:\n  xfree(free_me);\n  return retval;\n}\n\n/// start editing a new file\n///\n/// @param fnum     file number; if zero use ffname/sfname\n/// @param ffname   the file name\n///                 - full path if sfname used,\n///                 - any file name if sfname is NULL\n///                 - empty string to re-edit with the same file name (but may\n///                   be in a different directory)\n///                 - NULL to start an empty buffer\n/// @param sfname   the short file name (or NULL)\n/// @param eap      contains the command to be executed after loading the file\n///                 and forced 'ff' and 'fenc'\n/// @param newlnum  if > 0: put cursor on this line number (if possible)\n///                 ECMD_LASTL: use last position in loaded file\n///                 ECMD_LAST: use last position in all files\n///                 ECMD_ONE: use first line\n/// @param flags    ECMD_HIDE: if TRUE don't free the current buffer\n///                 ECMD_SET_HELP: set b_help flag of (new) buffer before\n///                 opening file\n///                 ECMD_OLDBUF: use existing buffer if it exists\n///                 ECMD_FORCEIT: ! used for Ex command\n///                 ECMD_ADDBUF: don't edit, just add to buffer list\n///                 ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate\n///                 file\n/// @param oldwin   Should be \"curwin\" when editing a new buffer in the current\n///                 window, NULL when splitting the window first.  When not NULL\n///                 info of the previous buffer for \"oldwin\" is stored.\n///\n/// @return FAIL for failure, OK otherwise\nint do_ecmd(\n    int fnum,\n    char_u *ffname,\n    char_u *sfname,\n    exarg_T *eap,                       /* can be NULL! */\n    linenr_T newlnum,\n    int flags,\n    win_T *oldwin\n)\n{\n  int other_file;                       /* TRUE if editing another file */\n  int oldbuf;                           /* TRUE if using existing buffer */\n  int auto_buf = FALSE;                 /* TRUE if autocommands brought us\n                                           into the buffer unexpectedly */\n  char_u      *new_name = NULL;\n  int did_set_swapcommand = FALSE;\n  buf_T       *buf;\n  bufref_T     bufref;\n  bufref_T     old_curbuf;\n  char_u      *free_fname = NULL;\n  int retval = FAIL;\n  long n;\n  pos_T orig_pos;\n  linenr_T topline = 0;\n  int newcol = -1;\n  int solcol = -1;\n  pos_T       *pos;\n  char_u      *command = NULL;\n  int did_get_winopts = FALSE;\n  int readfile_flags = 0;\n  bool did_inc_redrawing_disabled = false;\n  long *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n\n  if (eap != NULL)\n    command = eap->do_ecmd_cmd;\n\n  set_bufref(&old_curbuf, curbuf);\n\n  if (fnum != 0) {\n    if (fnum == curbuf->b_fnum)         /* file is already being edited */\n      return OK;                        /* nothing to do */\n    other_file = TRUE;\n  } else {\n    /* if no short name given, use ffname for short name */\n    if (sfname == NULL)\n      sfname = ffname;\n#ifdef USE_FNAME_CASE\n    if (sfname != NULL)\n      path_fix_case(sfname);             // set correct case for sfname\n#endif\n\n    if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))\n        && (ffname == NULL || *ffname == NUL)) {\n      goto theend;\n    }\n\n    if (ffname == NULL)\n      other_file = TRUE;\n    /* there is no file name */\n    else if (*ffname == NUL && curbuf->b_ffname == NULL)\n      other_file = FALSE;\n    else {\n      if (*ffname == NUL) {                 /* re-edit with same file name */\n        ffname = curbuf->b_ffname;\n        sfname = curbuf->b_fname;\n      }\n      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */\n      if (free_fname != NULL)\n        ffname = free_fname;\n      other_file = otherfile(ffname);\n    }\n  }\n\n  // Re-editing a terminal buffer: skip most buffer re-initialization.\n  if (!other_file && curbuf->terminal) {\n    check_arg_idx(curwin);  // Needed when called from do_argfile().\n    maketitle();            // Title may show the arg index, e.g. \"(2 of 5)\".\n    retval = OK;\n    goto theend;\n  }\n\n  // If the file was changed we may not be allowed to abandon it:\n  // - if we are going to re-edit the same file\n  // - or if we are the only window on this file and if ECMD_HIDE is FALSE\n  if (((!other_file && !(flags & ECMD_OLDBUF))\n       || (curbuf->b_nwindows == 1\n           && !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))\n      && check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n                       | (other_file ? 0 : CCGD_MULTWIN)\n                       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n                       | (eap == NULL ? 0 : CCGD_EXCMD))) {\n    if (fnum == 0 && other_file && ffname != NULL) {\n      (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n    }\n    goto theend;\n  }\n\n  /*\n   * End Visual mode before switching to another buffer, so the text can be\n   * copied into the GUI selection buffer.\n   */\n  reset_VIsual();\n\n  if ((command != NULL || newlnum > (linenr_T)0)\n      && *get_vim_var_str(VV_SWAPCOMMAND) == NUL) {\n    // Set v:swapcommand for the SwapExists autocommands.\n    const size_t len = (command != NULL) ? STRLEN(command) + 3 : 30;\n    char *const p = xmalloc(len);\n    if (command != NULL) {\n      vim_snprintf(p, len, \":%s\\r\", command);\n    } else {\n      vim_snprintf(p, len, \"%\" PRId64 \"G\", (int64_t)newlnum);\n    }\n    set_vim_var_string(VV_SWAPCOMMAND, p, -1);\n    did_set_swapcommand = TRUE;\n    xfree(p);\n  }\n\n  /*\n   * If we are starting to edit another file, open a (new) buffer.\n   * Otherwise we re-use the current buffer.\n   */\n  if (other_file) {\n    if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF))) {\n      if (!cmdmod.keepalt) {\n        curwin->w_alt_fnum = curbuf->b_fnum;\n      }\n      if (oldwin != NULL) {\n        buflist_altfpos(oldwin);\n      }\n    }\n\n    if (fnum) {\n      buf = buflist_findnr(fnum);\n    } else {\n      if (flags & (ECMD_ADDBUF | ECMD_ALTBUF)) {\n        // Default the line number to zero to avoid that a wininfo item\n        // is added for the current window.\n        linenr_T tlnum = 0;\n\n        if (command != NULL) {\n          tlnum = atol((char *)command);\n          if (tlnum <= 0)\n            tlnum = 1L;\n        }\n        // Add BLN_NOCURWIN to avoid a new wininfo items are associated\n        // with the current window.\n        const buf_T *const newbuf\n            = buflist_new(ffname, sfname, tlnum, BLN_LISTED | BLN_NOCURWIN);\n        if (newbuf != NULL && (flags & ECMD_ALTBUF)) {\n          curwin->w_alt_fnum = newbuf->b_fnum;\n        }\n        goto theend;\n      }\n      buf = buflist_new(ffname, sfname, 0L,\n                        BLN_CURBUF | (flags & ECMD_SET_HELP ? 0 : BLN_LISTED));\n      // Autocmds may change curwin and curbuf.\n      if (oldwin != NULL) {\n        oldwin = curwin;\n      }\n      set_bufref(&old_curbuf, curbuf);\n    }\n    if (buf == NULL)\n      goto theend;\n    if (buf->b_ml.ml_mfp == NULL) {\n      // No memfile yet.\n      oldbuf = false;\n    } else {\n      // Existing memfile.\n      oldbuf = true;\n      set_bufref(&bufref, buf);\n      (void)buf_check_timestamp(buf);\n      // Check if autocommands made buffer invalid or changed the current\n      // buffer.\n      if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf) {\n        goto theend;\n      }\n      if (aborting()) {\n        // Autocmds may abort script processing.\n        goto theend;\n      }\n    }\n\n    /* May jump to last used line number for a loaded buffer or when asked\n     * for explicitly */\n    if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST) {\n      pos = buflist_findfpos(buf);\n      newlnum = pos->lnum;\n      solcol = pos->col;\n    }\n\n    /*\n     * Make the (new) buffer the one used by the current window.\n     * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.\n     * If the current buffer was empty and has no file name, curbuf\n     * is returned by buflist_new(), nothing to do here.\n     */\n    if (buf != curbuf) {\n      const int save_cmdwin_type = cmdwin_type;\n\n      // BufLeave applies to the old buffer.\n      cmdwin_type = 0;\n\n      // Be careful: The autocommands may delete any buffer and change\n      // the current buffer.\n      // - If the buffer we are going to edit is deleted, give up.\n      // - If the current buffer is deleted, prefer to load the new\n      //   buffer when loading a buffer is required.  This avoids\n      //   loading another buffer which then must be closed again.\n      // - If we ended up in the new buffer already, need to skip a few\n      //         things, set auto_buf.\n      if (buf->b_fname != NULL) {\n        new_name = vim_strsave(buf->b_fname);\n      }\n      set_bufref(&au_new_curbuf, buf);\n      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);\n      cmdwin_type = save_cmdwin_type;\n      if (!bufref_valid(&au_new_curbuf)) {\n        // New buffer has been deleted.\n        delbuf_msg(new_name);  // Frees new_name.\n        goto theend;\n      }\n      if (aborting()) {             /* autocmds may abort script processing */\n        xfree(new_name);\n        goto theend;\n      }\n      if (buf == curbuf) {  // already in new buffer\n        auto_buf = true;\n      } else {\n        win_T *the_curwin = curwin;\n        buf_T *was_curbuf = curbuf;\n\n        // Set w_closing to avoid that autocommands close the window.\n        // Set b_locked for the same reason.\n        the_curwin->w_closing = true;\n        buf->b_locked++;\n\n        if (curbuf == old_curbuf.br_buf) {\n          buf_copy_options(buf, BCO_ENTER);\n        }\n\n        // Close the link to the current buffer. This will set\n        // oldwin->w_buffer to NULL.\n        u_sync(false);\n        const bool did_decrement = close_buffer(\n            oldwin, curbuf,\n            (flags & ECMD_HIDE) || curbuf->terminal ? 0 : DOBUF_UNLOAD,\n            false);\n\n        // Autocommands may have closed the window.\n        if (win_valid(the_curwin)) {\n          the_curwin->w_closing = false;\n        }\n        buf->b_locked--;\n\n        // autocmds may abort script processing\n        if (aborting() && curwin->w_buffer != NULL) {\n          xfree(new_name);\n          goto theend;\n        }\n        // Be careful again, like above.\n        if (!bufref_valid(&au_new_curbuf)) {\n          // New buffer has been deleted.\n          delbuf_msg(new_name);  // Frees new_name.\n          goto theend;\n        }\n        if (buf == curbuf) {  // already in new buffer\n          // close_buffer() has decremented the window count,\n          // increment it again here and restore w_buffer.\n          if (did_decrement && buf_valid(was_curbuf)) {\n            was_curbuf->b_nwindows++;\n          }\n          if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL) {\n            oldwin->w_buffer = was_curbuf;\n          }\n          auto_buf = true;\n        } else {\n          // <VN> We could instead free the synblock\n          // and re-attach to buffer, perhaps.\n          if (curwin->w_buffer == NULL\n              || curwin->w_s == &(curwin->w_buffer->b_s)) {\n            curwin->w_s = &(buf->b_s);\n          }\n\n          curwin->w_buffer = buf;\n          curbuf = buf;\n          ++curbuf->b_nwindows;\n\n          /* Set 'fileformat', 'binary' and 'fenc' when forced. */\n          if (!oldbuf && eap != NULL) {\n            set_file_options(TRUE, eap);\n            set_forced_fenc(eap);\n          }\n        }\n\n        /* May get the window options from the last time this buffer\n         * was in this window (or another window).  If not used\n         * before, reset the local window options to the global\n         * values.  Also restores old folding stuff. */\n        get_winopts(curbuf);\n        did_get_winopts = TRUE;\n\n      }\n      xfree(new_name);\n      au_new_curbuf.br_buf = NULL;\n      au_new_curbuf.br_buf_free_count = 0;\n    }\n\n    curwin->w_pcmark.lnum = 1;\n    curwin->w_pcmark.col = 0;\n  } else {  // !other_file\n    if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL) {\n      goto theend;\n    }\n    oldbuf = (flags & ECMD_OLDBUF);\n  }\n\n  // Don't redraw until the cursor is in the right line, otherwise\n  // autocommands may cause ml_get errors.\n  RedrawingDisabled++;\n  did_inc_redrawing_disabled = true;\n\n  buf = curbuf;\n  if ((flags & ECMD_SET_HELP) || keep_help_flag) {\n    prepare_help_buffer();\n  } else if (!curbuf->b_help) {\n    // Don't make a buffer listed if it's a help buffer.  Useful when using\n    // CTRL-O to go back to a help file.\n    set_buflisted(TRUE);\n  }\n\n  /* If autocommands change buffers under our fingers, forget about\n   * editing the file. */\n  if (buf != curbuf)\n    goto theend;\n  if (aborting())           /* autocmds may abort script processing */\n    goto theend;\n\n  /* Since we are starting to edit a file, consider the filetype to be\n   * unset.  Helps for when an autocommand changes files and expects syntax\n   * highlighting to work in the other file. */\n  did_filetype = FALSE;\n\n  /*\n   * other_file\toldbuf\n   *  FALSE\tFALSE\t    re-edit same file, buffer is re-used\n   *  FALSE\tTRUE\t    re-edit same file, nothing changes\n   *  TRUE\tFALSE\t    start editing new file, new buffer\n   *  TRUE\tTRUE\t    start editing in existing buffer (nothing to do)\n   */\n  if (!other_file && !oldbuf) {         /* re-use the buffer */\n    set_last_cursor(curwin);            /* may set b_last_cursor */\n    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {\n      newlnum = curwin->w_cursor.lnum;\n      solcol = curwin->w_cursor.col;\n    }\n    buf = curbuf;\n    if (buf->b_fname != NULL) {\n      new_name = vim_strsave(buf->b_fname);\n    } else {\n      new_name = NULL;\n    }\n    set_bufref(&bufref, buf);\n\n    // If the buffer was used before, store the current contents so that\n    // the reload can be undone.  Do not do this if the (empty) buffer is\n    // being re-used for another file.\n    if (!(curbuf->b_flags & BF_NEVERLOADED)\n        && (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur)) {\n      // Sync first so that this is a separate undo-able action.\n      u_sync(false);\n      if (u_savecommon(curbuf, 0, curbuf->b_ml.ml_line_count + 1, 0, true)\n          == FAIL) {\n        xfree(new_name);\n        goto theend;\n      }\n      u_unchanged(curbuf);\n      buf_updates_unload(curbuf, false);\n      buf_freeall(curbuf, BFA_KEEP_UNDO);\n\n      // Tell readfile() not to clear or reload undo info.\n      readfile_flags = READ_KEEP_UNDO;\n    } else {\n      buf_updates_unload(curbuf, false);\n      buf_freeall(curbuf, 0);  // Free all things for buffer.\n    }\n    // If autocommands deleted the buffer we were going to re-edit, give\n    // up and jump to the end.\n    if (!bufref_valid(&bufref)) {\n      delbuf_msg(new_name);  // Frees new_name.\n      goto theend;\n    }\n    xfree(new_name);\n\n    /* If autocommands change buffers under our fingers, forget about\n     * re-editing the file.  Should do the buf_clear_file(), but perhaps\n     * the autocommands changed the buffer... */\n    if (buf != curbuf)\n      goto theend;\n    if (aborting())         /* autocmds may abort script processing */\n      goto theend;\n    buf_clear_file(curbuf);\n    curbuf->b_op_start.lnum = 0;        /* clear '[ and '] marks */\n    curbuf->b_op_end.lnum = 0;\n  }\n\n  /*\n   * If we get here we are sure to start editing\n   */\n\n  /* Assume success now */\n  retval = OK;\n\n  /*\n   * Check if we are editing the w_arg_idx file in the argument list.\n   */\n  check_arg_idx(curwin);\n\n  if (!auto_buf) {\n    /*\n     * Set cursor and init window before reading the file and executing\n     * autocommands.  This allows for the autocommands to position the\n     * cursor.\n     */\n    curwin_init();\n\n    /* It's possible that all lines in the buffer changed.  Need to update\n     * automatic folding for all windows where it's used. */\n    FOR_ALL_TAB_WINDOWS(tp, win) {\n      if (win->w_buffer == curbuf) {\n        foldUpdateAll(win);\n      }\n    }\n\n    /* Change directories when the 'acd' option is set. */\n    do_autochdir();\n\n    /*\n     * Careful: open_buffer() and apply_autocmds() may change the current\n     * buffer and window.\n     */\n    orig_pos = curwin->w_cursor;\n    topline = curwin->w_topline;\n    if (!oldbuf) {                          /* need to read the file */\n      swap_exists_action = SEA_DIALOG;\n      curbuf->b_flags |= BF_CHECK_RO;       /* set/reset 'ro' flag */\n\n      /*\n       * Open the buffer and read the file.\n       */\n      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))\n        retval = FAIL;\n\n      if (swap_exists_action == SEA_QUIT)\n        retval = FAIL;\n      handle_swap_exists(&old_curbuf);\n    } else {\n      /* Read the modelines, but only to set window-local options.  Any\n       * buffer-local options have already been set and may have been\n       * changed by the user. */\n      do_modelines(OPT_WINONLY);\n\n      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,\n          &retval);\n      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,\n          &retval);\n    }\n    check_arg_idx(curwin);\n\n    // If autocommands change the cursor position or topline, we should\n    // keep it.  Also when it moves within a line. But not when it moves\n    // to the first non-blank.\n    if (!equalpos(curwin->w_cursor, orig_pos)) {\n      const char_u *text = get_cursor_line_ptr();\n\n      if (curwin->w_cursor.lnum != orig_pos.lnum\n          || curwin->w_cursor.col != (int)(skipwhite(text) - text)) {\n        newlnum = curwin->w_cursor.lnum;\n        newcol = curwin->w_cursor.col;\n      }\n    }\n    if (curwin->w_topline == topline)\n      topline = 0;\n\n    /* Even when cursor didn't move we need to recompute topline. */\n    changed_line_abv_curs();\n\n    maketitle();\n  }\n\n  /* Tell the diff stuff that this buffer is new and/or needs updating.\n   * Also needed when re-editing the same buffer, because unloading will\n   * have removed it as a diff buffer. */\n  if (curwin->w_p_diff) {\n    diff_buf_add(curbuf);\n    diff_invalidate(curbuf);\n  }\n\n  /* If the window options were changed may need to set the spell language.\n   * Can only do this after the buffer has been properly setup. */\n  if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n    (void)did_set_spelllang(curwin);\n\n  if (command == NULL) {\n    if (newcol >= 0) {          /* position set by autocommands */\n      curwin->w_cursor.lnum = newlnum;\n      curwin->w_cursor.col = newcol;\n      check_cursor();\n    } else if (newlnum > 0) { /* line number from caller or old position */\n      curwin->w_cursor.lnum = newlnum;\n      check_cursor_lnum();\n      if (solcol >= 0 && !p_sol) {\n        /* 'sol' is off: Use last known column. */\n        curwin->w_cursor.col = solcol;\n        check_cursor_col();\n        curwin->w_cursor.coladd = 0;\n        curwin->w_set_curswant = TRUE;\n      } else\n        beginline(BL_SOL | BL_FIX);\n    } else {                  /* no line number, go to last line in Ex mode */\n      if (exmode_active)\n        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      beginline(BL_WHITE | BL_FIX);\n    }\n  }\n\n  // Check if cursors in other windows on the same buffer are still valid\n  check_lnums(false);\n\n  /*\n   * Did not read the file, need to show some info about the file.\n   * Do this after setting the cursor.\n   */\n  if (oldbuf\n      && !auto_buf\n      ) {\n    int msg_scroll_save = msg_scroll;\n\n    /* Obey the 'O' flag in 'cpoptions': overwrite any previous file\n     * message. */\n    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n      msg_scroll = FALSE;\n    if (!msg_scroll)            /* wait a bit when overwriting an error msg */\n      check_for_delay(FALSE);\n    msg_start();\n    msg_scroll = msg_scroll_save;\n    msg_scrolled_ign = TRUE;\n\n    if (!shortmess(SHM_FILEINFO)) {\n      fileinfo(false, true, false);\n    }\n\n    msg_scrolled_ign = FALSE;\n  }\n\n  curbuf->b_last_used = time(NULL);\n\n  if (command != NULL)\n    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);\n\n  if (curbuf->b_kmap_state & KEYMAP_INIT)\n    (void)keymap_init();\n\n  RedrawingDisabled--;\n  did_inc_redrawing_disabled = false;\n  if (!skip_redraw) {\n    n = *so_ptr;\n    if (topline == 0 && command == NULL) {\n      *so_ptr = 999;    // force cursor to be vertically centered in the window\n    }\n    update_topline(curwin);\n    curwin->w_scbind_pos = curwin->w_topline;\n    *so_ptr = n;\n    redraw_curbuf_later(NOT_VALID);     // redraw this buffer later\n  }\n\n  if (p_im) {\n    need_start_insertmode = true;\n  }\n\n  /* Change directories when the 'acd' option is set. */\n  do_autochdir();\n\n\ntheend:\n  if (bufref_valid(&old_curbuf) && old_curbuf.br_buf->terminal != NULL) {\n    terminal_check_size(old_curbuf.br_buf->terminal);\n  }\n\n  if (did_inc_redrawing_disabled) {\n    RedrawingDisabled--;\n  }\n  if (did_set_swapcommand) {\n    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n  }\n  xfree(free_fname);\n  return retval;\n}\n\nstatic void delbuf_msg(char_u *name)\n{\n  EMSG2(_(\"E143: Autocommands unexpectedly deleted new buffer %s\"),\n      name == NULL ? (char_u *)\"\" : name);\n  xfree(name);\n  au_new_curbuf.br_buf = NULL;\n  au_new_curbuf.br_buf_free_count = 0;\n}\n\nstatic int append_indent = 0;       /* autoindent for first line */\n\n/*\n * \":insert\" and \":append\", also used by \":change\"\n */\nvoid ex_append(exarg_T *eap)\n{\n  char_u      *theline;\n  bool did_undo = false;\n  linenr_T lnum = eap->line2;\n  int indent = 0;\n  char_u      *p;\n  int vcol;\n  int empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n  /* the ! flag toggles autoindent */\n  if (eap->forceit)\n    curbuf->b_p_ai = !curbuf->b_p_ai;\n\n  /* First autoindent comes from the line we start on */\n  if (eap->cmdidx != CMD_change && curbuf->b_p_ai && lnum > 0)\n    append_indent = get_indent_lnum(lnum);\n\n  if (eap->cmdidx != CMD_append)\n    --lnum;\n\n  // when the buffer is empty need to delete the dummy line\n  if (empty && lnum == 1)\n    lnum = 0;\n\n  State = INSERT;                   /* behave like in Insert mode */\n  if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n    State |= LANGMAP;\n\n  for (;; ) {\n    msg_scroll = TRUE;\n    need_wait_return = false;\n    if (curbuf->b_p_ai) {\n      if (append_indent >= 0) {\n        indent = append_indent;\n        append_indent = -1;\n      } else if (lnum > 0)\n        indent = get_indent_lnum(lnum);\n    }\n    if (eap->getline == NULL) {\n      /* No getline() function, use the lines that follow. This ends\n       * when there is no more. */\n      if (eap->nextcmd == NULL || *eap->nextcmd == NUL)\n        break;\n      p = vim_strchr(eap->nextcmd, NL);\n      if (p == NULL)\n        p = eap->nextcmd + STRLEN(eap->nextcmd);\n      theline = vim_strnsave(eap->nextcmd, p - eap->nextcmd);\n      if (*p != NUL) {\n        p++;\n      }\n      eap->nextcmd = p;\n    } else {\n      // Set State to avoid the cursor shape to be set to INSERT mode\n      // when getline() returns.\n      int save_State = State;\n      State = CMDLINE;\n      theline = eap->getline(\n          eap->cstack->cs_looplevel > 0 ? -1 :\n          NUL, eap->cookie, indent, true);\n      State = save_State;\n    }\n    lines_left = Rows - 1;\n    if (theline == NULL)\n      break;\n\n    /* Look for the \".\" after automatic indent. */\n    vcol = 0;\n    for (p = theline; indent > vcol; ++p) {\n      if (*p == ' ')\n        ++vcol;\n      else if (*p == TAB)\n        vcol += 8 - vcol % 8;\n      else\n        break;\n    }\n    if ((p[0] == '.' && p[1] == NUL)\n        || (!did_undo && u_save(lnum, lnum + 1 + (empty ? 1 : 0))\n            == FAIL)) {\n      xfree(theline);\n      break;\n    }\n\n    /* don't use autoindent if nothing was typed. */\n    if (p[0] == NUL)\n      theline[0] = NUL;\n\n    did_undo = true;\n    ml_append(lnum, theline, (colnr_T)0, false);\n    appended_lines_mark(lnum + (empty ? 1 : 0), 1L);\n\n    xfree(theline);\n    ++lnum;\n\n    if (empty) {\n      ml_delete(2L, false);\n      empty = 0;\n    }\n  }\n  State = NORMAL;\n\n  if (eap->forceit)\n    curbuf->b_p_ai = !curbuf->b_p_ai;\n\n  /* \"start\" is set to eap->line2+1 unless that position is invalid (when\n   * eap->line2 pointed to the end of the buffer and nothing was appended)\n   * \"end\" is set to lnum when something has been appended, otherwise\n   * it is the same than \"start\"  -- Acevedo */\n  curbuf->b_op_start.lnum = (eap->line2 < curbuf->b_ml.ml_line_count) ?\n                            eap->line2 + 1 : curbuf->b_ml.ml_line_count;\n  if (eap->cmdidx != CMD_append)\n    --curbuf->b_op_start.lnum;\n  curbuf->b_op_end.lnum = (eap->line2 < lnum)\n                          ? lnum : curbuf->b_op_start.lnum;\n  curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n  curwin->w_cursor.lnum = lnum;\n  check_cursor_lnum();\n  beginline(BL_SOL | BL_FIX);\n\n  need_wait_return = false;     // don't use wait_return() now\n  ex_no_reprint = true;\n}\n\n/*\n * \":change\"\n */\nvoid ex_change(exarg_T *eap)\n{\n  linenr_T lnum;\n\n  if (eap->line2 >= eap->line1\n      && u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)\n    return;\n\n  /* the ! flag toggles autoindent */\n  if (eap->forceit ? !curbuf->b_p_ai : curbuf->b_p_ai)\n    append_indent = get_indent_lnum(eap->line1);\n\n  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)           /* nothing to delete */\n      break;\n    ml_delete(eap->line1, false);\n  }\n\n  /* make sure the cursor is not beyond the end of the file now */\n  check_cursor_lnum();\n  deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));\n\n  /* \":append\" on the line above the deleted lines. */\n  eap->line2 = eap->line1;\n  ex_append(eap);\n}\n\nvoid ex_z(exarg_T *eap)\n{\n  char_u      *x;\n  int64_t     bigness;\n  char_u      *kind;\n  int minus = 0;\n  linenr_T start, end, curs, i;\n  int j;\n  linenr_T lnum = eap->line2;\n\n  // Vi compatible: \":z!\" uses display height, without a count uses\n  // 'scroll'\n  if (eap->forceit) {\n    bigness = curwin->w_height_inner;\n  } else if (ONE_WINDOW) {\n    bigness = curwin->w_p_scr * 2;\n  } else {\n    bigness = curwin->w_height_inner - 3;\n  }\n  if (bigness < 1) {\n    bigness = 1;\n  }\n\n  x = eap->arg;\n  kind = x;\n  if (*kind == '-' || *kind == '+' || *kind == '='\n      || *kind == '^' || *kind == '.')\n    ++x;\n  while (*x == '-' || *x == '+')\n    ++x;\n\n  if (*x != 0) {\n    if (!ascii_isdigit(*x)) {\n      EMSG(_(\"E144: non-numeric argument to :z\"));\n      return;\n    }\n    bigness = atol((char *)x);\n\n    // bigness could be < 0 if atol(x) overflows.\n    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0) {\n      bigness = 2 * curbuf->b_ml.ml_line_count;\n    }\n\n    p_window = bigness;\n    if (*kind == '=') {\n      bigness += 2;\n    }\n  }\n\n  /* the number of '-' and '+' multiplies the distance */\n  if (*kind == '-' || *kind == '+')\n    for (x = kind + 1; *x == *kind; ++x)\n      ;\n\n  switch (*kind) {\n  case '-':\n    start = lnum - bigness * (linenr_T)(x - kind) + 1;\n    end = start + bigness - 1;\n    curs = end;\n    break;\n\n  case '=':\n    start = lnum - (bigness + 1) / 2 + 1;\n    end = lnum + (bigness + 1) / 2 - 1;\n    curs = lnum;\n    minus = 1;\n    break;\n\n  case '^':\n    start = lnum - bigness * 2;\n    end = lnum - bigness;\n    curs = lnum - bigness;\n    break;\n\n  case '.':\n    start = lnum - (bigness + 1) / 2 + 1;\n    end = lnum + (bigness + 1) / 2 - 1;\n    curs = end;\n    break;\n\n  default:        /* '+' */\n    start = lnum;\n    if (*kind == '+')\n      start += bigness * (linenr_T)(x - kind - 1) + 1;\n    else if (eap->addr_count == 0)\n      ++start;\n    end = start + bigness - 1;\n    curs = end;\n    break;\n  }\n\n  if (start < 1)\n    start = 1;\n\n  if (end > curbuf->b_ml.ml_line_count)\n    end = curbuf->b_ml.ml_line_count;\n\n  if (curs > curbuf->b_ml.ml_line_count) {\n    curs = curbuf->b_ml.ml_line_count;\n  } else if (curs < 1) {\n    curs = 1;\n  }\n\n  for (i = start; i <= end; i++) {\n    if (minus && i == lnum) {\n      msg_putchar('\\n');\n\n      for (j = 1; j < Columns; j++)\n        msg_putchar('-');\n    }\n\n    print_line(i, eap->flags & EXFLAG_NR, eap->flags & EXFLAG_LIST);\n\n    if (minus && i == lnum) {\n      msg_putchar('\\n');\n\n      for (j = 1; j < Columns; j++)\n        msg_putchar('-');\n    }\n  }\n\n  if (curwin->w_cursor.lnum != curs) {\n    curwin->w_cursor.lnum = curs;\n    curwin->w_cursor.col = 0;\n  }\n  ex_no_reprint = true;\n}\n\n/*\n * Check if the secure flag is set (.exrc or .vimrc in current directory).\n * If so, give an error message and return TRUE.\n * Otherwise, return FALSE.\n */\nint check_secure(void)\n{\n  if (secure) {\n    secure = 2;\n    EMSG(_(e_curdir));\n    return TRUE;\n  }\n\n  // In the sandbox more things are not allowed, including the things\n  // disallowed in secure mode.\n  if (sandbox != 0) {\n    EMSG(_(e_sandbox));\n    return TRUE;\n  }\n  return FALSE;\n}\n\n/// Previous substitute replacement string\nstatic SubReplacementString old_sub = {NULL, 0, NULL};\n\nstatic int global_need_beginline;       // call beginline() after \":g\"\n\n/// Get old substitute replacement string\n///\n/// @param[out]  ret_sub    Location where old string will be saved.\nvoid sub_get_replacement(SubReplacementString *const ret_sub)\n  FUNC_ATTR_NONNULL_ALL\n{\n  *ret_sub = old_sub;\n}\n\n/// Set substitute string and timestamp\n///\n/// @warning `sub` must be in allocated memory. It is not copied.\n///\n/// @param[in]  sub  New replacement string.\nvoid sub_set_replacement(SubReplacementString sub)\n{\n  xfree(old_sub.sub);\n  if (sub.additional_elements != old_sub.additional_elements) {\n    tv_list_unref(old_sub.additional_elements);\n  }\n  old_sub = sub;\n}\n\n/// Recognize \":%s/\\n//\" and turn it into a join command, which is much\n/// more efficient.\n///\n/// @param[in]  eap  Ex arguments\n/// @param[in]  pat  Search pattern\n/// @param[in]  sub  Replacement string\n/// @param[in]  cmd  Command from :s_flags\n/// @param[in]  save Save pattern to options, history\n///\n/// @returns true if :substitute can be replaced with a join command\nstatic bool sub_joining_lines(exarg_T *eap, char_u *pat, char_u *sub,\n                              char_u *cmd, bool save)\n  FUNC_ATTR_NONNULL_ARG(1, 3, 4)\n{\n  // TODO(vim): find a generic solution to make line-joining operations more\n  // efficient, avoid allocating a string that grows in size.\n  if (pat != NULL\n      && strcmp((const char *)pat, \"\\\\n\") == 0\n      && *sub == NUL\n      && (*cmd == NUL || (cmd[1] == NUL\n                          && (*cmd == 'g'\n                              || *cmd == 'l'\n                              || *cmd == 'p'\n                              || *cmd == '#')))) {\n    if (eap->skip) {\n      return true;\n    }\n    curwin->w_cursor.lnum = eap->line1;\n    if (*cmd == 'l') {\n      eap->flags = EXFLAG_LIST;\n    } else if (*cmd == '#') {\n      eap->flags = EXFLAG_NR;\n    } else if (*cmd == 'p') {\n      eap->flags = EXFLAG_PRINT;\n    }\n\n    // The number of lines joined is the number of lines in the range\n    linenr_T joined_lines_count = eap->line2 - eap->line1 + 1\n      // plus one extra line if not at the end of file.\n      + (eap->line2 < curbuf->b_ml.ml_line_count ? 1 : 0);\n    if (joined_lines_count > 1) {\n      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);\n      sub_nsubs = joined_lines_count - 1;\n      sub_nlines = 1;\n      do_sub_msg(false);\n      ex_may_print(eap);\n    }\n\n    if (save) {\n      if (!cmdmod.keeppatterns) {\n        save_re_pat(RE_SUBST, pat, p_magic);\n      }\n      add_to_history(HIST_SEARCH, pat, true, NUL);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n/// Allocate memory to store the replacement text for :substitute.\n///\n/// Slightly more memory that is strictly necessary is allocated to reduce the\n/// frequency of memory (re)allocation.\n///\n/// @param[in,out]  new_start   pointer to the memory for the replacement text\n/// @param[in]      needed_len  amount of memory needed\n///\n/// @returns pointer to the end of the allocated memory\nstatic char_u *sub_grow_buf(char_u **new_start, int needed_len)\n  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_RET\n{\n  int new_start_len = 0;\n  char_u *new_end;\n  if (*new_start == NULL) {\n    // Get some space for a temporary buffer to do the\n    // substitution into (and some extra space to avoid\n    // too many calls to xmalloc()/free()).\n    new_start_len = needed_len + 50;\n    *new_start = xmalloc(new_start_len);\n    **new_start = NUL;\n    new_end = *new_start;\n  } else {\n    // Check if the temporary buffer is long enough to do the\n    // substitution into.  If not, make it larger (with a bit\n    // extra to avoid too many calls to xmalloc()/free()).\n    size_t len = STRLEN(*new_start);\n    needed_len += len;\n    if (needed_len > new_start_len) {\n      new_start_len = needed_len + 50;\n      *new_start = xrealloc(*new_start, new_start_len);\n    }\n    new_end = *new_start + len;\n  }\n\n  return new_end;\n}\n\n/// Parse cmd string for :substitute's {flags} and update subflags accordingly\n///\n/// @param[in]      cmd  command string\n/// @param[in,out]  subflags  current flags defined for the :substitute command\n/// @param[in,out]  which_pat  pattern type from which to get default search\n///\n/// @returns pointer to the end of the flags, which may be the end of the string\nstatic char_u *sub_parse_flags(char_u *cmd, subflags_T *subflags,\n                               int *which_pat)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  // Find trailing options.  When '&' is used, keep old options.\n  if (*cmd == '&') {\n    cmd++;\n  } else {\n    subflags->do_all = p_gd;\n    subflags->do_ask = false;\n    subflags->do_error = true;\n    subflags->do_print = false;\n    subflags->do_list = false;\n    subflags->do_count = false;\n    subflags->do_number = false;\n    subflags->do_ic = kSubHonorOptions;\n  }\n  while (*cmd) {\n    // Note that 'g' and 'c' are always inverted.\n    // 'r' is never inverted.\n    if (*cmd == 'g') {\n      subflags->do_all = !subflags->do_all;\n    } else if (*cmd == 'c') {\n      subflags->do_ask = !subflags->do_ask;\n    } else if (*cmd == 'n') {\n      subflags->do_count = true;\n    } else if (*cmd == 'e') {\n      subflags->do_error = !subflags->do_error;\n    } else if (*cmd == 'r') {  // use last used regexp\n      *which_pat = RE_LAST;\n    } else if (*cmd == 'p') {\n      subflags->do_print = true;\n    } else if (*cmd == '#') {\n      subflags->do_print = true;\n      subflags->do_number = true;\n    } else if (*cmd == 'l') {\n      subflags->do_print = true;\n      subflags->do_list = true;\n    } else if (*cmd == 'i') {  // ignore case\n      subflags->do_ic = kSubIgnoreCase;\n    } else if (*cmd == 'I') {  // don't ignore case\n      subflags->do_ic = kSubMatchCase;\n    } else {\n      break;\n    }\n    cmd++;\n  }\n  if (subflags->do_count) {\n    subflags->do_ask = false;\n  }\n\n  return cmd;\n}\n\nstatic int check_regexp_delim(int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (isalpha(c)) {\n    EMSG(_(\"E146: Regular expressions can't be delimited by letters\"));\n    return FAIL;\n  }\n  return OK;\n}\n\n/// Perform a substitution from line eap->line1 to line eap->line2 using the\n/// command pointed to by eap->arg which should be of the form:\n///\n/// /pattern/substitution/{flags}\n///\n/// The usual escapes are supported as described in the regexp docs.\n///\n/// @param do_buf_event If `true`, send buffer updates.\n/// @return buffer used for 'inccommand' preview\nstatic buf_T *do_sub(exarg_T *eap, proftime_T timeout,\n                     bool do_buf_event, handle_T bufnr)\n{\n  long i = 0;\n  regmmatch_T regmatch;\n  static subflags_T subflags = {\n    .do_all = false,\n    .do_ask = false,\n    .do_count = false,\n    .do_error = true,\n    .do_print = false,\n    .do_list = false,\n    .do_number = false,\n    .do_ic = kSubHonorOptions\n  };\n  char_u *pat = NULL, *sub = NULL;  // init for GCC\n  int delimiter;\n  bool has_second_delim = false;\n  int sublen;\n  int got_quit = false;\n  int got_match = false;\n  int which_pat;\n  char_u *cmd = eap->arg;\n  linenr_T first_line = 0;  // first changed line\n  linenr_T last_line= 0;    // below last changed line AFTER the change\n  linenr_T old_line_count = curbuf->b_ml.ml_line_count;\n  char_u *sub_firstline;    // allocated copy of first sub line\n  bool endcolumn = false;   // cursor in last column when done\n  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0 };\n  static int pre_src_id = 0;  // Source id for the preview highlight\n  static int pre_hl_id = 0;\n  buf_T *orig_buf = curbuf;  // save to reset highlighting\n  pos_T old_cursor = curwin->w_cursor;\n  int start_nsubs;\n  int save_ma = 0;\n  int save_b_changed = curbuf->b_changed;\n  bool preview = (State & CMDPREVIEW);\n\n  bool did_save = false;\n\n  if (!global_busy) {\n    sub_nsubs = 0;\n    sub_nlines = 0;\n  }\n  start_nsubs = sub_nsubs;\n\n  if (eap->cmdidx == CMD_tilde)\n    which_pat = RE_LAST;        /* use last used regexp */\n  else\n    which_pat = RE_SUBST;       /* use last substitute regexp */\n\n  /* new pattern and substitution */\n  if (eap->cmd[0] == 's' && *cmd != NUL && !ascii_iswhite(*cmd)\n      && vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL) {\n    // don't accept alphanumeric for separator\n    if (check_regexp_delim(*cmd) == FAIL) {\n      return NULL;\n    }\n\n    // undocumented vi feature:\n    //  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n    //  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n    if (*cmd == '\\\\') {\n      ++cmd;\n      if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {\n        EMSG(_(e_backslash));\n        return NULL;\n      }\n      if (*cmd != '&') {\n        which_pat = RE_SEARCH;              // use last '/' pattern\n      }\n      pat = (char_u *)\"\";                   // empty search pattern\n      delimiter = *cmd++;                   // remember delimiter character\n      has_second_delim = true;\n    } else {          // find the end of the regexp\n      which_pat = RE_LAST;                  // use last used regexp\n      delimiter = *cmd++;                   // remember delimiter character\n      pat = cmd;                            // remember start of search pat\n      cmd = skip_regexp(cmd, delimiter, p_magic, &eap->arg);\n      if (cmd[0] == delimiter) {            // end delimiter found\n        *cmd++ = NUL;                       // replace it with a NUL\n        has_second_delim = true;\n      }\n    }\n\n    /*\n     * Small incompatibility: vi sees '\\n' as end of the command, but in\n     * Vim we want to use '\\n' to find/substitute a NUL.\n     */\n    sub = cmd;              /* remember the start of the substitution */\n\n    while (cmd[0]) {\n      if (cmd[0] == delimiter) {                /* end delimiter found */\n        *cmd++ = NUL;                           /* replace it with a NUL */\n        break;\n      }\n      if (cmd[0] == '\\\\' && cmd[1] != 0) {      // skip escaped characters\n        cmd++;\n      }\n      MB_PTR_ADV(cmd);\n    }\n\n    if (!eap->skip && !preview) {\n      sub_set_replacement((SubReplacementString) {\n        .sub = xstrdup((char *) sub),\n        .timestamp = os_time(),\n        .additional_elements = NULL,\n      });\n    }\n  } else if (!eap->skip) {    /* use previous pattern and substitution */\n    if (old_sub.sub == NULL) {      /* there is no previous command */\n      EMSG(_(e_nopresub));\n      return NULL;\n    }\n    pat = NULL;                 /* search_regcomp() will use previous pattern */\n    sub = (char_u *) old_sub.sub;\n\n    /* Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n     * last column after using \"$\". */\n    endcolumn = (curwin->w_curswant == MAXCOL);\n  }\n\n  if (sub != NULL && sub_joining_lines(eap, pat, sub, cmd, !preview)) {\n    return NULL;\n  }\n\n  cmd = sub_parse_flags(cmd, &subflags, &which_pat);\n\n  bool save_do_all = subflags.do_all;  // remember user specified 'g' flag\n  bool save_do_ask = subflags.do_ask;  // remember user specified 'c' flag\n\n  // check for a trailing count\n  cmd = skipwhite(cmd);\n  if (ascii_isdigit(*cmd)) {\n    i = getdigits_long(&cmd, true, 0);\n    if (i <= 0 && !eap->skip && subflags.do_error) {\n      EMSG(_(e_zerocount));\n      return NULL;\n    }\n    eap->line1 = eap->line2;\n    eap->line2 += i - 1;\n    if (eap->line2 > curbuf->b_ml.ml_line_count)\n      eap->line2 = curbuf->b_ml.ml_line_count;\n  }\n\n  /*\n   * check for trailing command or garbage\n   */\n  cmd = skipwhite(cmd);\n  if (*cmd && *cmd != '\"') {        /* if not end-of-line or comment */\n    eap->nextcmd = check_nextcmd(cmd);\n    if (eap->nextcmd == NULL) {\n      EMSG(_(e_trailing));\n      return NULL;\n    }\n  }\n\n  if (eap->skip) {          // not executing commands, only parsing\n    return NULL;\n  }\n\n  if (!subflags.do_count && !MODIFIABLE(curbuf)) {\n    // Substitution is not allowed in non-'modifiable' buffer\n    EMSG(_(e_modifiable));\n    return NULL;\n  }\n\n  if (search_regcomp(pat, RE_SUBST, which_pat, (preview ? 0 : SEARCH_HIS),\n                     &regmatch) == FAIL) {\n    if (subflags.do_error) {\n      EMSG(_(e_invcmd));\n    }\n    return NULL;\n  }\n\n  // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n  if (subflags.do_ic == kSubIgnoreCase) {\n    regmatch.rmm_ic = true;\n  } else if (subflags.do_ic == kSubMatchCase) {\n    regmatch.rmm_ic = false;\n  }\n\n  sub_firstline = NULL;\n\n  // ~ in the substitute pattern is replaced with the old pattern.\n  // We do it here once to avoid it to be replaced over and over again.\n  // But don't do it when it starts with \"\\=\", then it's an expression.\n  assert(sub != NULL);\n  if (!(sub[0] == '\\\\' && sub[1] == '=')) {\n    sub = regtilde(sub, p_magic);\n  }\n\n  // Check for a match on each line.\n  // If preview: limit to max('cmdwinheight', viewport).\n  linenr_T line2 = eap->line2;\n\n  for (linenr_T lnum = eap->line1;\n       lnum <= line2 && !got_quit && !aborting()\n       && (!preview || preview_lines.lines_needed <= (linenr_T)p_cwh\n           || lnum <= curwin->w_botline);\n       lnum++) {\n    long nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n                                    (colnr_T)0, NULL, NULL);\n    if (nmatch) {\n      colnr_T copycol;\n      colnr_T matchcol;\n      colnr_T prev_matchcol = MAXCOL;\n      char_u      *new_end, *new_start = NULL;\n      char_u      *p1;\n      int did_sub = FALSE;\n      int lastone;\n      long nmatch_tl = 0;               // nr of lines matched below lnum\n      int do_again;                     // do it again after joining lines\n      bool skip_match = false;\n      linenr_T sub_firstlnum;           // nr of first sub line\n\n      /*\n       * The new text is build up step by step, to avoid too much\n       * copying.  There are these pieces:\n       * sub_firstline\tThe old text, unmodified.\n       * copycol\t\tColumn in the old text where we started\n       *\t\t\tlooking for a match; from here old text still\n       *\t\t\tneeds to be copied to the new text.\n       * matchcol\t\tColumn number of the old text where to look\n       *\t\t\tfor the next match.  It's just after the\n       *\t\t\tprevious match or one further.\n       * prev_matchcol\tColumn just after the previous match (if any).\n       *\t\t\tMostly equal to matchcol, except for the first\n       *\t\t\tmatch and after skipping an empty match.\n       * regmatch.*pos\tWhere the pattern matched in the old text.\n       * new_start\tThe new text, all that has been produced so\n       *\t\t\tfar.\n       * new_end\t\tThe new text, where to append new text.\n       *\n       * lnum\t\tThe line number where we found the start of\n       *\t\t\tthe match.  Can be below the line we searched\n       *\t\t\twhen there is a \\n before a \\zs in the\n       *\t\t\tpattern.\n       * sub_firstlnum\tThe line number in the buffer where to look\n       *\t\t\tfor a match.  Can be different from \"lnum\"\n       *\t\t\twhen the pattern or substitute string contains\n       *\t\t\tline breaks.\n       *\n       * Special situations:\n       * - When the substitute string contains a line break, the part up\n       *   to the line break is inserted in the text, but the copy of\n       *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n       *   the inserted lines.\n       * - When the matched pattern contains a line break, the old line\n       *   is taken from the line at the end of the pattern.  The lines\n       *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n       *   accordingly.\n       *\n       * The new text is built up in new_start[].  It has some extra\n       * room to avoid using xmalloc()/free() too often.\n       *\n       * Make a copy of the old line, so it won't be taken away when\n       * updating the screen or handling a multi-line match.  The \"old_\"\n       * pointers point into this copy.\n       */\n      sub_firstlnum = lnum;\n      copycol = 0;\n      matchcol = 0;\n\n      /* At first match, remember current cursor position. */\n      if (!got_match) {\n        setpcmark();\n        got_match = TRUE;\n      }\n\n      /*\n       * Loop until nothing more to replace in this line.\n       * 1. Handle match with empty string.\n       * 2. If subflags.do_ask is set, ask for confirmation.\n       * 3. substitute the string.\n       * 4. if subflags.do_all is set, find next match\n       * 5. break if there isn't another match in this line\n       */\n      for (;; ) {\n        SubResult current_match = {\n          .start = { 0, 0 },\n          .end   = { 0, 0 },\n          .pre_match = 0,\n        };\n        // lnum is where the match start, but maybe not the pattern match,\n        // since we can have \\n before \\zs in the pattern\n\n        // Advance \"lnum\" to the line where the match starts.  The\n        // match does not start in the first line when there is a line\n        // break before \\zs.\n        if (regmatch.startpos[0].lnum > 0) {\n          current_match.pre_match = lnum;\n          lnum += regmatch.startpos[0].lnum;\n          sub_firstlnum += regmatch.startpos[0].lnum;\n          nmatch -= regmatch.startpos[0].lnum;\n          XFREE_CLEAR(sub_firstline);\n        }\n\n        // Now we're at the line where the pattern match starts\n        // Note: If not first match on a line, column can't be known here\n        current_match.start.lnum = sub_firstlnum;\n\n        // Match might be after the last line for \"\\n\\zs\" matching at\n        // the end of the last line.\n        if (lnum > curbuf->b_ml.ml_line_count) {\n          break;\n        }\n        if (sub_firstline == NULL) {\n          sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n        }\n\n        /* Save the line number of the last change for the final\n         * cursor position (just like Vi). */\n        curwin->w_cursor.lnum = lnum;\n        do_again = FALSE;\n\n        /*\n         * 1. Match empty string does not count, except for first\n         * match.  This reproduces the strange vi behaviour.\n         * This also catches endless loops.\n         */\n        if (matchcol == prev_matchcol\n            && regmatch.endpos[0].lnum == 0\n            && matchcol == regmatch.endpos[0].col) {\n          if (sub_firstline[matchcol] == NUL) {\n            // We already were at the end of the line.  Don't look\n            // for a match in this line again.\n            skip_match = true;\n          } else {\n            // search for a match at next column\n            matchcol += mb_ptr2len(sub_firstline + matchcol);\n          }\n          // match will be pushed to preview_lines, bring it into a proper state\n          current_match.start.col = matchcol;\n          current_match.end.lnum = sub_firstlnum;\n          current_match.end.col = matchcol;\n          goto skip;\n        }\n\n        /* Normally we continue searching for a match just after the\n         * previous match. */\n        matchcol = regmatch.endpos[0].col;\n        prev_matchcol = matchcol;\n\n        // 2. If subflags.do_count is set only increase the counter.\n        //    If do_ask is set, ask for confirmation.\n        if (subflags.do_count) {\n          // For a multi-line match, put matchcol at the NUL at\n          // the end of the line and set nmatch to one, so that\n          // we continue looking for a match on the next line.\n          // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n          if (nmatch > 1) {\n            matchcol = (colnr_T)STRLEN(sub_firstline);\n            nmatch = 1;\n            skip_match = true;\n          }\n          sub_nsubs++;\n          did_sub = TRUE;\n          /* Skip the substitution, unless an expression is used,\n           * then it is evaluated in the sandbox. */\n          if (!(sub[0] == '\\\\' && sub[1] == '='))\n            goto skip;\n        }\n\n        if (subflags.do_ask && !preview) {\n          int typed = 0;\n\n          /* change State to CONFIRM, so that the mouse works\n           * properly */\n          int save_State = State;\n          State = CONFIRM;\n          setmouse();                   /* disable mouse in xterm */\n          curwin->w_cursor.col = regmatch.startpos[0].col;\n\n          if (curwin->w_p_crb) {\n            do_check_cursorbind();\n          }\n\n          /* When 'cpoptions' contains \"u\" don't sync undo when\n           * asking for confirmation. */\n          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n            ++no_u_sync;\n\n          /*\n           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n           */\n          while (subflags.do_ask) {\n            if (exmode_active) {\n              char        *prompt;\n              char_u      *resp;\n              colnr_T sc, ec;\n\n              print_line_no_prefix(lnum, subflags.do_number, subflags.do_list);\n\n              getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n              curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n              if (curwin->w_cursor.col < 0) {\n                curwin->w_cursor.col = 0;\n              }\n              getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n              if (subflags.do_number || curwin->w_p_nu) {\n                int numw = number_width(curwin) + 1;\n                sc += numw;\n                ec += numw;\n              }\n\n              prompt = xmallocz(ec + 1);\n              memset(prompt, ' ', sc);\n              memset(prompt + sc, '^', ec - sc + 1);\n              resp = (char_u *)getcmdline_prompt(NUL, prompt, 0, EXPAND_NOTHING,\n                                                 NULL, CALLBACK_NONE);\n              msg_putchar('\\n');\n              xfree(prompt);\n              if (resp != NULL) {\n                typed = *resp;\n                xfree(resp);\n              }\n            } else {\n              char_u *orig_line = NULL;\n              int len_change = 0;\n              const bool save_p_lz = p_lz;\n              int save_p_fen = curwin->w_p_fen;\n\n              curwin->w_p_fen = FALSE;\n              /* Invert the matched string.\n               * Remove the inversion afterwards. */\n              int temp = RedrawingDisabled;\n              RedrawingDisabled = 0;\n\n              // avoid calling update_screen() in vgetorpeek()\n              p_lz = false;\n\n              if (new_start != NULL) {\n                /* There already was a substitution, we would\n                 * like to show this to the user.  We cannot\n                 * really update the line, it would change\n                 * what matches.  Temporarily replace the line\n                 * and change it back afterwards. */\n                orig_line = vim_strsave(ml_get(lnum));\n                char_u *new_line = concat_str(new_start, sub_firstline + copycol);\n\n                // Position the cursor relative to the end of the line, the\n                // previous substitute may have inserted or deleted characters\n                // before the cursor.\n                len_change = (int)STRLEN(new_line) - (int)STRLEN(orig_line);\n                curwin->w_cursor.col += len_change;\n                ml_replace(lnum, new_line, false);\n              }\n\n              search_match_lines = regmatch.endpos[0].lnum\n                                   - regmatch.startpos[0].lnum;\n              search_match_endcol = regmatch.endpos[0].col\n                                    + len_change;\n              highlight_match = TRUE;\n\n              update_topline(curwin);\n              validate_cursor();\n              update_screen(SOME_VALID);\n              highlight_match = false;\n              redraw_later(curwin, SOME_VALID);\n\n              curwin->w_p_fen = save_p_fen;\n              if (msg_row == Rows - 1) {\n                msg_didout = false;                     // avoid a scroll-up\n              }\n              msg_starthere();\n              i = msg_scroll;\n              msg_scroll = 0;                           /* truncate msg when\n                                                           needed */\n              msg_no_more = true;\n              msg_ext_set_kind(\"confirm_sub\");\n              smsg_attr(HL_ATTR(HLF_R),  // Same highlight as wait_return().\n                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n              msg_no_more = FALSE;\n              msg_scroll = i;\n              showruler(true);\n              ui_cursor_goto(msg_row, msg_col);\n              RedrawingDisabled = temp;\n\n              no_mapping++;                     // don't map this key\n              typed = plain_vgetc();\n              no_mapping--;\n\n              // clear the question\n              msg_didout = false;               // don't scroll up\n              msg_col = 0;\n              gotocmdline(true);\n              p_lz = save_p_lz;\n\n              // restore the line\n              if (orig_line != NULL) {\n                ml_replace(lnum, orig_line, false);\n              }\n            }\n\n            need_wait_return = false;             // no hit-return prompt\n            if (typed == 'q' || typed == ESC || typed == Ctrl_C) {\n              got_quit = true;\n              break;\n            }\n            if (typed == 'n')\n              break;\n            if (typed == 'y')\n              break;\n            if (typed == 'l') {\n              // last: replace and then stop\n              subflags.do_all = false;\n              line2 = lnum;\n              break;\n            }\n            if (typed == 'a') {\n              subflags.do_ask = false;\n              break;\n            }\n            if (typed == Ctrl_E)\n              scrollup_clamp();\n            else if (typed == Ctrl_Y)\n              scrolldown_clamp();\n          }\n          State = save_State;\n          setmouse();\n          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n            --no_u_sync;\n\n          if (typed == 'n') {\n            /* For a multi-line match, put matchcol at the NUL at\n             * the end of the line and set nmatch to one, so that\n             * we continue looking for a match on the next line.\n             * Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n             * get stuck when pressing 'n'. */\n            if (nmatch > 1) {\n              matchcol = (colnr_T)STRLEN(sub_firstline);\n              skip_match = true;\n            }\n            goto skip;\n          }\n          if (got_quit)\n            goto skip;\n        }\n\n        /* Move the cursor to the start of the match, so that we can\n         * use \"\\=col(\".\"). */\n        curwin->w_cursor.col = regmatch.startpos[0].col;\n\n        // When the match included the \"$\" of the last line it may\n        // go beyond the last line of the buffer.\n        if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1) {\n          nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n          current_match.end.lnum = sub_firstlnum + nmatch;\n          skip_match = true;\n        }\n\n#define ADJUST_SUB_FIRSTLNUM() \\\n        do { \\\n          /* For a multi-line match, make a copy of the last matched */ \\\n          /* line and continue in that one. */ \\\n          if (nmatch > 1) { \\\n            sub_firstlnum += nmatch - 1; \\\n            xfree(sub_firstline); \\\n            sub_firstline = vim_strsave(ml_get(sub_firstlnum)); \\\n            /* When going beyond the last line, stop substituting. */ \\\n            if (sub_firstlnum <= line2) { \\\n              do_again = true; \\\n            } else { \\\n              subflags.do_all = false; \\\n            } \\\n          } \\\n          if (skip_match) { \\\n            /* Already hit end of the buffer, sub_firstlnum is one */ \\\n            /* less than what it ought to be. */ \\\n            xfree(sub_firstline); \\\n            sub_firstline = vim_strsave((char_u *)\"\"); \\\n            copycol = 0; \\\n          } \\\n        } while (0)\n\n        // Save the line numbers for the preview buffer\n        // NOTE: If the pattern matches a final newline, the next line will\n        // be shown also, but should not be highlighted. Intentional for now.\n        if (preview && !has_second_delim) {\n          current_match.start.col = regmatch.startpos[0].col;\n          if (current_match.end.lnum == 0) {\n            current_match.end.lnum = sub_firstlnum + nmatch - 1;\n          }\n          current_match.end.col  = regmatch.endpos[0].col;\n\n          ADJUST_SUB_FIRSTLNUM();\n          lnum += nmatch - 1;\n\n          goto skip;\n        }\n\n\n        // 3. Substitute the string. During 'inccommand' preview only do this if\n        //    there is a replace pattern.\n        if (!preview || has_second_delim) {\n          long lnum_start = lnum;  // save the start lnum\n          save_ma = curbuf->b_p_ma;\n          if (subflags.do_count) {\n            // prevent accidentally changing the buffer by a function\n            curbuf->b_p_ma = false;\n            sandbox++;\n          }\n          // Save flags for recursion.  They can change for e.g.\n          // :s/^/\\=execute(\"s#^##gn\")\n          subflags_T subflags_save = subflags;\n          // get length of substitution part\n          sublen = vim_regsub_multi(&regmatch,\n                                    sub_firstlnum - regmatch.startpos[0].lnum,\n                                    sub, sub_firstline, false, p_magic, true);\n          // If getting the substitute string caused an error, don't do\n          // the replacement.\n          // Don't keep flags set by a recursive call\n          subflags = subflags_save;\n          if (aborting() || subflags.do_count) {\n            curbuf->b_p_ma = save_ma;\n            if (sandbox > 0) {\n              sandbox--;\n            }\n            goto skip;\n          }\n\n          // Need room for:\n          // - result so far in new_start (not for first sub in line)\n          // - original text up to match\n          // - length of substituted part\n          // - original text after match\n          if (nmatch == 1) {\n            p1 = sub_firstline;\n          } else {\n            p1 = ml_get(sub_firstlnum + nmatch - 1);\n            nmatch_tl += nmatch - 1;\n          }\n          size_t copy_len = regmatch.startpos[0].col - copycol;\n          new_end = sub_grow_buf(&new_start,\n                                 (STRLEN(p1) - regmatch.endpos[0].col)\n                                 + copy_len + sublen + 1);\n\n          // copy the text up to the part that matched\n          memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n          new_end += copy_len;\n\n          // Finally, at this point we can know where the match actually will\n          // start in the new text\n          int start_col = new_end - new_start;\n          current_match.start.col = start_col;\n\n          (void)vim_regsub_multi(&regmatch,\n                                 sub_firstlnum - regmatch.startpos[0].lnum,\n                                 sub, new_end, true, p_magic, true);\n          sub_nsubs++;\n          did_sub = true;\n\n          // Move the cursor to the start of the line, to avoid that it\n          // is beyond the end of the line after the substitution.\n          curwin->w_cursor.col = 0;\n\n          // Remember next character to be copied.\n          copycol = regmatch.endpos[0].col;\n\n          ADJUST_SUB_FIRSTLNUM();\n\n          // TODO(bfredl): this has some robustness issues, look into later.\n          bcount_t replaced_bytes = 0;\n          lpos_T start = regmatch.startpos[0], end = regmatch.endpos[0];\n          for (i = 0; i < nmatch-1; i++) {\n            replaced_bytes += STRLEN(ml_get(lnum_start+i)) + 1;\n          }\n          replaced_bytes += end.col - start.col;\n\n\n          // Now the trick is to replace CTRL-M chars with a real line\n          // break.  This would make it impossible to insert a CTRL-M in\n          // the text.  The line break can be avoided by preceding the\n          // CTRL-M with a backslash.  To be able to insert a backslash,\n          // they must be doubled in the string and are halved here.\n          // That is Vi compatible.\n          for (p1 = new_end; *p1; p1++) {\n            if (p1[0] == '\\\\' && p1[1] != NUL) {            // remove backslash\n              STRMOVE(p1, p1 + 1);\n            } else if (*p1 == CAR) {\n              if (u_inssub(lnum) == OK) {             // prepare for undo\n                *p1 = NUL;                            // truncate up to the CR\n                ml_append(lnum - 1, new_start,\n                          (colnr_T)(p1 - new_start + 1), false);\n                mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L, kExtmarkNOOP);\n\n                if (subflags.do_ask) {\n                  appended_lines(lnum - 1, 1L);\n                } else {\n                  if (first_line == 0) {\n                    first_line = lnum;\n                  }\n                  last_line = lnum + 1;\n                }\n                // All line numbers increase.\n                sub_firstlnum++;\n                lnum++;\n                line2++;\n                // move the cursor to the new line, like Vi\n                curwin->w_cursor.lnum++;\n                // copy the rest\n                STRMOVE(new_start, p1 + 1);\n                p1 = new_start - 1;\n              }\n            } else {\n              p1 += utfc_ptr2len(p1) - 1;\n            }\n          }\n          size_t new_endcol = STRLEN(new_start);\n          current_match.end.col = new_endcol;\n          current_match.end.lnum = lnum;\n\n          int matchcols = end.col - ((end.lnum == start.lnum)\n                                     ? start.col : 0);\n          int subcols = new_endcol - ((lnum == lnum_start) ? start_col : 0);\n          if (!did_save) {\n            // Required for Undo to work for extmarks.\n            u_save_cursor();\n            did_save = true;\n          }\n          extmark_splice(curbuf, lnum_start-1, start_col,\n                         end.lnum-start.lnum, matchcols, replaced_bytes,\n                         lnum-lnum_start, subcols, sublen-1, kExtmarkUndo);\n        }\n\n\n        // 4. If subflags.do_all is set, find next match.\n        // Prevent endless loop with patterns that match empty\n        // strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n        // But \":s/\\n/#/\" is OK.\nskip:\n        /* We already know that we did the last subst when we are at\n         * the end of the line, except that a pattern like\n         * \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n         * \"line2\" when there is a \\zs in the pattern after a line\n         * break. */\n        lastone = (skip_match\n                   || got_int\n                   || got_quit\n                   || lnum > line2\n                   || !(subflags.do_all || do_again)\n                   || (sub_firstline[matchcol] == NUL && nmatch <= 1\n                       && !re_multiline(regmatch.regprog)));\n        nmatch = -1;\n\n        /*\n         * Replace the line in the buffer when needed.  This is\n         * skipped when there are more matches.\n         * The check for nmatch_tl is needed for when multi-line\n         * matching must replace the lines before trying to do another\n         * match, otherwise \"\\@<=\" won't work.\n         * When the match starts below where we start searching also\n         * need to replace the line first (using \\zs after \\n).\n         */\n        if (lastone\n            || nmatch_tl > 0\n            || (nmatch = vim_regexec_multi(&regmatch, curwin,\n                                           curbuf, sub_firstlnum,\n                                           matchcol, NULL, NULL)) == 0\n            || regmatch.startpos[0].lnum > 0) {\n          if (new_start != NULL) {\n            /*\n             * Copy the rest of the line, that didn't match.\n             * \"matchcol\" has to be adjusted, we use the end of\n             * the line as reference, because the substitute may\n             * have changed the number of characters.  Same for\n             * \"prev_matchcol\".\n             */\n            STRCAT(new_start, sub_firstline + copycol);\n            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n            prev_matchcol = (colnr_T)STRLEN(sub_firstline)\n                            - prev_matchcol;\n\n            if (u_savesub(lnum) != OK) {\n              break;\n            }\n            ml_replace(lnum, new_start, true);\n\n            if (nmatch_tl > 0) {\n              /*\n               * Matched lines have now been substituted and are\n               * useless, delete them.  The part after the match\n               * has been appended to new_start, we don't need\n               * it in the buffer.\n               */\n              ++lnum;\n              if (u_savedel(lnum, nmatch_tl) != OK)\n                break;\n              for (i = 0; i < nmatch_tl; i++) {\n                ml_delete(lnum, false);\n              }\n              mark_adjust(lnum, lnum + nmatch_tl - 1,\n                          (long)MAXLNUM, -nmatch_tl, kExtmarkNOOP);\n              if (subflags.do_ask) {\n                deleted_lines(lnum, nmatch_tl);\n              }\n              lnum--;\n              line2 -= nmatch_tl;  // nr of lines decreases\n              nmatch_tl = 0;\n            }\n\n            /* When asking, undo is saved each time, must also set\n             * changed flag each time. */\n            if (subflags.do_ask) {\n              changed_bytes(lnum, 0);\n            } else {\n              if (first_line == 0) {\n                first_line = lnum;\n              }\n              last_line = lnum + 1;\n            }\n\n            sub_firstlnum = lnum;\n            xfree(sub_firstline);                /* free the temp buffer */\n            sub_firstline = new_start;\n            new_start = NULL;\n            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n            prev_matchcol = (colnr_T)STRLEN(sub_firstline)\n                            - prev_matchcol;\n            copycol = 0;\n          }\n          if (nmatch == -1 && !lastone)\n            nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n                                       sub_firstlnum, matchcol, NULL, NULL);\n\n          /*\n           * 5. break if there isn't another match in this line\n           */\n          if (nmatch <= 0) {\n            /* If the match found didn't start where we were\n             * searching, do the next search in the line where we\n             * found the match. */\n            if (nmatch == -1)\n              lnum -= regmatch.startpos[0].lnum;\n\n#define PUSH_PREVIEW_LINES() \\\n            do { \\\n              linenr_T match_lines = current_match.end.lnum \\\n                                     - current_match.start.lnum +1; \\\n              if (preview_lines.subresults.size > 0) { \\\n                linenr_T last = kv_last(preview_lines.subresults).end.lnum; \\\n                if (last == current_match.start.lnum) { \\\n                  preview_lines.lines_needed += match_lines - 1; \\\n                } \\\n              } else { \\\n                preview_lines.lines_needed += match_lines; \\\n              } \\\n              kv_push(preview_lines.subresults, current_match); \\\n            } while (0)\n\n            // Push the match to preview_lines.\n            PUSH_PREVIEW_LINES();\n\n            break;\n          }\n        }\n        // Push the match to preview_lines.\n        PUSH_PREVIEW_LINES();\n\n        line_breakcheck();\n      }\n\n      if (did_sub) {\n        sub_nlines++;\n      }\n      xfree(new_start);              // for when substitute was cancelled\n      XFREE_CLEAR(sub_firstline);    // free the copy of the original line\n    }\n\n    line_breakcheck();\n\n    if (profile_passed_limit(timeout)) {\n      got_quit = true;\n    }\n  }\n\n  curbuf->deleted_bytes2 = 0;\n\n  if (first_line != 0) {\n    /* Need to subtract the number of added lines from \"last_line\" to get\n     * the line number before the change (same as adding the number of\n     * deleted lines). */\n    i = curbuf->b_ml.ml_line_count - old_line_count;\n    changed_lines(first_line, 0, last_line - i, i, false);\n\n    int64_t num_added = last_line - first_line;\n    int64_t num_removed = num_added - i;\n    buf_updates_send_changes(curbuf, first_line, num_added, num_removed,\n                             do_buf_event);\n  }\n\n  xfree(sub_firstline);   /* may have to free allocated copy of the line */\n\n  // \":s/pat//n\" doesn't move the cursor\n  if (subflags.do_count) {\n    curwin->w_cursor = old_cursor;\n  }\n\n  if (sub_nsubs > start_nsubs) {\n    /* Set the '[ and '] marks. */\n    curbuf->b_op_start.lnum = eap->line1;\n    curbuf->b_op_end.lnum = line2;\n    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\n    if (!global_busy) {\n      // when interactive leave cursor on the match\n      if (!subflags.do_ask) {\n        if (endcolumn) {\n          coladvance(MAXCOL);\n        } else {\n          beginline(BL_WHITE | BL_FIX);\n        }\n      }\n      if (!preview && !do_sub_msg(subflags.do_count) && subflags.do_ask) {\n        MSG(\"\");\n      }\n    } else {\n      global_need_beginline = true;\n    }\n    if (subflags.do_print) {\n      print_line(curwin->w_cursor.lnum, subflags.do_number, subflags.do_list);\n    }\n  } else if (!global_busy) {\n    if (got_int) {\n      // interrupted\n      EMSG(_(e_interr));\n    } else if (got_match) {\n      // did find something but nothing substituted\n      MSG(\"\");\n    } else if (subflags.do_error) {\n      // nothing found\n      EMSG2(_(e_patnotf2), get_search_pat());\n    }\n  }\n\n  if (subflags.do_ask && hasAnyFolding(curwin)) {\n    // Cursor position may require updating\n    changed_window_setting();\n  }\n\n  vim_regfree(regmatch.regprog);\n\n  // Restore the flag values, they can be used for \":&&\".\n  subflags.do_all = save_do_all;\n  subflags.do_ask = save_do_ask;\n\n  // Show 'inccommand' preview if there are matched lines.\n  buf_T *preview_buf = NULL;\n  size_t subsize = preview_lines.subresults.size;\n  if (preview && !aborting()) {\n    if (got_quit || profile_passed_limit(timeout)) {  // Too slow, disable.\n      set_string_option_direct(\"icm\", -1, (char_u *)\"\", OPT_FREE,\n                               SID_NONE);\n    } else if (*p_icm != NUL &&  pat != NULL) {\n      if (pre_src_id == 0) {\n        // Get a unique new src_id, saved in a static\n        pre_src_id = (int)nvim_create_namespace((String)STRING_INIT);\n      }\n      if (pre_hl_id == 0) {\n        pre_hl_id = syn_check_group((char_u *)S_LEN(\"Substitute\"));\n      }\n      curbuf->b_changed = save_b_changed;  // preserve 'modified' during preview\n      preview_buf = show_sub(eap, old_cursor, &preview_lines,\n                             pre_hl_id, pre_src_id, bufnr);\n      if (subsize > 0) {\n        extmark_clear(orig_buf, pre_src_id, eap->line1-1, 0,\n                      kv_last(preview_lines.subresults).end.lnum-1, MAXCOL);\n      }\n    }\n  }\n\n  kv_destroy(preview_lines.subresults);\n\n  return preview_buf;\n#undef ADJUST_SUB_FIRSTLNUM\n#undef PUSH_PREVIEW_LINES\n}  // NOLINT(readability/fn_size)\n\n/*\n * Give message for number of substitutions.\n * Can also be used after a \":global\" command.\n * Return TRUE if a message was given.\n */\nbool\ndo_sub_msg (\n    bool count_only                /* used 'n' flag for \":s\" */\n)\n{\n  /*\n   * Only report substitutions when:\n   * - more than 'report' substitutions\n   * - command was typed by user, or number of changed lines > 'report'\n   * - giving messages is not disabled by 'lazyredraw'\n   */\n  if (((sub_nsubs > p_report && (KeyTyped || sub_nlines > 1 || p_report < 1))\n       || count_only)\n      && messaging()) {\n    if (got_int)\n      STRCPY(msg_buf, _(\"(Interrupted) \"));\n    else\n      *msg_buf = NUL;\n    if (sub_nsubs == 1)\n      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),\n          \"%s\", count_only ? _(\"1 match\") : _(\"1 substitution\"));\n    else\n      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),\n          count_only ? _(\"%\" PRId64 \" matches\")\n                     : _(\"%\" PRId64 \" substitutions\"),\n          (int64_t)sub_nsubs);\n    if (sub_nlines == 1)\n      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),\n          \"%s\", _(\" on 1 line\"));\n    else\n      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),\n          _(\" on %\" PRId64 \" lines\"), (int64_t)sub_nlines);\n    if (msg(msg_buf))\n      /* save message to display it after redraw */\n      set_keep_msg(msg_buf, 0);\n    return true;\n  }\n  if (got_int) {\n    EMSG(_(e_interr));\n    return true;\n  }\n  return false;\n}\n\nstatic void global_exe_one(char_u *const cmd, const linenr_T lnum)\n{\n  curwin->w_cursor.lnum = lnum;\n  curwin->w_cursor.col = 0;\n  if (*cmd == NUL || *cmd == '\\n') {\n    do_cmdline((char_u *)\"p\", NULL, NULL, DOCMD_NOWAIT);\n  } else {\n    do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);\n  }\n}\n\n/*\n * Execute a global command of the form:\n *\n * g/pattern/X : execute X on all lines where pattern matches\n * v/pattern/X : execute X on all lines where pattern does not match\n *\n * where 'X' is an EX command\n *\n * The command character (as well as the trailing slash) is optional, and\n * is assumed to be 'p' if missing.\n *\n * This is implemented in two passes: first we scan the file for the pattern and\n * set a mark for each line that (not) matches. Secondly we execute the command\n * for each line that has a mark. This is required because after deleting\n * lines we do not know where to search for the next match.\n */\nvoid ex_global(exarg_T *eap)\n{\n  linenr_T lnum;                /* line number according to old situation */\n  int ndone = 0;\n  int type;                     /* first char of cmd: 'v' or 'g' */\n  char_u      *cmd;             /* command argument */\n\n  char_u delim;                 /* delimiter, normally '/' */\n  char_u      *pat;\n  regmmatch_T regmatch;\n  int match;\n  int which_pat;\n\n  // When nesting the command works on one line.  This allows for\n  // \":g/found/v/notfound/command\".\n  if (global_busy && (eap->line1 != 1\n                      || eap->line2 != curbuf->b_ml.ml_line_count)) {\n    // will increment global_busy to break out of the loop\n    EMSG(_(\"E147: Cannot do :global recursive with a range\"));\n    return;\n  }\n\n  if (eap->forceit)                 /* \":global!\" is like \":vglobal\" */\n    type = 'v';\n  else\n    type = *eap->cmd;\n  cmd = eap->arg;\n  which_pat = RE_LAST;              /* default: use last used regexp */\n\n  /*\n   * undocumented vi feature:\n   *\t\"\\/\" and \"\\?\": use previous search pattern.\n   *\t\t \"\\&\": use previous substitute pattern.\n   */\n  if (*cmd == '\\\\') {\n    ++cmd;\n    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL) {\n      EMSG(_(e_backslash));\n      return;\n    }\n    if (*cmd == '&')\n      which_pat = RE_SUBST;             /* use previous substitute pattern */\n    else\n      which_pat = RE_SEARCH;            /* use previous search pattern */\n    ++cmd;\n    pat = (char_u *)\"\";\n  } else if (*cmd == NUL) {\n    EMSG(_(\"E148: Regular expression missing from global\"));\n    return;\n  } else if (check_regexp_delim(*cmd) == FAIL) {\n    return;\n  } else {\n    delim = *cmd;               /* get the delimiter */\n    if (delim)\n      ++cmd;                    /* skip delimiter if there is one */\n    pat = cmd;                  /* remember start of pattern */\n    cmd = skip_regexp(cmd, delim, p_magic, &eap->arg);\n    if (cmd[0] == delim)                    /* end delimiter found */\n      *cmd++ = NUL;                         /* replace it with a NUL */\n  }\n\n  if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL) {\n    EMSG(_(e_invcmd));\n    return;\n  }\n\n  if (global_busy) {\n    lnum = curwin->w_cursor.lnum;\n    match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n                              (colnr_T)0, NULL, NULL);\n    if ((type == 'g' && match) || (type == 'v' && !match)) {\n      global_exe_one(cmd, lnum);\n    }\n  } else {\n    // pass 1: set marks for each (not) matching line\n    for (lnum = eap->line1; lnum <= eap->line2 && !got_int; lnum++) {\n      // a match on this line?\n      match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n                                (colnr_T)0, NULL, NULL);\n      if ((type == 'g' && match) || (type == 'v' && !match)) {\n        ml_setmarked(lnum);\n        ndone++;\n      }\n      line_breakcheck();\n    }\n\n    // pass 2: execute the command for each line that has been marked\n    if (got_int) {\n      MSG(_(e_interr));\n    } else if (ndone == 0) {\n      if (type == 'v') {\n        smsg(_(\"Pattern found in every line: %s\"), pat);\n      } else {\n        smsg(_(\"Pattern not found: %s\"), pat);\n      }\n    } else {\n      global_exe(cmd);\n    }\n    ml_clearmarked();         // clear rest of the marks\n  }\n  vim_regfree(regmatch.regprog);\n}\n\n/// Execute `cmd` on lines marked with ml_setmarked().\nvoid global_exe(char_u *cmd)\n{\n  linenr_T old_lcount;      // b_ml.ml_line_count before the command\n  buf_T *old_buf = curbuf;  // remember what buffer we started in\n  linenr_T lnum;            // line number according to old situation\n  int save_mapped_ctrl_c = mapped_ctrl_c;\n\n  // Set current position only once for a global command.\n  // If global_busy is set, setpcmark() will not do anything.\n  // If there is an error, global_busy will be incremented.\n  setpcmark();\n\n  // When the command writes a message, don't overwrite the command.\n  msg_didout = true;\n  // Disable CTRL-C mapping, let it interrupt (potentially long output).\n  mapped_ctrl_c = 0;\n\n  sub_nsubs = 0;\n  sub_nlines = 0;\n  global_need_beginline = false;\n  global_busy = 1;\n  old_lcount = curbuf->b_ml.ml_line_count;\n\n  while (!got_int && (lnum = ml_firstmarked()) != 0 && global_busy == 1) {\n    global_exe_one(cmd, lnum);\n    os_breakcheck();\n  }\n\n  mapped_ctrl_c = save_mapped_ctrl_c;\n  global_busy = 0;\n  if (global_need_beginline) {\n    beginline(BL_WHITE | BL_FIX);\n  } else {\n    check_cursor();  // cursor may be beyond the end of the line\n  }\n\n  // the cursor may not have moved in the text but a change in a previous\n  // line may move it on the screen\n  changed_line_abv_curs();\n\n  // If it looks like no message was written, allow overwriting the\n  // command with the report for number of changes.\n  if (msg_col == 0 && msg_scrolled == 0) {\n    msg_didout = false;\n  }\n\n  // If substitutes done, report number of substitutes, otherwise report\n  // number of extra or deleted lines.\n  // Don't report extra or deleted lines in the edge case where the buffer\n  // we are in after execution is different from the buffer we started in.\n  if (!do_sub_msg(false) && curbuf == old_buf) {\n    msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n  }\n}\n\n#if defined(EXITFREE)\nvoid free_old_sub(void)\n{\n  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});\n}\n\n#endif\n\n/*\n * Set up for a tagpreview.\n * Return TRUE when it was created.\n */\nbool\nprepare_tagpreview (\n    bool undo_sync                  /* sync undo when leaving the window */\n)\n{\n  /*\n   * If there is already a preview window open, use that one.\n   */\n  if (!curwin->w_p_pvw) {\n    bool found_win = false;\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_p_pvw) {\n        win_enter(wp, undo_sync);\n        found_win = true;\n        break;\n      }\n    }\n    if (!found_win) {\n      /*\n       * There is no preview window open yet.  Create one.\n       */\n      if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0)\n          == FAIL)\n        return false;\n      curwin->w_p_pvw = TRUE;\n      curwin->w_p_wfh = TRUE;\n      RESET_BINDING(curwin);                /* don't take over 'scrollbind'\n                                               and 'cursorbind' */\n      curwin->w_p_diff = false;             // no 'diff'\n      set_string_option_direct(\"fdc\", -1,     // no 'foldcolumn'\n                               (char_u *)\"0\", OPT_FREE, SID_NONE);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n\n/*\n * \":help\": open a read-only window on a help file\n */\nvoid ex_help(exarg_T *eap)\n{\n  char_u      *arg;\n  char_u      *tag;\n  FILE        *helpfd;          /* file descriptor of help file */\n  int n;\n  int i;\n  win_T       *wp;\n  int num_matches;\n  char_u      **matches;\n  char_u      *p;\n  int empty_fnum = 0;\n  int alt_fnum = 0;\n  buf_T       *buf;\n  int len;\n  char_u      *lang;\n  const bool old_KeyTyped = KeyTyped;\n\n  if (eap != NULL) {\n    /*\n     * A \":help\" command ends at the first LF, or at a '|' that is\n     * followed by some text.  Set nextcmd to the following command.\n     */\n    for (arg = eap->arg; *arg; ++arg) {\n      if (*arg == '\\n' || *arg == '\\r'\n          || (*arg == '|' && arg[1] != NUL && arg[1] != '|')) {\n        *arg++ = NUL;\n        eap->nextcmd = arg;\n        break;\n      }\n    }\n    arg = eap->arg;\n\n    if (eap->forceit && *arg == NUL && !curbuf->b_help) {\n      EMSG(_(\"E478: Don't panic!\"));\n      return;\n    }\n\n    if (eap->skip)          /* not executing commands */\n      return;\n  } else\n    arg = (char_u *)\"\";\n\n  /* remove trailing blanks */\n  p = arg + STRLEN(arg) - 1;\n  while (p > arg && ascii_iswhite(*p) && p[-1] != '\\\\')\n    *p-- = NUL;\n\n  /* Check for a specified language */\n  lang = check_help_lang(arg);\n\n  /* When no argument given go to the index. */\n  if (*arg == NUL)\n    arg = (char_u *)\"help.txt\";\n\n  /*\n   * Check if there is a match for the argument.\n   */\n  n = find_help_tags(arg, &num_matches, &matches,\n      eap != NULL && eap->forceit);\n\n  i = 0;\n  if (n != FAIL && lang != NULL)\n    /* Find first item with the requested language. */\n    for (i = 0; i < num_matches; ++i) {\n      len = (int)STRLEN(matches[i]);\n      if (len > 3 && matches[i][len - 3] == '@'\n          && STRICMP(matches[i] + len - 2, lang) == 0)\n        break;\n    }\n  if (i >= num_matches || n == FAIL) {\n    if (lang != NULL)\n      EMSG3(_(\"E661: Sorry, no '%s' help for %s\"), lang, arg);\n    else\n      EMSG2(_(\"E149: Sorry, no help for %s\"), arg);\n    if (n != FAIL)\n      FreeWild(num_matches, matches);\n    return;\n  }\n\n  /* The first match (in the requested language) is the best match. */\n  tag = vim_strsave(matches[i]);\n  FreeWild(num_matches, matches);\n\n  /*\n   * Re-use an existing help window or open a new one.\n   * Always open a new one for \":tab help\".\n   */\n  if (!bt_help(curwin->w_buffer)\n      || cmdmod.tab != 0\n      ) {\n    if (cmdmod.tab != 0) {\n      wp = NULL;\n    } else {\n      wp = NULL;\n      FOR_ALL_WINDOWS_IN_TAB(wp2, curtab) {\n        if (bt_help(wp2->w_buffer)) {\n          wp = wp2;\n          break;\n        }\n      }\n    }\n    if (wp != NULL && wp->w_buffer->b_nwindows > 0) {\n      win_enter(wp, true);\n    } else {\n      // There is no help window yet.\n      // Try to open the file specified by the \"helpfile\" option.\n      if ((helpfd = os_fopen((char *)p_hf, READBIN)) == NULL) {\n        smsg(_(\"Sorry, help file \\\"%s\\\" not found\"), p_hf);\n        goto erret;\n      }\n      fclose(helpfd);\n\n      /* Split off help window; put it at far top if no position\n       * specified, the current window is vertically split and\n       * narrow. */\n      n = WSP_HELP;\n      if (cmdmod.split == 0 && curwin->w_width != Columns\n          && curwin->w_width < 80)\n        n |= WSP_TOP;\n      if (win_split(0, n) == FAIL)\n        goto erret;\n\n      if (curwin->w_height < p_hh)\n        win_setheight((int)p_hh);\n\n      /*\n       * Open help file (do_ecmd() will set b_help flag, readfile() will\n       * set b_p_ro flag).\n       * Set the alternate file to the previously edited file.\n       */\n      alt_fnum = curbuf->b_fnum;\n      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,\n          ECMD_HIDE + ECMD_SET_HELP,\n          NULL                  /* buffer is still open, don't store info */\n          );\n      if (!cmdmod.keepalt)\n        curwin->w_alt_fnum = alt_fnum;\n      empty_fnum = curbuf->b_fnum;\n    }\n  }\n\n  if (!p_im)\n    restart_edit = 0;               /* don't want insert mode in help file */\n\n  /* Restore KeyTyped, setting 'filetype=help' may reset it.\n   * It is needed for do_tag top open folds under the cursor. */\n  KeyTyped = old_KeyTyped;\n\n  do_tag(tag, DT_HELP, 1, FALSE, TRUE);\n\n  /* Delete the empty buffer if we're not using it.  Careful: autocommands\n   * may have jumped to another window, check that the buffer is not in a\n   * window. */\n  if (empty_fnum != 0 && curbuf->b_fnum != empty_fnum) {\n    buf = buflist_findnr(empty_fnum);\n    if (buf != NULL && buf->b_nwindows == 0) {\n      wipe_buffer(buf, true);\n    }\n  }\n\n  /* keep the previous alternate file */\n  if (alt_fnum != 0 && curwin->w_alt_fnum == empty_fnum && !cmdmod.keepalt)\n    curwin->w_alt_fnum = alt_fnum;\n\nerret:\n  xfree(tag);\n}\n\n\n/*\n * In an argument search for a language specifiers in the form \"@xx\".\n * Changes the \"@\" to NUL if found, and returns a pointer to \"xx\".\n * Returns NULL if not found.\n */\nchar_u *check_help_lang(char_u *arg)\n{\n  int len = (int)STRLEN(arg);\n\n  if (len >= 3 && arg[len - 3] == '@' && ASCII_ISALPHA(arg[len - 2])\n      && ASCII_ISALPHA(arg[len - 1])) {\n    arg[len - 3] = NUL;                 /* remove the '@' */\n    return arg + len - 2;\n  }\n  return NULL;\n}\n\n/*\n * Return a heuristic indicating how well the given string matches.  The\n * smaller the number, the better the match.  This is the order of priorities,\n * from best match to worst match:\n *\t- Match with least alphanumeric characters is better.\n *\t- Match with least total characters is better.\n *\t- Match towards the start is better.\n *\t- Match starting with \"+\" is worse (feature instead of command)\n * Assumption is made that the matched_string passed has already been found to\n * match some string for which help is requested.  webb.\n */\nint\nhelp_heuristic(\n    char_u *matched_string,\n    int offset,                             // offset for match\n    int wrong_case                          // no matching case\n)\n{\n  int num_letters;\n  char_u      *p;\n\n  num_letters = 0;\n  for (p = matched_string; *p; p++)\n    if (ASCII_ISALNUM(*p))\n      num_letters++;\n\n  /*\n   * Multiply the number of letters by 100 to give it a much bigger\n   * weighting than the number of characters.\n   * If there only is a match while ignoring case, add 5000.\n   * If the match starts in the middle of a word, add 10000 to put it\n   * somewhere in the last half.\n   * If the match is more than 2 chars from the start, multiply by 200 to\n   * put it after matches at the start.\n   */\n  if (offset > 0\n      && ASCII_ISALNUM(matched_string[offset])\n      && ASCII_ISALNUM(matched_string[offset - 1])) {\n    offset += 10000;\n  } else if (offset > 2) {\n    offset *= 200;\n  }\n  if (wrong_case) {\n    offset += 5000;\n  }\n  // Features are less interesting than the subjects themselves, but \"+\"\n  // alone is not a feature.\n  if (matched_string[0] == '+' && matched_string[1] != NUL) {\n    offset += 100;\n  }\n  return (int)(100 * num_letters + STRLEN(matched_string) + offset);\n}\n\n/*\n * Compare functions for qsort() below, that checks the help heuristics number\n * that has been put after the tagname by find_tags().\n */\nstatic int help_compare(const void *s1, const void *s2)\n{\n  char    *p1;\n  char    *p2;\n\n  p1 = *(char **)s1 + strlen(*(char **)s1) + 1;\n  p2 = *(char **)s2 + strlen(*(char **)s2) + 1;\n  return strcmp(p1, p2);\n}\n\n// Find all help tags matching \"arg\", sort them and return in matches[], with\n// the number of matches in num_matches.\n// The matches will be sorted with a \"best\" match algorithm.\n// When \"keep_lang\" is true try keeping the language of the current buffer.\nint find_help_tags(const char_u *arg, int *num_matches, char_u ***matches,\n                   bool keep_lang)\n{\n  int i;\n  static const char *(mtable[]) = {\n      \"*\", \"g*\", \"[*\", \"]*\",\n      \"/*\", \"/\\\\*\", \"\\\"*\", \"**\",\n      \"/\\\\(\\\\)\", \"/\\\\%(\\\\)\",\n      \"?\", \":?\", \"?<CR>\", \"g?\", \"g?g?\", \"g??\",\n      \"-?\", \"q?\", \"v_g?\",\n      \"/\\\\?\", \"/\\\\z(\\\\)\", \"\\\\=\", \":s\\\\=\",\n      \"[count]\", \"[quotex]\",\n      \"[range]\", \":[range]\",\n      \"[pattern]\", \"\\\\|\", \"\\\\%$\",\n      \"s/\\\\~\", \"s/\\\\U\", \"s/\\\\L\",\n      \"s/\\\\1\", \"s/\\\\2\", \"s/\\\\3\", \"s/\\\\9\"\n  };\n  static const char *(rtable[]) = {\n      \"star\", \"gstar\", \"[star\", \"]star\",\n      \"/star\", \"/\\\\\\\\star\", \"quotestar\", \"starstar\",\n      \"/\\\\\\\\(\\\\\\\\)\", \"/\\\\\\\\%(\\\\\\\\)\",\n      \"?\", \":?\", \"?<CR>\", \"g?\", \"g?g?\", \"g??\",\n      \"-?\", \"q?\", \"v_g?\",\n      \"/\\\\\\\\?\", \"/\\\\\\\\z(\\\\\\\\)\", \"\\\\\\\\=\", \":s\\\\\\\\=\",\n      \"\\\\[count]\", \"\\\\[quotex]\",\n      \"\\\\[range]\", \":\\\\[range]\",\n      \"\\\\[pattern]\", \"\\\\\\\\bar\", \"/\\\\\\\\%\\\\$\",\n      \"s/\\\\\\\\\\\\~\", \"s/\\\\\\\\U\", \"s/\\\\\\\\L\",\n      \"s/\\\\\\\\1\", \"s/\\\\\\\\2\", \"s/\\\\\\\\3\", \"s/\\\\\\\\9\"\n  };\n  static const char *(expr_table[]) = {\n      \"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n      \">=?\", \">?\", \"is?\", \"isnot?\"\n  };\n  char_u *d = IObuff;       // assume IObuff is long enough!\n\n  if (STRNICMP(arg, \"expr-\", 5) == 0) {\n    // When the string starting with \"expr-\" and containing '?' and matches\n    // the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n    // is recognized as a wildcard.\n    for (i = (int)ARRAY_SIZE(expr_table); --i >= 0; ) {\n      if (STRCMP(arg + 5, expr_table[i]) == 0) {\n        for (int si = 0, di = 0; ; si++) {\n          if (arg[si] == '~') {\n            d[di++] = '\\\\';\n          }\n          d[di++] = arg[si];\n          if (arg[si] == NUL) {\n            break;\n          }\n        }\n        break;\n      }\n    }\n  } else {\n    // Recognize a few exceptions to the rule.  Some strings that contain\n    // '*' with \"star\".  Otherwise '*' is recognized as a wildcard.\n    for (i = (int)ARRAY_SIZE(mtable); --i >= 0; ) {\n      if (STRCMP(arg, mtable[i]) == 0) {\n        STRCPY(d, rtable[i]);\n        break;\n      }\n    }\n  }\n\n  if (i < 0) {  /* no match in table */\n    /* Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n     * Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n     * Also \"\\zs\", \"\\z1\", etc.\n     * Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n     * And also \"\\_$\" and \"\\_^\". */\n    if (arg[0] == '\\\\'\n        && ((arg[1] != NUL && arg[2] == NUL)\n            || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n                && arg[2] != NUL))) {\n      STRCPY(d, \"/\\\\\\\\\");\n      STRCPY(d + 3, arg + 1);\n      /* Check for \"/\\\\_$\", should be \"/\\\\_\\$\" */\n      if (d[3] == '_' && d[4] == '$')\n        STRCPY(d + 4, \"\\\\$\");\n    } else {\n      /* Replace:\n       * \"[:...:]\" with \"\\[:...:]\"\n       * \"[++...]\" with \"\\[++...]\"\n       * \"\\{\" with \"\\\\{\"               -- matching \"} \\}\"\n       */\n      if ((arg[0] == '[' && (arg[1] == ':'\n                             || (arg[1] == '+' && arg[2] == '+')))\n          || (arg[0] == '\\\\' && arg[1] == '{'))\n        *d++ = '\\\\';\n\n      // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n      if (*arg == '(' && arg[1] == '\\'') {\n          arg++;\n      }\n      for (const char_u *s = arg; *s; s++) {\n        // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n        // the tags for these commands.\n        // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n        // completion.\n        // Insert a backslash before '~', '$' and '.' to avoid their\n        // special meaning.\n        if (d - IObuff > IOSIZE - 10) {           // getting too long!?\n          break;\n        }\n        switch (*s) {\n        case '|':   STRCPY(d, \"bar\");\n          d += 3;\n          continue;\n        case '\"':   STRCPY(d, \"quote\");\n          d += 5;\n          continue;\n        case '*':   *d++ = '.';\n          break;\n        case '?':   *d++ = '.';\n          continue;\n        case '$':\n        case '.':\n        case '~':   *d++ = '\\\\';\n          break;\n        }\n\n        /*\n         * Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n         * \":help i_^_CTRL-D\" work.\n         * Insert '-' before and after \"CTRL-X\" when applicable.\n         */\n        if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n                                               || vim_strchr((char_u *)\n                                                   \"?@[\\\\]^\",\n                                                   s[1]) != NULL))) {\n          if (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */\n          STRCPY(d, \"CTRL-\");\n          d += 5;\n          if (*s < ' ') {\n            *d++ = *s + '@';\n            if (d[-1] == '\\\\')\n              *d++ = '\\\\';              /* double a backslash */\n          } else\n            *d++ = *++s;\n          if (s[1] != NUL && s[1] != '_')\n            *d++ = '_';                 /* append a '_' */\n          continue;\n        } else if (*s == '^')           /* \"^\" or \"CTRL-^\" or \"^_\" */\n          *d++ = '\\\\';\n\n        /*\n         * Insert a backslash before a backslash after a slash, for search\n         * pattern tags: \"/\\|\" --> \"/\\\\|\".\n         */\n        else if (s[0] == '\\\\' && s[1] != '\\\\'\n                 && *arg == '/' && s == arg + 1)\n          *d++ = '\\\\';\n\n        /* \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n         * \"CTRL-\\_CTRL-N\" */\n        if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0) {\n          STRCPY(d, \"CTRL-\\\\\\\\\");\n          d += 7;\n          s += 6;\n        }\n\n        *d++ = *s;\n\n        // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n        // This is for help on functions, e.g.: abs({expr}).\n        if (*s == '(' && (s[1] == '{' || s[1] =='[')) {\n          break;\n        }\n\n        // If tag starts with ', toss everything after a second '. Fixes\n        // CTRL-] on 'option'. (would include the trailing '.').\n        if (*s == '\\'' && s > arg && *arg == '\\'') {\n          break;\n        }\n        // Also '{' and '}'. Fixes CTRL-] on '{address}'.\n        if (*s == '}' && s > arg && *arg == '{') {\n          break;\n        }\n      }\n      *d = NUL;\n\n      if (*IObuff == '`') {\n        if (d > IObuff + 2 && d[-1] == '`') {\n          /* remove the backticks from `command` */\n          memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n          d[-2] = NUL;\n        } else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',') {\n          /* remove the backticks and comma from `command`, */\n          memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n          d[-3] = NUL;\n        } else if (d > IObuff + 4 && d[-3] == '`'\n                   && d[-2] == '\\\\' && d[-1] == '.') {\n          /* remove the backticks and dot from `command`\\. */\n          memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n          d[-4] = NUL;\n        }\n      }\n    }\n  }\n\n  *matches = NULL;\n  *num_matches = 0;\n  int flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n  if (keep_lang) {\n    flags |= TAG_KEEP_LANG;\n  }\n  if (find_tags(IObuff, num_matches, matches, flags, MAXCOL, NULL) == OK\n      && *num_matches > 0) {\n    /* Sort the matches found on the heuristic number that is after the\n     * tag name. */\n    qsort((void *)*matches, (size_t)*num_matches,\n        sizeof(char_u *), help_compare);\n    /* Delete more than TAG_MANY to reduce the size of the listing. */\n    while (*num_matches > TAG_MANY)\n      xfree((*matches)[--*num_matches]);\n  }\n  return OK;\n}\n\n/// Called when starting to edit a buffer for a help file.\nstatic void prepare_help_buffer(void)\n{\n  curbuf->b_help = true;\n  set_string_option_direct(\"buftype\", -1, (char_u *)\"help\",\n                           OPT_FREE|OPT_LOCAL, 0);\n\n  // Always set these options after jumping to a help tag, because the\n  // user may have an autocommand that gets in the way.\n  // Accept all ASCII chars for keywords, except ' ', '*', '\"', '|', and\n  // latin1 word characters (for translated help files).\n  // Only set it when needed, buf_init_chartab() is some work.\n  char_u *p = (char_u *)\"!-~,^*,^|,^\\\",192-255\";\n  if (STRCMP(curbuf->b_p_isk, p) != 0) {\n    set_string_option_direct(\"isk\", -1, p, OPT_FREE|OPT_LOCAL, 0);\n    check_buf_options(curbuf);\n    (void)buf_init_chartab(curbuf, FALSE);\n  }\n\n  // Don't use the global foldmethod.\n  set_string_option_direct(\"fdm\", -1, (char_u *)\"manual\",\n                           OPT_FREE|OPT_LOCAL, 0);\n\n  curbuf->b_p_ts = 8;         // 'tabstop' is 8.\n  curwin->w_p_list = FALSE;   // No list mode.\n\n  curbuf->b_p_ma = FALSE;     // Not modifiable.\n  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.\n  curwin->w_p_nu = 0;         // No line numbers.\n  curwin->w_p_rnu = 0;        // No relative line numbers.\n  RESET_BINDING(curwin);      // No scroll or cursor binding.\n  curwin->w_p_arab = FALSE;   // No arabic mode.\n  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.\n  curwin->w_p_fen = FALSE;    // No folding in the help window.\n  curwin->w_p_diff = FALSE;   // No 'diff'.\n  curwin->w_p_spell = FALSE;  // No spell checking.\n\n  set_buflisted(FALSE);\n}\n\n/*\n * After reading a help file: May cleanup a help buffer when syntax\n * highlighting is not used.\n */\nvoid fix_help_buffer(void)\n{\n  linenr_T lnum;\n  char_u      *line;\n  bool in_example = false;\n\n  // Set filetype to \"help\".\n  if (STRCMP(curbuf->b_p_ft, \"help\") != 0) {\n    curbuf->b_ro_locked++;\n    set_option_value(\"ft\", 0L, \"help\", OPT_LOCAL);\n    curbuf->b_ro_locked--;\n  }\n\n  if (!syntax_present(curwin)) {\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; lnum++) {\n      line = ml_get_buf(curbuf, lnum, false);\n      const size_t len = STRLEN(line);\n      if (in_example && len > 0 && !ascii_iswhite(line[0])) {\n        /* End of example: non-white or '<' in first column. */\n        if (line[0] == '<') {\n          // blank-out a '<' in the first column\n          line = ml_get_buf(curbuf, lnum, true);\n          line[0] = ' ';\n        }\n        in_example = false;\n      }\n      if (!in_example && len > 0) {\n        if (line[len - 1] == '>' && (len == 1 || line[len - 2] == ' ')) {\n          // blank-out a '>' in the last column (start of example)\n          line = ml_get_buf(curbuf, lnum, true);\n          line[len - 1] = ' ';\n          in_example = true;\n        } else if (line[len - 1] == '~') {\n          // blank-out a '~' at the end of line (header marker)\n          line = ml_get_buf(curbuf, lnum, true);\n          line[len - 1] = ' ';\n        }\n      }\n    }\n  }\n\n  /*\n   * In the \"help.txt\" and \"help.abx\" file, add the locally added help\n   * files.  This uses the very first line in the help file.\n   */\n  char_u *const fname = path_tail(curbuf->b_fname);\n  if (fnamecmp(fname, \"help.txt\") == 0\n      || (fnamencmp(fname, \"help.\", 5) == 0\n          && ASCII_ISALPHA(fname[5])\n          && ASCII_ISALPHA(fname[6])\n          && TOLOWER_ASC(fname[7]) == 'x'\n          && fname[8] == NUL)\n      ) {\n    for (lnum = 1; lnum < curbuf->b_ml.ml_line_count; lnum++) {\n      line = ml_get_buf(curbuf, lnum, false);\n      if (strstr((char *)line, \"*local-additions*\") == NULL) {\n        continue;\n      }\n\n      /* Go through all directories in 'runtimepath', skipping\n       * $VIMRUNTIME. */\n      char_u *p = p_rtp;\n      while (*p != NUL) {\n        copy_option_part(&p, NameBuff, MAXPATHL, \",\");\n        char_u *const rt = (char_u *)vim_getenv(\"VIMRUNTIME\");\n        if (rt != NULL\n            && path_full_compare(rt, NameBuff, false, true) != kEqualFiles) {\n          int fcount;\n          char_u      **fnames;\n          char_u      *s;\n          vimconv_T vc;\n          char_u      *cp;\n\n          // Find all \"doc/ *.txt\" files in this directory.\n          if (!add_pathsep((char *)NameBuff)\n              || STRLCAT(NameBuff, \"doc/*.??[tx]\",\n                         sizeof(NameBuff)) >= MAXPATHL) {\n            EMSG(_(e_fnametoolong));\n            continue;\n          }\n\n          // Note: We cannot just do `&NameBuff` because it is a statically sized array\n          //       so `NameBuff == &NameBuff` according to C semantics.\n          char_u *buff_list[1] = {NameBuff};\n          if (gen_expand_wildcards(1, buff_list, &fcount,\n                  &fnames, EW_FILE|EW_SILENT) == OK\n              && fcount > 0) {\n            // If foo.abx is found use it instead of foo.txt in\n            // the same directory.\n            for (int i1 = 0; i1 < fcount; i1++) {\n              for (int i2 = 0; i2 < fcount; i2++) {\n                if (i1 == i2) {\n                  continue;\n                }\n                if (fnames[i1] == NULL || fnames[i2] == NULL) {\n                  continue;\n                }\n                const char_u *const f1 = fnames[i1];\n                const char_u *const f2 = fnames[i2];\n                const char_u *const t1 = path_tail(f1);\n                const char_u *const t2 = path_tail(f2);\n                const char_u *const e1 = STRRCHR(t1, '.');\n                const char_u *const e2 = STRRCHR(t2, '.');\n                if (e1 == NULL || e2 == NULL) {\n                  continue;\n                }\n                if (fnamecmp(e1, \".txt\") != 0\n                    && fnamecmp(e1, fname + 4) != 0) {\n                  // Not .txt and not .abx, remove it.\n                  XFREE_CLEAR(fnames[i1]);\n                  continue;\n                }\n                if (e1 - f1 != e2 - f2\n                    || fnamencmp(f1, f2, e1 - f1) != 0) {\n                  continue;\n                }\n                if (fnamecmp(e1, \".txt\") == 0\n                    && fnamecmp(e2, fname + 4) == 0) {\n                  // use .abx instead of .txt\n                  XFREE_CLEAR(fnames[i1]);\n                }\n              }\n            }\n            for (int fi = 0; fi < fcount; fi++) {\n              if (fnames[fi] == NULL) {\n                continue;\n              }\n\n              FILE *const fd = os_fopen((char *)fnames[fi], \"r\");\n              if (fd == NULL) {\n                continue;\n              }\n              vim_fgets(IObuff, IOSIZE, fd);\n              if (IObuff[0] == '*'\n                  && (s = vim_strchr(IObuff + 1, '*'))\n                  != NULL) {\n                TriState this_utf = kNone;\n                // Change tag definition to a\n                // reference and remove <CR>/<NL>.\n                IObuff[0] = '|';\n                *s = '|';\n                while (*s != NUL) {\n                  if (*s == '\\r' || *s == '\\n')\n                    *s = NUL;\n                  /* The text is utf-8 when a byte\n                   * above 127 is found and no\n                   * illegal byte sequence is found.\n                   */\n                  if (*s >= 0x80 && this_utf != kFalse) {\n                    this_utf = kTrue;\n                    const int l = utf_ptr2len(s);\n                    if (l == 1) {\n                      this_utf = kFalse;\n                    }\n                    s += l - 1;\n                  }\n                  ++s;\n                }\n                /* The help file is latin1 or utf-8;\n                 * conversion to the current\n                 * 'encoding' may be required. */\n                vc.vc_type = CONV_NONE;\n                convert_setup(\n                    &vc,\n                    (char_u *)(this_utf == kTrue ? \"utf-8\" : \"latin1\"),\n                    p_enc);\n                if (vc.vc_type == CONV_NONE) {\n                  // No conversion needed.\n                  cp = IObuff;\n                } else {\n                  // Do the conversion.  If it fails\n                  // use the unconverted text.\n                  cp = string_convert(&vc, IObuff, NULL);\n                  if (cp == NULL) {\n                    cp = IObuff;\n                  }\n                }\n                convert_setup(&vc, NULL, NULL);\n\n                ml_append(lnum, cp, (colnr_T)0, false);\n                if (cp != IObuff) {\n                  xfree(cp);\n                }\n                lnum++;\n              }\n              fclose(fd);\n            }\n            FreeWild(fcount, fnames);\n          }\n        }\n        xfree(rt);\n      }\n      break;\n    }\n  }\n}\n\n/*\n * \":exusage\"\n */\nvoid ex_exusage(exarg_T *eap)\n{\n  do_cmdline_cmd(\"help ex-cmd-index\");\n}\n\n/*\n * \":viusage\"\n */\nvoid ex_viusage(exarg_T *eap)\n{\n  do_cmdline_cmd(\"help normal-index\");\n}\n\n\n/// Generate tags in one help directory\n///\n/// @param dir  Path to the doc directory\n/// @param ext  Suffix of the help files (\".txt\", \".itx\", \".frx\", etc.)\n/// @param tagname  Name of the tags file (\"tags\" for English, \"tags-fr\" for\n///                 French)\n/// @param add_help_tags  Whether to add the \"help-tags\" tag\n/// @param ignore_writeerr  ignore write error\nstatic void helptags_one(char_u *dir, const char_u *ext, const char_u *tagfname,\n                         bool add_help_tags, bool ignore_writeerr)\n  FUNC_ATTR_NONNULL_ALL\n{\n  garray_T ga;\n  int filecount;\n  char_u      **files;\n  char_u      *p1, *p2;\n  char_u      *s;\n  TriState utf8 = kNone;\n  bool mix = false;             // detected mixed encodings\n\n  // Find all *.txt files.\n  size_t dirlen = STRLCPY(NameBuff, dir, sizeof(NameBuff));\n  if (dirlen >= MAXPATHL\n      || STRLCAT(NameBuff, \"/**/*\", sizeof(NameBuff)) >= MAXPATHL  // NOLINT\n      || STRLCAT(NameBuff, ext, sizeof(NameBuff)) >= MAXPATHL) {\n    EMSG(_(e_fnametoolong));\n    return;\n  }\n\n  // Note: We cannot just do `&NameBuff` because it is a statically sized array\n  //       so `NameBuff == &NameBuff` according to C semantics.\n  char_u *buff_list[1] = {NameBuff};\n  if (gen_expand_wildcards(1, buff_list, &filecount, &files,\n          EW_FILE|EW_SILENT) == FAIL\n      || filecount == 0) {\n    if (!got_int) {\n      EMSG2(_(\"E151: No match: %s\"), NameBuff);\n    }\n    return;\n  }\n\n  //\n  // Open the tags file for writing.\n  // Do this before scanning through all the files.\n  //\n  memcpy(NameBuff, dir, dirlen + 1);\n  if (!add_pathsep((char *)NameBuff)\n      || STRLCAT(NameBuff, tagfname, sizeof(NameBuff)) >= MAXPATHL) {\n    EMSG(_(e_fnametoolong));\n    return;\n  }\n\n  FILE *const fd_tags = os_fopen((char *)NameBuff, \"w\");\n  if (fd_tags == NULL) {\n    if (!ignore_writeerr) {\n      EMSG2(_(\"E152: Cannot open %s for writing\"), NameBuff);\n    }\n    FreeWild(filecount, files);\n    return;\n  }\n\n  // If using the \"++t\" argument or generating tags for \"$VIMRUNTIME/doc\"\n  // add the \"help-tags\" tag.\n  ga_init(&ga, (int)sizeof(char_u *), 100);\n  if (add_help_tags\n      || path_full_compare((char_u *)\"$VIMRUNTIME/doc\",\n                           dir, false, true) == kEqualFiles) {\n    s = xmalloc(18 + STRLEN(tagfname));\n    sprintf((char *)s, \"help-tags\\t%s\\t1\\n\", tagfname);\n    GA_APPEND(char_u *, &ga, s);\n  }\n\n  // Go over all the files and extract the tags.\n  for (int fi = 0; fi < filecount && !got_int; fi++) {\n    FILE *const fd = os_fopen((char *)files[fi], \"r\");\n    if (fd == NULL) {\n      EMSG2(_(\"E153: Unable to open %s for reading\"), files[fi]);\n      continue;\n    }\n    const char_u *const fname = files[fi] + dirlen + 1;\n\n    bool firstline = true;\n    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int) {\n      if (firstline) {\n        // Detect utf-8 file by a non-ASCII char in the first line.\n        TriState this_utf8 = kNone;\n        for (s = IObuff; *s != NUL; s++) {\n          if (*s >= 0x80) {\n            this_utf8 = kTrue;\n            const int l = utf_ptr2len(s);\n            if (l == 1) {\n              // Illegal UTF-8 byte sequence.\n              this_utf8 = kFalse;\n              break;\n            }\n            s += l - 1;\n          }\n        }\n        if (this_utf8 == kNone) {           // only ASCII characters found\n          this_utf8 = kFalse;\n        }\n        if (utf8 == kNone) {                // first file\n          utf8 = this_utf8;\n        } else if (utf8 != this_utf8) {\n          EMSG2(_(\n                  \"E670: Mix of help file encodings within a language: %s\"),\n              files[fi]);\n          mix = !got_int;\n          got_int = TRUE;\n        }\n        firstline = false;\n      }\n      p1 = vim_strchr(IObuff, '*');                        // find first '*'\n      while (p1 != NULL) {\n        p2 = (char_u *)strchr((const char *)p1 + 1, '*');  // Find second '*'.\n        if (p2 != NULL && p2 > p1 + 1) {                   // Skip \"*\" and \"**\".\n          for (s = p1 + 1; s < p2; s++) {\n            if (*s == ' ' || *s == '\\t' || *s == '|') {\n              break;\n            }\n          }\n\n          // Only accept a *tag* when it consists of valid\n          // characters, there is white space before it and is\n          // followed by a white character or end-of-line.\n          if (s == p2\n              && (p1 == IObuff || p1[-1] == ' ' || p1[-1] == '\\t')\n              && (vim_strchr((char_u *)\" \\t\\n\\r\", s[1]) != NULL\n                  || s[1] == '\\0')) {\n            *p2 = '\\0';\n            ++p1;\n            s = xmalloc((p2 - p1) + STRLEN(fname) + 2);\n            GA_APPEND(char_u *, &ga, s);\n            sprintf((char *)s, \"%s\\t%s\", p1, fname);\n\n            // find next '*'\n            p2 = vim_strchr(p2 + 1, '*');\n          }\n        }\n        p1 = p2;\n      }\n      line_breakcheck();\n    }\n\n    fclose(fd);\n  }\n\n  FreeWild(filecount, files);\n\n  if (!got_int && ga.ga_data != NULL) {\n    // Sort the tags.\n    sort_strings((char_u **)ga.ga_data, ga.ga_len);\n\n    // Check for duplicates.\n    for (int i = 1; i < ga.ga_len; i++) {\n      p1 = ((char_u **)ga.ga_data)[i - 1];\n      p2 = ((char_u **)ga.ga_data)[i];\n      while (*p1 == *p2) {\n        if (*p2 == '\\t') {\n          *p2 = NUL;\n          vim_snprintf((char *)NameBuff, MAXPATHL,\n              _(\"E154: Duplicate tag \\\"%s\\\" in file %s/%s\"),\n              ((char_u **)ga.ga_data)[i], dir, p2 + 1);\n          EMSG(NameBuff);\n          *p2 = '\\t';\n          break;\n        }\n        ++p1;\n        ++p2;\n      }\n    }\n\n    if (utf8 == kTrue) {\n      fprintf(fd_tags, \"!_TAG_FILE_ENCODING\\tutf-8\\t//\\n\");\n    }\n\n    // Write the tags into the file.\n    for (int i = 0; i < ga.ga_len; i++) {\n      s = ((char_u **)ga.ga_data)[i];\n      if (STRNCMP(s, \"help-tags\\t\", 10) == 0) {\n        // help-tags entry was added in formatted form\n        fputs((char *)s, fd_tags);\n      } else {\n        fprintf(fd_tags, \"%s\\t/\" \"*\", s);\n        for (p1 = s; *p1 != '\\t'; p1++) {\n          // insert backslash before '\\\\' and '/'\n          if (*p1 == '\\\\' || *p1 == '/') {\n            putc('\\\\', fd_tags);\n          }\n          putc(*p1, fd_tags);\n        }\n        fprintf(fd_tags, \"*\\n\");\n      }\n    }\n  }\n  if (mix) {\n    got_int = false;        // continue with other languages\n  }\n\n  GA_DEEP_CLEAR_PTR(&ga);\n  fclose(fd_tags);          // there is no check for an error...\n}\n\n/// Generate tags in one help directory, taking care of translations.\nstatic void do_helptags(char_u *dirname, bool add_help_tags,\n                        bool ignore_writeerr)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int len;\n  garray_T ga;\n  char_u lang[2];\n  char_u ext[5];\n  char_u fname[8];\n  int filecount;\n  char_u **files;\n\n  // Get a list of all files in the help directory and in subdirectories.\n  STRLCPY(NameBuff, dirname, sizeof(NameBuff));\n  if (!add_pathsep((char *)NameBuff)\n      || STRLCAT(NameBuff, \"**\", sizeof(NameBuff)) >= MAXPATHL) {\n    EMSG(_(e_fnametoolong));\n    return;\n  }\n\n  // Note: We cannot just do `&NameBuff` because it is a statically sized array\n  //       so `NameBuff == &NameBuff` according to C semantics.\n  char_u *buff_list[1] = {NameBuff};\n  if (gen_expand_wildcards(1, buff_list, &filecount, &files,\n                           EW_FILE|EW_SILENT) == FAIL\n      || filecount == 0) {\n    EMSG2(_(\"E151: No match: %s\"), NameBuff);\n    return;\n  }\n\n  /* Go over all files in the directory to find out what languages are\n   * present. */\n  int j;\n  ga_init(&ga, 1, 10);\n  for (int i = 0; i < filecount; i++) {\n    len = (int)STRLEN(files[i]);\n    if (len <= 4) {\n      continue;\n    }\n    if (STRICMP(files[i] + len - 4, \".txt\") == 0) {\n      /* \".txt\" -> language \"en\" */\n      lang[0] = 'e';\n      lang[1] = 'n';\n    } else if (files[i][len - 4] == '.'\n               && ASCII_ISALPHA(files[i][len - 3])\n               && ASCII_ISALPHA(files[i][len - 2])\n               && TOLOWER_ASC(files[i][len - 1]) == 'x') {\n      /* \".abx\" -> language \"ab\" */\n      lang[0] = TOLOWER_ASC(files[i][len - 3]);\n      lang[1] = TOLOWER_ASC(files[i][len - 2]);\n    } else\n      continue;\n\n    // Did we find this language already?\n    for (j = 0; j < ga.ga_len; j += 2) {\n      if (STRNCMP(lang, ((char_u *)ga.ga_data) + j, 2) == 0) {\n        break;\n      }\n    }\n    if (j == ga.ga_len) {\n      // New language, add it.\n      ga_grow(&ga, 2);\n      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[0];\n      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[1];\n    }\n  }\n\n  /*\n   * Loop over the found languages to generate a tags file for each one.\n   */\n  for (j = 0; j < ga.ga_len; j += 2) {\n    STRCPY(fname, \"tags-xx\");\n    fname[5] = ((char_u *)ga.ga_data)[j];\n    fname[6] = ((char_u *)ga.ga_data)[j + 1];\n    if (fname[5] == 'e' && fname[6] == 'n') {\n      /* English is an exception: use \".txt\" and \"tags\". */\n      fname[4] = NUL;\n      STRCPY(ext, \".txt\");\n    } else {\n      /* Language \"ab\" uses \".abx\" and \"tags-ab\". */\n      STRCPY(ext, \".xxx\");\n      ext[1] = fname[5];\n      ext[2] = fname[6];\n    }\n    helptags_one(dirname, ext, fname, add_help_tags, ignore_writeerr);\n  }\n\n  ga_clear(&ga);\n  FreeWild(filecount, files);\n}\n\nstatic void helptags_cb(char_u *fname, void *cookie)\n  FUNC_ATTR_NONNULL_ALL\n{\n    do_helptags(fname, *(bool *)cookie, true);\n}\n\n/*\n * \":helptags\"\n */\nvoid ex_helptags(exarg_T *eap)\n{\n  expand_T xpc;\n  char_u *dirname;\n  bool add_help_tags = false;\n\n  /* Check for \":helptags ++t {dir}\". */\n  if (STRNCMP(eap->arg, \"++t\", 3) == 0 && ascii_iswhite(eap->arg[3])) {\n    add_help_tags = true;\n    eap->arg = skipwhite(eap->arg + 3);\n  }\n\n  if (STRCMP(eap->arg, \"ALL\") == 0) {\n    do_in_path(p_rtp, (char_u *)\"doc\", DIP_ALL + DIP_DIR,\n               helptags_cb, &add_help_tags);\n  } else {\n    ExpandInit(&xpc);\n    xpc.xp_context = EXPAND_DIRECTORIES;\n    dirname = ExpandOne(&xpc, eap->arg, NULL,\n                        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);\n    if (dirname == NULL || !os_isdir(dirname)) {\n      EMSG2(_(\"E150: Not a directory: %s\"), eap->arg);\n    } else {\n      do_helptags(dirname, add_help_tags, false);\n    }\n    xfree(dirname);\n  }\n}\n\n/*\n * \":helpclose\": Close one help window\n */\nvoid ex_helpclose(exarg_T *eap)\n{\n  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n    if (bt_help(win->w_buffer)) {\n      win_close(win, false);\n      return;\n    }\n  }\n}\n\n/// Tries to enter to an existing window of given buffer. If no existing buffer\n/// is found, creates a new split.\n///\n/// Returns OK/FAIL.\nint sub_preview_win(buf_T *preview_buf)\n{\n  if (preview_buf != NULL) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_buffer == preview_buf) {\n        win_enter(wp, false);\n\n        return OK;\n      }\n    }\n  }\n  return win_split((int)p_cwh, WSP_BOT);\n}\n\n/// Shows the effects of the :substitute command being typed ('inccommand').\n/// If inccommand=split, shows a preview window and later restores the layout.\nstatic buf_T *show_sub(exarg_T *eap, pos_T old_cusr,\n                       PreviewLines *preview_lines, int hl_id, int src_id,\n                       handle_T bufnr)\n  FUNC_ATTR_NONNULL_ALL\n{\n  win_T *save_curwin = curwin;\n  cmdmod_T save_cmdmod = cmdmod;\n  char_u *save_shm_p = vim_strsave(p_shm);\n  PreviewLines lines = *preview_lines;\n  buf_T *orig_buf = curbuf;\n\n  // We keep a special-purpose buffer around, but don't assume it exists.\n  buf_T *preview_buf = bufnr ? buflist_findnr(bufnr) : 0;\n  cmdmod.split = 0;               // disable :leftabove/botright modifiers\n  cmdmod.tab = 0;                 // disable :tab modifier\n  cmdmod.noswapfile = true;       // disable swap for preview buffer\n  // disable file info message\n  set_string_option_direct(\"shm\", -1, (char_u *)\"F\", OPT_FREE,\n                           SID_NONE);\n\n  bool outside_curline = (eap->line1 != old_cusr.lnum\n                          || eap->line2 != old_cusr.lnum);\n  bool preview = outside_curline && (*p_icm != 'n');\n  if (preview_buf == curbuf) {  // Preview buffer cannot preview itself!\n    preview = false;\n    preview_buf = NULL;\n  }\n\n  // Place cursor on nearest matching line, to undo do_sub() cursor placement.\n  for (size_t i = 0; i < lines.subresults.size; i++) {\n    SubResult curres = lines.subresults.items[i];\n    if (curres.start.lnum >= old_cusr.lnum) {\n      curwin->w_cursor.lnum = curres.start.lnum;\n      curwin->w_cursor.col = curres.start.col;\n      break;\n    }  // Else: All matches are above, do_sub() already placed cursor.\n  }\n\n  // Width of the \"| lnum|...\" column which displays the line numbers.\n  linenr_T highest_num_line = 0;\n  int col_width = 0;\n\n  if (preview && sub_preview_win(preview_buf) != FAIL) {\n    buf_open_scratch(preview_buf ? bufnr : 0, \"[Preview]\");\n    buf_clear();\n    preview_buf = curbuf;\n    curbuf->b_p_bl = false;\n    curbuf->b_p_ma = true;\n    curbuf->b_p_ul = -1;\n    curbuf->b_p_tw = 0;         // Reset 'textwidth' (was set by ftplugin)\n    curwin->w_p_cul = false;\n    curwin->w_p_cuc = false;\n    curwin->w_p_spell = false;\n    curwin->w_p_fen = false;\n\n    if (lines.subresults.size > 0) {\n      highest_num_line = kv_last(lines.subresults).end.lnum;\n      col_width = log10(highest_num_line) + 1 + 3;\n    }\n  } else {\n    // Failed to split the window, don't show 'inccommand' preview.\n    preview_buf = NULL;\n  }\n\n  char *str = NULL;  // construct the line to show in here\n  size_t old_line_size = 0;\n  size_t line_size = 0;\n  linenr_T linenr_preview = 0;  // last line added to preview buffer\n  linenr_T linenr_origbuf = 0;  // last line added to original buffer\n  linenr_T next_linenr = 0;     // next line to show for the match\n\n  for (size_t matchidx = 0; matchidx < lines.subresults.size; matchidx++) {\n    SubResult match = lines.subresults.items[matchidx];\n\n    if (preview_buf) {\n      lpos_T p_start = { 0, match.start.col };  // match starts here in preview\n      lpos_T p_end   = { 0, match.end.col };    // ... and ends here\n\n      if (match.pre_match == 0) {\n        next_linenr = match.start.lnum;\n      } else {\n        next_linenr = match.pre_match;\n      }\n      // Don't add a line twice\n      if (next_linenr == linenr_origbuf) {\n        next_linenr++;\n        p_start.lnum = linenr_preview;  // might be redefined below\n        p_end.lnum = linenr_preview;  // might be redefined below\n      }\n\n      for (; next_linenr <= match.end.lnum; next_linenr++) {\n        if (next_linenr == match.start.lnum) {\n          p_start.lnum = linenr_preview + 1;\n        }\n        if (next_linenr == match.end.lnum) {\n          p_end.lnum = linenr_preview + 1;\n        }\n        char *line;\n        if (next_linenr == orig_buf->b_ml.ml_line_count + 1) {\n          line = \"\";\n        } else {\n          line = (char *)ml_get_buf(orig_buf, next_linenr, false);\n          line_size = strlen(line) + col_width + 1;\n\n          // Reallocate if line not long enough\n          if (line_size > old_line_size) {\n            str = xrealloc(str, line_size * sizeof(char));\n            old_line_size = line_size;\n          }\n        }\n        // Put \"|lnum| line\" into `str` and append it to the preview buffer.\n        snprintf(str, line_size, \"|%*ld| %s\", col_width - 3,\n                 next_linenr, line);\n        if (linenr_preview == 0) {\n          ml_replace(1, (char_u *)str, true);\n        } else {\n          ml_append(linenr_preview, (char_u *)str, (colnr_T)line_size, false);\n        }\n        linenr_preview += 1;\n      }\n      linenr_origbuf = match.end.lnum;\n\n      bufhl_add_hl_pos_offset(preview_buf, src_id, hl_id, p_start,\n                              p_end, col_width);\n    }\n    bufhl_add_hl_pos_offset(orig_buf, src_id, hl_id, match.start,\n                            match.end, 0);\n  }\n  xfree(str);\n\n  redraw_later(curwin, SOME_VALID);\n  win_enter(save_curwin, false);  // Return to original window\n  update_topline(curwin);\n\n  // Update screen now.\n  int save_rd = RedrawingDisabled;\n  RedrawingDisabled = 0;\n  update_screen(SOME_VALID);\n  RedrawingDisabled = save_rd;\n\n  set_string_option_direct(\"shm\", -1, save_shm_p, OPT_FREE, SID_NONE);\n  xfree(save_shm_p);\n\n  cmdmod = save_cmdmod;\n\n  return preview_buf;\n}\n\n/// Closes any open windows for inccommand preview buffer.\nvoid close_preview_windows(void)\n{\n    block_autocmds();\n    buf_T *buf = preview_bufnr ? buflist_findnr(preview_bufnr) : NULL;\n    if (buf != NULL) {\n      close_windows(buf, false);\n    }\n    unblock_autocmds();\n}\n\n/// :substitute command\n///\n/// If 'inccommand' is empty: calls do_sub().\n/// If 'inccommand' is set: shows a \"live\" preview then removes the changes.\n/// from undo history.\nvoid ex_substitute(exarg_T *eap)\n{\n  bool preview = (State & CMDPREVIEW);\n  if (*p_icm == NUL || !preview) {  // 'inccommand' is disabled\n    close_preview_windows();\n    (void)do_sub(eap, profile_zero(), true, preview_bufnr);\n\n    return;\n  }\n\n  block_autocmds();           // Disable events during command preview.\n\n  char_u *save_eap = eap->arg;\n  garray_T save_view;\n  win_size_save(&save_view);  // Save current window sizes.\n  save_search_patterns();\n  int save_changedtick = buf_get_changedtick(curbuf);\n  time_t save_b_u_time_cur = curbuf->b_u_time_cur;\n  u_header_T *save_b_u_newhead = curbuf->b_u_newhead;\n  long save_b_p_ul = curbuf->b_p_ul;\n  int save_w_p_cul = curwin->w_p_cul;\n  int save_w_p_cuc = curwin->w_p_cuc;\n\n  curbuf->b_p_ul = LONG_MAX;  // make sure we can undo all changes\n  curwin->w_p_cul = false;    // Disable 'cursorline'\n  curwin->w_p_cuc = false;    // Disable 'cursorcolumn'\n\n  // Don't show search highlighting during live substitution\n  bool save_hls = p_hls;\n  p_hls = false;\n  buf_T *preview_buf = do_sub(eap, profile_setlimit(p_rdt), false,\n                              preview_bufnr);\n  p_hls = save_hls;\n\n  if (preview_buf != NULL) {\n    preview_bufnr = preview_buf->handle;\n  }\n\n  if (save_changedtick != buf_get_changedtick(curbuf)) {\n    // Undo invisibly. This also moves the cursor!\n    if (!u_undo_and_forget(1)) { abort(); }\n    // Restore newhead. It is meaningless when curhead is valid, but we must\n    // restore it so that undotree() is identical before/after the preview.\n    curbuf->b_u_newhead = save_b_u_newhead;\n    curbuf->b_u_time_cur = save_b_u_time_cur;\n    buf_set_changedtick(curbuf, save_changedtick);\n  }\n\n  curbuf->b_p_ul = save_b_p_ul;\n  curwin->w_p_cul = save_w_p_cul;   // Restore 'cursorline'\n  curwin->w_p_cuc = save_w_p_cuc;   // Restore 'cursorcolumn'\n  eap->arg = save_eap;\n  restore_search_patterns();\n  win_size_restore(&save_view);\n  ga_clear(&save_view);\n  unblock_autocmds();\n}\n\n/// Skip over the pattern argument of \":vimgrep /pat/[g][j]\".\n/// Put the start of the pattern in \"*s\", unless \"s\" is NULL.\n/// If \"flags\" is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.\n/// If \"s\" is not NULL terminate the pattern with a NUL.\n/// Return a pointer to the char just past the pattern plus flags.\nchar_u *skip_vimgrep_pat(char_u *p, char_u **s, int *flags)\n{\n  int c;\n\n  if (vim_isIDc(*p)) {\n    // \":vimgrep pattern fname\"\n    if (s != NULL) {\n      *s = p;\n    }\n    p = skiptowhite(p);\n    if (s != NULL && *p != NUL) {\n      *p++ = NUL;\n    }\n  } else {\n    // \":vimgrep /pattern/[g][j] fname\"\n    if (s != NULL) {\n      *s = p + 1;\n    }\n    c = *p;\n    p = skip_regexp(p + 1, c, true, NULL);\n    if (*p != c) {\n      return NULL;\n    }\n\n    // Truncate the pattern.\n    if (s != NULL) {\n      *p = NUL;\n    }\n    p++;\n\n    // Find the flags\n    while (*p == 'g' || *p == 'j') {\n      if (flags != NULL) {\n        if (*p == 'g') {\n          *flags |= VGR_GLOBAL;\n        } else {\n          *flags |= VGR_NOJUMP;\n        }\n      }\n      p++;\n    }\n  }\n  return p;\n}\n\n/// List v:oldfiles in a nice way.\nvoid ex_oldfiles(exarg_T *eap)\n{\n  list_T      *l = get_vim_var_list(VV_OLDFILES);\n  long nr = 0;\n\n  if (l == NULL) {\n    msg((char_u *)_(\"No old files\"));\n  } else {\n    msg_start();\n    msg_scroll = true;\n    TV_LIST_ITER(l, li, {\n      if (got_int) {\n        break;\n      }\n      nr++;\n      const char *fname = tv_get_string(TV_LIST_ITEM_TV(li));\n      if (!message_filtered((char_u *)fname)) {\n        msg_outnum(nr);\n        MSG_PUTS(\": \");\n        msg_outtrans((char_u *)tv_get_string(TV_LIST_ITEM_TV(li)));\n        msg_clr_eos();\n        msg_putchar('\\n');\n        ui_flush();                  // output one line at a time\n        os_breakcheck();\n      }\n    });\n\n    // Assume \"got_int\" was set to truncate the listing.\n    got_int = false;\n\n    // File selection prompt on \":browse oldfiles\"\n    if (cmdmod.browse) {\n      quit_more = false;\n      nr = prompt_for_number(false);\n      msg_starthere();\n      if (nr > 0 && nr <= tv_list_len(l)) {\n        const char *const p = tv_list_find_str(l, nr - 1);\n        if (p == NULL) {\n          return;\n        }\n        char *const s = (char *)expand_env_save((char_u *)p);\n        eap->arg = (char_u *)s;\n        eap->cmdidx = CMD_edit;\n        cmdmod.browse = false;\n        do_exedit(eap, NULL);\n        xfree(s);\n      }\n    }\n  }\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 1250}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1274}, "message": "Assuming 'do_out' is false"}, {"location": {"col": 7, "file": 0, "line": 1277}, "message": "Assuming 'do_in' is true"}, {"location": {"col": 34, "file": 0, "line": 1281}, "message": "Assuming 'stmp' is 0"}, {"location": {"col": 7, "file": 0, "line": 1313}, "message": "Assuming 'curbuf' is equal to 'old_curbuf'"}, {"location": {"col": 23, "file": 0, "line": 1333}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [], "notes": [], "path": "src/nvim/ex_cmds.c", "reportHash": "3125958826d9e6ba31da11ae07d51e2a", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2272}, "message": "Assuming field 'w_p_so' is < 0"}, {"location": {"col": 7, "file": 0, "line": 2274}, "message": "Assuming 'eap' is equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 2279}, "message": "Assuming 'fnum' is equal to 0"}, {"location": {"col": 9, "file": 0, "line": 2285}, "message": "Assuming 'sfname' is not equal to NULL"}, {"location": {"col": 10, "file": 0, "line": 2292}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 2297}, "message": "Assuming 'ffname' is not equal to NULL"}, {"location": {"col": 14, "file": 0, "line": 2300}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 2308}, "message": "Assuming 'free_fname' is equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 2315}, "message": "Assuming 'other_file' is not equal to 0"}, {"location": {"col": 12, "file": 0, "line": 2326}, "message": "Assuming field 'b_nwindows' is not equal to 1"}, {"location": {"col": 27, "file": 0, "line": 2344}, "message": "Assuming 'newlnum' is <= 0"}, {"location": {"col": 11, "file": 0, "line": 2365}, "message": "Assuming field 'keepalt' is true"}, {"location": {"col": 11, "file": 0, "line": 2368}, "message": "Assuming 'oldwin' is equal to NULL"}, {"location": {"col": 39, "file": 0, "line": 2396}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 2403}, "message": "Assuming 'buf' is not equal to NULL"}, {"location": {"col": 9, "file": 0, "line": 2405}, "message": "Assuming field 'ml_mfp' is equal to NULL"}, {"location": {"col": 46, "file": 0, "line": 2426}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 2438}, "message": "Assuming 'buf' is not equal to 'curbuf'"}, {"location": {"col": 11, "file": 0, "line": 2452}, "message": "Assuming field 'b_fname' is equal to NULL"}, {"location": {"col": 11, "file": 0, "line": 2458}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 2463}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 2467}, "message": "Assuming 'buf' is not equal to 'curbuf'"}, {"location": {"col": 13, "file": 0, "line": 2478}, "message": "Assuming 'curbuf' is not equal to field 'br_buf'"}, {"location": {"col": 14, "file": 0, "line": 2487}, "message": "Assuming the condition is true"}, {"location": {"col": 13, "file": 0, "line": 2491}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 2497}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 2502}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 2507}, "message": "Assuming 'buf' is equal to 'curbuf'"}, {"location": {"col": 15, "file": 0, "line": 2510}, "message": "Assuming 'did_decrement' is false"}, {"location": {"col": 15, "file": 0, "line": 2513}, "message": "Assuming the condition is true"}, {"location": {"col": 44, "file": 0, "line": 2513}, "message": "Access to field 'w_buffer' results in a dereference of a null pointer (loaded from variable 'oldwin')"}], "macros": [], "notes": [], "path": "src/nvim/ex_cmds.c", "reportHash": "4958c1f332590682c69d02bf8232f00f", "checkerName": "core.NullDereference", "reviewStatus": null, "severity": "HIGH"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
