<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/option.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// User-settable options. Checklist for adding a new option:\n// - Put it in options.lua\n// - For a global option: Add a variable for it in option_defs.h.\n// - For a buffer or window local option:\n//   - Add a BV_XX or WV_XX entry to option_defs.h\n//   - Add a variable to the window or buffer struct in buffer_defs.h.\n//   - For a window option, add some code to copy_winopt().\n//   - For a window string option, add code to check_winopt()\n//     and clear_winopt(). If setting the option needs parsing,\n//     add some code to didset_window_options().\n//   - For a buffer option, add some code to buf_copy_options().\n//   - For a buffer string option, add code to check_buf_options().\n// - If it's a numeric option, add any necessary bounds checks to\n//   set_num_option().\n// - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n// - Add documentation! doc/options.txt, and any other related places.\n// - Add an entry in runtime/optwin.vim.\n\n#define IN_OPTION_C\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/macros.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/option.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/typval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hardcopy.h\"\n#include \"nvim/highlight.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memfile.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/runtime.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/cursor_shape.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/popupmnu.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/ex_session.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/spellfile.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/ui_compositor.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#ifdef WIN32\n# include \"nvim/os/pty_conpty_win.h\"\n#endif\n#include \"nvim/lua/executor.h\"\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/lang.h\"\n#include \"nvim/quickfix.h\"\n\n/*\n * The options that are local to a window or buffer have \"indir\" set to one of\n * these values.  Special values:\n * PV_NONE: global option.\n * PV_WIN is added: window-local option\n * PV_BUF is added: buffer-local option\n * PV_BOTH is added: global option which also has a local value.\n */\n#define PV_BOTH 0x1000\n#define PV_WIN  0x2000\n#define PV_BUF  0x4000\n#define PV_MASK 0x0fff\n#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))\n#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))\n#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))\n\n\n// WV_ and BV_ values get typecasted to this for the \"indir\" field\ntypedef enum {\n  PV_NONE = 0,\n  PV_MAXVAL = 0xffff      // to avoid warnings for value out of range\n} idopt_T;\n\n/*\n * Options local to a window have a value local to a buffer and global to all\n * buffers.  Indicate this by setting \"var\" to VAR_WIN.\n */\n#define VAR_WIN ((char_u *)-1)\n\nstatic char *p_term = NULL;\nstatic char *p_ttytype = NULL;\n\n/*\n * These are the global values for options which are also local to a buffer.\n * Only to be used in option.c!\n */\nstatic int p_ai;\nstatic int p_bin;\nstatic int p_bomb;\nstatic char_u   *p_bh;\nstatic char_u   *p_bt;\nstatic int p_bl;\nstatic long p_channel;\nstatic int p_ci;\nstatic int p_cin;\nstatic char_u   *p_cink;\nstatic char_u   *p_cino;\nstatic char_u   *p_cinw;\nstatic char_u   *p_com;\nstatic char_u   *p_cms;\nstatic char_u   *p_cpt;\nstatic char_u   *p_cfu;\nstatic char_u   *p_ofu;\nstatic char_u   *p_tfu;\nstatic int p_eol;\nstatic int p_fixeol;\nstatic int p_et;\nstatic char_u   *p_fenc;\nstatic char_u   *p_ff;\nstatic char_u   *p_fo;\nstatic char_u   *p_flp;\nstatic char_u   *p_ft;\nstatic long p_iminsert;\nstatic long p_imsearch;\nstatic char_u   *p_inex;\nstatic char_u   *p_inde;\nstatic char_u   *p_indk;\nstatic char_u   *p_fex;\nstatic int p_inf;\nstatic char_u   *p_isk;\nstatic int p_lisp;\nstatic int p_ml;\nstatic int p_ma;\nstatic int p_mod;\nstatic char_u   *p_mps;\nstatic char_u   *p_nf;\nstatic int p_pi;\nstatic char_u   *p_qe;\nstatic int p_ro;\nstatic int p_si;\nstatic long p_sts;\nstatic char_u   *p_sua;\nstatic long p_sw;\nstatic int p_swf;\nstatic long p_smc;\nstatic char_u   *p_syn;\nstatic char_u   *p_spc;\nstatic char_u   *p_spf;\nstatic char_u   *p_spl;\nstatic char_u   *p_spo;\nstatic long p_ts;\nstatic long p_tw;\nstatic int p_udf;\nstatic long p_wm;\nstatic char_u *p_vsts;\nstatic char_u *p_vts;\nstatic char_u   *p_keymap;\n\n// Saved values for when 'bin' is set.\nstatic int p_et_nobin;\nstatic int p_ml_nobin;\nstatic long p_tw_nobin;\nstatic long p_wm_nobin;\n\n// Saved values for when 'paste' is set.\nstatic int p_ai_nopaste;\nstatic int p_et_nopaste;\nstatic long p_sts_nopaste;\nstatic long p_tw_nopaste;\nstatic long p_wm_nopaste;\nstatic char_u *p_vsts_nopaste;\n\ntypedef struct vimoption {\n  char        *fullname;        // full option name\n  char        *shortname;       // permissible abbreviation\n  uint32_t flags;               // see below\n  char_u      *var;             // global option: pointer to variable;\n                                // window-local option: VAR_WIN;\n                                // buffer-local option: global value\n  idopt_T indir;                // global option: PV_NONE;\n                                // local option: indirect option index\n  char_u      *def_val;         // default values for variable (neovim!!)\n  LastSet last_set;             // script in which the option was last set\n} vimoption_T;\n\n\n/*\n * Flags\n */\n#define P_BOOL          0x01U    // the option is boolean\n#define P_NUM           0x02U    // the option is numeric\n#define P_STRING        0x04U    // the option is a string\n#define P_ALLOCED       0x08U    // the string option is in allocated memory,\n                                 // must use free_string_option() when\n                                 // assigning new value. Not set if default is\n                                 // the same.\n#define P_EXPAND        0x10U    // environment expansion.  NOTE: P_EXPAND can\n                                 // never be used for local or hidden options\n#define P_NODEFAULT     0x40U    // don't set to default value\n#define P_DEF_ALLOCED   0x80U    // default value is in allocated memory, must\n                                 // use free() when assigning new value\n#define P_WAS_SET       0x100U   // option has been set/reset\n#define P_NO_MKRC       0x200U   // don't include in :mkvimrc output\n\n// when option changed, what to display:\n#define P_RSTAT         0x1000U  ///< redraw status lines\n#define P_RWIN          0x2000U  ///< redraw current window and recompute text\n#define P_RBUF          0x4000U  ///< redraw current buffer and recompute text\n#define P_RALL          0x6000U  ///< redraw all windows\n#define P_RCLR          0x7000U  ///< clear and redraw all\n\n#define P_COMMA         0x8000U    ///< comma separated list\n#define P_ONECOMMA      0x18000U   ///< P_COMMA and cannot have two consecutive\n                                   ///< commas\n#define P_NODUP         0x20000U   ///< don't allow duplicate strings\n#define P_FLAGLIST      0x40000U   ///< list of single-char flags\n\n#define P_SECURE        0x80000U   ///< cannot change in modeline or secure mode\n#define P_GETTEXT       0x100000U  ///< expand default value with _()\n#define P_NOGLOB        0x200000U  ///< do not use local value for global vimrc\n#define P_NFNAME        0x400000U  ///< only normal file name chars allowed\n#define P_INSECURE      0x800000U  ///< option was set from a modeline\n#define P_PRI_MKRC     0x1000000U  ///< priority for :mkvimrc (setting option\n                                   ///< has side effects)\n#define P_NO_ML        0x2000000U  ///< not allowed in modeline\n#define P_CURSWANT     0x4000000U  ///< update curswant required; not needed\n                                   ///< when there is a redraw flag\n#define P_NO_DEF_EXP   0x8000000U  ///< Do not expand default value.\n\n#define P_RWINONLY     0x10000000U  ///< only redraw current window\n#define P_NDNAME       0x20000000U  ///< only normal dir name chars allowed\n#define P_UI_OPTION    0x40000000U  ///< send option to remote ui\n#define P_MLE          0x80000000U  ///< under control of 'modelineexpr'\n\n#define HIGHLIGHT_INIT \\\n  \"8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,d:Directory,e:ErrorMsg,\" \\\n  \"i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,a:LineNrAbove,b:LineNrBelow,N:CursorLineNr,\" \\\n  \"r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,\" \\\n  \"W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,\" \\\n  \"-:Conceal,B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,x:PmenuSbar,\" \\\n  \"X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,!:CursorColumn,.:CursorLine,o:ColorColumn,\" \\\n  \"q:QuickFixLine,0:Whitespace,I:NormalNC\"\n\n/*\n * options[] is initialized here.\n * The order of the options MUST be alphabetic for \":set all\" and findoption().\n * All option names MUST start with a lowercase letter (for findoption()).\n * Exception: \"t_\" options are at the end.\n * The options with a NULL variable are 'hidden': a set command for them is\n * ignored and they are not printed.\n */\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"options.generated.h\"\n#endif\n\n#define PARAM_COUNT ARRAY_SIZE(options)\n\nstatic char *(p_ambw_values[]) =      { \"single\", \"double\", NULL };\nstatic char *(p_bg_values[]) =        { \"light\", \"dark\", NULL };\nstatic char *(p_nf_values[]) =        { \"bin\", \"octal\", \"hex\", \"alpha\",\n                                        \"unsigned\", NULL };\nstatic char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };\nstatic char *(p_wak_values[]) =       { \"yes\", \"menu\", \"no\", NULL };\nstatic char *(p_mousem_values[]) =    { \"extend\", \"popup\", \"popup_setpos\",\n                                        \"mac\", NULL };\nstatic char *(p_sel_values[]) =       { \"inclusive\", \"exclusive\", \"old\", NULL };\nstatic char *(p_slm_values[]) =       { \"mouse\", \"key\", \"cmd\", NULL };\nstatic char *(p_km_values[]) =        { \"startsel\", \"stopsel\", NULL };\nstatic char *(p_scbopt_values[]) =    { \"ver\", \"hor\", \"jump\", NULL };\nstatic char *(p_debug_values[]) =     { \"msg\", \"throw\", \"beep\", NULL };\nstatic char *(p_ead_values[]) =       { \"both\", \"ver\", \"hor\", NULL };\nstatic char *(p_buftype_values[]) =   { \"nofile\", \"nowrite\", \"quickfix\",\n                                        \"help\", \"acwrite\", \"terminal\",\n                                        \"prompt\", NULL };\n\nstatic char *(p_bufhidden_values[]) = { \"hide\", \"unload\", \"delete\",\n                                        \"wipe\", NULL };\nstatic char *(p_bs_values[]) = { \"indent\", \"eol\", \"start\", \"nostop\", NULL };\nstatic char *(p_fdm_values[]) =       { \"manual\", \"expr\", \"marker\", \"indent\",\n                                        \"syntax\",  \"diff\", NULL };\nstatic char *(p_fcl_values[]) =       { \"all\", NULL };\nstatic char *(p_cot_values[]) =       { \"menu\", \"menuone\", \"longest\", \"preview\",\n                                        \"noinsert\", \"noselect\", NULL };\n#ifdef BACKSLASH_IN_FILENAME\nstatic char *(p_csl_values[]) =       { \"slash\", \"backslash\", NULL };\n#endif\nstatic char *(p_icm_values[]) =       { \"nosplit\", \"split\", NULL };\nstatic char *(p_scl_values[]) =       { \"yes\", \"no\", \"auto\", \"auto:1\", \"auto:2\",\n  \"auto:3\", \"auto:4\", \"auto:5\", \"auto:6\", \"auto:7\", \"auto:8\", \"auto:9\",\n  \"yes:1\", \"yes:2\", \"yes:3\", \"yes:4\", \"yes:5\", \"yes:6\", \"yes:7\", \"yes:8\",\n  \"yes:9\", \"number\", NULL };\nstatic char *(p_fdc_values[]) =       { \"auto\", \"auto:1\", \"auto:2\",\n  \"auto:3\", \"auto:4\", \"auto:5\", \"auto:6\", \"auto:7\", \"auto:8\", \"auto:9\",\n  \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", NULL };\n\n/// All possible flags for 'shm'.\nstatic char_u SHM_ALL[] = {\n  SHM_RO, SHM_MOD, SHM_FILE, SHM_LAST, SHM_TEXT, SHM_LINES, SHM_NEW, SHM_WRI,\n  SHM_ABBREVIATIONS, SHM_WRITE, SHM_TRUNC, SHM_TRUNCALL, SHM_OVER,\n  SHM_OVERALL, SHM_SEARCH, SHM_ATTENTION, SHM_INTRO, SHM_COMPLETIONMENU,\n  SHM_RECORDING, SHM_FILEINFO, SHM_SEARCHCOUNT,\n  0,\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"option.c.generated.h\"\n#endif\n\n/// Initialize the options, first part.\n///\n/// Called only once from main(), just after creating the first buffer.\n/// If \"clean_arg\" is true, Nvim was started with --clean.\n///\n/// NOTE: ELOG() etc calls are not allowed here, as log location depends on\n/// env var expansion which depends on expression evaluation and other\n/// editor state initialized here. Do logging in set_init_2 or later.\nvoid set_init_1(bool clean_arg)\n{\n  int opt_idx;\n\n  langmap_init();\n\n  /*\n   * Find default value for 'shell' option.\n   * Don't use it if it is empty.\n   */\n  {\n    const char *shell = os_getenv(\"SHELL\");\n    if (shell != NULL) {\n      if (vim_strchr((const char_u *)shell, ' ') != NULL) {\n        const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL\n        char *const cmd = xmalloc(len);\n        snprintf(cmd, len, \"\\\"%s\\\"\", shell);\n        set_string_default(\"sh\", cmd, true);\n      } else {\n        set_string_default(\"sh\", (char *)shell, false);\n      }\n    }\n  }\n\n  /*\n   * Set the default for 'backupskip' to include environment variables for\n   * temp files.\n   */\n  {\n# ifdef UNIX\n    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n    garray_T ga;\n    opt_idx = findoption(\"backupskip\");\n\n    ga_init(&ga, 1, 100);\n    for (size_t n = 0; n < ARRAY_SIZE(names); n++) {\n      bool mustfree = true;\n      char *p;\n# ifdef UNIX\n      if (*names[n] == NUL) {\n#  ifdef __APPLE__\n        p = \"/private/tmp\";\n#  else\n        p = \"/tmp\";\n#  endif\n        mustfree = false;\n      } else\n# endif\n      {\n        p = vim_getenv(names[n]);\n      }\n      if (p != NULL && *p != NUL) {\n        // First time count the NUL, otherwise count the ','.\n        const size_t len = strlen(p) + 3;\n        char *item = xmalloc(len);\n        xstrlcpy(item, p, len);\n        add_pathsep(item);\n        xstrlcat(item, \"*\", len);\n        if (find_dup_item(ga.ga_data, (char_u *)item, options[opt_idx].flags)\n            == NULL) {\n          ga_grow(&ga, (int)len);\n          if (!GA_EMPTY(&ga)) {\n            STRCAT(ga.ga_data, \",\");\n          }\n          STRCAT(ga.ga_data, p);\n          add_pathsep(ga.ga_data);\n          STRCAT(ga.ga_data, \"*\");\n          ga.ga_len += (int)len;\n        }\n        xfree(item);\n      }\n      if(mustfree) {\n        xfree(p);\n      }\n    }\n    if (ga.ga_data != NULL) {\n      set_string_default(\"bsk\", ga.ga_data, true);\n    }\n  }\n\n  {\n    char_u  *cdpath;\n    char_u  *buf;\n    int i;\n    int j;\n\n    // Initialize the 'cdpath' option's default value.\n    cdpath = (char_u *)vim_getenv(\"CDPATH\");\n    if (cdpath != NULL) {\n      buf = xmalloc(2 * STRLEN(cdpath) + 2);\n      {\n        buf[0] = ',';               // start with \",\", current dir first\n        j = 1;\n        for (i = 0; cdpath[i] != NUL; i++) {\n          if (vim_ispathlistsep(cdpath[i])) {\n            buf[j++] = ',';\n          } else {\n            if (cdpath[i] == ' ' || cdpath[i] == ',') {\n              buf[j++] = '\\\\';\n            }\n            buf[j++] = cdpath[i];\n          }\n        }\n        buf[j] = NUL;\n        opt_idx = findoption(\"cdpath\");\n        if (opt_idx >= 0) {\n          options[opt_idx].def_val = buf;\n          options[opt_idx].flags |= P_DEF_ALLOCED;\n        } else {\n          xfree(buf);           // cannot happen\n        }\n      }\n      xfree(cdpath);\n    }\n  }\n\n#if defined(MSWIN) || defined(MAC)\n  // Set print encoding on platforms that don't default to latin1\n  set_string_default(\"printencoding\", \"hp-roman8\", false);\n#endif\n\n  // 'printexpr' must be allocated to be able to evaluate it.\n  set_string_default(\"printexpr\",\n#ifdef UNIX\n                     \"system(['lpr'] \"\n                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"\n                            \"+ [v:fname_in])\"\n                     \". delete(v:fname_in)\"\n                     \"+ v:shell_error\",\n#elif defined(MSWIN)\n                     \"system(['copy', v:fname_in, \"\n                             \"empty(&printdevice)?'LPT1':&printdevice])\"\n                     \". delete(v:fname_in)\",\n#else\n                     \"\",\n#endif\n                     false);\n\n  char *backupdir = stdpaths_user_data_subpath(\"backup\", 2, true);\n  const size_t backupdir_len = strlen(backupdir);\n  backupdir = xrealloc(backupdir, backupdir_len + 3);\n  memmove(backupdir + 2, backupdir, backupdir_len + 1);\n  memmove(backupdir, \".,\", 2);\n  set_string_default(\"backupdir\", backupdir, true);\n  set_string_default(\"viewdir\", stdpaths_user_data_subpath(\"view\", 2, true),\n                     true);\n  set_string_default(\"directory\", stdpaths_user_data_subpath(\"swap\", 2, true),\n                     true);\n  set_string_default(\"undodir\", stdpaths_user_data_subpath(\"undo\", 2, true),\n                     true);\n  // Set default for &runtimepath. All necessary expansions are performed in\n  // this function.\n  char *rtp = runtimepath_default(clean_arg);\n  if (rtp) {\n    set_string_default(\"runtimepath\", rtp, true);\n    // Make a copy of 'rtp' for 'packpath'\n    set_string_default(\"packpath\", rtp, false);\n    rtp = NULL;  // ownership taken\n  }\n\n  /*\n   * Set all the options (except the terminal options) to their default\n   * value.  Also set the global value for local options.\n   */\n  set_options_default(0);\n\n\n  curbuf->b_p_initialized = true;\n  curbuf->b_p_ar = -1;          // no local 'autoread' value\n  curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n  check_buf_options(curbuf);\n  check_win_options(curwin);\n  check_options();\n\n  // Set all options to their default value\n  set_options_default(OPT_FREE);\n\n  // set 'laststatus'\n  last_status(false);\n\n  // Must be before option_expand(), because that one needs vim_isIDc()\n  didset_options();\n\n  // Use the current chartab for the generic chartab. This is not in\n  // didset_options() because it only depends on 'encoding'.\n  init_spell_chartab();\n\n  /*\n   * Expand environment variables and things like \"~\" for the defaults.\n   * If option_expand() returns non-NULL the variable is expanded.  This can\n   * only happen for non-indirect options.\n   * Also set the default to the expanded value, so \":set\" does not list\n   * them.\n   * Don't set the P_ALLOCED flag, because we don't want to free the\n   * default.\n   */\n  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {\n    if (options[opt_idx].flags & P_NO_DEF_EXP) {\n      continue;\n    }\n    char *p;\n    if ((options[opt_idx].flags & P_GETTEXT)\n        && options[opt_idx].var != NULL) {\n      p = _(*(char **)options[opt_idx].var);\n    } else {\n      p = (char *) option_expand(opt_idx, NULL);\n    }\n    if (p != NULL) {\n      p = xstrdup(p);\n      *(char **)options[opt_idx].var = p;\n      if (options[opt_idx].flags & P_DEF_ALLOCED) {\n        xfree(options[opt_idx].def_val);\n      }\n      options[opt_idx].def_val = (char_u *)p;\n      options[opt_idx].flags |= P_DEF_ALLOCED;\n    }\n  }\n\n  save_file_ff(curbuf);         // Buffer is unchanged\n\n  /* Detect use of mlterm.\n   * Mlterm is a terminal emulator akin to xterm that has some special\n   * abilities (bidi namely).\n   * NOTE: mlterm's author is being asked to 'set' a variable\n   *       instead of an environment variable due to inheritance.\n   */\n  if (os_env_exists(\"MLTERM\")) {\n    set_option_value(\"tbidi\", 1L, NULL, 0);\n  }\n\n  didset_options2();\n\n  lang_init();\n\n  // enc_locale() will try to find the encoding of the current locale.\n  // This will be used when 'default' is used as encoding specifier\n  // in 'fileencodings'\n  char_u *p = enc_locale();\n  if (p == NULL) {\n      // use utf-8 as 'default' if locale encoding can't be detected.\n      p = (char_u *)xmemdupz(S_LEN(\"utf-8\"));\n  }\n  fenc_default = p;\n\n#ifdef HAVE_WORKING_LIBINTL\n  // GNU gettext 0.10.37 supports this feature: set the codeset used for\n  // translated messages independently from the current locale.\n  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);\n#endif\n\n  // Set the default for 'helplang'.\n  set_helplang_default(get_mess_lang());\n}\n\n/// Set an option to its default value.\n/// This does not take care of side effects!\n///\n/// @param opt_flags OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\nstatic void set_option_default(int opt_idx, int opt_flags)\n{\n  char_u      *varp;            // pointer to variable for current option\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n  varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n  uint32_t flags = options[opt_idx].flags;\n  if (varp != NULL) {       // skip hidden option, nothing to do for it\n    if (flags & P_STRING) {\n      /* Use set_string_option_direct() for local options to handle\n       * freeing and allocating the value. */\n      if (options[opt_idx].indir != PV_NONE) {\n        set_string_option_direct(NULL, opt_idx,\n                                 options[opt_idx].def_val, opt_flags, 0);\n      } else {\n        if ((opt_flags & OPT_FREE) && (flags & P_ALLOCED)) {\n          free_string_option(*(char_u **)(varp));\n        }\n        *(char_u **)varp = options[opt_idx].def_val;\n        options[opt_idx].flags &= ~P_ALLOCED;\n      }\n    } else if (flags & P_NUM)   {\n      if (options[opt_idx].indir == PV_SCROLL) {\n        win_comp_scroll(curwin);\n      } else {\n        long def_val = (long)options[opt_idx].def_val;\n        if ((long *)varp == &curwin->w_p_so\n            || (long *)varp == &curwin->w_p_siso) {\n          // 'scrolloff' and 'sidescrolloff' local values have a\n          // different default value than the global default.\n          *(long *)varp = -1;\n        } else {\n          *(long *)varp = def_val;\n        }\n        // May also set global value for local option.\n        if (both) {\n          *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n            def_val;\n        }\n      }\n    } else {  // P_BOOL\n      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val;\n#ifdef UNIX\n      // 'modeline' defaults to off for root\n      if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID) {\n        *(int *)varp = false;\n      }\n#endif\n      // May also set global value for local option.\n      if (both) {\n        *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n          *(int *)varp;\n      }\n    }\n\n    // The default value is not insecure.\n    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);\n    *flagsp = *flagsp & ~P_INSECURE;\n  }\n\n  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n}\n\n/// Set all options (except terminal options) to their default value.\nstatic void\nset_options_default(\n    int opt_flags               // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n)\n{\n  for (int i = 0; options[i].fullname; i++) {\n    if (!(options[i].flags & P_NODEFAULT)) {\n      set_option_default(i, opt_flags);\n    }\n  }\n\n  // The 'scroll' option must be computed for all windows.\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    win_comp_scroll(wp);\n  }\n\n  parse_cino(curbuf);\n}\n\n/// Set the Vi-default value of a string option.\n/// Used for 'sh', 'backupskip' and 'term'.\n///\n/// @param name The name of the option\n/// @param val The value of the option\n/// @param allocated If true, do not copy default as it was already allocated.\nstatic void set_string_default(const char *name, char *val, bool allocated)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int opt_idx = findoption(name);\n  if (opt_idx >= 0) {\n    if (options[opt_idx].flags & P_DEF_ALLOCED) {\n      xfree(options[opt_idx].def_val);\n    }\n\n    options[opt_idx].def_val = allocated\n        ? (char_u *)val\n        : (char_u *)xstrdup(val);\n    options[opt_idx].flags |= P_DEF_ALLOCED;\n  }\n}\n\n// For an option value that contains comma separated items, find \"newval\" in\n// \"origval\".  Return NULL if not found.\nstatic char_u *find_dup_item(char_u *origval, const char_u *newval,\n                             uint32_t flags)\n  FUNC_ATTR_NONNULL_ARG(2)\n{\n  int bs = 0;\n\n  if (origval == NULL) {\n    return NULL;\n  }\n\n  const size_t newlen = STRLEN(newval);\n  for (char_u *s = origval; *s != NUL; s++) {\n    if ((!(flags & P_COMMA) || s == origval || (s[-1] == ',' && !(bs & 1)))\n        && STRNCMP(s, newval, newlen) == 0\n        && (!(flags & P_COMMA) || s[newlen] == ',' || s[newlen] == NUL)) {\n      return s;\n    }\n    // Count backslashes.  Only a comma with an even number of backslashes\n    // or a single backslash preceded by a comma before it is recognized as\n    // a separator.\n    if ((s > origval + 1 && s[-1] == '\\\\' && s[-2] != ',')\n        || (s == origval + 1 && s[-1] == '\\\\')) {\n      bs++;\n    } else {\n      bs = 0;\n    }\n  }\n  return NULL;\n}\n\n/// Set the Vi-default value of a number option.\n/// Used for 'lines' and 'columns'.\nvoid set_number_default(char *name, long val)\n{\n  int opt_idx;\n\n  opt_idx = findoption(name);\n  if (opt_idx >= 0) {\n    options[opt_idx].def_val = (char_u *)(intptr_t)val;\n  }\n}\n\n#if defined(EXITFREE)\n/// Free all options.\nvoid free_all_options(void)\n{\n  for (int i = 0; options[i].fullname; i++) {\n    if (options[i].indir == PV_NONE) {\n      // global option: free value and default value.\n      if ((options[i].flags & P_ALLOCED) && options[i].var != NULL) {\n        free_string_option(*(char_u **)options[i].var);\n      }\n      if (options[i].flags & P_DEF_ALLOCED) {\n        free_string_option(options[i].def_val);\n      }\n    } else if (options[i].var != VAR_WIN && (options[i].flags & P_STRING)) {\n      // buffer-local option: free global value\n      clear_string_option((char_u **)options[i].var);\n    }\n  }\n}\n#endif\n\n\n/// Initialize the options, part two: After getting Rows and Columns.\nvoid set_init_2(bool headless)\n{\n  // set in set_init_1 but logging is not allowed there\n  ILOG(\"startup runtimepath/packpath value: %s\", p_rtp);\n\n  int idx;\n\n  // 'scroll' defaults to half the window height. The stored default is zero,\n  // which results in the actual value computed from the window height.\n  idx = findoption(\"scroll\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET)) {\n    set_option_default(idx, OPT_LOCAL);\n  }\n  comp_col();\n\n  /*\n   * 'window' is only for backwards compatibility with Vi.\n   * Default is Rows - 1.\n   */\n  if (!option_was_set(\"window\")) {\n    p_window = Rows - 1;\n  }\n  set_number_default(\"window\", Rows - 1);\n  (void)parse_printoptions();      // parse 'printoptions' default value\n}\n\n/// Initialize the options, part three: After reading the .vimrc\nvoid set_init_3(void)\n{\n  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'\n\n  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n  // This is done after other initializations, where 'shell' might have been\n  // set, but only if they have not been set before.\n  int idx_srr = findoption(\"srr\");\n  int do_srr = (idx_srr < 0)\n    ? false\n    : !(options[idx_srr].flags & P_WAS_SET);\n  int idx_sp = findoption(\"sp\");\n  int do_sp = (idx_sp < 0)\n    ? false\n    : !(options[idx_sp].flags & P_WAS_SET);\n\n  size_t len = 0;\n  char_u *p = (char_u *)invocation_path_tail(p_sh, &len);\n  p = vim_strnsave(p, len);\n\n  {\n    //\n    // Default for p_sp is \"| tee\", for p_srr is \">\".\n    // For known shells it is changed here to include stderr.\n    //\n    if (       fnamecmp(p, \"csh\") == 0\n               || fnamecmp(p, \"tcsh\") == 0\n               ) {\n      if (do_sp) {\n        p_sp = (char_u *)\"|& tee\";\n        options[idx_sp].def_val = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">&\";\n        options[idx_srr].def_val = p_srr;\n      }\n    } else if (fnamecmp(p, \"sh\") == 0\n               || fnamecmp(p, \"ksh\") == 0\n               || fnamecmp(p, \"mksh\") == 0\n               || fnamecmp(p, \"pdksh\") == 0\n               || fnamecmp(p, \"zsh\") == 0\n               || fnamecmp(p, \"zsh-beta\") == 0\n               || fnamecmp(p, \"bash\") == 0\n               || fnamecmp(p, \"fish\") == 0\n               || fnamecmp(p, \"ash\") == 0\n               || fnamecmp(p, \"dash\") == 0\n               ) {\n      // Always use POSIX shell style redirection if we reach this\n      if (do_sp) {\n        p_sp = (char_u *)\"2>&1| tee\";\n        options[idx_sp].def_val = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">%s 2>&1\";\n        options[idx_srr].def_val = p_srr;\n      }\n    }\n    xfree(p);\n  }\n\n  if (buf_is_empty(curbuf)) {\n    int idx_ffs = findoption_len(S_LEN(\"ffs\"));\n\n    // Apply the first entry of 'fileformats' to the initial buffer.\n    if (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET)) {\n      set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n  }\n\n  set_title_defaults();  // 'title', 'icon'\n}\n\n/// When 'helplang' is still at its default value, set it to \"lang\".\n/// Only the first two characters of \"lang\" are used.\nvoid set_helplang_default(const char *lang)\n{\n  if (lang == NULL) {\n    return;\n  }\n\n  const size_t lang_len = strlen(lang);\n  if (lang_len < 2) {  // safety check\n    return;\n  }\n  int idx = findoption(\"hlg\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET)) {\n    if (options[idx].flags & P_ALLOCED) {\n      free_string_option(p_hlg);\n    }\n    p_hlg = (char_u *)xmemdupz(lang, lang_len);\n    // zh_CN becomes \"cn\", zh_TW becomes \"tw\".\n    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5) {\n      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);\n      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);\n    } else if (STRLEN(p_hlg) >= 1 && *p_hlg == 'C') {\n      // any C like setting, such as C.UTF-8, becomes \"en\"\n      p_hlg[0] = 'e';\n      p_hlg[1] = 'n';\n    }\n    p_hlg[2] = NUL;\n    options[idx].flags |= P_ALLOCED;\n  }\n}\n\n\n/// 'title' and 'icon' only default to true if they have not been set or reset\n/// in .vimrc and we can read the old value.\n/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n/// they can be reset.  This reduces startup time when using X on a remote\n/// machine.\nvoid set_title_defaults(void)\n{\n  int idx1;\n\n  /*\n   * If GUI is (going to be) used, we can always set the window title and\n   * icon name.  Saves a bit of time, because the X11 display server does\n   * not need to be contacted.\n   */\n  idx1 = findoption(\"title\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val = (char_u *)(intptr_t)0;\n    p_title = 0;\n  }\n  idx1 = findoption(\"icon\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val = (char_u *)(intptr_t)0;\n    p_icon = 0;\n  }\n}\n\n// Parse 'arg' for option settings.\n//\n// 'arg' may be IObuff, but only when no errors can be present and option\n// does not need to be expanded with option_expand().\n// \"opt_flags\":\n// 0 for \":set\"\n// OPT_GLOBAL   for \":setglobal\"\n// OPT_LOCAL    for \":setlocal\" and a modeline\n// OPT_MODELINE for a modeline\n// OPT_WINONLY  to only set window-local options\n// OPT_NOWIN    to skip setting window-local options\n//\n// returns FAIL if an error is detected, OK otherwise\nint do_set(\n    char_u *arg,               // option string (may be written to!)\n    int opt_flags\n)\n{\n  int opt_idx;\n  char_u      *errmsg;\n  char_u errbuf[80];\n  char_u      *startarg;\n  int prefix;           // 1: nothing, 0: \"no\", 2: \"inv\" in front of name\n  char_u nextchar;                  // next non-white char after option name\n  int afterchar;                    // character just after option name\n  int len;\n  int i;\n  varnumber_T value;\n  int key;\n  uint32_t flags;                   // flags for current option\n  char_u      *varp = NULL;         // pointer to variable for current option\n  int did_show = false;             // already showed one value\n  int adding;                       // \"opt+=arg\"\n  int prepending;                   // \"opt^=arg\"\n  int removing;                     // \"opt-=arg\"\n\n  if (*arg == NUL) {\n    showoptions(0, opt_flags);\n    did_show = true;\n    goto theend;\n  }\n\n  while (*arg != NUL) {         // loop to process all options\n    errmsg = NULL;\n    startarg = arg;             // remember for error message\n\n    if (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n        && !(opt_flags & OPT_MODELINE)) {\n      /*\n       * \":set all\"  show all options.\n       * \":set all&\" set all options to their default value.\n       */\n      arg += 3;\n      if (*arg == '&') {\n        arg++;\n        // Only for :set command set global value of local options.\n        set_options_default(OPT_FREE | opt_flags);\n        didset_options();\n        didset_options2();\n        ui_refresh_options();\n        redraw_all_later(CLEAR);\n      } else {\n        showoptions(1, opt_flags);\n        did_show = true;\n      }\n    } else {\n      prefix = 1;\n      if (STRNCMP(arg, \"no\", 2) == 0) {\n        prefix = 0;\n        arg += 2;\n      } else if (STRNCMP(arg, \"inv\", 3) == 0) {\n        prefix = 2;\n        arg += 3;\n      }\n\n      // find end of name\n      key = 0;\n      if (*arg == '<') {\n        opt_idx = -1;\n        // look out for <t_>;>\n        if (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4]) {\n          len = 5;\n        } else {\n          len = 1;\n          while (arg[len] != NUL && arg[len] != '>') {\n            len++;\n          }\n        }\n        if (arg[len] != '>') {\n          errmsg = e_invarg;\n          goto skip;\n        }\n        if (arg[1] == 't' && arg[2] == '_') {  // could be term code\n          opt_idx = findoption_len((const char *)arg + 1, (size_t)(len - 1));\n        }\n        len++;\n        if (opt_idx == -1) {\n          key = find_key_option(arg + 1, true);\n        }\n      } else {\n        len = 0;\n        // The two characters after \"t_\" may not be alphanumeric.\n        if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3]) {\n          len = 4;\n        } else {\n          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {\n            len++;\n          }\n        }\n        opt_idx = findoption_len((const char *)arg, (size_t)len);\n        if (opt_idx == -1) {\n          key = find_key_option(arg, false);\n        }\n      }\n\n      // remember character after option name\n      afterchar = arg[len];\n\n      // skip white space, allow \":set ai  ?\"\n      while (ascii_iswhite(arg[len])) {\n        len++;\n      }\n\n      adding = false;\n      prepending = false;\n      removing = false;\n      if (arg[len] != NUL && arg[len + 1] == '=') {\n        if (arg[len] == '+') {\n          adding = true;                        // \"+=\"\n          len++;\n        } else if (arg[len] == '^') {\n          prepending = true;                    // \"^=\"\n          len++;\n        } else if (arg[len] == '-') {\n          removing = true;                      // \"-=\"\n          len++;\n        }\n      }\n      nextchar = arg[len];\n\n      if (opt_idx == -1 && key == 0) {          // found a mismatch: skip\n        errmsg = (char_u *)N_(\"E518: Unknown option\");\n        goto skip;\n      }\n\n      if (opt_idx >= 0) {\n        if (options[opt_idx].var == NULL) {         // hidden option: skip\n          // Only give an error message when requesting the value of\n          // a hidden option, ignore setting it.\n          if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n              && (!(options[opt_idx].flags & P_BOOL)\n                  || nextchar == '?')) {\n            errmsg = (char_u *)_(e_unsupportedoption);\n          }\n          goto skip;\n        }\n\n        flags = options[opt_idx].flags;\n        varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      } else {\n        flags = P_STRING;\n      }\n\n      /* Skip all options that are not window-local (used when showing\n       * an already loaded buffer in a window). */\n      if ((opt_flags & OPT_WINONLY)\n          && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n        goto skip;\n\n      // Skip all options that are window-local (used for :vimgrep).\n      if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n          && options[opt_idx].var == VAR_WIN) {\n        goto skip;\n      }\n\n      // Disallow changing some options from modelines.\n      if (opt_flags & OPT_MODELINE) {\n        if (flags & (P_SECURE | P_NO_ML)) {\n          errmsg = (char_u *)N_(\"E520: Not allowed in a modeline\");\n          goto skip;\n        }\n        if ((flags & P_MLE) && !p_mle) {\n          errmsg = (char_u *)N_(\n              \"E992: Not allowed in a modeline when 'modelineexpr' is off\");\n          goto skip;\n        }\n        // In diff mode some options are overruled.  This avoids that\n        // 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n        // \"wrap\" gets set.\n        if (curwin->w_p_diff\n            && opt_idx >= 0              // shut up coverity warning\n            && (options[opt_idx].indir == PV_FDM\n                || options[opt_idx].indir == PV_WRAP)) {\n          goto skip;\n        }\n      }\n\n      // Disallow changing some options in the sandbox\n      if (sandbox != 0 && (flags & P_SECURE)) {\n        errmsg = e_sandbox;\n        goto skip;\n      }\n\n      if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL) {\n        arg += len;\n        if (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i') {\n          if (arg[3] == 'm') {  // \"opt&vim\": set to Vim default\n            arg += 3;\n          } else {  // \"opt&vi\": set to Vi default\n            arg += 2;\n          }\n        }\n        if (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n            && arg[1] != NUL && !ascii_iswhite(arg[1])) {\n          errmsg = e_trailing;\n          goto skip;\n        }\n      }\n\n      //\n      // allow '=' and ':' as MS-DOS command.com allows only one\n      // '=' character per \"set\" command line. grrr. (jw)\n      //\n      if (nextchar == '?'\n          || (prefix == 1\n              && vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n              && !(flags & P_BOOL))) {\n        /*\n         * print value\n         */\n        if (did_show) {\n          msg_putchar('\\n');                // cursor below last one\n        } else {\n          gotocmdline(true);                // cursor at status line\n          did_show = true;                  // remember that we did a line\n        }\n        if (opt_idx >= 0) {\n          showoneopt(&options[opt_idx], opt_flags);\n          if (p_verbose > 0) {\n            // Mention where the option was last set.\n            if (varp == options[opt_idx].var) {\n              option_last_set_msg(options[opt_idx].last_set);\n            } else if ((int)options[opt_idx].indir & PV_WIN) {\n              option_last_set_msg(curwin->w_p_script_ctx[\n                  (int)options[opt_idx].indir & PV_MASK]);\n            } else if ((int)options[opt_idx].indir & PV_BUF) {\n              option_last_set_msg(curbuf->b_p_script_ctx[\n                  (int)options[opt_idx].indir & PV_MASK]);\n            }\n          }\n        } else {\n          errmsg = (char_u *)N_(\"E846: Key code not set\");\n          goto skip;\n        }\n        if (nextchar != '?'\n            && nextchar != NUL && !ascii_iswhite(afterchar))\n          errmsg = e_trailing;\n      } else {\n        int value_is_replaced = !prepending && !adding && !removing;\n        int value_checked = false;\n\n        if (flags & P_BOOL) {                       // boolean\n          if (nextchar == '=' || nextchar == ':') {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          /*\n           * \":set opt!\": invert\n           * \":set opt&\": reset to default value\n           * \":set opt<\": reset to global value\n           */\n          if (nextchar == '!') {\n            value = *(int *)(varp) ^ 1;\n          } else if (nextchar == '&') {\n            value = (int)(intptr_t)options[opt_idx].def_val;\n          } else if (nextchar == '<') {\n            // For 'autoread' -1 means to use global value.\n            if ((int *)varp == &curbuf->b_p_ar\n                && opt_flags == OPT_LOCAL) {\n              value = -1;\n            } else {\n              value = *(int *)get_varp_scope(&(options[opt_idx]),\n                                             OPT_GLOBAL);\n            }\n          } else {\n            /*\n             * \":set invopt\": invert\n             * \":set opt\" or \":set noopt\": set or reset\n             */\n            if (nextchar != NUL && !ascii_iswhite(afterchar)) {\n              errmsg = e_trailing;\n              goto skip;\n            }\n            if (prefix == 2) {                  // inv\n              value = *(int *)(varp) ^ 1;\n            } else {\n              value = prefix;\n            }\n          }\n\n          errmsg = (char_u *)set_bool_option(opt_idx, varp, (int)value,\n                                             opt_flags);\n        } else {  // Numeric or string.\n          if (vim_strchr((const char_u *)\"=:&<\", nextchar) == NULL\n              || prefix != 1) {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          if (flags & P_NUM) {                      // numeric\n            // Different ways to set a number option:\n            // &            set to default value\n            // <            set to global value\n            // <xx>         accept special key codes for 'wildchar'\n            // c            accept any non-digit for 'wildchar'\n            // [-]0-9       set number\n            // other        error\n            arg++;\n            if (nextchar == '&') {\n              value = (long)(intptr_t)options[opt_idx].def_val;\n            } else if (nextchar == '<') {\n              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n              // use the global value.\n              if ((long *)varp == &curbuf->b_p_ul && opt_flags == OPT_LOCAL) {\n                value = NO_LOCAL_UNDOLEVEL;\n              } else {\n                value = *(long *)get_varp_scope(\n                    &(options[opt_idx]), OPT_GLOBAL);\n              }\n            } else if (((long *)varp == &p_wc\n                        || (long *)varp == &p_wcm)\n                       && (*arg == '<'\n                           || *arg == '^'\n                           || (*arg != NUL && (!arg[1] || ascii_iswhite(arg[1]))\n                               && !ascii_isdigit(*arg)))) {\n              value = string_to_key(arg);\n              if (value == 0 && (long *)varp != &p_wcm) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else if (*arg == '-' || ascii_isdigit(*arg)) {\n              // Allow negative, octal and hex numbers.\n              vim_str2nr(arg, NULL, &i, STR2NR_ALL, &value, NULL, 0);\n              if (arg[i] != NUL && !ascii_iswhite(arg[i])) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else {\n              errmsg = (char_u *)N_(\"E521: Number required after =\");\n              goto skip;\n            }\n\n            if (adding) {\n              value = *(long *)varp + value;\n            }\n            if (prepending) {\n              value = *(long *)varp * value;\n            }\n            if (removing) {\n              value = *(long *)varp - value;\n            }\n            errmsg = (char_u *)set_num_option(opt_idx, varp, (long)value,\n                                              errbuf, sizeof(errbuf),\n                                              opt_flags);\n          } else if (opt_idx >= 0) {  // String.\n            char_u      *save_arg = NULL;\n            char_u      *s = NULL;\n            char_u      *oldval = NULL;         // previous value if *varp\n            char_u      *newval;\n            char_u      *origval = NULL;\n            char *saved_origval = NULL;\n            char *saved_newval = NULL;\n            unsigned newlen;\n            int comma;\n            bool new_value_alloced = false;  // new string option was allocated\n\n            /* When using \":set opt=val\" for a global option\n             * with a local value the local value will be\n             * reset, use the global value here. */\n            if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n                && ((int)options[opt_idx].indir & PV_BOTH))\n              varp = options[opt_idx].var;\n\n            /* The old value is kept until we are sure that the\n             * new value is valid. */\n            oldval = *(char_u **)varp;\n\n            // When setting the local value of a global\n            // option, the old value may be the global value.\n            if (((int)options[opt_idx].indir & PV_BOTH) && (opt_flags\n                                                            & OPT_LOCAL)) {\n              origval = *(char_u **)get_varp(&options[opt_idx]);\n            } else {\n              origval = oldval;\n            }\n\n            if (nextchar == '&') {  // set to default val\n              newval = options[opt_idx].def_val;\n              // expand environment variables and ~ (since the\n              // default value was already expanded, only\n              // required when an environment variable was set\n              // later\n              new_value_alloced = true;\n              if (newval == NULL) {\n                newval = empty_option;\n              } else if (!(options[opt_idx].flags & P_NO_DEF_EXP)) {\n                s = option_expand(opt_idx, newval);\n                if (s == NULL) {\n                  s = newval;\n                }\n                newval = vim_strsave(s);\n              } else {\n                newval = (char_u *)xstrdup((char *)newval);\n              }\n            } else if (nextchar == '<') {  // set to global val\n              newval = vim_strsave(*(char_u **)get_varp_scope(\n                  &(options[opt_idx]), OPT_GLOBAL));\n              new_value_alloced = true;\n            } else {\n              arg++;                    // jump to after the '=' or ':'\n\n              /*\n               * Set 'keywordprg' to \":help\" if an empty\n               * value was passed to :set by the user.\n               * Misuse errbuf[] for the resulting string.\n               */\n              if (varp == (char_u *)&p_kp\n                  && (*arg == NUL || *arg == ' ')) {\n                STRCPY(errbuf, \":help\");\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Convert 'backspace' number to string, for\n               * adding, prepending and removing string.\n               */\n              else if (varp == (char_u *)&p_bs\n                       && ascii_isdigit(**(char_u **)varp)) {\n                i = getdigits_int((char_u **)varp, true, 0);\n                switch (i) {\n                case 0:\n                  *(char_u **)varp = empty_option;\n                  break;\n                case 1:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol\");\n                  break;\n                case 2:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol,start\");\n                  break;\n                case 3:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol,nostop\");\n                  break;\n                }\n                xfree(oldval);\n                if (origval == oldval) {\n                  origval = *(char_u **)varp;\n                }\n                oldval = *(char_u **)varp;\n              }\n              /*\n               * Convert 'whichwrap' number to string, for\n               * backwards compatibility with Vim 3.0.\n               * Misuse errbuf[] for the resulting string.\n               */\n              else if (varp == (char_u *)&p_ww\n                       && ascii_isdigit(*arg)) {\n                *errbuf = NUL;\n                i = getdigits_int(&arg, true, 0);\n                if (i & 1) {\n                  STRLCAT(errbuf, \"b,\", sizeof(errbuf));\n                }\n                if (i & 2) {\n                  STRLCAT(errbuf, \"s,\", sizeof(errbuf));\n                }\n                if (i & 4) {\n                  STRLCAT(errbuf, \"h,l,\", sizeof(errbuf));\n                }\n                if (i & 8) {\n                  STRLCAT(errbuf, \"<,>,\", sizeof(errbuf));\n                }\n                if (i & 16) {\n                  STRLCAT(errbuf, \"[,],\", sizeof(errbuf));\n                }\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Remove '>' before 'dir' and 'bdir', for\n               * backwards compatibility with version 3.0\n               */\n              else if (  *arg == '>'\n                         && (varp == (char_u *)&p_dir\n                             || varp == (char_u *)&p_bdir)) {\n                arg++;\n              }\n\n              /*\n               * Copy the new string into allocated memory.\n               * Can't use set_string_option_direct(), because\n               * we need to remove the backslashes.\n               */\n              // get a bit too much\n              newlen = (unsigned)STRLEN(arg) + 1;\n              if (adding || prepending || removing) {\n                newlen += (unsigned)STRLEN(origval) + 1;\n              }\n              newval = xmalloc(newlen);\n              s = newval;\n\n              /*\n               * Copy the string, skip over escaped chars.\n               * For WIN32 backslashes before normal\n               * file name characters are not removed, and keep\n               * backslash at start, for \"\\\\machine\\path\", but\n               * do remove it for \"\\\\\\\\machine\\\\path\".\n               * The reverse is found in ExpandOldSetting().\n               */\n              while (*arg && !ascii_iswhite(*arg)) {\n                if (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n                    && !((flags & P_EXPAND)\n                         && vim_isfilec(arg[1])\n                         && !ascii_iswhite(arg[1])\n                         && (arg[1] != '\\\\'\n                             || (s == newval\n                                 && arg[2] != '\\\\')))\n#endif\n                    )\n                  arg++;                        // remove backslash\n                i = utfc_ptr2len(arg);\n                if (i > 1) {\n                  // copy multibyte char\n                  memmove(s, arg, (size_t)i);\n                  arg += i;\n                  s += i;\n                } else {\n                  *s++ = *arg++;\n                }\n              }\n              *s = NUL;\n\n              /*\n               * Expand environment variables and ~.\n               * Don't do it when adding without inserting a\n               * comma.\n               */\n              if (!(adding || prepending || removing)\n                  || (flags & P_COMMA)) {\n                s = option_expand(opt_idx, newval);\n                if (s != NULL) {\n                  xfree(newval);\n                  newlen = (unsigned)STRLEN(s) + 1;\n                  if (adding || prepending || removing) {\n                    newlen += (unsigned)STRLEN(origval) + 1;\n                  }\n                  newval = xmalloc(newlen);\n                  STRCPY(newval, s);\n                }\n              }\n\n              /* locate newval[] in origval[] when removing it\n               * and when adding to avoid duplicates */\n              i = 0;                    // init for GCC\n              if (removing || (flags & P_NODUP)) {\n                i = (int)STRLEN(newval);\n                s = find_dup_item(origval, newval, flags);\n\n                // do not add if already there\n                if ((adding || prepending) && s != NULL) {\n                  prepending = false;\n                  adding = false;\n                  STRCPY(newval, origval);\n                }\n\n                // if no duplicate, move pointer to end of\n                // original value\n                if (s == NULL) {\n                  s = origval + (int)STRLEN(origval);\n                }\n              }\n\n              /* concatenate the two strings; add a ',' if\n               * needed */\n              if (adding || prepending) {\n                comma = ((flags & P_COMMA) && *origval != NUL\n                         && *newval != NUL);\n                if (adding) {\n                  i = (int)STRLEN(origval);\n                  // Strip a trailing comma, would get 2.\n                  if (comma && i > 1\n                      && (flags & P_ONECOMMA) == P_ONECOMMA\n                      && origval[i - 1] == ','\n                      && origval[i - 2] != '\\\\') {\n                    i--;\n                  }\n                  memmove(newval + i + comma, newval,\n                      STRLEN(newval) + 1);\n                  memmove(newval, origval, (size_t)i);\n                } else {\n                  i = (int)STRLEN(newval);\n                  STRMOVE(newval + i + comma, origval);\n                }\n                if (comma) {\n                  newval[i] = ',';\n                }\n              }\n\n              /* Remove newval[] from origval[]. (Note: \"i\" has\n               * been set above and is used here). */\n              if (removing) {\n                STRCPY(newval, origval);\n                if (*s) {\n                  // may need to remove a comma\n                  if (flags & P_COMMA) {\n                    if (s == origval) {\n                      // include comma after string\n                      if (s[i] == ',') {\n                        i++;\n                      }\n                    } else {\n                      // include comma before string\n                      s--;\n                      i++;\n                    }\n                  }\n                  STRMOVE(newval + (s - origval), s + i);\n                }\n              }\n\n              if (flags & P_FLAGLIST) {\n                // Remove flags that appear twice.\n                for (s = newval; *s;) {\n                  // if options have P_FLAGLIST and P_ONECOMMA such as\n                  // 'whichwrap'\n                  if (flags & P_ONECOMMA) {\n                    if (*s != ',' && *(s + 1) == ','\n                        && vim_strchr(s + 2, *s) != NULL) {\n                      // Remove the duplicated value and the next comma.\n                      STRMOVE(s, s + 2);\n                      continue;\n                    }\n                  } else {\n                    if ((!(flags & P_COMMA) || *s != ',')\n                        && vim_strchr(s + 1, *s) != NULL) {\n                      STRMOVE(s, s + 1);\n                      continue;\n                    }\n                  }\n                  s++;\n                }\n              }\n\n              if (save_arg != NULL) {               // number for 'whichwrap'\n                arg = save_arg;\n              }\n              new_value_alloced = true;\n            }\n\n            // Set the new value.\n            *(char_u **)(varp) = newval;\n\n            // origval may be freed by\n            // did_set_string_option(), make a copy.\n            saved_origval = (origval != NULL) ? xstrdup((char *)origval) : 0;\n\n            // newval (and varp) may become invalid if the\n            // buffer is closed by autocommands.\n            saved_newval = (newval != NULL) ? xstrdup((char *)newval) : 0;\n\n            {\n              uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);\n              const int secure_saved = secure;\n\n              // When an option is set in the sandbox, from a\n              // modeline or in secure mode, then deal with side\n              // effects in secure mode.  Also when the value was\n              // set with the P_INSECURE flag and is not\n              // completely replaced.\n              if ((opt_flags & OPT_MODELINE)\n                  || sandbox != 0\n                  || (!value_is_replaced && (*p & P_INSECURE))) {\n                secure = 1;\n              }\n\n              // Handle side effects, and set the global value\n              // for \":set\" on local options. Note: when setting\n              // 'syntax' or 'filetype' autocommands may be\n              // triggered that can cause havoc.\n              errmsg = did_set_string_option(opt_idx, (char_u **)varp,\n                                             new_value_alloced, oldval,\n                                             errbuf, sizeof(errbuf),\n                                             opt_flags, &value_checked);\n\n              secure = secure_saved;\n            }\n\n            if (errmsg == NULL) {\n              if (!starting) {\n                trigger_optionsset_string(opt_idx, opt_flags, saved_origval,\n                                          saved_newval);\n              }\n              if (options[opt_idx].flags & P_UI_OPTION) {\n                ui_call_option_set(cstr_as_string(options[opt_idx].fullname),\n                                   STRING_OBJ(cstr_as_string(saved_newval)));\n              }\n            }\n            xfree(saved_origval);\n            xfree(saved_newval);\n\n            // If error detected, print the error message.\n            if (errmsg != NULL) {\n              goto skip;\n            }\n\n          } else {\n            // key code option(FIXME(tarruda): Show a warning or something\n            // similar)\n          }\n        }\n\n        if (opt_idx >= 0) {\n          did_set_option(opt_idx, opt_flags, value_is_replaced, value_checked);\n        }\n      }\n\nskip:\n      /*\n       * Advance to next argument.\n       * - skip until a blank found, taking care of backslashes\n       * - skip blanks\n       * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n       */\n      for (i = 0; i < 2; i++) {\n        while (*arg != NUL && !ascii_iswhite(*arg)) {\n          if (*arg++ == '\\\\' && *arg != NUL) {\n            arg++;\n          }\n        }\n        arg = skipwhite(arg);\n        if (*arg != '=') {\n          break;\n        }\n      }\n    }\n\n    if (errmsg != NULL) {\n      STRLCPY(IObuff, _(errmsg), IOSIZE);\n      i = (int)STRLEN(IObuff) + 2;\n      if (i + (arg - startarg) < IOSIZE) {\n        // append the argument with the error\n        STRCAT(IObuff, \": \");\n        assert(arg >= startarg);\n        memmove(IObuff + i, startarg, (size_t)(arg - startarg));\n        IObuff[i + (arg - startarg)] = NUL;\n      }\n      // make sure all characters are printable\n      trans_characters(IObuff, IOSIZE);\n\n      no_wait_return++;         // wait_return done later\n      emsg(IObuff);             // show error highlighted\n      no_wait_return--;\n\n      return FAIL;\n    }\n\n    arg = skipwhite(arg);\n  }\n\ntheend:\n  if (silent_mode && did_show) {\n    // After displaying option values in silent mode.\n    silent_mode = false;\n    info_message = true;        // use mch_msg(), not mch_errmsg()\n    msg_putchar('\\n');\n    ui_flush();\n    silent_mode = true;\n    info_message = false;       // use mch_msg(), not mch_errmsg()\n  }\n\n  return OK;\n}\n\n// Call this when an option has been given a new value through a user command.\n// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\nstatic void did_set_option(\n    int opt_idx,\n    int opt_flags,              // possibly with OPT_MODELINE\n    int new_value,              // value was replaced completely\n    int value_checked           // value was checked to be safe, no need to\n                                // set P_INSECURE\n)\n{\n  options[opt_idx].flags |= P_WAS_SET;\n\n  /* When an option is set in the sandbox, from a modeline or in secure mode\n   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n   * flag. */\n  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);\n  if (!value_checked && (secure\n                         || sandbox != 0\n                         || (opt_flags & OPT_MODELINE))) {\n    *p = *p | P_INSECURE;\n  } else if (new_value) {\n    *p = *p & ~P_INSECURE;\n  }\n}\n\nstatic char_u *illegal_char(char_u *errbuf, size_t errbuflen, int c)\n{\n  if (errbuf == NULL) {\n    return (char_u *)\"\";\n  }\n  vim_snprintf((char *)errbuf, errbuflen, _(\"E539: Illegal character <%s>\"),\n               (char *)transchar(c));\n  return errbuf;\n}\n\n/// Convert a key name or string into a key value.\n/// Used for 'wildchar' and 'cedit' options.\nstatic int string_to_key(char_u *arg)\n{\n  if (*arg == '<') {\n    return find_key_option(arg + 1, true);\n  }\n  if (*arg == '^') {\n    return Ctrl_chr(arg[1]);\n  }\n  return *arg;\n}\n\n/// Check value of 'cedit' and set cedit_key.\n/// Returns NULL if value is OK, error message otherwise.\nstatic char_u *check_cedit(void)\n{\n  int n;\n\n  if (*p_cedit == NUL) {\n    cedit_key = -1;\n  } else {\n    n = string_to_key(p_cedit);\n    if (vim_isprintc(n)) {\n      return e_invarg;\n    }\n    cedit_key = n;\n  }\n  return NULL;\n}\n\n// When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n// maketitle() to create and display it.\n// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get\n// the old value back.\nstatic void did_set_title(void)\n{\n  if (starting != NO_SCREEN) {\n    maketitle();\n  }\n}\n\n// set_options_bin -  called when 'bin' changes value.\nvoid set_options_bin(\n    int oldval,\n    int newval,\n    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL\n)\n{\n  /*\n   * The option values that are changed when 'bin' changes are\n   * copied when 'bin is set and restored when 'bin' is reset.\n   */\n  if (newval) {\n    if (!oldval) {              // switched on\n      if (!(opt_flags & OPT_GLOBAL)) {\n        curbuf->b_p_tw_nobin = curbuf->b_p_tw;\n        curbuf->b_p_wm_nobin = curbuf->b_p_wm;\n        curbuf->b_p_ml_nobin = curbuf->b_p_ml;\n        curbuf->b_p_et_nobin = curbuf->b_p_et;\n      }\n      if (!(opt_flags & OPT_LOCAL)) {\n        p_tw_nobin = p_tw;\n        p_wm_nobin = p_wm;\n        p_ml_nobin = p_ml;\n        p_et_nobin = p_et;\n      }\n    }\n\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = 0;       // no automatic line wrap\n      curbuf->b_p_wm = 0;       // no automatic line wrap\n      curbuf->b_p_ml = 0;       // no modelines\n      curbuf->b_p_et = 0;       // no expandtab\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = 0;\n      p_wm = 0;\n      p_ml = false;\n      p_et = false;\n      p_bin = true;             // needed when called for the \"-b\" argument\n    }\n  } else if (oldval) {        // switched off\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n      curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n      curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n      curbuf->b_p_et = curbuf->b_p_et_nobin;\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = p_tw_nobin;\n      p_wm = p_wm_nobin;\n      p_ml = p_ml_nobin;\n      p_et = p_et_nobin;\n    }\n  }\n}\n\n/// Find the parameter represented by the given character (eg ', :, \", or /),\n/// and return its associated value in the 'shada' string.\n/// Only works for number parameters, not for 'r' or 'n'.\n/// If the parameter is not specified in the string or there is no following\n/// number, return -1.\nint get_shada_parameter(int type)\n{\n  char_u  *p;\n\n  p = find_shada_parameter(type);\n  if (p != NULL && ascii_isdigit(*p)) {\n    return atoi((char *)p);\n  }\n  return -1;\n}\n\n/// Find the parameter represented by the given character (eg ''', ':', '\"', or\n/// '/') in the 'shada' option and return a pointer to the string after it.\n/// Return NULL if the parameter is not specified in the string.\nchar_u *find_shada_parameter(int type)\n{\n  char_u  *p;\n\n  for (p = p_shada; *p; p++) {\n    if (*p == type) {\n      return p + 1;\n    }\n    if (*p == 'n') {                // 'n' is always the last one\n      break;\n    }\n    p = vim_strchr(p, ',');         // skip until next ','\n    if (p == NULL) {                // hit the end without finding parameter\n      break;\n    }\n  }\n  return NULL;\n}\n\n/// Expand environment variables for some string options.\n/// These string options cannot be indirect!\n/// If \"val\" is NULL expand the current value of the option.\n/// Return pointer to NameBuff, or NULL when not expanded.\nstatic char_u *option_expand(int opt_idx, char_u *val)\n{\n  // if option doesn't need expansion nothing to do\n  if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL) {\n    return NULL;\n  }\n\n  if (val == NULL) {\n    val = *(char_u **)options[opt_idx].var;\n  }\n\n  // If val is longer than MAXPATHL no meaningful expansion can be done,\n  // expand_env() would truncate the string.\n  if (val == NULL || STRLEN(val) > MAXPATHL) {\n    return NULL;\n  }\n\n  /*\n   * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n   * Escape spaces when expanding 'tags', they are used to separate file\n   * names.\n   * For 'spellsuggest' expand after \"file:\".\n   */\n  expand_env_esc(val, NameBuff, MAXPATHL,\n                 (char_u **)options[opt_idx].var == &p_tags, false,\n                 (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n                 NULL);\n  if (STRCMP(NameBuff, val) == 0) {   // they are the same\n    return NULL;\n  }\n\n  return NameBuff;\n}\n\n// After setting various option values: recompute variables that depend on\n// option values.\nstatic void didset_options(void)\n{\n  // initialize the table for 'iskeyword' et.al.\n  (void)init_chartab();\n\n  (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true);\n  (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, true);\n  (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, true);\n  (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true);\n  (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true);\n  (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true);\n  (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, true);\n  (void)opt_strings_flags(p_rdb, p_rdb_values, &rdb_flags, true);\n  (void)opt_strings_flags(p_tc, p_tc_values, &tc_flags, false);\n  (void)opt_strings_flags(p_tpf, p_tpf_values, &tpf_flags, true);\n  (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, true);\n  (void)opt_strings_flags(p_wop, p_wop_values, &wop_flags, true);\n  (void)opt_strings_flags(p_jop, p_jop_values, &jop_flags, true);\n  (void)spell_check_msm();\n  (void)spell_check_sps();\n  (void)compile_cap_prog(curwin->w_s);\n  (void)did_set_spell_option(true);\n  // set cedit_key\n  (void)check_cedit();\n  briopt_check(curwin);\n  // initialize the table for 'breakat'.\n  fill_breakat_flags();\n  fill_culopt_flags(NULL, curwin);\n}\n\n// More side effects of setting options.\nstatic void didset_options2(void)\n{\n  // Initialize the highlight_attr[] table.\n  highlight_changed();\n\n  // Parse default for 'clipboard'.\n  (void)opt_strings_flags(p_cb, p_cb_values, &cb_flags, true);\n\n  // Parse default for 'fillchars'.\n  (void)set_chars_option(curwin, &curwin->w_p_fcs, true);\n\n  // Parse default for 'listchars'.\n  (void)set_chars_option(curwin, &curwin->w_p_lcs, true);\n\n  // Parse default for 'wildmode'.\n  check_opt_wim();\n  xfree(curbuf->b_p_vsts_array);\n  tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n  xfree(curbuf->b_p_vts_array);\n  tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n}\n\n/// Check for string options that are NULL (normally only termcap options).\nvoid check_options(void)\n{\n  int opt_idx;\n\n  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {\n    if ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL) {\n      check_string_option((char_u **)get_varp(&(options[opt_idx])));\n    }\n  }\n}\n\n/// Check string options in a buffer for NULL value.\nvoid check_buf_options(buf_T *buf)\n{\n  check_string_option(&buf->b_p_bh);\n  check_string_option(&buf->b_p_bt);\n  check_string_option(&buf->b_p_fenc);\n  check_string_option(&buf->b_p_ff);\n  check_string_option(&buf->b_p_def);\n  check_string_option(&buf->b_p_inc);\n  check_string_option(&buf->b_p_inex);\n  check_string_option(&buf->b_p_inde);\n  check_string_option(&buf->b_p_indk);\n  check_string_option(&buf->b_p_fp);\n  check_string_option(&buf->b_p_fex);\n  check_string_option(&buf->b_p_kp);\n  check_string_option(&buf->b_p_mps);\n  check_string_option(&buf->b_p_fo);\n  check_string_option(&buf->b_p_flp);\n  check_string_option(&buf->b_p_isk);\n  check_string_option(&buf->b_p_com);\n  check_string_option(&buf->b_p_cms);\n  check_string_option(&buf->b_p_nf);\n  check_string_option(&buf->b_p_qe);\n  check_string_option(&buf->b_p_syn);\n  check_string_option(&buf->b_s.b_syn_isk);\n  check_string_option(&buf->b_s.b_p_spc);\n  check_string_option(&buf->b_s.b_p_spf);\n  check_string_option(&buf->b_s.b_p_spl);\n  check_string_option(&buf->b_s.b_p_spo);\n  check_string_option(&buf->b_p_sua);\n  check_string_option(&buf->b_p_cink);\n  check_string_option(&buf->b_p_cino);\n  parse_cino(buf);\n  check_string_option(&buf->b_p_ft);\n  check_string_option(&buf->b_p_cinw);\n  check_string_option(&buf->b_p_cpt);\n  check_string_option(&buf->b_p_cfu);\n  check_string_option(&buf->b_p_ofu);\n  check_string_option(&buf->b_p_keymap);\n  check_string_option(&buf->b_p_gp);\n  check_string_option(&buf->b_p_mp);\n  check_string_option(&buf->b_p_efm);\n  check_string_option(&buf->b_p_ep);\n  check_string_option(&buf->b_p_path);\n  check_string_option(&buf->b_p_tags);\n  check_string_option(&buf->b_p_tfu);\n  check_string_option(&buf->b_p_tc);\n  check_string_option(&buf->b_p_dict);\n  check_string_option(&buf->b_p_tsr);\n  check_string_option(&buf->b_p_lw);\n  check_string_option(&buf->b_p_bkc);\n  check_string_option(&buf->b_p_menc);\n  check_string_option(&buf->b_p_vsts);\n  check_string_option(&buf->b_p_vts);\n}\n\n/// Free the string allocated for an option.\n/// Checks for the string being empty_option. This may happen if we're out of\n/// memory, vim_strsave() returned NULL, which was replaced by empty_option by\n/// check_options().\n/// Does NOT check for P_ALLOCED flag!\nvoid free_string_option(char_u *p)\n{\n  if (p != empty_option) {\n    xfree(p);\n  }\n}\n\nvoid clear_string_option(char_u **pp)\n{\n  if (*pp != empty_option) {\n    xfree(*pp);\n  }\n  *pp = empty_option;\n}\n\nstatic void check_string_option(char_u **pp)\n{\n  if (*pp == NULL) {\n    *pp = empty_option;\n  }\n}\n\n/// Return true when option \"opt\" was set from a modeline or in secure mode.\n/// Return false when it wasn't.\n/// Return -1 for an unknown option.\nint was_set_insecurely(win_T *const wp, char_u *opt, int opt_flags)\n{\n  int idx = findoption((const char *)opt);\n\n  if (idx >= 0) {\n    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);\n    return (*flagp & P_INSECURE) != 0;\n  }\n  internal_error(\"was_set_insecurely()\");\n  return -1;\n}\n\n/// Get a pointer to the flags used for the P_INSECURE flag of option\n/// \"opt_idx\".  For some local options a local flags field is used.\n/// NOTE: Caller must make sure that \"wp\" is set to the window from which\n/// the option is used.\nstatic uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)\n{\n  if (opt_flags & OPT_LOCAL) {\n    assert(wp != NULL);\n    switch ((int)options[opt_idx].indir) {\n    case PV_STL:        return &wp->w_p_stl_flags;\n    case PV_FDE:        return &wp->w_p_fde_flags;\n    case PV_FDT:        return &wp->w_p_fdt_flags;\n    case PV_INDE:       return &wp->w_buffer->b_p_inde_flags;\n    case PV_FEX:        return &wp->w_buffer->b_p_fex_flags;\n    case PV_INEX:       return &wp->w_buffer->b_p_inex_flags;\n    }\n  }\n\n  // Nothing special, return global flags field.\n  return &options[opt_idx].flags;\n}\n\n\n/// Redraw the window title and/or tab page text later.\nstatic void redraw_titles(void)\n{\n  need_maketitle = true;\n  redraw_tabline = true;\n}\n\nstatic int shada_idx = -1;\n\n// Set a string option to a new value (without checking the effect).\n// The string is copied into allocated memory.\n// if (\"opt_idx\" == -1) \"name\" is used, otherwise \"opt_idx\" is used.\n// When \"set_sid\" is zero set the scriptID to current_sctx.sc_sid.  When\n// \"set_sid\" is SID_NONE don't set the scriptID.  Otherwise set the scriptID to\n// \"set_sid\".\nvoid\nset_string_option_direct(\n    const char *name,\n    int opt_idx,\n    const char_u *val,\n    int opt_flags,                  // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL\n    int set_sid\n)\n{\n  char_u      *s;\n  char_u      **varp;\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int idx = opt_idx;\n\n  if (idx == -1) {  // Use name.\n    idx = findoption(name);\n    if (idx < 0) {  // Not found (should not happen).\n      internal_error(\"set_string_option_direct()\");\n      IEMSG2(_(\"For option %s\"), name);\n      return;\n    }\n  }\n\n  if (options[idx].var == NULL) {       // can't set hidden option\n    return;\n  }\n\n  assert((void *) options[idx].var != (void *) &p_shada);\n\n  s = vim_strsave(val);\n  {\n    varp = (char_u **)get_varp_scope(&(options[idx]),\n                                     both ? OPT_LOCAL : opt_flags);\n    if ((opt_flags & OPT_FREE) && (options[idx].flags & P_ALLOCED)) {\n      free_string_option(*varp);\n    }\n    *varp = s;\n\n    // For buffer/window local option may also set the global value.\n    if (both) {\n      set_string_option_global(idx, varp);\n    }\n\n    options[idx].flags |= P_ALLOCED;\n\n    /* When setting both values of a global option with a local value,\n    * make the local value empty, so that the global value is used. */\n    if (((int)options[idx].indir & PV_BOTH) && both) {\n      free_string_option(*varp);\n      *varp = empty_option;\n    }\n    if (set_sid != SID_NONE) {\n      sctx_T script_ctx;\n\n      if (set_sid == 0) {\n        script_ctx = current_sctx;\n      } else {\n        script_ctx.sc_sid = set_sid;\n        script_ctx.sc_seq = 0;\n        script_ctx.sc_lnum = 0;\n      }\n      set_option_sctx_idx(idx, opt_flags, script_ctx);\n    }\n  }\n}\n\n/// Set global value for string option when it's a local option.\nstatic void\nset_string_option_global(\n    int opt_idx,                    // option index\n    char_u **varp             // pointer to option variable\n)\n{\n  char_u      **p, *s;\n\n  // the global value is always allocated\n  if (options[opt_idx].var == VAR_WIN) {\n    p = (char_u **)GLOBAL_WO(varp);\n  } else {\n    p = (char_u **)options[opt_idx].var;\n  }\n  if (options[opt_idx].indir != PV_NONE && p != varp) {\n    s = vim_strsave(*varp);\n    free_string_option(*p);\n    *p = s;\n  }\n}\n\n/// Set a string option to a new value, handling the effects\n///\n/// @param[in]  opt_idx  Option to set.\n/// @param[in]  value  New value.\n/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or\n///                        #OPT_GLOBAL.\n///\n/// @return NULL on success, error message on error.\nstatic char *set_string_option(const int opt_idx, const char *const value,\n                               const int opt_flags)\n  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (options[opt_idx].var == NULL) {  // don't set hidden option\n    return NULL;\n  }\n\n  char *const s = xstrdup(value);\n  char **const varp = (char **)get_varp_scope(\n      &(options[opt_idx]),\n      ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n       ? (((int)options[opt_idx].indir & PV_BOTH)\n          ? OPT_GLOBAL : OPT_LOCAL)\n       : opt_flags));\n  char *const oldval = *varp;\n  *varp = s;\n\n  char *const saved_oldval = xstrdup(oldval);\n  char *const saved_newval = xstrdup(s);\n\n  int value_checked = false;\n  char *const r = (char *)did_set_string_option(\n      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval,\n      NULL, 0, opt_flags, &value_checked);\n  if (r == NULL) {\n    did_set_option(opt_idx, opt_flags, true, value_checked);\n  }\n\n  // call autocommand after handling side effects\n  if (r == NULL) {\n    if (!starting) {\n      trigger_optionsset_string(opt_idx, opt_flags, saved_oldval, saved_newval);\n    }\n    if (options[opt_idx].flags & P_UI_OPTION) {\n      ui_call_option_set(cstr_as_string(options[opt_idx].fullname),\n                         STRING_OBJ(cstr_as_string(saved_newval)));\n    }\n  }\n  xfree(saved_oldval);\n  xfree(saved_newval);\n\n  return r;\n}\n\n/// Return true if \"val\" is a valid name: only consists of alphanumeric ASCII\n/// characters or characters in \"allowed\".\nstatic bool valid_name(const char_u *val, const char *allowed)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  for (const char_u *s = val; *s != NUL; s++) {\n    if (!ASCII_ISALNUM(*s)\n        && vim_strchr((const char_u *)allowed, *s) == NULL) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Return true if \"val\" is a valid 'filetype' name.\n/// Also used for 'syntax' and 'keymap'.\nstatic bool valid_filetype(const char_u *val)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return valid_name(val, \".-_\");\n}\n\n/// Return true if \"val\" is a valid 'spelllang' value.\nbool valid_spelllang(const char_u *val)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return valid_name(val, \".-_,@\");\n}\n\n/// Return true if \"val\" is a valid 'spellfile' value.\nstatic bool valid_spellfile(const char_u *val)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  for (const char_u *s = val; *s != NUL; s++) {\n    if (!vim_isfilec(*s) && *s != ',' && *s != ' ') {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Handle string options that need some action to perform when changed.\n/// Returns NULL for success, or an error message for an error.\nstatic char_u *\ndid_set_string_option(\n    int opt_idx,                       // index in options[] table\n    char_u **varp,                     // pointer to the option variable\n    bool new_value_alloced,            // new value was allocated\n    char_u *oldval,                    // previous value of the option\n    char_u *errbuf,                    // buffer for errors, or NULL\n    size_t errbuflen,                  // length of errors buffer\n    int opt_flags,                     // OPT_LOCAL and/or OPT_GLOBAL\n    int *value_checked                 // value was checked to be safe, no\n                                       // need to set P_INSECURE\n)\n{\n  char_u      *errmsg = NULL;\n  char_u      *s, *p;\n  int did_chartab = false;\n  char_u      **gvarp;\n  bool free_oldval = (options[opt_idx].flags & P_ALLOCED);\n  bool value_changed = false;\n\n  /* Get the global option to compare with, otherwise we would have to check\n   * two values for all local options. */\n  gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n  // Disallow changing some options from secure mode\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    errmsg = e_secure;\n  } else if (((options[opt_idx].flags & P_NFNAME)\n              && vim_strpbrk(*varp, (char_u *)(secure ? \"/\\\\*?[|;&<>\\r\\n\"\n                                               : \"/\\\\*?[<>\\r\\n\")) != NULL)\n             || ((options[opt_idx].flags & P_NDNAME)\n                 && vim_strpbrk(*varp, (char_u *)\"*?[|;&<>\\r\\n\") != NULL)) {\n    // Check for a \"normal\" directory or file name in some options.  Disallow a\n    // path separator (slash and/or backslash), wildcards and characters that\n    // are often illegal in a file name. Be more permissive if \"secure\" is off.\n    errmsg = e_invarg;\n  } else if (gvarp == &p_bkc) {  // 'backupcopy'\n    char_u       *bkc   = p_bkc;\n    unsigned int *flags = &bkc_flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      bkc   = curbuf->b_p_bkc;\n      flags = &curbuf->b_bkc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *bkc == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else {\n      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {\n        errmsg = e_invarg;\n      }\n\n      if (((*flags & BKC_AUTO) != 0)\n          + ((*flags & BKC_YES) != 0)\n          + ((*flags & BKC_NO) != 0) != 1) {\n        // Must have exactly one of \"auto\", \"yes\"  and \"no\".\n        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);\n        errmsg = e_invarg;\n      }\n    }\n  } else if (varp == &p_bex || varp == &p_pm) {  // 'backupext' and 'patchmode'\n    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n               *p_pm == '.' ? p_pm + 1 : p_pm) == 0) {\n      errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n    }\n  } else if (varp == &curwin->w_p_briopt) {  // 'breakindentopt'\n    if (briopt_check(curwin) == FAIL) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_isi\n             || varp == &(curbuf->b_p_isk)\n             || varp == &p_isp\n             || varp == &p_isf) {\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    if (init_chartab() == FAIL) {\n      did_chartab = true;           // need to restore it below\n      errmsg = e_invarg;            // error in value\n    }\n  } else if (varp == &p_hf) {  // 'helpfile'\n    // May compute new values for $VIM and $VIMRUNTIME\n    if (didset_vim) {\n      os_setenv(\"VIM\", \"\", 1);\n      didset_vim = false;\n    }\n    if (didset_vimruntime) {\n      os_setenv(\"VIMRUNTIME\", \"\", 1);\n      didset_vimruntime = false;\n    }\n  } else if (varp == &curwin->w_p_culopt\n             || gvarp == &curwin->w_allbuf_opt.wo_culopt) {  // 'cursorlineopt'\n    if (**varp == NUL || fill_culopt_flags(*varp, curwin) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &curwin->w_p_cc) {  // 'colorcolumn'\n    errmsg = check_colorcolumn(curwin);\n  } else if (varp == &p_hlg) {  // 'helplang'\n    // Check for \"\", \"ab\", \"ab,cd\", etc.\n    for (s = p_hlg; *s != NUL; s += 3) {\n      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL)) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (s[2] == NUL) {\n        break;\n      }\n    }\n  } else if (varp == &p_hl) {\n    // 'highlight'\n    if (strcmp((char *)(*varp), HIGHLIGHT_INIT) != 0) {\n      errmsg = e_unsupportedoption;\n    }\n  } else if (varp == &p_jop) {  // 'jumpoptions'\n    if (opt_strings_flags(p_jop, p_jop_values, &jop_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_nf) {  // 'nrformats'\n    if (check_opt_strings(*varp, p_nf_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_ssop) {  // 'sessionoptions'\n    if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n    if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR)) {\n      // Don't allow both \"sesdir\" and \"curdir\".\n      (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, true);\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_vop) {  // 'viewoptions'\n    if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_rdb) {  // 'redrawdebug'\n    if (opt_strings_flags(p_rdb, p_rdb_values, &rdb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_sbo) {  // 'scrollopt'\n    if (check_opt_strings(p_sbo, p_scbopt_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_ambw || (int *)varp == &p_emoji) {\n    // 'ambiwidth'\n    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {\n      errmsg = e_invarg;\n    } else {\n      FOR_ALL_TAB_WINDOWS(tp, wp) {\n        if (set_chars_option(wp, &wp->w_p_lcs, true) != NULL) {\n          errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n          goto ambw_end;\n        }\n        if (set_chars_option(wp, &wp->w_p_fcs, true) != NULL) {\n          errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n          goto ambw_end;\n        }\n      }\nambw_end:\n      {}  // clint prefers {} over ; as an empty statement\n    }\n  } else if (varp == &p_bg) {  // 'background'\n    if (check_opt_strings(p_bg, p_bg_values, false) == OK) {\n      int dark = (*p_bg == 'd');\n\n      init_highlight(false, false);\n\n      if (dark != (*p_bg == 'd') && get_var_value(\"g:colors_name\") != NULL) {\n        // The color scheme must have set 'background' back to another\n        // value, that's not what we want here.  Disable the color\n        // scheme and set the colors again.\n        do_unlet(S_LEN(\"g:colors_name\"), true);\n        free_string_option(p_bg);\n        p_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n        check_string_option(&p_bg);\n        init_highlight(false, false);\n      }\n    } else\n      errmsg = e_invarg;\n  } else if (varp == &p_wim) {  // 'wildmode'\n    if (check_opt_wim() == FAIL) {\n      errmsg = e_invarg;\n    }\n  // 'wildoptions'\n  } else if (varp == &p_wop) {\n    if (opt_strings_flags(p_wop, p_wop_values, &wop_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_wak) {  // 'winaltkeys'\n    if (*p_wak == NUL\n        || check_opt_strings(p_wak, p_wak_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_ei) {  // 'eventignore'\n    if (check_ei() == FAIL) {\n      errmsg = e_invarg;\n    }\n  // 'encoding', 'fileencoding' and 'makeencoding'\n  } else if (varp == &p_enc || gvarp == &p_fenc || gvarp == &p_menc) {\n    if (gvarp == &p_fenc) {\n      if (!MODIFIABLE(curbuf) && opt_flags != OPT_GLOBAL) {\n        errmsg = e_modifiable;\n      } else if (vim_strchr(*varp, ',') != NULL) {\n        // No comma allowed in 'fileencoding'; catches confusing it\n        // with 'fileencodings'.\n        errmsg = e_invarg;\n      } else {\n        // May show a \"+\" in the title now.\n        redraw_titles();\n        // Add 'fileencoding' to the swap file.\n        ml_setflags(curbuf);\n      }\n    }\n\n    if (errmsg == NULL) {\n      // canonize the value, so that STRCMP() can be used on it\n      p = enc_canonize(*varp);\n      xfree(*varp);\n      *varp = p;\n      if (varp == &p_enc) {\n        // only encoding=utf-8 allowed\n        if (STRCMP(p_enc, \"utf-8\") != 0) {\n          errmsg = e_unsupportedoption;\n        }\n      }\n    }\n  } else if (varp == &p_penc) {\n    // Canonize printencoding if VIM standard one\n    p = enc_canonize(p_penc);\n    xfree(p_penc);\n    p_penc = p;\n  } else if (varp == &curbuf->b_p_keymap) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    } else {\n      int secure_save = secure;\n\n      // Reset the secure flag, since the value of 'keymap' has\n      // been checked to be safe.\n      secure = 0;\n\n      // load or unload key mapping tables\n      errmsg = keymap_init();\n\n      secure = secure_save;\n\n      // Since we check the value, there is no need to set P_INSECURE,\n      // even when the value comes from a modeline.\n      *value_checked = true;\n    }\n\n    if (errmsg == NULL) {\n      if (*curbuf->b_p_keymap != NUL) {\n        // Installed a new keymap, switch on using it.\n        curbuf->b_p_iminsert = B_IMODE_LMAP;\n        if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT) {\n          curbuf->b_p_imsearch = B_IMODE_LMAP;\n        }\n      } else {\n        // Cleared the keymap, may reset 'iminsert' and 'imsearch'.\n        if (curbuf->b_p_iminsert == B_IMODE_LMAP) {\n          curbuf->b_p_iminsert = B_IMODE_NONE;\n        }\n        if (curbuf->b_p_imsearch == B_IMODE_LMAP) {\n          curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n        }\n      }\n      if ((opt_flags & OPT_LOCAL) == 0) {\n        set_iminsert_global();\n        set_imsearch_global();\n      }\n      status_redraw_curbuf();\n    }\n  } else if (gvarp == &p_ff) {  // 'fileformat'\n    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL)) {\n      errmsg = e_modifiable;\n    } else if (check_opt_strings(*varp, p_ff_values, false) != OK) {\n      errmsg = e_invarg;\n    } else {\n      redraw_titles();\n      // update flag in swap file\n      ml_setflags(curbuf);\n      /* Redraw needed when switching to/from \"mac\": a CR in the text\n       * will be displayed differently. */\n      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm') {\n        redraw_curbuf_later(NOT_VALID);\n      }\n    }\n  } else if (varp == &p_ffs) {  // 'fileformats'\n    if (check_opt_strings(p_ffs, p_ff_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_mps) {  // 'matchpairs'\n    for (p = *varp; *p != NUL; p++) {\n      int x2 = -1;\n      int x3 = -1;\n\n      if (*p != NUL) {\n        p += utfc_ptr2len(p);\n      }\n      if (*p != NUL) {\n        x2 = *p++;\n      }\n      if (*p != NUL) {\n        x3 = utf_ptr2char(p);\n        p += utfc_ptr2len(p);\n      }\n      if (x2 != ':' || x3 == -1 || (*p != NUL && *p != ',')) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (*p == NUL) {\n        break;\n      }\n    }\n  } else if (gvarp == &p_com) {  // 'comments'\n    for (s = *varp; *s; ) {\n      while (*s && *s != ':') {\n        if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n            && !ascii_isdigit(*s) && *s != '-') {\n          errmsg = illegal_char(errbuf, errbuflen, *s);\n          break;\n        }\n        s++;\n      }\n      if (*s++ == NUL) {\n        errmsg = (char_u *)N_(\"E524: Missing colon\");\n      } else if (*s == ',' || *s == NUL) {\n        errmsg = (char_u *)N_(\"E525: Zero length string\");\n      }\n      if (errmsg != NULL) {\n        break;\n      }\n      while (*s && *s != ',') {\n        if (*s == '\\\\' && s[1] != NUL) {\n          s++;\n        }\n        s++;\n      }\n      s = skip_to_option_part(s);\n    }\n  } else if (varp == &p_lcs) {  // 'listchars'\n    errmsg = set_chars_option(curwin, varp, false);\n    if (!errmsg) {\n      FOR_ALL_TAB_WINDOWS(tp, wp) {\n        set_chars_option(wp, &wp->w_p_lcs, true);\n      }\n    }\n    redraw_all_later(NOT_VALID);\n  } else if (varp == &curwin->w_p_lcs) {  // local 'listchars'\n    errmsg = set_chars_option(curwin, varp, true);\n  } else if (varp == &p_fcs) {  // 'fillchars'\n    errmsg = set_chars_option(curwin, varp, false);\n    if (!errmsg) {\n      FOR_ALL_TAB_WINDOWS(tp, wp) {\n        set_chars_option(wp, &wp->w_p_fcs, true);\n      }\n    }\n    redraw_all_later(NOT_VALID);\n  } else if (varp == &curwin->w_p_fcs) {  // local 'fillchars'\n    errmsg = set_chars_option(curwin, varp, true);\n  } else if (varp == &p_cedit) {  // 'cedit'\n    errmsg = check_cedit();\n  } else if (varp == &p_vfile) {  // 'verbosefile'\n    verbose_stop();\n    if (*p_vfile != NUL && verbose_open() == FAIL) {\n      errmsg = e_invarg;\n    }\n  // 'shada'\n  } else if (varp == &p_shada) {\n    // TODO(ZyX-I): Remove this code in the future, alongside with &viminfo\n    //              option.\n    opt_idx = ((options[opt_idx].fullname[0] == 'v')\n               ? (shada_idx == -1\n                  ? ((shada_idx = findoption(\"shada\")))\n                  : shada_idx)\n               : opt_idx);\n    // Update free_oldval now that we have the opt_idx for 'shada', otherwise\n    // there would be a disconnect between the check for P_ALLOCED at the start\n    // of the function and the set of P_ALLOCED at the end of the function.\n    free_oldval = (options[opt_idx].flags & P_ALLOCED);\n    for (s = p_shada; *s; ) {\n      // Check it's a valid character\n      if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, errbuflen, *s);\n        break;\n      }\n      if (*s == 'n') {          // name is always last one\n        break;\n      } else if (*s == 'r') {  // skip until next ','\n        while (*++s && *s != ',') {}\n      } else if (*s == '%') {\n        // optional number\n        while (ascii_isdigit(*++s)) {}\n      } else if (*s == '!' || *s == 'h' || *s == 'c') {\n        s++;                    // no extra chars\n      } else {                    // must have a number\n        while (ascii_isdigit(*++s)) {}\n\n        if (!ascii_isdigit(*(s - 1))) {\n          if (errbuf != NULL) {\n            vim_snprintf((char *)errbuf, errbuflen,\n                         _(\"E526: Missing number after <%s>\"),\n                         transchar_byte(*(s - 1)));\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n      if (*s == ',') {\n        s++;\n      } else if (*s) {\n        if (errbuf != NULL) {\n          errmsg = (char_u *)N_(\"E527: Missing comma\");\n        } else {\n          errmsg = (char_u *)\"\";\n        }\n        break;\n      }\n    }\n    if (*p_shada && errmsg == NULL && get_shada_parameter('\\'') < 0) {\n      errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n    }\n  } else if (varp == &p_sbr) {  // 'showbreak'\n    for (s = p_sbr; *s; ) {\n      if (ptr2cells(s) != 1) {\n        errmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n      }\n      MB_PTR_ADV(s);\n    }\n  } else if (varp == &p_guicursor) {  // 'guicursor'\n    errmsg = parse_shape_opt(SHAPE_CURSOR);\n  } else if (varp == &p_popt) {\n    errmsg = parse_printoptions();\n  } else if (varp == &p_pmfn) {\n    errmsg = parse_printmbfont();\n  } else if (varp == &p_langmap) {  // 'langmap'\n    langmap_set();\n  } else if (varp == &p_breakat) {  // 'breakat'\n    fill_breakat_flags();\n  } else if (varp == &p_titlestring || varp == &p_iconstring) {\n    // 'titlestring' and 'iconstring'\n    int flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n    // NULL => statusline syntax\n    if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL) {\n      stl_syntax |= flagval;\n    } else {\n      stl_syntax &= ~flagval;\n    }\n    did_set_title();\n\n  } else if (varp == &p_sel) {  // 'selection'\n    if (*p_sel == NUL\n        || check_opt_strings(p_sel, p_sel_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_slm) {  // 'selectmode'\n    if (check_opt_strings(p_slm, p_slm_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_km) {  // 'keymodel'\n    if (check_opt_strings(p_km, p_km_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n      km_startsel = (vim_strchr(p_km, 'a') != NULL);\n    }\n  } else if (varp == &p_mousem) {  // 'mousemodel'\n    if (check_opt_strings(p_mousem, p_mousem_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_swb) {  // 'switchbuf'\n    if (opt_strings_flags(p_swb, p_swb_values, &swb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_debug) {  // 'debug'\n    if (check_opt_strings(p_debug, p_debug_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_dy) {  // 'display'\n    if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      (void)init_chartab();\n      msg_grid_validate();\n    }\n  } else if (varp == &p_ead) {  // 'eadirection'\n    if (check_opt_strings(p_ead, p_ead_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cb) {  // 'clipboard'\n    if (opt_strings_flags(p_cb, p_cb_values, &cb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curwin->w_s->b_p_spl)  // 'spell'\n             || varp == &(curwin->w_s->b_p_spf)) {\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    const bool is_spellfile = varp == &(curwin->w_s->b_p_spf);\n\n    if ((is_spellfile && !valid_spellfile(*varp))\n        || (!is_spellfile && !valid_spelllang(*varp))) {\n      errmsg = e_invarg;\n    } else {\n      errmsg = did_set_spell_option(is_spellfile);\n    }\n  } else if (varp == &(curwin->w_s->b_p_spc)) {\n    // When 'spellcapcheck' is set compile the regexp program.\n    errmsg = compile_cap_prog(curwin->w_s);\n  } else if (varp == &(curwin->w_s->b_p_spo)) {  // 'spelloptions'\n    if (**varp != NUL && STRCMP(\"camel\", *varp) != 0) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_sps) {  // 'spellsuggest'\n    if (spell_check_sps() != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_msm) {  // 'mkspellmem'\n    if (spell_check_msm() != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_bh) {\n    // When 'bufhidden' is set, check for valid value.\n    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_bt) {\n    // When 'buftype' is set, check for valid value.\n    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')\n        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')\n        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, false) != OK) {\n      errmsg = e_invarg;\n    } else {\n      if (curwin->w_status_height) {\n        curwin->w_redr_status = true;\n        redraw_later(curwin, VALID);\n      }\n      curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n      redraw_titles();\n    }\n  } else if (gvarp == &p_stl || varp == &p_ruf) {\n    // 'statusline' or 'rulerformat'\n    int wid;\n\n    if (varp == &p_ruf) {       // reset ru_wid first\n      ru_wid = 0;\n    }\n    s = *varp;\n    if (varp == &p_ruf && *s == '%') {\n      // set ru_wid if 'ruf' starts with \"%99(\"\n      if (*++s == '-') {        // ignore a '-'\n        s++;\n      }\n      wid = getdigits_int(&s, true, 0);\n      if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL) {\n        ru_wid = wid;\n      } else {\n        errmsg = check_stl_option(p_ruf);\n      }\n    } else if (varp == &p_ruf || s[0] != '%' || s[1] != '!') {\n      // check 'statusline' only if it doesn't start with \"%!\"\n      errmsg = check_stl_option(s);\n    }\n    if (varp == &p_ruf && errmsg == NULL) {\n      comp_col();\n    }\n  } else if (gvarp == &p_cpt) {\n    // check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s; ) {\n      while (*s == ',' || *s == ' ')\n        s++;\n      if (!*s) {\n        break;\n      }\n      if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, errbuflen, *s);\n        break;\n      }\n      if (*++s != NUL && *s != ',' && *s != ' ') {\n        if (s[-1] == 'k' || s[-1] == 's') {\n          // skip optional filename after 'k' and 's'\n          while (*s && *s != ',' && *s != ' ') {\n            if (*s == '\\\\' && s[1] != NUL) {\n              s++;\n            }\n            s++;\n          }\n        } else {\n          if (errbuf != NULL) {\n            vim_snprintf((char *)errbuf, errbuflen,\n                         _(\"E535: Illegal character after <%c>\"),\n                         *--s);\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n    }\n  } else if (varp == &p_cot) {  // 'completeopt'\n    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      completeopt_was_set();\n    }\n#ifdef BACKSLASH_IN_FILENAME\n  } else if (gvarp == &p_csl) {  // 'completeslash'\n    if (check_opt_strings(p_csl, p_csl_values, false) != OK\n        || check_opt_strings(curbuf->b_p_csl, p_csl_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n#endif\n  } else if (varp == &curwin->w_p_scl) {\n    // 'signcolumn'\n    if (check_signcolumn(*varp) != OK) {\n      errmsg = e_invarg;\n    }\n    // When changing the 'signcolumn' to or from 'number', recompute the\n    // width of the number column if 'number' or 'relativenumber' is set.\n    if (((*oldval == 'n' && *(oldval + 1) == 'u')\n         || (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) =='u'))\n        && (curwin->w_p_nu || curwin->w_p_rnu)) {\n      curwin->w_nrwidth_line_count = 0;\n    }\n  } else if (varp == &curwin->w_p_fdc || varp == &curwin->w_allbuf_opt.wo_fdc) {\n    // 'foldcolumn'\n    if (check_opt_strings(*varp, p_fdc_values, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_pt) {\n    // 'pastetoggle': translate key codes like in a mapping\n    if (*p_pt) {\n      (void)replace_termcodes(p_pt, STRLEN(p_pt), &p, true, true, true,\n                              CPO_TO_CPO_FLAGS);\n      if (p != NULL) {\n        if (new_value_alloced) {\n          free_string_option(p_pt);\n        }\n        p_pt = p;\n        new_value_alloced = true;\n      }\n    }\n  } else if (varp == &p_bs) {  // 'backspace'\n    if (ascii_isdigit(*p_bs)) {\n      if (*p_bs > '3' || p_bs[1] != NUL) {\n        errmsg = e_invarg;\n      }\n    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_bo) {\n    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_tc) {  // 'tagcase'\n    unsigned int *flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      p = curbuf->b_p_tc;\n      flags = &curbuf->b_tc_flags;\n    } else {\n      p = p_tc;\n      flags = &tc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *p == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else if (*p == NUL\n               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cmp) {  // 'casemap'\n    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_dip) {  // 'diffopt'\n    if (diffopt_changed() == FAIL) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {  // 'foldmethod'\n    if (check_opt_strings(*varp, p_fdm_values, false) != OK\n        || *curwin->w_p_fdm == NUL) {\n      errmsg = e_invarg;\n    } else {\n      foldUpdateAll(curwin);\n      if (foldmethodIsDiff(curwin)) {\n        newFoldLevel();\n      }\n    }\n  } else if (varp == &curwin->w_p_fde) {  // 'foldexpr'\n    if (foldmethodIsExpr(curwin)) {\n      foldUpdateAll(curwin);\n    }\n  } else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {  // 'foldmarker'\n    p = vim_strchr(*varp, ',');\n    if (p == NULL) {\n      errmsg = (char_u *)N_(\"E536: comma required\");\n    } else if (p == *varp || p[1] == NUL) {\n      errmsg = e_invarg;\n    } else if (foldmethodIsMarker(curwin)) {\n      foldUpdateAll(curwin);\n    }\n  } else if (gvarp == &p_cms) {  // 'commentstring'\n    if (**varp != NUL && strstr((char *)(*varp), \"%s\") == NULL) {\n      errmsg = (char_u *)N_(\n          \"E537: 'commentstring' must be empty or contain %s\");\n    }\n  } else if (varp == &p_fdo) {  // 'foldopen'\n    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_fcl) {  // 'foldclose'\n    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {  // 'foldignore'\n    if (foldmethodIsIndent(curwin)) {\n      foldUpdateAll(curwin);\n    }\n  } else if (varp == &p_ve) {  // 'virtualedit'\n    if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, true) != OK) {\n      errmsg = e_invarg;\n    } else if (STRCMP(p_ve, oldval) != 0) {\n      // Recompute cursor position in case the new 've' setting\n      // changes something.\n      validate_virtcol();\n      coladvance(curwin->w_virtcol);\n    }\n  } else if (varp == &p_csqf) {\n    if (p_csqf != NULL) {\n      p = p_csqf;\n      while (*p != NUL) {\n        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n            || p[1] == NUL\n            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n            || (p[2] != NUL && p[2] != ',')) {\n          errmsg = e_invarg;\n          break;\n        } else if (p[2] == NUL) {\n          break;\n        } else {\n          p += 3;\n        }\n      }\n    }\n  } else if (gvarp == &p_cino) {  // 'cinoptions'\n    // TODO(vim): recognize errors\n    parse_cino(curbuf);\n  // inccommand\n  } else if (varp == &p_icm) {\n      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n        errmsg = e_invarg;\n      }\n  } else if (gvarp == &p_ft) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    } else {\n      value_changed = STRCMP(oldval, *varp) != 0;\n\n      // Since we check the value, there is no need to set P_INSECURE,\n      // even when the value comes from a modeline.\n      *value_checked = true;\n    }\n  } else if (gvarp == &p_syn) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    } else {\n      value_changed = STRCMP(oldval, *varp) != 0;\n\n      // Since we check the value, there is no need to set P_INSECURE,\n      // even when the value comes from a modeline.\n      *value_checked = true;\n    }\n  } else if (varp == &curwin->w_p_winhl) {\n    if (!parse_winhl_opt(curwin)) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_tpf) {\n    if (opt_strings_flags(p_tpf, p_tpf_values, &tpf_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curbuf->b_p_vsts)) {  // 'varsofttabstop'\n    char_u *cp;\n\n    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {\n      if (curbuf->b_p_vsts_array) {\n        xfree(curbuf->b_p_vsts_array);\n        curbuf->b_p_vsts_array = 0;\n      }\n    } else {\n      for (cp = *varp; *cp; cp++) {\n        if (ascii_isdigit(*cp)) {\n          continue;\n        }\n        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {\n          continue;\n        }\n        errmsg = e_invarg;\n        break;\n      }\n      if (errmsg == NULL) {\n        long *oldarray = curbuf->b_p_vsts_array;\n        if (tabstop_set(*varp, &(curbuf->b_p_vsts_array))) {\n          xfree(oldarray);\n        } else {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &(curbuf->b_p_vts)) {  // 'vartabstop'\n    char_u *cp;\n\n    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {\n      if (curbuf->b_p_vts_array) {\n        xfree(curbuf->b_p_vts_array);\n        curbuf->b_p_vts_array = NULL;\n      }\n    } else {\n      for (cp = *varp; *cp; cp++) {\n        if (ascii_isdigit(*cp)) {\n          continue;\n        }\n        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {\n          continue;\n        }\n        errmsg = e_invarg;\n        break;\n      }\n      if (errmsg == NULL) {\n        long *oldarray = curbuf->b_p_vts_array;\n        if (tabstop_set(*varp, &(curbuf->b_p_vts_array))) {\n          xfree(oldarray);\n          if (foldmethodIsIndent(curwin)) {\n            foldUpdateAll(curwin);\n          }\n        } else {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &p_qftf) {\n    if (!qf_process_qftf_option()) {\n      errmsg = e_invarg;\n    }\n  } else {\n    // Options that are a list of flags.\n    p = NULL;\n    if (varp == &p_ww) {  // 'whichwrap'\n      p = (char_u *)WW_ALL;\n    }\n    if (varp == &p_shm) {  // 'shortmess'\n      p = (char_u *)SHM_ALL;\n    } else if (varp == &(p_cpo)) {  // 'cpoptions'\n      p = (char_u *)CPO_VI;\n    } else if (varp == &(curbuf->b_p_fo)) {  // 'formatoptions'\n      p = (char_u *)FO_ALL;\n    } else if (varp == &curwin->w_p_cocu) {  // 'concealcursor'\n      p = (char_u *)COCU_ALL;\n    } else if (varp == &p_mouse) {  // 'mouse'\n      p = (char_u *)MOUSE_ALL;\n    }\n    if (p != NULL) {\n      for (s = *varp; *s; s++) {\n        if (vim_strchr(p, *s) == NULL) {\n          errmsg = illegal_char(errbuf, errbuflen, *s);\n          break;\n        }\n      }\n    }\n  }\n\n  /*\n   * If error detected, restore the previous value.\n   */\n  if (errmsg != NULL) {\n    if (new_value_alloced) {\n      free_string_option(*varp);\n    }\n    *varp = oldval;\n    /*\n     * When resetting some values, need to act on it.\n     */\n    if (did_chartab) {\n      (void)init_chartab();\n    }\n  } else {\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n    // Free string options that are in allocated memory.\n    // Use \"free_oldval\", because recursiveness may change the flags under\n    // our fingers (esp. init_highlight()).\n    if (free_oldval) {\n      free_string_option(oldval);\n    }\n    if (new_value_alloced) {\n      options[opt_idx].flags |= P_ALLOCED;\n    } else {\n      options[opt_idx].flags &= ~P_ALLOCED;\n    }\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n        && ((int)options[opt_idx].indir & PV_BOTH)) {\n      /* global option with local value set to use global value; free\n       * the local value and make it empty */\n      p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n      free_string_option(*(char_u **)p);\n      *(char_u **)p = empty_option;\n    } else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL) {\n      // May set global value for local option.\n      set_string_option_global(opt_idx, varp);\n    }\n\n    /*\n     * Trigger the autocommand only after setting the flags.\n     */\n    // When 'syntax' is set, load the syntax of that name\n    if (varp == &(curbuf->b_p_syn)) {\n      static int syn_recursive = 0;\n\n      syn_recursive++;\n      // Only pass true for \"force\" when the value changed or not used\n      // recursively, to avoid endless recurrence.\n      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn, curbuf->b_fname,\n                     value_changed || syn_recursive == 1, curbuf);\n      curbuf->b_flags |= BF_SYN_SET;\n      syn_recursive--;\n    } else if (varp == &(curbuf->b_p_ft)) {\n      // 'filetype' is set, trigger the FileType autocommand\n      // Skip this when called from a modeline and the filetype was\n      // already set to this value.\n      if (!(opt_flags & OPT_MODELINE) || value_changed) {\n        static int ft_recursive = 0;\n        int secure_save = secure;\n\n        // Reset the secure flag, since the value of 'filetype' has\n        // been checked to be safe.\n        secure = 0;\n\n        ft_recursive++;\n        did_filetype = true;\n        // Only pass true for \"force\" when the value changed or not\n        // used recursively, to avoid endless recurrence.\n        apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n                       value_changed || ft_recursive == 1, curbuf);\n        ft_recursive--;\n        // Just in case the old \"curbuf\" is now invalid\n        if (varp != &(curbuf->b_p_ft)) {\n          varp = NULL;\n        }\n        secure = secure_save;\n      }\n    }\n    if (varp == &(curwin->w_s->b_p_spl)) {\n      char_u fname[200];\n      char_u      *q = curwin->w_s->b_p_spl;\n\n      // Skip the first name if it is \"cjk\".\n      if (STRNCMP(q, \"cjk,\", 4) == 0) {\n        q += 4;\n      }\n\n      /*\n       * Source the spell/LANG.vim in 'runtimepath'.\n       * They could set 'spellcapcheck' depending on the language.\n       * Use the first name in 'spelllang' up to '_region' or\n       * '.encoding'.\n       */\n      for (p = q; *p != NUL; p++) {\n        if (!ASCII_ISALNUM(*p) && *p != '-') {\n          break;\n        }\n      }\n      if (p > q) {\n        vim_snprintf((char *)fname, sizeof(fname), \"spell/%.*s.vim\",\n                     (int)(p - q), q);\n        source_runtime(fname, DIP_ALL);\n      }\n    }\n  }\n\n  if (varp == &p_mouse) {\n    setmouse();  // in case 'mouse' changed\n  }\n\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = true;\n\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}  // NOLINT(readability/fn_size)\n\n/// Simple int comparison function for use with qsort()\nstatic int int_cmp(const void *a, const void *b)\n{\n  return *(const int *)a - *(const int *)b;\n}\n\n/// Handle setting 'signcolumn' for value 'val'\n///\n/// @return OK when the value is valid, FAIL otherwise\nint check_signcolumn(char_u *val)\n{\n  // check for basic match\n  if (check_opt_strings(val, p_scl_values, false) == OK) {\n    return OK;\n  }\n\n  // check for 'auto:<NUMBER>-<NUMBER>'\n  if (STRLEN(val) == 8\n      && !STRNCMP(val, \"auto:\", 5)\n      && ascii_isdigit(val[5])\n      && val[6] == '-'\n      && ascii_isdigit(val[7])\n      ) {\n    int min = val[5] - '0';\n    int max = val[7] - '0';\n    if (min < 1 || max < 2 || min > 8 || max > 9 || min >= max) {\n      return FAIL;\n    }\n    return OK;\n  }\n\n  return FAIL;\n}\n\n/// Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n///\n/// @return error message, NULL if it's OK.\nchar_u *check_colorcolumn(win_T *wp)\n{\n  char_u      *s;\n  int col;\n  unsigned int count = 0;\n  int color_cols[256];\n  int j = 0;\n\n  if (wp->w_buffer == NULL) {\n    return NULL;      // buffer was closed\n  }\n\n  for (s = wp->w_p_cc; *s != NUL && count < 255; ) {\n    if (*s == '-' || *s == '+') {\n      // -N and +N: add to 'textwidth'\n      col = (*s == '-') ? -1 : 1;\n      s++;\n      if (!ascii_isdigit(*s)) {\n        return e_invarg;\n      }\n      col = col * getdigits_int(&s, true, 0);\n      if (wp->w_buffer->b_p_tw == 0) {\n        goto skip;          // 'textwidth' not set, skip this item\n      }\n      assert((col >= 0\n              && wp->w_buffer->b_p_tw <= INT_MAX - col\n              && wp->w_buffer->b_p_tw + col >= INT_MIN)\n             || (col < 0\n                 && wp->w_buffer->b_p_tw >= INT_MIN - col\n                 && wp->w_buffer->b_p_tw + col <= INT_MAX));\n      col += (int)wp->w_buffer->b_p_tw;\n      if (col < 0) {\n        goto skip;\n      }\n    } else if (ascii_isdigit(*s)) {\n      col = getdigits_int(&s, true, 0);\n    } else {\n      return e_invarg;\n    }\n    color_cols[count++] = col - 1;      // 1-based to 0-based\nskip:\n    if (*s == NUL) {\n      break;\n    }\n    if (*s != ',') {\n      return e_invarg;\n    }\n    if (*++s == NUL) {\n      return e_invarg;        // illegal trailing comma as in \"set cc=80,\"\n    }\n  }\n\n  xfree(wp->w_p_cc_cols);\n  if (count == 0) {\n    wp->w_p_cc_cols = NULL;\n  } else {\n    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));\n    /* sort the columns for faster usage on screen redraw inside\n     * win_line() */\n    qsort(color_cols, count, sizeof(int), int_cmp);\n\n    for (unsigned int i = 0; i < count; i++) {\n      // skip duplicates\n      if (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i]) {\n        wp->w_p_cc_cols[j++] = color_cols[i];\n      }\n    }\n    wp->w_p_cc_cols[j] = -1;        // end marker\n  }\n\n  return NULL;    // no error\n}\n\nvoid check_blending(win_T *wp)\n{\n  wp->w_grid_alloc.blending =\n    wp->w_p_winbl > 0 || (wp->w_floating && wp->w_float_config.shadow);\n}\n\n\n/// Handle setting 'listchars' or 'fillchars'.\n/// Assume monocell characters\n///\n/// @param varp either &curwin->w_p_lcs or &curwin->w_p_fcs\n/// @return error message, NULL if it's OK.\nstatic char_u *set_chars_option(win_T *wp, char_u **varp, bool set)\n{\n  int round, i, len, entries;\n  char_u *p, *s;\n  int c1;\n  int c2 = 0;\n  int c3 = 0;\n\n  struct chars_tab {\n    int     *cp;    ///< char value\n    char    *name;  ///< char id\n    int     def;    ///< default value\n  };\n  struct chars_tab *tab;\n\n  struct chars_tab fcs_tab[] = {\n    { &wp->w_p_fcs_chars.stl,     \"stl\",      ' '  },\n    { &wp->w_p_fcs_chars.stlnc,   \"stlnc\",    ' '  },\n    { &wp->w_p_fcs_chars.vert,    \"vert\",     9474 },  // \u2502\n    { &wp->w_p_fcs_chars.fold,    \"fold\",     183  },  // \u00b7\n    { &wp->w_p_fcs_chars.foldopen,   \"foldopen\",  '-'  },\n    { &wp->w_p_fcs_chars.foldclosed, \"foldclose\", '+'  },\n    { &wp->w_p_fcs_chars.foldsep,    \"foldsep\",   9474 },  // \u2502\n    { &wp->w_p_fcs_chars.diff,    \"diff\",     '-'  },\n    { &wp->w_p_fcs_chars.msgsep,  \"msgsep\",   ' '  },\n    { &wp->w_p_fcs_chars.eob,     \"eob\",      '~'  },\n  };\n  struct chars_tab lcs_tab[] = {\n    { &wp->w_p_lcs_chars.eol,     \"eol\",      NUL  },\n    { &wp->w_p_lcs_chars.ext,     \"extends\",  NUL  },\n    { &wp->w_p_lcs_chars.nbsp,    \"nbsp\",     NUL  },\n    { &wp->w_p_lcs_chars.prec,    \"precedes\", NUL  },\n    { &wp->w_p_lcs_chars.space,   \"space\",    NUL  },\n    { &wp->w_p_lcs_chars.tab2,    \"tab\",      NUL  },\n    { &wp->w_p_lcs_chars.lead,    \"lead\",     NUL  },\n    { &wp->w_p_lcs_chars.trail,   \"trail\",    NUL  },\n    { &wp->w_p_lcs_chars.conceal, \"conceal\",  NUL  },\n  };\n\n  if (varp == &p_lcs || varp == &wp->w_p_lcs) {\n    tab = lcs_tab;\n    entries = ARRAY_SIZE(lcs_tab);\n    if (varp == &wp->w_p_lcs && wp->w_p_lcs[0] == NUL) {\n      varp = &p_lcs;\n    }\n  } else {\n    tab = fcs_tab;\n    entries = ARRAY_SIZE(fcs_tab);\n    if (varp == &wp->w_p_fcs && wp->w_p_fcs[0] == NUL) {\n      varp = &p_fcs;\n    }\n    if (*p_ambw == 'd') {\n      // XXX: If ambiwidth=double then \"|\" and \"\u00b7\" take 2 columns, which is\n      // forbidden (TUI limitation?). Set old defaults.\n      fcs_tab[2].def = '|';\n      fcs_tab[6].def = '|';\n      fcs_tab[3].def = '-';\n    } else {\n      fcs_tab[2].def = 9474;  // \u2502\n      fcs_tab[6].def = 9474;  // \u2502\n      fcs_tab[3].def = 183;   // \u00b7\n    }\n  }\n\n  // first round: check for valid value, second round: assign values\n  for (round = 0; round <= (set ? 1 : 0); round++) {\n    if (round > 0) {\n      // After checking that the value is valid: set defaults\n      for (i = 0; i < entries; i++) {\n        if (tab[i].cp != NULL) {\n          *(tab[i].cp) = tab[i].def;\n        }\n      }\n      if (varp == &p_lcs || varp == &wp->w_p_lcs) {\n        wp->w_p_lcs_chars.tab1 = NUL;\n        wp->w_p_lcs_chars.tab3 = NUL;\n      }\n    }\n    p = *varp;\n    while (*p) {\n      for (i = 0; i < entries; i++) {\n        len = (int)STRLEN(tab[i].name);\n        if (STRNCMP(p, tab[i].name, len) == 0\n            && p[len] == ':'\n            && p[len + 1] != NUL) {\n          c2 = c3 = 0;\n          s = p + len + 1;\n\n          // TODO(bfredl): use schar_T representation and utfc_ptr2len\n          int c1len = utf_ptr2len(s);\n          c1 = mb_cptr2char_adv((const char_u **)&s);\n          if (mb_char2cells(c1) > 1 || (c1len == 1 && c1 > 127)) {\n            continue;\n          }\n          if (tab[i].cp == &wp->w_p_lcs_chars.tab2) {\n            if (*s == NUL) {\n              continue;\n            }\n            int c2len = utf_ptr2len(s);\n            c2 = mb_cptr2char_adv((const char_u **)&s);\n            if (mb_char2cells(c2) > 1 || (c2len == 1 && c2 > 127)) {\n              continue;\n            }\n            if (!(*s == ',' || *s == NUL)) {\n              int c3len = utf_ptr2len(s);\n              c3 = mb_cptr2char_adv((const char_u **)&s);\n              if (mb_char2cells(c3) > 1 || (c3len == 1 && c3 > 127)) {\n                continue;\n              }\n            }\n          }\n          if (*s == ',' || *s == NUL) {\n            if (round) {\n              if (tab[i].cp == &wp->w_p_lcs_chars.tab2) {\n                wp->w_p_lcs_chars.tab1 = c1;\n                wp->w_p_lcs_chars.tab2 = c2;\n                wp->w_p_lcs_chars.tab3 = c3;\n              } else if (tab[i].cp != NULL) {\n                *(tab[i].cp) = c1;\n              }\n            }\n            p = s;\n            break;\n          }\n        }\n      }\n\n      if (i == entries) {\n        return e_invarg;\n      }\n      if (*p == ',') {\n        p++;\n      }\n    }\n  }\n\n  return NULL;          // no error\n}\n\n/// Check validity of options with the 'statusline' format.\n/// Return error message or NULL.\nchar_u *check_stl_option(char_u *s)\n{\n  int groupdepth = 0;\n  static char_u errbuf[80];\n\n  while (*s) {\n    // Check for valid keys after % sequences\n    while (*s && *s != '%') {\n      s++;\n    }\n    if (!*s) {\n      break;\n    }\n    s++;\n    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {\n      s++;\n      continue;\n    }\n    if (*s == ')') {\n      s++;\n      if (--groupdepth < 0) {\n        break;\n      }\n      continue;\n    }\n    if (*s == '-') {\n      s++;\n    }\n    while (ascii_isdigit(*s)) {\n      s++;\n    }\n    if (*s == STL_USER_HL) {\n      continue;\n    }\n    if (*s == '.') {\n      s++;\n      while (*s && ascii_isdigit(*s))\n        s++;\n    }\n    if (*s == '(') {\n      groupdepth++;\n      continue;\n    }\n    if (vim_strchr(STL_ALL, *s) == NULL) {\n      return illegal_char(errbuf, sizeof(errbuf), *s);\n    }\n    if (*s == '{') {\n      int reevaluate = (*s == '%');\n      s++;\n      while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s) {\n        s++;\n      }\n      if (*s != '}') {\n        return (char_u *)N_(\"E540: Unclosed expression sequence\");\n      }\n    }\n  }\n  if (groupdepth != 0) {\n    return (char_u *)N_(\"E542: unbalanced groups\");\n  }\n  return NULL;\n}\n\nstatic char_u *did_set_spell_option(bool is_spellfile)\n{\n  char_u  *errmsg = NULL;\n\n  if (is_spellfile) {\n    int l = (int)STRLEN(curwin->w_s->b_p_spf);\n    if (l > 0\n        && (l < 4 || STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0)) {\n      errmsg = e_invarg;\n    }\n  }\n\n  if (errmsg == NULL) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_buffer == curbuf && wp->w_p_spell) {\n        errmsg = did_set_spelllang(wp);\n        break;\n      }\n    }\n  }\n\n  return errmsg;\n}\n\n/// Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n/// Return error message when failed, NULL when OK.\nstatic char_u *compile_cap_prog(synblock_T *synblock)\n  FUNC_ATTR_NONNULL_ALL\n{\n  regprog_T   *rp = synblock->b_cap_prog;\n  char_u      *re;\n\n  if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL) {\n    synblock->b_cap_prog = NULL;\n  } else {\n    // Prepend a ^ so that we only match at one column\n    re = concat_str((char_u *)\"^\", synblock->b_p_spc);\n    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n    xfree(re);\n    if (synblock->b_cap_prog == NULL) {\n      synblock->b_cap_prog = rp;         // restore the previous program\n      return e_invarg;\n    }\n  }\n\n  vim_regfree(rp);\n  return NULL;\n}\n\n/// Handle setting `winhighlight' in window \"wp\"\nstatic bool parse_winhl_opt(win_T *wp)\n{\n  int w_hl_id_normal = 0;\n  int w_hl_ids[HLF_COUNT] = { 0 };\n  int hlf;\n\n  const char *p = (const char *)wp->w_p_winhl;\n  while (*p) {\n    char *colon = strchr(p, ':');\n    if (!colon) {\n      return false;\n    }\n    size_t nlen = (size_t)(colon-p);\n    char *hi = colon+1;\n    char *commap = xstrchrnul(hi, ',');\n    int len = (int)(commap-hi);\n    int hl_id = len ? syn_check_group((char_u *)hi, len) : -1;\n\n    if (strncmp(\"Normal\", p, nlen) == 0) {\n      w_hl_id_normal = hl_id;\n    } else {\n      for (hlf = 0; hlf < (int)HLF_COUNT; hlf++) {\n        if (strlen(hlf_names[hlf]) == nlen\n            && strncmp(hlf_names[hlf], p, nlen) == 0) {\n          w_hl_ids[hlf] = hl_id;\n          break;\n        }\n      }\n      if (hlf == HLF_COUNT) {\n        return false;\n      }\n    }\n\n    p = *commap ? commap+1 : \"\";\n  }\n\n  wp->w_hl_id_normal = w_hl_id_normal;\n  memcpy(wp->w_hl_ids, w_hl_ids, sizeof(w_hl_ids));\n  wp->w_hl_needs_update = true;\n  return true;\n}\n\n// Set the script_ctx for an option, taking care of setting the buffer- or\n// window-local value.\nstatic void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)\n{\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int indir = (int)options[opt_idx].indir;\n  const LastSet last_set = {\n    .script_ctx = {\n      script_ctx.sc_sid,\n      script_ctx.sc_seq,\n      script_ctx.sc_lnum + sourcing_lnum\n    },\n    current_channel_id\n  };\n\n  // Remember where the option was set.  For local options need to do that\n  // in the buffer or window structure.\n  if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0) {\n    options[opt_idx].last_set = last_set;\n  }\n  if (both || (opt_flags & OPT_LOCAL)) {\n    if (indir & PV_BUF) {\n      curbuf->b_p_script_ctx[indir & PV_MASK] = last_set;\n    } else if (indir & PV_WIN) {\n      curwin->w_p_script_ctx[indir & PV_MASK] = last_set;\n    }\n  }\n}\n\n/// Set the value of a boolean option, taking care of side effects\n///\n/// @param[in]  opt_idx  Option index in options[] table.\n/// @param[out]  varp  Pointer to the option variable.\n/// @param[in]  value  New value.\n/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.\n///\n/// @return NULL on success, error message on error.\nstatic char *set_bool_option(const int opt_idx, char_u *const varp,\n                             const int value,\n                             const int opt_flags)\n{\n  int old_value = *(int *)varp;\n\n  // Disallow changing some options from secure mode\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return (char *)e_secure;\n  }\n\n  *(int *)varp = value;             // set the new value\n  // Remember where the option was set.\n  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n\n\n  // May set global value for local option.\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0) {\n    *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n  }\n\n  // Ensure that options set to p_force_on cannot be disabled.\n  if ((int *)varp == &p_force_on && p_force_on == false) {\n    p_force_on = true;\n    return (char *)e_unsupportedoption;\n  // Ensure that options set to p_force_off cannot be enabled.\n  } else if ((int *)varp == &p_force_off && p_force_off == true) {\n    p_force_off = false;\n    return (char *)e_unsupportedoption;\n  } else if ((int *)varp == &p_lrm) {\n    // 'langremap' -> !'langnoremap'\n    p_lnr = !p_lrm;\n  } else if ((int *)varp == &p_lnr) {\n    // 'langnoremap' -> !'langremap'\n    p_lrm = !p_lnr;\n  } else if ((int *)varp == &curwin->w_p_cul && !value && old_value) {\n    // 'cursorline'\n    reset_cursorline();\n  // 'undofile'\n  } else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf) {\n    // Only take action when the option was set. When reset we do not\n    // delete the undo file, the option may be set again without making\n    // any changes in between.\n    if (curbuf->b_p_udf || p_udf) {\n      char_u hash[UNDO_HASH_SIZE];\n\n      FOR_ALL_BUFFERS(bp) {\n        // When 'undofile' is set globally: for every buffer, otherwise\n        // only for the current buffer: Try to read in the undofile,\n        // if one exists, the buffer wasn't changed and the buffer was\n        // loaded\n        if ((curbuf == bp\n             || (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n            && !bufIsChanged(bp) && bp->b_ml.ml_mfp != NULL) {\n          u_compute_hash(bp, hash);\n          u_read_undo(NULL, hash, bp->b_fname);\n        }\n      }\n    }\n  } else if ((int *)varp == &curbuf->b_p_ro) {\n    // when 'readonly' is reset globally, also reset readonlymode\n    if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0) {\n      readonlymode = false;\n    }\n\n    // when 'readonly' is set may give W10 again\n    if (curbuf->b_p_ro) {\n      curbuf->b_did_warn = false;\n    }\n\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_ma) {\n    // when 'modifiable' is changed, redraw the window title\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_eol) {\n    // when 'endofline' is changed, redraw the window title\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_fixeol) {\n    // when 'fixeol' is changed, redraw the window title\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_bomb) {\n    // when 'bomb' is changed, redraw the window title and tab page text\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_bin) {\n    // when 'bin' is set also set some other options\n    set_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl) {\n    // when 'buflisted' changes, trigger autocommands\n    apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n                   NULL, NULL, true, curbuf);\n  } else if ((int *)varp == (int *)&curbuf->b_p_swf) {\n    // when 'swf' is set, create swapfile, when reset remove swapfile\n    if (curbuf->b_p_swf && p_uc) {\n      ml_open_file(curbuf);                     // create the swap file\n    } else {\n      // no need to reset curbuf->b_may_swap, ml_open_file() will check\n      // buf->b_p_swf\n      mf_close_file(curbuf, true);              // remove the swap file\n    }\n  } else if ((int *)varp == &p_terse) {\n    // when 'terse' is set change 'shortmess'\n    char_u  *p;\n\n    p = vim_strchr(p_shm, SHM_SEARCH);\n\n    // insert 's' in p_shm\n    if (p_terse && p == NULL) {\n      STRCPY(IObuff, p_shm);\n      STRCAT(IObuff, \"s\");\n      set_string_option_direct(\"shm\", -1, IObuff, OPT_FREE, 0);\n    } else if (!p_terse && p != NULL) {  // remove 's' from p_shm\n      STRMOVE(p, p + 1);\n    }\n  } else if ((int *)varp == &p_paste) {\n    // when 'paste' is set or reset also change other options\n    paste_option_changed();\n  } else if ((int *)varp == &p_im) {\n    // when 'insertmode' is set from an autocommand need to do work here\n    if (p_im) {\n      if ((State & INSERT) == 0) {\n        need_start_insertmode = true;\n      }\n      stop_insert_mode = false;\n    } else if (old_value) {  // only reset if it was set previously\n      need_start_insertmode = false;\n      stop_insert_mode = true;\n      if (restart_edit != 0 && mode_displayed) {\n        clear_cmdline = true;  // remove \"(insert)\"\n      }\n      restart_edit = 0;\n    }\n  } else if ((int *)varp == &p_ic && p_hls) {\n    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw\n    redraw_all_later(SOME_VALID);\n  } else if ((int *)varp == &p_hls) {\n    // when 'hlsearch' is set or reset: reset no_hlsearch\n    set_no_hlsearch(false);\n  } else if ((int *)varp == &curwin->w_p_scb) {\n  // when 'scrollbind' is set: snapshot the current position to avoid a jump\n  // at the end of normal_cmd()\n    if (curwin->w_p_scb) {\n      do_check_scrollbind(false);\n      curwin->w_scbind_pos = curwin->w_topline;\n    }\n  } else if ((int *)varp == &curwin->w_p_pvw) {\n    // There can be only one window with 'previewwindow' set.\n    if (curwin->w_p_pvw) {\n      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n        if (win->w_p_pvw && win != curwin) {\n          curwin->w_p_pvw = false;\n          return N_(\"E590: A preview window already exists\");\n        }\n      }\n    }\n  } else if (varp == (char_u *)&(curbuf->b_p_lisp)) {\n    // When 'lisp' option changes include/exclude '-' in\n    // keyword characters.\n    (void)buf_init_chartab(curbuf, false);          // ignore errors\n  } else if ((int *)varp == &p_title) {\n    // when 'title' changed, may need to change the title; same for 'icon'\n    did_set_title();\n  } else if ((int *)varp == &p_icon) {\n    did_set_title();\n  } else if ((int *)varp == &curbuf->b_changed) {\n    if (!value) {\n      save_file_ff(curbuf);             // Buffer is unchanged\n    }\n    redraw_titles();\n    modified_was_set = value;\n  }\n\n#ifdef BACKSLASH_IN_FILENAME\n  else if ((int *)varp == &p_ssl) {\n    if (p_ssl) {\n      psepc = '/';\n      psepcN = '\\\\';\n      pseps[0] = '/';\n    } else {\n      psepc = '\\\\';\n      psepcN = '/';\n      pseps[0] = '\\\\';\n    }\n\n    // need to adjust the file name arguments and buffer names.\n    buflist_slash_adjust();\n    alist_slash_adjust();\n    scriptnames_slash_adjust();\n  }\n#endif\n  else if ((int *)varp == &curwin->w_p_wrap) {\n    // If 'wrap' is set, set w_leftcol to zero.\n    if (curwin->w_p_wrap) {\n      curwin->w_leftcol = 0;\n    }\n  } else if ((int *)varp == &p_ea) {\n    if (p_ea && !old_value) {\n      win_equal(curwin, false, 0);\n    }\n  } else if ((int *)varp == &p_acd) {\n    // Change directories when the 'acd' option is set now.\n    do_autochdir();\n  } else if ((int *)varp == &curwin->w_p_diff) {  // 'diff'\n    // May add or remove the buffer from the list of diff buffers.\n    diff_buf_adjust(curwin);\n    if (foldmethodIsDiff(curwin)) {\n      foldUpdateAll(curwin);\n    }\n  } else if ((int *)varp == &curwin->w_p_spell) {  // 'spell'\n    if (curwin->w_p_spell) {\n      char_u      *errmsg = did_set_spelllang(curwin);\n      if (errmsg != NULL) {\n        EMSG(_(errmsg));\n      }\n    }\n  }\n\n  if ((int *)varp == &curwin->w_p_arab) {\n    if (curwin->w_p_arab) {\n      /*\n       * 'arabic' is set, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        // set rightleft mode\n        if (!curwin->w_p_rl) {\n          curwin->w_p_rl = true;\n          changed_window_setting();\n        }\n\n        // Enable Arabic shaping (major part of what Arabic requires)\n        if (!p_arshape) {\n          p_arshape = true;\n          redraw_all_later(NOT_VALID);\n        }\n      }\n\n      /* Arabic requires a utf-8 encoding, inform the user if its not\n       * set. */\n      if (STRCMP(p_enc, \"utf-8\") != 0) {\n        static char *w_arabic = N_(\n            \"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n        msg_source(HL_ATTR(HLF_W));\n        msg_attr(_(w_arabic), HL_ATTR(HLF_W));\n        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);\n      }\n\n      // set 'delcombine'\n      p_deco = true;\n\n      // Force-set the necessary keymap for arabic.\n      set_option_value(\"keymap\", 0L, \"arabic\", OPT_LOCAL);\n    } else {\n      /*\n       * 'arabic' is reset, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        // reset rightleft mode\n        if (curwin->w_p_rl) {\n          curwin->w_p_rl = false;\n          changed_window_setting();\n        }\n\n        /* 'arabicshape' isn't reset, it is a global option and\n         * another window may still need it \"on\". */\n      }\n\n      /* 'delcombine' isn't reset, it is a global option and another\n       * window may still want it \"on\". */\n\n      // Revert to the default keymap\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n      curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n    }\n  }\n\n\n  /*\n   * End of handling side effects for bool options.\n   */\n\n  // after handling side effects, call autocommand\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  // Don't do this while starting up or recursively.\n  if (!starting && *get_vim_var_str(VV_OPTION_TYPE) == NUL) {\n    char buf_old[2];\n    char buf_new[2];\n    char buf_type[7];\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%d\",\n                 old_value ? true: false);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%d\",\n                 value ? true: false);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  if (options[opt_idx].flags & P_UI_OPTION) {\n    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),\n                       BOOLEAN_OBJ(value));\n  }\n\n  comp_col();                       // in case 'ruler' or 'showcmd' changed\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0) {\n    curwin->w_set_curswant = true;\n  }\n  check_redraw(options[opt_idx].flags);\n\n  return NULL;\n}\n\n/// Set the value of a number option, taking care of side effects\n///\n/// @param[in]  opt_idx  Option index in options[] table.\n/// @param[out]  varp  Pointer to the option variable.\n/// @param[in]  value  New value.\n/// @param  errbuf  Buffer for error messages.\n/// @param[in]  errbuflen  Length of `errbuf`.\n/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.\n///\n/// @return NULL on success, error message on error.\nstatic char *set_num_option(int opt_idx, char_u *varp, long value,\n                            char_u *errbuf, size_t errbuflen, int opt_flags)\n{\n  char_u      *errmsg = NULL;\n  long old_value = *(long *)varp;\n  long old_Rows = Rows;                 // remember old Rows\n  long        *pp = (long *)varp;\n\n  // Disallow changing some options from secure mode.\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return (char *)e_secure;\n  }\n\n  // Many number options assume their value is in the signed int range.\n  if (value < INT_MIN || value > INT_MAX) {\n      return (char *)e_invarg;\n  }\n\n  // Options that need some validation.\n  if (pp == &p_wh) {\n    if (value < 1) {\n      errmsg = e_positive;\n    } else if (p_wmh > value) {\n      errmsg = e_winheight;\n    }\n  } else if (pp == &p_hh) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_wmh) {\n    if (value < 0) {\n      errmsg = e_positive;\n    } else if (value > p_wh) {\n      errmsg = e_winheight;\n    }\n  } else if (pp == &p_wiw) {\n    if (value < 1) {\n      errmsg = e_positive;\n    } else if (p_wmw > value) {\n      errmsg = e_winwidth;\n    }\n  } else if (pp == &p_wmw) {\n    if (value < 0) {\n      errmsg = e_positive;\n    } else if (value > p_wiw) {\n      errmsg = e_winwidth;\n    }\n  } else if (pp == &p_mco) {\n    value = MAX_MCO;\n  } else if (pp == &p_titlelen) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_uc) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_ch) {\n    int minval = ui_has(kUIMessages) ? 0 : 1;\n    if (value < minval) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_tm) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_hi) {\n    if (value < 0) {\n      errmsg = e_positive;\n    } else if (value > 10000) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &p_re) {\n    if (value < 0 || value > 2) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &p_report) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_so) {\n    if (value < 0 && full_screen) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_siso) {\n    if (value < 0 && full_screen) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_cwh) {\n    if (value < 1) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_ut) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_ss) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &curwin->w_p_fdl || pp == &curwin->w_allbuf_opt.wo_fdl) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &curwin->w_p_cole || pp == &curwin->w_allbuf_opt.wo_cole) {\n    if (value < 0) {\n      errmsg = e_positive;\n    } else if (value > 3) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &curwin->w_p_nuw || pp == &curwin->w_allbuf_opt.wo_nuw) {\n    if (value < 1) {\n      errmsg = e_positive;\n    } else if (value > 20) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &curbuf->b_p_iminsert || pp == &p_iminsert) {\n    if (value < 0 || value > B_IMODE_LAST) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &curbuf->b_p_imsearch || pp == &p_imsearch) {\n    if (value < -1 || value > B_IMODE_LAST) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &curbuf->b_p_channel || pp == &p_channel) {\n    errmsg = e_invarg;\n  } else if (pp == &curbuf->b_p_scbk || pp == &p_scbk) {\n    if (value < -1 || value > SB_MAX) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &curbuf->b_p_sw || pp == &p_sw) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &curbuf->b_p_ts || pp == &p_ts) {\n    if (value < 1) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &curbuf->b_p_tw || pp == &p_tw) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  } else if (pp == &p_wd) {\n    if (value < 0) {\n      errmsg = e_positive;\n    }\n  }\n\n  // Don't change the value and return early if validation failed.\n  if (errmsg != NULL) {\n    return (char *)errmsg;\n  }\n\n  *pp = value;\n  // Remember where the option was set.\n  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n\n  // For these options we want to fix some invalid values.\n  if (pp == &p_window) {\n    if (p_window < 1) {\n      p_window = Rows - 1;\n    } else if (p_window >= Rows) {\n      p_window = Rows - 1;\n    }\n  } else if (pp == &p_ch) {\n    if (ui_has(kUIMessages)) {\n      p_ch = 0;\n    }\n    if (p_ch > Rows - min_rows() + 1) {\n      p_ch = Rows - min_rows() + 1;\n    }\n  }\n\n  // Number options that need some action when changed\n  if (pp == &p_wh) {\n    // 'winheight'\n    if (!ONE_WINDOW && curwin->w_height < p_wh) {\n      win_setheight((int)p_wh);\n    }\n  } else if (pp == &p_hh) {\n    // 'helpheight'\n    if (!ONE_WINDOW && curbuf->b_help && curwin->w_height < p_hh) {\n      win_setheight((int)p_hh);\n    }\n  } else if (pp == &p_wmh) {\n    // 'winminheight'\n    win_setminheight();\n  } else if (pp == &p_wiw) {\n    // 'winwidth'\n    if (!ONE_WINDOW && curwin->w_width < p_wiw) {\n      win_setwidth((int)p_wiw);\n    }\n  } else if (pp == &p_wmw) {\n    // 'winminwidth'\n    win_setminwidth();\n  } else if (pp == &p_ls) {\n    last_status(false);  // (re)set last window status line.\n  } else if (pp == &p_stal) {\n    // (re)set tab page line\n    shell_new_rows();   // recompute window positions and heights\n  } else if (pp == &curwin->w_p_fdl) {\n    newFoldLevel();\n  } else if (pp == &curwin->w_p_fml) {\n    foldUpdateAll(curwin);\n  } else if (pp == &curwin->w_p_fdn) {\n    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin)) {\n      foldUpdateAll(curwin);\n    }\n  } else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts) {\n    // 'shiftwidth' or 'tabstop'\n    if (foldmethodIsIndent(curwin)) {\n      foldUpdateAll(curwin);\n    }\n    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n    // parse 'cinoptions'.\n    if (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0) {\n      parse_cino(curbuf);\n    }\n  } else if (pp == &curbuf->b_p_iminsert) {\n    showmode();\n    // Show/unshow value of 'keymap' in status lines.\n    status_redraw_curbuf();\n  } else if (pp == &p_titlelen) {\n    // if 'titlelen' has changed, redraw the title\n    if (starting != NO_SCREEN && old_value != p_titlelen) {\n      need_maketitle = true;\n    }\n  } else if (pp == &p_ch) {\n    // if p_ch changed value, change the command line height\n    // Only compute the new window layout when startup has been\n    // completed. Otherwise the frame sizes may be wrong.\n    if (p_ch != old_value && full_screen) {\n      command_height();\n    }\n  } else if (pp == &p_uc) {\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    if (p_uc && !old_value) {\n      ml_open_files();\n    }\n  } else if (pp == &p_pb) {\n    p_pb = MAX(MIN(p_pb, 100), 0);\n    hl_invalidate_blends();\n    pum_grid.blending = (p_pb > 0);\n    if (pum_drawn()) {\n      pum_redraw();\n    }\n  } else if (pp == &p_pyx) {\n    if (p_pyx != 0 && p_pyx != 2 && p_pyx != 3) {\n      errmsg = e_invarg;\n    }\n  } else if (pp == &p_ul || pp == &curbuf->b_p_ul) {\n    // sync undo before 'undolevels' changes\n    // use the old value, otherwise u_sync() may not work properly\n    *pp = old_value;\n    u_sync(true);\n    *pp = value;\n  } else if (pp == &curbuf->b_p_tw) {\n    FOR_ALL_TAB_WINDOWS(tp, wp) {\n      check_colorcolumn(wp);\n    }\n  } else if (pp == &curbuf->b_p_scbk || pp == &p_scbk) {\n    if (curbuf->terminal) {\n      // Force the scrollback to take effect.\n      terminal_check_size(curbuf->terminal);\n    }\n  } else if (pp == &curwin->w_p_nuw) {\n    curwin->w_nrwidth_line_count = 0;\n  } else if (pp == &curwin->w_p_winbl && value != old_value) {\n    // 'floatblend'\n    curwin->w_p_winbl = MAX(MIN(curwin->w_p_winbl, 100), 0);\n    curwin->w_hl_needs_update = true;\n    check_blending(curwin);\n  }\n\n\n  // Check the (new) bounds for Rows and Columns here.\n  if (p_lines < min_rows() && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E593: Need at least %d lines\"), min_rows());\n      errmsg = errbuf;\n    }\n    p_lines = min_rows();\n  }\n  if (p_columns < MIN_COLUMNS && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E594: Need at least %d columns\"), MIN_COLUMNS);\n      errmsg = errbuf;\n    }\n    p_columns = MIN_COLUMNS;\n  }\n\n  // True max size is defined by check_shellsize()\n  p_lines = MIN(p_lines, INT_MAX);\n  p_columns = MIN(p_columns, INT_MAX);\n\n  // If the screen (shell) height has been changed, assume it is the\n  // physical screenheight.\n  if (p_lines != Rows || p_columns != Columns) {\n    // Changing the screen size is not allowed while updating the screen.\n    if (updating_screen) {\n      *pp = old_value;\n    } else if (full_screen) {\n      screen_resize((int)p_columns, (int)p_lines);\n    } else {\n      // TODO(bfredl): is this branch ever needed?\n      // Postpone the resizing; check the size and cmdline position for\n      // messages.\n      Rows = (int)p_lines;\n      Columns = (int)p_columns;\n      check_shellsize();\n      if (cmdline_row > Rows - p_ch && Rows > p_ch) {\n        assert(p_ch >= 0 && Rows - p_ch <= INT_MAX);\n        cmdline_row = (int)(Rows - p_ch);\n      }\n    }\n    if (p_window >= Rows || !option_was_set(\"window\")) {\n      p_window = Rows - 1;\n    }\n  }\n\n  if ((curwin->w_p_scr <= 0\n       || (curwin->w_p_scr > curwin->w_height\n           && curwin->w_height > 0))\n      && full_screen) {\n    if (pp == &(curwin->w_p_scr)) {\n      if (curwin->w_p_scr != 0) {\n        errmsg = e_scroll;\n      }\n      win_comp_scroll(curwin);\n    } else if (curwin->w_p_scr <= 0) {\n    // If 'scroll' became invalid because of a side effect silently adjust it.\n      curwin->w_p_scr = 1;\n    } else {  // curwin->w_p_scr > curwin->w_height\n      curwin->w_p_scr = curwin->w_height;\n    }\n  }\n  if ((p_sj < -100 || p_sj >= Rows) && full_screen) {\n    if (Rows != old_Rows) {     // Rows changed, just adjust p_sj\n      p_sj = Rows / 2;\n    } else {\n      errmsg = e_scroll;\n      p_sj = 1;\n    }\n  }\n\n  // May set global value for local option.\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0) {\n    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n  }\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  // Don't do this while starting up, failure or recursively.\n  if (!starting && errmsg == NULL && *get_vim_var_str(VV_OPTION_TYPE) == NUL) {\n    char buf_old[NUMBUFLEN];\n    char buf_new[NUMBUFLEN];\n    char buf_type[7];\n\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%ld\", old_value);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%ld\", value);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  if (errmsg == NULL && options[opt_idx].flags & P_UI_OPTION) {\n    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),\n                       INTEGER_OBJ(value));\n  }\n\n  comp_col();                       // in case 'columns' or 'ls' changed\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0) {\n    curwin->w_set_curswant = true;\n  }\n  check_redraw(options[opt_idx].flags);\n\n  return (char *)errmsg;\n}\n\nstatic void trigger_optionsset_string(int opt_idx, int opt_flags,\n                                      char *oldval, char *newval)\n{\n  // Don't do this recursively.\n  if (oldval != NULL\n      && newval != NULL\n      && *get_vim_var_str(VV_OPTION_TYPE) == NUL) {\n    char buf_type[7];\n\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_OLD, oldval, -1);\n    set_vim_var_string(VV_OPTION_NEW, newval, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *)options[opt_idx].fullname, NULL, false, NULL);\n    reset_v_option_vars();\n  }\n}\n\n/// Called after an option changed: check if something needs to be redrawn.\nstatic void check_redraw(uint32_t flags)\n{\n  // Careful: P_RCLR and P_RALL are a combination of other P_ flags\n  bool doclear = (flags & P_RCLR) == P_RCLR;\n  bool all = ((flags & P_RALL) == P_RALL || doclear);\n\n  if ((flags & P_RSTAT) || all) {  // mark all status lines dirty\n    status_redraw_all();\n  }\n\n  if ((flags & P_RBUF) || (flags & P_RWIN) || all) {\n    changed_window_setting();\n  }\n  if (flags & P_RBUF) {\n    redraw_curbuf_later(NOT_VALID);\n  }\n  if (flags & P_RWINONLY) {\n    redraw_later(curwin, NOT_VALID);\n  }\n  if (doclear) {\n    redraw_all_later(CLEAR);\n  } else if (all) {\n    redraw_all_later(NOT_VALID);\n  }\n}\n\n/// Find index for named option\n///\n/// @param[in]  arg  Option to find index for.\n/// @param[in]  len  Length of the option.\n///\n/// @return Index of the option or -1 if option was not found.\nint findoption_len(const char *const arg, const size_t len)\n{\n  const char *s;\n  const char *p;\n  static int quick_tab[27] = { 0, 0 };  // quick access table\n\n  // For first call: Initialize the quick-access table.\n  // It contains the index for the first option that starts with a certain\n  // letter.  There are 26 letters, plus the first \"t_\" option.\n  if (quick_tab[1] == 0) {\n    p = options[0].fullname;\n    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {\n      if (s[0] != p[0]) {\n        if (s[0] == 't' && s[1] == '_') {\n          quick_tab[26] = i;\n        } else {\n          quick_tab[CharOrdLow(s[0])] = i;\n        }\n      }\n      p = s;\n    }\n  }\n\n  // Check for name starting with an illegal character.\n  if (len == 0 || arg[0] < 'a' || arg[0] > 'z') {\n    return -1;\n  }\n\n  int opt_idx;\n  const bool is_term_opt = (len > 2 && arg[0] == 't' && arg[1] == '_');\n  if (is_term_opt) {\n    opt_idx = quick_tab[26];\n  } else {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n  }\n  // Match full name\n  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {\n    if (strncmp(arg, s, len) == 0 && s[len] == NUL) {\n      break;\n    }\n  }\n  if (s == NULL && !is_term_opt) {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n    // Match short name\n    for (; options[opt_idx].fullname != NULL; opt_idx++) {\n      s = options[opt_idx].shortname;\n      if (s != NULL && strncmp(arg, s, len) == 0 && s[len] == NUL) {\n        break;\n      }\n      s = NULL;\n    }\n  }\n  if (s == NULL) {\n    opt_idx = -1;\n  } else {\n    // Nvim: handle option aliases.\n    if (STRNCMP(options[opt_idx].fullname, \"viminfo\", 7) == 0) {\n      if (STRLEN(options[opt_idx].fullname) == 7) {\n        return findoption_len(\"shada\", 5);\n      }\n      assert(STRCMP(options[opt_idx].fullname, \"viminfofile\") == 0);\n      return findoption_len(\"shadafile\", 9);\n    }\n  }\n  return opt_idx;\n}\n\nbool is_tty_option(const char *name)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return (name[0] == 't' && name[1] == '_')\n    || strequal(name, \"term\")\n    || strequal(name, \"ttytype\");\n}\n\n#define TCO_BUFFER_SIZE 8\n/// @param name TUI-related option\n/// @param[out,allocated] value option string value\nbool get_tty_option(const char *name, char **value)\n{\n  if (strequal(name, \"t_Co\")) {\n    if (value) {\n      if (t_colors <= 1) {\n        *value = xstrdup(\"\");\n      } else {\n        *value = xmalloc(TCO_BUFFER_SIZE);\n        snprintf(*value, TCO_BUFFER_SIZE, \"%d\", t_colors);\n      }\n    }\n    return true;\n  }\n\n  if (strequal(name, \"term\")) {\n    if (value) {\n      *value = p_term ? xstrdup(p_term) : xstrdup(\"nvim\");\n    }\n    return true;\n  }\n\n  if (strequal(name, \"ttytype\")) {\n    if (value) {\n      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(\"nvim\");\n    }\n    return true;\n  }\n\n  if (is_tty_option(name)) {\n    if (value) {\n      // XXX: All other t_* options were removed in 3baba1e7.\n      *value = xstrdup(\"\");\n    }\n    return true;\n  }\n\n  return false;\n}\n\nbool set_tty_option(const char *name, char *value)\n{\n  if (strequal(name, \"term\")) {\n    if (p_term) {\n      xfree(p_term);\n    }\n    p_term = value;\n    return true;\n  }\n\n  if (strequal(name, \"ttytype\")) {\n    if (p_ttytype) {\n      xfree(p_ttytype);\n    }\n    p_ttytype = value;\n    return true;\n  }\n\n  return false;\n}\n\n/// Find index for an option\n///\n/// @param[in]  arg  Option name.\n///\n/// @return Option index or -1 if option was not found.\nstatic int findoption(const char *const arg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return findoption_len(arg, strlen(arg));\n}\n\n/// Gets the value for an option.\n///\n/// @returns:\n/// Number or Toggle option: 1, *numval gets value.\n///           String option: 0, *stringval gets allocated string.\n/// Hidden Number or Toggle option: -1.\n///           hidden String option: -2.\n///                 unknown option: -3.\nint get_option_value(\n    const char *name,\n    long *numval,\n    char_u **stringval,            ///< NULL when only checking existence\n    int opt_flags\n)\n{\n  if (get_tty_option(name, (char **)stringval)) {\n    return 0;\n  }\n\n  int opt_idx = findoption(name);\n  if (opt_idx < 0) {  // Unknown option.\n    return -3;\n  }\n\n  char_u *varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\n  if (options[opt_idx].flags & P_STRING) {\n    if (varp == NULL) {  // hidden option\n      return -2;\n    }\n    if (stringval != NULL) {\n      *stringval = vim_strsave(*(char_u **)(varp));\n    }\n    return 0;\n  }\n\n  if (varp == NULL) {  // hidden option\n    return -1;\n  }\n  if (options[opt_idx].flags & P_NUM) {\n    *numval = *(long *)varp;\n  } else {\n    // Special case: 'modified' is b_changed, but we also want to consider\n    // it set when 'ff' or 'fenc' changed.\n    if ((int *)varp == &curbuf->b_changed) {\n      *numval = curbufIsChanged();\n    } else {\n      *numval = (long) *(int *)varp;  // NOLINT(whitespace/cast)\n    }\n  }\n  return 1;\n}\n\n// Returns the option attributes and its value. Unlike the above function it\n// will return either global value or local value of the option depending on\n// what was requested, but it will never return global value if it was\n// requested to return local one and vice versa. Neither it will return\n// buffer-local value if it was requested to return window-local one.\n//\n// Pretends that option is absent if it is not present in the requested scope\n// (i.e. has no global, window-local or buffer-local value depending on\n// opt_type).\n//\n// Returned flags:\n//       0 hidden or unknown option, also option that does not have requested\n//         type (see SREQ_* in option_defs.h)\n//  see SOPT_* in option_defs.h for other flags\n//\n// Possible opt_type values: see SREQ_* in option_defs.h\nint get_option_value_strict(char *name,\n                            int64_t *numval,\n                            char **stringval,\n                            int opt_type,\n                            void *from)\n{\n  if (get_tty_option(name, stringval)) {\n    return SOPT_STRING | SOPT_GLOBAL;\n  }\n\n  char_u *varp = NULL;\n  int rv = 0;\n  int opt_idx = findoption(name);\n  if (opt_idx < 0) {\n    return 0;\n  }\n\n  vimoption_T *p = &options[opt_idx];\n\n  // Hidden option\n  if (p->var == NULL) {\n    return 0;\n  }\n\n  if (p->flags & P_BOOL) {\n    rv |= SOPT_BOOL;\n  } else if (p->flags & P_NUM) {\n    rv |= SOPT_NUM;\n  } else if (p->flags & P_STRING) {\n    rv |= SOPT_STRING;\n  }\n\n  if (p->indir == PV_NONE) {\n    if (opt_type == SREQ_GLOBAL) {\n      rv |= SOPT_GLOBAL;\n    } else {\n      return 0;  // Did not request global-only option\n    }\n  } else {\n    if (p->indir & PV_BOTH) {\n      rv |= SOPT_GLOBAL;\n    }\n\n    if (p->indir & PV_WIN) {\n      if (opt_type == SREQ_BUF) {\n        return 0;  // Requested buffer-local, not window-local option\n      } else {\n        rv |= SOPT_WIN;\n      }\n    } else if (p->indir & PV_BUF) {\n      if (opt_type == SREQ_WIN) {\n        return 0;  // Requested window-local, not buffer-local option\n      } else {\n        rv |= SOPT_BUF;\n      }\n    }\n  }\n\n  if (stringval == NULL) {\n    return rv;\n  }\n\n  if (opt_type == SREQ_GLOBAL) {\n    if (p->var == VAR_WIN) {\n      return 0;\n    } else {\n      varp = p->var;\n    }\n  } else {\n    if (opt_type == SREQ_BUF) {\n      // Special case: 'modified' is b_changed, but we also want to\n      // consider it set when 'ff' or 'fenc' changed.\n      if (p->indir == PV_MOD) {\n        *numval = bufIsChanged((buf_T *)from);\n        varp = NULL;\n      } else {\n        buf_T *save_curbuf = curbuf;\n\n        // only getting a pointer, no need to use aucmd_prepbuf()\n        curbuf = (buf_T *)from;\n        curwin->w_buffer = curbuf;\n        varp = get_varp(p);\n        curbuf = save_curbuf;\n        curwin->w_buffer = curbuf;\n      }\n    } else if (opt_type == SREQ_WIN) {\n      win_T *save_curwin = curwin;\n      curwin = (win_T *)from;\n      curbuf = curwin->w_buffer;\n      varp = get_varp(p);\n      curwin = save_curwin;\n      curbuf = curwin->w_buffer;\n    }\n\n    if (varp == p->var) {\n      return (rv | SOPT_UNSET);\n    }\n  }\n\n  if (varp != NULL) {\n    if (p->flags & P_STRING) {\n      *stringval = xstrdup(*(char **)(varp));\n    } else if (p->flags & P_NUM) {\n      *numval = *(long *)varp;\n    } else {\n      *numval = *(int *)varp;\n    }\n  }\n\n  return rv;\n}\n\n/// Set the value of an option\n///\n/// @param[in]  name  Option name.\n/// @param[in]  number  New value for the number or boolean option.\n/// @param[in]  string  New value for string option.\n/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).\n///\n/// @return NULL on success, error message on error.\nchar *set_option_value(const char *const name, const long number,\n                       const char *const string, const int opt_flags)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (is_tty_option(name)) {\n    return NULL;  // Fail silently; many old vimrcs set t_xx options.\n  }\n\n  int opt_idx;\n  char_u      *varp;\n\n  opt_idx = findoption(name);\n  if (opt_idx < 0) {\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n  } else {\n    uint32_t flags = options[opt_idx].flags;\n    // Disallow changing some options in the sandbox\n    if (sandbox > 0 && (flags & P_SECURE)) {\n      EMSG(_(e_sandbox));\n      return NULL;\n    }\n    if (flags & P_STRING) {\n      const char *s = string;\n      if (s == NULL) {\n        s = \"\";\n      }\n      return set_string_option(opt_idx, s, opt_flags);\n    } else {\n      varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      if (varp != NULL) {       // hidden option is not changed\n        if (number == 0 && string != NULL) {\n          int idx;\n\n          // Either we are given a string or we are setting option\n          // to zero.\n          for (idx = 0; string[idx] == '0'; idx++) {}\n          if (string[idx] != NUL || idx == 0) {\n            // There's another character after zeros or the string\n            // is empty.  In both cases, we are trying to set a\n            // num option using a string.\n            EMSG3(_(\"E521: Number required: &%s = '%s'\"),\n                  name, string);\n            return NULL;  // do nothing as we hit an error\n          }\n        }\n        if (flags & P_NUM) {\n          return set_num_option(opt_idx, varp, number, NULL, 0, opt_flags);\n        } else {\n          return set_bool_option(opt_idx, varp, (int)number, opt_flags);\n        }\n      }\n    }\n  }\n  return NULL;\n}\n\n// Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n// When \"has_lt\" is true there is a '<' before \"*arg_arg\".\n// Returns 0 when the key is not recognized.\nint find_key_option_len(const char_u *arg_arg, size_t len, bool has_lt)\n{\n  int key = 0;\n  int modifiers;\n  const char_u *arg = arg_arg;\n\n  // Don't use get_special_key_code() for t_xx, we don't want it to call\n  // add_termcap_entry().\n  if (len >= 4 && arg[0] == 't' && arg[1] == '_') {\n    key = TERMCAP2KEY(arg[2], arg[3]);\n  } else if (has_lt)  {\n    arg--;  // put arg at the '<'\n    modifiers = 0;\n    key = find_special_key(&arg, len + 1, &modifiers, true, true, false);\n    if (modifiers) {  // can't handle modifiers here\n      key = 0;\n    }\n  }\n  return key;\n}\n\nstatic int find_key_option(const char_u *arg, bool has_lt)\n{\n  return find_key_option_len(arg, STRLEN(arg), has_lt);\n}\n\n/// if 'all' == 0: show changed options\n/// if 'all' == 1: show all normal options\nstatic void\nshowoptions(\n    int all,\n    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL\n)\n{\n  vimoption_T    *p;\n  int col;\n  char_u              *varp;\n  int item_count;\n  int run;\n  int row, rows;\n  int cols;\n  int i;\n  int len;\n\n#define INC 20\n#define GAP 3\n\n  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);\n\n  // Highlight title\n  if (opt_flags & OPT_GLOBAL) {\n    MSG_PUTS_TITLE(_(\"\\n--- Global option values ---\"));\n  } else if (opt_flags & OPT_LOCAL) {\n    MSG_PUTS_TITLE(_(\"\\n--- Local option values ---\"));\n  } else {\n    MSG_PUTS_TITLE(_(\"\\n--- Options ---\"));\n  }\n\n  // Do the loop two times:\n  // 1. display the short items\n  // 2. display the long items (only strings and numbers)\n  for (run = 1; run <= 2 && !got_int; run++) {\n    // collect the items in items[]\n    item_count = 0;\n    for (p = &options[0]; p->fullname != NULL; p++) {\n      // apply :filter /pat/\n      if (message_filtered((char_u *)p->fullname)) {\n        continue;\n      }\n\n      varp = NULL;\n      if (opt_flags != 0) {\n        if (p->indir != PV_NONE) {\n          varp = get_varp_scope(p, opt_flags);\n        }\n      } else {\n        varp = get_varp(p);\n      }\n      if (varp != NULL\n          && (all == 1 || (all == 0 && !optval_default(p, varp)))) {\n        if (p->flags & P_BOOL) {\n          len = 1;                      //  a toggle option fits always\n        } else {\n          option_value2string(p, opt_flags);\n          len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n        }\n        if ((len <= INC - GAP && run == 1)\n            || (len > INC - GAP && run == 2)) {\n          items[item_count++] = p;\n        }\n      }\n    }\n\n    /*\n     * display the items\n     */\n    if (run == 1) {\n      assert(Columns <= INT_MAX - GAP\n             && Columns + GAP >= INT_MIN + 3\n             && (Columns + GAP - 3) / INC >= INT_MIN\n             && (Columns + GAP - 3) / INC <= INT_MAX);\n      cols = (int)((Columns + GAP - 3) / INC);\n      if (cols == 0) {\n        cols = 1;\n      }\n      rows = (item_count + cols - 1) / cols;\n    } else {    // run == 2\n      rows = item_count;\n    }\n    for (row = 0; row < rows && !got_int; row++) {\n      msg_putchar('\\n');                        // go to next line\n      if (got_int) {                            // 'q' typed in more\n        break;\n      }\n      col = 0;\n      for (i = row; i < item_count; i += rows) {\n        msg_col = col;                          // make columns\n        showoneopt(items[i], opt_flags);\n        col += INC;\n      }\n      ui_flush();\n      os_breakcheck();\n    }\n  }\n  xfree(items);\n}\n\n/// Return true if option \"p\" has its default value.\nstatic int optval_default(vimoption_T *p, char_u *varp)\n{\n  if (varp == NULL) {\n    return true;            // hidden option is always at default\n  }\n  if (p->flags & P_NUM) {\n    return *(long *)varp == (long)(intptr_t)p->def_val;\n  }\n  if (p->flags & P_BOOL) {\n    return *(int *)varp == (int)(intptr_t)p->def_val;\n  }\n  // P_STRING\n  return STRCMP(*(char_u **)varp, p->def_val) == 0;\n}\n\n/// Send update to UIs with values of UI relevant options\nvoid ui_refresh_options(void)\n{\n  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {\n    uint32_t flags = options[opt_idx].flags;\n    if (!(flags & P_UI_OPTION)) {\n      continue;\n    }\n    String name = cstr_as_string(options[opt_idx].fullname);\n    void *varp = options[opt_idx].var;\n    Object value = OBJECT_INIT;\n    if (flags & P_BOOL) {\n      value = BOOLEAN_OBJ(*(int *)varp);\n    } else if (flags & P_NUM) {\n      value = INTEGER_OBJ(*(long *)varp);\n    } else if (flags & P_STRING) {\n      // cstr_as_string handles NULL string\n      value = STRING_OBJ(cstr_as_string(*(char **)varp));\n    }\n    ui_call_option_set(name, value);\n  }\n  if (p_mouse != NULL) {\n    setmouse();\n  }\n}\n\n/// showoneopt: show the value of one option\n/// must not be called with a hidden option!\nstatic void\nshowoneopt(\n    vimoption_T *p,\n    int opt_flags                          // OPT_LOCAL or OPT_GLOBAL\n)\n{\n  char_u      *varp;\n  int save_silent = silent_mode;\n\n  silent_mode = false;\n  info_message = true;          // use mch_msg(), not mch_errmsg()\n\n  varp = get_varp_scope(p, opt_flags);\n\n  // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n  if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n                              ? !curbufIsChanged() : !*(int *)varp)) {\n    MSG_PUTS(\"no\");\n  } else if ((p->flags & P_BOOL) && *(int *)varp < 0) {\n    MSG_PUTS(\"--\");\n  } else {\n    MSG_PUTS(\"  \");\n  }\n  MSG_PUTS(p->fullname);\n  if (!(p->flags & P_BOOL)) {\n    msg_putchar('=');\n    // put value string in NameBuff\n    option_value2string(p, opt_flags);\n    msg_outtrans(NameBuff);\n  }\n\n  silent_mode = save_silent;\n  info_message = false;\n}\n\n/// Write modified options as \":set\" commands to a file.\n///\n/// There are three values for \"opt_flags\":\n/// OPT_GLOBAL:         Write global option values and fresh values of\n///             buffer-local options (used for start of a session\n///             file).\n/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n///             curwin (used for a vimrc file).\n/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh\n///             and local values for window-local options of\n///             curwin.  Local values are also written when at the\n///             default value, because a modeline or autocommand\n///             may have set them when doing \":edit file\" and the\n///             user has set them back at the default or fresh\n///             value.\n///             When \"local_only\" is true, don't write fresh\n///             values, only local values (for \":mkview\").\n/// (fresh value = value used for a new buffer or window for a local option).\n///\n/// Return FAIL on error, OK otherwise.\nint makeset(FILE *fd, int opt_flags, int local_only)\n{\n  vimoption_T    *p;\n  char_u              *varp;                    // currently used value\n  char_u              *varp_fresh;              // local value\n  char_u              *varp_local = NULL;       // fresh value\n  char                *cmd;\n  int round;\n  int pri;\n\n  /*\n   * Some options are never written:\n   * - Options that don't have a default (terminal name, columns, lines).\n   * - Terminal options.\n   * - Hidden options.\n   *\n   * Do the loop over \"options[]\" twice: once for options with the\n   * P_PRI_MKRC flag and once without.\n   */\n  for (pri = 1; pri >= 0; pri--) {\n    for (p = &options[0]; p->fullname; p++) {\n      if (!(p->flags & P_NO_MKRC)\n          && ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0))) {\n        // skip global option when only doing locals\n        if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL)) {\n          continue;\n        }\n\n        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc\n         * file, they are always buffer-specific. */\n        if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB)) {\n          continue;\n        }\n\n        varp = get_varp_scope(p, opt_flags);\n        // Hidden options are never written.\n        if (!varp) {\n          continue;\n        }\n        // Global values are only written when not at the default value.\n        if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp)) {\n          continue;\n        }\n\n        if ((opt_flags & OPT_SKIPRTP)\n            && (p->var == (char_u *)&p_rtp || p->var == (char_u *)&p_pp)) {\n          continue;\n        }\n\n        round = 2;\n        if (p->indir != PV_NONE) {\n          if (p->var == VAR_WIN) {\n            // skip window-local option when only doing globals\n            if (!(opt_flags & OPT_LOCAL)) {\n              continue;\n            }\n            // When fresh value of window-local option is not at the\n            // default, need to write it too.\n            if (!(opt_flags & OPT_GLOBAL) && !local_only) {\n              varp_fresh = get_varp_scope(p, OPT_GLOBAL);\n              if (!optval_default(p, varp_fresh)) {\n                round = 1;\n                varp_local = varp;\n                varp = varp_fresh;\n              }\n            }\n          }\n        }\n\n        /* Round 1: fresh value for window-local options.\n         * Round 2: other values */\n        for (; round <= 2; varp = varp_local, round++) {\n          if (round == 1 || (opt_flags & OPT_GLOBAL)) {\n            cmd = \"set\";\n          } else {\n            cmd = \"setlocal\";\n          }\n\n          if (p->flags & P_BOOL) {\n            if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL) {\n              return FAIL;\n            }\n          } else if (p->flags & P_NUM) {\n            if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL) {\n              return FAIL;\n            }\n          } else {    // P_STRING\n            int do_endif = false;\n\n            // Don't set 'syntax' and 'filetype' again if the value is\n            // already right, avoids reloading the syntax file.\n            if (p->indir == PV_SYN || p->indir == PV_FT) {\n              if (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n                          *(char_u **)(varp)) < 0\n                  || put_eol(fd) < 0) {\n                return FAIL;\n              }\n              do_endif = true;\n            }\n            if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n                              p->flags) == FAIL) {\n              return FAIL;\n            }\n            if (do_endif) {\n              if (put_line(fd, \"endif\") == FAIL) {\n                return FAIL;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return OK;\n}\n\n/// Generate set commands for the local fold options only.  Used when\n/// 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\nint makefoldset(FILE *fd)\n{\n  if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, 0) == FAIL\n      || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, 0)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, 0)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, 0)\n      == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n      || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n      ) {\n    return FAIL;\n  }\n\n  return OK;\n}\n\nstatic int put_setstring(FILE *fd, char *cmd, char *name,\n                         char_u **valuep, uint64_t flags)\n{\n  char_u      *s;\n  char_u      *buf = NULL;\n  char_u      *part = NULL;\n  char_u      *p;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0) {\n    return FAIL;\n  }\n  if (*valuep != NULL) {\n    /* Output 'pastetoggle' as key names.  For other\n     * options some characters have to be escaped with\n     * CTRL-V or backslash */\n    if (valuep == &p_pt) {\n      s = *valuep;\n      while (*s != NUL) {\n        if (put_escstr(fd, (char_u *)str2special((const char **)&s, false,\n                                                 false), 2)\n            == FAIL) {\n          return FAIL;\n        }\n      }\n    } else if ((flags & P_EXPAND) != 0) {\n      size_t size = (size_t)STRLEN(*valuep) + 1;\n\n      // replace home directory in the whole option value into \"buf\"\n      buf = xmalloc(size);\n      home_replace(NULL, *valuep, buf, size, false);\n\n      // If the option value is longer than MAXPATHL, we need to append\n      // search comma separated part of the option separately, so that it\n      // can be expanded when read back.\n      if (size >= MAXPATHL && (flags & P_COMMA) != 0\n          && vim_strchr(*valuep, ',') != NULL) {\n        part = xmalloc(size);\n\n        // write line break to clear the option, e.g. ':set rtp='\n        if (put_eol(fd) == FAIL) {\n          goto fail;\n        }\n        p = buf;\n        while (*p != NUL) {\n            // for each comma separated option part, append value to\n            // the option, :set rtp+=value\n            if (fprintf(fd, \"%s %s+=\", cmd, name) < 0) {\n              goto fail;\n            }\n            (void)copy_option_part(&p, part, size, \",\");\n            if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {\n              goto fail;\n            }\n        }\n        xfree(buf);\n        xfree(part);\n        return OK;\n      }\n      if (put_escstr(fd, buf, 2) == FAIL) {\n        xfree(buf);\n        return FAIL;\n      }\n      xfree(buf);\n    } else if (put_escstr(fd, *valuep, 2) == FAIL) {\n      return FAIL;\n    }\n  }\n  if (put_eol(fd) < 0) {\n    return FAIL;\n  }\n  return OK;\nfail:\n  xfree(buf);\n  xfree(part);\n  return FAIL;\n}\n\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)\n{\n  long wc;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0) {\n    return FAIL;\n  }\n  if (wc_use_keyname((char_u *)valuep, &wc)) {\n    // print 'wildchar' and 'wildcharm' as a key name\n    if (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0) {\n      return FAIL;\n    }\n  } else if (fprintf(fd, \"%\" PRId64, (int64_t)(*valuep)) < 0) {\n    return FAIL;\n  }\n  if (put_eol(fd) < 0) {\n    return FAIL;\n  }\n  return OK;\n}\n\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value)\n{\n  if (value < 0) {      // global/local option using global value\n    return OK;\n  }\n  if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n      || put_eol(fd) < 0) {\n    return FAIL;\n  }\n  return OK;\n}\n\n/// Compute columns for ruler and shown command. 'sc_col' is also used to\n/// decide what the maximum length of a message on the status line can be.\n/// If there is a status line for the last window, 'sc_col' is independent\n/// of 'ru_col'.\n\n#define COL_RULER 17        // columns needed by standard ruler\n\nvoid comp_col(void)\n{\n  int last_has_status = (p_ls == 2 || (p_ls == 1 && !ONE_WINDOW));\n\n  sc_col = 0;\n  ru_col = 0;\n  if (p_ru) {\n    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;\n    // no last status line, adjust sc_col\n    if (!last_has_status) {\n      sc_col = ru_col;\n    }\n  }\n  if (p_sc) {\n    sc_col += SHOWCMD_COLS;\n    if (!p_ru || last_has_status) {         // no need for separating space\n      sc_col++;\n    }\n  }\n  assert(sc_col >= 0\n         && INT_MIN + sc_col <= Columns\n         && Columns - sc_col <= INT_MAX);\n  sc_col = (int)(Columns - sc_col);\n  assert(ru_col >= 0\n         && INT_MIN + ru_col <= Columns\n         && Columns - ru_col <= INT_MAX);\n  ru_col = (int)(Columns - ru_col);\n  if (sc_col <= 0) {            // screen too narrow, will become a mess\n    sc_col = 1;\n  }\n  if (ru_col <= 0) {\n    ru_col = 1;\n  }\n  set_vim_var_nr(VV_ECHOSPACE, sc_col - 1);\n}\n\n// Unset local option value, similar to \":set opt<\".\nvoid unset_global_local_option(char *name, void *from)\n{\n  vimoption_T *p;\n  buf_T *buf = (buf_T *)from;\n\n  int opt_idx = findoption(name);\n  if (opt_idx < 0) {\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n    return;\n  }\n  p = &(options[opt_idx]);\n\n  switch ((int)p->indir)\n  {\n    // global option with local value: use local value if it's been set\n    case PV_EP:\n      clear_string_option(&buf->b_p_ep);\n      break;\n    case PV_KP:\n      clear_string_option(&buf->b_p_kp);\n      break;\n    case PV_PATH:\n      clear_string_option(&buf->b_p_path);\n      break;\n    case PV_AR:\n      buf->b_p_ar = -1;\n      break;\n    case PV_BKC:\n      clear_string_option(&buf->b_p_bkc);\n      buf->b_bkc_flags = 0;\n      break;\n    case PV_TAGS:\n      clear_string_option(&buf->b_p_tags);\n      break;\n    case PV_TC:\n      clear_string_option(&buf->b_p_tc);\n      buf->b_tc_flags = 0;\n      break;\n    case PV_SISO:\n      curwin->w_p_siso = -1;\n      break;\n    case PV_SO:\n      curwin->w_p_so = -1;\n      break;\n    case PV_DEF:\n      clear_string_option(&buf->b_p_def);\n      break;\n    case PV_INC:\n      clear_string_option(&buf->b_p_inc);\n      break;\n    case PV_DICT:\n      clear_string_option(&buf->b_p_dict);\n      break;\n    case PV_TSR:\n      clear_string_option(&buf->b_p_tsr);\n      break;\n    case PV_FP:\n      clear_string_option(&buf->b_p_fp);\n      break;\n    case PV_EFM:\n      clear_string_option(&buf->b_p_efm);\n      break;\n    case PV_GP:\n      clear_string_option(&buf->b_p_gp);\n      break;\n    case PV_MP:\n      clear_string_option(&buf->b_p_mp);\n      break;\n    case PV_STL:\n      clear_string_option(&((win_T *)from)->w_p_stl);\n      break;\n    case PV_UL:\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      break;\n    case PV_LW:\n      clear_string_option(&buf->b_p_lw);\n      break;\n    case PV_MENC:\n      clear_string_option(&buf->b_p_menc);\n      break;\n    case PV_LCS:\n      clear_string_option(&((win_T *)from)->w_p_lcs);\n      set_chars_option((win_T *)from, &((win_T *)from)->w_p_lcs, true);\n      redraw_later((win_T *)from, NOT_VALID);\n      break;\n    case PV_FCS:\n      clear_string_option(&((win_T *)from)->w_p_fcs);\n      set_chars_option((win_T *)from, &((win_T *)from)->w_p_fcs, true);\n      redraw_later((win_T *)from, NOT_VALID);\n      break;\n  }\n}\n\n/// Get pointer to option variable, depending on local or global scope.\nstatic char_u *get_varp_scope(vimoption_T *p, int opt_flags)\n{\n  if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE) {\n    if (p->var == VAR_WIN) {\n      return (char_u *)GLOBAL_WO(get_varp(p));\n    }\n    return p->var;\n  }\n  if ((opt_flags & OPT_LOCAL) && ((int)p->indir & PV_BOTH)) {\n    switch ((int)p->indir) {\n    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);\n    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n    case PV_SISO: return (char_u *)&(curwin->w_p_siso);\n    case PV_SO:   return (char_u *)&(curwin->w_p_so);\n    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n    case PV_TFU:  return (char_u *)&(curbuf->b_p_tfu);\n    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);\n    case PV_FCS:  return (char_u *)&(curwin->w_p_fcs);\n    case PV_LCS:  return (char_u *)&(curwin->w_p_lcs);\n    }\n    return NULL;     // \"cannot happen\"\n  }\n  return get_varp(p);\n}\n\n/// Get pointer to option variable.\nstatic char_u *get_varp(vimoption_T *p)\n{\n  // hidden option, always return NULL\n  if (p->var == NULL) {\n    return NULL;\n  }\n\n  switch ((int)p->indir) {\n  case PV_NONE:   return p->var;\n\n  // global option with local value: use local value if it's been set\n  case PV_EP:     return *curbuf->b_p_ep != NUL\n           ? (char_u *)&curbuf->b_p_ep : p->var;\n  case PV_KP:     return *curbuf->b_p_kp != NUL\n           ? (char_u *)&curbuf->b_p_kp : p->var;\n  case PV_PATH:   return *curbuf->b_p_path != NUL\n           ? (char_u *)&(curbuf->b_p_path) : p->var;\n  case PV_AR:     return curbuf->b_p_ar >= 0\n           ? (char_u *)&(curbuf->b_p_ar) : p->var;\n  case PV_TAGS:   return *curbuf->b_p_tags != NUL\n           ? (char_u *)&(curbuf->b_p_tags) : p->var;\n  case PV_TC:     return *curbuf->b_p_tc != NUL\n           ? (char_u *)&(curbuf->b_p_tc) : p->var;\n  case PV_SISO:   return curwin->w_p_siso >= 0\n           ? (char_u *)&(curwin->w_p_siso) : p->var;\n  case PV_SO:     return curwin->w_p_so >= 0\n           ? (char_u *)&(curwin->w_p_so) : p->var;\n  case PV_BKC:    return *curbuf->b_p_bkc != NUL\n           ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n  case PV_DEF:    return *curbuf->b_p_def != NUL\n           ? (char_u *)&(curbuf->b_p_def) : p->var;\n  case PV_INC:    return *curbuf->b_p_inc != NUL\n           ? (char_u *)&(curbuf->b_p_inc) : p->var;\n  case PV_DICT:   return *curbuf->b_p_dict != NUL\n           ? (char_u *)&(curbuf->b_p_dict) : p->var;\n  case PV_TSR:    return *curbuf->b_p_tsr != NUL\n           ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n  case PV_FP: return *curbuf->b_p_fp != NUL\n           ? (char_u *)&(curbuf->b_p_fp) : p->var;\n  case PV_EFM:    return *curbuf->b_p_efm != NUL\n           ? (char_u *)&(curbuf->b_p_efm) : p->var;\n  case PV_GP:     return *curbuf->b_p_gp != NUL\n           ? (char_u *)&(curbuf->b_p_gp) : p->var;\n  case PV_MP:     return *curbuf->b_p_mp != NUL\n           ? (char_u *)&(curbuf->b_p_mp) : p->var;\n  case PV_STL:    return *curwin->w_p_stl != NUL\n           ? (char_u *)&(curwin->w_p_stl) : p->var;\n  case PV_UL:     return curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n           ? (char_u *)&(curbuf->b_p_ul) : p->var;\n  case PV_LW:   return *curbuf->b_p_lw != NUL\n           ? (char_u *)&(curbuf->b_p_lw) : p->var;\n  case PV_MENC: return *curbuf->b_p_menc != NUL\n           ? (char_u *)&(curbuf->b_p_menc) : p->var;\n  case PV_FCS:    return *curwin->w_p_fcs != NUL\n           ? (char_u *)&(curwin->w_p_fcs) : p->var;\n  case PV_LCS:    return *curwin->w_p_lcs != NUL\n           ? (char_u *)&(curwin->w_p_lcs) : p->var;\n\n  case PV_ARAB:   return (char_u *)&(curwin->w_p_arab);\n  case PV_LIST:   return (char_u *)&(curwin->w_p_list);\n  case PV_SPELL:  return (char_u *)&(curwin->w_p_spell);\n  case PV_CUC:    return (char_u *)&(curwin->w_p_cuc);\n  case PV_CUL:    return (char_u *)&(curwin->w_p_cul);\n  case PV_CULOPT: return (char_u *)&(curwin->w_p_culopt);\n  case PV_CC:     return (char_u *)&(curwin->w_p_cc);\n  case PV_DIFF:   return (char_u *)&(curwin->w_p_diff);\n  case PV_FDC:    return (char_u *)&(curwin->w_p_fdc);\n  case PV_FEN:    return (char_u *)&(curwin->w_p_fen);\n  case PV_FDI:    return (char_u *)&(curwin->w_p_fdi);\n  case PV_FDL:    return (char_u *)&(curwin->w_p_fdl);\n  case PV_FDM:    return (char_u *)&(curwin->w_p_fdm);\n  case PV_FML:    return (char_u *)&(curwin->w_p_fml);\n  case PV_FDN:    return (char_u *)&(curwin->w_p_fdn);\n  case PV_FDE:    return (char_u *)&(curwin->w_p_fde);\n  case PV_FDT:    return (char_u *)&(curwin->w_p_fdt);\n  case PV_FMR:    return (char_u *)&(curwin->w_p_fmr);\n  case PV_NU:     return (char_u *)&(curwin->w_p_nu);\n  case PV_RNU:    return (char_u *)&(curwin->w_p_rnu);\n  case PV_NUW:    return (char_u *)&(curwin->w_p_nuw);\n  case PV_WFH:    return (char_u *)&(curwin->w_p_wfh);\n  case PV_WFW:    return (char_u *)&(curwin->w_p_wfw);\n  case PV_PVW:    return (char_u *)&(curwin->w_p_pvw);\n  case PV_RL:     return (char_u *)&(curwin->w_p_rl);\n  case PV_RLC:    return (char_u *)&(curwin->w_p_rlc);\n  case PV_SCROLL: return (char_u *)&(curwin->w_p_scr);\n  case PV_WRAP:   return (char_u *)&(curwin->w_p_wrap);\n  case PV_LBR:    return (char_u *)&(curwin->w_p_lbr);\n  case PV_BRI:    return (char_u *)&(curwin->w_p_bri);\n  case PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n  case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n  case PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n  case PV_COCU:    return (char_u *)&(curwin->w_p_cocu);\n  case PV_COLE:    return (char_u *)&(curwin->w_p_cole);\n\n  case PV_AI:     return (char_u *)&(curbuf->b_p_ai);\n  case PV_BIN:    return (char_u *)&(curbuf->b_p_bin);\n  case PV_BOMB:   return (char_u *)&(curbuf->b_p_bomb);\n  case PV_BH:     return (char_u *)&(curbuf->b_p_bh);\n  case PV_BT:     return (char_u *)&(curbuf->b_p_bt);\n  case PV_BL:     return (char_u *)&(curbuf->b_p_bl);\n  case PV_CHANNEL:return (char_u *)&(curbuf->b_p_channel);\n  case PV_CI:     return (char_u *)&(curbuf->b_p_ci);\n  case PV_CIN:    return (char_u *)&(curbuf->b_p_cin);\n  case PV_CINK:   return (char_u *)&(curbuf->b_p_cink);\n  case PV_CINO:   return (char_u *)&(curbuf->b_p_cino);\n  case PV_CINW:   return (char_u *)&(curbuf->b_p_cinw);\n  case PV_COM:    return (char_u *)&(curbuf->b_p_com);\n  case PV_CMS:    return (char_u *)&(curbuf->b_p_cms);\n  case PV_CPT:    return (char_u *)&(curbuf->b_p_cpt);\n# ifdef BACKSLASH_IN_FILENAME\n  case PV_CSL:    return (char_u *)&(curbuf->b_p_csl);\n# endif\n  case PV_CFU:    return (char_u *)&(curbuf->b_p_cfu);\n  case PV_OFU:    return (char_u *)&(curbuf->b_p_ofu);\n  case PV_EOL:    return (char_u *)&(curbuf->b_p_eol);\n  case PV_FIXEOL: return (char_u *)&(curbuf->b_p_fixeol);\n  case PV_ET:     return (char_u *)&(curbuf->b_p_et);\n  case PV_FENC:   return (char_u *)&(curbuf->b_p_fenc);\n  case PV_FF:     return (char_u *)&(curbuf->b_p_ff);\n  case PV_FT:     return (char_u *)&(curbuf->b_p_ft);\n  case PV_FO:     return (char_u *)&(curbuf->b_p_fo);\n  case PV_FLP:    return (char_u *)&(curbuf->b_p_flp);\n  case PV_IMI:    return (char_u *)&(curbuf->b_p_iminsert);\n  case PV_IMS:    return (char_u *)&(curbuf->b_p_imsearch);\n  case PV_INF:    return (char_u *)&(curbuf->b_p_inf);\n  case PV_ISK:    return (char_u *)&(curbuf->b_p_isk);\n  case PV_INEX:   return (char_u *)&(curbuf->b_p_inex);\n  case PV_INDE:   return (char_u *)&(curbuf->b_p_inde);\n  case PV_INDK:   return (char_u *)&(curbuf->b_p_indk);\n  case PV_FEX:    return (char_u *)&(curbuf->b_p_fex);\n  case PV_LISP:   return (char_u *)&(curbuf->b_p_lisp);\n  case PV_ML:     return (char_u *)&(curbuf->b_p_ml);\n  case PV_MPS:    return (char_u *)&(curbuf->b_p_mps);\n  case PV_MA:     return (char_u *)&(curbuf->b_p_ma);\n  case PV_MOD:    return (char_u *)&(curbuf->b_changed);\n  case PV_NF:     return (char_u *)&(curbuf->b_p_nf);\n  case PV_PI:     return (char_u *)&(curbuf->b_p_pi);\n  case PV_QE:     return (char_u *)&(curbuf->b_p_qe);\n  case PV_RO:     return (char_u *)&(curbuf->b_p_ro);\n  case PV_SCBK:   return (char_u *)&(curbuf->b_p_scbk);\n  case PV_SI:     return (char_u *)&(curbuf->b_p_si);\n  case PV_STS:    return (char_u *)&(curbuf->b_p_sts);\n  case PV_SUA:    return (char_u *)&(curbuf->b_p_sua);\n  case PV_SWF:    return (char_u *)&(curbuf->b_p_swf);\n  case PV_SMC:    return (char_u *)&(curbuf->b_p_smc);\n  case PV_SYN:    return (char_u *)&(curbuf->b_p_syn);\n  case PV_SPC:    return (char_u *)&(curwin->w_s->b_p_spc);\n  case PV_SPF:    return (char_u *)&(curwin->w_s->b_p_spf);\n  case PV_SPL:    return (char_u *)&(curwin->w_s->b_p_spl);\n  case PV_SPO:    return (char_u *)&(curwin->w_s->b_p_spo);\n  case PV_SW:     return (char_u *)&(curbuf->b_p_sw);\n  case PV_TFU:    return (char_u *)&(curbuf->b_p_tfu);\n  case PV_TS:     return (char_u *)&(curbuf->b_p_ts);\n  case PV_TW:     return (char_u *)&(curbuf->b_p_tw);\n  case PV_UDF:    return (char_u *)&(curbuf->b_p_udf);\n  case PV_WM:     return (char_u *)&(curbuf->b_p_wm);\n  case PV_VSTS:   return (char_u *)&(curbuf->b_p_vsts);\n  case PV_VTS:    return (char_u *)&(curbuf->b_p_vts);\n  case PV_KMAP:   return (char_u *)&(curbuf->b_p_keymap);\n  case PV_SCL:    return (char_u *)&(curwin->w_p_scl);\n  case PV_WINHL:  return (char_u *)&(curwin->w_p_winhl);\n  case PV_WINBL:  return (char_u *)&(curwin->w_p_winbl);\n  default:        IEMSG(_(\"E356: get_varp ERROR\"));\n  }\n  // always return a valid pointer to avoid a crash!\n  return (char_u *)&(curbuf->b_p_wm);\n}\n\n/// Get the value of 'equalprg', either the buffer-local one or the global one.\nchar_u *get_equalprg(void)\n{\n  if (*curbuf->b_p_ep == NUL) {\n    return p_ep;\n  }\n  return curbuf->b_p_ep;\n}\n\n/// Copy options from one window to another.\n/// Used when splitting a window.\nvoid win_copy_options(win_T *wp_from, win_T *wp_to)\n{\n  copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n  copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n}\n\n/// Copy the options from one winopt_T to another.\n/// Doesn't free the old option values in \"to\", use clear_winopt() for that.\n/// The 'scroll' option is not copied, because it depends on the window height.\n/// The 'previewwindow' option is reset, there can be only one preview window.\nvoid copy_winopt(winopt_T *from, winopt_T *to)\n{\n  to->wo_arab = from->wo_arab;\n  to->wo_list = from->wo_list;\n  to->wo_nu = from->wo_nu;\n  to->wo_rnu = from->wo_rnu;\n  to->wo_nuw = from->wo_nuw;\n  to->wo_rl  = from->wo_rl;\n  to->wo_rlc = vim_strsave(from->wo_rlc);\n  to->wo_stl = vim_strsave(from->wo_stl);\n  to->wo_wrap = from->wo_wrap;\n  to->wo_wrap_save = from->wo_wrap_save;\n  to->wo_lbr = from->wo_lbr;\n  to->wo_bri = from->wo_bri;\n  to->wo_briopt = vim_strsave(from->wo_briopt);\n  to->wo_scb = from->wo_scb;\n  to->wo_scb_save = from->wo_scb_save;\n  to->wo_crb = from->wo_crb;\n  to->wo_crb_save = from->wo_crb_save;\n  to->wo_spell = from->wo_spell;\n  to->wo_cuc = from->wo_cuc;\n  to->wo_cul = from->wo_cul;\n  to->wo_culopt = vim_strsave(from->wo_culopt);\n  to->wo_cc = vim_strsave(from->wo_cc);\n  to->wo_diff = from->wo_diff;\n  to->wo_diff_saved = from->wo_diff_saved;\n  to->wo_cocu = vim_strsave(from->wo_cocu);\n  to->wo_cole = from->wo_cole;\n  to->wo_fdc = vim_strsave(from->wo_fdc);\n  to->wo_fdc_save = from->wo_diff_saved\n                    ? vim_strsave(from->wo_fdc_save) : empty_option;\n  to->wo_fen = from->wo_fen;\n  to->wo_fen_save = from->wo_fen_save;\n  to->wo_fdi = vim_strsave(from->wo_fdi);\n  to->wo_fml = from->wo_fml;\n  to->wo_fdl = from->wo_fdl;\n  to->wo_fdl_save = from->wo_fdl_save;\n  to->wo_fdm = vim_strsave(from->wo_fdm);\n  to->wo_fdm_save = from->wo_diff_saved\n                    ? vim_strsave(from->wo_fdm_save) : empty_option;\n  to->wo_fdn = from->wo_fdn;\n  to->wo_fde = vim_strsave(from->wo_fde);\n  to->wo_fdt = vim_strsave(from->wo_fdt);\n  to->wo_fmr = vim_strsave(from->wo_fmr);\n  to->wo_scl = vim_strsave(from->wo_scl);\n  to->wo_winhl = vim_strsave(from->wo_winhl);\n  to->wo_fcs = vim_strsave(from->wo_fcs);\n  to->wo_lcs = vim_strsave(from->wo_lcs);\n  to->wo_winbl = from->wo_winbl;\n  check_winopt(to);             // don't want NULL pointers\n}\n\n/// Check string options in a window for a NULL value.\nvoid check_win_options(win_T *win)\n{\n  check_winopt(&win->w_onebuf_opt);\n  check_winopt(&win->w_allbuf_opt);\n}\n\n/// Check for NULL pointers in a winopt_T and replace them with empty_option.\nstatic void check_winopt(winopt_T *wop)\n{\n  check_string_option(&wop->wo_fdc);\n  check_string_option(&wop->wo_fdc_save);\n  check_string_option(&wop->wo_fdi);\n  check_string_option(&wop->wo_fdm);\n  check_string_option(&wop->wo_fdm_save);\n  check_string_option(&wop->wo_fde);\n  check_string_option(&wop->wo_fdt);\n  check_string_option(&wop->wo_fmr);\n  check_string_option(&wop->wo_scl);\n  check_string_option(&wop->wo_rlc);\n  check_string_option(&wop->wo_stl);\n  check_string_option(&wop->wo_culopt);\n  check_string_option(&wop->wo_cc);\n  check_string_option(&wop->wo_cocu);\n  check_string_option(&wop->wo_briopt);\n  check_string_option(&wop->wo_winhl);\n  check_string_option(&wop->wo_fcs);\n  check_string_option(&wop->wo_lcs);\n}\n\n/// Free the allocated memory inside a winopt_T.\nvoid clear_winopt(winopt_T *wop)\n{\n  clear_string_option(&wop->wo_fdc);\n  clear_string_option(&wop->wo_fdc_save);\n  clear_string_option(&wop->wo_fdi);\n  clear_string_option(&wop->wo_fdm);\n  clear_string_option(&wop->wo_fdm_save);\n  clear_string_option(&wop->wo_fde);\n  clear_string_option(&wop->wo_fdt);\n  clear_string_option(&wop->wo_fmr);\n  clear_string_option(&wop->wo_scl);\n  clear_string_option(&wop->wo_rlc);\n  clear_string_option(&wop->wo_stl);\n  clear_string_option(&wop->wo_culopt);\n  clear_string_option(&wop->wo_cc);\n  clear_string_option(&wop->wo_cocu);\n  clear_string_option(&wop->wo_briopt);\n  clear_string_option(&wop->wo_winhl);\n  clear_string_option(&wop->wo_fcs);\n  clear_string_option(&wop->wo_lcs);\n}\n\nvoid didset_window_options(win_T *wp)\n{\n  check_colorcolumn(wp);\n  briopt_check(wp);\n  fill_culopt_flags(NULL, wp);\n  set_chars_option(wp, &wp->w_p_fcs, true);\n  set_chars_option(wp, &wp->w_p_lcs, true);\n  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl\n  check_blending(wp);\n  wp->w_grid_alloc.blending = wp->w_p_winbl > 0;\n}\n\n\n/// Copy global option values to local options for one buffer.\n/// Used when creating a new buffer and sometimes when entering a buffer.\n/// flags:\n/// BCO_ENTER    We will enter the buf buffer.\n/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when\n///      appropriate.\n/// BCO_NOHELP   Don't copy the values to a help buffer.\nvoid buf_copy_options(buf_T *buf, int flags)\n{\n  int should_copy = true;\n  char_u      *save_p_isk = NULL;           // init for GCC\n  int dont_do_help;\n  int did_isk = false;\n\n  /*\n   * Skip this when the option defaults have not been set yet.  Happens when\n   * main() allocates the first buffer.\n   */\n  if (p_cpo != NULL) {\n    //\n    // Always copy when entering and 'cpo' contains 'S'.\n    // Don't copy when already initialized.\n    // Don't copy when 'cpo' contains 's' and not entering.\n    //    'S'      BCO_ENTER  initialized  's'  should_copy\n    //    yes        yes          X         X      true\n    //    yes        no          yes        X      false\n    //    no          X          yes        X      false\n    //     X         no          no        yes     false\n    //     X         no          no        no      true\n    //    no         yes         no         X      true\n    ///\n    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n        && (buf->b_p_initialized\n            || (!(flags & BCO_ENTER)\n                && vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {\n      should_copy = false;\n    }\n\n    if (should_copy || (flags & BCO_ALWAYS)) {\n      /* Don't copy the options specific to a help buffer when\n      * BCO_NOHELP is given or the options were initialized already\n      * (jumping back to a help file with CTRL-T or CTRL-O) */\n      dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n                     || buf->b_p_initialized;\n      if (dont_do_help) {               // don't free b_p_isk\n        save_p_isk = buf->b_p_isk;\n        buf->b_p_isk = NULL;\n      }\n      // Always free the allocated strings.  If not already initialized,\n      // reset 'readonly' and copy 'fileformat'.\n      if (!buf->b_p_initialized) {\n        free_buf_options(buf, true);\n        buf->b_p_ro = false;                    // don't copy readonly\n        buf->b_p_fenc = vim_strsave(p_fenc);\n        switch (*p_ffs) {\n          case 'm': {\n            buf->b_p_ff = vim_strsave((char_u *)FF_MAC);\n            break;\n          }\n          case 'd': {\n            buf->b_p_ff = vim_strsave((char_u *)FF_DOS);\n            break;\n          }\n          case 'u': {\n            buf->b_p_ff = vim_strsave((char_u *)FF_UNIX);\n            break;\n          }\n          default: {\n            buf->b_p_ff = vim_strsave(p_ff);\n            break;\n          }\n        }\n        buf->b_p_bh = empty_option;\n        buf->b_p_bt = empty_option;\n      } else {\n        free_buf_options(buf, false);\n      }\n\n      buf->b_p_ai = p_ai;\n      buf->b_p_ai_nopaste = p_ai_nopaste;\n      buf->b_p_sw = p_sw;\n      buf->b_p_scbk = p_scbk;\n      buf->b_p_tw = p_tw;\n      buf->b_p_tw_nopaste = p_tw_nopaste;\n      buf->b_p_tw_nobin = p_tw_nobin;\n      buf->b_p_wm = p_wm;\n      buf->b_p_wm_nopaste = p_wm_nopaste;\n      buf->b_p_wm_nobin = p_wm_nobin;\n      buf->b_p_bin = p_bin;\n      buf->b_p_bomb = p_bomb;\n      buf->b_p_et = p_et;\n      buf->b_p_fixeol = p_fixeol;\n      buf->b_p_et_nobin = p_et_nobin;\n      buf->b_p_et_nopaste = p_et_nopaste;\n      buf->b_p_ml = p_ml;\n      buf->b_p_ml_nobin = p_ml_nobin;\n      buf->b_p_inf = p_inf;\n      buf->b_p_swf = cmdmod.noswapfile ? false : p_swf;\n      buf->b_p_cpt = vim_strsave(p_cpt);\n# ifdef BACKSLASH_IN_FILENAME\n      buf->b_p_csl = vim_strsave(p_csl);\n# endif\n      buf->b_p_cfu = vim_strsave(p_cfu);\n      buf->b_p_ofu = vim_strsave(p_ofu);\n      buf->b_p_tfu = vim_strsave(p_tfu);\n      buf->b_p_sts = p_sts;\n      buf->b_p_sts_nopaste = p_sts_nopaste;\n      buf->b_p_vsts = vim_strsave(p_vsts);\n      if (p_vsts && p_vsts != empty_option) {\n        tabstop_set(p_vsts, &buf->b_p_vsts_array);\n      } else {\n        buf->b_p_vsts_array = 0;\n      }\n      buf->b_p_vsts_nopaste = p_vsts_nopaste\n                                ? vim_strsave(p_vsts_nopaste)\n                                : NULL;\n      buf->b_p_com = vim_strsave(p_com);\n      buf->b_p_cms = vim_strsave(p_cms);\n      buf->b_p_fo = vim_strsave(p_fo);\n      buf->b_p_flp = vim_strsave(p_flp);\n      buf->b_p_nf = vim_strsave(p_nf);\n      buf->b_p_mps = vim_strsave(p_mps);\n      buf->b_p_si = p_si;\n      buf->b_p_channel = 0;\n      buf->b_p_ci = p_ci;\n      buf->b_p_cin = p_cin;\n      buf->b_p_cink = vim_strsave(p_cink);\n      buf->b_p_cino = vim_strsave(p_cino);\n      // Don't copy 'filetype', it must be detected\n      buf->b_p_ft = empty_option;\n      buf->b_p_pi = p_pi;\n      buf->b_p_cinw = vim_strsave(p_cinw);\n      buf->b_p_lisp = p_lisp;\n      // Don't copy 'syntax', it must be set\n      buf->b_p_syn = empty_option;\n      buf->b_p_smc = p_smc;\n      buf->b_s.b_syn_isk = empty_option;\n      buf->b_s.b_p_spc = vim_strsave(p_spc);\n      (void)compile_cap_prog(&buf->b_s);\n      buf->b_s.b_p_spf = vim_strsave(p_spf);\n      buf->b_s.b_p_spl = vim_strsave(p_spl);\n      buf->b_s.b_p_spo = vim_strsave(p_spo);\n      buf->b_p_inde = vim_strsave(p_inde);\n      buf->b_p_indk = vim_strsave(p_indk);\n      buf->b_p_fp = empty_option;\n      buf->b_p_fex = vim_strsave(p_fex);\n      buf->b_p_sua = vim_strsave(p_sua);\n      buf->b_p_keymap = vim_strsave(p_keymap);\n      buf->b_kmap_state |= KEYMAP_INIT;\n      /* This isn't really an option, but copying the langmap and IME\n      * state from the current buffer is better than resetting it. */\n      buf->b_p_iminsert = p_iminsert;\n      buf->b_p_imsearch = p_imsearch;\n\n      /* options that are normally global but also have a local value\n       * are not copied, start using the global value */\n      buf->b_p_ar = -1;\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      buf->b_p_bkc = empty_option;\n      buf->b_bkc_flags = 0;\n      buf->b_p_gp = empty_option;\n      buf->b_p_mp = empty_option;\n      buf->b_p_efm = empty_option;\n      buf->b_p_ep = empty_option;\n      buf->b_p_kp = empty_option;\n      buf->b_p_path = empty_option;\n      buf->b_p_tags = empty_option;\n      buf->b_p_tc = empty_option;\n      buf->b_tc_flags = 0;\n      buf->b_p_def = empty_option;\n      buf->b_p_inc = empty_option;\n      buf->b_p_inex = vim_strsave(p_inex);\n      buf->b_p_dict = empty_option;\n      buf->b_p_tsr = empty_option;\n      buf->b_p_qe = vim_strsave(p_qe);\n      buf->b_p_udf = p_udf;\n      buf->b_p_lw = empty_option;\n      buf->b_p_menc = empty_option;\n\n      /*\n       * Don't copy the options set by ex_help(), use the saved values,\n       * when going from a help buffer to a non-help buffer.\n       * Don't touch these at all when BCO_NOHELP is used and going from\n       * or to a help buffer.\n       */\n      if (dont_do_help) {\n        buf->b_p_isk = save_p_isk;\n        if (p_vts && p_vts != empty_option && !buf->b_p_vts_array) {\n          tabstop_set(p_vts, &buf->b_p_vts_array);\n        } else {\n          buf->b_p_vts_array = NULL;\n        }\n      } else {\n        buf->b_p_isk = vim_strsave(p_isk);\n        did_isk = true;\n        buf->b_p_ts = p_ts;\n        buf->b_p_vts = vim_strsave(p_vts);\n        if (p_vts && p_vts != empty_option && !buf->b_p_vts_array) {\n          tabstop_set(p_vts, &buf->b_p_vts_array);\n        } else {\n          buf->b_p_vts_array = NULL;\n        }\n        buf->b_help = false;\n        if (buf->b_p_bt[0] == 'h') {\n          clear_string_option(&buf->b_p_bt);\n        }\n        buf->b_p_ma = p_ma;\n      }\n    }\n\n    /*\n     * When the options should be copied (ignoring BCO_ALWAYS), set the\n     * flag that indicates that the options have been initialized.\n     */\n    if (should_copy) {\n      buf->b_p_initialized = true;\n    }\n  }\n\n  check_buf_options(buf);           // make sure we don't have NULLs\n  if (did_isk) {\n    (void)buf_init_chartab(buf, false);\n  }\n}\n\n/// Reset the 'modifiable' option and its default value.\nvoid reset_modifiable(void)\n{\n  int opt_idx;\n\n  curbuf->b_p_ma = false;\n  p_ma = false;\n  opt_idx = findoption(\"ma\");\n  if (opt_idx >= 0) {\n    options[opt_idx].def_val = false;\n  }\n}\n\n/// Set the global value for 'iminsert' to the local value.\nvoid set_iminsert_global(void)\n{\n  p_iminsert = curbuf->b_p_iminsert;\n}\n\n/// Set the global value for 'imsearch' to the local value.\nvoid set_imsearch_global(void)\n{\n  p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\nvoid\nset_context_in_set_cmd(\n    expand_T *xp,\n    char_u *arg,\n    int opt_flags                  // OPT_GLOBAL and/or OPT_LOCAL\n)\n{\n  char_u nextchar;\n  uint32_t flags = 0;           // init for GCC\n  int opt_idx = 0;              // init for GCC\n  char_u      *p;\n  char_u      *s;\n  int is_term_option = false;\n  int key;\n\n  expand_option_flags = opt_flags;\n\n  xp->xp_context = EXPAND_SETTINGS;\n  if (*arg == NUL) {\n    xp->xp_pattern = arg;\n    return;\n  }\n  p = arg + STRLEN(arg) - 1;\n  if (*p == ' ' && *(p - 1) != '\\\\') {\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  while (p > arg) {\n    s = p;\n    // count number of backslashes before ' ' or ','\n    if (*p == ' ' || *p == ',') {\n      while (s > arg && *(s - 1) == '\\\\') {\n        s--;\n      }\n    }\n    // break at a space with an even number of backslashes\n    if (*p == ' ' && ((p - s) & 1) == 0) {\n      p++;\n      break;\n    }\n    p--;\n  }\n  if (STRNCMP(p, \"no\", 2) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 2;\n  }\n  if (STRNCMP(p, \"inv\", 3) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 3;\n  }\n  xp->xp_pattern = arg = p;\n  if (*arg == '<') {\n    while (*p != '>') {\n      if (*p++ == NUL) {            // expand terminal option name\n        return;\n      }\n    }\n    key = get_special_key_code(arg + 1);\n    if (key == 0) {                 // unknown name\n      xp->xp_context = EXPAND_NOTHING;\n      return;\n    }\n    nextchar = *++p;\n    is_term_option = true;\n    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);\n    expand_option_name[3] = KEY2TERMCAP1(key);\n  } else {\n    if (p[0] == 't' && p[1] == '_') {\n      p += 2;\n      if (*p != NUL) {\n        p++;\n      }\n      if (*p == NUL) {\n        return;                 // expand option name\n      }\n      nextchar = *++p;\n      is_term_option = true;\n      expand_option_name[2] = p[-2];\n      expand_option_name[3] = p[-1];\n    } else {\n      // Allow * wildcard.\n      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {\n        p++;\n      }\n      if (*p == NUL) {\n        return;\n      }\n      nextchar = *p;\n      opt_idx = findoption_len((const char *)arg, (size_t)(p - arg));\n      if (opt_idx == -1 || options[opt_idx].var == NULL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n      flags = options[opt_idx].flags;\n      if (flags & P_BOOL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n    }\n  }\n  // handle \"-=\" and \"+=\"\n  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=') {\n    p++;\n    nextchar = '=';\n  }\n  if ((nextchar != '=' && nextchar != ':')\n      || xp->xp_context == EXPAND_BOOL_SETTINGS) {\n    xp->xp_context = EXPAND_UNSUCCESSFUL;\n    return;\n  }\n  if (p[1] == NUL) {\n    xp->xp_context = EXPAND_OLD_SETTING;\n    if (is_term_option) {\n      expand_option_idx = -1;\n    } else {\n      expand_option_idx = opt_idx;\n    }\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  xp->xp_context = EXPAND_NOTHING;\n  if (is_term_option || (flags & P_NUM)) {\n    return;\n  }\n\n  xp->xp_pattern = p + 1;\n\n  if (flags & P_EXPAND) {\n    p = options[opt_idx].var;\n    if (p == (char_u *)&p_bdir\n        || p == (char_u *)&p_dir\n        || p == (char_u *)&p_path\n        || p == (char_u *)&p_pp\n        || p == (char_u *)&p_rtp\n        || p == (char_u *)&p_cdpath\n        || p == (char_u *)&p_vdir\n        ) {\n      xp->xp_context = EXPAND_DIRECTORIES;\n      if (p == (char_u *)&p_path\n          || p == (char_u *)&p_cdpath\n          )\n        xp->xp_backslash = XP_BS_THREE;\n      else\n        xp->xp_backslash = XP_BS_ONE;\n    } else if (p == (char_u *)&p_ft) {\n      xp->xp_context = EXPAND_FILETYPE;\n    } else {\n      xp->xp_context = EXPAND_FILES;\n      // for 'tags' need three backslashes for a space\n      if (p == (char_u *)&p_tags) {\n        xp->xp_backslash = XP_BS_THREE;\n      } else {\n        xp->xp_backslash = XP_BS_ONE;\n      }\n    }\n  }\n\n  /* For an option that is a list of file names, find the start of the\n   * last file name. */\n  for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; p--) {\n    // count number of backslashes before ' ' or ','\n    if (*p == ' ' || *p == ',') {\n      s = p;\n      while (s > xp->xp_pattern && *(s - 1) == '\\\\') {\n        s--;\n      }\n      if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n          || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0)) {\n        xp->xp_pattern = p + 1;\n        break;\n      }\n    }\n\n    // for 'spellsuggest' start at \"file:\"\n    if (options[opt_idx].var == (char_u *)&p_sps\n        && STRNCMP(p, \"file:\", 5) == 0) {\n      xp->xp_pattern = p + 5;\n      break;\n    }\n  }\n\n  return;\n}\n\nint ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)\n{\n  int num_normal = 0;  // Nr of matching non-term-code settings\n  int match;\n  int count = 0;\n  char_u      *str;\n  int loop;\n  static char *(names[]) = { \"all\" };\n  int ic = regmatch->rm_ic;  // remember the ignore-case flag\n\n  /* do this loop twice:\n   * loop == 0: count the number of matching options\n   * loop == 1: copy the matching options into allocated memory\n   */\n  for (loop = 0; loop <= 1; loop++) {\n    regmatch->rm_ic = ic;\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS) {\n      for (match = 0; match < (int)ARRAY_SIZE(names);\n           match++) {\n        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {\n          if (loop == 0) {\n            num_normal++;\n          } else {\n            (*file)[count++] = vim_strsave((char_u *)names[match]);\n          }\n        }\n      }\n    }\n    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n         opt_idx++) {\n      if (options[opt_idx].var == NULL) {\n        continue;\n      }\n      if (xp->xp_context == EXPAND_BOOL_SETTINGS\n          && !(options[opt_idx].flags & P_BOOL)) {\n        continue;\n      }\n      match = false;\n      if (vim_regexec(regmatch, str, (colnr_T)0)\n          || (options[opt_idx].shortname != NULL\n              && vim_regexec(regmatch,\n                             (char_u *)options[opt_idx].shortname,\n                             (colnr_T)0))) {\n        match = true;\n      }\n\n      if (match) {\n        if (loop == 0) {\n          num_normal++;\n        } else\n          (*file)[count++] = vim_strsave(str);\n      }\n    }\n\n    if (loop == 0) {\n      if (num_normal > 0) {\n        *num_file = num_normal;\n      } else {\n        return OK;\n      }\n      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));\n    }\n  }\n  return OK;\n}\n\nvoid ExpandOldSetting(int *num_file, char_u ***file)\n{\n  char_u *var = NULL;\n\n  *num_file = 0;\n  *file = (char_u **)xmalloc(sizeof(char_u *));\n\n  /*\n   * For a terminal key code expand_option_idx is < 0.\n   */\n  if (expand_option_idx < 0) {\n    expand_option_idx = findoption((const char *)expand_option_name);\n  }\n\n  if (expand_option_idx >= 0) {\n    // Put string of option value in NameBuff.\n    option_value2string(&options[expand_option_idx], expand_option_flags);\n    var = NameBuff;\n  } else {\n    var = (char_u *)\"\";\n  }\n\n  // A backslash is required before some characters.  This is the reverse of\n  // what happens in do_set().\n  char_u *buf = vim_strsave_escaped(var, escape_chars);\n\n#ifdef BACKSLASH_IN_FILENAME\n  /* For MS-Windows et al. we don't double backslashes at the start and\n   * before a file name character. */\n  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {\n    if (var[0] == '\\\\' && var[1] == '\\\\'\n        && expand_option_idx >= 0\n        && (options[expand_option_idx].flags & P_EXPAND)\n        && vim_isfilec(var[2])\n        && (var[2] != '\\\\' || (var == buf && var[4] != '\\\\'))) {\n      STRMOVE(var, var + 1);\n    }\n  }\n#endif\n\n  *file[0] = buf;\n  *num_file = 1;\n}\n\n/// Get the value for the numeric or string option///opp in a nice format into\n/// NameBuff[].  Must not be called with a hidden option!\nstatic void\noption_value2string(\n    vimoption_T *opp,\n    int opt_flags                          // OPT_GLOBAL and/or OPT_LOCAL\n)\n{\n  char_u      *varp;\n\n  varp = get_varp_scope(opp, opt_flags);\n\n  if (opp->flags & P_NUM) {\n    long wc = 0;\n\n    if (wc_use_keyname(varp, &wc)) {\n      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));\n    } else if (wc != 0) {\n      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));\n    } else {\n      snprintf((char *)NameBuff,\n               sizeof(NameBuff),\n               \"%\" PRId64,\n               (int64_t)*(long *)varp);\n    }\n  } else {  // P_STRING\n    varp = *(char_u **)(varp);\n    if (varp == NULL) {  // Just in case.\n      NameBuff[0] = NUL;\n    } else if (opp->flags & P_EXPAND) {\n      home_replace(NULL, varp, NameBuff, MAXPATHL, false);\n    // Translate 'pastetoggle' into special key names.\n    } else if ((char_u **)opp->var == &p_pt) {\n      str2specialbuf((const char *)p_pt, (char *)NameBuff, MAXPATHL);\n    } else {\n      STRLCPY(NameBuff, varp, MAXPATHL);\n    }\n  }\n}\n\n/// Return true if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n/// printed as a keyname.\n/// \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\nstatic int wc_use_keyname(char_u *varp, long *wcp)\n{\n  if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm)) {\n    *wcp = *(long *)varp;\n    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) >= 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Any character has an equivalent 'langmap' character.  This is used for\n/// keyboards that have a special language mode that sends characters above\n/// 128 (although other characters can be translated too).  The \"to\" field is a\n/// Vim command character.  This avoids having to switch the keyboard back to\n/// ASCII mode when leaving Insert mode.\n///\n/// langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim\n/// commands.\n/// langmap_mapga.ga_data is a sorted table of langmap_entry_T.\n/// This does the same as langmap_mapchar[] for characters >= 256.\n///\n/// With multi-byte support use growarray for 'langmap' chars >= 256\ntypedef struct {\n  int from;\n  int to;\n} langmap_entry_T;\n\nstatic garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;\n\n/// Search for an entry in \"langmap_mapga\" for \"from\".  If found set the \"to\"\n/// field.  If not found insert a new entry at the appropriate location.\nstatic void langmap_set_entry(int from, int to)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  unsigned int a = 0;\n  assert(langmap_mapga.ga_len >= 0);\n  unsigned int b = (unsigned int)langmap_mapga.ga_len;\n\n  // Do a binary search for an existing entry.\n  while (a != b) {\n    unsigned int i = (a + b) / 2;\n    int d = entries[i].from - from;\n\n    if (d == 0) {\n      entries[i].to = to;\n      return;\n    }\n    if (d < 0) {\n      a = i + 1;\n    } else {\n      b = i;\n    }\n  }\n\n  ga_grow(&langmap_mapga, 1);\n\n  // insert new entry at position \"a\"\n  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;\n  memmove(entries + 1, entries,\n          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));\n  langmap_mapga.ga_len++;\n  entries[0].from = from;\n  entries[0].to = to;\n}\n\n/// Apply 'langmap' to multi-byte character \"c\" and return the result.\nint langmap_adjust_mb(int c)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  int a = 0;\n  int b = langmap_mapga.ga_len;\n\n  while (a != b) {\n    int i = (a + b) / 2;\n    int d = entries[i].from - c;\n\n    if (d == 0) {\n      return entries[i].to;        // found matching entry\n    }\n    if (d < 0) {\n      a = i + 1;\n    } else {\n      b = i;\n    }\n  }\n  return c;    // no entry found, return \"c\" unmodified\n}\n\nstatic void langmap_init(void)\n{\n  for (int i = 0; i < 256; i++) {\n    langmap_mapchar[i] = (char_u)i;      // we init with a one-to-one map\n  }\n  ga_init(&langmap_mapga, sizeof(langmap_entry_T), 8);\n}\n\n/// Called when langmap option is set; the language map can be\n/// changed at any time!\nstatic void langmap_set(void)\n{\n  char_u  *p;\n  char_u  *p2;\n  int from, to;\n\n  ga_clear(&langmap_mapga);                 // clear the previous map first\n  langmap_init();                           // back to one-to-one map\n\n  for (p = p_langmap; p[0] != NUL; ) {\n    for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';\n         MB_PTR_ADV(p2)) {\n      if (p2[0] == '\\\\' && p2[1] != NUL) {\n        p2++;\n      }\n    }\n    if (p2[0] == ';') {\n      p2++;                 // abcd;ABCD form, p2 points to A\n    } else {\n      p2 = NULL;            // aAbBcCdD form, p2 is NULL\n    }\n    while (p[0]) {\n      if (p[0] == ',') {\n        p++;\n        break;\n      }\n      if (p[0] == '\\\\' && p[1] != NUL) {\n        p++;\n      }\n      from = utf_ptr2char(p);\n      to = NUL;\n      if (p2 == NULL) {\n        MB_PTR_ADV(p);\n        if (p[0] != ',') {\n          if (p[0] == '\\\\') {\n            p++;\n          }\n          to = utf_ptr2char(p);\n        }\n      } else {\n        if (p2[0] != ',') {\n          if (p2[0] == '\\\\') {\n            p2++;\n          }\n          to = utf_ptr2char(p2);\n        }\n      }\n      if (to == NUL) {\n        EMSG2(_(\"E357: 'langmap': Matching character missing for %s\"),\n            transchar(from));\n        return;\n      }\n\n      if (from >= 256) {\n        langmap_set_entry(from, to);\n      } else {\n        assert(to <= UCHAR_MAX);\n        langmap_mapchar[from & 255] = (char_u)to;\n      }\n\n      // Advance to next pair\n      MB_PTR_ADV(p);\n      if (p2 != NULL) {\n        MB_PTR_ADV(p2);\n        if (*p == ';') {\n          p = p2;\n          if (p[0] != NUL) {\n            if (p[0] != ',') {\n              EMSG2(_(\n                      \"E358: 'langmap': Extra characters after semicolon: %s\"),\n                  p);\n              return;\n            }\n            p++;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\n/// Return true if format option 'x' is in effect.\n/// Take care of no formatting when 'paste' is set.\nbool has_format_option(int x)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (p_paste) {\n    return false;\n  }\n  return vim_strchr(curbuf->b_p_fo, x) != NULL;\n}\n\n/// @returns true if \"x\" is present in 'shortmess' option, or\n/// 'shortmess' contains 'a' and \"x\" is present in SHM_ALL_ABBREVIATIONS.\nbool shortmess(int x)\n{\n  return (p_shm != NULL\n          && (vim_strchr(p_shm, x) != NULL\n              || (vim_strchr(p_shm, 'a') != NULL\n                  && vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));\n}\n\n/// paste_option_changed() - Called after p_paste was set or reset.\nstatic void paste_option_changed(void)\n{\n  static int old_p_paste = false;\n  static int save_sm = 0;\n  static int save_sta = 0;\n  static int save_ru = 0;\n  static int save_ri = 0;\n  static int save_hkmap = 0;\n\n  if (p_paste) {\n    /*\n     * Paste switched from off to on.\n     * Save the current values, so they can be restored later.\n     */\n    if (!old_p_paste) {\n      // save options for each buffer\n      FOR_ALL_BUFFERS(buf) {\n        buf->b_p_tw_nopaste = buf->b_p_tw;\n        buf->b_p_wm_nopaste = buf->b_p_wm;\n        buf->b_p_sts_nopaste = buf->b_p_sts;\n        buf->b_p_ai_nopaste = buf->b_p_ai;\n        buf->b_p_et_nopaste = buf->b_p_et;\n        if (buf->b_p_vsts_nopaste) {\n          xfree(buf->b_p_vsts_nopaste);\n        }\n        buf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n                                    ? vim_strsave(buf->b_p_vsts)\n                                    : NULL;\n      }\n\n      // save global options\n      save_sm = p_sm;\n      save_sta = p_sta;\n      save_ru = p_ru;\n      save_ri = p_ri;\n      save_hkmap = p_hkmap;\n      // save global values for local buffer options\n      p_ai_nopaste = p_ai;\n      p_et_nopaste = p_et;\n      p_sts_nopaste = p_sts;\n      p_tw_nopaste = p_tw;\n      p_wm_nopaste = p_wm;\n      if (p_vsts_nopaste) {\n        xfree(p_vsts_nopaste);\n      }\n      p_vsts_nopaste = p_vsts && p_vsts != empty_option\n                          ? vim_strsave(p_vsts)\n                          : NULL;\n    }\n\n    // Always set the option values, also when 'paste' is set when it is\n    // already on.\n    // set options for each buffer\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = 0;              // textwidth is 0\n      buf->b_p_wm = 0;              // wrapmargin is 0\n      buf->b_p_sts = 0;             // softtabstop is 0\n      buf->b_p_ai = 0;              // no auto-indent\n      buf->b_p_et = 0;              // no expandtab\n      if (buf->b_p_vsts) {\n        free_string_option(buf->b_p_vsts);\n      }\n      buf->b_p_vsts = empty_option;\n      if (buf->b_p_vsts_array) {\n        xfree(buf->b_p_vsts_array);\n      }\n      buf->b_p_vsts_array = 0;\n    }\n\n    // set global options\n    p_sm = 0;                       // no showmatch\n    p_sta = 0;                      // no smarttab\n    if (p_ru) {\n      status_redraw_all();          // redraw to remove the ruler\n    }\n    p_ru = 0;                       // no ruler\n    p_ri = 0;                       // no reverse insert\n    p_hkmap = 0;                    // no Hebrew keyboard\n    // set global values for local buffer options\n    p_tw = 0;\n    p_wm = 0;\n    p_sts = 0;\n    p_ai = 0;\n    if (p_vsts) {\n      free_string_option(p_vsts);\n    }\n    p_vsts = empty_option;\n  } else if (old_p_paste) {\n    // Paste switched from on to off: Restore saved values.\n\n    // restore options for each buffer\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = buf->b_p_tw_nopaste;\n      buf->b_p_wm = buf->b_p_wm_nopaste;\n      buf->b_p_sts = buf->b_p_sts_nopaste;\n      buf->b_p_ai = buf->b_p_ai_nopaste;\n      buf->b_p_et = buf->b_p_et_nopaste;\n      if (buf->b_p_vsts) {\n        free_string_option(buf->b_p_vsts);\n      }\n      buf->b_p_vsts = buf->b_p_vsts_nopaste\n                        ? vim_strsave(buf->b_p_vsts_nopaste)\n                        : empty_option;\n      if (buf->b_p_vsts_array) {\n        xfree(buf->b_p_vsts_array);\n      }\n      if (buf->b_p_vsts && buf->b_p_vsts != empty_option) {\n        tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n      } else {\n        buf->b_p_vsts_array = 0;\n      }\n    }\n\n    // restore global options\n    p_sm = save_sm;\n    p_sta = save_sta;\n    if (p_ru != save_ru) {\n      status_redraw_all();          // redraw to draw the ruler\n    }\n    p_ru = save_ru;\n    p_ri = save_ri;\n    p_hkmap = save_hkmap;\n    // set global values for local buffer options\n    p_ai = p_ai_nopaste;\n    p_et = p_et_nopaste;\n    p_sts = p_sts_nopaste;\n    p_tw = p_tw_nopaste;\n    p_wm = p_wm_nopaste;\n    if (p_vsts) {\n      free_string_option(p_vsts);\n    }\n    p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n  }\n\n  old_p_paste = p_paste;\n}\n\n/// vimrc_found() - Called when a vimrc or \"VIMINIT\" has been found.\n///\n/// Set the values for options that didn't get set yet to the defaults.\n/// When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\nvoid vimrc_found(char_u *fname, char_u *envname)\n{\n  if (fname != NULL && envname != NULL) {\n    char *p = vim_getenv((char *)envname);\n    if (p == NULL) {\n      // Set $MYVIMRC to the first vimrc file found.\n      p = FullName_save((char *)fname, false);\n      if (p != NULL) {\n        os_setenv((char *)envname, p, 1);\n        xfree(p);\n      }\n    } else {\n      xfree(p);\n    }\n  }\n}\n\n/// Check whether global option has been set\n///\n/// @param[in]  name  Option name.\n///\n/// @return True if it was set.\nbool option_was_set(const char *name)\n{\n  int idx;\n\n  idx = findoption(name);\n  if (idx < 0) {  // Unknown option.\n    return false;\n  } else if (options[idx].flags & P_WAS_SET) {\n    return true;\n  }\n  return false;\n}\n\n/// Reset the flag indicating option \"name\" was set.\n///\n/// @param[in]  name  Option name.\nvoid reset_option_was_set(const char *name)\n{\n  const int idx = findoption(name);\n\n  if (idx >= 0) {\n    options[idx].flags &= ~P_WAS_SET;\n  }\n}\n\n/// fill_breakat_flags() -- called when 'breakat' changes value.\nstatic void fill_breakat_flags(void)\n{\n  char_u      *p;\n  int i;\n\n  for (i = 0; i < 256; i++) {\n    breakat_flags[i] = false;\n  }\n\n  if (p_breakat != NULL) {\n    for (p = p_breakat; *p; p++) {\n      breakat_flags[*p] = true;\n    }\n  }\n}\n\n/// fill_culopt_flags() -- called when 'culopt' changes value\nstatic int fill_culopt_flags(char_u *val, win_T *wp)\n{\n  char_u *p;\n  char_u culopt_flags_new = 0;\n\n  if (val == NULL) {\n    p = wp->w_p_culopt;\n  } else {\n    p = val;\n  }\n  while (*p != NUL) {\n    if (STRNCMP(p, \"line\", 4) == 0) {\n      p += 4;\n      culopt_flags_new |= CULOPT_LINE;\n    } else if (STRNCMP(p, \"both\", 4) == 0) {\n      p += 4;\n      culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;\n    } else if (STRNCMP(p, \"number\", 6) == 0) {\n      p += 6;\n      culopt_flags_new |= CULOPT_NBR;\n    } else if (STRNCMP(p, \"screenline\", 10) == 0) {\n      p += 10;\n      culopt_flags_new |= CULOPT_SCRLINE;\n    }\n\n    if (*p != ',' && *p != NUL) {\n      return FAIL;\n    }\n    if (*p == ',') {\n      p++;\n    }\n  }\n\n  // Can't have both \"line\" and \"screenline\".\n  if ((culopt_flags_new & CULOPT_LINE) && (culopt_flags_new & CULOPT_SCRLINE)) {\n    return FAIL;\n  }\n  wp->w_p_culopt_flags = culopt_flags_new;\n\n  return OK;\n}\n\n/// Check an option that can be a range of string values.\n///\n/// Return OK for correct value, FAIL otherwise.\n/// Empty is always OK.\nstatic int check_opt_strings(\n    char_u *val,\n    char **values,\n    int list                   // when true: accept a list of values\n)\n{\n  return opt_strings_flags(val, values, NULL, list);\n}\n\n/// Handle an option that can be a range of string values.\n/// Set a flag in \"*flagp\" for each string present.\n///\n/// Return OK for correct value, FAIL otherwise.\n/// Empty is always OK.\nstatic int opt_strings_flags(\n    char_u *val,             // new value\n    char **values,           // array of valid string values\n    unsigned *flagp,\n    bool list                // when true: accept a list of values\n)\n{\n  unsigned int new_flags = 0;\n\n  while (*val) {\n    for (unsigned int i = 0;; i++) {\n      if (values[i] == NULL) {          // val not found in values[]\n        return FAIL;\n      }\n\n      size_t len = STRLEN(values[i]);\n      if (STRNCMP(values[i], val, len) == 0\n          && ((list && val[len] == ',') || val[len] == NUL)) {\n        val += len + (val[len] == ',');\n        assert(i < sizeof(1U) * 8);\n        new_flags |= (1U << i);\n        break;                  // check next item in val list\n      }\n    }\n  }\n  if (flagp != NULL) {\n    *flagp = new_flags;\n  }\n\n  return OK;\n}\n\n/// Read the 'wildmode' option, fill wim_flags[].\nstatic int check_opt_wim(void)\n{\n  char_u new_wim_flags[4];\n  char_u      *p;\n  int i;\n  int idx = 0;\n\n  for (i = 0; i < 4; i++) {\n    new_wim_flags[i] = 0;\n  }\n\n  for (p = p_wim; *p; p++) {\n    for (i = 0; ASCII_ISALPHA(p[i]); i++) {}\n    if (p[i] != NUL && p[i] != ',' && p[i] != ':') {\n      return FAIL;\n    }\n    if (i == 7 && STRNCMP(p, \"longest\", 7) == 0) {\n      new_wim_flags[idx] |= WIM_LONGEST;\n    } else if (i == 4 && STRNCMP(p, \"full\", 4) == 0) {\n      new_wim_flags[idx] |= WIM_FULL;\n    } else if (i == 4 && STRNCMP(p, \"list\", 4) == 0) {\n      new_wim_flags[idx] |= WIM_LIST;\n    } else if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0) {\n      new_wim_flags[idx] |= WIM_BUFLASTUSED;\n    } else {\n      return FAIL;\n    }\n    p += i;\n    if (*p == NUL) {\n      break;\n    }\n    if (*p == ',') {\n      if (idx == 3) {\n        return FAIL;\n      }\n      idx++;\n    }\n  }\n\n  // fill remaining entries with last flag\n  while (idx < 3) {\n    new_wim_flags[idx + 1] = new_wim_flags[idx];\n    idx++;\n  }\n\n  // only when there are no errors, wim_flags[] is changed\n  for (i = 0; i < 4; i++) {\n    wim_flags[i] = new_wim_flags[i];\n  }\n  return OK;\n}\n\n/// Check if backspacing over something is allowed.\n/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP\nbool can_bs(int what)\n{\n  if (what == BS_START && bt_prompt(curbuf)) {\n    return false;\n  }\n  switch (*p_bs) {\n    case '3':       return true;\n    case '2':       return what != BS_NOSTOP;\n    case '1':       return what != BS_START;\n    case '0':       return false;\n  }\n  return vim_strchr(p_bs, what) != NULL;\n}\n\n/// Save the current values of 'fileformat' and 'fileencoding', so that we know\n/// the file must be considered changed when the value is different.\nvoid save_file_ff(buf_T *buf)\n{\n  buf->b_start_ffc = *buf->b_p_ff;\n  buf->b_start_eol = buf->b_p_eol;\n  buf->b_start_bomb = buf->b_p_bomb;\n\n  // Only use free/alloc when necessary, they take time.\n  if (buf->b_start_fenc == NULL\n      || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0) {\n    xfree(buf->b_start_fenc);\n    buf->b_start_fenc = vim_strsave(buf->b_p_fenc);\n  }\n}\n\n/// Return true if 'fileformat' and/or 'fileencoding' has a different value\n/// from when editing started (save_file_ff() called).\n/// Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was\n/// changed and 'binary' is not set.\n/// Also when 'endofline' was changed and 'fixeol' is not set.\n/// When \"ignore_empty\" is true don't consider a new, empty buffer to be\n/// changed.\nbool file_ff_differs(buf_T *buf, bool ignore_empty)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // In a buffer that was never loaded the options are not valid.\n  if (buf->b_flags & BF_NEVERLOADED) {\n    return false;\n  }\n  if (ignore_empty\n      && (buf->b_flags & BF_NEW)\n      && buf->b_ml.ml_line_count == 1\n      && *ml_get_buf(buf, (linenr_T)1, false) == NUL) {\n    return false;\n  }\n  if (buf->b_start_ffc != *buf->b_p_ff) {\n    return true;\n  }\n  if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol) {\n    return true;\n  }\n  if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb) {\n    return true;\n  }\n  if (buf->b_start_fenc == NULL) {\n    return *buf->b_p_fenc != NUL;\n  }\n  return STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0;\n}\n\n/// return OK if \"p\" is a valid fileformat name, FAIL otherwise.\nint check_ff_value(char_u *p)\n{\n  return check_opt_strings(p, p_ff_values, false);\n}\n\n// Set the integer values corresponding to the string setting of 'vartabstop'.\n// \"array\" will be set, caller must free it if needed.\nbool tabstop_set(char_u *var, long **array)\n{\n  long valcount = 1;\n  int t;\n  char_u *cp;\n\n  if (var[0] == NUL || (var[0] == '0' && var[1] == NUL)) {\n    *array = NULL;\n    return true;\n  }\n\n  for (cp = var; *cp != NUL; cp++) {\n    if (cp == var || cp[-1] == ',') {\n      char_u *end;\n\n      if (strtol((char *)cp, (char **)&end, 10) <= 0) {\n        if (cp != end) {\n          EMSG(_(e_positive));\n        } else {\n          EMSG(_(e_invarg));\n        }\n        return false;\n      }\n    }\n\n    if (ascii_isdigit(*cp)) {\n      continue;\n    }\n    if (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL) {\n      valcount++;\n      continue;\n    }\n    EMSG(_(e_invarg));\n    return false;\n  }\n\n  *array = (long *)xmalloc((unsigned)(valcount + 1) * sizeof(long));\n  (*array)[0] = valcount;\n\n  t = 1;\n  for (cp = var; *cp != NUL;) {\n    (*array)[t++] = atoi((char *)cp);\n    while (*cp  != NUL && *cp != ',') {\n      cp++;\n    }\n    if (*cp != NUL) {\n      cp++;\n    }\n  }\n\n  return true;\n}\n\n// Calculate the number of screen spaces a tab will occupy.\n// If \"vts\" is set then the tab widths are taken from that array,\n// otherwise the value of ts is used.\nint tabstop_padding(colnr_T col, long ts_arg, long *vts)\n{\n  long ts = ts_arg == 0 ? 8 : ts_arg;\n  colnr_T tabcol = 0;\n  int t;\n  long padding = 0;\n\n  if (vts == NULL || vts[0] == 0) {\n    return (int)(ts - (col % ts));\n  }\n\n  const long tabcount = vts[0];\n\n  for (t = 1; t <= tabcount; t++) {\n    tabcol += (colnr_T)vts[t];\n    if (tabcol > col) {\n      padding = tabcol - col;\n      break;\n    }\n  }\n  if (t > tabcount) {\n    padding = vts[tabcount] - ((col - tabcol) % vts[tabcount]);\n  }\n\n  return (int)padding;\n}\n\n// Find the size of the tab that covers a particular column.\nint tabstop_at(colnr_T col, long ts, long *vts)\n{\n  colnr_T tabcol = 0;\n  int t;\n  long tab_size = 0;\n\n  if (vts == NULL || vts[0] == 0) {\n    return (int)ts;\n  }\n\n  const long tabcount = vts[0];\n  for (t = 1; t <= tabcount; t++) {\n    tabcol += (colnr_T)vts[t];\n    if (tabcol > col) {\n      tab_size = vts[t];\n      break;\n    }\n  }\n  if (t > tabcount) {\n    tab_size = vts[tabcount];\n  }\n\n  return (int)tab_size;\n}\n\n// Find the column on which a tab starts.\ncolnr_T tabstop_start(colnr_T col, long ts, long *vts)\n{\n  colnr_T tabcol = 0;\n  int t;\n\n  if (vts == NULL || vts[0] == 0) {\n    return (int)((col / ts) * ts);\n  }\n\n  const long tabcount = vts[0];\n  for (t = 1; t <= tabcount; t++) {\n    tabcol += (colnr_T)vts[t];\n    if (tabcol > col) {\n      return (int)(tabcol - vts[t]);\n    }\n  }\n\n  const int excess = (int)(tabcol % vts[tabcount]);\n  return (int)(excess + ((col - excess) / vts[tabcount]) * vts[tabcount]);\n}\n\n// Find the number of tabs and spaces necessary to get from one column\n// to another.\nvoid tabstop_fromto(colnr_T start_col,\n                    colnr_T end_col,\n                    long ts_arg,\n                    long *vts,\n                    int *ntabs,\n                    int *nspcs)\n{\n  int spaces = end_col - start_col;\n  colnr_T tabcol = 0;\n  long padding = 0;\n  int t;\n  long ts = ts_arg == 0 ? curbuf->b_p_ts : ts_arg;\n\n  if (vts == NULL || vts[0] == 0) {\n    int tabs = 0;\n\n    const int initspc = (int)(ts - (start_col % ts));\n    if (spaces >= initspc) {\n      spaces -= initspc;\n      tabs++;\n    }\n    tabs += (int)(spaces / ts);\n    spaces -= (int)((spaces / ts) * ts);\n\n    *ntabs = tabs;\n    *nspcs = spaces;\n    return;\n  }\n\n  // Find the padding needed to reach the next tabstop.\n  const long tabcount = vts[0];\n  for (t = 1; t <= tabcount; t++) {\n    tabcol += (colnr_T)vts[t];\n    if (tabcol > start_col) {\n      padding = tabcol - start_col;\n      break;\n    }\n  }\n  if (t > tabcount) {\n    padding = vts[tabcount] - ((start_col - tabcol) % vts[tabcount]);\n  }\n\n  // If the space needed is less than the padding no tabs can be used.\n  if (spaces < padding) {\n    *ntabs = 0;\n    *nspcs = spaces;\n    return;\n  }\n\n  *ntabs = 1;\n  spaces -= (int)padding;\n\n  // At least one tab has been used. See if any more will fit.\n  while (spaces != 0 && ++t <= tabcount) {\n    padding = vts[t];\n    if (spaces < padding) {\n      *nspcs = spaces;\n      return;\n    }\n    *ntabs += 1;\n    spaces -= (int)padding;\n  }\n\n  *ntabs += spaces / (int)vts[tabcount];\n  *nspcs = spaces % (int)vts[tabcount];\n}\n\n// See if two tabstop arrays contain the same values.\nbool tabstop_eq(long *ts1, long *ts2)\n{\n  int t;\n\n  if ((ts1 == 0 && ts2) || (ts1 && ts2 == 0)) {\n    return false;\n  }\n  if (ts1 == ts2) {\n    return true;\n  }\n  if (ts1[0] != ts2[0]) {\n    return false;\n  }\n\n  for (t = 1; t <= ts1[0]; t++) {\n    if (ts1[t] != ts2[t]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Copy a tabstop array, allocating space for the new array.\nint *tabstop_copy(long *oldts)\n{\n  long *newts;\n  int t;\n\n  if (oldts == 0) {\n    return 0;\n  }\n\n  newts = xmalloc((unsigned)(oldts[0] + 1) * sizeof(long));\n  for (t = 0; t <= oldts[0]; t++) {\n    newts[t] = oldts[t];\n  }\n\n  return (int *)newts;\n}\n\n// Return a count of the number of tabstops.\nint tabstop_count(long *ts)\n{\n  return ts != NULL ? (int)ts[0] : 0;\n}\n\n// Return the first tabstop, or 8 if there are no tabstops defined.\nint tabstop_first(long *ts)\n{\n  return ts != NULL ? (int)ts[1] : 8;\n}\n\n/// Return the effective shiftwidth value for current buffer, using the\n/// 'tabstop' value when 'shiftwidth' is zero.\nint get_sw_value(buf_T *buf)\n{\n  long result = get_sw_value_col(buf, 0);\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n// Idem, using the first non-black in the current line.\nlong get_sw_value_indent(buf_T *buf)\n{\n  pos_T pos = curwin->w_cursor;\n\n  pos.col = (colnr_T)getwhitecols_curline();\n  return get_sw_value_pos(buf, &pos);\n}\n\n// Idem, using \"pos\".\nlong get_sw_value_pos(buf_T *buf, pos_T *pos)\n{\n  pos_T save_cursor = curwin->w_cursor;\n  long sw_value;\n\n  curwin->w_cursor = *pos;\n  sw_value = get_sw_value_col(buf, get_nolist_virtcol());\n  curwin->w_cursor = save_cursor;\n  return sw_value;\n}\n\n// Idem, using virtual column \"col\".\nlong get_sw_value_col(buf_T *buf, colnr_T col)\n{\n  return buf->b_p_sw ? buf->b_p_sw\n                     : tabstop_at(col, buf->b_p_ts, buf->b_p_vts_array);\n}\n\n/// Return the effective softtabstop value for the current buffer,\n/// using the shiftwidth  value when 'softtabstop' is negative.\nint get_sts_value(void)\n{\n  long result = curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n/// This is called when 'breakindentopt' is changed and when a window is\n/// initialized\nstatic bool briopt_check(win_T *wp)\n{\n  int bri_shift = 0;\n  int bri_min = 20;\n  bool bri_sbr = false;\n  int bri_list = 0;\n\n  char_u *p = wp->w_p_briopt;\n  while (*p != NUL)\n  {\n    if (STRNCMP(p, \"shift:\", 6) == 0\n        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))\n    {\n      p += 6;\n      bri_shift = getdigits_int(&p, true, 0);\n    }\n    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))\n    {\n      p += 4;\n      bri_min = getdigits_int(&p, true, 0);\n    }\n    else if (STRNCMP(p, \"sbr\", 3) == 0)\n    {\n      p += 3;\n      bri_sbr = true;\n    } else if (STRNCMP(p, \"list:\", 5) == 0) {\n      p += 5;\n      bri_list = (int)getdigits(&p, false, 0);\n    }\n    if (*p != ',' && *p != NUL) {\n      return false;\n    }\n    if (*p == ',') {\n      p++;\n    }\n  }\n\n  wp->w_briopt_shift = bri_shift;\n  wp->w_briopt_min = bri_min;\n  wp->w_briopt_sbr = bri_sbr;\n  wp->w_briopt_list  = bri_list;\n\n  return true;\n}\n\n/// Get the local or global value of 'backupcopy'.\n///\n/// @param buf The buffer.\nunsigned int get_bkc_value(buf_T *buf)\n{\n  return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.\nint get_fileformat(const buf_T *buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  int c = *buf->b_p_ff;\n\n  if (buf->b_p_bin || c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Like get_fileformat(), but override 'fileformat' with \"p\" for \"++opt=val\"\n/// argument.\n///\n/// @param eap  can be NULL!\nint get_fileformat_force(const buf_T *buf, const exarg_T *eap)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  int c;\n\n  if (eap != NULL && eap->force_ff != 0) {\n    c = eap->force_ff;\n  } else {\n    if ((eap != NULL && eap->force_bin != 0)\n        ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin) {\n      return EOL_UNIX;\n    }\n    c = *buf->b_p_ff;\n  }\n  if (c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Return the default fileformat from 'fileformats'.\nint default_fileformat(void)\n{\n  switch (*p_ffs) {\n  case 'm':   return EOL_MAC;\n  case 'd':   return EOL_DOS;\n  }\n  return EOL_UNIX;\n}\n\n/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.\n///\n/// Sets 'fileformat'.\n///\n/// @param eol_style End-of-line style.\n/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL\nvoid set_fileformat(int eol_style, int opt_flags)\n{\n  char *p = NULL;\n\n  switch (eol_style) {\n      case EOL_UNIX:\n          p = FF_UNIX;\n          break;\n      case EOL_MAC:\n          p = FF_MAC;\n          break;\n      case EOL_DOS:\n          p = FF_DOS;\n          break;\n  }\n\n  // p is NULL if \"eol_style\" is EOL_UNKNOWN.\n  if (p != NULL) {\n    set_string_option_direct(\"ff\",\n                             -1,\n                             (char_u *)p,\n                             OPT_FREE | opt_flags,\n                             0);\n  }\n\n  // This may cause the buffer to become (un)modified.\n  check_status(curbuf);\n  redraw_tabline = true;\n  need_maketitle = true;  // Set window title later.\n}\n\n/// Skip to next part of an option argument: skip space and comma\nchar_u *skip_to_option_part(const char_u *p)\n{\n  if (*p == ',') {\n    p++;\n  }\n  while (*p == ' ') {\n    p++;\n  }\n  return (char_u *)p;\n}\n\n/// Isolate one part of a string option separated by `sep_chars`.\n///\n/// @param[in,out]  option    advanced to the next part\n/// @param[in,out]  buf       copy of the isolated part\n/// @param[in]      maxlen    length of `buf`\n/// @param[in]      sep_chars chars that separate the option parts\n///\n/// @return length of `*option`\nsize_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,\n                        char *sep_chars)\n{\n  size_t len = 0;\n  char_u  *p = *option;\n\n  // skip '.' at start of option part, for 'suffixes'\n  if (*p == '.') {\n    buf[len++] = *p++;\n  }\n  while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL) {\n    // Skip backslash before a separator character and space.\n    if (p[0] == '\\\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL) {\n      p++;\n    }\n    if (len < maxlen - 1) {\n      buf[len++] = *p;\n    }\n    p++;\n  }\n  buf[len] = NUL;\n\n  if (*p != NUL && *p != ',') {  // skip non-standard separator\n    p++;\n  }\n  p = skip_to_option_part(p);    // p points to next file name\n\n  *option = p;\n  return len;\n}\n\n/// Return true when 'shell' has \"csh\" in the tail.\nint csh_like_shell(void)\n{\n  return strstr((char *)path_tail(p_sh), \"csh\") != NULL;\n}\n\n/// Return the number of requested sign columns, based on current\n/// buffer signs and on user configuration.\nint win_signcol_count(win_T *wp)\n{\n  return win_signcol_configured(wp, NULL);\n}\n\n/// Return the number of requested sign columns, based on user / configuration.\nint win_signcol_configured(win_T *wp, int *is_fixed)\n{\n  int minimum = 0, maximum = 1, needed_signcols;\n  const char *scl = (const char *)wp->w_p_scl;\n\n  if (is_fixed) {\n    *is_fixed = 1;\n  }\n\n  // Note: It checks \"no\" or \"number\" in 'signcolumn' option\n  if (*scl == 'n'\n      && (*(scl + 1) == 'o' || (*(scl + 1) == 'u'\n                                && (wp->w_p_nu || wp->w_p_rnu)))) {\n    return 0;\n  }\n  needed_signcols = buf_signcols(wp->w_buffer);\n\n  // yes or yes\n  if (!strncmp(scl, \"yes:\", 4)) {\n    // Fixed amount of columns\n    return scl[4] - '0';\n  }\n  if (*scl == 'y') {\n    return 1;\n  }\n\n  if (is_fixed) {\n    // auto or auto:<NUM>\n    *is_fixed = 0;\n  }\n\n  if (!strncmp(scl, \"auto:\", 5)) {\n    // Variable depending on a configuration\n    maximum = scl[5] - '0';\n    // auto:<NUM>-<NUM>\n    if (strlen(scl) == 8 && *(scl + 6) == '-') {\n      minimum = maximum;\n      maximum = scl[7] - '0';\n    }\n  }\n\n  int ret = MAX(minimum, MIN(maximum, needed_signcols));\n  assert(ret <= SIGN_SHOW_MAX);\n  return ret;\n}\n\n// Get the local or global value of 'showbreak'.\nchar_u *get_showbreak_value(win_T *win FUNC_ATTR_UNUSED)\n{\n  return p_sbr;\n}\n\n/// Get window or buffer local options\ndict_T *get_winbuf_options(const int bufopt)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  dict_T *const d = tv_dict_alloc();\n\n  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {\n    struct vimoption *opt = &options[opt_idx];\n\n    if ((bufopt && (opt->indir & PV_BUF))\n        || (!bufopt && (opt->indir & PV_WIN))) {\n      char_u *varp = get_varp(opt);\n\n      if (varp != NULL) {\n        if (opt->flags & P_STRING) {\n          tv_dict_add_str(d, opt->fullname, strlen(opt->fullname),\n                          *(const char **)varp);\n        } else if (opt->flags & P_NUM) {\n          tv_dict_add_nr(d, opt->fullname, strlen(opt->fullname),\n                         *(long *)varp);\n        } else {\n          tv_dict_add_nr(d, opt->fullname, strlen(opt->fullname), *(int *)varp);\n        }\n      }\n    }\n  }\n\n  return d;\n}\n\n/// Return the effective 'scrolloff' value for the current window, using the\n/// global value when appropriate.\nlong get_scrolloff_value(win_T *wp)\n{\n  // Disallow scrolloff in terminal-mode. #11915\n  if (State & TERM_FOCUS) {\n    return 0;\n  }\n  return wp->w_p_so < 0 ? p_so : wp->w_p_so;\n}\n\n/// Return the effective 'sidescrolloff' value for the current window, using the\n/// global value when appropriate.\nlong get_sidescrolloff_value(win_T *wp)\n{\n  return wp->w_p_siso < 0 ? p_siso : wp->w_p_siso;\n}\n\nDictionary get_vimoption(String name, Error *err)\n{\n  int opt_idx = findoption_len((const char *)name.data, name.size);\n  if (opt_idx < 0) {\n    api_set_error(err, kErrorTypeValidation, \"no such option: '%s'\", name.data);\n    return (Dictionary)ARRAY_DICT_INIT;\n  }\n  return vimoption2dict(&options[opt_idx]);\n}\n\nDictionary get_all_vimoptions(void)\n{\n  Dictionary retval = ARRAY_DICT_INIT;\n  for (size_t i = 0; options[i].fullname != NULL; i++) {\n    Dictionary opt_dict = vimoption2dict(&options[i]);\n    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));\n  }\n  return retval;\n}\n\nstatic Dictionary vimoption2dict(vimoption_T *opt)\n{\n    Dictionary dict = ARRAY_DICT_INIT;\n\n    PUT(dict, \"name\", CSTR_TO_OBJ(opt->fullname));\n    PUT(dict, \"shortname\", CSTR_TO_OBJ(opt->shortname));\n\n    const char *scope;\n    if (opt->indir & PV_BUF) {\n      scope = \"buf\";\n    } else if (opt->indir & PV_WIN) {\n      scope = \"win\";\n    } else {\n      scope = \"global\";\n    }\n\n    PUT(dict, \"scope\", CSTR_TO_OBJ(scope));\n\n    // welcome to the jungle\n    PUT(dict, \"global_local\", BOOL(opt->indir & PV_BOTH));\n    PUT(dict, \"commalist\", BOOL(opt->flags & P_COMMA));\n    PUT(dict, \"flaglist\", BOOL(opt->flags & P_FLAGLIST));\n\n    PUT(dict, \"was_set\", BOOL(opt->flags & P_WAS_SET));\n\n    PUT(dict, \"last_set_sid\", INTEGER_OBJ(opt->last_set.script_ctx.sc_sid));\n    PUT(dict, \"last_set_linenr\", INTEGER_OBJ(opt->last_set.script_ctx.sc_lnum));\n    PUT(dict, \"last_set_chan\", INTEGER_OBJ((int64_t)opt->last_set.channel_id));\n\n    const char *type;\n    Object def;\n    // TODO(bfredl): do you even nocp?\n    char_u *def_val = opt->def_val;\n    if (opt->flags & P_STRING) {\n      type = \"string\";\n      def = CSTR_TO_OBJ(def_val ? (char *)def_val : \"\");\n    } else if (opt->flags & P_NUM) {\n      type = \"number\";\n      def = INTEGER_OBJ((Integer)(intptr_t)def_val);\n    } else if (opt->flags & P_BOOL) {\n      type = \"boolean\";\n      def = BOOL((intptr_t)def_val);\n    } else {\n      type = \"\"; def = NIL;\n    }\n    PUT(dict, \"type\", CSTR_TO_OBJ(type));\n    PUT(dict, \"default\", def);\n    PUT(dict, \"allows_duplicates\", BOOL(!(opt->flags & P_NODUP)));\n\n    return dict;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 972}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 978}, "message": "Entering loop body"}, {"location": {"col": 40, "file": 0, "line": 982}, "message": "Assuming the condition is true"}, {"location": {"col": 12, "file": 0, "line": 983}, "message": "Assuming the condition is true"}, {"location": {"col": 11, "file": 0, "line": 989}, "message": "Assuming the condition is true"}, {"location": {"col": 9, "file": 0, "line": 992}, "message": "Calling 'set_options_default'"}, {"location": {"col": 1, "file": 0, "line": 670}, "message": "Entered call from 'do_set'"}, {"location": {"col": 19, "file": 0, "line": 675}, "message": "Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 676}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 677}, "message": "Calling 'set_option_default'"}, {"location": {"col": 1, "file": 0, "line": 606}, "message": "Entered call from 'set_options_default'"}, {"location": {"col": 14, "file": 0, "line": 609}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 613}, "message": "Assuming 'varp' is not equal to NULL"}, {"location": {"col": 9, "file": 0, "line": 614}, "message": "Assuming the condition is false"}, {"location": {"col": 16, "file": 0, "line": 627}, "message": "Assuming the condition is true"}, {"location": {"col": 37, "file": 0, "line": 628}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 9, "file": 0, "line": 982}, "expansion": "strncmp((char *)(arg), (char *)( \"all\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 37, "file": 0, "line": 628}, "expansion": "(idopt_T)(0x2000 + (int)(WV_SCROLL))", "name": "PV_SCROLL"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "d4df3c80502f873bbf1fe0a7c70edfd8", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 0, "line": 972}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 978}, "message": "Entering loop body"}, {"location": {"col": 40, "file": 0, "line": 982}, "message": "Assuming the condition is true"}, {"location": {"col": 12, "file": 0, "line": 983}, "message": "Assuming the condition is true"}, {"location": {"col": 11, "file": 0, "line": 989}, "message": "Assuming the condition is true"}, {"location": {"col": 9, "file": 0, "line": 992}, "message": "Calling 'set_options_default'"}, {"location": {"col": 1, "file": 0, "line": 670}, "message": "Entered call from 'do_set'"}, {"location": {"col": 19, "file": 0, "line": 675}, "message": "Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 676}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 677}, "message": "Calling 'set_option_default'"}, {"location": {"col": 1, "file": 0, "line": 606}, "message": "Entered call from 'set_options_default'"}, {"location": {"col": 14, "file": 0, "line": 609}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 613}, "message": "Assuming 'varp' is not equal to NULL"}, {"location": {"col": 9, "file": 0, "line": 614}, "message": "Assuming the condition is false"}, {"location": {"col": 16, "file": 0, "line": 627}, "message": "Assuming the condition is false"}, {"location": {"col": 37, "file": 0, "line": 650}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 9, "file": 0, "line": 982}, "expansion": "strncmp((char *)(arg), (char *)( \"all\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 37, "file": 0, "line": 650}, "expansion": "(idopt_T)(0x4000 + (int)(BV_ML))", "name": "PV_ML"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "dfb626e18ec0383b76f592804d203ffd", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 0, "line": 972}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 978}, "message": "Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 982}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1003}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1006}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1013}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 1038}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1041}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1041}, "message": "Loop body executed 0 times"}, {"location": {"col": 13, "file": 0, "line": 1046}, "message": "Assuming the condition is false"}, {"location": {"col": 14, "file": 0, "line": 1055}, "message": "Loop body executed 0 times"}, {"location": {"col": 30, "file": 0, "line": 1062}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1081}, "message": "Assuming 'opt_idx' is >= 0"}, {"location": {"col": 13, "file": 0, "line": 1082}, "message": "Assuming field 'var' is not equal to NULL"}, {"location": {"col": 12, "file": 0, "line": 1101}, "message": "Assuming the condition is false"}, {"location": {"col": 12, "file": 0, "line": 1106}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1112}, "message": "Assuming the condition is true"}, {"location": {"col": 13, "file": 0, "line": 1113}, "message": "Assuming the condition is false"}, {"location": {"col": 14, "file": 0, "line": 1117}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 1125}, "message": "Assuming field 'wo_diff' is not equal to 0"}, {"location": {"col": 43, "file": 0, "line": 1127}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 9, "file": 0, "line": 982}, "expansion": "strncmp((char *)(arg), (char *)( \"all\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 11, "file": 0, "line": 1003}, "expansion": "strncmp((char *)(arg), (char *)( \"no\"), (size_t)( 2))", "name": "STRNCMP"}, {"location": {"col": 18, "file": 0, "line": 1006}, "expansion": "strncmp((char *)(arg), (char *)( \"inv\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 18, "file": 0, "line": 1041}, "expansion": "( ( ((unsigned)(arg[len]) >= 'A' && (unsigned)(arg[len]) <= 'Z') || ((unsigned)(arg[len]) >= 'a' && (unsigned)(arg[len]) <= 'z')) || ascii_isdigit(arg[len]))", "name": "ASCII_ISALNUM"}, {"location": {"col": 18, "file": 0, "line": 1041}, "expansion": "( ( ((unsigned)(arg[len]) >= 'A' && (unsigned)(arg[len]) <= 'Z') || ((unsigned)(arg[len]) >= 'a' && (unsigned)(arg[len]) <= 'z')) || ascii_isdigit(arg[len]))", "name": "ASCII_ISALNUM"}, {"location": {"col": 43, "file": 0, "line": 1127}, "expansion": "(idopt_T)(0x2000 + (int)(WV_FDM))", "name": "PV_FDM"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "25fba7fa0c589b21cd507157b7c35504", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 0, "line": 972}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 978}, "message": "Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 982}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1003}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1006}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1013}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 1038}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1041}, "message": "Assuming the condition is false"}, {"location": {"col": 18, "file": 0, "line": 1041}, "message": "Loop body executed 0 times"}, {"location": {"col": 13, "file": 0, "line": 1046}, "message": "Assuming the condition is false"}, {"location": {"col": 14, "file": 0, "line": 1055}, "message": "Loop body executed 0 times"}, {"location": {"col": 30, "file": 0, "line": 1062}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1081}, "message": "Assuming 'opt_idx' is >= 0"}, {"location": {"col": 13, "file": 0, "line": 1082}, "message": "Assuming field 'var' is not equal to NULL"}, {"location": {"col": 12, "file": 0, "line": 1101}, "message": "Assuming the condition is false"}, {"location": {"col": 12, "file": 0, "line": 1106}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1112}, "message": "Assuming the condition is true"}, {"location": {"col": 13, "file": 0, "line": 1113}, "message": "Assuming the condition is false"}, {"location": {"col": 14, "file": 0, "line": 1117}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 1125}, "message": "Assuming field 'wo_diff' is not equal to 0"}, {"location": {"col": 17, "file": 0, "line": 1127}, "message": "Assuming the condition is false"}, {"location": {"col": 46, "file": 0, "line": 1128}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 9, "file": 0, "line": 982}, "expansion": "strncmp((char *)(arg), (char *)( \"all\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 11, "file": 0, "line": 1003}, "expansion": "strncmp((char *)(arg), (char *)( \"no\"), (size_t)( 2))", "name": "STRNCMP"}, {"location": {"col": 18, "file": 0, "line": 1006}, "expansion": "strncmp((char *)(arg), (char *)( \"inv\"), (size_t)( 3))", "name": "STRNCMP"}, {"location": {"col": 18, "file": 0, "line": 1041}, "expansion": "( ( ((unsigned)(arg[len]) >= 'A' && (unsigned)(arg[len]) <= 'Z') || ((unsigned)(arg[len]) >= 'a' && (unsigned)(arg[len]) <= 'z')) || ascii_isdigit(arg[len]))", "name": "ASCII_ISALNUM"}, {"location": {"col": 18, "file": 0, "line": 1041}, "expansion": "( ( ((unsigned)(arg[len]) >= 'A' && (unsigned)(arg[len]) <= 'Z') || ((unsigned)(arg[len]) >= 'a' && (unsigned)(arg[len]) <= 'z')) || ascii_isdigit(arg[len]))", "name": "ASCII_ISALNUM"}, {"location": {"col": 46, "file": 0, "line": 1128}, "expansion": "(idopt_T)(0x2000 + (int)(WV_WRAP))", "name": "PV_WRAP"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "5f243b06b7d407906e33aa2bdedf82d0", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 0, "line": 4774}, "message": "Assuming 'opt_idx' is >= 0"}, {"location": {"col": 7, "file": 0, "line": 4781}, "message": "Assuming field 'var' is not equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 4785}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 4793}, "message": "Assuming field 'indir' is not equal to PV_NONE"}, {"location": {"col": 9, "file": 0, "line": 4800}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 4804}, "message": "Assuming the condition is false"}, {"location": {"col": 16, "file": 0, "line": 4810}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 4819}, "message": "Assuming 'stringval' is not equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 4823}, "message": "Assuming 'opt_type' is not equal to SREQ_GLOBAL"}, {"location": {"col": 9, "file": 0, "line": 4830}, "message": "Assuming 'opt_type' is equal to SREQ_BUF"}, {"location": {"col": 23, "file": 0, "line": 4833}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 23, "file": 0, "line": 4833}, "expansion": "(idopt_T)(0x4000 + (int)(BV_MOD))", "name": "PV_MOD"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "1af922ac7d267eb1c7cca00dfa7107c9", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5185}, "message": "Entering loop body"}, {"location": {"col": 27, "file": 0, "line": 5186}, "message": "Entering loop body"}, {"location": {"col": 11, "file": 0, "line": 5187}, "message": "Assuming the condition is true"}, {"location": {"col": 30, "file": 0, "line": 5188}, "message": "Assuming the condition is true"}, {"location": {"col": 13, "file": 0, "line": 5190}, "message": "Assuming field 'indir' is not equal to PV_NONE"}, {"location": {"col": 14, "file": 0, "line": 5196}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 5202}, "message": "Assuming 'varp' is non-null"}, {"location": {"col": 14, "file": 0, "line": 5210}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 5216}, "message": "Assuming field 'indir' is equal to PV_NONE"}, {"location": {"col": 16, "file": 0, "line": 5237}, "message": "Entering loop body"}, {"location": {"col": 15, "file": 0, "line": 5244}, "message": "Assuming the condition is false"}, {"location": {"col": 22, "file": 0, "line": 5248}, "message": "Assuming the condition is false"}, {"location": {"col": 29, "file": 0, "line": 5257}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 29, "file": 0, "line": 5257}, "expansion": "(idopt_T)(0x4000 + (int)(BV_SYN))", "name": "PV_SYN"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "29b1c217d4f377d518b5d52838489a2f", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5185}, "message": "Entering loop body"}, {"location": {"col": 27, "file": 0, "line": 5186}, "message": "Entering loop body"}, {"location": {"col": 11, "file": 0, "line": 5187}, "message": "Assuming the condition is true"}, {"location": {"col": 30, "file": 0, "line": 5188}, "message": "Assuming the condition is true"}, {"location": {"col": 13, "file": 0, "line": 5190}, "message": "Assuming field 'indir' is not equal to PV_NONE"}, {"location": {"col": 14, "file": 0, "line": 5196}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 5202}, "message": "Assuming 'varp' is non-null"}, {"location": {"col": 14, "file": 0, "line": 5210}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 5216}, "message": "Assuming field 'indir' is equal to PV_NONE"}, {"location": {"col": 16, "file": 0, "line": 5237}, "message": "Entering loop body"}, {"location": {"col": 15, "file": 0, "line": 5244}, "message": "Assuming the condition is false"}, {"location": {"col": 22, "file": 0, "line": 5248}, "message": "Assuming the condition is false"}, {"location": {"col": 51, "file": 0, "line": 5257}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [{"location": {"col": 51, "file": 0, "line": 5257}, "expansion": "(idopt_T)(0x4000 + (int)(BV_FT))", "name": "PV_FT"}], "notes": [], "path": "src/nvim/option.c", "reportHash": "b2bfa33c2d77b9a1638e80e948ffbf27", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
