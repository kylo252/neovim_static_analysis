<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"24": {"id": 24, "path": "src/nvim/spell.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// spell.c: code for spell checking\n//\n// See spellfile.c for the Vim spell file format.\n//\n// The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n// has a list of bytes that can appear (siblings).  For each byte there is a\n// pointer to the node with the byte that follows in the word (child).\n//\n// A NUL byte is used where the word may end.  The bytes are sorted, so that\n// binary searching can be used and the NUL bytes are at the start.  The\n// number of possible bytes is stored before the list of bytes.\n//\n// The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n// either the next index or flags.  The tree starts at index 0.  For example,\n// to lookup \"vi\" this sequence is followed:\n//      i = 0\n//      len = byts[i]\n//      n = where \"v\" appears in byts[i + 1] to byts[i + len]\n//      i = idxs[n]\n//      len = byts[i]\n//      n = where \"i\" appears in byts[i + 1] to byts[i + len]\n//      i = idxs[n]\n//      len = byts[i]\n//      find that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n//\n// There are two word trees: one with case-folded words and one with words in\n// original case.  The second one is only used for keep-case words and is\n// usually small.\n//\n// There is one additional tree for when not all prefixes are applied when\n// generating the .spl file.  This tree stores all the possible prefixes, as\n// if they were words.  At each word (prefix) end the prefix nr is stored, the\n// following word must support this prefix nr.  And the condition nr is\n// stored, used to lookup the condition that the word must match with.\n//\n// Thanks to Olaf Seibert for providing an example implementation of this tree\n// and the compression mechanism.\n// LZ trie ideas:\n//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n//\n// Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n//\n// Why doesn't Vim use aspell/ispell/myspell/etc.?\n// See \":help develop-spell\".\n\n// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.\n// Only use it for small word lists!\n\n// Use SPELL_COMPRESS_ALLWAYS for debugging: compress the word tree after\n// adding a word.  Only use it for small word lists!\n\n// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a\n// specific word.\n\n// Use this to adjust the score after finding suggestions, based on the\n// suggested word sounding like the bad word.  This is much faster than doing\n// it for every possible suggestion.\n// Disadvantage: When \"the\" is typed as \"hte\" it sounds quite different (\"@\"\n// vs \"ht\") and goes down in the list.\n// Used when 'spellsuggest' is set to \"best\".\n#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)\n\n// Do the opposite: based on a maximum end score and a known sound score,\n// compute the maximum word score that can be used.\n#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)\n\n#include <assert.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <wctype.h>\n\n/* for offsetof() */\n#include <stddef.h>\n\n#include \"nvim/ascii.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/spellfile.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/input.h\"\n\n// only used for su_badflags\n#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI\n\n#define WF_CAPMASK (WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED       -1\n#define SP_RARE         0\n#define SP_OK           1\n#define SP_LOCAL        2\n#define SP_BAD          3\n\n// First language that is loaded, start of the linked list of loaded\n// languages.\nslang_T *first_lang = NULL;\n\n// file used for \"zG\" and \"zW\"\nchar_u *int_wordlist = NULL;\n\ntypedef struct wordcount_S {\n  uint16_t wc_count;                // nr of times word was seen\n  char_u wc_word[1];                // word, actually longer\n} wordcount_T;\n\n#define WC_KEY_OFF   offsetof(wordcount_T, wc_word)\n#define HI2WC(hi)    ((wordcount_T *)((hi)->hi_key - WC_KEY_OFF))\n#define MAXWORDCOUNT 0xffff\n\n// Information used when looking for suggestions.\ntypedef struct suginfo_S {\n  garray_T su_ga;                   // suggestions, contains \"suggest_T\"\n  int su_maxcount;                  // max. number of suggestions displayed\n  int su_maxscore;                  // maximum score for adding to su_ga\n  int su_sfmaxscore;                // idem, for when doing soundfold words\n  garray_T su_sga;                  // like su_ga, sound-folded scoring\n  char_u      *su_badptr;           // start of bad word in line\n  int su_badlen;                    // length of detected bad word in line\n  int su_badflags;                  // caps flags for bad word\n  char_u su_badword[MAXWLEN];       // bad word truncated at su_badlen\n  char_u su_fbadword[MAXWLEN];      // su_badword case-folded\n  char_u su_sal_badword[MAXWLEN];   // su_badword soundfolded\n  hashtab_T su_banned;              // table with banned words\n  slang_T     *su_sallang;          // default language for sound folding\n} suginfo_T;\n\n// One word suggestion.  Used in \"si_ga\".\ntypedef struct {\n  char_u      *st_word;         // suggested word, allocated string\n  int st_wordlen;               // STRLEN(st_word)\n  int st_orglen;                // length of replaced text\n  int st_score;                 // lower is better\n  int st_altscore;              // used when st_score compares equal\n  bool st_salscore;             // st_score is for soundalike\n  bool st_had_bonus;            // bonus already included in score\n  slang_T     *st_slang;        // language used for sound folding\n} suggest_T;\n\n#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])\n\n// True if a word appears in the list of banned words.\n#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))\n\n// Number of suggestions kept when cleaning up.  We need to keep more than\n// what is displayed, because when rescore_suggestions() is called the score\n// may change and wrong suggestions may be removed later.\n#define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < \\\n                                130 ? 150 : (su)->su_maxcount + 20)\n\n// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots\n// of suggestions that are not going to be displayed.\n#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)\n\n// score for various changes\n#define SCORE_SPLIT     149     // split bad word\n#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS\n#define SCORE_ICASE     52      // slightly different case\n#define SCORE_REGION    200     // word is for different region\n#define SCORE_RARE      180     // rare word\n#define SCORE_SWAP      75      // swap two characters\n#define SCORE_SWAP3     110     // swap two characters in three\n#define SCORE_REP       65      // REP replacement\n#define SCORE_SUBST     93      // substitute a character\n#define SCORE_SIMILAR   33      // substitute a similar character\n#define SCORE_SUBCOMP   33      // substitute a composing character\n#define SCORE_DEL       94      // delete a character\n#define SCORE_DELDUP    66      // delete a duplicated character\n#define SCORE_DELCOMP   28      // delete a composing character\n#define SCORE_INS       96      // insert a character\n#define SCORE_INSDUP    67      // insert a duplicate character\n#define SCORE_INSCOMP   30      // insert a composing character\n#define SCORE_NONWORD   103     // change non-word to word char\n\n#define SCORE_FILE      30      // suggestion from a file\n#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.\n                                // 350 allows for about three changes.\n\n#define SCORE_COMMON1   30      // subtracted for words seen before\n#define SCORE_COMMON2   40      // subtracted for words often seen\n#define SCORE_COMMON3   50      // subtracted for words very often seen\n#define SCORE_THRES2    10      // word count threshold for COMMON2\n#define SCORE_THRES3    100     // word count threshold for COMMON3\n\n// When trying changed soundfold words it becomes slow when trying more than\n// two changes.  With less then two changes it's slightly faster but we miss a\n// few good suggestions.  In rare cases we need to try three of four changes.\n#define SCORE_SFMAX1    200     // maximum score for first try\n#define SCORE_SFMAX2    300     // maximum score for second try\n#define SCORE_SFMAX3    400     // maximum score for third try\n\n#define SCORE_BIG       SCORE_INS * 3   // big difference\n#define SCORE_MAXMAX    999999          // accept any score\n#define SCORE_LIMITMAX  350             // for spell_edit_score_limit()\n\n// for spell_edit_score_limit() we need to know the minimum value of\n// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS\n#define SCORE_EDIT_MIN  SCORE_SIMILAR\n\n// Structure to store info for word matching.\ntypedef struct matchinf_S {\n  langp_T     *mi_lp;                   // info for language and region\n\n  // pointers to original text to be checked\n  char_u      *mi_word;                 // start of word being checked\n  char_u      *mi_end;                  // end of matching word so far\n  char_u      *mi_fend;                 // next char to be added to mi_fword\n  char_u      *mi_cend;                 // char after what was used for\n                                        // mi_capflags\n\n  // case-folded text\n  char_u mi_fword[MAXWLEN + 1];         // mi_word case-folded\n  int mi_fwordlen;                      // nr of valid bytes in mi_fword\n\n  // for when checking word after a prefix\n  int mi_prefarridx;                    // index in sl_pidxs with list of\n                                        // affixID/condition\n  int mi_prefcnt;                       // number of entries at mi_prefarridx\n  int mi_prefixlen;                     // byte length of prefix\n  int mi_cprefixlen;                    // byte length of prefix in original\n                                        // case\n\n  // for when checking a compound word\n  int mi_compoff;                       // start of following word offset\n  char_u mi_compflags[MAXWLEN];         // flags for compound words used\n  int mi_complen;                       // nr of compound words used\n  int mi_compextra;                     // nr of COMPOUNDROOT words\n\n  // others\n  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.\n  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP\n  win_T       *mi_win;                  // buffer being checked\n\n  // for NOBREAK\n  int mi_result2;                       // \"mi_resul\" without following word\n  char_u      *mi_end2;                 // \"mi_end\" without following word\n} matchinf_T;\n\n// Structure used for the cookie argument of do_in_runtimepath().\ntypedef struct spelload_S {\n  char_u sl_lang[MAXWLEN + 1];          // language name\n  slang_T *sl_slang;                    // resulting slang_T struct\n  int sl_nobreak;                       // NOBREAK language found\n} spelload_T;\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S {\n  char_u sy_chars[SY_MAXLEN];               // the sequence of chars\n  int sy_len;\n} syl_item_T;\n\nspelltab_T spelltab;\nint did_set_spelltab;\n\n// structure used to store soundfolded words that add_sound_suggest() has\n// handled already.\ntypedef struct {\n  short sft_score;              // lowest score used\n  char_u sft_word[1];           // soundfolded word, actually longer\n} sftword_T;\n\ntypedef struct {\n  int badi;\n  int goodi;\n  int score;\n} limitscore_T;\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"spell.c.generated.h\"\n#endif\n\n// values for ts_isdiff\n#define DIFF_NONE       0       // no different byte (yet)\n#define DIFF_YES        1       // different byte found\n#define DIFF_INSERT     2       // inserting character\n\n// values for ts_flags\n#define TSF_PREFIXOK    1       // already checked that prefix is OK\n#define TSF_DIDSPLIT    2       // tried split at this point\n#define TSF_DIDDEL      4       // did a delete, \"ts_delidx\" has index\n\n// special values ts_prefixdepth\n#define PFD_NOPREFIX    0xff    // not using prefixes\n#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree\n#define PFD_NOTSPECIAL  0xfd    // highest value that's not special\n\n// mode values for find_word\n#define FIND_FOLDWORD       0   // find word case-folded\n#define FIND_KEEPWORD       1   // find keep-case word\n#define FIND_PREFIX         2   // find word after prefix\n#define FIND_COMPOUND       3   // find case-folded compound word\n#define FIND_KEEPCOMPOUND   4   // find keep-case compound word\n\nchar *e_format = N_(\"E759: Format error in spell file\");\n\n// Remember what \"z?\" replaced.\nstatic char_u *repl_from = NULL;\nstatic char_u *repl_to = NULL;\n\n// Main spell-checking function.\n// \"ptr\" points to a character that could be the start of a word.\n// \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n// non-word or when it's OK it remains unchanged.\n// This must only be called when 'spelllang' is not empty.\n//\n// \"capcol\" is used to check for a Capitalised word after the end of a\n// sentence.  If it's zero then perform the check.  Return the column where to\n// check next, or -1 when no sentence end was found.  If it's NULL then don't\n// worry.\n//\n// Returns the length of the word in bytes, also when it's OK, so that the\n// caller can skip over the word.\nsize_t spell_check(\n    win_T *wp,                // current window\n    char_u *ptr,\n    hlf_T *attrp,\n    int *capcol,              // column to check for Capital\n    bool docount              // count good words\n)\n{\n  matchinf_T mi;              // Most things are put in \"mi\" so that it can\n                              // be passed to functions quickly.\n  size_t nrlen = 0;              // found a number first\n  int c;\n  size_t wrongcaplen = 0;\n  int lpi;\n  bool count_word = docount;\n  bool use_camel_case = *wp->w_s->b_p_spo != NUL;\n  bool camel_case = false;\n\n  // A word never starts at a space or a control character. Return quickly\n  // then, skipping over the character.\n  if (*ptr <= ' ') {\n    return 1;\n  }\n\n  // Return here when loading language files failed.\n  if (GA_EMPTY(&wp->w_s->b_langp)) {\n    return 1;\n  }\n\n  memset(&mi, 0, sizeof(matchinf_T));\n\n  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n  // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n  // julifeest\".\n  if (*ptr >= '0' && *ptr <= '9') {\n    if (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B')) {\n      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);\n    } else if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {\n      mi.mi_end = skiphex(ptr + 2);\n    } else {\n      mi.mi_end = skipdigits(ptr);\n    }\n    nrlen = (size_t)(mi.mi_end - ptr);\n  }\n\n  // Find the normal end of the word (until the next non-word character).\n  mi.mi_word = ptr;\n  mi.mi_fend = ptr;\n  if (spell_iswordp(mi.mi_fend, wp)) {\n    bool this_upper = false;  // init for gcc\n\n    if (use_camel_case) {\n      c = PTR2CHAR(mi.mi_fend);\n      this_upper = SPELL_ISUPPER(c);\n    }\n\n    do {\n      MB_PTR_ADV(mi.mi_fend);\n      if (use_camel_case) {\n        const bool prev_upper = this_upper;\n        c = PTR2CHAR(mi.mi_fend);\n        this_upper = SPELL_ISUPPER(c);\n        camel_case = !prev_upper && this_upper;\n      }\n    } while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n             && !camel_case);\n\n    if (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL) {\n      // Check word starting with capital letter.\n      c = PTR2CHAR(ptr);\n      if (!SPELL_ISUPPER(c)) {\n        wrongcaplen = (size_t)(mi.mi_fend - ptr);\n      }\n    }\n  }\n  if (capcol != NULL) {\n    *capcol = -1;\n  }\n\n  // We always use the characters up to the next non-word character,\n  // also for bad words.\n  mi.mi_end = mi.mi_fend;\n\n  // Check caps type later.\n  mi.mi_capflags = 0;\n  mi.mi_cend = NULL;\n  mi.mi_win = wp;\n\n  // case-fold the word with one non-word character, so that we can check\n  // for the word end.\n  if (*mi.mi_fend != NUL) {\n    MB_PTR_ADV(mi.mi_fend);\n  }\n\n  (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n                       MAXWLEN + 1);\n  mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n  if (camel_case) {\n    // introduce a fake word end space into the folded word.\n    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n  }\n\n  // The word is bad unless we recognize it.\n  mi.mi_result = SP_BAD;\n  mi.mi_result2 = SP_BAD;\n\n  // Loop over the languages specified in 'spelllang'.\n  // We check them all, because a word may be matched longer in another\n  // language.\n  for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi) {\n    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n    // If reloading fails the language is still in the list but everything\n    // has been cleared.\n    if (mi.mi_lp->lp_slang->sl_fidxs == NULL) {\n      continue;\n    }\n\n    // Check for a matching word in case-folded words.\n    find_word(&mi, FIND_FOLDWORD);\n\n    // Check for a matching word in keep-case words.\n    find_word(&mi, FIND_KEEPWORD);\n\n    // Check for matching prefixes.\n    find_prefix(&mi, FIND_FOLDWORD);\n\n    // For a NOBREAK language, may want to use a word without a following\n    // word as a backup.\n    if (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n        && mi.mi_result2 != SP_BAD) {\n      mi.mi_result = mi.mi_result2;\n      mi.mi_end = mi.mi_end2;\n    }\n\n    // Count the word in the first language where it's found to be OK.\n    if (count_word && mi.mi_result == SP_OK) {\n      count_common_word(mi.mi_lp->lp_slang, ptr,\n          (int)(mi.mi_end - ptr), 1);\n      count_word = false;\n    }\n  }\n\n  if (mi.mi_result != SP_OK) {\n    // If we found a number skip over it.  Allows for \"42nd\".  Do flag\n    // rare and local words, e.g., \"3GPP\".\n    if (nrlen > 0) {\n      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {\n        return nrlen;\n      }\n    } else if (!spell_iswordp_nmw(ptr, wp)) {\n    // When we are at a non-word character there is no error, just\n    // skip over the character (try looking for a word after it).\n      if (capcol != NULL && wp->w_s->b_cap_prog != NULL) {\n        regmatch_T regmatch;\n\n        // Check for end of sentence.\n        regmatch.regprog = wp->w_s->b_cap_prog;\n        regmatch.rm_ic = false;\n        int r = vim_regexec(&regmatch, ptr, 0);\n        wp->w_s->b_cap_prog = regmatch.regprog;\n        if (r) {\n          *capcol = (int)(regmatch.endp[0] - ptr);\n        }\n      }\n\n      return (size_t)(utfc_ptr2len(ptr));\n    } else if (mi.mi_end == ptr) {\n      // Always include at least one character.  Required for when there\n      // is a mixup in \"midword\".\n      MB_PTR_ADV(mi.mi_end);\n    } else if (mi.mi_result == SP_BAD\n               && LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak) {\n      char_u      *p, *fp;\n      int save_result = mi.mi_result;\n\n      // First language in 'spelllang' is NOBREAK.  Find first position\n      // at which any word would be valid.\n      mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n      if (mi.mi_lp->lp_slang->sl_fidxs != NULL) {\n        p = mi.mi_word;\n        fp = mi.mi_fword;\n        for (;;) {\n          MB_PTR_ADV(p);\n          MB_PTR_ADV(fp);\n          if (p >= mi.mi_end) {\n            break;\n          }\n          mi.mi_compoff = (int)(fp - mi.mi_fword);\n          find_word(&mi, FIND_COMPOUND);\n          if (mi.mi_result != SP_BAD) {\n            mi.mi_end = p;\n            break;\n          }\n        }\n        mi.mi_result = save_result;\n      }\n    }\n\n    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {\n      *attrp = HLF_SPB;\n    } else if (mi.mi_result == SP_RARE) {\n      *attrp = HLF_SPR;\n    } else {\n      *attrp = HLF_SPL;\n    }\n  }\n\n  if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {\n    // Report SpellCap only when the word isn't badly spelled.\n    *attrp = HLF_SPC;\n    return wrongcaplen;\n  }\n\n  return (size_t)(mi.mi_end - ptr);\n}\n\n// Check if the word at \"mip->mi_word\" is in the tree.\n// When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n// When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n// When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n// tree.\n//\n// For a match mip->mi_result is updated.\nstatic void find_word(matchinf_T *mip, int mode)\n{\n  int wlen = 0;\n  int flen;\n  char_u      *ptr;\n  slang_T     *slang = mip->mi_lp->lp_slang;\n  char_u      *byts;\n  idx_T       *idxs;\n\n  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {\n    // Check for word with matching case in keep-case tree.\n    ptr = mip->mi_word;\n    flen = 9999;                    // no case folding, always enough bytes\n    byts = slang->sl_kbyts;\n    idxs = slang->sl_kidxs;\n\n    if (mode == FIND_KEEPCOMPOUND)\n      // Skip over the previously found word(s).\n      wlen += mip->mi_compoff;\n  } else {\n    // Check for case-folded in case-folded tree.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;        // available case-folded bytes\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    if (mode == FIND_PREFIX) {\n      // Skip over the prefix.\n      wlen = mip->mi_prefixlen;\n      flen -= mip->mi_prefixlen;\n    } else if (mode == FIND_COMPOUND) {\n      // Skip over the previously found word(s).\n      wlen = mip->mi_compoff;\n      flen -= mip->mi_compoff;\n    }\n\n  }\n\n  if (byts == NULL)\n    return;                     // array is empty\n\n  idx_T arridx = 0;\n  int endlen[MAXWLEN];              // length at possible word endings\n  idx_T endidx[MAXWLEN];            // possible word endings\n  int endidxcnt = 0;\n  int len;\n  int c;\n\n  // Repeat advancing in the tree until:\n  // - there is a byte that doesn't match,\n  // - we reach the end of the tree,\n  // - or we reach the end of the line.\n  for (;; ) {\n    if (flen <= 0 && *mip->mi_fend != NUL)\n      flen = fold_more(mip);\n\n    len = byts[arridx++];\n\n    // If the first possible byte is a zero the word could end here.\n    // Remember this index, we first check for the longest word.\n    if (byts[arridx] == 0) {\n      if (endidxcnt == MAXWLEN) {\n        // Must be a corrupted spell file.\n        EMSG(_(e_format));\n        return;\n      }\n      endlen[endidxcnt] = wlen;\n      endidx[endidxcnt++] = arridx++;\n      --len;\n\n      // Skip over the zeros, there can be several flag/region\n      // combinations.\n      while (len > 0 && byts[arridx] == 0) {\n        ++arridx;\n        --len;\n      }\n      if (len == 0)\n        break;              // no children, word must end here\n    }\n\n    // Stop looking at end of the line.\n    if (ptr[wlen] == NUL)\n      break;\n\n    // Perform a binary search in the list of accepted bytes.\n    c = ptr[wlen];\n    if (c == TAB)           // <Tab> is handled like <Space>\n      c = ' ';\n    idx_T lo = arridx;\n    idx_T hi = arridx + len - 1;\n    while (lo < hi) {\n      idx_T m = (lo + hi) / 2;\n      if (byts[m] > c)\n        hi = m - 1;\n      else if (byts[m] < c)\n        lo = m + 1;\n      else {\n        lo = hi = m;\n        break;\n      }\n    }\n\n    // Stop if there is no matching byte.\n    if (hi < lo || byts[lo] != c)\n      break;\n\n    // Continue at the child (if there is one).\n    arridx = idxs[lo];\n    ++wlen;\n    --flen;\n\n    // One space in the good word may stand for several spaces in the\n    // checked word.\n    if (c == ' ') {\n      for (;; ) {\n        if (flen <= 0 && *mip->mi_fend != NUL)\n          flen = fold_more(mip);\n        if (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n          break;\n        ++wlen;\n        --flen;\n      }\n    }\n  }\n\n  char_u *p;\n  bool word_ends;\n\n  // Verify that one of the possible endings is valid.  Try the longest\n  // first.\n  while (endidxcnt > 0) {\n    --endidxcnt;\n    arridx = endidx[endidxcnt];\n    wlen = endlen[endidxcnt];\n\n    if (utf_head_off(ptr, ptr + wlen) > 0) {\n      continue;             // not at first byte of character\n    }\n    if (spell_iswordp(ptr + wlen, mip->mi_win)) {\n      if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n        continue;                   // next char is a word character\n      word_ends = false;\n    } else\n      word_ends = true;\n    // The prefix flag is before compound flags.  Once a valid prefix flag\n    // has been found we try compound flags.\n    bool prefix_found = false;\n\n    if (mode != FIND_KEEPWORD) {\n      // Compute byte length in original word, length may change\n      // when folding case.  This can be slow, take a shortcut when the\n      // case-folded word is equal to the keep-case word.\n      p = mip->mi_word;\n      if (STRNCMP(ptr, p, wlen) != 0) {\n        for (char_u *s = ptr; s < ptr + wlen; MB_PTR_ADV(s)) {\n          MB_PTR_ADV(p);\n        }\n        wlen = (int)(p - mip->mi_word);\n      }\n    }\n\n    // Check flags and region.  For FIND_PREFIX check the condition and\n    // prefix ID.\n    // Repeat this if there are more flags/region alternatives until there\n    // is a match.\n    for (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n         --len, ++arridx) {\n      uint32_t flags = idxs[arridx];\n\n      // For the fold-case tree check that the case of the checked word\n      // matches with what the word in the tree requires.\n      // For keep-case tree the case is always right.  For prefixes we\n      // don't bother to check.\n      if (mode == FIND_FOLDWORD) {\n        if (mip->mi_cend != mip->mi_word + wlen) {\n          // mi_capflags was set for a different word length, need\n          // to do it again.\n          mip->mi_cend = mip->mi_word + wlen;\n          mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n        }\n\n        if (mip->mi_capflags == WF_KEEPCAP\n            || !spell_valid_case(mip->mi_capflags, flags))\n          continue;\n      }\n      // When mode is FIND_PREFIX the word must support the prefix:\n      // check the prefix ID and the condition.  Do that for the list at\n      // mip->mi_prefarridx that find_prefix() filled.\n      else if (mode == FIND_PREFIX && !prefix_found) {\n        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n            flags,\n            mip->mi_word + mip->mi_cprefixlen, slang,\n            false);\n        if (c == 0)\n          continue;\n\n        // Use the WF_RARE flag for a rare prefix.\n        if (c & WF_RAREPFX)\n          flags |= WF_RARE;\n        prefix_found = true;\n      }\n\n      if (slang->sl_nobreak) {\n        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n            && (flags & WF_BANNED) == 0) {\n          // NOBREAK: found a valid following word.  That's all we\n          // need to know, so return.\n          mip->mi_result = SP_OK;\n          break;\n        }\n      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n                  || !word_ends)) {\n        // If there is no compound flag or the word is shorter than\n        // COMPOUNDMIN reject it quickly.\n        // Makes you wonder why someone puts a compound flag on a word\n        // that's too short...  Myspell compatibility requires this\n        // anyway.\n        if (((unsigned)flags >> 24) == 0\n            || wlen - mip->mi_compoff < slang->sl_compminlen)\n          continue;\n        // For multi-byte chars check character length against\n        // COMPOUNDMIN.\n        if (slang->sl_compminlen > 0\n            && mb_charlen_len(mip->mi_word + mip->mi_compoff,\n                              wlen - mip->mi_compoff) < slang->sl_compminlen) {\n          continue;\n        }\n\n        // Limit the number of compound words to COMPOUNDWORDMAX if no\n        // maximum for syllables is specified.\n        if (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n            > slang->sl_compmax\n            && slang->sl_compsylmax == MAXWLEN)\n          continue;\n\n        // Don't allow compounding on a side where an affix was added,\n        // unless COMPOUNDPERMITFLAG was used.\n        if (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n          continue;\n        if (!word_ends && (flags & WF_NOCOMPAFT))\n          continue;\n\n        // Quickly check if compounding is possible with this flag.\n        if (!byte_in_str(mip->mi_complen == 0\n                ? slang->sl_compstartflags\n                : slang->sl_compallflags,\n                ((unsigned)flags >> 24)))\n          continue;\n\n        // If there is a match with a CHECKCOMPOUNDPATTERN rule\n        // discard the compound word.\n        if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n          continue;\n\n        if (mode == FIND_COMPOUND) {\n          int capflags;\n\n          // Need to check the caps type of the appended compound\n          // word.\n          if (STRNCMP(ptr, mip->mi_word, mip->mi_compoff) != 0) {\n            // case folding may have changed the length\n            p = mip->mi_word;\n            for (char_u *s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s)) {\n              MB_PTR_ADV(p);\n            }\n          } else {\n            p = mip->mi_word + mip->mi_compoff;\n          }\n          capflags = captype(p, mip->mi_word + wlen);\n          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n                                         && (flags & WF_FIXCAP) != 0))\n            continue;\n\n          if (capflags != WF_ALLCAP) {\n            // When the character before the word is a word\n            // character we do not accept a Onecap word.  We do\n            // accept a no-caps word, even when the dictionary\n            // word specifies ONECAP.\n            MB_PTR_BACK(mip->mi_word, p);\n            if (spell_iswordp_nmw(p, mip->mi_win)\n                ? capflags == WF_ONECAP\n                : (flags & WF_ONECAP) != 0\n                && capflags != WF_ONECAP) {\n              continue;\n            }\n          }\n        }\n\n        // If the word ends the sequence of compound flags of the\n        // words must match with one of the COMPOUNDRULE items and\n        // the number of syllables must not be too large.\n        mip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n        mip->mi_compflags[mip->mi_complen + 1] = NUL;\n        if (word_ends) {\n          char_u fword[MAXWLEN] = { 0 };\n\n          if (slang->sl_compsylmax < MAXWLEN) {\n            // \"fword\" is only needed for checking syllables.\n            if (ptr == mip->mi_word) {\n              (void)spell_casefold(mip->mi_win, ptr, wlen, fword, MAXWLEN);\n            } else {\n              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);\n            }\n          }\n          if (!can_compound(slang, fword, mip->mi_compflags))\n            continue;\n        } else if (slang->sl_comprules != NULL\n                   && !match_compoundrule(slang, mip->mi_compflags))\n          // The compound flags collected so far do not match any\n          // COMPOUNDRULE, discard the compounded word.\n          continue;\n      }\n      // Check NEEDCOMPOUND: can't use word without compounding.\n      else if (flags & WF_NEEDCOMP)\n        continue;\n\n      int nobreak_result = SP_OK;\n\n      if (!word_ends) {\n        int save_result = mip->mi_result;\n        char_u  *save_end = mip->mi_end;\n        langp_T *save_lp = mip->mi_lp;\n\n        // Check that a valid word follows.  If there is one and we\n        // are compounding, it will set \"mi_result\", thus we are\n        // always finished here.  For NOBREAK we only check that a\n        // valid word follows.\n        // Recursive!\n        if (slang->sl_nobreak)\n          mip->mi_result = SP_BAD;\n\n        // Find following word in case-folded tree.\n        mip->mi_compoff = endlen[endidxcnt];\n        if (mode == FIND_KEEPWORD) {\n          // Compute byte length in case-folded word from \"wlen\":\n          // byte length in keep-case word.  Length may change when\n          // folding case.  This can be slow, take a shortcut when\n          // the case-folded word is equal to the keep-case word.\n          p = mip->mi_fword;\n          if (STRNCMP(ptr, p, wlen) != 0) {\n            for (char_u *s = ptr; s < ptr + wlen; MB_PTR_ADV(s)) {\n              MB_PTR_ADV(p);\n            }\n            mip->mi_compoff = (int)(p - mip->mi_fword);\n          }\n        }\n#if 0\n        c = mip->mi_compoff;\n#endif\n        ++mip->mi_complen;\n        if (flags & WF_COMPROOT)\n          ++mip->mi_compextra;\n\n        // For NOBREAK we need to try all NOBREAK languages, at least\n        // to find the \".add\" file(s).\n        for (int lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi) {\n          if (slang->sl_nobreak) {\n            mip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n            if (mip->mi_lp->lp_slang->sl_fidxs == NULL\n                || !mip->mi_lp->lp_slang->sl_nobreak)\n              continue;\n          }\n\n          find_word(mip, FIND_COMPOUND);\n\n          // When NOBREAK any word that matches is OK.  Otherwise we\n          // need to find the longest match, thus try with keep-case\n          // and prefix too.\n          if (!slang->sl_nobreak || mip->mi_result == SP_BAD) {\n            // Find following word in keep-case tree.\n            mip->mi_compoff = wlen;\n            find_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0       // Disabled, a prefix must not appear halfway through a compound\n            // word, unless the COMPOUNDPERMITFLAG is used, in which case it\n            // can't be a postponed prefix.\n            if (!slang->sl_nobreak || mip->mi_result == SP_BAD) {\n              // Check for following word with prefix.\n              mip->mi_compoff = c;\n              find_prefix(mip, FIND_COMPOUND);\n            }\n#endif\n          }\n\n          if (!slang->sl_nobreak)\n            break;\n        }\n        --mip->mi_complen;\n        if (flags & WF_COMPROOT)\n          --mip->mi_compextra;\n        mip->mi_lp = save_lp;\n\n        if (slang->sl_nobreak) {\n          nobreak_result = mip->mi_result;\n          mip->mi_result = save_result;\n          mip->mi_end = save_end;\n        } else {\n          if (mip->mi_result == SP_OK)\n            break;\n          continue;\n        }\n      }\n\n      int res = SP_BAD;\n      if (flags & WF_BANNED)\n        res = SP_BANNED;\n      else if (flags & WF_REGION) {\n        // Check region.\n        if ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n          res = SP_OK;\n        else\n          res = SP_LOCAL;\n      } else if (flags & WF_RARE)\n        res = SP_RARE;\n      else\n        res = SP_OK;\n\n      // Always use the longest match and the best result.  For NOBREAK\n      // we separately keep the longest match without a following good\n      // word as a fall-back.\n      if (nobreak_result == SP_BAD) {\n        if (mip->mi_result2 > res) {\n          mip->mi_result2 = res;\n          mip->mi_end2 = mip->mi_word + wlen;\n        } else if (mip->mi_result2 == res\n                   && mip->mi_end2 < mip->mi_word + wlen)\n          mip->mi_end2 = mip->mi_word + wlen;\n      } else if (mip->mi_result > res) {\n        mip->mi_result = res;\n        mip->mi_end = mip->mi_word + wlen;\n      } else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n        mip->mi_end = mip->mi_word + wlen;\n\n      if (mip->mi_result == SP_OK)\n        break;\n    }\n\n    if (mip->mi_result == SP_OK)\n      break;\n  }\n}\n\n// Returns true if there is a match between the word ptr[wlen] and\n// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n// word.\n// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n// end of ptr[wlen] and the second part matches after it.\nstatic bool\nmatch_checkcompoundpattern (\n    char_u *ptr,\n    int wlen,\n    garray_T *gap      // &sl_comppat\n)\n{\n  char_u      *p;\n  int len;\n\n  for (int i = 0; i + 1 < gap->ga_len; i += 2) {\n    p = ((char_u **)gap->ga_data)[i + 1];\n    if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0) {\n      // Second part matches at start of following compound word, now\n      // check if first part matches at end of previous word.\n      p = ((char_u **)gap->ga_data)[i];\n      len = (int)STRLEN(p);\n      if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n        return true;\n    }\n  }\n  return false;\n}\n\n// Returns true if \"flags\" is a valid sequence of compound flags and \"word\"\n// does not have too many syllables.\nstatic bool can_compound(slang_T *slang, const char_u *word,\n                         const char_u *flags)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u uflags[MAXWLEN * 2] = { 0 };\n\n  if (slang->sl_compprog == NULL) {\n    return false;\n  }\n  // Need to convert the single byte flags to utf8 characters.\n  char_u *p = uflags;\n  for (int i = 0; flags[i] != NUL; i++) {\n    p += utf_char2bytes(flags[i], p);\n  }\n  *p = NUL;\n  p = uflags;\n  if (!vim_regexec_prog(&slang->sl_compprog, false, p, 0)) {\n    return false;\n  }\n\n  // Count the number of syllables.  This may be slow, do it last.  If there\n  // are too many syllables AND the number of compound words is above\n  // COMPOUNDWORDMAX then compounding is not allowed.\n  if (slang->sl_compsylmax < MAXWLEN\n      && count_syllables(slang, word) > slang->sl_compsylmax)\n    return (int)STRLEN(flags) < slang->sl_compmax;\n  return true;\n}\n\n// Returns true when the sequence of flags in \"compflags\" plus \"flag\" can\n// possibly form a valid compounded word.  This also checks the COMPOUNDRULE\n// lines if they don't contain wildcards.\nstatic bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)\n{\n  // If the flag doesn't appear in sl_compstartflags or sl_compallflags\n  // then it can't possibly compound.\n  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit\n          ? slang->sl_compstartflags : slang->sl_compallflags, flag))\n    return false;\n\n  // If there are no wildcards, we can check if the flags collected so far\n  // possibly can form a match with COMPOUNDRULE patterns.  This only\n  // makes sense when we have two or more words.\n  if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit) {\n    compflags[sp->ts_complen] = flag;\n    compflags[sp->ts_complen + 1] = NUL;\n    bool v = match_compoundrule(slang, compflags + sp->ts_compsplit);\n    compflags[sp->ts_complen] = NUL;\n    return v;\n  }\n\n  return true;\n}\n\n// Returns true if the compound flags in compflags[] match the start of any\n// compound rule.  This is used to stop trying a compound if the flags\n// collected so far can't possibly match any compound rule.\n// Caller must check that slang->sl_comprules is not NULL.\nstatic bool match_compoundrule(slang_T *slang, char_u *compflags)\n{\n  char_u      *p;\n  int i;\n  int c;\n\n  // loop over all the COMPOUNDRULE entries\n  for (p = slang->sl_comprules; *p != NUL; ++p) {\n    // loop over the flags in the compound word we have made, match\n    // them against the current rule entry\n    for (i = 0;; ++i) {\n      c = compflags[i];\n      if (c == NUL)\n        // found a rule that matches for the flags we have so far\n        return true;\n      if (*p == '/' || *p == NUL)\n        break;          // end of rule, it's too short\n      if (*p == '[') {\n        bool match = false;\n\n        // compare against all the flags in []\n        ++p;\n        while (*p != ']' && *p != NUL)\n          if (*p++ == c)\n            match = true;\n        if (!match)\n          break;            // none matches\n      } else if (*p != c)\n        break;          // flag of word doesn't match flag in pattern\n      ++p;\n    }\n\n    // Skip to the next \"/\", where the next pattern starts.\n    p = vim_strchr(p, '/');\n    if (p == NULL)\n      break;\n  }\n\n  // Checked all the rules and none of them match the flags, so there\n  // can't possibly be a compound starting with these flags.\n  return false;\n}\n\n// Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n// ID in \"flags\" for the word \"word\".\n// The WF_RAREPFX flag is included in the return value for a rare prefix.\nstatic int\nvalid_word_prefix (\n    int totprefcnt,                 // nr of prefix IDs\n    int arridx,                     // idx in sl_pidxs[]\n    int flags,\n    char_u *word,\n    slang_T *slang,\n    bool cond_req                   // only use prefixes with a condition\n)\n{\n  int prefcnt;\n  int pidx;\n  int prefid;\n\n  prefid = (unsigned)flags >> 24;\n  for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt) {\n    pidx = slang->sl_pidxs[arridx + prefcnt];\n\n    // Check the prefix ID.\n    if (prefid != (pidx & 0xff))\n      continue;\n\n    // Check if the prefix doesn't combine and the word already has a\n    // suffix.\n    if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n      continue;\n\n    // Check the condition, if there is one.  The condition index is\n    // stored in the two bytes above the prefix ID byte.\n    regprog_T **rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n    if (*rp != NULL) {\n      if (!vim_regexec_prog(rp, false, word, 0)) {\n        continue;\n      }\n    } else if (cond_req)\n      continue;\n\n    // It's a match!  Return the WF_ flags.\n    return pidx;\n  }\n  return 0;\n}\n\n// Check if the word at \"mip->mi_word\" has a matching prefix.\n// If it does, then check the following word.\n//\n// If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n// prefix in a compound word.\n//\n// For a match mip->mi_result is updated.\nstatic void find_prefix(matchinf_T *mip, int mode)\n{\n  idx_T arridx = 0;\n  int len;\n  int wlen = 0;\n  int flen;\n  int c;\n  char_u      *ptr;\n  idx_T lo, hi, m;\n  slang_T     *slang = mip->mi_lp->lp_slang;\n  char_u      *byts;\n  idx_T       *idxs;\n\n  byts = slang->sl_pbyts;\n  if (byts == NULL)\n    return;                     // array is empty\n\n  // We use the case-folded word here, since prefixes are always\n  // case-folded.\n  ptr = mip->mi_fword;\n  flen = mip->mi_fwordlen;      // available case-folded bytes\n  if (mode == FIND_COMPOUND) {\n    // Skip over the previously found word(s).\n    ptr += mip->mi_compoff;\n    flen -= mip->mi_compoff;\n  }\n  idxs = slang->sl_pidxs;\n\n  // Repeat advancing in the tree until:\n  // - there is a byte that doesn't match,\n  // - we reach the end of the tree,\n  // - or we reach the end of the line.\n  for (;; ) {\n    if (flen == 0 && *mip->mi_fend != NUL)\n      flen = fold_more(mip);\n\n    len = byts[arridx++];\n\n    // If the first possible byte is a zero the prefix could end here.\n    // Check if the following word matches and supports the prefix.\n    if (byts[arridx] == 0) {\n      // There can be several prefixes with different conditions.  We\n      // try them all, since we don't know which one will give the\n      // longest match.  The word is the same each time, pass the list\n      // of possible prefixes to find_word().\n      mip->mi_prefarridx = arridx;\n      mip->mi_prefcnt = len;\n      while (len > 0 && byts[arridx] == 0) {\n        ++arridx;\n        --len;\n      }\n      mip->mi_prefcnt -= len;\n\n      // Find the word that comes after the prefix.\n      mip->mi_prefixlen = wlen;\n      if (mode == FIND_COMPOUND)\n        // Skip over the previously found word(s).\n        mip->mi_prefixlen += mip->mi_compoff;\n\n      // Case-folded length may differ from original length.\n      mip->mi_cprefixlen = nofold_len(mip->mi_fword, mip->mi_prefixlen,\n                                      mip->mi_word);\n      find_word(mip, FIND_PREFIX);\n\n\n      if (len == 0)\n        break;              // no children, word must end here\n    }\n\n    // Stop looking at end of the line.\n    if (ptr[wlen] == NUL)\n      break;\n\n    // Perform a binary search in the list of accepted bytes.\n    c = ptr[wlen];\n    lo = arridx;\n    hi = arridx + len - 1;\n    while (lo < hi) {\n      m = (lo + hi) / 2;\n      if (byts[m] > c)\n        hi = m - 1;\n      else if (byts[m] < c)\n        lo = m + 1;\n      else {\n        lo = hi = m;\n        break;\n      }\n    }\n\n    // Stop if there is no matching byte.\n    if (hi < lo || byts[lo] != c)\n      break;\n\n    // Continue at the child (if there is one).\n    arridx = idxs[lo];\n    ++wlen;\n    --flen;\n  }\n}\n\n// Need to fold at least one more character.  Do until next non-word character\n// for efficiency.  Include the non-word character too.\n// Return the length of the folded chars in bytes.\nstatic int fold_more(matchinf_T *mip)\n{\n  int flen;\n  char_u      *p;\n\n  p = mip->mi_fend;\n  do {\n    MB_PTR_ADV(mip->mi_fend);\n  } while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n  // Include the non-word character so that we can check for the word end.\n  if (*mip->mi_fend != NUL) {\n    MB_PTR_ADV(mip->mi_fend);\n  }\n\n  (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n                       mip->mi_fword + mip->mi_fwordlen,\n                       MAXWLEN - mip->mi_fwordlen);\n  flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n  mip->mi_fwordlen += flen;\n  return flen;\n}\n\n/// Checks case flags for a word. Returns true, if the word has the requested\n/// case.\n///\n/// @param wordflags Flags for the checked word.\n/// @param treeflags Flags for the word in the spell tree.\nstatic bool spell_valid_case(int wordflags, int treeflags)\n{\n  return (wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n         || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n             && ((treeflags & WF_ONECAP) == 0\n                 || (wordflags & WF_ONECAP) != 0));\n}\n\n// Returns true if spell checking is not enabled.\nstatic bool no_spell_checking(win_T *wp)\n{\n  if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL\n      || GA_EMPTY(&wp->w_s->b_langp)) {\n    EMSG(_(e_no_spell));\n    return true;\n  }\n  return false;\n}\n\n// Moves to the next spell error.\n// \"curline\" is false for \"[s\", \"]s\", \"[S\" and \"]S\".\n// \"curline\" is true to find word under/after cursor in the same line.\n// For Insert mode completion \"dir\" is BACKWARD and \"curline\" is true: move\n// to after badly spelled word before the cursor.\n// Return 0 if not found, length of the badly spelled word otherwise.\nsize_t\nspell_move_to (\n    win_T *wp,\n    int dir,                  // FORWARD or BACKWARD\n    bool allwords,            // true for \"[s\"/\"]s\", false for \"[S\"/\"]S\"\n    bool curline,\n    hlf_T *attrp              // return: attributes of bad word or NULL\n                              // (only when \"dir\" is FORWARD)\n)\n{\n  linenr_T lnum;\n  pos_T found_pos;\n  size_t found_len = 0;\n  char_u      *line;\n  char_u      *p;\n  char_u      *endp;\n  hlf_T attr = HLF_COUNT;\n  size_t len;\n  int has_syntax = syntax_present(wp);\n  int col;\n  bool can_spell;\n  char_u      *buf = NULL;\n  size_t buflen = 0;\n  int skip = 0;\n  int capcol = -1;\n  bool found_one = false;\n  bool wrapped = false;\n\n  if (no_spell_checking(wp))\n    return 0;\n\n  // Start looking for bad word at the start of the line, because we can't\n  // start halfway through a word, we don't know where it starts or ends.\n  //\n  // When searching backwards, we continue in the line to find the last\n  // bad word (in the cursor line: before the cursor).\n  //\n  // We concatenate the start of the next line, so that wrapped words work\n  // (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n  // though...\n  lnum = wp->w_cursor.lnum;\n  clearpos(&found_pos);\n\n  while (!got_int) {\n    line = ml_get_buf(wp->w_buffer, lnum, false);\n\n    len = STRLEN(line);\n    if (buflen < len + MAXWLEN + 2) {\n      xfree(buf);\n      buflen = len + MAXWLEN + 2;\n      buf = xmalloc(buflen);\n    }\n    assert(buf && buflen >= len + MAXWLEN + 2);\n\n    // In first line check first word for Capital.\n    if (lnum == 1)\n      capcol = 0;\n\n    // For checking first word with a capital skip white space.\n    if (capcol == 0) {\n      capcol = (int)getwhitecols(line);\n    } else if (curline && wp == curwin) {\n      // For spellbadword(): check if first word needs a capital.\n      col = (int)getwhitecols(line);\n      if (check_need_cap(lnum, col)) {\n        capcol = col;\n      }\n\n      // Need to get the line again, may have looked at the previous\n      // one.\n      line = ml_get_buf(wp->w_buffer, lnum, false);\n    }\n\n    // Copy the line into \"buf\" and append the start of the next line if\n    // possible.\n    STRCPY(buf, line);\n    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n      spell_cat_line(buf + STRLEN(buf),\n                     ml_get_buf(wp->w_buffer, lnum + 1, false),\n                     MAXWLEN);\n    p = buf + skip;\n    endp = buf + len;\n    while (p < endp) {\n      // When searching backward don't search after the cursor.  Unless\n      // we wrapped around the end of the buffer.\n      if (dir == BACKWARD\n          && lnum == wp->w_cursor.lnum\n          && !wrapped\n          && (colnr_T)(p - buf) >= wp->w_cursor.col)\n        break;\n\n      // start of word\n      attr = HLF_COUNT;\n      len = spell_check(wp, p, &attr, &capcol, false);\n\n      if (attr != HLF_COUNT) {\n        // We found a bad word.  Check the attribute.\n        if (allwords || attr == HLF_SPB) {\n          // When searching forward only accept a bad word after\n          // the cursor.\n          if (dir == BACKWARD\n              || lnum != wp->w_cursor.lnum\n              || wrapped\n              || ((colnr_T)(curline\n                            ? p - buf + (ptrdiff_t)len\n                            : p - buf) > wp->w_cursor.col)) {\n            if (has_syntax) {\n              col = (int)(p - buf);\n              (void)syn_get_id(wp, lnum, (colnr_T)col,\n                  FALSE, &can_spell, FALSE);\n              if (!can_spell)\n                attr = HLF_COUNT;\n            } else\n              can_spell = true;\n\n            if (can_spell) {\n              found_one = true;\n              found_pos.lnum = lnum;\n              found_pos.col = (int)(p - buf);\n              found_pos.coladd = 0;\n              if (dir == FORWARD) {\n                // No need to search further.\n                wp->w_cursor = found_pos;\n                xfree(buf);\n                if (attrp != NULL)\n                  *attrp = attr;\n                return len;\n              } else if (curline) {\n                // Insert mode completion: put cursor after\n                // the bad word.\n                assert(len <= INT_MAX);\n                found_pos.col += (int)len;\n              }\n              found_len = len;\n            }\n          } else\n            found_one = true;\n        }\n      }\n\n      // advance to character after the word\n      p += len;\n      assert(len <= INT_MAX);\n      capcol -= (int)len;\n    }\n\n    if (dir == BACKWARD && found_pos.lnum != 0) {\n      // Use the last match in the line (before the cursor).\n      wp->w_cursor = found_pos;\n      xfree(buf);\n      return found_len;\n    }\n\n    if (curline) {\n      break;            // only check cursor line\n    }\n\n    // If we are back at the starting line and searched it again there\n    // is no match, give up.\n    if (lnum == wp->w_cursor.lnum && wrapped) {\n      break;\n    }\n\n    // Advance to next line.\n    if (dir == BACKWARD) {\n      if (lnum > 1) {\n        lnum--;\n      } else if (!p_ws) {\n        break;              // at first line and 'nowrapscan'\n      } else {\n        // Wrap around to the end of the buffer.  May search the\n        // starting line again and accept the last match.\n        lnum = wp->w_buffer->b_ml.ml_line_count;\n        wrapped = true;\n        if (!shortmess(SHM_SEARCH))\n          give_warning((char_u *)_(top_bot_msg), true);\n      }\n      capcol = -1;\n    } else {\n      if (lnum < wp->w_buffer->b_ml.ml_line_count)\n        ++lnum;\n      else if (!p_ws)\n        break;              // at first line and 'nowrapscan'\n      else {\n        // Wrap around to the start of the buffer.  May search the\n        // starting line again and accept the first match.\n        lnum = 1;\n        wrapped = true;\n        if (!shortmess(SHM_SEARCH))\n          give_warning((char_u *)_(bot_top_msg), true);\n      }\n\n      // If we are back at the starting line and there is no match then\n      // give up.\n      if (lnum == wp->w_cursor.lnum && !found_one) {\n        break;\n      }\n\n      // Skip the characters at the start of the next line that were\n      // included in a match crossing line boundaries.\n      if (attr == HLF_COUNT)\n        skip = (int)(p - endp);\n      else\n        skip = 0;\n\n      // Capcol skips over the inserted space.\n      --capcol;\n\n      // But after empty line check first word in next line\n      if (*skipwhite(line) == NUL)\n        capcol = 0;\n    }\n\n    line_breakcheck();\n  }\n\n  xfree(buf);\n  return 0;\n}\n\n// For spell checking: concatenate the start of the following line \"line\" into\n// \"buf\", blanking-out special characters.  Copy less then \"maxlen\" bytes.\n// Keep the blanks at the start of the next line, this is used in win_line()\n// to skip those bytes if the word was OK.\nvoid spell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n  char_u      *p;\n  int n;\n\n  p = skipwhite(line);\n  while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n    p = skipwhite(p + 1);\n\n  if (*p != NUL) {\n    // Only worth concatenating if there is something else than spaces to\n    // concatenate.\n    n = (int)(p - line) + 1;\n    if (n < maxlen - 1) {\n      memset(buf, ' ', n);\n      STRLCPY(buf +  n, p, maxlen - n);\n    }\n  }\n}\n\n// Load word list(s) for \"lang\" from Vim spell file(s).\n// \"lang\" must be the language without the region: e.g., \"en\".\nstatic void spell_load_lang(char_u *lang)\n{\n  char_u fname_enc[85];\n  int r;\n  spelload_T sl;\n  int round;\n\n  // Copy the language name to pass it to spell_load_cb() as a cookie.\n  // It's truncated when an error is detected.\n  STRCPY(sl.sl_lang, lang);\n  sl.sl_slang = NULL;\n  sl.sl_nobreak = false;\n\n  // We may retry when no spell file is found for the language, an\n  // autocommand may load it then.\n  for (round = 1; round <= 2; ++round) {\n    // Find the first spell file for \"lang\" in 'runtimepath' and load it.\n    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n                 \"spell/%s.%s.spl\", lang, spell_enc());\n    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n    if (r == FAIL && *sl.sl_lang != NUL) {\n      // Try loading the ASCII version.\n      vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n                   \"spell/%s.ascii.spl\", lang);\n      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n      if (r == FAIL && *sl.sl_lang != NUL && round == 1\n          && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n              curbuf->b_fname, FALSE, curbuf))\n        continue;\n      break;\n    }\n    break;\n  }\n\n  if (r == FAIL) {\n    if (starting) {\n      // Prompt the user at VimEnter if spell files are missing. #3027\n      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.\n      char autocmd_buf[512] = { 0 };\n      snprintf(autocmd_buf, sizeof(autocmd_buf),\n               \"autocmd VimEnter * call spellfile#LoadFile('%s')|set spell\",\n               lang);\n      do_cmdline_cmd(autocmd_buf);\n    } else {\n      smsg(\n        _(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n        lang, spell_enc(), lang);\n    }\n  } else if (sl.sl_slang != NULL) {\n    // At least one file was loaded, now load ALL the additions.\n    STRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n  }\n}\n\n// Return the encoding used for spell checking: Use 'encoding', except that we\n// use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\nchar_u *spell_enc(void)\n{\n\n  if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n    return p_enc;\n  return (char_u *)\"latin1\";\n}\n\n// Get the name of the .spl file for the internal wordlist into\n// \"fname[MAXPATHL]\".\nstatic void int_wordlist_spl(char_u *fname)\n{\n  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n      int_wordlist, spell_enc());\n}\n\n// Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n// Caller must fill \"sl_next\".\nslang_T *slang_alloc(char_u *lang)\n  FUNC_ATTR_NONNULL_RET\n{\n  slang_T *lp = xcalloc(1, sizeof(slang_T));\n\n  if (lang != NULL)\n    lp->sl_name = vim_strsave(lang);\n  ga_init(&lp->sl_rep, sizeof(fromto_T), 10);\n  ga_init(&lp->sl_repsal, sizeof(fromto_T), 10);\n  lp->sl_compmax = MAXWLEN;\n  lp->sl_compsylmax = MAXWLEN;\n  hash_init(&lp->sl_wordcount);\n\n  return lp;\n}\n\n// Free the contents of an slang_T and the structure itself.\nvoid slang_free(slang_T *lp)\n{\n  xfree(lp->sl_name);\n  xfree(lp->sl_fname);\n  slang_clear(lp);\n  xfree(lp);\n}\n\n/// Frees a salitem_T\nstatic void free_salitem(salitem_T *smp) {\n  xfree(smp->sm_lead);\n  // Don't free sm_oneof and sm_rules, they point into sm_lead.\n  xfree(smp->sm_to);\n  xfree(smp->sm_lead_w);\n  xfree(smp->sm_oneof_w);\n  xfree(smp->sm_to_w);\n}\n\n/// Frees a fromto_T\nstatic void free_fromto(fromto_T *ftp) {\n  xfree(ftp->ft_from);\n  xfree(ftp->ft_to);\n}\n\n// Clear an slang_T so that the file can be reloaded.\nvoid slang_clear(slang_T *lp)\n{\n  garray_T    *gap;\n\n  XFREE_CLEAR(lp->sl_fbyts);\n  XFREE_CLEAR(lp->sl_kbyts);\n  XFREE_CLEAR(lp->sl_pbyts);\n\n  XFREE_CLEAR(lp->sl_fidxs);\n  XFREE_CLEAR(lp->sl_kidxs);\n  XFREE_CLEAR(lp->sl_pidxs);\n\n  GA_DEEP_CLEAR(&lp->sl_rep, fromto_T, free_fromto);\n  GA_DEEP_CLEAR(&lp->sl_repsal, fromto_T, free_fromto);\n\n  gap = &lp->sl_sal;\n  if (lp->sl_sofo) {\n    // \"ga_len\" is set to 1 without adding an item for latin1\n    GA_DEEP_CLEAR_PTR(gap);\n  } else {\n    // SAL items: free salitem_T items\n    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);\n  }\n\n  for (int i = 0; i < lp->sl_prefixcnt; ++i) {\n    vim_regfree(lp->sl_prefprog[i]);\n  }\n  lp->sl_prefixcnt = 0;\n  XFREE_CLEAR(lp->sl_prefprog);\n  XFREE_CLEAR(lp->sl_info);\n  XFREE_CLEAR(lp->sl_midword);\n\n  vim_regfree(lp->sl_compprog);\n  lp->sl_compprog = NULL;\n  XFREE_CLEAR(lp->sl_comprules);\n  XFREE_CLEAR(lp->sl_compstartflags);\n  XFREE_CLEAR(lp->sl_compallflags);\n\n  XFREE_CLEAR(lp->sl_syllable);\n  ga_clear(&lp->sl_syl_items);\n\n  ga_clear_strings(&lp->sl_comppat);\n\n  hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n  hash_init(&lp->sl_wordcount);\n\n  hash_clear_all(&lp->sl_map_hash, 0);\n\n  // Clear info from .sug file.\n  slang_clear_sug(lp);\n\n  lp->sl_compmax = MAXWLEN;\n  lp->sl_compminlen = 0;\n  lp->sl_compsylmax = MAXWLEN;\n  lp->sl_regions[0] = NUL;\n}\n\n// Clear the info from the .sug file in \"lp\".\nvoid slang_clear_sug(slang_T *lp)\n{\n  XFREE_CLEAR(lp->sl_sbyts);\n  XFREE_CLEAR(lp->sl_sidxs);\n  close_spellbuf(lp->sl_sugbuf);\n  lp->sl_sugbuf = NULL;\n  lp->sl_sugloaded = false;\n  lp->sl_sugtime = 0;\n}\n\n// Load one spell file and store the info into a slang_T.\n// Invoked through do_in_runtimepath().\nstatic void spell_load_cb(char_u *fname, void *cookie)\n{\n  spelload_T  *slp = (spelload_T *)cookie;\n  slang_T     *slang;\n\n  slang = spell_load_file(fname, slp->sl_lang, NULL, false);\n  if (slang != NULL) {\n    // When a previously loaded file has NOBREAK also use it for the\n    // \".add\" files.\n    if (slp->sl_nobreak && slang->sl_add)\n      slang->sl_nobreak = true;\n    else if (slang->sl_nobreak)\n      slp->sl_nobreak = true;\n\n    slp->sl_slang = slang;\n  }\n}\n\n/// Add a word to the hashtable of common words.\n/// If it's already there then the counter is increased.\n///\n/// @param[in]  lp\n/// @param[in]  word  added to common words hashtable\n/// @param[in]  len  length of word or -1 for NUL terminated\n/// @param[in]  count  1 to count once, 10 to init\nvoid count_common_word(slang_T *lp, char_u *word, int len, int count)\n{\n  hash_T hash;\n  hashitem_T  *hi;\n  wordcount_T *wc;\n  char_u buf[MAXWLEN];\n  char_u      *p;\n\n  if (len == -1) {\n    p = word;\n  } else if (len >= MAXWLEN) {\n    return;\n  } else {\n    STRLCPY(buf, word, len + 1);\n    p = buf;\n  }\n\n  hash = hash_hash(p);\n  const size_t p_len = STRLEN(p);\n  hi = hash_lookup(&lp->sl_wordcount, (const char *)p, p_len, hash);\n  if (HASHITEM_EMPTY(hi)) {\n    wc = xmalloc(sizeof(wordcount_T) + p_len);\n    memcpy(wc->wc_word, p, p_len + 1);\n    wc->wc_count = count;\n    hash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n  } else {\n    wc = HI2WC(hi);\n    if ((wc->wc_count += count) < (unsigned)count)      // check for overflow\n      wc->wc_count = MAXWORDCOUNT;\n  }\n}\n\n// Adjust the score of common words.\nstatic int\nscore_wordcount_adj (\n    slang_T *slang,\n    int score,\n    char_u *word,\n    bool split                  // word was split, less bonus\n)\n{\n  hashitem_T  *hi;\n  wordcount_T *wc;\n  int bonus;\n  int newscore;\n\n  hi = hash_find(&slang->sl_wordcount, word);\n  if (!HASHITEM_EMPTY(hi)) {\n    wc = HI2WC(hi);\n    if (wc->wc_count < SCORE_THRES2)\n      bonus = SCORE_COMMON1;\n    else if (wc->wc_count < SCORE_THRES3)\n      bonus = SCORE_COMMON2;\n    else\n      bonus = SCORE_COMMON3;\n    if (split)\n      newscore = score - bonus / 2;\n    else\n      newscore = score - bonus;\n    if (newscore < 0)\n      return 0;\n    return newscore;\n  }\n  return score;\n}\n\n// Returns true if byte \"n\" appears in \"str\".\n// Like strchr() but independent of locale.\nbool byte_in_str(char_u *str, int n)\n{\n  char_u      *p;\n\n  for (p = str; *p != NUL; ++p)\n    if (*p == n)\n      return true;\n  return false;\n}\n\n// Truncate \"slang->sl_syllable\" at the first slash and put the following items\n// in \"slang->sl_syl_items\".\nint init_syl_tab(slang_T *slang)\n{\n  char_u      *p;\n  char_u      *s;\n  int l;\n\n  ga_init(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n  p = vim_strchr(slang->sl_syllable, '/');\n  while (p != NULL) {\n    *p++ = NUL;\n    if (*p == NUL)          // trailing slash\n      break;\n    s = p;\n    p = vim_strchr(p, '/');\n    if (p == NULL)\n      l = (int)STRLEN(s);\n    else\n      l = (int)(p - s);\n    if (l >= SY_MAXLEN)\n      return SP_FORMERROR;\n\n    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &slang->sl_syl_items);\n    STRLCPY(syl->sy_chars, s, l + 1);\n    syl->sy_len = l;\n  }\n  return OK;\n}\n\n// Count the number of syllables in \"word\".\n// When \"word\" contains spaces the syllables after the last space are counted.\n// Returns zero if syllables are not defines.\nstatic int count_syllables(slang_T *slang, const char_u *word)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int cnt = 0;\n  bool skip = false;\n  int len;\n  syl_item_T  *syl;\n  int c;\n\n  if (slang->sl_syllable == NULL)\n    return 0;\n\n  for (const char_u *p = word; *p != NUL; p += len) {\n    // When running into a space reset counter.\n    if (*p == ' ') {\n      len = 1;\n      cnt = 0;\n      continue;\n    }\n\n    // Find longest match of syllable items.\n    len = 0;\n    for (int i = 0; i < slang->sl_syl_items.ga_len; ++i) {\n      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n      if (syl->sy_len > len\n          && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n        len = syl->sy_len;\n    }\n    if (len != 0) {     // found a match, count syllable\n      ++cnt;\n      skip = false;\n    } else {\n      // No recognized syllable item, at least a syllable char then?\n      c = utf_ptr2char(p);\n      len = (*mb_ptr2len)(p);\n      if (vim_strchr(slang->sl_syllable, c) == NULL)\n        skip = false;               // No, search for next syllable\n      else if (!skip) {\n        ++cnt;                      // Yes, count it\n        skip = true;                // don't count following syllable chars\n      }\n    }\n  }\n  return cnt;\n}\n\n// Parse 'spelllang' and set w_s->b_langp accordingly.\n// Returns NULL if it's OK, an error message otherwise.\nchar_u *did_set_spelllang(win_T *wp)\n{\n  garray_T ga;\n  char_u      *splp;\n  char_u      *region;\n  char_u region_cp[3];\n  bool filename;\n  int region_mask;\n  slang_T     *slang;\n  int c;\n  char_u lang[MAXWLEN + 1];\n  char_u spf_name[MAXPATHL];\n  int len;\n  char_u      *p;\n  int round;\n  char_u      *spf;\n  char_u      *use_region = NULL;\n  bool dont_use_region = false;\n  bool nobreak = false;\n  langp_T     *lp, *lp2;\n  static bool recursive = false;\n  char_u      *ret_msg = NULL;\n  char_u      *spl_copy;\n\n  bufref_T bufref;\n  set_bufref(&bufref, wp->w_buffer);\n\n  // We don't want to do this recursively.  May happen when a language is\n  // not available and the SpellFileMissing autocommand opens a new buffer\n  // in which 'spell' is set.\n  if (recursive)\n    return NULL;\n  recursive = true;\n\n  ga_init(&ga, sizeof(langp_T), 2);\n  clear_midword(wp);\n\n  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n  // it under our fingers.\n  spl_copy = vim_strsave(wp->w_s->b_p_spl);\n\n  wp->w_s->b_cjk = 0;\n\n  // Loop over comma separated language names.\n  for (splp = spl_copy; *splp != NUL; ) {\n    // Get one language name.\n    copy_option_part(&splp, lang, MAXWLEN, \",\");\n    region = NULL;\n    len = (int)STRLEN(lang);\n\n    if (!valid_spelllang(lang)) {\n      continue;\n    }\n\n    if (STRCMP(lang, \"cjk\") == 0) {\n      wp->w_s->b_cjk = 1;\n      continue;\n    }\n\n    // If the name ends in \".spl\" use it as the name of the spell file.\n    // If there is a region name let \"region\" point to it and remove it\n    // from the name.\n    if (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0) {\n      filename = true;\n\n      // Locate a region and remove it from the file name.\n      p = vim_strchr(path_tail(lang), '_');\n      if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n          && !ASCII_ISALPHA(p[3])) {\n        STRLCPY(region_cp, p + 1, 3);\n        memmove(p, p + 3, len - (p - lang) - 2);\n        region = region_cp;\n      } else\n        dont_use_region = true;\n\n      // Check if we loaded this language before.\n      for (slang = first_lang; slang != NULL; slang = slang->sl_next) {\n        if (path_full_compare(lang, slang->sl_fname, false, true)\n            == kEqualFiles) {\n          break;\n        }\n      }\n    } else {\n      filename = false;\n      if (len > 3 && lang[len - 3] == '_') {\n        region = lang + len - 2;\n        lang[len - 3] = NUL;\n      } else\n        dont_use_region = true;\n\n      // Check if we loaded this language before.\n      for (slang = first_lang; slang != NULL; slang = slang->sl_next)\n        if (STRICMP(lang, slang->sl_name) == 0)\n          break;\n    }\n\n    if (region != NULL) {\n      // If the region differs from what was used before then don't\n      // use it for 'spellfile'.\n      if (use_region != NULL && STRCMP(region, use_region) != 0)\n        dont_use_region = true;\n      use_region = region;\n    }\n\n    // If not found try loading the language now.\n    if (slang == NULL) {\n      if (filename)\n        (void)spell_load_file(lang, lang, NULL, false);\n      else {\n        spell_load_lang(lang);\n        // SpellFileMissing autocommands may do anything, including\n        // destroying the buffer we are using...\n        if (!bufref_valid(&bufref)) {\n          ret_msg =\n            (char_u *)N_(\"E797: SpellFileMissing autocommand deleted buffer\");\n          goto theend;\n        }\n      }\n    }\n\n    // Loop over the languages, there can be several files for \"lang\".\n    for (slang = first_lang; slang != NULL; slang = slang->sl_next) {\n      if (filename\n          ? path_full_compare(lang, slang->sl_fname, false, true) == kEqualFiles\n          : STRICMP(lang, slang->sl_name) == 0) {\n        region_mask = REGION_ALL;\n        if (!filename && region != NULL) {\n          // find region in sl_regions\n          c = find_region(slang->sl_regions, region);\n          if (c == REGION_ALL) {\n            if (slang->sl_add) {\n              if (*slang->sl_regions != NUL)\n                // This addition file is for other regions.\n                region_mask = 0;\n            } else\n              // This is probably an error.  Give a warning and\n              // accept the words anyway.\n              smsg(_(\"Warning: region %s not supported\"),\n                   region);\n          } else\n            region_mask = 1 << c;\n        }\n\n        if (region_mask != 0) {\n          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &ga);\n          p_->lp_slang = slang;\n          p_->lp_region = region_mask;\n\n          use_midword(slang, wp);\n          if (slang->sl_nobreak)\n            nobreak = true;\n        }\n      }\n    }\n  }\n\n  // round 0: load int_wordlist, if possible.\n  // round 1: load first name in 'spellfile'.\n  // round 2: load second name in 'spellfile.\n  // etc.\n  spf = curwin->w_s->b_p_spf;\n  for (round = 0; round == 0 || *spf != NUL; ++round) {\n    if (round == 0) {\n      // Internal wordlist, if there is one.\n      if (int_wordlist == NULL)\n        continue;\n      int_wordlist_spl(spf_name);\n    } else {\n      // One entry in 'spellfile'.\n      copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n      STRCAT(spf_name, \".spl\");\n\n      // If it was already found above then skip it.\n      for (c = 0; c < ga.ga_len; ++c) {\n        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n        if (p != NULL\n            && path_full_compare(spf_name, p, false, true) == kEqualFiles) {\n          break;\n        }\n      }\n      if (c < ga.ga_len)\n        continue;\n    }\n\n    // Check if it was loaded already.\n    for (slang = first_lang; slang != NULL; slang = slang->sl_next) {\n      if (path_full_compare(spf_name, slang->sl_fname, false, true)\n          == kEqualFiles) {\n        break;\n      }\n    }\n    if (slang == NULL) {\n      // Not loaded, try loading it now.  The language name includes the\n      // region name, the region is ignored otherwise.  for int_wordlist\n      // use an arbitrary name.\n      if (round == 0)\n        STRCPY(lang, \"internal wordlist\");\n      else {\n        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);\n        p = vim_strchr(lang, '.');\n        if (p != NULL)\n          *p = NUL;             // truncate at \".encoding.add\"\n      }\n      slang = spell_load_file(spf_name, lang, NULL, true);\n\n      // If one of the languages has NOBREAK we assume the addition\n      // files also have this.\n      if (slang != NULL && nobreak)\n        slang->sl_nobreak = true;\n    }\n    if (slang != NULL) {\n      region_mask = REGION_ALL;\n      if (use_region != NULL && !dont_use_region) {\n        // find region in sl_regions\n        c = find_region(slang->sl_regions, use_region);\n        if (c != REGION_ALL)\n          region_mask = 1 << c;\n        else if (*slang->sl_regions != NUL)\n          // This spell file is for other regions.\n          region_mask = 0;\n      }\n\n      if (region_mask != 0) {\n        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &ga);\n        p_->lp_slang = slang;\n        p_->lp_sallang = NULL;\n        p_->lp_replang = NULL;\n        p_->lp_region = region_mask;\n\n        use_midword(slang, wp);\n      }\n    }\n  }\n\n  // Everything is fine, store the new b_langp value.\n  ga_clear(&wp->w_s->b_langp);\n  wp->w_s->b_langp = ga;\n\n  // For each language figure out what language to use for sound folding and\n  // REP items.  If the language doesn't support it itself use another one\n  // with the same name.  E.g. for \"en-math\" use \"en\".\n  for (int i = 0; i < ga.ga_len; ++i) {\n    lp = LANGP_ENTRY(ga, i);\n\n    // sound folding\n    if (!GA_EMPTY(&lp->lp_slang->sl_sal))\n      // language does sound folding itself\n      lp->lp_sallang = lp->lp_slang;\n    else\n      // find first similar language that does sound folding\n      for (int j = 0; j < ga.ga_len; ++j) {\n        lp2 = LANGP_ENTRY(ga, j);\n        if (!GA_EMPTY(&lp2->lp_slang->sl_sal)\n            && STRNCMP(lp->lp_slang->sl_name,\n                lp2->lp_slang->sl_name, 2) == 0) {\n          lp->lp_sallang = lp2->lp_slang;\n          break;\n        }\n      }\n\n    // REP items\n    if (!GA_EMPTY(&lp->lp_slang->sl_rep))\n      // language has REP items itself\n      lp->lp_replang = lp->lp_slang;\n    else\n      // find first similar language that has REP items\n      for (int j = 0; j < ga.ga_len; ++j) {\n        lp2 = LANGP_ENTRY(ga, j);\n        if (!GA_EMPTY(&lp2->lp_slang->sl_rep)\n            && STRNCMP(lp->lp_slang->sl_name,\n                lp2->lp_slang->sl_name, 2) == 0) {\n          lp->lp_replang = lp2->lp_slang;\n          break;\n        }\n      }\n  }\n\ntheend:\n  xfree(spl_copy);\n  recursive = false;\n  redraw_later(wp, NOT_VALID);\n  return ret_msg;\n}\n\n// Clear the midword characters for buffer \"buf\".\nstatic void clear_midword(win_T *wp)\n{\n  memset(wp->w_s->b_spell_ismw, 0, 256);\n  XFREE_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n// Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n// They add up to any currently used midword characters.\nstatic void use_midword(slang_T *lp, win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (lp->sl_midword == NULL) {  // there aren't any\n    return;\n  }\n\n  for (char_u *p = lp->sl_midword; *p != NUL; ) {\n    const int c = utf_ptr2char(p);\n    const int l = utfc_ptr2len(p);\n    if (c < 256 && l <= 2) {\n      wp->w_s->b_spell_ismw[c] = true;\n    } else if (wp->w_s->b_spell_ismw_mb == NULL) {\n      // First multi-byte char in \"b_spell_ismw_mb\".\n      wp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n    } else {\n      // Append multi-byte chars to \"b_spell_ismw_mb\".\n      const int n = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n      char_u *bp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n      xfree(wp->w_s->b_spell_ismw_mb);\n      wp->w_s->b_spell_ismw_mb = bp;\n      STRLCPY(bp + n, p, l + 1);\n    }\n    p += l;\n  }\n}\n\n// Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n// Each region is simply stored as the two characters of its name.\n// Returns the index if found (first is 0), REGION_ALL if not found.\nstatic int find_region(char_u *rp, char_u *region)\n{\n  int i;\n\n  for (i = 0;; i += 2) {\n    if (rp[i] == NUL)\n      return REGION_ALL;\n    if (rp[i] == region[0] && rp[i + 1] == region[1])\n      break;\n  }\n  return i / 2;\n}\n\n/// Return case type of word:\n/// w word       0\n/// Word         WF_ONECAP\n/// W WORD       WF_ALLCAP\n/// WoRd wOrd    WF_KEEPCAP\n///\n/// @param[in]  word\n/// @param[in]  end  End of word or NULL for NUL delimited string\n///\n/// @returns  Case type of word\nint captype(char_u *word, char_u *end)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  char_u      *p;\n  int firstcap;\n  bool allcap;\n  bool past_second = false;              // past second word char\n\n  // find first letter\n  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {\n    if (end == NULL ? *p == NUL : p >= end) {\n      return 0;             // only non-word characters, illegal word\n    }\n  }\n  int c = mb_ptr2char_adv((const char_u **)&p);\n  firstcap = allcap = SPELL_ISUPPER(c);\n\n  // Need to check all letters to find a word with mixed upper/lower.\n  // But a word with an upper char only at start is a ONECAP.\n  for (; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p)) {\n    if (spell_iswordp_nmw(p, curwin)) {\n      c = PTR2CHAR(p);\n      if (!SPELL_ISUPPER(c)) {\n        // UUl -> KEEPCAP\n        if (past_second && allcap) {\n          return WF_KEEPCAP;\n        }\n        allcap = false;\n      } else if (!allcap) {\n        // UlU -> KEEPCAP\n        return WF_KEEPCAP;\n      }\n      past_second = true;\n    }\n  }\n\n  if (allcap)\n    return WF_ALLCAP;\n  if (firstcap)\n    return WF_ONECAP;\n  return 0;\n}\n\n// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a\n// capital.  So that make_case_word() can turn WOrd into Word.\n// Add ALLCAP for \"WOrD\".\nstatic int badword_captype(char_u *word, char_u *end)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int flags = captype(word, end);\n  int c;\n  int l, u;\n  bool first;\n  char_u      *p;\n\n  if (flags & WF_KEEPCAP) {\n    // Count the number of UPPER and lower case letters.\n    l = u = 0;\n    first = false;\n    for (p = word; p < end; MB_PTR_ADV(p)) {\n      c = PTR2CHAR(p);\n      if (SPELL_ISUPPER(c)) {\n        ++u;\n        if (p == word)\n          first = true;\n      } else\n        ++l;\n    }\n\n    // If there are more UPPER than lower case letters suggest an\n    // ALLCAP word.  Otherwise, if the first letter is UPPER then\n    // suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n    // require three upper case letters.\n    if (u > l && u > 2)\n      flags |= WF_ALLCAP;\n    else if (first)\n      flags |= WF_ONECAP;\n\n    if (u >= 2 && l >= 2)       // maCARONI maCAroni\n      flags |= WF_MIXCAP;\n  }\n  return flags;\n}\n\n// Delete the internal wordlist and its .spl file.\nvoid spell_delete_wordlist(void)\n{\n  char_u fname[MAXPATHL] = {0};\n\n  if (int_wordlist != NULL) {\n    os_remove((char *)int_wordlist);\n    int_wordlist_spl(fname);\n    os_remove((char *)fname);\n    XFREE_CLEAR(int_wordlist);\n  }\n}\n\n// Free all languages.\nvoid spell_free_all(void)\n{\n  slang_T     *slang;\n\n  // Go through all buffers and handle 'spelllang'. <VN>\n  FOR_ALL_BUFFERS(buf) {\n    ga_clear(&buf->b_s.b_langp);\n  }\n\n  while (first_lang != NULL) {\n    slang = first_lang;\n    first_lang = slang->sl_next;\n    slang_free(slang);\n  }\n\n  spell_delete_wordlist();\n\n  XFREE_CLEAR(repl_to);\n  XFREE_CLEAR(repl_from);\n}\n\n// Clear all spelling tables and reload them.\n// Used after 'encoding' is set and when \":mkspell\" was used.\nvoid spell_reload(void)\n{\n  // Initialize the table for spell_iswordp().\n  init_spell_chartab();\n\n  // Unload all allocated memory.\n  spell_free_all();\n\n  // Go through all buffers and handle 'spelllang'.\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    // Only load the wordlists when 'spelllang' is set and there is a\n    // window for this buffer in which 'spell' is set.\n    if (*wp->w_s->b_p_spl != NUL) {\n      if (wp->w_p_spell) {\n        (void)did_set_spelllang(wp);\n        break;\n      }\n    }\n  }\n}\n\n\n// Opposite of offset2bytes().\n// \"pp\" points to the bytes and is advanced over it.\n// Returns the offset.\nstatic int bytes2offset(char_u **pp)\n{\n  char_u *p = *pp;\n  int nr;\n  int c;\n\n  c = *p++;\n  if ((c & 0x80) == 0x00) {             // 1 byte\n    nr = c - 1;\n  } else if ((c & 0xc0) == 0x80)   {    // 2 bytes\n    nr = (c & 0x3f) - 1;\n    nr = nr * 255 + (*p++ - 1);\n  } else if ((c & 0xe0) == 0xc0)   {    // 3 bytes\n    nr = (c & 0x1f) - 1;\n    nr = nr * 255 + (*p++ - 1);\n    nr = nr * 255 + (*p++ - 1);\n  } else {                              // 4 bytes\n    nr = (c & 0x0f) - 1;\n    nr = nr * 255 + (*p++ - 1);\n    nr = nr * 255 + (*p++ - 1);\n    nr = nr * 255 + (*p++ - 1);\n  }\n\n  *pp = p;\n  return nr;\n}\n\n// Open a spell buffer.  This is a nameless buffer that is not in the buffer\n// list and only contains text lines.  Can use a swapfile to reduce memory\n// use.\n// Most other fields are invalid!  Esp. watch out for string options being\n// NULL and there is no undo info.\nbuf_T *open_spellbuf(void)\n{\n  buf_T *buf = xcalloc(1, sizeof(buf_T));\n\n  buf->b_spell = true;\n  buf->b_p_swf = true;        // may create a swap file\n  if (ml_open(buf) == FAIL) {\n    ELOG(\"Error opening a new memline\");\n  }\n  ml_open_file(buf);          // create swap file now\n\n  return buf;\n}\n\n// Close the buffer used for spell info.\nvoid close_spellbuf(buf_T *buf)\n{\n  if (buf != NULL) {\n    ml_close(buf, TRUE);\n    xfree(buf);\n  }\n}\n\n// Init the chartab used for spelling for ASCII.\nvoid clear_spell_chartab(spelltab_T *sp)\n{\n  int i;\n\n  // Init everything to false.\n  memset(sp->st_isw, false, sizeof(sp->st_isw));\n  memset(sp->st_isu, false, sizeof(sp->st_isu));\n\n  for (i = 0; i < 256; ++i) {\n    sp->st_fold[i] = i;\n    sp->st_upper[i] = i;\n  }\n\n  // We include digits. A word shouldn't start with a digit, but handling\n  // that is done separately.\n  for (i = '0'; i <= '9'; ++i)\n    sp->st_isw[i] = true;\n  for (i = 'A'; i <= 'Z'; ++i) {\n    sp->st_isw[i] = true;\n    sp->st_isu[i] = true;\n    sp->st_fold[i] = i + 0x20;\n  }\n  for (i = 'a'; i <= 'z'; ++i) {\n    sp->st_isw[i] = true;\n    sp->st_upper[i] = i - 0x20;\n  }\n}\n\n// Init the chartab used for spelling. Called once while starting up.\n// The default is to use isalpha(), but the spell file should define the word\n// characters to make it possible that 'encoding' differs from the current\n// locale.  For utf-8 we don't use isalpha() but our own functions.\nvoid init_spell_chartab(void)\n{\n  int i;\n\n  did_set_spelltab = false;\n  clear_spell_chartab(&spelltab);\n  for (i = 128; i < 256; i++) {\n    int f = utf_fold(i);\n    int u = mb_toupper(i);\n\n    spelltab.st_isu[i] = mb_isupper(i);\n    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);\n    // The folded/upper-cased value is different between latin1 and\n    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n    // value for utf-8 to avoid this.\n    spelltab.st_fold[i] = (f < 256) ? f : i;\n    spelltab.st_upper[i] = (u < 256) ? u : i;\n  }\n}\n\n/// Returns true if \"p\" points to a word character.\n/// As a special case we see \"midword\" characters as word character when it is\n/// followed by a word character.  This finds they'there but not 'they there'.\n/// Thus this only works properly when past the first character of the word.\n///\n/// @param wp Buffer used.\nstatic bool spell_iswordp(const char_u *p, const win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int c;\n\n  const int l = utfc_ptr2len(p);\n  const char_u *s = p;\n  if (l == 1) {\n    // be quick for ASCII\n    if (wp->w_s->b_spell_ismw[*p]) {\n      s = p + 1;                      // skip a mid-word character\n    }\n  } else {\n    c = utf_ptr2char(p);\n    if (c < 256\n        ? wp->w_s->b_spell_ismw[c]\n        : (wp->w_s->b_spell_ismw_mb != NULL\n           && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL)) {\n      s = p + l;\n    }\n  }\n\n  c = utf_ptr2char(s);\n  if (c > 255) {\n    return spell_mb_isword_class(mb_get_class(s), wp);\n  }\n  return spelltab.st_isw[c];\n}\n\n// Returns true if \"p\" points to a word character.\n// Unlike spell_iswordp() this doesn't check for \"midword\" characters.\nbool spell_iswordp_nmw(const char_u *p, win_T *wp)\n{\n  int c = utf_ptr2char(p);\n  if (c > 255) {\n    return spell_mb_isword_class(mb_get_class(p), wp);\n  }\n  return spelltab.st_isw[c];\n}\n\n// Returns true if word class indicates a word character.\n// Only for characters above 255.\n// Unicode subscript and superscript are not considered word characters.\n// See also utf_class() in mbyte.c.\nstatic bool spell_mb_isword_class(int cl, const win_T *wp)\n  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (wp->w_s->b_cjk)\n    // East Asian characters are not considered word characters.\n    return cl == 2 || cl == 0x2800;\n  return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n// Returns true if \"p\" points to a word character.\n// Wide version of spell_iswordp().\nstatic bool spell_iswordp_w(const int *p, const win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const int *s;\n\n  if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n      : (wp->w_s->b_spell_ismw_mb != NULL\n         && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n    s = p + 1;\n  else\n    s = p;\n\n  if (*s > 255) {\n    return spell_mb_isword_class(utf_class(*s), wp);\n  }\n  return spelltab.st_isw[*s];\n}\n\n// Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n// Uses the character definitions from the .spl file.\n// When using a multi-byte 'encoding' the length may change!\n// Returns FAIL when something wrong.\nint spell_casefold(const win_T *wp, char_u *str, int len, char_u *buf,\n                   int buflen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (len >= buflen) {\n    buf[0] = NUL;\n    return FAIL;                // result will not fit\n  }\n\n  int outi = 0;\n\n  // Fold one character at a time.\n  for (char_u *p = str; p < str + len; ) {\n    if (outi + MB_MAXBYTES > buflen) {\n      buf[outi] = NUL;\n      return FAIL;\n    }\n    int c = mb_cptr2char_adv((const char_u **)&p);\n\n    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n    // when it is the last character in a word, then it folds to\n    // 0x03C2.\n    if (c == 0x03a3 || c == 0x03c2) {\n      if (p == str + len || !spell_iswordp(p, wp)) {\n        c = 0x03c2;\n      } else {\n        c = 0x03c3;\n      }\n    } else {\n      c = SPELL_TOFOLD(c);\n    }\n\n    outi += utf_char2bytes(c, buf + outi);\n  }\n  buf[outi] = NUL;\n\n  return OK;\n}\n\n// values for sps_flags\n#define SPS_BEST    1\n#define SPS_FAST    2\n#define SPS_DOUBLE  4\n\nstatic int sps_flags = SPS_BEST;        // flags from 'spellsuggest'\nstatic int sps_limit = 9999;            // max nr of suggestions given\n\n// Check the 'spellsuggest' option.  Return FAIL if it's wrong.\n// Sets \"sps_flags\" and \"sps_limit\".\nint spell_check_sps(void)\n{\n  char_u      *p;\n  char_u      *s;\n  char_u buf[MAXPATHL];\n  int f;\n\n  sps_flags = 0;\n  sps_limit = 9999;\n\n  for (p = p_sps; *p != NUL; ) {\n    copy_option_part(&p, buf, MAXPATHL, \",\");\n\n    f = 0;\n    if (ascii_isdigit(*buf)) {\n      s = buf;\n      sps_limit = getdigits_int(&s, true, 0);\n      if (*s != NUL && !ascii_isdigit(*s)) {\n        f = -1;\n      }\n    } else if (STRCMP(buf, \"best\") == 0) {\n      f = SPS_BEST;\n    } else if (STRCMP(buf, \"fast\") == 0) {\n      f = SPS_FAST;\n    } else if (STRCMP(buf, \"double\") == 0) {\n      f = SPS_DOUBLE;\n    } else if (STRNCMP(buf, \"expr:\", 5) != 0\n               && STRNCMP(buf, \"file:\", 5) != 0) {\n      f = -1;\n    }\n\n    if (f == -1 || (sps_flags != 0 && f != 0)) {\n      sps_flags = SPS_BEST;\n      sps_limit = 9999;\n      return FAIL;\n    }\n    if (f != 0)\n      sps_flags = f;\n  }\n\n  if (sps_flags == 0)\n    sps_flags = SPS_BEST;\n\n  return OK;\n}\n\n// \"z=\": Find badly spelled word under or after the cursor.\n// Give suggestions for the properly spelled word.\n// In Visual mode use the highlighted word as the bad word.\n// When \"count\" is non-zero use that suggestion.\nvoid spell_suggest(int count)\n{\n  char_u      *line;\n  pos_T prev_cursor = curwin->w_cursor;\n  char_u wcopy[MAXWLEN + 2];\n  char_u      *p;\n  int c;\n  suginfo_T sug;\n  suggest_T   *stp;\n  int mouse_used;\n  int need_cap;\n  int limit;\n  int selected = count;\n  int badlen = 0;\n  int msg_scroll_save = msg_scroll;\n  const int wo_spell_save = curwin->w_p_spell;\n\n  if (!curwin->w_p_spell) {\n    did_set_spelllang(curwin);\n    curwin->w_p_spell = true;\n  }\n\n  if (*curwin->w_s->b_p_spl == NUL) {\n    EMSG(_(e_no_spell));\n    return;\n  }\n\n  if (VIsual_active) {\n    // Use the Visually selected text as the bad word.  But reject\n    // a multi-line selection.\n    if (curwin->w_cursor.lnum != VIsual.lnum) {\n      vim_beep(BO_SPELL);\n      return;\n    }\n    badlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n    if (badlen < 0) {\n      badlen = -badlen;\n    } else {\n      curwin->w_cursor.col = VIsual.col;\n    }\n    badlen++;\n    end_visual_mode();\n  } else\n  // Find the start of the badly spelled word.\n  if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0\n      || curwin->w_cursor.col > prev_cursor.col) {\n    // No bad word or it starts after the cursor: use the word under the\n    // cursor.\n    curwin->w_cursor = prev_cursor;\n    line = get_cursor_line_ptr();\n    p = line + curwin->w_cursor.col;\n    // Backup to before start of word.\n    while (p > line && spell_iswordp_nmw(p, curwin)) {\n      MB_PTR_BACK(line, p);\n    }\n    // Forward to start of word.\n    while (*p != NUL && !spell_iswordp_nmw(p, curwin)) {\n      MB_PTR_ADV(p);\n    }\n\n    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.\n      beep_flush();\n      return;\n    }\n    curwin->w_cursor.col = (colnr_T)(p - line);\n  }\n\n  // Get the word and its length.\n\n  // Figure out if the word should be capitalised.\n  need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n  // Make a copy of current line since autocommands may free the line.\n  line = vim_strsave(get_cursor_line_ptr());\n\n  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n  // 'spellsuggest', whatever is smaller.\n  if (sps_limit > (int)Rows - 2)\n    limit = (int)Rows - 2;\n  else\n    limit = sps_limit;\n  spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n      true, need_cap, true);\n\n  if (GA_EMPTY(&sug.su_ga))\n    MSG(_(\"Sorry, no suggestions\"));\n  else if (count > 0) {\n    if (count > sug.su_ga.ga_len)\n      smsg(_(\"Sorry, only %\" PRId64 \" suggestions\"),\n           (int64_t)sug.su_ga.ga_len);\n  } else {\n    // When 'rightleft' is set the list is drawn right-left.\n    cmdmsg_rl = curwin->w_p_rl;\n    if (cmdmsg_rl)\n      msg_col = Columns - 1;\n\n    // List the suggestions.\n    msg_start();\n    msg_row = Rows - 1;         // for when 'cmdheight' > 1\n    lines_left = Rows;          // avoid more prompt\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n        sug.su_badlen, sug.su_badptr);\n    if (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0) {\n      // And now the rabbit from the high hat: Avoid showing the\n      // untranslated message rightleft.\n      vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n          sug.su_badlen, sug.su_badptr);\n    }\n    msg_puts((const char *)IObuff);\n    msg_clr_eos();\n    msg_putchar('\\n');\n\n    msg_scroll = TRUE;\n    for (int i = 0; i < sug.su_ga.ga_len; ++i) {\n      stp = &SUG(sug.su_ga, i);\n\n      // The suggested word may replace only part of the bad word, add\n      // the not replaced part.\n      STRLCPY(wcopy, stp->st_word, MAXWLEN + 1);\n      if (sug.su_badlen > stp->st_orglen)\n        STRLCPY(wcopy + stp->st_wordlen,\n            sug.su_badptr + stp->st_orglen,\n            sug.su_badlen - stp->st_orglen + 1);\n      vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n      if (cmdmsg_rl) {\n        rl_mirror(IObuff);\n      }\n      msg_puts((const char *)IObuff);\n\n      vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n      msg_puts((const char *)IObuff);\n\n      // The word may replace more than \"su_badlen\".\n      if (sug.su_badlen < stp->st_orglen) {\n        vim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n                     stp->st_orglen, sug.su_badptr);\n        msg_puts((const char *)IObuff);\n      }\n\n      if (p_verbose > 0) {\n        // Add the score.\n        if (sps_flags & (SPS_DOUBLE | SPS_BEST))\n          vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n              stp->st_salscore ? \"s \" : \"\",\n              stp->st_score, stp->st_altscore);\n        else\n          vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n              stp->st_score);\n        if (cmdmsg_rl)\n          // Mirror the numbers, but keep the leading space.\n          rl_mirror(IObuff + 1);\n        msg_advance(30);\n        msg_puts((const char *)IObuff);\n      }\n      msg_putchar('\\n');\n    }\n\n    cmdmsg_rl = FALSE;\n    msg_col = 0;\n    // Ask for choice.\n    selected = prompt_for_number(&mouse_used);\n\n    if (ui_has(kUIMessages)) {\n      ui_call_msg_clear();\n    }\n\n    if (mouse_used) {\n      selected -= lines_left;\n    }\n    lines_left = Rows;                  // avoid more prompt\n    // don't delay for 'smd' in normal_cmd()\n    msg_scroll = msg_scroll_save;\n  }\n\n  if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK) {\n    // Save the from and to text for :spellrepall.\n    XFREE_CLEAR(repl_from);\n    XFREE_CLEAR(repl_to);\n\n    stp = &SUG(sug.su_ga, selected - 1);\n    if (sug.su_badlen > stp->st_orglen) {\n      // Replacing less than \"su_badlen\", append the remainder to\n      // repl_to.\n      repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n      vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n          sug.su_badlen - stp->st_orglen,\n          sug.su_badptr + stp->st_orglen);\n      repl_to = vim_strsave(IObuff);\n    } else {\n      // Replacing su_badlen or more, use the whole word.\n      repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n      repl_to = vim_strsave(stp->st_word);\n    }\n\n    // Replace the word.\n    p = xmalloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n    c = (int)(sug.su_badptr - line);\n    memmove(p, line, c);\n    STRCPY(p + c, stp->st_word);\n    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n    // For redo we use a change-word command.\n    ResetRedobuff();\n    AppendToRedobuff(\"ciw\");\n    AppendToRedobuffLit(p + c,\n        stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n    AppendCharToRedobuff(ESC);\n\n    // \"p\" may be freed here\n    ml_replace(curwin->w_cursor.lnum, p, false);\n    curwin->w_cursor.col = c;\n\n    changed_bytes(curwin->w_cursor.lnum, c);\n  } else\n    curwin->w_cursor = prev_cursor;\n\n  spell_find_cleanup(&sug);\n  xfree(line);\n  curwin->w_p_spell = wo_spell_save;\n}\n\n// Check if the word at line \"lnum\" column \"col\" is required to start with a\n// capital.  This uses 'spellcapcheck' of the current buffer.\nstatic bool check_need_cap(linenr_T lnum, colnr_T col)\n{\n  bool need_cap = false;\n  char_u      *line;\n  char_u      *line_copy = NULL;\n  char_u      *p;\n  colnr_T endcol;\n  regmatch_T regmatch;\n\n  if (curwin->w_s->b_cap_prog == NULL)\n    return false;\n\n  line = get_cursor_line_ptr();\n  endcol = 0;\n  if (getwhitecols(line) >= (int)col) {\n    // At start of line, check if previous line is empty or sentence\n    // ends there.\n    if (lnum == 1)\n      need_cap = true;\n    else {\n      line = ml_get(lnum - 1);\n      if (*skipwhite(line) == NUL)\n        need_cap = true;\n      else {\n        // Append a space in place of the line break.\n        line_copy = concat_str(line, (char_u *)\" \");\n        line = line_copy;\n        endcol = (colnr_T)STRLEN(line);\n      }\n    }\n  } else {\n    endcol = col;\n  }\n\n  if (endcol > 0) {\n    // Check if sentence ends before the bad word.\n    regmatch.regprog = curwin->w_s->b_cap_prog;\n    regmatch.rm_ic = FALSE;\n    p = line + endcol;\n    for (;; ) {\n      MB_PTR_BACK(line, p);\n      if (p == line || spell_iswordp_nmw(p, curwin)) {\n        break;\n      }\n      if (vim_regexec(&regmatch, p, 0)\n          && regmatch.endp[0] == line + endcol) {\n        need_cap = true;\n        break;\n      }\n    }\n    curwin->w_s->b_cap_prog = regmatch.regprog;\n  }\n\n  xfree(line_copy);\n\n  return need_cap;\n}\n\n\n// \":spellrepall\"\nvoid ex_spellrepall(exarg_T *eap)\n{\n  pos_T pos = curwin->w_cursor;\n  char_u      *frompat;\n  int addlen;\n  char_u      *line;\n  char_u      *p;\n  bool save_ws = p_ws;\n  linenr_T prev_lnum = 0;\n\n  if (repl_from == NULL || repl_to == NULL) {\n    EMSG(_(\"E752: No previous spell replacement\"));\n    return;\n  }\n  addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n  frompat = xmalloc(STRLEN(repl_from) + 7);\n  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n  p_ws = false;\n\n  sub_nsubs = 0;\n  sub_nlines = 0;\n  curwin->w_cursor.lnum = 0;\n  while (!got_int) {\n    if (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n        || u_save_cursor() == FAIL) {\n      break;\n    }\n\n    // Only replace when the right word isn't there yet.  This happens\n    // when changing \"etc\" to \"etc.\".\n    line = get_cursor_line_ptr();\n    if (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n            repl_to, STRLEN(repl_to)) != 0) {\n      p = xmalloc(STRLEN(line) + addlen + 1);\n      memmove(p, line, curwin->w_cursor.col);\n      STRCPY(p + curwin->w_cursor.col, repl_to);\n      STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n      ml_replace(curwin->w_cursor.lnum, p, false);\n      changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n      if (curwin->w_cursor.lnum != prev_lnum) {\n        ++sub_nlines;\n        prev_lnum = curwin->w_cursor.lnum;\n      }\n      ++sub_nsubs;\n    }\n    curwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n  }\n\n  p_ws = save_ws;\n  curwin->w_cursor = pos;\n  xfree(frompat);\n\n  if (sub_nsubs == 0)\n    EMSG2(_(\"E753: Not found: %s\"), repl_from);\n  else\n    do_sub_msg(false);\n}\n\n// Find spell suggestions for \"word\".  Return them in the growarray \"*gap\" as\n// a list of allocated strings.\nvoid\nspell_suggest_list (\n    garray_T *gap,\n    char_u *word,\n    int maxcount,                   // maximum nr of suggestions\n    bool need_cap,                  // 'spellcapcheck' matched\n    bool interactive\n)\n{\n  suginfo_T sug;\n  suggest_T   *stp;\n  char_u      *wcopy;\n\n  spell_find_suggest(word, 0, &sug, maxcount, false, need_cap, interactive);\n\n  // Make room in \"gap\".\n  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);\n  ga_grow(gap, sug.su_ga.ga_len);\n  for (int i = 0; i < sug.su_ga.ga_len; ++i) {\n    stp = &SUG(sug.su_ga, i);\n\n    // The suggested word may replace only part of \"word\", add the not\n    // replaced part.\n    wcopy = xmalloc(stp->st_wordlen\n                    + STRLEN(sug.su_badptr + stp->st_orglen) + 1);\n    STRCPY(wcopy, stp->st_word);\n    STRCPY(wcopy + stp->st_wordlen, sug.su_badptr + stp->st_orglen);\n    ((char_u **)gap->ga_data)[gap->ga_len++] = wcopy;\n  }\n\n  spell_find_cleanup(&sug);\n}\n\n// Find spell suggestions for the word at the start of \"badptr\".\n// Return the suggestions in \"su->su_ga\".\n// The maximum number of suggestions is \"maxcount\".\n// Note: does use info for the current window.\n// This is based on the mechanisms of Aspell, but completely reimplemented.\nstatic void\nspell_find_suggest (\n    char_u *badptr,\n    int badlen,                     // length of bad word or 0 if unknown\n    suginfo_T *su,\n    int maxcount,\n    bool banbadword,                 // don't include badword in suggestions\n    bool need_cap,                  // word should start with capital\n    bool interactive\n)\n{\n  hlf_T attr = HLF_COUNT;\n  char_u buf[MAXPATHL];\n  char_u      *p;\n  bool do_combine = false;\n  char_u      *sps_copy;\n  static bool expr_busy = false;\n  int c;\n  langp_T     *lp;\n  bool did_intern = false;\n\n  // Set the info in \"*su\".\n  memset(su, 0, sizeof(suginfo_T));\n  ga_init(&su->su_ga, (int)sizeof(suggest_T), 10);\n  ga_init(&su->su_sga, (int)sizeof(suggest_T), 10);\n  if (*badptr == NUL)\n    return;\n  hash_init(&su->su_banned);\n\n  su->su_badptr = badptr;\n  if (badlen != 0)\n    su->su_badlen = badlen;\n  else {\n    size_t tmplen = spell_check(curwin, su->su_badptr, &attr, NULL, false);\n    assert(tmplen <= INT_MAX);\n    su->su_badlen = (int)tmplen;\n  }\n  su->su_maxcount = maxcount;\n  su->su_maxscore = SCORE_MAXINIT;\n\n  if (su->su_badlen >= MAXWLEN)\n    su->su_badlen = MAXWLEN - 1;        // just in case\n  STRLCPY(su->su_badword, su->su_badptr, su->su_badlen + 1);\n  (void)spell_casefold(curwin, su->su_badptr, su->su_badlen, su->su_fbadword,\n                       MAXWLEN);\n\n  // TODO(vim): make this work if the case-folded text is longer than the\n  // original text. Currently an illegal byte causes wrong pointer\n  // computations.\n  su->su_fbadword[su->su_badlen] = NUL;\n\n  // get caps flags for bad word\n  su->su_badflags = badword_captype(su->su_badptr,\n      su->su_badptr + su->su_badlen);\n  if (need_cap)\n    su->su_badflags |= WF_ONECAP;\n\n  // Find the default language for sound folding.  We simply use the first\n  // one in 'spelllang' that supports sound folding.  That's good for when\n  // using multiple files for one language, it's not that bad when mixing\n  // languages (e.g., \"pl,en\").\n  for (int i = 0; i < curbuf->b_s.b_langp.ga_len; ++i) {\n    lp = LANGP_ENTRY(curbuf->b_s.b_langp, i);\n    if (lp->lp_sallang != NULL) {\n      su->su_sallang = lp->lp_sallang;\n      break;\n    }\n  }\n\n  // Soundfold the bad word with the default sound folding, so that we don't\n  // have to do this many times.\n  if (su->su_sallang != NULL)\n    spell_soundfold(su->su_sallang, su->su_fbadword, true,\n        su->su_sal_badword);\n\n  // If the word is not capitalised and spell_check() doesn't consider the\n  // word to be bad then it might need to be capitalised.  Add a suggestion\n  // for that.\n  c = PTR2CHAR(su->su_badptr);\n  if (!SPELL_ISUPPER(c) && attr == HLF_COUNT) {\n    make_case_word(su->su_badword, buf, WF_ONECAP);\n    add_suggestion(su, &su->su_ga, buf, su->su_badlen, SCORE_ICASE,\n        0, true, su->su_sallang, false);\n  }\n\n  // Ban the bad word itself.  It may appear in another region.\n  if (banbadword)\n    add_banned(su, su->su_badword);\n\n  // Make a copy of 'spellsuggest', because the expression may change it.\n  sps_copy = vim_strsave(p_sps);\n\n  // Loop over the items in 'spellsuggest'.\n  for (p = sps_copy; *p != NUL; ) {\n    copy_option_part(&p, buf, MAXPATHL, \",\");\n\n    if (STRNCMP(buf, \"expr:\", 5) == 0) {\n      // Evaluate an expression.  Skip this when called recursively,\n      // when using spellsuggest() in the expression.\n      if (!expr_busy) {\n        expr_busy = true;\n        spell_suggest_expr(su, buf + 5);\n        expr_busy = false;\n      }\n    } else if (STRNCMP(buf, \"file:\", 5) == 0) {\n      // Use list of suggestions in a file.\n      spell_suggest_file(su, buf + 5);\n    } else if (!did_intern) {\n      // Use internal method once.\n      spell_suggest_intern(su, interactive);\n      if (sps_flags & SPS_DOUBLE) {\n        do_combine = true;\n      }\n      did_intern = true;\n    }\n  }\n\n  xfree(sps_copy);\n\n  if (do_combine)\n    // Combine the two list of suggestions.  This must be done last,\n    // because sorting changes the order again.\n    score_combine(su);\n}\n\n// Find suggestions by evaluating expression \"expr\".\nstatic void spell_suggest_expr(suginfo_T *su, char_u *expr)\n{\n  int score;\n  const char *p;\n\n  // The work is split up in a few parts to avoid having to export\n  // suginfo_T.\n  // First evaluate the expression and get the resulting list.\n  list_T *const list = eval_spell_expr(su->su_badword, expr);\n  if (list != NULL) {\n    // Loop over the items in the list.\n    TV_LIST_ITER(list, li, {\n      if (TV_LIST_ITEM_TV(li)->v_type == VAR_LIST) {\n        // Get the word and the score from the items.\n        score = get_spellword(TV_LIST_ITEM_TV(li)->vval.v_list, &p);\n        if (score >= 0 && score <= su->su_maxscore) {\n          add_suggestion(su, &su->su_ga, (const char_u *)p, su->su_badlen,\n                         score, 0, true, su->su_sallang, false);\n        }\n      }\n    });\n    tv_list_unref(list);\n  }\n\n  // Remove bogus suggestions, sort and truncate at \"maxcount\".\n  check_suggestions(su, &su->su_ga);\n  (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n\n// Find suggestions in file \"fname\".  Used for \"file:\" in 'spellsuggest'.\nstatic void spell_suggest_file(suginfo_T *su, char_u *fname)\n{\n  FILE        *fd;\n  char_u line[MAXWLEN * 2];\n  char_u      *p;\n  int len;\n  char_u cword[MAXWLEN];\n\n  // Open the file.\n  fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return;\n  }\n\n  // Read it line by line.\n  while (!vim_fgets(line, MAXWLEN * 2, fd) && !got_int) {\n    line_breakcheck();\n\n    p = vim_strchr(line, '/');\n    if (p == NULL)\n      continue;             // No Tab found, just skip the line.\n    *p++ = NUL;\n    if (STRICMP(su->su_badword, line) == 0) {\n      // Match!  Isolate the good word, until CR or NL.\n      for (len = 0; p[len] >= ' '; ++len)\n        ;\n      p[len] = NUL;\n\n      // If the suggestion doesn't have specific case duplicate the case\n      // of the bad word.\n      if (captype(p, NULL) == 0) {\n        make_case_word(p, cword, su->su_badflags);\n        p = cword;\n      }\n\n      add_suggestion(su, &su->su_ga, p, su->su_badlen,\n          SCORE_FILE, 0, true, su->su_sallang, false);\n    }\n  }\n\n  fclose(fd);\n\n  // Remove bogus suggestions, sort and truncate at \"maxcount\".\n  check_suggestions(su, &su->su_ga);\n  (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n\n// Find suggestions for the internal method indicated by \"sps_flags\".\nstatic void spell_suggest_intern(suginfo_T *su, bool interactive)\n{\n  // Load the .sug file(s) that are available and not done yet.\n  suggest_load_files();\n\n  // 1. Try special cases, such as repeating a word: \"the the\" -> \"the\".\n  //\n  // Set a maximum score to limit the combination of operations that is\n  // tried.\n  suggest_try_special(su);\n\n  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries\n  //    from the .aff file and inserting a space (split the word).\n  suggest_try_change(su);\n\n  // For the resulting top-scorers compute the sound-a-like score.\n  if (sps_flags & SPS_DOUBLE)\n    score_comp_sal(su);\n\n  // 3. Try finding sound-a-like words.\n  if ((sps_flags & SPS_FAST) == 0) {\n    if (sps_flags & SPS_BEST)\n      // Adjust the word score for the suggestions found so far for how\n      // they sounds like.\n      rescore_suggestions(su);\n\n    // While going through the soundfold tree \"su_maxscore\" is the score\n    // for the soundfold word, limits the changes that are being tried,\n    // and \"su_sfmaxscore\" the rescored score, which is set by\n    // cleanup_suggestions().\n    // First find words with a small edit distance, because this is much\n    // faster and often already finds the top-N suggestions.  If we didn't\n    // find many suggestions try again with a higher edit distance.\n    // \"sl_sounddone\" is used to avoid doing the same word twice.\n    suggest_try_soundalike_prep();\n    su->su_maxscore = SCORE_SFMAX1;\n    su->su_sfmaxscore = SCORE_MAXINIT * 3;\n    suggest_try_soundalike(su);\n    if (su->su_ga.ga_len < SUG_CLEAN_COUNT(su)) {\n      // We didn't find enough matches, try again, allowing more\n      // changes to the soundfold word.\n      su->su_maxscore = SCORE_SFMAX2;\n      suggest_try_soundalike(su);\n      if (su->su_ga.ga_len < SUG_CLEAN_COUNT(su)) {\n        // Still didn't find enough matches, try again, allowing even\n        // more changes to the soundfold word.\n        su->su_maxscore = SCORE_SFMAX3;\n        suggest_try_soundalike(su);\n      }\n    }\n    su->su_maxscore = su->su_sfmaxscore;\n    suggest_try_soundalike_finish();\n  }\n\n  // When CTRL-C was hit while searching do show the results.  Only clear\n  // got_int when using a command, not for spellsuggest().\n  os_breakcheck();\n  if (interactive && got_int) {\n    (void)vgetc();\n    got_int = FALSE;\n  }\n\n  if ((sps_flags & SPS_DOUBLE) == 0 && su->su_ga.ga_len != 0) {\n    if (sps_flags & SPS_BEST)\n      // Adjust the word score for how it sounds like.\n      rescore_suggestions(su);\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n  }\n}\n\n// Free the info put in \"*su\" by spell_find_suggest().\nstatic void spell_find_cleanup(suginfo_T *su)\n{\n# define FREE_SUG_WORD(sug) xfree(sug->st_word)\n  // Free the suggestions.\n  GA_DEEP_CLEAR(&su->su_ga, suggest_T, FREE_SUG_WORD);\n  GA_DEEP_CLEAR(&su->su_sga, suggest_T, FREE_SUG_WORD);\n\n  // Free the banned words.\n  hash_clear_all(&su->su_banned, 0);\n}\n\n/// Make a copy of \"word\", with the first letter upper or lower cased, to\n/// \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n/// The result is NUL terminated.\n///\n/// @param[in]  word  source string to copy\n/// @param[in,out]  wcopy  copied string, with case of first letter changed\n/// @param[in]  upper  True to upper case, otherwise lower case\nvoid onecap_copy(char_u *word, char_u *wcopy, bool upper)\n{\n  char_u *p = word;\n  int c = mb_cptr2char_adv((const char_u **)&p);\n  if (upper) {\n    c = SPELL_TOUPPER(c);\n  } else {\n    c = SPELL_TOFOLD(c);\n  }\n  int l = utf_char2bytes(c, wcopy);\n  STRLCPY(wcopy + l, p, MAXWLEN - l);\n}\n\n// Make a copy of \"word\" with all the letters upper cased into\n// \"wcopy[MAXWLEN]\".  The result is NUL terminated.\nstatic void allcap_copy(char_u *word, char_u *wcopy)\n{\n  char_u *d = wcopy;\n  for (char_u *s = word; *s != NUL; ) {\n    int c = mb_cptr2char_adv((const char_u **)&s);\n\n    if (c == 0xdf) {\n      c = 'S';\n      if (d - wcopy >= MAXWLEN - 1)\n        break;\n      *d++ = c;\n    } else\n      c = SPELL_TOUPPER(c);\n\n    if (d - wcopy >= MAXWLEN - MB_MAXBYTES) {\n      break;\n    }\n    d += utf_char2bytes(c, d);\n  }\n  *d = NUL;\n}\n\n// Try finding suggestions by recognizing specific situations.\nstatic void suggest_try_special(suginfo_T *su)\n{\n  char_u      *p;\n  size_t len;\n  int c;\n  char_u word[MAXWLEN];\n\n  // Recognize a word that is repeated: \"the the\".\n  p = skiptowhite(su->su_fbadword);\n  len = p - su->su_fbadword;\n  p = skipwhite(p);\n  if (STRLEN(p) == len && STRNCMP(su->su_fbadword, p, len) == 0) {\n    // Include badflags: if the badword is onecap or allcap\n    // use that for the goodword too: \"The the\" -> \"The\".\n    c = su->su_fbadword[len];\n    su->su_fbadword[len] = NUL;\n    make_case_word(su->su_fbadword, word, su->su_badflags);\n    su->su_fbadword[len] = c;\n\n    // Give a soundalike score of 0, compute the score as if deleting one\n    // character.\n    add_suggestion(su, &su->su_ga, word, su->su_badlen,\n        RESCORE(SCORE_REP, 0), 0, true, su->su_sallang, false);\n  }\n}\n\n// Measure how much time is spent in each state.\n// Output is dumped in \"suggestprof\".\n\n#ifdef SUGGEST_PROFILE\nproftime_T current;\nproftime_T total;\nproftime_T times[STATE_FINAL + 1];\nlong counts[STATE_FINAL + 1];\n\n  static void\nprof_init(void)\n{\n  for (int i = 0; i <= STATE_FINAL; i++) {\n    profile_zero(&times[i]);\n    counts[i] = 0;\n  }\n  profile_start(&current);\n  profile_start(&total);\n}\n\n// call before changing state\n  static void\nprof_store(state_T state)\n{\n  profile_end(&current);\n  profile_add(&times[state], &current);\n  counts[state]++;\n  profile_start(&current);\n}\n# define PROF_STORE(state) prof_store(state);\n\n  static void\nprof_report(char *name)\n{\n  FILE *fd = fopen(\"suggestprof\", \"a\");\n\n  profile_end(&total);\n  fprintf(fd, \"-----------------------\\n\");\n  fprintf(fd, \"%s: %s\\n\", name, profile_msg(&total));\n  for (int i = 0; i <= STATE_FINAL; i++) {\n    fprintf(fd, \"%d: %s (\"%\" PRId64)\\n\", i, profile_msg(&times[i]), counts[i]);\n  }\n  fclose(fd);\n}\n#else\n# define PROF_STORE(state)\n#endif\n\n// Try finding suggestions by adding/removing/swapping letters.\n\nstatic void suggest_try_change(suginfo_T *su)\n{\n  char_u fword[MAXWLEN];            // copy of the bad word, case-folded\n  int n;\n  char_u      *p;\n  langp_T     *lp;\n\n  // We make a copy of the case-folded bad word, so that we can modify it\n  // to find matches (esp. REP items).  Append some more text, changing\n  // chars after the bad word may help.\n  STRCPY(fword, su->su_fbadword);\n  n = (int)STRLEN(fword);\n  p = su->su_badptr + su->su_badlen;\n  (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);\n\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\n    // If reloading a spell file fails it's still in the list but\n    // everything has been cleared.\n    if (lp->lp_slang->sl_fbyts == NULL)\n      continue;\n\n    // Try it for this language.  Will add possible suggestions.\n    //\n#ifdef SUGGEST_PROFILE\n    prof_init();\n#endif\n    suggest_trie_walk(su, lp, fword, false);\n#ifdef SUGGEST_PROFILE\n    prof_report(\"try_change\");\n#endif\n  }\n}\n\n// Check the maximum score, if we go over it we won't try this change.\n#define TRY_DEEPER(su, stack, depth, add) \\\n  (stack[depth].ts_score + (add) < su->su_maxscore)\n\n// Try finding suggestions by adding/removing/swapping letters.\n//\n// This uses a state machine.  At each node in the tree we try various\n// operations.  When trying if an operation works \"depth\" is increased and the\n// stack[] is used to store info.  This allows combinations, thus insert one\n// character, replace one and delete another.  The number of changes is\n// limited by su->su_maxscore.\n//\n// After implementing this I noticed an article by Kemal Oflazer that\n// describes something similar: \"Error-tolerant Finite State Recognition with\n// Applications to Morphological Analysis and Spelling Correction\" (1996).\n// The implementation in the article is simplified and requires a stack of\n// unknown depth.  The implementation here only needs a stack depth equal to\n// the length of the word.\n//\n// This is also used for the sound-folded word, \"soundfold\" is true then.\n// The mechanism is the same, but we find a match with a sound-folded word\n// that comes from one or more original words.  Each of these words may be\n// added, this is done by add_sound_suggest().\n// Don't use:\n//      the prefix tree or the keep-case tree\n//      \"su->su_badlen\"\n//      anything to do with upper and lower case\n//      anything to do with word or non-word characters (\"spell_iswordp()\")\n//      banned words\n//      word flags (rare, region, compounding)\n//      word splitting for now\n//      \"similar_chars()\"\n//      use \"slang->sl_repsal\" instead of \"lp->lp_replang->sl_rep\"\nstatic void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)\n{\n  char_u tword[MAXWLEN];            // good word collected so far\n  trystate_T stack[MAXWLEN];\n  char_u preword[MAXWLEN * 3] = { 0 };  // word found with proper case;\n                                    // concatenation of prefix compound\n                                    // words and split word.  NUL terminated\n                                    // when going deeper but not when coming\n                                    // back.\n  char_u compflags[MAXWLEN];        // compound flags, one for each word\n  trystate_T  *sp;\n  int newscore;\n  int score;\n  char_u      *byts, *fbyts, *pbyts;\n  idx_T       *idxs, *fidxs, *pidxs;\n  int depth;\n  int c, c2, c3;\n  int n = 0;\n  int flags;\n  garray_T    *gap;\n  idx_T arridx;\n  int len;\n  char_u      *p;\n  fromto_T    *ftp;\n  int fl = 0, tl;\n  int repextra = 0;                 // extra bytes in fword[] from REP item\n  slang_T     *slang = lp->lp_slang;\n  int fword_ends;\n  bool goodword_ends;\n#ifdef DEBUG_TRIEWALK\n  // Stores the name of the change made at each level.\n  char_u changename[MAXWLEN][80];\n#endif\n  int breakcheckcount = 1000;\n  bool compound_ok;\n\n  // Go through the whole case-fold tree, try changes at each node.\n  // \"tword[]\" contains the word collected from nodes in the tree.\n  // \"fword[]\" the word we are trying to match with (initially the bad\n  // word).\n  depth = 0;\n  sp = &stack[0];\n  memset(sp, 0, sizeof(trystate_T));  // -V512\n  sp->ts_curi = 1;\n\n  if (soundfold) {\n    // Going through the soundfold tree.\n    byts = fbyts = slang->sl_sbyts;\n    idxs = fidxs = slang->sl_sidxs;\n    pbyts = NULL;\n    pidxs = NULL;\n    sp->ts_prefixdepth = PFD_NOPREFIX;\n    sp->ts_state = STATE_START;\n  } else {\n    // When there are postponed prefixes we need to use these first.  At\n    // the end of the prefix we continue in the case-fold tree.\n    fbyts = slang->sl_fbyts;\n    fidxs = slang->sl_fidxs;\n    pbyts = slang->sl_pbyts;\n    pidxs = slang->sl_pidxs;\n    if (pbyts != NULL) {\n      byts = pbyts;\n      idxs = pidxs;\n      sp->ts_prefixdepth = PFD_PREFIXTREE;\n      sp->ts_state = STATE_NOPREFIX;            // try without prefix first\n    } else {\n      byts = fbyts;\n      idxs = fidxs;\n      sp->ts_prefixdepth = PFD_NOPREFIX;\n      sp->ts_state = STATE_START;\n    }\n  }\n\n  // Loop to find all suggestions.  At each round we either:\n  // - For the current state try one operation, advance \"ts_curi\",\n  //   increase \"depth\".\n  // - When a state is done go to the next, set \"ts_state\".\n  // - When all states are tried decrease \"depth\".\n  while (depth >= 0 && !got_int) {\n    sp = &stack[depth];\n    switch (sp->ts_state) {\n    case STATE_START:\n    case STATE_NOPREFIX:\n      // Start of node: Deal with NUL bytes, which means\n      // tword[] may end here.\n      arridx = sp->ts_arridx;               // current node in the tree\n      len = byts[arridx];                   // bytes in this node\n      arridx += sp->ts_curi;                // index of current byte\n\n      if (sp->ts_prefixdepth == PFD_PREFIXTREE) {\n        // Skip over the NUL bytes, we use them later.\n        for (n = 0; n < len && byts[arridx + n] == 0; ++n)\n          ;\n        sp->ts_curi += n;\n\n        // Always past NUL bytes now.\n        n = (int)sp->ts_state;\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_ENDNUL;\n        sp->ts_save_badflags = su->su_badflags;\n\n        // At end of a prefix or at start of prefixtree: check for\n        // following word.\n        if (byts[arridx] == 0 || n == (int)STATE_NOPREFIX) {\n          // Set su->su_badflags to the caps type at this position.\n          // Use the caps type until here for the prefix itself.\n          n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n          flags = badword_captype(su->su_badptr, su->su_badptr + n);\n          su->su_badflags = badword_captype(su->su_badptr + n,\n              su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n          sprintf(changename[depth], \"prefix\");\n#endif\n          go_deeper(stack, depth, 0);\n          ++depth;\n          sp = &stack[depth];\n          sp->ts_prefixdepth = depth - 1;\n          byts = fbyts;\n          idxs = fidxs;\n          sp->ts_arridx = 0;\n\n          // Move the prefix to preword[] with the right case\n          // and make find_keepcap_word() works.\n          tword[sp->ts_twordlen] = NUL;\n          make_case_word(tword + sp->ts_splitoff,\n              preword + sp->ts_prewordlen, flags);\n          sp->ts_prewordlen = (char_u)STRLEN(preword);\n          sp->ts_splitoff = sp->ts_twordlen;\n        }\n        break;\n      }\n\n      if (sp->ts_curi > len || byts[arridx] != 0) {\n        // Past bytes in node and/or past NUL bytes.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_ENDNUL;\n        sp->ts_save_badflags = su->su_badflags;\n        break;\n      }\n\n      // End of word in tree.\n      ++sp->ts_curi;                    // eat one NUL byte\n\n      flags = (int)idxs[arridx];\n\n      // Skip words with the NOSUGGEST flag.\n      if (flags & WF_NOSUGGEST)\n        break;\n\n      fword_ends = (fword[sp->ts_fidx] == NUL\n                    || (soundfold\n                        ? ascii_iswhite(fword[sp->ts_fidx])\n                        : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n      tword[sp->ts_twordlen] = NUL;\n\n      if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n          && (sp->ts_flags & TSF_PREFIXOK) == 0\n          && pbyts != NULL) {\n        // There was a prefix before the word.  Check that the prefix\n        // can be used with this word.\n        // Count the length of the NULs in the prefix.  If there are\n        // none this must be the first try without a prefix.\n        n = stack[sp->ts_prefixdepth].ts_arridx;\n        len = pbyts[n++];\n        for (c = 0; c < len && pbyts[n + c] == 0; ++c)\n          ;\n        if (c > 0) {\n          c = valid_word_prefix(c, n, flags,\n              tword + sp->ts_splitoff, slang, false);\n          if (c == 0)\n            break;\n\n          // Use the WF_RARE flag for a rare prefix.\n          if (c & WF_RAREPFX)\n            flags |= WF_RARE;\n\n          // Tricky: when checking for both prefix and compounding\n          // we run into the prefix flag first.\n          // Remember that it's OK, so that we accept the prefix\n          // when arriving at a compound flag.\n          sp->ts_flags |= TSF_PREFIXOK;\n        }\n      }\n\n      // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n      // appending another compound word below.\n      if (sp->ts_complen == sp->ts_compsplit && fword_ends\n          && (flags & WF_NEEDCOMP))\n        goodword_ends = false;\n      else\n        goodword_ends = true;\n\n      p = NULL;\n      compound_ok = true;\n      if (sp->ts_complen > sp->ts_compsplit) {\n        if (slang->sl_nobreak) {\n          // There was a word before this word.  When there was no\n          // change in this word (it was correct) add the first word\n          // as a suggestion.  If this word was corrected too, we\n          // need to check if a correct word follows.\n          if (sp->ts_fidx - sp->ts_splitfidx\n              == sp->ts_twordlen - sp->ts_splitoff\n              && STRNCMP(fword + sp->ts_splitfidx,\n                  tword + sp->ts_splitoff,\n                  sp->ts_fidx - sp->ts_splitfidx) == 0) {\n            preword[sp->ts_prewordlen] = NUL;\n            newscore = score_wordcount_adj(slang, sp->ts_score,\n                preword + sp->ts_prewordlen,\n                sp->ts_prewordlen > 0);\n            // Add the suggestion if the score isn't too bad.\n            if (newscore <= su->su_maxscore)\n              add_suggestion(su, &su->su_ga, preword,\n                  sp->ts_splitfidx - repextra,\n                  newscore, 0, false,\n                  lp->lp_sallang, false);\n            break;\n          }\n        } else {\n          // There was a compound word before this word.  If this\n          // word does not support compounding then give up\n          // (splitting is tried for the word without compound\n          // flag).\n          if (((unsigned)flags >> 24) == 0\n              || sp->ts_twordlen - sp->ts_splitoff\n              < slang->sl_compminlen) {\n            break;\n          }\n          // For multi-byte chars check character length against\n          // COMPOUNDMIN.\n          if (slang->sl_compminlen > 0\n              && mb_charlen(tword + sp->ts_splitoff)\n              < slang->sl_compminlen) {\n            break;\n          }\n\n          compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n          compflags[sp->ts_complen + 1] = NUL;\n          STRLCPY(preword + sp->ts_prewordlen,\n              tword + sp->ts_splitoff,\n              sp->ts_twordlen - sp->ts_splitoff + 1);\n\n          // Verify CHECKCOMPOUNDPATTERN  rules.\n          if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n                  &slang->sl_comppat))\n            compound_ok = false;\n\n          if (compound_ok) {\n            p = preword;\n            while (*skiptowhite(p) != NUL)\n              p = skipwhite(skiptowhite(p));\n            if (fword_ends && !can_compound(slang, p,\n                    compflags + sp->ts_compsplit))\n              // Compound is not allowed.  But it may still be\n              // possible if we add another (short) word.\n              compound_ok = false;\n          }\n\n          // Get pointer to last char of previous word.\n          p = preword + sp->ts_prewordlen;\n          MB_PTR_BACK(preword, p);\n        }\n      }\n\n      // Form the word with proper case in preword.\n      // If there is a word from a previous split, append.\n      // For the soundfold tree don't change the case, simply append.\n      if (soundfold)\n        STRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n      else if (flags & WF_KEEPCAP)\n        // Must find the word in the keep-case tree.\n        find_keepcap_word(slang, tword + sp->ts_splitoff,\n            preword + sp->ts_prewordlen);\n      else {\n        // Include badflags: If the badword is onecap or allcap\n        // use that for the goodword too.  But if the badword is\n        // allcap and it's only one char long use onecap.\n        c = su->su_badflags;\n        if ((c & WF_ALLCAP)\n            && su->su_badlen == (*mb_ptr2len)(su->su_badptr)\n            )\n          c = WF_ONECAP;\n        c |= flags;\n\n        // When appending a compound word after a word character don't\n        // use Onecap.\n        if (p != NULL && spell_iswordp_nmw(p, curwin))\n          c &= ~WF_ONECAP;\n        make_case_word(tword + sp->ts_splitoff,\n            preword + sp->ts_prewordlen, c);\n      }\n\n      if (!soundfold) {\n        // Don't use a banned word.  It may appear again as a good\n        // word, thus remember it.\n        if (flags & WF_BANNED) {\n          add_banned(su, preword + sp->ts_prewordlen);\n          break;\n        }\n        if ((sp->ts_complen == sp->ts_compsplit\n             && WAS_BANNED(su, preword + sp->ts_prewordlen))\n            || WAS_BANNED(su, preword)) {\n          if (slang->sl_compprog == NULL)\n            break;\n          // the word so far was banned but we may try compounding\n          goodword_ends = false;\n        }\n      }\n\n      newscore = 0;\n      if (!soundfold) {         // soundfold words don't have flags\n        if ((flags & WF_REGION)\n            && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n          newscore += SCORE_REGION;\n        if (flags & WF_RARE)\n          newscore += SCORE_RARE;\n\n        if (!spell_valid_case(su->su_badflags,\n                captype(preword + sp->ts_prewordlen, NULL)))\n          newscore += SCORE_ICASE;\n      }\n\n      // TODO: how about splitting in the soundfold tree?\n      if (fword_ends\n          && goodword_ends\n          && sp->ts_fidx >= sp->ts_fidxtry\n          && compound_ok) {\n        // The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n        if (soundfold && STRCMP(preword, \"smwrd\") == 0) {\n          int j;\n\n          // print the stack of changes that brought us here\n          smsg(\"------ %s -------\", fword);\n          for (j = 0; j < depth; ++j)\n            smsg(\"%s\", changename[j]);\n        }\n#endif\n        if (soundfold) {\n          // For soundfolded words we need to find the original\n          // words, the edit distance and then add them.\n          add_sound_suggest(su, preword, sp->ts_score, lp);\n        } else if (sp->ts_fidx > 0)   {\n          // Give a penalty when changing non-word char to word\n          // char, e.g., \"thes,\" -> \"these\".\n          p = fword + sp->ts_fidx;\n          MB_PTR_BACK(fword, p);\n          if (!spell_iswordp(p, curwin)) {\n            p = preword + STRLEN(preword);\n            MB_PTR_BACK(preword, p);\n            if (spell_iswordp(p, curwin)) {\n              newscore += SCORE_NONWORD;\n            }\n          }\n\n          // Give a bonus to words seen before.\n          score = score_wordcount_adj(slang,\n              sp->ts_score + newscore,\n              preword + sp->ts_prewordlen,\n              sp->ts_prewordlen > 0);\n\n          // Add the suggestion if the score isn't too bad.\n          if (score <= su->su_maxscore) {\n            add_suggestion(su, &su->su_ga, preword,\n                sp->ts_fidx - repextra,\n                score, 0, false, lp->lp_sallang, false);\n\n            if (su->su_badflags & WF_MIXCAP) {\n              // We really don't know if the word should be\n              // upper or lower case, add both.\n              c = captype(preword, NULL);\n              if (c == 0 || c == WF_ALLCAP) {\n                make_case_word(tword + sp->ts_splitoff,\n                    preword + sp->ts_prewordlen,\n                    c == 0 ? WF_ALLCAP : 0);\n\n                add_suggestion(su, &su->su_ga, preword,\n                    sp->ts_fidx - repextra,\n                    score + SCORE_ICASE, 0, false,\n                    lp->lp_sallang, false);\n              }\n            }\n          }\n        }\n      }\n\n      // Try word split and/or compounding.\n      if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n          // Don't split in the middle of a character\n          && (sp->ts_tcharlen == 0)\n          ) {\n        bool try_compound;\n        int try_split;\n\n        // If past the end of the bad word don't try a split.\n        // Otherwise try changing the next word.  E.g., find\n        // suggestions for \"the the\" where the second \"the\" is\n        // different.  It's done like a split.\n        // TODO: word split for soundfold words\n        try_split = (sp->ts_fidx - repextra < su->su_badlen)\n                    && !soundfold;\n\n        // Get here in several situations:\n        // 1. The word in the tree ends:\n        //    If the word allows compounding try that.  Otherwise try\n        //    a split by inserting a space.  For both check that a\n        //    valid words starts at fword[sp->ts_fidx].\n        //    For NOBREAK do like compounding to be able to check if\n        //    the next word is valid.\n        // 2. The badword does end, but it was due to a change (e.g.,\n        //    a swap).  No need to split, but do check that the\n        //    following word is valid.\n        // 3. The badword and the word in the tree end.  It may still\n        //    be possible to compound another (short) word.\n        try_compound = false;\n        if (!soundfold\n            && !slang->sl_nocompoundsugs\n            && slang->sl_compprog != NULL\n            && ((unsigned)flags >> 24) != 0\n            && sp->ts_twordlen - sp->ts_splitoff\n            >= slang->sl_compminlen\n            && (slang->sl_compminlen == 0\n                || mb_charlen(tword + sp->ts_splitoff)\n                >= slang->sl_compminlen)\n            && (slang->sl_compsylmax < MAXWLEN\n                || sp->ts_complen + 1 - sp->ts_compsplit\n                < slang->sl_compmax)\n            && (can_be_compound(sp, slang,\n                    compflags, ((unsigned)flags >> 24)))) {\n          try_compound = true;\n          compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n          compflags[sp->ts_complen + 1] = NUL;\n        }\n\n        // For NOBREAK we never try splitting, it won't make any word\n        // valid.\n        if (slang->sl_nobreak && !slang->sl_nocompoundsugs) {\n          try_compound = true;\n        } else if (!fword_ends\n                   && try_compound\n                   && (sp->ts_flags & TSF_DIDSPLIT) == 0) {\n          // If we could add a compound word, and it's also possible to\n          // split at this point, do the split first and set\n          // TSF_DIDSPLIT to avoid doing it again.\n          try_compound = false;\n          sp->ts_flags |= TSF_DIDSPLIT;\n          --sp->ts_curi;                    // do the same NUL again\n          compflags[sp->ts_complen] = NUL;\n        } else {\n          sp->ts_flags &= ~TSF_DIDSPLIT;\n        }\n\n        if (try_split || try_compound) {\n          if (!try_compound && (!fword_ends || !goodword_ends)) {\n            // If we're going to split need to check that the\n            // words so far are valid for compounding.  If there\n            // is only one word it must not have the NEEDCOMPOUND\n            // flag.\n            if (sp->ts_complen == sp->ts_compsplit\n                && (flags & WF_NEEDCOMP))\n              break;\n            p = preword;\n            while (*skiptowhite(p) != NUL)\n              p = skipwhite(skiptowhite(p));\n            if (sp->ts_complen > sp->ts_compsplit\n                && !can_compound(slang, p,\n                    compflags + sp->ts_compsplit))\n              break;\n\n            if (slang->sl_nosplitsugs)\n              newscore += SCORE_SPLIT_NO;\n            else\n              newscore += SCORE_SPLIT;\n\n            // Give a bonus to words seen before.\n            newscore = score_wordcount_adj(slang, newscore,\n                preword + sp->ts_prewordlen, true);\n          }\n\n          if (TRY_DEEPER(su, stack, depth, newscore)) {\n            go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n            if (!try_compound && !fword_ends)\n              sprintf(changename[depth], \"%.*s-%s: split\",\n                  sp->ts_twordlen, tword, fword + sp->ts_fidx);\n            else\n              sprintf(changename[depth], \"%.*s-%s: compound\",\n                  sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n            // Save things to be restored at STATE_SPLITUNDO.\n            sp->ts_save_badflags = su->su_badflags;\n            PROF_STORE(sp->ts_state)\n            sp->ts_state = STATE_SPLITUNDO;\n\n            ++depth;\n            sp = &stack[depth];\n\n            // Append a space to preword when splitting.\n            if (!try_compound && !fword_ends)\n              STRCAT(preword, \" \");\n            sp->ts_prewordlen = (char_u)STRLEN(preword);\n            sp->ts_splitoff = sp->ts_twordlen;\n            sp->ts_splitfidx = sp->ts_fidx;\n\n            // If the badword has a non-word character at this\n            // position skip it.  That means replacing the\n            // non-word character with a space.  Always skip a\n            // character when the word ends.  But only when the\n            // good word can end.\n            if (((!try_compound && !spell_iswordp_nmw(fword\n                      + sp->ts_fidx,\n                      curwin))\n                 || fword_ends)\n                && fword[sp->ts_fidx] != NUL\n                && goodword_ends) {\n              int l;\n\n              l = utfc_ptr2len(fword + sp->ts_fidx);\n              if (fword_ends) {\n                // Copy the skipped character to preword.\n                memmove(preword + sp->ts_prewordlen,\n                    fword + sp->ts_fidx, l);\n                sp->ts_prewordlen += l;\n                preword[sp->ts_prewordlen] = NUL;\n              } else\n                sp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n              sp->ts_fidx += l;\n            }\n\n            // When compounding include compound flag in\n            // compflags[] (already set above).  When splitting we\n            // may start compounding over again.\n            if (try_compound)\n              ++sp->ts_complen;\n            else\n              sp->ts_compsplit = sp->ts_complen;\n            sp->ts_prefixdepth = PFD_NOPREFIX;\n\n            // set su->su_badflags to the caps type at this\n            // position\n            n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n            su->su_badflags = badword_captype(su->su_badptr + n,\n                su->su_badptr + su->su_badlen);\n\n            // Restart at top of the tree.\n            sp->ts_arridx = 0;\n\n            // If there are postponed prefixes, try these too.\n            if (pbyts != NULL) {\n              byts = pbyts;\n              idxs = pidxs;\n              sp->ts_prefixdepth = PFD_PREFIXTREE;\n              PROF_STORE(sp->ts_state)\n              sp->ts_state = STATE_NOPREFIX;\n            }\n          }\n        }\n      }\n      break;\n\n    case STATE_SPLITUNDO:\n      // Undo the changes done for word split or compound word.\n      su->su_badflags = sp->ts_save_badflags;\n\n      // Continue looking for NUL bytes.\n      PROF_STORE(sp->ts_state)\n      sp->ts_state = STATE_START;\n\n      // In case we went into the prefix tree.\n      byts = fbyts;\n      idxs = fidxs;\n      break;\n\n    case STATE_ENDNUL:\n      // Past the NUL bytes in the node.\n      su->su_badflags = sp->ts_save_badflags;\n      if (fword[sp->ts_fidx] == NUL\n          && sp->ts_tcharlen == 0\n          ) {\n        // The badword ends, can't use STATE_PLAIN.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_DEL;\n        break;\n      }\n      PROF_STORE(sp->ts_state)\n      sp->ts_state = STATE_PLAIN;\n      FALLTHROUGH;\n\n    case STATE_PLAIN:\n      // Go over all possible bytes at this node, add each to tword[]\n      // and use child node.  \"ts_curi\" is the index.\n      arridx = sp->ts_arridx;\n      if (sp->ts_curi > byts[arridx]) {\n        // Done all bytes at this node, do next state.  When still at\n        // already changed bytes skip the other tricks.\n        PROF_STORE(sp->ts_state)\n        if (sp->ts_fidx >= sp->ts_fidxtry) {\n          sp->ts_state = STATE_DEL;\n        } else {\n          sp->ts_state = STATE_FINAL;\n        }\n      } else {\n        arridx += sp->ts_curi++;\n        c = byts[arridx];\n\n        // Normal byte, go one level deeper.  If it's not equal to the\n        // byte in the bad word adjust the score.  But don't even try\n        // when the byte was already changed.  And don't try when we\n        // just deleted this byte, accepting it is always cheaper than\n        // delete + substitute.\n        if (c == fword[sp->ts_fidx]\n            || (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE)\n            )\n          newscore = 0;\n        else\n          newscore = SCORE_SUBST;\n        if ((newscore == 0\n             || (sp->ts_fidx >= sp->ts_fidxtry\n                 && ((sp->ts_flags & TSF_DIDDEL) == 0\n                     || c != fword[sp->ts_delidx])))\n            && TRY_DEEPER(su, stack, depth, newscore)) {\n          go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n          if (newscore > 0)\n            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n                sp->ts_twordlen, tword, fword + sp->ts_fidx,\n                fword[sp->ts_fidx], c);\n          else\n            sprintf(changename[depth], \"%.*s-%s: accept %c\",\n                sp->ts_twordlen, tword, fword + sp->ts_fidx,\n                fword[sp->ts_fidx]);\n#endif\n          ++depth;\n          sp = &stack[depth];\n          ++sp->ts_fidx;\n          tword[sp->ts_twordlen++] = c;\n          sp->ts_arridx = idxs[arridx];\n          if (newscore == SCORE_SUBST) {\n            sp->ts_isdiff = DIFF_YES;\n          }\n          // Multi-byte characters are a bit complicated to\n          // handle: They differ when any of the bytes differ\n          // and then their length may also differ.\n          if (sp->ts_tcharlen == 0) {\n            // First byte.\n            sp->ts_tcharidx = 0;\n            sp->ts_tcharlen = MB_BYTE2LEN(c);\n            sp->ts_fcharstart = sp->ts_fidx - 1;\n            sp->ts_isdiff = (newscore != 0)\n                            ? DIFF_YES : DIFF_NONE;\n          } else if (sp->ts_isdiff == DIFF_INSERT) {\n            // When inserting trail bytes don't advance in the\n            // bad word.\n            sp->ts_fidx--;\n          }\n          if (++sp->ts_tcharidx == sp->ts_tcharlen) {\n            // Last byte of character.\n            if (sp->ts_isdiff == DIFF_YES) {\n              // Correct ts_fidx for the byte length of the\n              // character (we didn't check that before).\n              sp->ts_fidx = sp->ts_fcharstart\n                            + utfc_ptr2len(fword + sp->ts_fcharstart);\n\n              // For changing a composing character adjust\n              // the score from SCORE_SUBST to\n              // SCORE_SUBCOMP.\n              if (utf_iscomposing(utf_ptr2char(tword + sp->ts_twordlen\n                                               - sp->ts_tcharlen))\n                  && utf_iscomposing(utf_ptr2char(fword\n                                                  + sp->ts_fcharstart))) {\n                sp->ts_score -= SCORE_SUBST - SCORE_SUBCOMP;\n              } else if (\n                  !soundfold\n                  && slang->sl_has_map\n                  && similar_chars(\n                      slang,\n                      utf_ptr2char(tword + sp->ts_twordlen - sp->ts_tcharlen),\n                      utf_ptr2char(fword + sp->ts_fcharstart))) {\n                // For a similar character adjust score from\n                // SCORE_SUBST to SCORE_SIMILAR.\n                sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n              }\n            } else if (sp->ts_isdiff == DIFF_INSERT\n                       && sp->ts_twordlen > sp->ts_tcharlen) {\n              p = tword + sp->ts_twordlen - sp->ts_tcharlen;\n              c = utf_ptr2char(p);\n              if (utf_iscomposing(c)) {\n                // Inserting a composing char doesn't\n                // count that much.\n                sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n              } else {\n                // If the previous character was the same,\n                // thus doubling a character, give a bonus\n                // to the score.  Also for the soundfold\n                // tree (might seem illogical but does\n                // give better scores).\n                MB_PTR_BACK(tword, p);\n                if (c == utf_ptr2char(p)) {\n                  sp->ts_score -= SCORE_INS - SCORE_INSDUP;\n                }\n              }\n            }\n\n            // Starting a new char, reset the length.\n            sp->ts_tcharlen = 0;\n          }\n        }\n      }\n      break;\n\n    case STATE_DEL:\n      // When past the first byte of a multi-byte char don't try\n      // delete/insert/swap a character.\n      if (sp->ts_tcharlen > 0) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_FINAL;\n        break;\n      }\n      // Try skipping one character in the bad word (delete it).\n      PROF_STORE(sp->ts_state)\n      sp->ts_state = STATE_INS_PREP;\n      sp->ts_curi = 1;\n      if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n        // Deleting a vowel at the start of a word counts less, see\n        // soundalike_score().\n        newscore = 2 * SCORE_DEL / 3;\n      else\n        newscore = SCORE_DEL;\n      if (fword[sp->ts_fidx] != NUL\n          && TRY_DEEPER(su, stack, depth, newscore)) {\n        go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n        sprintf(changename[depth], \"%.*s-%s: delete %c\",\n            sp->ts_twordlen, tword, fword + sp->ts_fidx,\n            fword[sp->ts_fidx]);\n#endif\n        ++depth;\n\n        // Remember what character we deleted, so that we can avoid\n        // inserting it again.\n        stack[depth].ts_flags |= TSF_DIDDEL;\n        stack[depth].ts_delidx = sp->ts_fidx;\n\n        // Advance over the character in fword[].  Give a bonus to the\n        // score if the same character is following \"nn\" -> \"n\".  It's\n        // a bit illogical for soundfold tree but it does give better\n        // results.\n        c = utf_ptr2char(fword + sp->ts_fidx);\n        stack[depth].ts_fidx += utfc_ptr2len(fword + sp->ts_fidx);\n        if (utf_iscomposing(c)) {\n          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n        } else if (c == utf_ptr2char(fword + stack[depth].ts_fidx)) {\n          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n        }\n\n        break;\n      }\n      FALLTHROUGH;\n\n    case STATE_INS_PREP:\n      if (sp->ts_flags & TSF_DIDDEL) {\n        // If we just deleted a byte then inserting won't make sense,\n        // a substitute is always cheaper.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_SWAP;\n        break;\n      }\n\n      // skip over NUL bytes\n      n = sp->ts_arridx;\n      for (;; ) {\n        if (sp->ts_curi > byts[n]) {\n          // Only NUL bytes at this node, go to next state.\n          PROF_STORE(sp->ts_state)\n          sp->ts_state = STATE_SWAP;\n          break;\n        }\n        if (byts[n + sp->ts_curi] != NUL) {\n          // Found a byte to insert.\n          PROF_STORE(sp->ts_state)\n          sp->ts_state = STATE_INS;\n          break;\n        }\n        ++sp->ts_curi;\n      }\n      break;\n\n    case STATE_INS:\n      // Insert one byte.  Repeat this for each possible byte at this\n      // node.\n      n = sp->ts_arridx;\n      if (sp->ts_curi > byts[n]) {\n        // Done all bytes at this node, go to next state.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_SWAP;\n        break;\n      }\n\n      // Do one more byte at this node, but:\n      // - Skip NUL bytes.\n      // - Skip the byte if it's equal to the byte in the word,\n      //   accepting that byte is always better.\n      n += sp->ts_curi++;\n      c = byts[n];\n      if (soundfold && sp->ts_twordlen == 0 && c == '*')\n        // Inserting a vowel at the start of a word counts less,\n        // see soundalike_score().\n        newscore = 2 * SCORE_INS / 3;\n      else\n        newscore = SCORE_INS;\n      if (c != fword[sp->ts_fidx]\n          && TRY_DEEPER(su, stack, depth, newscore)) {\n        go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n        sprintf(changename[depth], \"%.*s-%s: insert %c\",\n            sp->ts_twordlen, tword, fword + sp->ts_fidx,\n            c);\n#endif\n        ++depth;\n        sp = &stack[depth];\n        tword[sp->ts_twordlen++] = c;\n        sp->ts_arridx = idxs[n];\n        fl = MB_BYTE2LEN(c);\n        if (fl > 1) {\n          // There are following bytes for the same character.\n          // We must find all bytes before trying\n          // delete/insert/swap/etc.\n          sp->ts_tcharlen = fl;\n          sp->ts_tcharidx = 1;\n          sp->ts_isdiff = DIFF_INSERT;\n        }\n        if (fl == 1) {\n          // If the previous character was the same, thus doubling a\n          // character, give a bonus to the score.  Also for\n          // soundfold words (illogical but does give a better\n          // score).\n          if (sp->ts_twordlen >= 2\n              && tword[sp->ts_twordlen - 2] == c)\n            sp->ts_score -= SCORE_INS - SCORE_INSDUP;\n        }\n      }\n      break;\n\n    case STATE_SWAP:\n      // Swap two bytes in the bad word: \"12\" -> \"21\".\n      // We change \"fword\" here, it's changed back afterwards at\n      // STATE_UNSWAP.\n      p = fword + sp->ts_fidx;\n      c = *p;\n      if (c == NUL) {\n        // End of word, can't swap or replace.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_FINAL;\n        break;\n      }\n\n      // Don't swap if the first character is not a word character.\n      // SWAP3 etc. also don't make sense then.\n      if (!soundfold && !spell_iswordp(p, curwin)) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n        break;\n      }\n\n      n = MB_CPTR2LEN(p);\n      c = utf_ptr2char(p);\n      if (p[n] == NUL) {\n        c2 = NUL;\n      } else if (!soundfold && !spell_iswordp(p + n, curwin)) {\n        c2 = c;  // don't swap non-word char\n      } else {\n        c2 = utf_ptr2char(p + n);\n      }\n\n      // When the second character is NUL we can't swap.\n      if (c2 == NUL) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n        break;\n      }\n\n      // When characters are identical, swap won't do anything.\n      // Also get here if the second char is not a word character.\n      if (c == c2) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_SWAP3;\n        break;\n      }\n      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {\n        go_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n        snprintf(changename[depth], sizeof(changename[0]),\n                 \"%.*s-%s: swap %c and %c\",\n                 sp->ts_twordlen, tword, fword + sp->ts_fidx,\n                 c, c2);\n#endif\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_UNSWAP;\n        depth++;\n        fl = mb_char2len(c2);\n        memmove(p, p + n, fl);\n        utf_char2bytes(c, p + fl);\n        stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n      } else {\n        // If this swap doesn't work then SWAP3 won't either.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n      }\n      break;\n\n    case STATE_UNSWAP:\n      // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n      p = fword + sp->ts_fidx;\n      n = utfc_ptr2len(p);\n      c = utf_ptr2char(p + n);\n      memmove(p + utfc_ptr2len(p + n), p, n);\n      utf_char2bytes(c, p);\n\n      FALLTHROUGH;\n\n    case STATE_SWAP3:\n      // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n      // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n      p = fword + sp->ts_fidx;\n      n = MB_CPTR2LEN(p);\n      c = utf_ptr2char(p);\n      fl = MB_CPTR2LEN(p + n);\n      c2 = utf_ptr2char(p + n);\n      if (!soundfold && !spell_iswordp(p + n + fl, curwin)) {\n        c3 = c;  // don't swap non-word char\n      } else {\n        c3 = utf_ptr2char(p + n + fl);\n      }\n\n      // When characters are identical: \"121\" then SWAP3 result is\n      // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n      // same as SWAP on next char: \"112\".  Thus skip all swapping.\n      // Also skip when c3 is NUL.\n      // Also get here when the third character is not a word character.\n      // Second character may any char: \"a.b\" -> \"b.a\"\n      if (c == c3 || c3 == NUL) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n        break;\n      }\n      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {\n        go_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n            sp->ts_twordlen, tword, fword + sp->ts_fidx,\n            c, c3);\n#endif\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_UNSWAP3;\n        depth++;\n        tl = mb_char2len(c3);\n        memmove(p, p + n + fl, tl);\n        utf_char2bytes(c2, p + tl);\n        utf_char2bytes(c, p + fl + tl);\n        stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n      } else {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n      }\n      break;\n\n    case STATE_UNSWAP3:\n      // Undo STATE_SWAP3: \"321\" -> \"123\"\n      p = fword + sp->ts_fidx;\n      n = utfc_ptr2len(p);\n      c2 = utf_ptr2char(p + n);\n      fl = utfc_ptr2len(p + n);\n      c = utf_ptr2char(p + n + fl);\n      tl = utfc_ptr2len(p + n + fl);\n      memmove(p + fl + tl, p, n);\n      utf_char2bytes(c, p);\n      utf_char2bytes(c2, p + tl);\n      p = p + tl;\n\n      if (!soundfold && !spell_iswordp(p, curwin)) {\n        // Middle char is not a word char, skip the rotate.  First and\n        // third char were already checked at swap and swap3.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n        break;\n      }\n\n      // Rotate three characters left: \"123\" -> \"231\".  We change\n      // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {\n        go_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n        p = fword + sp->ts_fidx;\n        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n            sp->ts_twordlen, tword, fword + sp->ts_fidx,\n            p[0], p[1], p[2]);\n#endif\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_UNROT3L;\n        ++depth;\n        p = fword + sp->ts_fidx;\n        n = MB_CPTR2LEN(p);\n        c = utf_ptr2char(p);\n        fl = MB_CPTR2LEN(p + n);\n        fl += MB_CPTR2LEN(p + n + fl);\n        memmove(p, p + n, fl);\n        utf_char2bytes(c, p + fl);\n        stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n      } else {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n      }\n      break;\n\n    case STATE_UNROT3L:\n      // Undo ROT3L: \"231\" -> \"123\"\n      p = fword + sp->ts_fidx;\n      n = utfc_ptr2len(p);\n      n += utfc_ptr2len(p + n);\n      c = utf_ptr2char(p + n);\n      tl = utfc_ptr2len(p + n);\n      memmove(p + tl, p, n);\n      utf_char2bytes(c, p);\n\n      // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n      // here, it's changed back afterwards at STATE_UNROT3R.\n      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {\n        go_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n        p = fword + sp->ts_fidx;\n        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n            sp->ts_twordlen, tword, fword + sp->ts_fidx,\n            p[0], p[1], p[2]);\n#endif\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_UNROT3R;\n        ++depth;\n        p = fword + sp->ts_fidx;\n        n = MB_CPTR2LEN(p);\n        n += MB_CPTR2LEN(p + n);\n        c = utf_ptr2char(p + n);\n        tl = MB_CPTR2LEN(p + n);\n        memmove(p + tl, p, n);\n        utf_char2bytes(c, p);\n        stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n      } else {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_REP_INI;\n      }\n      break;\n\n    case STATE_UNROT3R:\n      // Undo ROT3R: \"312\" -> \"123\"\n      p = fword + sp->ts_fidx;\n      c = utf_ptr2char(p);\n      tl = utfc_ptr2len(p);\n      n = utfc_ptr2len(p + tl);\n      n += utfc_ptr2len(p + tl + n);\n      memmove(p, p + tl, n);\n      utf_char2bytes(c, p + n);\n\n      FALLTHROUGH;\n\n    case STATE_REP_INI:\n      // Check if matching with REP items from the .aff file would work.\n      // Quickly skip if:\n      // - there are no REP items and we are not in the soundfold trie\n      // - the score is going to be too high anyway\n      // - already applied a REP item or swapped here\n      if ((lp->lp_replang == NULL && !soundfold)\n          || sp->ts_score + SCORE_REP >= su->su_maxscore\n          || sp->ts_fidx < sp->ts_fidxtry) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_FINAL;\n        break;\n      }\n\n      // Use the first byte to quickly find the first entry that may\n      // match.  If the index is -1 there is none.\n      if (soundfold)\n        sp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n      else\n        sp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n      if (sp->ts_curi < 0) {\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_FINAL;\n        break;\n      }\n\n      PROF_STORE(sp->ts_state)\n      sp->ts_state = STATE_REP;\n      FALLTHROUGH;\n\n    case STATE_REP:\n      // Try matching with REP items from the .aff file.  For each match\n      // replace the characters and check if the resulting word is\n      // valid.\n      p = fword + sp->ts_fidx;\n\n      if (soundfold)\n        gap = &slang->sl_repsal;\n      else\n        gap = &lp->lp_replang->sl_rep;\n      while (sp->ts_curi < gap->ga_len) {\n        ftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n        if (*ftp->ft_from != *p) {\n          // past possible matching entries\n          sp->ts_curi = gap->ga_len;\n          break;\n        }\n        if (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n            && TRY_DEEPER(su, stack, depth, SCORE_REP)) {\n          go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n              sp->ts_twordlen, tword, fword + sp->ts_fidx,\n              ftp->ft_from, ftp->ft_to);\n#endif\n          // Need to undo this afterwards.\n          PROF_STORE(sp->ts_state)\n          sp->ts_state = STATE_REP_UNDO;\n\n          // Change the \"from\" to the \"to\" string.\n          ++depth;\n          fl = (int)STRLEN(ftp->ft_from);\n          tl = (int)STRLEN(ftp->ft_to);\n          if (fl != tl) {\n            STRMOVE(p + tl, p + fl);\n            repextra += tl - fl;\n          }\n          memmove(p, ftp->ft_to, tl);\n          stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n          stack[depth].ts_tcharlen = 0;\n          break;\n        }\n      }\n\n      if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n        // No (more) matches.\n        PROF_STORE(sp->ts_state)\n        sp->ts_state = STATE_FINAL;\n\n      break;\n\n    case STATE_REP_UNDO:\n      // Undo a REP replacement and continue with the next one.\n      if (soundfold)\n        gap = &slang->sl_repsal;\n      else\n        gap = &lp->lp_replang->sl_rep;\n      ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n      fl = (int)STRLEN(ftp->ft_from);\n      tl = (int)STRLEN(ftp->ft_to);\n      p = fword + sp->ts_fidx;\n      if (fl != tl) {\n        STRMOVE(p + fl, p + tl);\n        repextra -= tl - fl;\n      }\n      memmove(p, ftp->ft_from, fl);\n      PROF_STORE(sp->ts_state)\n      sp->ts_state = STATE_REP;\n      break;\n\n    default:\n      // Did all possible states at this level, go up one level.\n      --depth;\n\n      if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {\n        // Continue in or go back to the prefix tree.\n        byts = pbyts;\n        idxs = pidxs;\n      }\n\n      // Don't check for CTRL-C too often, it takes time.\n      if (--breakcheckcount == 0) {\n        os_breakcheck();\n        breakcheckcount = 1000;\n      }\n    }\n  }\n}\n\n\n// Go one level deeper in the tree.\nstatic void go_deeper(trystate_T *stack, int depth, int score_add)\n{\n  stack[depth + 1] = stack[depth];\n  stack[depth + 1].ts_state = STATE_START;\n  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;\n  stack[depth + 1].ts_curi = 1;         // start just after length byte\n  stack[depth + 1].ts_flags = 0;\n}\n\n// Case-folding may change the number of bytes: Count nr of chars in\n// fword[flen] and return the byte length of that many chars in \"word\".\nstatic int nofold_len(char_u *fword, int flen, char_u *word)\n{\n  char_u      *p;\n  int i = 0;\n\n  for (p = fword; p < fword + flen; MB_PTR_ADV(p)) {\n    i++;\n  }\n  for (p = word; i > 0; MB_PTR_ADV(p)) {\n    i--;\n  }\n  return (int)(p - word);\n}\n\n// \"fword\" is a good word with case folded.  Find the matching keep-case\n// words and put it in \"kword\".\n// Theoretically there could be several keep-case words that result in the\n// same case-folded word, but we only find one...\nstatic void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)\n{\n  char_u uword[MAXWLEN];                // \"fword\" in upper-case\n  int depth;\n  idx_T tryidx;\n\n  // The following arrays are used at each depth in the tree.\n  idx_T arridx[MAXWLEN];\n  int round[MAXWLEN];\n  int fwordidx[MAXWLEN];\n  int uwordidx[MAXWLEN];\n  int kwordlen[MAXWLEN];\n\n  int flen, ulen;\n  int l;\n  int len;\n  int c;\n  idx_T lo, hi, m;\n  char_u      *p;\n  char_u      *byts = slang->sl_kbyts;      // array with bytes of the words\n  idx_T       *idxs = slang->sl_kidxs;      // array with indexes\n\n  if (byts == NULL) {\n    // array is empty: \"cannot happen\"\n    *kword = NUL;\n    return;\n  }\n\n  // Make an all-cap version of \"fword\".\n  allcap_copy(fword, uword);\n\n  // Each character needs to be tried both case-folded and upper-case.\n  // All this gets very complicated if we keep in mind that changing case\n  // may change the byte length of a multi-byte character...\n  depth = 0;\n  arridx[0] = 0;\n  round[0] = 0;\n  fwordidx[0] = 0;\n  uwordidx[0] = 0;\n  kwordlen[0] = 0;\n  while (depth >= 0) {\n    if (fword[fwordidx[depth]] == NUL) {\n      // We are at the end of \"fword\".  If the tree allows a word to end\n      // here we have found a match.\n      if (byts[arridx[depth] + 1] == 0) {\n        kword[kwordlen[depth]] = NUL;\n        return;\n      }\n\n      // kword is getting too long, continue one level up\n      --depth;\n    } else if (++round[depth] > 2)   {\n      // tried both fold-case and upper-case character, continue one\n      // level up\n      --depth;\n    } else {\n      // round[depth] == 1: Try using the folded-case character.\n      // round[depth] == 2: Try using the upper-case character.\n      flen = MB_CPTR2LEN(fword + fwordidx[depth]);\n      ulen = MB_CPTR2LEN(uword + uwordidx[depth]);\n      if (round[depth] == 1) {\n        p = fword + fwordidx[depth];\n        l = flen;\n      } else {\n        p = uword + uwordidx[depth];\n        l = ulen;\n      }\n\n      for (tryidx = arridx[depth]; l > 0; --l) {\n        // Perform a binary search in the list of accepted bytes.\n        len = byts[tryidx++];\n        c = *p++;\n        lo = tryidx;\n        hi = tryidx + len - 1;\n        while (lo < hi) {\n          m = (lo + hi) / 2;\n          if (byts[m] > c)\n            hi = m - 1;\n          else if (byts[m] < c)\n            lo = m + 1;\n          else {\n            lo = hi = m;\n            break;\n          }\n        }\n\n        // Stop if there is no matching byte.\n        if (hi < lo || byts[lo] != c)\n          break;\n\n        // Continue at the child (if there is one).\n        tryidx = idxs[lo];\n      }\n\n      if (l == 0) {\n        // Found the matching char.  Copy it to \"kword\" and go a\n        // level deeper.\n        if (round[depth] == 1) {\n          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],\n              flen);\n          kwordlen[depth + 1] = kwordlen[depth] + flen;\n        } else {\n          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],\n              ulen);\n          kwordlen[depth + 1] = kwordlen[depth] + ulen;\n        }\n        fwordidx[depth + 1] = fwordidx[depth] + flen;\n        uwordidx[depth + 1] = uwordidx[depth] + ulen;\n\n        ++depth;\n        arridx[depth] = tryidx;\n        round[depth] = 0;\n      }\n    }\n  }\n\n  // Didn't find it: \"cannot happen\".\n  *kword = NUL;\n}\n\n// Compute the sound-a-like score for suggestions in su->su_ga and add them to\n// su->su_sga.\nstatic void score_comp_sal(suginfo_T *su)\n{\n  langp_T     *lp;\n  char_u badsound[MAXWLEN];\n  int i;\n  suggest_T   *stp;\n  suggest_T   *sstp;\n  int score;\n\n  ga_grow(&su->su_sga, su->su_ga.ga_len);\n\n  // Use the sound-folding of the first language that supports it.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    if (!GA_EMPTY(&lp->lp_slang->sl_sal)) {\n      // soundfold the bad word\n      spell_soundfold(lp->lp_slang, su->su_fbadword, true, badsound);\n\n      for (i = 0; i < su->su_ga.ga_len; ++i) {\n        stp = &SUG(su->su_ga, i);\n\n        // Case-fold the suggested word, sound-fold it and compute the\n        // sound-a-like score.\n        score = stp_sal_score(stp, su, lp->lp_slang, badsound);\n        if (score < SCORE_MAXMAX) {\n          // Add the suggestion.\n          sstp = &SUG(su->su_sga, su->su_sga.ga_len);\n          sstp->st_word = vim_strsave(stp->st_word);\n          sstp->st_wordlen = stp->st_wordlen;\n          sstp->st_score = score;\n          sstp->st_altscore = 0;\n          sstp->st_orglen = stp->st_orglen;\n          ++su->su_sga.ga_len;\n        }\n      }\n      break;\n    }\n  }\n}\n\n// Combine the list of suggestions in su->su_ga and su->su_sga.\n// They are entwined.\nstatic void score_combine(suginfo_T *su)\n{\n  garray_T ga;\n  garray_T    *gap;\n  langp_T     *lp;\n  suggest_T   *stp;\n  char_u      *p;\n  char_u badsound[MAXWLEN];\n  int round;\n  slang_T     *slang = NULL;\n\n  // Add the alternate score to su_ga.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    if (!GA_EMPTY(&lp->lp_slang->sl_sal)) {\n      // soundfold the bad word\n      slang = lp->lp_slang;\n      spell_soundfold(slang, su->su_fbadword, true, badsound);\n\n      for (int i = 0; i < su->su_ga.ga_len; ++i) {\n        stp = &SUG(su->su_ga, i);\n        stp->st_altscore = stp_sal_score(stp, su, slang, badsound);\n        if (stp->st_altscore == SCORE_MAXMAX)\n          stp->st_score = (stp->st_score * 3 + SCORE_BIG) / 4;\n        else\n          stp->st_score = (stp->st_score * 3\n                           + stp->st_altscore) / 4;\n        stp->st_salscore = false;\n      }\n      break;\n    }\n  }\n\n  if (slang == NULL) {  // Using \"double\" without sound folding.\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore,\n        su->su_maxcount);\n    return;\n  }\n\n  // Add the alternate score to su_sga.\n  for (int i = 0; i < su->su_sga.ga_len; ++i) {\n    stp = &SUG(su->su_sga, i);\n    stp->st_altscore = spell_edit_score(slang,\n        su->su_badword, stp->st_word);\n    if (stp->st_score == SCORE_MAXMAX)\n      stp->st_score = (SCORE_BIG * 7 + stp->st_altscore) / 8;\n    else\n      stp->st_score = (stp->st_score * 7 + stp->st_altscore) / 8;\n    stp->st_salscore = true;\n  }\n\n  // Remove bad suggestions, sort the suggestions and truncate at \"maxcount\"\n  // for both lists.\n  check_suggestions(su, &su->su_ga);\n  (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n  check_suggestions(su, &su->su_sga);\n  (void)cleanup_suggestions(&su->su_sga, su->su_maxscore, su->su_maxcount);\n\n  ga_init(&ga, (int)sizeof(suginfo_T), 1);\n  ga_grow(&ga, su->su_ga.ga_len + su->su_sga.ga_len);\n\n  stp = &SUG(ga, 0);\n  for (int i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i) {\n    // round 1: get a suggestion from su_ga\n    // round 2: get a suggestion from su_sga\n    for (round = 1; round <= 2; ++round) {\n      gap = round == 1 ? &su->su_ga : &su->su_sga;\n      if (i < gap->ga_len) {\n        // Don't add a word if it's already there.\n        p = SUG(*gap, i).st_word;\n        int j;\n        for (j = 0; j < ga.ga_len; ++j)\n          if (STRCMP(stp[j].st_word, p) == 0)\n            break;\n        if (j == ga.ga_len)\n          stp[ga.ga_len++] = SUG(*gap, i);\n        else\n          xfree(p);\n      }\n    }\n  }\n\n  ga_clear(&su->su_ga);\n  ga_clear(&su->su_sga);\n\n  // Truncate the list to the number of suggestions that will be displayed.\n  if (ga.ga_len > su->su_maxcount) {\n    for (int i = su->su_maxcount; i < ga.ga_len; ++i) {\n      xfree(stp[i].st_word);\n    }\n    ga.ga_len = su->su_maxcount;\n  }\n\n  su->su_ga = ga;\n}\n\n// For the goodword in \"stp\" compute the soundalike score compared to the\n// badword.\nstatic int\nstp_sal_score (\n    suggest_T *stp,\n    suginfo_T *su,\n    slang_T *slang,\n    char_u *badsound          // sound-folded badword\n)\n{\n  char_u      *p;\n  char_u      *pbad;\n  char_u      *pgood;\n  char_u badsound2[MAXWLEN];\n  char_u fword[MAXWLEN];\n  char_u goodsound[MAXWLEN];\n  char_u goodword[MAXWLEN];\n  int lendiff;\n\n  lendiff = su->su_badlen - stp->st_orglen;\n  if (lendiff >= 0)\n    pbad = badsound;\n  else {\n    // soundfold the bad word with more characters following\n    (void)spell_casefold(curwin, su->su_badptr, stp->st_orglen, fword, MAXWLEN);\n\n    // When joining two words the sound often changes a lot.  E.g., \"t he\"\n    // sounds like \"t h\" while \"the\" sounds like \"@\".  Avoid that by\n    // removing the space.  Don't do it when the good word also contains a\n    // space.\n    if (ascii_iswhite(su->su_badptr[su->su_badlen])\n        && *skiptowhite(stp->st_word) == NUL)\n      for (p = fword; *(p = skiptowhite(p)) != NUL; )\n        STRMOVE(p, p + 1);\n\n    spell_soundfold(slang, fword, true, badsound2);\n    pbad = badsound2;\n  }\n\n  if (lendiff > 0 && stp->st_wordlen + lendiff < MAXWLEN) {\n    // Add part of the bad word to the good word, so that we soundfold\n    // what replaces the bad word.\n    STRCPY(goodword, stp->st_word);\n    STRLCPY(goodword + stp->st_wordlen,\n        su->su_badptr + su->su_badlen - lendiff, lendiff + 1);\n    pgood = goodword;\n  } else\n    pgood = stp->st_word;\n\n  // Sound-fold the word and compute the score for the difference.\n  spell_soundfold(slang, pgood, false, goodsound);\n\n  return soundalike_score(goodsound, pbad);\n}\n\nstatic sftword_T dumsft;\n#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&dumsft)))\n#define HI2SFT(hi)     HIKEY2SFT((hi)->hi_key)\n\n// Prepare for calling suggest_try_soundalike().\nstatic void suggest_try_soundalike_prep(void)\n{\n  langp_T     *lp;\n  slang_T     *slang;\n\n  // Do this for all languages that support sound folding and for which a\n  // .sug file has been loaded.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    slang = lp->lp_slang;\n    if (!GA_EMPTY(&slang->sl_sal) && slang->sl_sbyts != NULL)\n      // prepare the hashtable used by add_sound_suggest()\n      hash_init(&slang->sl_sounddone);\n  }\n}\n\n// Find suggestions by comparing the word in a sound-a-like form.\n// Note: This doesn't support postponed prefixes.\nstatic void suggest_try_soundalike(suginfo_T *su)\n{\n  char_u salword[MAXWLEN];\n  langp_T     *lp;\n  slang_T     *slang;\n\n  // Do this for all languages that support sound folding and for which a\n  // .sug file has been loaded.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    slang = lp->lp_slang;\n    if (!GA_EMPTY(&slang->sl_sal) && slang->sl_sbyts != NULL) {\n      // soundfold the bad word\n      spell_soundfold(slang, su->su_fbadword, true, salword);\n\n      // try all kinds of inserts/deletes/swaps/etc.\n      // TODO: also soundfold the next words, so that we can try joining\n      // and splitting\n#ifdef SUGGEST_PROFILE\n      prof_init();\n#endif\n      suggest_trie_walk(su, lp, salword, true);\n#ifdef SUGGEST_PROFILE\n      prof_report(\"soundalike\");\n#endif\n    }\n  }\n}\n\n// Finish up after calling suggest_try_soundalike().\nstatic void suggest_try_soundalike_finish(void)\n{\n  langp_T     *lp;\n  slang_T     *slang;\n  int todo;\n  hashitem_T  *hi;\n\n  // Do this for all languages that support sound folding and for which a\n  // .sug file has been loaded.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    slang = lp->lp_slang;\n    if (!GA_EMPTY(&slang->sl_sal) && slang->sl_sbyts != NULL) {\n      // Free the info about handled words.\n      todo = (int)slang->sl_sounddone.ht_used;\n      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi)\n        if (!HASHITEM_EMPTY(hi)) {\n          xfree(HI2SFT(hi));\n          --todo;\n        }\n\n      // Clear the hashtable, it may also be used by another region.\n      hash_clear(&slang->sl_sounddone);\n      hash_init(&slang->sl_sounddone);\n    }\n  }\n}\n\n// A match with a soundfolded word is found.  Add the good word(s) that\n// produce this soundfolded word.\nstatic void\nadd_sound_suggest (\n    suginfo_T *su,\n    char_u *goodword,\n    int score,                      // soundfold score\n    langp_T *lp\n)\n{\n  slang_T     *slang = lp->lp_slang;    // language for sound folding\n  int sfwordnr;\n  char_u      *nrline;\n  int orgnr;\n  char_u theword[MAXWLEN];\n  int i;\n  int wlen;\n  char_u      *byts;\n  idx_T       *idxs;\n  int n;\n  int wordcount;\n  int wc;\n  int goodscore;\n  hash_T hash;\n  hashitem_T  *hi;\n  sftword_T   *sft;\n  int bc, gc;\n  int limit;\n\n  // It's very well possible that the same soundfold word is found several\n  // times with different scores.  Since the following is quite slow only do\n  // the words that have a better score than before.  Use a hashtable to\n  // remember the words that have been done.\n  hash = hash_hash(goodword);\n  const size_t goodword_len = STRLEN(goodword);\n  hi = hash_lookup(&slang->sl_sounddone, (const char *)goodword, goodword_len,\n                   hash);\n  if (HASHITEM_EMPTY(hi)) {\n    sft = xmalloc(sizeof(sftword_T) + goodword_len);\n    sft->sft_score = score;\n    memcpy(sft->sft_word, goodword, goodword_len + 1);\n    hash_add_item(&slang->sl_sounddone, hi, sft->sft_word, hash);\n  } else {\n    sft = HI2SFT(hi);\n    if (score >= sft->sft_score)\n      return;\n    sft->sft_score = score;\n  }\n\n  // Find the word nr in the soundfold tree.\n  sfwordnr = soundfold_find(slang, goodword);\n  if (sfwordnr < 0) {\n    internal_error(\"add_sound_suggest()\");\n    return;\n  }\n\n  // Go over the list of good words that produce this soundfold word\n  nrline = ml_get_buf(slang->sl_sugbuf, (linenr_T)sfwordnr + 1, false);\n  orgnr = 0;\n  while (*nrline != NUL) {\n    // The wordnr was stored in a minimal nr of bytes as an offset to the\n    // previous wordnr.\n    orgnr += bytes2offset(&nrline);\n\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    // Lookup the word \"orgnr\" one of the two tries.\n    n = 0;\n    wordcount = 0;\n    for (wlen = 0; wlen < MAXWLEN - 3; ++wlen) {\n      i = 1;\n      if (wordcount == orgnr && byts[n + 1] == NUL)\n        break;          // found end of word\n\n      if (byts[n + 1] == NUL)\n        ++wordcount;\n\n      // skip over the NUL bytes\n      for (; byts[n + i] == NUL; ++i)\n        if (i > byts[n]) {              // safety check\n          STRCPY(theword + wlen, \"BAD\");\n          wlen += 3;\n          goto badword;\n        }\n\n      // One of the siblings must have the word.\n      for (; i < byts[n]; ++i) {\n        wc = idxs[idxs[n + i]];         // nr of words under this byte\n        if (wordcount + wc > orgnr)\n          break;\n        wordcount += wc;\n      }\n\n      theword[wlen] = byts[n + i];\n      n = idxs[n + i];\n    }\nbadword:\n    theword[wlen] = NUL;\n\n    // Go over the possible flags and regions.\n    for (; i <= byts[n] && byts[n + i] == NUL; ++i) {\n      char_u cword[MAXWLEN];\n      char_u      *p;\n      int flags = (int)idxs[n + i];\n\n      // Skip words with the NOSUGGEST flag\n      if (flags & WF_NOSUGGEST)\n        continue;\n\n      if (flags & WF_KEEPCAP) {\n        // Must find the word in the keep-case tree.\n        find_keepcap_word(slang, theword, cword);\n        p = cword;\n      } else {\n        flags |= su->su_badflags;\n        if ((flags & WF_CAPMASK) != 0) {\n          // Need to fix case according to \"flags\".\n          make_case_word(theword, cword, flags);\n          p = cword;\n        } else\n          p = theword;\n      }\n\n      // Add the suggestion.\n      if (sps_flags & SPS_DOUBLE) {\n        // Add the suggestion if the score isn't too bad.\n        if (score <= su->su_maxscore)\n          add_suggestion(su, &su->su_sga, p, su->su_badlen,\n              score, 0, false, slang, false);\n      } else {\n        // Add a penalty for words in another region.\n        if ((flags & WF_REGION)\n            && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n          goodscore = SCORE_REGION;\n        else\n          goodscore = 0;\n\n        // Add a small penalty for changing the first letter from\n        // lower to upper case.  Helps for \"tath\" -> \"Kath\", which is\n        // less common than \"tath\" -> \"path\".  Don't do it when the\n        // letter is the same, that has already been counted.\n        gc = PTR2CHAR(p);\n        if (SPELL_ISUPPER(gc)) {\n          bc = PTR2CHAR(su->su_badword);\n          if (!SPELL_ISUPPER(bc)\n              && SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))\n            goodscore += SCORE_ICASE / 2;\n        }\n\n        // Compute the score for the good word.  This only does letter\n        // insert/delete/swap/replace.  REP items are not considered,\n        // which may make the score a bit higher.\n        // Use a limit for the score to make it work faster.  Use\n        // MAXSCORE(), because RESCORE() will change the score.\n        // If the limit is very high then the iterative method is\n        // inefficient, using an array is quicker.\n        limit = MAXSCORE(su->su_sfmaxscore - goodscore, score);\n        if (limit > SCORE_LIMITMAX)\n          goodscore += spell_edit_score(slang, su->su_badword, p);\n        else\n          goodscore += spell_edit_score_limit(slang, su->su_badword,\n              p, limit);\n\n        // When going over the limit don't bother to do the rest.\n        if (goodscore < SCORE_MAXMAX) {\n          // Give a bonus to words seen before.\n          goodscore = score_wordcount_adj(slang, goodscore, p, false);\n\n          // Add the suggestion if the score isn't too bad.\n          goodscore = RESCORE(goodscore, score);\n          if (goodscore <= su->su_sfmaxscore)\n            add_suggestion(su, &su->su_ga, p, su->su_badlen,\n                goodscore, score, true, slang, true);\n        }\n      }\n    }\n  }\n}\n\n// Find word \"word\" in fold-case tree for \"slang\" and return the word number.\nstatic int soundfold_find(slang_T *slang, char_u *word)\n{\n  idx_T arridx = 0;\n  int len;\n  int wlen = 0;\n  int c;\n  char_u      *ptr = word;\n  char_u      *byts;\n  idx_T       *idxs;\n  int wordnr = 0;\n\n  byts = slang->sl_sbyts;\n  idxs = slang->sl_sidxs;\n\n  for (;; ) {\n    // First byte is the number of possible bytes.\n    len = byts[arridx++];\n\n    // If the first possible byte is a zero the word could end here.\n    // If the word ends we found the word.  If not skip the NUL bytes.\n    c = ptr[wlen];\n    if (byts[arridx] == NUL) {\n      if (c == NUL)\n        break;\n\n      // Skip over the zeros, there can be several.\n      while (len > 0 && byts[arridx] == NUL) {\n        ++arridx;\n        --len;\n      }\n      if (len == 0)\n        return -1;            // no children, word should have ended here\n      ++wordnr;\n    }\n\n    // If the word ends we didn't find it.\n    if (c == NUL)\n      return -1;\n\n    // Perform a binary search in the list of accepted bytes.\n    if (c == TAB)           // <Tab> is handled like <Space>\n      c = ' ';\n    while (byts[arridx] < c) {\n      // The word count is in the first idxs[] entry of the child.\n      wordnr += idxs[idxs[arridx]];\n      ++arridx;\n      if (--len == 0)           // end of the bytes, didn't find it\n        return -1;\n    }\n    if (byts[arridx] != c)      // didn't find the byte\n      return -1;\n\n    // Continue at the child (if there is one).\n    arridx = idxs[arridx];\n    ++wlen;\n\n    // One space in the good word may stand for several spaces in the\n    // checked word.\n    if (c == ' ')\n      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)\n        ++wlen;\n  }\n\n  return wordnr;\n}\n\n// Copy \"fword\" to \"cword\", fixing case according to \"flags\".\nstatic void make_case_word(char_u *fword, char_u *cword, int flags)\n{\n  if (flags & WF_ALLCAP)\n    // Make it all upper-case\n    allcap_copy(fword, cword);\n  else if (flags & WF_ONECAP)\n    // Make the first letter upper-case\n    onecap_copy(fword, cword, true);\n  else\n    // Use goodword as-is.\n    STRCPY(cword, fword);\n}\n\n// Returns true if \"c1\" and \"c2\" are similar characters according to the MAP\n// lines in the .aff file.\nstatic bool similar_chars(slang_T *slang, int c1, int c2)\n{\n  int m1, m2;\n  char_u buf[MB_MAXBYTES + 1];\n  hashitem_T  *hi;\n\n  if (c1 >= 256) {\n    buf[utf_char2bytes(c1, buf)] = 0;\n    hi = hash_find(&slang->sl_map_hash, buf);\n    if (HASHITEM_EMPTY(hi)) {\n      m1 = 0;\n    } else {\n      m1 = utf_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n  } else {\n    m1 = slang->sl_map_array[c1];\n  }\n  if (m1 == 0) {\n    return false;\n  }\n\n  if (c2 >= 256) {\n    buf[utf_char2bytes(c2, buf)] = 0;\n    hi = hash_find(&slang->sl_map_hash, buf);\n    if (HASHITEM_EMPTY(hi)) {\n      m2 = 0;\n    } else {\n      m2 = utf_ptr2char(hi->hi_key + STRLEN(hi->hi_key) + 1);\n    }\n  } else {\n    m2 = slang->sl_map_array[c2];\n  }\n\n  return m1 == m2;\n}\n\n// Adds a suggestion to the list of suggestions.\n// For a suggestion that is already in the list the lowest score is remembered.\nstatic void\nadd_suggestion (\n    suginfo_T *su,\n    garray_T *gap,              // either su_ga or su_sga\n    const char_u *goodword,\n    int badlenarg,              // len of bad word replaced with \"goodword\"\n    int score,\n    int altscore,\n    bool had_bonus,             // value for st_had_bonus\n    slang_T *slang,             // language for sound folding\n    bool maxsf                  // su_maxscore applies to soundfold score,\n                                // su_sfmaxscore to the total score.\n)\n{\n  int goodlen;                  // len of goodword changed\n  int badlen;                   // len of bad word changed\n  suggest_T   *stp;\n  suggest_T new_sug;\n\n  // Minimize \"badlen\" for consistency.  Avoids that changing \"the the\" to\n  // \"thee the\" is added next to changing the first \"the\" the \"thee\".\n  const char_u *pgood = goodword + STRLEN(goodword);\n  char_u *pbad = su->su_badptr + badlenarg;\n  for (;; ) {\n    goodlen = (int)(pgood - goodword);\n    badlen = (int)(pbad - su->su_badptr);\n    if (goodlen <= 0 || badlen <= 0)\n      break;\n    MB_PTR_BACK(goodword, pgood);\n    MB_PTR_BACK(su->su_badptr, pbad);\n    if (utf_ptr2char(pgood) != utf_ptr2char(pbad)) {\n      break;\n    }\n  }\n\n  if (badlen == 0 && goodlen == 0)\n    // goodword doesn't change anything; may happen for \"the the\" changing\n    // the first \"the\" to itself.\n    return;\n\n  int i;\n  if (GA_EMPTY(gap)) {\n    i = -1;\n  } else {\n    // Check if the word is already there.  Also check the length that is\n    // being replaced \"thes,\" -> \"these\" is a different suggestion from\n    // \"thes\" -> \"these\".\n    stp = &SUG(*gap, 0);\n    for (i = gap->ga_len; --i >= 0; ++stp) {\n      if (stp->st_wordlen == goodlen\n          && stp->st_orglen == badlen\n          && STRNCMP(stp->st_word, goodword, goodlen) == 0) {\n        // Found it.  Remember the word with the lowest score.\n        if (stp->st_slang == NULL)\n          stp->st_slang = slang;\n\n        new_sug.st_score = score;\n        new_sug.st_altscore = altscore;\n        new_sug.st_had_bonus = had_bonus;\n\n        if (stp->st_had_bonus != had_bonus) {\n          // Only one of the two had the soundalike score computed.\n          // Need to do that for the other one now, otherwise the\n          // scores can't be compared.  This happens because\n          // suggest_try_change() doesn't compute the soundalike\n          // word to keep it fast, while some special methods set\n          // the soundalike score to zero.\n          if (had_bonus)\n            rescore_one(su, stp);\n          else {\n            new_sug.st_word = stp->st_word;\n            new_sug.st_wordlen = stp->st_wordlen;\n            new_sug.st_slang = stp->st_slang;\n            new_sug.st_orglen = badlen;\n            rescore_one(su, &new_sug);\n          }\n        }\n\n        if (stp->st_score > new_sug.st_score) {\n          stp->st_score = new_sug.st_score;\n          stp->st_altscore = new_sug.st_altscore;\n          stp->st_had_bonus = new_sug.st_had_bonus;\n        }\n        break;\n      }\n    }\n  }\n\n  if (i < 0) {\n    // Add a suggestion.\n    stp = GA_APPEND_VIA_PTR(suggest_T, gap);\n    stp->st_word = vim_strnsave(goodword, goodlen);\n    stp->st_wordlen = goodlen;\n    stp->st_score = score;\n    stp->st_altscore = altscore;\n    stp->st_had_bonus = had_bonus;\n    stp->st_orglen = badlen;\n    stp->st_slang = slang;\n\n    // If we have too many suggestions now, sort the list and keep\n    // the best suggestions.\n    if (gap->ga_len > SUG_MAX_COUNT(su)) {\n      if (maxsf)\n        su->su_sfmaxscore = cleanup_suggestions(gap,\n            su->su_sfmaxscore, SUG_CLEAN_COUNT(su));\n      else\n        su->su_maxscore = cleanup_suggestions(gap,\n            su->su_maxscore, SUG_CLEAN_COUNT(su));\n    }\n  }\n}\n\n// Suggestions may in fact be flagged as errors.  Esp. for banned words and\n// for split words, such as \"the the\".  Remove these from the list here.\nstatic void\ncheck_suggestions (\n    suginfo_T *su,\n    garray_T *gap                   // either su_ga or su_sga\n)\n{\n  suggest_T   *stp;\n  char_u longword[MAXWLEN + 1];\n  int len;\n  hlf_T attr;\n\n  if (gap->ga_len == 0) {\n    return;\n  }\n  stp = &SUG(*gap, 0);\n  for (int i = gap->ga_len - 1; i >= 0; --i) {\n    // Need to append what follows to check for \"the the\".\n    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);\n    len = stp[i].st_wordlen;\n    STRLCPY(longword + len, su->su_badptr + stp[i].st_orglen,\n        MAXWLEN - len + 1);\n    attr = HLF_COUNT;\n    (void)spell_check(curwin, longword, &attr, NULL, false);\n    if (attr != HLF_COUNT) {\n      // Remove this entry.\n      xfree(stp[i].st_word);\n      --gap->ga_len;\n      if (i < gap->ga_len)\n        memmove(stp + i, stp + i + 1,\n            sizeof(suggest_T) * (gap->ga_len - i));\n    }\n  }\n}\n\n\n// Add a word to be banned.\nstatic void add_banned(suginfo_T *su, char_u *word)\n{\n  char_u      *s;\n  hash_T hash;\n  hashitem_T  *hi;\n\n  hash = hash_hash(word);\n  const size_t word_len = STRLEN(word);\n  hi = hash_lookup(&su->su_banned, (const char *)word, word_len, hash);\n  if (HASHITEM_EMPTY(hi)) {\n    s = xmemdupz(word, word_len);\n    hash_add_item(&su->su_banned, hi, s, hash);\n  }\n}\n\n// Recompute the score for all suggestions if sound-folding is possible.  This\n// is slow, thus only done for the final results.\nstatic void rescore_suggestions(suginfo_T *su)\n{\n  if (su->su_sallang != NULL) {\n    for (int i = 0; i < su->su_ga.ga_len; ++i) {\n      rescore_one(su, &SUG(su->su_ga, i));\n    }\n  }\n}\n\n// Recompute the score for one suggestion if sound-folding is possible.\nstatic void rescore_one(suginfo_T *su, suggest_T *stp)\n{\n  slang_T     *slang = stp->st_slang;\n  char_u sal_badword[MAXWLEN];\n  char_u      *p;\n\n  // Only rescore suggestions that have no sal score yet and do have a\n  // language.\n  if (slang != NULL && !GA_EMPTY(&slang->sl_sal) && !stp->st_had_bonus) {\n    if (slang == su->su_sallang)\n      p = su->su_sal_badword;\n    else {\n      spell_soundfold(slang, su->su_fbadword, true, sal_badword);\n      p = sal_badword;\n    }\n\n    stp->st_altscore = stp_sal_score(stp, su, slang, p);\n    if (stp->st_altscore == SCORE_MAXMAX)\n      stp->st_altscore = SCORE_BIG;\n    stp->st_score = RESCORE(stp->st_score, stp->st_altscore);\n    stp->st_had_bonus = true;\n  }\n}\n\n\n// Function given to qsort() to sort the suggestions on st_score.\n// First on \"st_score\", then \"st_altscore\" then alphabetically.\nstatic int sug_compare(const void *s1, const void *s2)\n{\n  suggest_T   *p1 = (suggest_T *)s1;\n  suggest_T   *p2 = (suggest_T *)s2;\n  int n = p1->st_score - p2->st_score;\n\n  if (n == 0) {\n    n = p1->st_altscore - p2->st_altscore;\n    if (n == 0)\n      n = STRICMP(p1->st_word, p2->st_word);\n  }\n  return n;\n}\n\n// Cleanup the suggestions:\n// - Sort on score.\n// - Remove words that won't be displayed.\n// Returns the maximum score in the list or \"maxscore\" unmodified.\nstatic int\ncleanup_suggestions (\n    garray_T *gap,\n    int maxscore,\n    int keep                       // nr of suggestions to keep\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (gap->ga_len > 0) {\n    // Sort the list.\n    qsort(gap->ga_data, (size_t)gap->ga_len, sizeof(suggest_T), sug_compare);\n\n    // Truncate the list to the number of suggestions that will be displayed.\n    if (gap->ga_len > keep) {\n      suggest_T *const stp = &SUG(*gap, 0);\n\n      for (int i = keep; i < gap->ga_len; i++) {\n        xfree(stp[i].st_word);\n      }\n      gap->ga_len = keep;\n      if (keep >= 1) {\n        return stp[keep - 1].st_score;\n      }\n    }\n  }\n  return maxscore;\n}\n\n/// Soundfold a string, for soundfold()\n///\n/// @param[in]  word  Word to soundfold.\n///\n/// @return [allocated] soundfolded string or NULL in case of error. May return\n///                     copy of the input string if soundfolding is not\n///                     supported by any of the languages in &spellang.\nchar *eval_soundfold(const char *const word)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL\n{\n  if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL) {\n    // Use the sound-folding of the first language that supports it.\n    for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; lpi++) {\n      langp_T *const lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n      if (!GA_EMPTY(&lp->lp_slang->sl_sal)) {\n        // soundfold the word\n        char_u sound[MAXWLEN];\n        spell_soundfold(lp->lp_slang, (char_u *)word, false, sound);\n        return xstrdup((const char *)sound);\n      }\n    }\n  }\n\n  // No language with sound folding, return word as-is.\n  return xstrdup(word);\n}\n\n/// Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n///\n/// There are many ways to turn a word into a sound-a-like representation.  The\n/// oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n/// swedish name matching - survey and test of different algorithms\" by Klas\n/// Erikson.\n///\n/// We support two methods:\n/// 1. SOFOFROM/SOFOTO do a simple character mapping.\n/// 2. SAL items define a more advanced sound-folding (and much slower).\n///\n/// @param[in]  slang\n/// @param[in]  inword  word to soundfold\n/// @param[in]  folded  whether inword is already case-folded\n/// @param[in,out]  res  destination for soundfolded word\nvoid spell_soundfold(slang_T *slang, char_u *inword, bool folded, char_u *res)\n{\n  char_u fword[MAXWLEN];\n  char_u      *word;\n\n  if (slang->sl_sofo)\n    // SOFOFROM and SOFOTO used\n    spell_soundfold_sofo(slang, inword, res);\n  else {\n    // SAL items used.  Requires the word to be case-folded.\n    if (folded) {\n      word = inword;\n    } else {\n      (void)spell_casefold(curwin, inword, (int)STRLEN(inword), fword, MAXWLEN);\n      word = fword;\n    }\n\n    spell_soundfold_wsal(slang, word, res);\n  }\n}\n\n// Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n// SOFOTO lines.\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n  int ri = 0;\n\n  int prevc = 0;\n\n  // The sl_sal_first[] table contains the translation for chars up to\n  // 255, sl_sal the rest.\n  for (char_u *s = inword; *s != NUL; ) {\n    int c = mb_cptr2char_adv((const char_u **)&s);\n    if (utf_class(c) == 0) {\n      c = ' ';\n    } else if (c < 256) {\n      c = slang->sl_sal_first[c];\n    } else {\n      int *ip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n      if (ip == NULL) {               // empty list, can't match\n        c = NUL;\n      } else {\n        for (;; ) {                   // find \"c\" in the list\n          if (*ip == 0) {             // not found\n            c = NUL;\n            break;\n          }\n          if (*ip == c) {             // match!\n            c = ip[1];\n            break;\n          }\n          ip += 2;\n        }\n      }\n    }\n\n    if (c != NUL && c != prevc) {\n      ri += utf_char2bytes(c, res + ri);\n      if (ri + MB_MAXBYTES > MAXWLEN) {\n        break;\n      }\n      prevc = c;\n    }\n  }\n\n  res[ri] = NUL;\n}\n\n// Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n// Multi-byte version of spell_soundfold().\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n  salitem_T   *smp = (salitem_T *)slang->sl_sal.ga_data;\n  int word[MAXWLEN] = { 0 };\n  int wres[MAXWLEN] = { 0 };\n  int l;\n  int         *ws;\n  int         *pf;\n  int i, j, z;\n  int reslen;\n  int n, k = 0;\n  int z0;\n  int k0;\n  int n0;\n  int c;\n  int pri;\n  int p0 = -333;\n  int c0;\n  bool did_white = false;\n  int wordlen;\n\n\n  // Convert the multi-byte string to a wide-character string.\n  // Remove accents, if wanted.  We actually remove all non-word characters.\n  // But keep white space.\n  wordlen = 0;\n  for (const char_u *s = inword; *s != NUL; ) {\n    const char_u *t = s;\n    c = mb_cptr2char_adv((const char_u **)&s);\n    if (slang->sl_rem_accents) {\n      if (utf_class(c) == 0) {\n        if (did_white) {\n          continue;\n        }\n        c = ' ';\n        did_white = true;\n      } else {\n        did_white = false;\n        if (!spell_iswordp_nmw(t, curwin)) {\n          continue;\n        }\n      }\n    }\n    word[wordlen++] = c;\n  }\n  word[wordlen] = NUL;\n\n  // This algorithm comes from Aspell phonet.cpp.\n  // Converted from C++ to C.  Added support for multi-byte chars.\n  // Changed to keep spaces.\n  i = reslen = z = 0;\n  while ((c = word[i]) != NUL) {\n    // Start with the first rule that has the character in the word.\n    n = slang->sl_sal_first[c & 0xff];\n    z0 = 0;\n\n    if (n >= 0) {\n      // Check all rules for the same index byte.\n      // If c is 0x300 need extra check for the end of the array, as\n      // (c & 0xff) is NUL.\n      for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n           && ws[0] != NUL; ++n) {\n        // Quickly skip entries that don't match the word.  Most\n        // entries are less then three chars, optimize for that.\n        if (c != ws[0])\n          continue;\n        k = smp[n].sm_leadlen;\n        if (k > 1) {\n          if (word[i + 1] != ws[1])\n            continue;\n          if (k > 2) {\n            for (j = 2; j < k; ++j)\n              if (word[i + j] != ws[j])\n                break;\n            if (j < k)\n              continue;\n          }\n        }\n\n        if ((pf = smp[n].sm_oneof_w) != NULL) {\n          // Check for match with one of the chars in \"sm_oneof\".\n          while (*pf != NUL && *pf != word[i + k])\n            ++pf;\n          if (*pf == NUL)\n            continue;\n          ++k;\n        }\n        char_u *s = smp[n].sm_rules;\n        pri = 5;            // default priority\n\n        p0 = *s;\n        k0 = k;\n        while (*s == '-' && k > 1) {\n          k--;\n          s++;\n        }\n        if (*s == '<')\n          s++;\n        if (ascii_isdigit(*s)) {\n          // determine priority\n          pri = *s - '0';\n          s++;\n        }\n        if (*s == '^' && *(s + 1) == '^')\n          s++;\n\n        if (*s == NUL\n            || (*s == '^'\n                && (i == 0 || !(word[i - 1] == ' '\n                                || spell_iswordp_w(word + i - 1, curwin)))\n                && (*(s + 1) != '$'\n                    || (!spell_iswordp_w(word + i + k0, curwin))))\n            || (*s == '$' && i > 0\n                && spell_iswordp_w(word + i - 1, curwin)\n                && (!spell_iswordp_w(word + i + k0, curwin)))) {\n          // search for followup rules, if:\n          // followup and k > 1  and  NO '-' in searchstring\n          c0 = word[i + k - 1];\n          n0 = slang->sl_sal_first[c0 & 0xff];\n\n          if (slang->sl_followup && k > 1 && n0 >= 0\n              && p0 != '-' && word[i + k] != NUL) {\n            // Test follow-up rule for \"word[i + k]\"; loop over\n            // all entries with the same index byte.\n            for (; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n                 == (c0 & 0xff); ++n0) {\n              // Quickly skip entries that don't match the word.\n              if (c0 != ws[0])\n                continue;\n              k0 = smp[n0].sm_leadlen;\n              if (k0 > 1) {\n                if (word[i + k] != ws[1])\n                  continue;\n                if (k0 > 2) {\n                  pf = word + i + k + 1;\n                  for (j = 2; j < k0; ++j)\n                    if (*pf++ != ws[j])\n                      break;\n                  if (j < k0)\n                    continue;\n                }\n              }\n              k0 += k - 1;\n\n              if ((pf = smp[n0].sm_oneof_w) != NULL) {\n                // Check for match with one of the chars in\n                // \"sm_oneof\".\n                while (*pf != NUL && *pf != word[i + k0])\n                  ++pf;\n                if (*pf == NUL)\n                  continue;\n                ++k0;\n              }\n\n              p0 = 5;\n              s = smp[n0].sm_rules;\n              while (*s == '-') {\n                // \"k0\" gets NOT reduced because\n                // \"if (k0 == k)\"\n                s++;\n              }\n              if (*s == '<')\n                s++;\n              if (ascii_isdigit(*s)) {\n                p0 = *s - '0';\n                s++;\n              }\n\n              if (*s == NUL\n                  // *s == '^' cuts\n                  || (*s == '$'\n                      && !spell_iswordp_w(word + i + k0,\n                          curwin))) {\n                if (k0 == k)\n                  // this is just a piece of the string\n                  continue;\n\n                if (p0 < pri)\n                  // priority too low\n                  continue;\n                // rule fits; stop search\n                break;\n              }\n            }\n\n            if (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n                == (c0 & 0xff))\n              continue;\n          }\n\n          // replace string\n          ws = smp[n].sm_to_w;\n          s = smp[n].sm_rules;\n          p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n          if (p0 == 1 && z == 0) {\n            // rule with '<' is used\n            if (reslen > 0 && ws != NULL && *ws != NUL\n                && (wres[reslen - 1] == c\n                    || wres[reslen - 1] == *ws))\n              reslen--;\n            z0 = 1;\n            z = 1;\n            k0 = 0;\n            if (ws != NULL)\n              while (*ws != NUL && word[i + k0] != NUL) {\n                word[i + k0] = *ws;\n                k0++;\n                ws++;\n              }\n            if (k > k0)\n              memmove(word + i + k0, word + i + k,\n                  sizeof(int) * (wordlen - (i + k) + 1));\n\n            // new \"actual letter\"\n            c = word[i];\n          } else {\n            // no '<' rule used\n            i += k - 1;\n            z = 0;\n            if (ws != NULL)\n              while (*ws != NUL && ws[1] != NUL\n                     && reslen < MAXWLEN) {\n                if (reslen == 0 || wres[reslen - 1] != *ws)\n                  wres[reslen++] = *ws;\n                ws++;\n              }\n            // new \"actual letter\"\n            if (ws == NULL)\n              c = NUL;\n            else\n              c = *ws;\n            if (strstr((char *)s, \"^^\") != NULL) {\n              if (c != NUL)\n                wres[reslen++] = c;\n              memmove(word, word + i + 1,\n                  sizeof(int) * (wordlen - (i + 1) + 1));\n              i = 0;\n              z0 = 1;\n            }\n          }\n          break;\n        }\n      }\n    } else if (ascii_iswhite(c))   {\n      c = ' ';\n      k = 1;\n    }\n\n    if (z0 == 0) {\n      if (k && !p0 && reslen < MAXWLEN && c != NUL\n          && (!slang->sl_collapse || reslen == 0\n              || wres[reslen - 1] != c))\n        // condense only double letters\n        wres[reslen++] = c;\n\n      i++;\n      z = 0;\n      k = 0;\n    }\n  }\n\n  // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n  l = 0;\n  for (n = 0; n < reslen; n++) {\n    l += utf_char2bytes(wres[n], res + l);\n    if (l + MB_MAXBYTES > MAXWLEN) {\n      break;\n    }\n  }\n  res[l] = NUL;\n}\n\n// Compute a score for two sound-a-like words.\n// This permits up to two inserts/deletes/swaps/etc. to keep things fast.\n// Instead of a generic loop we write out the code.  That keeps it fast by\n// avoiding checks that will not be possible.\nstatic int\nsoundalike_score (\n    char_u *goodstart,         // sound-folded good word\n    char_u *badstart          // sound-folded bad word\n)\n{\n  char_u      *goodsound = goodstart;\n  char_u      *badsound = badstart;\n  int goodlen;\n  int badlen;\n  int n;\n  char_u      *pl, *ps;\n  char_u      *pl2, *ps2;\n  int score = 0;\n\n  // Adding/inserting \"*\" at the start (word starts with vowel) shouldn't be\n  // counted so much, vowels in the middle of the word aren't counted at all.\n  if ((*badsound == '*' || *goodsound == '*') && *badsound != *goodsound) {\n    if ((badsound[0] == NUL && goodsound[1] == NUL)\n        || (goodsound[0] == NUL && badsound[1] == NUL))\n      // changing word with vowel to word without a sound\n      return SCORE_DEL;\n    if (badsound[0] == NUL || goodsound[0] == NUL)\n      // more than two changes\n      return SCORE_MAXMAX;\n\n    if (badsound[1] == goodsound[1]\n        || (badsound[1] != NUL\n            && goodsound[1] != NUL\n            && badsound[2] == goodsound[2])) {\n      // handle like a substitute\n    } else {\n      score = 2 * SCORE_DEL / 3;\n      if (*badsound == '*')\n        ++badsound;\n      else\n        ++goodsound;\n    }\n  }\n\n  goodlen = (int)STRLEN(goodsound);\n  badlen = (int)STRLEN(badsound);\n\n  // Return quickly if the lengths are too different to be fixed by two\n  // changes.\n  n = goodlen - badlen;\n  if (n < -2 || n > 2)\n    return SCORE_MAXMAX;\n\n  if (n > 0) {\n    pl = goodsound;         // goodsound is longest\n    ps = badsound;\n  } else {\n    pl = badsound;          // badsound is longest\n    ps = goodsound;\n  }\n\n  // Skip over the identical part.\n  while (*pl == *ps && *pl != NUL) {\n    ++pl;\n    ++ps;\n  }\n\n  switch (n) {\n  case -2:\n  case 2:\n    // Must delete two characters from \"pl\".\n    ++pl;               // first delete\n    while (*pl == *ps) {\n      ++pl;\n      ++ps;\n    }\n    // strings must be equal after second delete\n    if (STRCMP(pl + 1, ps) == 0)\n      return score + SCORE_DEL * 2;\n\n    // Failed to compare.\n    break;\n\n  case -1:\n  case 1:\n    // Minimal one delete from \"pl\" required.\n\n    // 1: delete\n    pl2 = pl + 1;\n    ps2 = ps;\n    while (*pl2 == *ps2) {\n      if (*pl2 == NUL)                  // reached the end\n        return score + SCORE_DEL;\n      ++pl2;\n      ++ps2;\n    }\n\n    // 2: delete then swap, then rest must be equal\n    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n        && STRCMP(pl2 + 2, ps2 + 2) == 0)\n      return score + SCORE_DEL + SCORE_SWAP;\n\n    // 3: delete then substitute, then the rest must be equal\n    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n      return score + SCORE_DEL + SCORE_SUBST;\n\n    // 4: first swap then delete\n    if (pl[0] == ps[1] && pl[1] == ps[0]) {\n      pl2 = pl + 2;                 // swap, skip two chars\n      ps2 = ps + 2;\n      while (*pl2 == *ps2) {\n        ++pl2;\n        ++ps2;\n      }\n      // delete a char and then strings must be equal\n      if (STRCMP(pl2 + 1, ps2) == 0)\n        return score + SCORE_SWAP + SCORE_DEL;\n    }\n\n    // 5: first substitute then delete\n    pl2 = pl + 1;                   // substitute, skip one char\n    ps2 = ps + 1;\n    while (*pl2 == *ps2) {\n      ++pl2;\n      ++ps2;\n    }\n    // delete a char and then strings must be equal\n    if (STRCMP(pl2 + 1, ps2) == 0)\n      return score + SCORE_SUBST + SCORE_DEL;\n\n    // Failed to compare.\n    break;\n\n  case 0:\n    // Lengths are equal, thus changes must result in same length: An\n    // insert is only possible in combination with a delete.\n    // 1: check if for identical strings\n    if (*pl == NUL)\n      return score;\n\n    // 2: swap\n    if (pl[0] == ps[1] && pl[1] == ps[0]) {\n      pl2 = pl + 2;                 // swap, skip two chars\n      ps2 = ps + 2;\n      while (*pl2 == *ps2) {\n        if (*pl2 == NUL)                // reached the end\n          return score + SCORE_SWAP;\n        ++pl2;\n        ++ps2;\n      }\n      // 3: swap and swap again\n      if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n          && STRCMP(pl2 + 2, ps2 + 2) == 0)\n        return score + SCORE_SWAP + SCORE_SWAP;\n\n      // 4: swap and substitute\n      if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n        return score + SCORE_SWAP + SCORE_SUBST;\n    }\n\n    // 5: substitute\n    pl2 = pl + 1;\n    ps2 = ps + 1;\n    while (*pl2 == *ps2) {\n      if (*pl2 == NUL)                  // reached the end\n        return score + SCORE_SUBST;\n      ++pl2;\n      ++ps2;\n    }\n\n    // 6: substitute and swap\n    if (pl2[0] == ps2[1] && pl2[1] == ps2[0]\n        && STRCMP(pl2 + 2, ps2 + 2) == 0)\n      return score + SCORE_SUBST + SCORE_SWAP;\n\n    // 7: substitute and substitute\n    if (STRCMP(pl2 + 1, ps2 + 1) == 0)\n      return score + SCORE_SUBST + SCORE_SUBST;\n\n    // 8: insert then delete\n    pl2 = pl;\n    ps2 = ps + 1;\n    while (*pl2 == *ps2) {\n      ++pl2;\n      ++ps2;\n    }\n    if (STRCMP(pl2 + 1, ps2) == 0)\n      return score + SCORE_INS + SCORE_DEL;\n\n    // 9: delete then insert\n    pl2 = pl + 1;\n    ps2 = ps;\n    while (*pl2 == *ps2) {\n      ++pl2;\n      ++ps2;\n    }\n    if (STRCMP(pl2, ps2 + 1) == 0)\n      return score + SCORE_INS + SCORE_DEL;\n\n    // Failed to compare.\n    break;\n  }\n\n  return SCORE_MAXMAX;\n}\n\n// Compute the \"edit distance\" to turn \"badword\" into \"goodword\".  The less\n// deletes/inserts/substitutes/swaps are required the lower the score.\n//\n// The algorithm is described by Du and Chang, 1992.\n// The implementation of the algorithm comes from Aspell editdist.cpp,\n// edit_distance().  It has been converted from C++ to C and modified to\n// support multi-byte characters.\nstatic int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword)\n{\n  int *cnt;\n  int j, i;\n  int t;\n  int bc, gc;\n  int pbc, pgc;\n  int wbadword[MAXWLEN];\n  int wgoodword[MAXWLEN];\n\n  // Lengths with NUL.\n  int badlen;\n  int goodlen;\n  {\n    // Get the characters from the multi-byte strings and put them in an\n    // int array for easy access.\n    badlen = 0;\n    for (const char_u *p = badword; *p != NUL; ) {\n      wbadword[badlen++] = mb_cptr2char_adv(&p);\n    }\n    wbadword[badlen++] = 0;\n    goodlen = 0;\n    for (const char_u *p = goodword; *p != NUL; ) {\n      wgoodword[goodlen++] = mb_cptr2char_adv(&p);\n    }\n    wgoodword[goodlen++] = 0;\n  }\n\n  // We use \"cnt\" as an array: CNT(badword_idx, goodword_idx).\n#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]\n  cnt = xmalloc(sizeof(int) * (badlen + 1) * (goodlen + 1));\n\n  CNT(0, 0) = 0;\n  for (j = 1; j <= goodlen; ++j)\n    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;\n\n  for (i = 1; i <= badlen; ++i) {\n    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;\n    for (j = 1; j <= goodlen; j++) {\n      bc = wbadword[i - 1];\n      gc = wgoodword[j - 1];\n      if (bc == gc) {\n        CNT(i, j) = CNT(i - 1, j - 1);\n      } else {\n        // Use a better score when there is only a case difference.\n        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);\n        else {\n          // For a similar character use SCORE_SIMILAR.\n          if (slang != NULL\n              && slang->sl_has_map\n              && similar_chars(slang, gc, bc))\n            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);\n          else\n            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);\n        }\n\n        if (i > 1 && j > 1) {\n          pbc = wbadword[i - 2];\n          pgc = wgoodword[j - 2];\n          if (bc == pgc && pbc == gc) {\n            t = SCORE_SWAP + CNT(i - 2, j - 2);\n            if (t < CNT(i, j))\n              CNT(i, j) = t;\n          }\n        }\n        t = SCORE_DEL + CNT(i - 1, j);\n        if (t < CNT(i, j))\n          CNT(i, j) = t;\n        t = SCORE_INS + CNT(i, j - 1);\n        if (t < CNT(i, j))\n          CNT(i, j) = t;\n      }\n    }\n  }\n\n  i = CNT(badlen - 1, goodlen - 1);\n  xfree(cnt);\n  return i;\n}\n\n// Like spell_edit_score(), but with a limit on the score to make it faster.\n// May return SCORE_MAXMAX when the score is higher than \"limit\".\n//\n// This uses a stack for the edits still to be tried.\n// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support\n// for multi-byte characters.\nstatic int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)\n{\n  return spell_edit_score_limit_w(slang, badword, goodword, limit);\n}\n\n// Multi-byte version of spell_edit_score_limit().\n// Keep it in sync with the above!\nstatic int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)\n{\n  limitscore_T stack[10];               // allow for over 3 * 2 edits\n  int stackidx;\n  int bi, gi;\n  int bi2, gi2;\n  int bc, gc;\n  int score;\n  int score_off;\n  int minscore;\n  int round;\n  int wbadword[MAXWLEN];\n  int wgoodword[MAXWLEN];\n\n  // Get the characters from the multi-byte strings and put them in an\n  // int array for easy access.\n  bi = 0;\n  for (const char_u *p = badword; *p != NUL; ) {\n    wbadword[bi++] = mb_cptr2char_adv(&p);\n  }\n  wbadword[bi++] = 0;\n  gi = 0;\n  for (const char_u *p = goodword; *p != NUL; ) {\n    wgoodword[gi++] = mb_cptr2char_adv(&p);\n  }\n  wgoodword[gi++] = 0;\n\n  // The idea is to go from start to end over the words.  So long as\n  // characters are equal just continue, this always gives the lowest score.\n  // When there is a difference try several alternatives.  Each alternative\n  // increases \"score\" for the edit distance.  Some of the alternatives are\n  // pushed unto a stack and tried later, some are tried right away.  At the\n  // end of the word the score for one alternative is known.  The lowest\n  // possible score is stored in \"minscore\".\n  stackidx = 0;\n  bi = 0;\n  gi = 0;\n  score = 0;\n  minscore = limit + 1;\n\n  for (;; ) {\n    // Skip over an equal part, score remains the same.\n    for (;; ) {\n      bc = wbadword[bi];\n      gc = wgoodword[gi];\n\n      if (bc != gc)             // stop at a char that's different\n        break;\n      if (bc == NUL) {          // both words end\n        if (score < minscore)\n          minscore = score;\n        goto pop;               // do next alternative\n      }\n      ++bi;\n      ++gi;\n    }\n\n    if (gc == NUL) {      // goodword ends, delete badword chars\n      do {\n        if ((score += SCORE_DEL) >= minscore)\n          goto pop;                 // do next alternative\n      } while (wbadword[++bi] != NUL);\n      minscore = score;\n    } else if (bc == NUL)   { // badword ends, insert badword chars\n      do {\n        if ((score += SCORE_INS) >= minscore)\n          goto pop;                 // do next alternative\n      } while (wgoodword[++gi] != NUL);\n      minscore = score;\n    } else {                  // both words continue\n      // If not close to the limit, perform a change.  Only try changes\n      // that may lead to a lower score than \"minscore\".\n      // round 0: try deleting a char from badword\n      // round 1: try inserting a char in badword\n      for (round = 0; round <= 1; ++round) {\n        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);\n        if (score_off < minscore) {\n          if (score_off + SCORE_EDIT_MIN >= minscore) {\n            // Near the limit, rest of the words must match.  We\n            // can check that right now, no need to push an item\n            // onto the stack.\n            bi2 = bi + 1 - round;\n            gi2 = gi + round;\n            while (wgoodword[gi2] == wbadword[bi2]) {\n              if (wgoodword[gi2] == NUL) {\n                minscore = score_off;\n                break;\n              }\n              ++bi2;\n              ++gi2;\n            }\n          } else {\n            // try deleting a character from badword later\n            stack[stackidx].badi = bi + 1 - round;\n            stack[stackidx].goodi = gi + round;\n            stack[stackidx].score = score_off;\n            ++stackidx;\n          }\n        }\n      }\n\n      if (score + SCORE_SWAP < minscore) {\n        // If swapping two characters makes a match then the\n        // substitution is more expensive, thus there is no need to\n        // try both.\n        if (gc == wbadword[bi + 1] && bc == wgoodword[gi + 1]) {\n          // Swap two characters, that is: skip them.\n          gi += 2;\n          bi += 2;\n          score += SCORE_SWAP;\n          continue;\n        }\n      }\n\n      // Substitute one character for another which is the same\n      // thing as deleting a character from both goodword and badword.\n      // Use a better score when there is only a case difference.\n      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))\n        score += SCORE_ICASE;\n      else {\n        // For a similar character use SCORE_SIMILAR.\n        if (slang != NULL\n            && slang->sl_has_map\n            && similar_chars(slang, gc, bc))\n          score += SCORE_SIMILAR;\n        else\n          score += SCORE_SUBST;\n      }\n\n      if (score < minscore) {\n        // Do the substitution.\n        ++gi;\n        ++bi;\n        continue;\n      }\n    }\npop:\n    // Get here to try the next alternative, pop it from the stack.\n    if (stackidx == 0)                  // stack is empty, finished\n      break;\n\n    // pop an item from the stack\n    --stackidx;\n    gi = stack[stackidx].goodi;\n    bi = stack[stackidx].badi;\n    score = stack[stackidx].score;\n  }\n\n  // When the score goes over \"limit\" it may actually be much higher.\n  // Return a very large number to avoid going below the limit when giving a\n  // bonus.\n  if (minscore > limit)\n    return SCORE_MAXMAX;\n  return minscore;\n}\n\n// \":spellinfo\"\nvoid ex_spellinfo(exarg_T *eap)\n{\n  if (no_spell_checking(curwin)) {\n    return;\n  }\n\n  msg_start();\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; lpi++) {\n    langp_T *const lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    msg_puts(\"file: \");\n    msg_puts((const char *)lp->lp_slang->sl_fname);\n    msg_putchar('\\n');\n    const char *const p = (const char *)lp->lp_slang->sl_info;\n    if (p != NULL) {\n      msg_puts(p);\n      msg_putchar('\\n');\n    }\n  }\n  msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree\n#define DUMPFLAG_COUNT      2   // include word count\n#define DUMPFLAG_ICASE      4   // ignore case when finding matches\n#define DUMPFLAG_ONECAP     8   // pattern starts with capital\n#define DUMPFLAG_ALLCAP     16  // pattern is all capitals\n\n// \":spelldump\"\nvoid ex_spelldump(exarg_T *eap)\n{\n  char_u  *spl;\n  long dummy;\n\n  if (no_spell_checking(curwin)) {\n    return;\n  }\n  get_option_value(\"spl\", &dummy, &spl, OPT_LOCAL);\n\n  // Create a new empty buffer in a new window.\n  do_cmdline_cmd(\"new\");\n\n  // enable spelling locally in the new window\n  set_option_value(\"spell\", true, \"\", OPT_LOCAL);\n  set_option_value(\"spl\",  dummy, (char *)spl, OPT_LOCAL);\n  xfree(spl);\n\n  if (!buf_is_empty(curbuf)) {\n    return;\n  }\n\n  spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n  // Delete the empty line that we started with.\n  if (curbuf->b_ml.ml_line_count > 1) {\n    ml_delete(curbuf->b_ml.ml_line_count, false);\n  }\n  redraw_later(curwin, NOT_VALID);\n}\n\n// Go through all possible words and:\n// 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n//      \"ic\" and \"dir\" are not used.\n// 2. When \"pat\" is not NULL: add matching words to insert mode completion.\nvoid\nspell_dump_compl (\n    char_u *pat,           // leading part of the word\n    int ic,                     // ignore case\n    Direction *dir,        // direction for adding matches\n    int dumpflags_arg              // DUMPFLAG_*\n)\n{\n  langp_T     *lp;\n  slang_T     *slang;\n  idx_T arridx[MAXWLEN];\n  int curi[MAXWLEN];\n  char_u word[MAXWLEN];\n  int c;\n  char_u      *byts;\n  idx_T       *idxs;\n  linenr_T lnum = 0;\n  int round;\n  int depth;\n  int n;\n  int flags;\n  char_u      *region_names = NULL;         // region names being used\n  bool do_region = true;                    // dump region names and numbers\n  char_u      *p;\n  int dumpflags = dumpflags_arg;\n  int patlen;\n\n  // When ignoring case or when the pattern starts with capital pass this on\n  // to dump_word().\n  if (pat != NULL) {\n    if (ic)\n      dumpflags |= DUMPFLAG_ICASE;\n    else {\n      n = captype(pat, NULL);\n      if (n == WF_ONECAP)\n        dumpflags |= DUMPFLAG_ONECAP;\n      else if (n == WF_ALLCAP\n               && (int)STRLEN(pat) > mb_ptr2len(pat)\n               )\n        dumpflags |= DUMPFLAG_ALLCAP;\n    }\n  }\n\n  // Find out if we can support regions: All languages must support the same\n  // regions or none at all.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    p = lp->lp_slang->sl_regions;\n    if (p[0] != 0) {\n      if (region_names == NULL)             // first language with regions\n        region_names = p;\n      else if (STRCMP(region_names, p) != 0) {\n        do_region = false;                  // region names are different\n        break;\n      }\n    }\n  }\n\n  if (do_region && region_names != NULL) {\n    if (pat == NULL) {\n      vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n      ml_append(lnum++, IObuff, (colnr_T)0, false);\n    }\n  } else\n    do_region = false;\n\n  // Loop over all files loaded for the entries in 'spelllang'.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    slang = lp->lp_slang;\n    if (slang->sl_fbyts == NULL)            // reloading failed\n      continue;\n\n    if (pat == NULL) {\n      vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n      ml_append(lnum++, IObuff, (colnr_T)0, false);\n    }\n\n    // When matching with a pattern and there are no prefixes only use\n    // parts of the tree that match \"pat\".\n    if (pat != NULL && slang->sl_pbyts == NULL)\n      patlen = (int)STRLEN(pat);\n    else\n      patlen = -1;\n\n    // round 1: case-folded tree\n    // round 2: keep-case tree\n    for (round = 1; round <= 2; ++round) {\n      if (round == 1) {\n        dumpflags &= ~DUMPFLAG_KEEPCASE;\n        byts = slang->sl_fbyts;\n        idxs = slang->sl_fidxs;\n      } else {\n        dumpflags |= DUMPFLAG_KEEPCASE;\n        byts = slang->sl_kbyts;\n        idxs = slang->sl_kidxs;\n      }\n      if (byts == NULL)\n        continue;                       // array is empty\n\n      depth = 0;\n      arridx[0] = 0;\n      curi[0] = 1;\n      while (depth >= 0 && !got_int\n             && (pat == NULL || !compl_interrupted)) {\n        if (curi[depth] > byts[arridx[depth]]) {\n          // Done all bytes at this node, go up one level.\n          --depth;\n          line_breakcheck();\n          ins_compl_check_keys(50, false);\n        } else {\n          // Do one more byte at this node.\n          n = arridx[depth] + curi[depth];\n          ++curi[depth];\n          c = byts[n];\n          if (c == 0) {\n            // End of word, deal with the word.\n            // Don't use keep-case words in the fold-case tree,\n            // they will appear in the keep-case tree.\n            // Only use the word when the region matches.\n            flags = (int)idxs[n];\n            if ((round == 2 || (flags & WF_KEEPCAP) == 0)\n                && (flags & WF_NEEDCOMP) == 0\n                && (do_region\n                    || (flags & WF_REGION) == 0\n                    || (((unsigned)flags >> 16)\n                        & lp->lp_region) != 0)) {\n              word[depth] = NUL;\n              if (!do_region)\n                flags &= ~WF_REGION;\n\n              // Dump the basic word if there is no prefix or\n              // when it's the first one.\n              c = (unsigned)flags >> 24;\n              if (c == 0 || curi[depth] == 2) {\n                dump_word(slang, word, pat, dir,\n                    dumpflags, flags, lnum);\n                if (pat == NULL)\n                  ++lnum;\n              }\n\n              // Apply the prefix, if there is one.\n              if (c != 0)\n                lnum = dump_prefixes(slang, word, pat, dir,\n                    dumpflags, flags, lnum);\n            }\n          } else {\n            // Normal char, go one level deeper.\n            word[depth++] = c;\n            arridx[depth] = idxs[n];\n            curi[depth] = 1;\n\n            // Check if this characters matches with the pattern.\n            // If not skip the whole tree below it.\n            // Always ignore case here, dump_word() will check\n            // proper case later.  This isn't exactly right when\n            // length changes for multi-byte characters with\n            // ignore case...\n            assert(depth >= 0);\n            if (depth <= patlen\n                && mb_strnicmp(word, pat, (size_t)depth) != 0)\n              --depth;\n          }\n        }\n      }\n    }\n  }\n}\n\n// Dumps one word: apply case modifications and append a line to the buffer.\n// When \"lnum\" is zero add insert mode completion.\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat,\n                      Direction *dir, int dumpflags, int wordflags,\n                      linenr_T lnum)\n{\n  bool keepcap = false;\n  char_u      *p;\n  char_u      *tw;\n  char_u cword[MAXWLEN];\n  char_u badword[MAXWLEN + 10];\n  int i;\n  int flags = wordflags;\n\n  if (dumpflags & DUMPFLAG_ONECAP)\n    flags |= WF_ONECAP;\n  if (dumpflags & DUMPFLAG_ALLCAP)\n    flags |= WF_ALLCAP;\n\n  if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0) {\n    // Need to fix case according to \"flags\".\n    make_case_word(word, cword, flags);\n    p = cword;\n  } else {\n    p = word;\n    if ((dumpflags & DUMPFLAG_KEEPCASE)\n        && ((captype(word, NULL) & WF_KEEPCAP) == 0\n            || (flags & WF_FIXCAP) != 0))\n      keepcap = true;\n  }\n  tw = p;\n\n  if (pat == NULL) {\n    // Add flags and regions after a slash.\n    if ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {\n      STRCPY(badword, p);\n      STRCAT(badword, \"/\");\n      if (keepcap) {\n        STRCAT(badword, \"=\");\n      }\n      if (flags & WF_BANNED) {\n        STRCAT(badword, \"!\");\n      } else if (flags & WF_RARE) {\n        STRCAT(badword, \"?\");\n      }\n      if (flags & WF_REGION) {\n        for (i = 0; i < 7; i++) {\n          if (flags & (0x10000 << i)) {\n            const size_t badword_len = STRLEN(badword);\n            snprintf((char *)badword + badword_len,\n                     sizeof(badword) - badword_len,\n                     \"%d\", i + 1);\n          }\n        }\n      }\n      p = badword;\n    }\n\n    if (dumpflags & DUMPFLAG_COUNT) {\n      hashitem_T  *hi;\n\n      // Include the word count for \":spelldump!\".\n      hi = hash_find(&slang->sl_wordcount, tw);\n      if (!HASHITEM_EMPTY(hi)) {\n        vim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n            tw, HI2WC(hi)->wc_count);\n        p = IObuff;\n      }\n    }\n\n    ml_append(lnum, p, (colnr_T)0, false);\n  } else if (((dumpflags & DUMPFLAG_ICASE)\n              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0\n              : STRNCMP(p, pat, STRLEN(pat)) == 0)\n             && ins_compl_add_infercase(p, (int)STRLEN(p),\n                                        p_ic, NULL, *dir, false) == OK) {\n    // if dir was BACKWARD then honor it just once\n    *dir = FORWARD;\n  }\n}\n\n// For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n// \"word\" and append a line to the buffer.\n// When \"lnum\" is zero add insert mode completion.\n// Return the updated line number.\nstatic linenr_T\ndump_prefixes (\n    slang_T *slang,\n    char_u *word,          // case-folded word\n    char_u *pat,\n    Direction *dir,\n    int dumpflags,\n    int flags,                  // flags with prefix ID\n    linenr_T startlnum\n)\n{\n  idx_T arridx[MAXWLEN];\n  int curi[MAXWLEN];\n  char_u prefix[MAXWLEN];\n  char_u word_up[MAXWLEN];\n  bool has_word_up = false;\n  int c;\n  char_u      *byts;\n  idx_T       *idxs;\n  linenr_T lnum = startlnum;\n  int depth;\n  int n;\n  int len;\n  int i;\n\n  // If the word starts with a lower-case letter make the word with an\n  // upper-case letter in word_up[].\n  c = PTR2CHAR(word);\n  if (SPELL_TOUPPER(c) != c) {\n    onecap_copy(word, word_up, true);\n    has_word_up = true;\n  }\n\n  byts = slang->sl_pbyts;\n  idxs = slang->sl_pidxs;\n  if (byts != NULL) {           // array not is empty\n    // Loop over all prefixes, building them byte-by-byte in prefix[].\n    // When at the end of a prefix check that it supports \"flags\".\n    depth = 0;\n    arridx[0] = 0;\n    curi[0] = 1;\n    while (depth >= 0 && !got_int) {\n      n = arridx[depth];\n      len = byts[n];\n      if (curi[depth] > len) {\n        // Done all bytes at this node, go up one level.\n        --depth;\n        line_breakcheck();\n      } else {\n        // Do one more byte at this node.\n        n += curi[depth];\n        ++curi[depth];\n        c = byts[n];\n        if (c == 0) {\n          // End of prefix, find out how many IDs there are.\n          for (i = 1; i < len; ++i)\n            if (byts[n + i] != 0)\n              break;\n          curi[depth] += i - 1;\n\n          c = valid_word_prefix(i, n, flags, word, slang, false);\n          if (c != 0) {\n            STRLCPY(prefix + depth, word, MAXWLEN - depth);\n            dump_word(slang, prefix, pat, dir, dumpflags,\n                (c & WF_RAREPFX) ? (flags | WF_RARE)\n                : flags, lnum);\n            if (lnum != 0)\n              ++lnum;\n          }\n\n          // Check for prefix that matches the word when the\n          // first letter is upper-case, but only if the prefix has\n          // a condition.\n          if (has_word_up) {\n            c = valid_word_prefix(i, n, flags, word_up, slang,\n                true);\n            if (c != 0) {\n              STRLCPY(prefix + depth, word_up, MAXWLEN - depth);\n              dump_word(slang, prefix, pat, dir, dumpflags,\n                  (c & WF_RAREPFX) ? (flags | WF_RARE)\n                  : flags, lnum);\n              if (lnum != 0)\n                ++lnum;\n            }\n          }\n        } else {\n          // Normal char, go one level deeper.\n          prefix[depth++] = c;\n          arridx[depth] = idxs[n];\n          curi[depth] = 1;\n        }\n      }\n    }\n  }\n\n  return lnum;\n}\n\n// Move \"p\" to the end of word \"start\".\n// Uses the spell-checking word characters.\nchar_u *spell_to_word_end(char_u *start, win_T *win)\n{\n  char_u  *p = start;\n\n  while (*p != NUL && spell_iswordp(p, win)) {\n    MB_PTR_ADV(p);\n  }\n  return p;\n}\n\n// For Insert mode completion CTRL-X s:\n// Find start of the word in front of column \"startcol\".\n// We don't check if it is badly spelled, with completion we can only change\n// the word in front of the cursor.\n// Returns the column number of the word.\nint spell_word_start(int startcol)\n{\n  char_u      *line;\n  char_u      *p;\n  int col = 0;\n\n  if (no_spell_checking(curwin)) {\n    return startcol;\n  }\n\n  // Find a word character before \"startcol\".\n  line = get_cursor_line_ptr();\n  for (p = line + startcol; p > line; ) {\n    MB_PTR_BACK(line, p);\n    if (spell_iswordp_nmw(p, curwin)) {\n      break;\n    }\n  }\n\n  // Go back to start of the word.\n  while (p > line) {\n    col = (int)(p - line);\n    MB_PTR_BACK(line, p);\n    if (!spell_iswordp(p, curwin)) {\n      break;\n    }\n    col = 0;\n  }\n\n  return col;\n}\n\n// Need to check for 'spellcapcheck' now, the word is removed before\n// expand_spelling() is called.  Therefore the ugly global variable.\nstatic bool spell_expand_need_cap;\n\nvoid spell_expand_check_cap(colnr_T col)\n{\n  spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n// Get list of spelling suggestions.\n// Used for Insert mode completion CTRL-X ?.\n// Returns the number of matches.  The matches are in \"matchp[]\", array of\n// allocated strings.\nint expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp)\n{\n  garray_T ga;\n\n  spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, true);\n  *matchp = ga.ga_data;\n  return ga.ga_len;\n}\n"}}, "reports": [{"events": [{"location": {"col": 48, "file": 24, "line": 65}, "message": "(         ) (fixit)"}, {"location": {"col": 48, "file": 24, "line": 65}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "fa1cb65ffced036cfe4a68061a5530a2", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 61, "file": 24, "line": 65}, "message": "(          ) (fixit)"}, {"location": {"col": 61, "file": 24, "line": 65}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "0e69120ed2039061aa3d7342b3b4e2b6", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 24, "line": 69}, "message": "(         ) (fixit)"}, {"location": {"col": 49, "file": 24, "line": 69}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "4ec59f766a7233b5f609caef5d007c19", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 62, "file": 24, "line": 69}, "message": "(          ) (fixit)"}, {"location": {"col": 62, "file": 24, "line": 69}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "844b9277954b07cbf8b5612588ef95d4", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 24, "line": 125}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 24, "line": 125}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "684a3d7085d0953efe4b5487402196f1", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 58, "file": 24, "line": 179}, "message": "( ) (fixit)"}, {"location": {"col": 58, "file": 24, "line": 179}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "cd78f0207029a5ebc32773c1084505a8", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 24, "line": 228}, "message": "(            ) (fixit)"}, {"location": {"col": 35, "file": 24, "line": 228}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "4167f08f0c0c53d6baf041fb7656da4d", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 52, "file": 24, "line": 757}, "message": "narrowing conversion from 'uint32_t' (aka 'unsigned int') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "d6c74ed730ec8d36ce134e075e7ef290", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 24, "line": 765}, "message": "narrowing conversion from 'uint32_t' (aka 'unsigned int') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "7fe5c12a2cb02e61d77e3e0955d979b9", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 24, "line": 821}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "44c6951a8d9f5e1d553d60607b6d3632", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 24, "line": 1166}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "f4122b38bf119885390dec315b06c758", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 24, "line": 3423}, "message": "(  ) (fixit)"}, {"location": {"col": 35, "file": 24, "line": 3423}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "ff23d5e79989aa91f9a4c7f8e65ed05a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 4, "file": 24, "line": 3590}, "message": "(    ) (fixit)"}, {"location": {"col": 4, "file": 24, "line": 3590}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "360b146dde14f9847f5f13fc0cb10514", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 24, "line": 3590}, "message": "( ) (fixit)"}, {"location": {"col": 36, "file": 24, "line": 3590}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "86ed05d1bfcf9d87c67f065d3639247d", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 24, "line": 3714}, "message": "narrowing conversion from 'int' to signed type 'short' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "9317d455783c9bfb8e662e761bf99415", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 24, "line": 4048}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "8034d671a5d5dea722f820faeed962cc", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 24, "line": 4291}, "message": "end of the original"}, {"location": {"col": 65, "file": 24, "line": 4297}, "message": "clone 1 starts here"}, {"location": {"col": 74, "file": 24, "line": 4289}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "f69bea982367e5ef959b631c4199900d", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 24, "line": 4728}, "message": "narrowing conversion from 'int' to signed type 'short' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "d905d92ea6e1bfee57bc02bdab84ebff", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 24, "line": 5150}, "message": "() (fixit)"}, {"location": {"col": 38, "file": 24, "line": 5150}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "98d49433377b9338f1ec2facdd715481", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 24, "line": 5269}, "message": "narrowing conversion from 'int' to signed type 'short' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "e320c169a61f4eab0c7b6d59a682d2e8", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 24, "line": 5276}, "message": "narrowing conversion from 'int' to signed type 'short' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "e320c169a61f4eab0c7b6d59a682d2e8", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 24, "line": 6825}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/spell.c", "reportHash": "f051c7cf3d7a364fee53212d2f6a21b8", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
