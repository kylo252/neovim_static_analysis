<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/eval/userfunc.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// User defined function support\n\n#include \"nvim/ascii.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/debugger.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/encode.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/globals.h\"\n#include \"nvim/lua/executor.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/search.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/vim.h\"\n\n// flags used in uf_flags\n#define FC_ABORT    0x01          // abort function on error\n#define FC_RANGE    0x02          // function accepts range\n#define FC_DICT     0x04          // Dict function, uses \"self\"\n#define FC_CLOSURE  0x08          // closure, uses outer scope variables\n#define FC_DELETED  0x10          // :delfunction used while uf_refcount > 0\n#define FC_REMOVED  0x20          // function redefined while uf_refcount > 0\n#define FC_SANDBOX  0x40          // function defined in the sandbox\n#define FC_DEAD     0x80          // function kept only for reference to dfunc\n#define FC_EXPORT   0x100         // \"export def Func()\"\n#define FC_NOARGS   0x200         // no a: variables in lambda\n#define FC_VIM9     0x400         // defined in vim9 script file\n#define FC_CFUNC    0x800         // C function extension\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n#include \"eval/userfunc.c.generated.h\"\n#endif\n\nhashtab_T func_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY_INIT_VALUE;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic char *e_funcexts = N_(\"E122: Function %s already exists, add ! to replace it\");\nstatic char *e_funcdict = N_(\"E717: Dictionary entry already exists\");\nstatic char *e_funcref = N_(\"E718: Funcref required\");\nstatic char *e_nofunc = N_(\"E130: Unknown function: %s\");\n\nvoid func_init(void)\n{\n  hash_init(&func_hashtab);\n}\n\n/// Get function arguments.\nstatic int get_function_args(char_u **argp, char_u endchar, garray_T *newargs, int *varargs,\n                             garray_T *default_args, bool skip)\n{\n  bool    mustend = false;\n  char_u *arg = *argp;\n  char_u *p = arg;\n  int     c;\n  int     i;\n\n  if (newargs != NULL) {\n    ga_init(newargs, (int)sizeof(char_u *), 3);\n  }\n  if (default_args != NULL) {\n    ga_init(default_args, (int)sizeof(char_u *), 3);\n  }\n\n  if (varargs != NULL) {\n    *varargs = false;\n  }\n\n  // Isolate the arguments: \"arg1, arg2, ...)\"\n  bool any_default = false;\n  while (*p != endchar) {\n    if (p[0] == '.' && p[1] == '.' && p[2] == '.') {\n      if (varargs != NULL) {\n        *varargs = true;\n      }\n      p += 3;\n      mustend = true;\n    } else {\n      arg = p;\n      while (ASCII_ISALNUM(*p) || *p == '_') {\n        p++;\n      }\n      if (arg == p || isdigit(*arg)\n          || (p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n          || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0)) {\n        if (!skip) {\n          EMSG2(_(\"E125: Illegal argument: %s\"), arg);\n        }\n        break;\n      }\n      if (newargs != NULL) {\n        ga_grow(newargs, 1);\n        c = *p;\n        *p = NUL;\n        arg = vim_strsave(arg);\n\n        // Check for duplicate argument name.\n        for (i = 0; i < newargs->ga_len; i++) {\n          if (STRCMP(((char_u **)(newargs->ga_data))[i], arg) == 0) {\n            EMSG2(_(\"E853: Duplicate argument name: %s\"), arg);\n            xfree(arg);\n            goto err_ret;\n          }\n        }\n        ((char_u **)(newargs->ga_data))[newargs->ga_len] = arg;\n        newargs->ga_len++;\n\n        *p = c;\n      }\n      if (*skipwhite(p) == '=' && default_args != NULL) {\n        typval_T rettv;\n\n        any_default = true;\n        p = skipwhite(p) + 1;\n        p = skipwhite(p);\n        char_u *expr = p;\n        if (eval1(&p, &rettv, false) != FAIL) {\n          ga_grow(default_args, 1);\n\n          // trim trailing whitespace\n          while (p > expr && ascii_iswhite(p[-1])) {\n            p--;\n          }\n          c = *p;\n          *p = NUL;\n          expr = vim_strsave(expr);\n          ((char_u **)(default_args->ga_data))\n          [default_args->ga_len] = expr;\n          default_args->ga_len++;\n          *p = c;\n        } else {\n          mustend = true;\n        }\n      } else if (any_default) {\n        EMSG(_(\"E989: Non-default argument follows default argument\"));\n        mustend = true;\n      }\n      if (*p == ',') {\n        p++;\n      } else {\n        mustend = true;\n      }\n    }\n    p = skipwhite(p);\n    if (mustend && *p != endchar) {\n      if (!skip) {\n        EMSG2(_(e_invarg2), *argp);\n      }\n      break;\n    }\n  }\n  if (*p != endchar) {\n    goto err_ret;\n  }\n  p++;  // skip \"endchar\"\n\n  *argp = p;\n  return OK;\n\nerr_ret:\n  if (newargs != NULL) {\n    ga_clear_strings(newargs);\n  }\n  if (default_args != NULL) {\n    ga_clear_strings(default_args);\n  }\n  return FAIL;\n}\n\n/// Register function \"fp\" as using \"current_funccal\" as its scope.\nstatic void register_closure(ufunc_T *fp)\n{\n  if (fp->uf_scoped == current_funccal) {\n    // no change\n    return;\n  }\n  funccal_unref(fp->uf_scoped, fp, false);\n  fp->uf_scoped = current_funccal;\n  current_funccal->fc_refcount++;\n  ga_grow(&current_funccal->fc_funcs, 1);\n  ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n  [current_funccal->fc_funcs.ga_len++] = fp;\n}\n\n\n/// Get a name for a lambda.  Returned in static memory.\nchar_u * get_lambda_name(void)\n{\n  static char_u   name[30];\n  static int      lambda_no = 0;\n\n  snprintf((char *)name, sizeof(name), \"<lambda>%d\", ++lambda_no);\n  return name;\n}\n\n/// Parse a lambda expression and get a Funcref from \"*arg\".\n///\n/// @return OK or FAIL.  Returns NOTDONE for dict or {expr}.\nint get_lambda_tv(char_u **arg, typval_T *rettv, bool evaluate)\n{\n  garray_T   newargs = GA_EMPTY_INIT_VALUE;\n  garray_T *pnewargs;\n  ufunc_T *fp = NULL;\n  partial_T *pt = NULL;\n  int        varargs;\n  int        ret;\n  char_u *start = skipwhite(*arg + 1);\n  char_u *s, *e;\n  bool *old_eval_lavars = eval_lavars_used;\n  bool       eval_lavars = false;\n\n  // First, check if this is a lambda expression. \"->\" must exists.\n  ret = get_function_args(&start, '-', NULL, NULL, NULL, true);\n  if (ret == FAIL || *start != '>') {\n    return NOTDONE;\n  }\n\n  // Parse the arguments again.\n  if (evaluate) {\n    pnewargs = &newargs;\n  } else {\n    pnewargs = NULL;\n  }\n  *arg = skipwhite(*arg + 1);\n  ret = get_function_args(arg, '-', pnewargs, &varargs, NULL, false);\n  if (ret == FAIL || **arg != '>') {\n    goto errret;\n  }\n\n  // Set up a flag for checking local variables and arguments.\n  if (evaluate) {\n    eval_lavars_used = &eval_lavars;\n  }\n\n  // Get the start and the end of the expression.\n  *arg = skipwhite(*arg + 1);\n  s = *arg;\n  ret = skip_expr(arg);\n  if (ret == FAIL) {\n    goto errret;\n  }\n  e = *arg;\n  *arg = skipwhite(*arg);\n  if (**arg != '}') {\n    goto errret;\n  }\n  (*arg)++;\n\n  if (evaluate) {\n    int len, flags = 0;\n    char_u *p;\n    garray_T newlines;\n\n    char_u *name = get_lambda_name();\n\n    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    pt = xcalloc(1, sizeof(partial_T));\n\n    ga_init(&newlines, (int)sizeof(char_u *), 1);\n    ga_grow(&newlines, 1);\n\n    // Add \"return \" before the expression.\n    len = 7 + e - s + 1;\n    p = (char_u *)xmalloc(len);\n    ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n    STRCPY(p, \"return \");\n    STRLCPY(p + 7, s, e - s + 1);\n    if (strstr((char *)p + 7, \"a:\") == NULL) {\n      // No a: variables are used for sure.\n      flags |= FC_NOARGS;\n    }\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n    fp->uf_args = newargs;\n    ga_init(&fp->uf_def_args, (int)sizeof(char_u *), 1);\n    fp->uf_lines = newlines;\n    if (current_funccal != NULL && eval_lavars) {\n      flags |= FC_CLOSURE;\n      register_closure(fp);\n    } else {\n      fp->uf_scoped = NULL;\n    }\n\n    if (prof_def_func()) {\n      func_do_profile(fp);\n    }\n    if (sandbox) {\n      flags |= FC_SANDBOX;\n    }\n    fp->uf_varargs = true;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum - newlines.ga_len;\n\n    pt->pt_func = fp;\n    pt->pt_refcount = 1;\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n  }\n\n  eval_lavars_used = old_eval_lavars;\n  return OK;\n\nerrret:\n  ga_clear_strings(&newargs);\n  xfree(fp);\n  xfree(pt);\n  eval_lavars_used = old_eval_lavars;\n  return FAIL;\n}\n\n/// Return name of the function corresponding to `name`\n///\n/// If `name` points to variable that is either a function or partial then\n/// corresponding function name is returned. Otherwise it returns `name` itself.\n///\n/// @param[in]  name  Function name to check.\n/// @param[in,out]  lenp  Location where length of the returned name is stored.\n///                       Must be set to the length of the `name` argument.\n/// @param[out]  partialp  Location where partial will be stored if found\n///                        function appears to be a partial. May be NULL if this\n///                        is not needed.\n/// @param[in]  no_autoload  If true, do not source autoload scripts if function\n///                          was not found.\n///\n/// @return name of the function.\nchar_u *deref_func_name(const char *name, int *lenp, partial_T **const partialp, bool no_autoload)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  if (partialp != NULL) {\n    *partialp = NULL;\n  }\n\n  dictitem_T *const v = find_var(name, (size_t)(*lenp), NULL, no_autoload);\n  if (v != NULL && v->di_tv.v_type == VAR_FUNC) {\n    if (v->di_tv.vval.v_string == NULL) {  // just in case\n      *lenp = 0;\n      return (char_u *)\"\";\n    }\n    *lenp = (int)STRLEN(v->di_tv.vval.v_string);\n    return v->di_tv.vval.v_string;\n  }\n\n  if (v != NULL && v->di_tv.v_type == VAR_PARTIAL) {\n    partial_T *const pt = v->di_tv.vval.v_partial;\n\n    if (pt == NULL) {  // just in case\n      *lenp = 0;\n      return (char_u *)\"\";\n    }\n    if (partialp != NULL) {\n      *partialp = pt;\n    }\n    char_u *s = partial_name(pt);\n    *lenp = (int)STRLEN(s);\n    return s;\n  }\n\n  return (char_u *)name;\n}\n\n/// Give an error message with a function name.  Handle <SNR> things.\n///\n/// @param ermsg must be passed without translation (use N_() instead of _()).\n/// @param name function name\nvoid emsg_funcname(char *ermsg, const char_u *name)\n{\n  char_u *p;\n\n  if (*name == K_SPECIAL) {\n    p = concat_str((char_u *)\"<SNR>\", name + 3);\n  } else {\n    p = (char_u *)name;\n  }\n\n  EMSG2(_(ermsg), p);\n\n  if (p != name) {\n    xfree(p);\n  }\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\nint get_func_tv(const char_u *name,     // name of the function\n                int len,                // length of \"name\" or -1 to use strlen()\n                typval_T *rettv, char_u **arg,           // argument, pointing to the '('\n                funcexe_T *funcexe      // various values\n                )\n{\n  char_u *argp;\n  int ret = OK;\n  typval_T argvars[MAX_FUNC_ARGS + 1];          // vars for arguments\n  int argcount = 0;                     // number of arguments found\n\n  /*\n   * Get the arguments.\n   */\n  argp = *arg;\n  while (argcount < MAX_FUNC_ARGS\n         - (funcexe->partial == NULL ? 0 : funcexe->partial->pt_argc)) {\n    argp = skipwhite(argp + 1);             // skip the '(' or ','\n    if (*argp == ')' || *argp == ',' || *argp == NUL) {\n      break;\n    }\n    if (eval1(&argp, &argvars[argcount], funcexe->evaluate) == FAIL) {\n      ret = FAIL;\n      break;\n    }\n    ++argcount;\n    if (*argp != ',') {\n      break;\n    }\n  }\n  if (*argp == ')') {\n    ++argp;\n  } else {\n    ret = FAIL;\n  }\n\n  if (ret == OK) {\n    int i = 0;\n\n    if (get_vim_var_nr(VV_TESTING)) {\n      // Prepare for calling garbagecollect_for_testing(), need to know\n      // what variables are used on the call stack.\n      if (funcargs.ga_itemsize == 0) {\n        ga_init(&funcargs, (int)sizeof(typval_T *), 50);\n      }\n      for (i = 0; i < argcount; i++) {\n        ga_grow(&funcargs, 1);\n        ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] = &argvars[i];\n      }\n    }\n    ret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\n    funcargs.ga_len -= i;\n  } else if (!aborting()) {\n    if (argcount == MAX_FUNC_ARGS) {\n      emsg_funcname(N_(\"E740: Too many arguments for function %s\"), name);\n    } else {\n      emsg_funcname(N_(\"E116: Invalid arguments for function %s\"), name);\n    }\n  }\n\n  while (--argcount >= 0) {\n    tv_clear(&argvars[argcount]);\n  }\n\n  *arg = skipwhite(argp);\n  return ret;\n}\n\n#define FLEN_FIXED 40\n\n/// Check whether function name starts with <SID> or s:\n///\n/// @warning Only works for names previously checked by eval_fname_script(), if\n///          it returned non-zero.\n///\n/// @param[in]  name  Name to check.\n///\n/// @return true if it starts with <SID> or s:, false otherwise.\nstatic inline bool eval_fname_sid(const char *const name)\n  FUNC_ATTR_PURE FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT\n  FUNC_ATTR_NONNULL_ALL\n{\n  return *name == 's' || TOUPPER_ASC(name[2]) == 'I';\n}\n\n/// In a script transform script-local names into actually used names\n///\n/// Transforms \"<SID>\" and \"s:\" prefixes to `K_SNR {N}` (e.g. K_SNR \"123\") and\n/// \"<SNR>\" prefix to `K_SNR`. Uses `fname_buf` buffer that is supposed to have\n/// #FLEN_FIXED + 1 length when it fits, otherwise it allocates memory.\n///\n/// @param[in]  name  Name to transform.\n/// @param  fname_buf  Buffer to save resulting function name to, if it fits.\n///                    Must have at least #FLEN_FIXED + 1 length.\n/// @param[out]  tofree  Location where pointer to an allocated memory is saved\n///                      in case result does not fit into fname_buf.\n/// @param[out]  error  Location where error type is saved, @see\n///                     FnameTransError.\n///\n/// @return transformed name: either `fname_buf` or a pointer to an allocated\n///         memory.\nstatic char_u *fname_trans_sid(const char_u *const name, char_u *const fname_buf,\n                               char_u **const tofree, int *const error)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  char_u *fname;\n  const int llen = eval_fname_script((const char *)name);\n  if (llen > 0) {\n    fname_buf[0] = K_SPECIAL;\n    fname_buf[1] = KS_EXTRA;\n    fname_buf[2] = (int)KE_SNR;\n    int i = 3;\n    if (eval_fname_sid((const char *)name)) {  // \"<SID>\" or \"s:\"\n      if (current_sctx.sc_sid <= 0) {\n        *error = ERROR_SCRIPT;\n      } else {\n        snprintf((char *)fname_buf + i, FLEN_FIXED + 1 - i, \"%\" PRId64 \"_\",\n                 (int64_t)current_sctx.sc_sid);\n        i = (int)STRLEN(fname_buf);\n      }\n    }\n    if (i + STRLEN(name + llen) < FLEN_FIXED) {\n      STRCPY(fname_buf + i, name + llen);\n      fname = fname_buf;\n    } else {\n      fname = xmalloc(i + STRLEN(name + llen) + 1);\n      *tofree = fname;\n      memmove(fname, fname_buf, (size_t)i);\n      STRCPY(fname + i, name + llen);\n    }\n  } else {\n    fname = (char_u *)name;\n  }\n\n  return fname;\n}\n\n/// Find a function by name, return pointer to it in ufuncs.\n/// @return NULL for unknown function.\nufunc_T *find_func(const char_u *name)\n{\n  hashitem_T *hi;\n\n  hi = hash_find(&func_hashtab, name);\n  if (!HASHITEM_EMPTY(hi)) {\n    return HI2UF(hi);\n  }\n  return NULL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\nstatic void cat_func_name(char_u *buf, ufunc_T *fp)\n{\n  if (fp->uf_name[0] == K_SPECIAL) {\n    STRCPY(buf, \"<SNR>\");\n    STRCAT(buf, fp->uf_name + 3);\n  } else {\n    STRCPY(buf, fp->uf_name);\n  }\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\nstatic void add_nr_var(dict_T *dp, dictitem_T *v, char *name, varnumber_T nr)\n{\n#ifndef __clang_analyzer__\n  STRCPY(v->di_key, name);\n#endif\n  v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n  tv_dict_add(dp, v);\n  v->di_tv.v_type = VAR_NUMBER;\n  v->di_tv.v_lock = VAR_FIXED;\n  v->di_tv.vval.v_number = nr;\n}\n\n// Free \"fc\"\nstatic void free_funccal(funccall_T *fc)\n{\n  for (int i = 0; i < fc->fc_funcs.ga_len; i++) {\n    ufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n    // When garbage collecting a funccall_T may be freed before the\n    // function that references it, clear its uf_scoped field.\n    // The function may have been redefined and point to another\n    // funccal_T, don't clear it then.\n    if (fp != NULL && fp->uf_scoped == fc) {\n      fp->uf_scoped = NULL;\n    }\n  }\n  ga_clear(&fc->fc_funcs);\n\n  func_ptr_unref(fc->func);\n  xfree(fc);\n}\n\n// Free \"fc\" and what it contains.\n// Can be called only when \"fc\" is kept beyond the period of it called,\n// i.e. after cleanup_function_call(fc).\nstatic void free_funccal_contents(funccall_T *fc)\n{\n  // Free all l: variables.\n  vars_clear(&fc->l_vars.dv_hashtab);\n\n  // Free all a: variables.\n  vars_clear(&fc->l_avars.dv_hashtab);\n\n  // Free the a:000 variables.\n  TV_LIST_ITER(&fc->l_varlist, li, {\n    tv_clear(TV_LIST_ITEM_TV(li));\n  });\n\n  free_funccal(fc);\n}\n\n/// Handle the last part of returning from a function: free the local hashtable.\n/// Unless it is still in use by a closure.\nstatic void cleanup_function_call(funccall_T *fc)\n{\n  bool may_free_fc = fc->fc_refcount <= 0;\n  bool free_fc = true;\n\n  current_funccal = fc->caller;\n\n  // Free all l: variables if not referred.\n  if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT) {\n    vars_clear(&fc->l_vars.dv_hashtab);\n  } else {\n    free_fc = false;\n  }\n\n  // If the a:000 list and the l: and a: dicts are not referenced and\n  // there is no closure using it, we can free the funccall_T and what's\n  // in it.\n  if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT) {\n    vars_clear_ext(&fc->l_avars.dv_hashtab, false);\n  } else {\n    free_fc = false;\n\n    // Make a copy of the a: variables, since we didn't do that above.\n    TV_DICT_ITER(&fc->l_avars, di, {\n      tv_copy(&di->di_tv, &di->di_tv);\n    });\n  }\n\n  if (may_free_fc && fc->l_varlist.lv_refcount   // NOLINT(runtime/deprecated)\n      == DO_NOT_FREE_CNT) {\n    fc->l_varlist.lv_first = NULL;  // NOLINT(runtime/deprecated)\n  } else {\n    free_fc = false;\n\n    // Make a copy of the a:000 items, since we didn't do that above.\n    TV_LIST_ITER(&fc->l_varlist, li, {\n      tv_copy(TV_LIST_ITEM_TV(li), TV_LIST_ITEM_TV(li));\n    });\n  }\n\n  if (free_fc) {\n    free_funccal(fc);\n  } else {\n    static int made_copy = 0;\n\n    // \"fc\" is still in use.  This can happen when returning \"a:000\",\n    // assigning \"l:\" to a global variable or defining a closure.\n    // Link \"fc\" in the list for garbage collection later.\n    fc->caller = previous_funccal;\n    previous_funccal = fc;\n\n    if (want_garbage_collect) {\n      // If garbage collector is ready, clear count.\n      made_copy = 0;\n    } else if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc))) {\n      // We have made a lot of copies, worth 4 Mbyte.  This can happen\n      // when repetitively calling a function that creates a reference to\n      // itself somehow.  Call the garbage collector soon to avoid using\n      // too much memory.\n      made_copy = 0;\n      want_garbage_collect = true;\n    }\n  }\n}\n\n/// Unreference \"fc\": decrement the reference count and free it when it\n/// becomes zero.  \"fp\" is detached from \"fc\".\n///\n/// @param[in]   force   When true, we are exiting.\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, bool force)\n{\n  funccall_T **pfc;\n  int i;\n\n  if (fc == NULL) {\n    return;\n  }\n\n  fc->fc_refcount--;\n  if (force ? fc->fc_refcount <= 0 : !fc_referenced(fc)) {\n    for (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller) {\n      if (fc == *pfc) {\n        *pfc = fc->caller;\n        free_funccal_contents(fc);\n        return;\n      }\n    }\n  }\n  for (i = 0; i < fc->fc_funcs.ga_len; i++) {\n    if (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp) {\n      ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n    }\n  }\n}\n\n/// Remove the function from the function hashtable.  If the function was\n/// deleted while it still has references this was already done.\n///\n/// @return true if the entry was deleted, false if it wasn't found.\nstatic bool func_remove(ufunc_T *fp)\n{\n  hashitem_T *hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n\n  if (!HASHITEM_EMPTY(hi)) {\n    hash_remove(&func_hashtab, hi);\n    return true;\n  }\n\n  return false;\n}\n\nstatic void func_clear_items(ufunc_T *fp)\n{\n  ga_clear_strings(&(fp->uf_args));\n  ga_clear_strings(&(fp->uf_def_args));\n  ga_clear_strings(&(fp->uf_lines));\n\n  if (fp->uf_cb_free != NULL) {\n    fp->uf_cb_free(fp->uf_cb_state);\n    fp->uf_cb_free = NULL;\n  }\n\n  XFREE_CLEAR(fp->uf_tml_count);\n  XFREE_CLEAR(fp->uf_tml_total);\n  XFREE_CLEAR(fp->uf_tml_self);\n}\n\n/// Free all things that a function contains. Does not free the function\n/// itself, use func_free() for that.\n///\n/// param[in]        force        When true, we are exiting.\nstatic void func_clear(ufunc_T *fp, bool force)\n{\n  if (fp->uf_cleared) {\n    return;\n  }\n  fp->uf_cleared = true;\n\n  // clear this function\n  func_clear_items(fp);\n  funccal_unref(fp->uf_scoped, fp, force);\n}\n\n/// Free a function and remove it from the list of functions. Does not free\n/// what a function contains, call func_clear() first.\n///\n/// param[in]        fp        The function to free.\nstatic void func_free(ufunc_T *fp)\n{\n  // only remove it when not done already, otherwise we would remove a newer\n  // version of the function\n  if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0) {\n    func_remove(fp);\n  }\n  xfree(fp);\n}\n\n/// Free all things that a function contains and free the function itself.\n///\n/// param[in]        force        When true, we are exiting.\nstatic void func_clear_free(ufunc_T *fp, bool force)\n{\n  func_clear(fp, force);\n  func_free(fp);\n}\n\n/// Call a user function\n///\n/// @param  fp  Function to call.\n/// @param[in]  argcount  Number of arguments.\n/// @param  argvars  Arguments.\n/// @param[out]  rettv  Return value.\n/// @param[in]  firstline  First line of range.\n/// @param[in]  lastline  Last line of range.\n/// @param  selfdict  Dictionary for \"self\" for dictionary functions.\nvoid call_user_func(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv,\n                    linenr_T firstline, linenr_T lastline, dict_T *selfdict)\n  FUNC_ATTR_NONNULL_ARG(1, 3, 4)\n{\n  char_u *save_sourcing_name;\n  linenr_T save_sourcing_lnum;\n  bool using_sandbox = false;\n  funccall_T *fc;\n  int save_did_emsg;\n  static int depth = 0;\n  dictitem_T *v;\n  int fixvar_idx = 0;           // index in fixvar[]\n  int ai;\n  bool islambda = false;\n  char_u numbuf[NUMBUFLEN];\n  char_u *name;\n  typval_T *tv_to_free[MAX_FUNC_ARGS];\n  int tv_to_free_len = 0;\n  proftime_T wait_start;\n  proftime_T call_start;\n  int started_profiling = false;\n  bool did_save_redo = false;\n  save_redo_T save_redo;\n\n  // If depth of calling is getting too high, don't execute the function\n  if (depth >= p_mfd) {\n    EMSG(_(\"E132: Function call depth is higher than 'maxfuncdepth'\"));\n    rettv->v_type = VAR_NUMBER;\n    rettv->vval.v_number = -1;\n    return;\n  }\n  ++depth;\n  // Save search patterns and redo buffer.\n  save_search_patterns();\n  if (!ins_compl_active()) {\n    saveRedobuff(&save_redo);\n    did_save_redo = true;\n  }\n  ++fp->uf_calls;\n  // check for CTRL-C hit\n  line_breakcheck();\n  // prepare the funccall_T structure\n  fc = xcalloc(1, sizeof(funccall_T));\n  fc->caller = current_funccal;\n  current_funccal = fc;\n  fc->func = fp;\n  fc->rettv = rettv;\n  fc->level = ex_nesting_level;\n  // Check if this function has a breakpoint.\n  fc->breakpoint = dbg_find_breakpoint(false, fp->uf_name, (linenr_T)0);\n  fc->dbg_tick = debug_tick;\n\n  // Set up fields for closure.\n  ga_init(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n  func_ptr_ref(fp);\n\n  if (STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0) {\n    islambda = true;\n  }\n\n  // Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n  // with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n  // each argument variable and saves a lot of time.\n  //\n  // Init l: variables.\n  init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n  if (selfdict != NULL) {\n    // Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n    // some compiler that checks the destination size.\n    v = (dictitem_T *)&fc->fixvar[fixvar_idx++];\n#ifndef __clang_analyzer__\n    name = v->di_key;\n    STRCPY(name, \"self\");\n#endif\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    tv_dict_add(&fc->l_vars, v);\n    v->di_tv.v_type = VAR_DICT;\n    v->di_tv.v_lock = VAR_UNLOCKED;\n    v->di_tv.vval.v_dict = selfdict;\n    ++selfdict->dv_refcount;\n  }\n\n  // Init a: variables, unless none found (in lambda).\n  // Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n  // Set a:000 to a list with room for the \"...\" arguments.\n  init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n  if ((fp->uf_flags & FC_NOARGS) == 0) {\n    add_nr_var(&fc->l_avars, (dictitem_T *)&fc->fixvar[fixvar_idx++], \"0\",\n               (varnumber_T)(argcount >= fp->uf_args.ga_len\n                             ? argcount - fp->uf_args.ga_len : 0));\n  }\n  fc->l_avars.dv_lock = VAR_FIXED;\n  if ((fp->uf_flags & FC_NOARGS) == 0) {\n    // Use \"name\" to avoid a warning from some compiler that checks the\n    // destination size.\n    v = (dictitem_T *)&fc->fixvar[fixvar_idx++];\n#ifndef __clang_analyzer__\n    name = v->di_key;\n    STRCPY(name, \"000\");\n#endif\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    tv_dict_add(&fc->l_avars, v);\n    v->di_tv.v_type = VAR_LIST;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_list = &fc->l_varlist;\n  }\n  tv_list_init_static(&fc->l_varlist);\n  tv_list_set_lock(&fc->l_varlist, VAR_FIXED);\n\n  // Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n  // Set a:name to named arguments.\n  // Set a:N to the \"...\" arguments.\n  // Skipped when no a: variables used (in lambda).\n  if ((fp->uf_flags & FC_NOARGS) == 0) {\n    add_nr_var(&fc->l_avars, (dictitem_T *)&fc->fixvar[fixvar_idx++],\n               \"firstline\", (varnumber_T)firstline);\n    add_nr_var(&fc->l_avars, (dictitem_T *)&fc->fixvar[fixvar_idx++],\n               \"lastline\", (varnumber_T)lastline);\n  }\n  bool default_arg_err = false;\n  for (int i = 0; i < argcount || i < fp->uf_args.ga_len; i++) {\n    bool addlocal = false;\n    bool isdefault = false;\n    typval_T def_rettv;\n\n    ai = i - fp->uf_args.ga_len;\n    if (ai < 0) {\n      // named argument a:name\n      name = FUNCARG(fp, i);\n      if (islambda) {\n        addlocal = true;\n      }\n\n      // evaluate named argument default expression\n      isdefault = ai + fp->uf_def_args.ga_len >= 0 && i >= argcount;\n      if (isdefault) {\n        char_u *default_expr = NULL;\n        def_rettv.v_type = VAR_NUMBER;\n        def_rettv.vval.v_number = -1;\n\n        default_expr = ((char_u **)(fp->uf_def_args.ga_data))\n                       [ai + fp->uf_def_args.ga_len];\n        if (eval1(&default_expr, &def_rettv, true) == FAIL) {\n          default_arg_err = true;\n          break;\n        }\n      }\n    } else {\n      if ((fp->uf_flags & FC_NOARGS) != 0) {\n        // Bail out if no a: arguments used (in lambda).\n        break;\n      }\n      // \"...\" argument a:1, a:2, etc.\n      snprintf((char *)numbuf, sizeof(numbuf), \"%d\", ai + 1);\n      name = numbuf;\n    }\n    if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN) {\n      v = (dictitem_T *)&fc->fixvar[fixvar_idx++];\n      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    } else {\n      v = xmalloc(sizeof(dictitem_T) + STRLEN(name));\n      v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX | DI_FLAGS_ALLOC;\n    }\n    STRCPY(v->di_key, name);\n\n    // Note: the values are copied directly to avoid alloc/free.\n    // \"argvars\" must have VAR_FIXED for v_lock.\n    v->di_tv = isdefault ? def_rettv : argvars[i];\n    v->di_tv.v_lock = VAR_FIXED;\n\n    if (isdefault) {\n      // Need to free this later, no matter where it's stored.\n      tv_to_free[tv_to_free_len++] = &v->di_tv;\n    }\n\n    if (addlocal) {\n      // Named arguments can be accessed without the \"a:\" prefix in lambda\n      // expressions. Add to the l: dict.\n      tv_copy(&v->di_tv, &v->di_tv);\n      tv_dict_add(&fc->l_vars, v);\n    } else {\n      tv_dict_add(&fc->l_avars, v);\n    }\n\n    if (ai >= 0 && ai < MAX_FUNC_ARGS) {\n      listitem_T *li = &fc->l_listitems[ai];\n\n      *TV_LIST_ITEM_TV(li) = argvars[i];\n      TV_LIST_ITEM_TV(li)->v_lock =  VAR_FIXED;\n      tv_list_append(&fc->l_varlist, li);\n    }\n  }\n\n  // Don't redraw while executing the function.\n  RedrawingDisabled++;\n  save_sourcing_name = sourcing_name;\n  save_sourcing_lnum = sourcing_lnum;\n  sourcing_lnum = 1;\n\n  if (fp->uf_flags & FC_SANDBOX) {\n    using_sandbox = true;\n    sandbox++;\n  }\n\n  // need space for new sourcing_name:\n  // * save_sourcing_name\n  // * \"[\"number\"]..\" or \"function \"\n  // * \"<SNR>\" + fp->uf_name - 3\n  // * terminating NUL\n  size_t len = (save_sourcing_name == NULL ? 0 : STRLEN(save_sourcing_name))\n               + STRLEN(fp->uf_name) + 27;\n  sourcing_name = xmalloc(len);\n  {\n    if (save_sourcing_name != NULL\n        && STRNCMP(save_sourcing_name, \"function \", 9) == 0) {\n      vim_snprintf((char *)sourcing_name,\n                   len,\n                   \"%s[%\" PRId64 \"]..\",\n                   save_sourcing_name,\n                   (int64_t)save_sourcing_lnum);\n    } else {\n      STRCPY(sourcing_name, \"function \");\n    }\n    cat_func_name(sourcing_name + STRLEN(sourcing_name), fp);\n\n    if (p_verbose >= 12) {\n      ++no_wait_return;\n      verbose_enter_scroll();\n\n      smsg(_(\"calling %s\"), sourcing_name);\n      if (p_verbose >= 14) {\n        msg_puts(\"(\");\n        for (int i = 0; i < argcount; i++) {\n          if (i > 0) {\n            msg_puts(\", \");\n          }\n          if (argvars[i].v_type == VAR_NUMBER) {\n            msg_outnum((long)argvars[i].vval.v_number);\n          } else {\n            // Do not want errors such as E724 here.\n            emsg_off++;\n            char *tofree = encode_tv2string(&argvars[i], NULL);\n            emsg_off--;\n            if (tofree != NULL) {\n              char *s = tofree;\n              char buf[MSG_BUF_LEN];\n              if (vim_strsize((char_u *)s) > MSG_BUF_CLEN) {\n                trunc_string((char_u *)s, (char_u *)buf, MSG_BUF_CLEN,\n                             sizeof(buf));\n                s = buf;\n              }\n              msg_puts(s);\n              xfree(tofree);\n            }\n          }\n        }\n        msg_puts(\")\");\n      }\n      msg_puts(\"\\n\");  // don't overwrite this either\n\n      verbose_leave_scroll();\n      --no_wait_return;\n    }\n  }\n\n  const bool do_profiling_yes = do_profiling == PROF_YES;\n\n  bool func_not_yet_profiling_but_should =\n    do_profiling_yes\n    && !fp->uf_profiling && has_profiling(false, fp->uf_name, NULL);\n\n  if (func_not_yet_profiling_but_should) {\n    started_profiling = true;\n    func_do_profile(fp);\n  }\n\n  bool func_or_func_caller_profiling =\n    do_profiling_yes\n    && (fp->uf_profiling\n        || (fc->caller != NULL && fc->caller->func->uf_profiling));\n\n  if (func_or_func_caller_profiling) {\n    ++fp->uf_tm_count;\n    call_start = profile_start();\n    fp->uf_tm_children = profile_zero();\n  }\n\n  if (do_profiling_yes) {\n    script_prof_save(&wait_start);\n  }\n\n  const sctx_T save_current_sctx = current_sctx;\n  current_sctx = fp->uf_script_ctx;\n  save_did_emsg = did_emsg;\n  did_emsg = FALSE;\n\n  if (default_arg_err && (fp->uf_flags & FC_ABORT)) {\n    did_emsg = true;\n  } else if (islambda) {\n    char_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n    // A Lambda always has the command \"return {expr}\".  It is much faster\n    // to evaluate {expr} directly.\n    ex_nesting_level++;\n    (void)eval1(&p, rettv, true);\n    ex_nesting_level--;\n  } else {\n    // call do_cmdline() to execute the lines\n    do_cmdline(NULL, get_func_line, (void *)fc,\n               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n  }\n\n  --RedrawingDisabled;\n\n  // when the function was aborted because of an error, return -1\n  if ((did_emsg\n       && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN) {\n    tv_clear(rettv);\n    rettv->v_type = VAR_NUMBER;\n    rettv->vval.v_number = -1;\n  }\n\n  if (func_or_func_caller_profiling) {\n    call_start = profile_end(call_start);\n    call_start = profile_sub_wait(wait_start, call_start);  // -V614\n    fp->uf_tm_total = profile_add(fp->uf_tm_total, call_start);\n    fp->uf_tm_self = profile_self(fp->uf_tm_self, call_start,\n                                  fp->uf_tm_children);\n    if (fc->caller != NULL && fc->caller->func->uf_profiling) {\n      fc->caller->func->uf_tm_children =\n        profile_add(fc->caller->func->uf_tm_children, call_start);\n      fc->caller->func->uf_tml_children =\n        profile_add(fc->caller->func->uf_tml_children, call_start);\n    }\n    if (started_profiling) {\n      // make a \":profdel func\" stop profiling the function\n      fp->uf_profiling = false;\n    }\n  }\n\n  // when being verbose, mention the return value\n  if (p_verbose >= 12) {\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (aborting()) {\n      smsg(_(\"%s aborted\"), sourcing_name);\n    } else if (fc->rettv->v_type == VAR_NUMBER) {\n      smsg(_(\"%s returning #%\" PRId64 \"\"),\n           sourcing_name, (int64_t)fc->rettv->vval.v_number);\n    } else {\n      char_u buf[MSG_BUF_LEN];\n\n      // The value may be very long.  Skip the middle part, so that we\n      // have some idea how it starts and ends. smsg() would always\n      // truncate it at the end. Don't want errors such as E724 here.\n      emsg_off++;\n      char_u *s = (char_u *)encode_tv2string(fc->rettv, NULL);\n      char_u *tofree = s;\n      emsg_off--;\n      if (s != NULL) {\n        if (vim_strsize(s) > MSG_BUF_CLEN) {\n          trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n          s = buf;\n        }\n        smsg(_(\"%s returning %s\"), sourcing_name, s);\n        xfree(tofree);\n      }\n    }\n    msg_puts(\"\\n\");  // don't overwrite this either\n\n    verbose_leave_scroll();\n    --no_wait_return;\n  }\n\n  xfree(sourcing_name);\n  sourcing_name = save_sourcing_name;\n  sourcing_lnum = save_sourcing_lnum;\n  current_sctx = save_current_sctx;\n  if (do_profiling_yes) {\n    script_prof_restore(&wait_start);\n  }\n  if (using_sandbox) {\n    sandbox--;\n  }\n\n  if (p_verbose >= 12 && sourcing_name != NULL) {\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    smsg(_(\"continuing in %s\"), sourcing_name);\n    msg_puts(\"\\n\");  // don't overwrite this either\n\n    verbose_leave_scroll();\n    --no_wait_return;\n  }\n\n  did_emsg |= save_did_emsg;\n  depth--;\n  for (int i = 0; i < tv_to_free_len; i++) {\n    tv_clear(tv_to_free[i]);\n  }\n  cleanup_function_call(fc);\n\n  if (--fp->uf_calls <= 0 && fp->uf_refcount <= 0) {\n    // Function was unreferenced while being used, free it now.\n    func_clear_free(fp, false);\n  }\n  // restore search patterns and redo buffer\n  if (did_save_redo) {\n    restoreRedobuff(&save_redo);\n  }\n  restore_search_patterns();\n}\n\n/// There are two kinds of function names:\n/// 1. ordinary names, function defined with :function\n/// 2. numbered functions and lambdas\n/// For the first we only count the name stored in func_hashtab as a reference,\n/// using function() does not count as a reference, because the function is\n/// looked up by name.\nstatic bool func_name_refcount(char_u *name)\n{\n  return isdigit(*name) || *name == '<';\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n// Save the current function call pointer, and set it to NULL.\n// Used when executing autocommands and for \":source\".\nvoid save_funccal(funccal_entry_T *entry)\n{\n  entry->top_funccal = current_funccal;\n  entry->next = funccal_stack;\n  funccal_stack = entry;\n  current_funccal = NULL;\n}\n\nvoid restore_funccal(void)\n{\n  if (funccal_stack == NULL) {\n    IEMSG(\"INTERNAL: restore_funccal()\");\n  } else {\n    current_funccal = funccal_stack->top_funccal;\n    funccal_stack = funccal_stack->next;\n  }\n}\n\nfunccall_T *get_current_funccal(void)\n{\n  return current_funccal;\n}\n\nvoid set_current_funccal(funccall_T *fc)\n{\n  current_funccal = fc;\n}\n\n#if defined(EXITFREE)\nvoid free_all_functions(void)\n{\n  hashitem_T *hi;\n  ufunc_T *fp;\n  uint64_t skipped = 0;\n  uint64_t todo = 1;\n  uint64_t used;\n\n  // Clean up the current_funccal chain and the funccal stack.\n  while (current_funccal != NULL) {\n    tv_clear(current_funccal->rettv);\n    cleanup_function_call(current_funccal);\n    if (current_funccal == NULL && funccal_stack != NULL) {\n      restore_funccal();\n    }\n  }\n\n  // First clear what the functions contain. Since this may lower the\n  // reference count of a function, it may also free a function and change\n  // the hash table. Restart if that happens.\n  while (todo > 0) {\n    todo = func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0; hi++) {\n      if (!HASHITEM_EMPTY(hi)) {\n        // Only free functions that are not refcounted, those are\n        // supposed to be freed when no longer referenced.\n        fp = HI2UF(hi);\n        if (func_name_refcount(fp->uf_name)) {\n          skipped++;\n        } else {\n          used = func_hashtab.ht_used;\n          func_clear(fp, true);\n          if (used != func_hashtab.ht_used) {\n            skipped = 0;\n            break;\n          }\n        }\n        todo--;\n      }\n    }\n  }\n\n  // Now actually free the functions. Need to start all over every time,\n  // because func_free() may change the hash table.\n  skipped = 0;\n  while (func_hashtab.ht_used > skipped) {\n    todo = func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0; hi++) {\n      if (!HASHITEM_EMPTY(hi)) {\n        todo--;\n        // Only free functions that are not refcounted, those are\n        // supposed to be freed when no longer referenced.\n        fp = HI2UF(hi);\n        if (func_name_refcount(fp->uf_name)) {\n          skipped++;\n        } else {\n          func_free(fp);\n          skipped = 0;\n          break;\n        }\n      }\n    }\n  }\n  if (skipped == 0) {\n    hash_clear(&func_hashtab);\n  }\n}\n\n#endif\n\n/// Checks if a builtin function with the given name exists.\n///\n/// @param[in]   name   name of the builtin function to check.\n/// @param[in]   len    length of \"name\", or -1 for NUL terminated.\n///\n/// @return true if \"name\" looks like a builtin function name: starts with a\n/// lower case letter and doesn't contain AUTOLOAD_CHAR.\nstatic bool builtin_function(const char *name, int len)\n{\n  if (!ASCII_ISLOWER(name[0])) {\n    return false;\n  }\n\n  const char *p = (len == -1\n                   ? strchr(name, AUTOLOAD_CHAR)\n                   : memchr(name, AUTOLOAD_CHAR, (size_t)len));\n\n  return p == NULL;\n}\n\nint func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv)\n{\n  typval_T argv[MAX_FUNC_ARGS + 1];\n  int argc = 0;\n  int r = 0;\n\n  TV_LIST_ITER(args->vval.v_list, item, {\n    if (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc)) {\n      EMSG(_(\"E699: Too many arguments\"));\n      goto func_call_skip_call;\n    }\n    // Make a copy of each argument.  This is needed to be able to set\n    // v_lock to VAR_FIXED in the copy without changing the original list.\n    tv_copy(TV_LIST_ITEM_TV(item), &argv[argc++]);\n  });\n\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = true;\n  funcexe.partial = partial;\n  funcexe.selfdict = selfdict;\n  r = call_func(name, -1, rettv, argc, argv, &funcexe);\n\nfunc_call_skip_call:\n  // Free the arguments.\n  while (argc > 0) {\n    tv_clear(&argv[--argc]);\n  }\n\n  return r;\n}\n\n// Give an error message for the result of a function.\n// Nothing if \"error\" is FCERR_NONE.\nstatic void user_func_error(int error, const char_u *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  switch (error) {\n  case ERROR_UNKNOWN:\n    emsg_funcname(N_(\"E117: Unknown function: %s\"), name);\n    break;\n  case ERROR_NOTMETHOD:\n    emsg_funcname(N_(\"E276: Cannot use function as a method: %s\"), name);\n    break;\n  case ERROR_DELETED:\n    emsg_funcname(N_(\"E933: Function was deleted: %s\"), name);\n    break;\n  case ERROR_TOOMANY:\n    emsg_funcname(_(e_toomanyarg), name);\n    break;\n  case ERROR_TOOFEW:\n    emsg_funcname(N_(\"E119: Not enough arguments for function: %s\"),\n                  name);\n    break;\n  case ERROR_SCRIPT:\n    emsg_funcname(N_(\"E120: Using <SID> not in a script context: %s\"),\n                  name);\n    break;\n  case ERROR_DICT:\n    emsg_funcname(N_(\"E725: Calling dict function without Dictionary: %s\"),\n                  name);\n    break;\n  }\n}\n\n/// Used by call_func to add a method base (if any) to a function argument list\n/// as the first argument. @see call_func\nstatic void argv_add_base(typval_T *const basetv, typval_T **const argvars, int *const argcount,\n                          typval_T *const new_argvars, int *const argv_base)\n  FUNC_ATTR_NONNULL_ARG(2, 3, 4, 5)\n{\n  if (basetv != NULL) {\n    // Method call: base->Method()\n    memmove(&new_argvars[1], *argvars, sizeof(typval_T) * (*argcount));\n    new_argvars[0] = *basetv;\n    (*argcount)++;\n    *argvars = new_argvars;\n    *argv_base = 1;\n  }\n}\n\n/// Call a function with its resolved parameters\n///\n/// @return FAIL if function cannot be called, else OK (even if an error\n///         occurred while executing the function! Set `msg_list` to capture\n///         the error, see do_cmdline()).\nint call_func(const char_u *funcname,         // name of the function\n              int len,                        // length of \"name\" or -1 to use strlen()\n              typval_T *rettv,                // [out] value goes here\n              int argcount_in,                // number of \"argvars\"\n              typval_T *argvars_in,           // vars for arguments, must have \"argcount\"\n                                              // PLUS ONE elements!\n              funcexe_T *funcexe              // more arguments\n              )\n  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6)\n{\n  int ret = FAIL;\n  int error = ERROR_NONE;\n  ufunc_T *fp = NULL;\n  char_u fname_buf[FLEN_FIXED + 1];\n  char_u *tofree = NULL;\n  char_u *fname = NULL;\n  char_u *name = NULL;\n  int argcount = argcount_in;\n  typval_T *argvars = argvars_in;\n  dict_T *selfdict = funcexe->selfdict;\n  typval_T argv[MAX_FUNC_ARGS + 1];  // used when \"partial\" or\n                                     // \"funcexe->basetv\" is not NULL\n  int argv_clear = 0;\n  int argv_base = 0;\n  partial_T *partial = funcexe->partial;\n\n  // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n  // even when call_func() returns FAIL.\n  rettv->v_type = VAR_UNKNOWN;\n\n  if (len <= 0) {\n    len = (int)STRLEN(funcname);\n  }\n  if (partial != NULL) {\n    fp = partial->pt_func;\n  }\n  if (fp == NULL) {\n    // Make a copy of the name, if it comes from a funcref variable it could\n    // be changed or deleted in the called function.\n    name = vim_strnsave(funcname, len);\n    fname = fname_trans_sid(name, fname_buf, &tofree, &error);\n  }\n\n  if (funcexe->doesrange != NULL) {\n    *funcexe->doesrange = false;\n  }\n\n  if (partial != NULL) {\n    // When the function has a partial with a dict and there is a dict\n    // argument, use the dict argument. That is backwards compatible.\n    // When the dict was bound explicitly use the one from the partial.\n    if (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto)) {\n      selfdict = partial->pt_dict;\n    }\n    if (error == ERROR_NONE && partial->pt_argc > 0) {\n      for (argv_clear = 0; argv_clear < partial->pt_argc; argv_clear++) {\n        if (argv_clear + argcount_in >= MAX_FUNC_ARGS) {\n          error = ERROR_TOOMANY;\n          goto theend;\n        }\n        tv_copy(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n      }\n      for (int i = 0; i < argcount_in; i++) {\n        argv[i + argv_clear] = argvars_in[i];\n      }\n      argvars = argv;\n      argcount = partial->pt_argc + argcount_in;\n    }\n  }\n\n  if (error == ERROR_NONE && funcexe->evaluate) {\n    char_u *rfname = fname;\n\n    // Ignore \"g:\" before a function name.\n    if (fp == NULL && fname[0] == 'g' && fname[1] == ':') {\n      rfname = fname + 2;\n    }\n\n    rettv->v_type = VAR_NUMBER;         // default rettv is number zero\n    rettv->vval.v_number = 0;\n    error = ERROR_UNKNOWN;\n\n    if (is_luafunc(partial)) {\n      if (len > 0) {\n        error = ERROR_NONE;\n        argv_add_base(funcexe->basetv, &argvars, &argcount, argv, &argv_base);\n        nlua_typval_call((const char *)funcname, len, argvars, argcount, rettv);\n      } else {\n        // v:lua was called directly; show its name in the emsg\n        XFREE_CLEAR(name);\n        funcname = (const char_u *)\"v:lua\";\n      }\n    } else if (fp != NULL || !builtin_function((const char *)rfname, -1)) {\n      // User defined function.\n      if (fp == NULL) {\n        fp = find_func(rfname);\n      }\n\n      // Trigger FuncUndefined event, may load the function.\n      if (fp == NULL\n          && apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, true, NULL)\n          && !aborting()) {\n        // executed an autocommand, search for the function again\n        fp = find_func(rfname);\n      }\n      // Try loading a package.\n      if (fp == NULL && script_autoload((const char *)rfname, STRLEN(rfname),\n                                        true) && !aborting()) {\n        // Loaded a package, search for the function again.\n        fp = find_func(rfname);\n      }\n\n      if (fp != NULL && (fp->uf_flags & FC_DELETED)) {\n        error = ERROR_DELETED;\n      } else if (fp != NULL && (fp->uf_flags & FC_CFUNC)) {\n        cfunc_T cb = fp->uf_cb;\n        error = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n      } else if (fp != NULL) {\n        if (funcexe->argv_func != NULL) {\n          // postponed filling in the arguments, do it now\n          argcount = funcexe->argv_func(argcount, argvars, argv_clear,\n                                        fp->uf_args.ga_len);\n        }\n\n        argv_add_base(funcexe->basetv, &argvars, &argcount, argv, &argv_base);\n\n        if (fp->uf_flags & FC_RANGE && funcexe->doesrange != NULL) {\n          *funcexe->doesrange = true;\n        }\n        if (argcount < fp->uf_args.ga_len - fp->uf_def_args.ga_len) {\n          error = ERROR_TOOFEW;\n        } else if (!fp->uf_varargs && argcount > fp->uf_args.ga_len) {\n          error = ERROR_TOOMANY;\n        } else if ((fp->uf_flags & FC_DICT) && selfdict == NULL) {\n          error = ERROR_DICT;\n        } else {\n          // Call the user function.\n          call_user_func(fp, argcount, argvars, rettv, funcexe->firstline,\n                         funcexe->lastline,\n                         (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n          error = ERROR_NONE;\n        }\n      }\n    } else if (funcexe->basetv != NULL) {\n      // expr->method(): Find the method name in the table, call its\n      // implementation with the base as one of the arguments.\n      error = call_internal_method(fname, argcount, argvars, rettv,\n                                   funcexe->basetv);\n    } else {\n      // Find the function name in the table, call its implementation.\n      error = call_internal_func(fname, argcount, argvars, rettv);\n    }\n    /*\n     * The function call (or \"FuncUndefined\" autocommand sequence) might\n     * have been aborted by an error, an interrupt, or an explicitly thrown\n     * exception that has not been caught so far.  This situation can be\n     * tested for by calling aborting().  For an error in an internal\n     * function or for the \"E132\" error in call_user_func(), however, the\n     * throw point at which the \"force_abort\" flag (temporarily reset by\n     * emsg()) is normally updated has not been reached yet. We need to\n     * update that flag first to make aborting() reliable.\n     */\n    update_force_abort();\n  }\n  if (error == ERROR_NONE) {\n    ret = OK;\n  }\n\ntheend:\n  // Report an error unless the argument evaluation or function call has been\n  // cancelled due to an aborting error, an interrupt, or an exception.\n  if (!aborting()) {\n    user_func_error(error, (name != NULL) ? name : funcname);\n  }\n\n  // clear the copies made from the partial\n  while (argv_clear > 0) {\n    tv_clear(&argv[--argv_clear + argv_base]);\n  }\n\n  xfree(tofree);\n  xfree(name);\n\n  return ret;\n}\n\n/// List the head of the function: \"name(arg1, arg2)\".\n///\n/// @param[in]  fp      Function pointer.\n/// @param[in]  indent  Indent line.\n/// @param[in]  force   Include bang \"!\" (i.e.: \"function!\").\nstatic void list_func_head(ufunc_T *fp, int indent, bool force)\n{\n  msg_start();\n  if (indent) {\n    MSG_PUTS(\"   \");\n  }\n  MSG_PUTS(force ? \"function! \" : \"function \");\n  if (fp->uf_name[0] == K_SPECIAL) {\n    MSG_PUTS_ATTR(\"<SNR>\", HL_ATTR(HLF_8));\n    msg_puts((const char *)fp->uf_name + 3);\n  } else {\n    msg_puts((const char *)fp->uf_name);\n  }\n  msg_putchar('(');\n  int j;\n  for (j = 0; j < fp->uf_args.ga_len; j++) {\n    if (j) {\n      msg_puts(\", \");\n    }\n    msg_puts((const char *)FUNCARG(fp, j));\n    if (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len) {\n      msg_puts(\" = \");\n      msg_puts(((char **)(fp->uf_def_args.ga_data))\n               [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n    }\n  }\n  if (fp->uf_varargs) {\n    if (j) {\n      msg_puts(\", \");\n    }\n    msg_puts(\"...\");\n  }\n  msg_putchar(')');\n  if (fp->uf_flags & FC_ABORT) {\n    msg_puts(\" abort\");\n  }\n  if (fp->uf_flags & FC_RANGE) {\n    msg_puts(\" range\");\n  }\n  if (fp->uf_flags & FC_DICT) {\n    msg_puts(\" dict\");\n  }\n  if (fp->uf_flags & FC_CLOSURE) {\n    msg_puts(\" closure\");\n  }\n  msg_clr_eos();\n  if (p_verbose > 0) {\n    last_set_msg(fp->uf_script_ctx);\n  }\n}\n\n/// Get a function name, translating \"<SID>\" and \"<SNR>\".\n/// Also handles a Funcref in a List or Dictionary.\n/// flags:\n/// TFN_INT:         internal function name OK\n/// TFN_QUIET:       be quiet\n/// TFN_NO_AUTOLOAD: do not use script autoloading\n/// TFN_NO_DEREF:    do not dereference a Funcref\n/// Advances \"pp\" to just after the function name (if no error).\n///\n/// @return the function name in allocated memory, or NULL for failure.\nchar_u *trans_function_name(char_u **pp, bool skip,                     // only find the end, don't evaluate\n                            int flags, funcdict_T *fdp,               // return: info about dictionary used\n                            partial_T **partial            // return: partial of a FuncRef\n                            )\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  char_u *name = NULL;\n  const char_u *start;\n  const char_u *end;\n  int lead;\n  int len;\n  lval_T lv;\n\n  if (fdp != NULL) {\n    memset(fdp, 0, sizeof(funcdict_T));\n  }\n  start = *pp;\n\n  /* Check for hard coded <SNR>: already translated function ID (from a user\n   * command). */\n  if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n      && (*pp)[2] == (int)KE_SNR) {\n    *pp += 3;\n    len = get_id_len((const char **)pp) + 3;\n    return (char_u *)xmemdupz(start, len);\n  }\n\n  /* A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n   * don't skip over \"s:\", get_lval() needs it for \"s:dict.func\". */\n  lead = eval_fname_script((const char *)start);\n  if (lead > 2) {\n    start += lead;\n  }\n\n  // Note that TFN_ flags use the same values as GLV_ flags.\n  end = get_lval((char_u *)start, NULL, &lv, false, skip, flags | GLV_READ_ONLY,\n                 lead > 2 ? 0 : FNE_CHECK_START);\n  if (end == start) {\n    if (!skip) {\n      EMSG(_(\"E129: Function name required\"));\n    }\n    goto theend;\n  }\n  if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range))) {\n    /*\n     * Report an invalid expression in braces, unless the expression\n     * evaluation has been cancelled due to an aborting error, an\n     * interrupt, or an exception.\n     */\n    if (!aborting()) {\n      if (end != NULL) {\n        emsgf(_(e_invarg2), start);\n      }\n    } else {\n      *pp = (char_u *)find_name_end(start, NULL, NULL, FNE_INCL_BR);\n    }\n    goto theend;\n  }\n\n  if (lv.ll_tv != NULL) {\n    if (fdp != NULL) {\n      fdp->fd_dict = lv.ll_dict;\n      fdp->fd_newkey = lv.ll_newkey;\n      lv.ll_newkey = NULL;\n      fdp->fd_di = lv.ll_di;\n    }\n    if (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL) {\n      name = vim_strsave(lv.ll_tv->vval.v_string);\n      *pp = (char_u *)end;\n    } else if (lv.ll_tv->v_type == VAR_PARTIAL\n               && lv.ll_tv->vval.v_partial != NULL) {\n      if (is_luafunc(lv.ll_tv->vval.v_partial) && *end == '.') {\n        len = check_luafunc_name((const char *)end+1, true);\n        if (len == 0) {\n          EMSG2(e_invexpr2, \"v:lua\");\n          goto theend;\n        }\n        name = xmallocz(len);\n        memcpy(name, end+1, len);\n        *pp = (char_u *)end+1+len;\n      } else {\n        name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n        *pp = (char_u *)end;\n      }\n      if (partial != NULL) {\n        *partial = lv.ll_tv->vval.v_partial;\n      }\n    } else {\n      if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n                                            || lv.ll_dict == NULL\n                                            || fdp->fd_newkey == NULL)) {\n        EMSG(_(e_funcref));\n      } else {\n        *pp = (char_u *)end;\n      }\n      name = NULL;\n    }\n    goto theend;\n  }\n\n  if (lv.ll_name == NULL) {\n    // Error found, but continue after the function name.\n    *pp = (char_u *)end;\n    goto theend;\n  }\n\n  // Check if the name is a Funcref.  If so, use the value.\n  if (lv.ll_exp_name != NULL) {\n    len = (int)strlen(lv.ll_exp_name);\n    name = deref_func_name(lv.ll_exp_name, &len, partial,\n                           flags & TFN_NO_AUTOLOAD);\n    if ((const char *)name == lv.ll_exp_name) {\n      name = NULL;\n    }\n  } else if (!(flags & TFN_NO_DEREF)) {\n    len = (int)(end - *pp);\n    name = deref_func_name((const char *)(*pp), &len, partial,\n                           flags & TFN_NO_AUTOLOAD);\n    if (name == *pp) {\n      name = NULL;\n    }\n  }\n  if (name != NULL) {\n    name = vim_strsave(name);\n    *pp = (char_u *)end;\n    if (strncmp((char *)name, \"<SNR>\", 5) == 0) {\n      // Change \"<SNR>\" to the byte sequence.\n      name[0] = K_SPECIAL;\n      name[1] = KS_EXTRA;\n      name[2] = (int)KE_SNR;\n      memmove(name + 3, name + 5, strlen((char *)name + 5) + 1);\n    }\n    goto theend;\n  }\n\n  if (lv.ll_exp_name != NULL) {\n    len = (int)strlen(lv.ll_exp_name);\n    if (lead <= 2 && lv.ll_name == lv.ll_exp_name\n        && lv.ll_name_len >= 2 && memcmp(lv.ll_name, \"s:\", 2) == 0) {\n      // When there was \"s:\" already or the name expanded to get a\n      // leading \"s:\" then remove it.\n      lv.ll_name += 2;\n      lv.ll_name_len -= 2;\n      len -= 2;\n      lead = 2;\n    }\n  } else {\n    // Skip over \"s:\" and \"g:\".\n    if (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':')) {\n      lv.ll_name += 2;\n      lv.ll_name_len -= 2;\n    }\n    len = (int)((const char *)end - lv.ll_name);\n  }\n\n  size_t sid_buf_len = 0;\n  char sid_buf[20];\n\n  // Copy the function name to allocated memory.\n  // Accept <SID>name() inside a script, translate into <SNR>123_name().\n  // Accept <SNR>123_name() outside a script.\n  if (skip) {\n    lead = 0;  // do nothing\n  } else if (lead > 0) {\n    lead = 3;\n    if ((lv.ll_exp_name != NULL && eval_fname_sid(lv.ll_exp_name))\n        || eval_fname_sid((const char *)(*pp))) {\n      // It's \"s:\" or \"<SID>\".\n      if (current_sctx.sc_sid <= 0) {\n        EMSG(_(e_usingsid));\n        goto theend;\n      }\n      sid_buf_len = snprintf(sid_buf, sizeof(sid_buf),\n                             \"%\" PRIdSCID \"_\", current_sctx.sc_sid);\n      lead += sid_buf_len;\n    }\n  } else if (!(flags & TFN_INT)\n             && builtin_function(lv.ll_name, lv.ll_name_len)) {\n    EMSG2(_(\"E128: Function name must start with a capital or \\\"s:\\\": %s\"),\n          start);\n    goto theend;\n  }\n\n  if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF)) {\n    char_u *cp = xmemrchr(lv.ll_name, ':', lv.ll_name_len);\n\n    if (cp != NULL && cp < end) {\n      EMSG2(_(\"E884: Function name cannot contain a colon: %s\"), start);\n      goto theend;\n    }\n  }\n\n  name = xmalloc(len + lead + 1);\n  if (!skip && lead > 0) {\n    name[0] = K_SPECIAL;\n    name[1] = KS_EXTRA;\n    name[2] = (int)KE_SNR;\n    if (sid_buf_len > 0) {  // If it's \"<SID>\"\n      memcpy(name + 3, sid_buf, sid_buf_len);\n    }\n  }\n  memmove(name + lead, lv.ll_name, len);\n  name[lead + len] = NUL;\n  *pp = (char_u *)end;\n\ntheend:\n  clear_lval(&lv);\n  return name;\n}\n\n/*\n * \":function\"\n */\nvoid ex_function(exarg_T *eap)\n{\n  char_u *theline;\n  char_u *line_to_free = NULL;\n  int c;\n  int saved_did_emsg;\n  bool saved_wait_return = need_wait_return;\n  char_u *name = NULL;\n  char_u *p;\n  char_u *arg;\n  char_u *line_arg = NULL;\n  garray_T newargs;\n  garray_T default_args;\n  garray_T newlines;\n  int varargs = false;\n  int flags = 0;\n  ufunc_T *fp;\n  bool overwrite = false;\n  int indent;\n  int nesting;\n  dictitem_T *v;\n  funcdict_T fudi;\n  static int func_nr = 0;           // number for nameless function\n  int paren;\n  hashtab_T *ht;\n  int todo;\n  hashitem_T *hi;\n  linenr_T sourcing_lnum_off;\n  linenr_T sourcing_lnum_top;\n  bool is_heredoc = false;\n  char_u *skip_until = NULL;\n  char_u *heredoc_trimmed = NULL;\n  bool show_block = false;\n  bool do_concat = true;\n\n  /*\n   * \":function\" without argument: list functions.\n   */\n  if (ends_excmd(*eap->arg)) {\n    if (!eap->skip) {\n      todo = (int)func_hashtab.ht_used;\n      for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {\n        if (!HASHITEM_EMPTY(hi)) {\n          --todo;\n          fp = HI2UF(hi);\n          if (message_filtered(fp->uf_name)) {\n            continue;\n          }\n          if (!func_name_refcount(fp->uf_name)) {\n            list_func_head(fp, false, false);\n          }\n        }\n      }\n    }\n    eap->nextcmd = check_nextcmd(eap->arg);\n    return;\n  }\n\n  /*\n   * \":function /pat\": list functions matching pattern.\n   */\n  if (*eap->arg == '/') {\n    p = skip_regexp(eap->arg + 1, '/', TRUE, NULL);\n    if (!eap->skip) {\n      regmatch_T regmatch;\n\n      c = *p;\n      *p = NUL;\n      regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n      *p = c;\n      if (regmatch.regprog != NULL) {\n        regmatch.rm_ic = p_ic;\n\n        todo = (int)func_hashtab.ht_used;\n        for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {\n          if (!HASHITEM_EMPTY(hi)) {\n            --todo;\n            fp = HI2UF(hi);\n            if (!isdigit(*fp->uf_name)\n                && vim_regexec(&regmatch, fp->uf_name, 0)) {\n              list_func_head(fp, false, false);\n            }\n          }\n        }\n        vim_regfree(regmatch.regprog);\n      }\n    }\n    if (*p == '/') {\n      ++p;\n    }\n    eap->nextcmd = check_nextcmd(p);\n    return;\n  }\n\n  // Get the function name.  There are these situations:\n  // func        function name\n  //             \"name\" == func, \"fudi.fd_dict\" == NULL\n  // dict.func   new dictionary entry\n  //             \"name\" == NULL, \"fudi.fd_dict\" set,\n  //             \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n  // dict.func   existing dict entry with a Funcref\n  //             \"name\" == func, \"fudi.fd_dict\" set,\n  //             \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n  // dict.func   existing dict entry that's not a Funcref\n  //             \"name\" == NULL, \"fudi.fd_dict\" set,\n  //             \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n  // s:func      script-local function name\n  // g:func      global function name, same as \"func\"\n  p = eap->arg;\n  name = trans_function_name(&p, eap->skip, TFN_NO_AUTOLOAD, &fudi, NULL);\n  paren = (vim_strchr(p, '(') != NULL);\n  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip) {\n    /*\n     * Return on an invalid expression in braces, unless the expression\n     * evaluation has been cancelled due to an aborting error, an\n     * interrupt, or an exception.\n     */\n    if (!aborting()) {\n      if (fudi.fd_newkey != NULL) {\n        EMSG2(_(e_dictkey), fudi.fd_newkey);\n      }\n      xfree(fudi.fd_newkey);\n      return;\n    } else {\n      eap->skip = TRUE;\n    }\n  }\n\n  /* An error in a function call during evaluation of an expression in magic\n   * braces should not cause the function not to be defined. */\n  saved_did_emsg = did_emsg;\n  did_emsg = FALSE;\n\n  //\n  // \":function func\" with only function name: list function.\n  // If bang is given:\n  //  - include \"!\" in function head\n  //  - exclude line numbers from function body\n  //\n  if (!paren) {\n    if (!ends_excmd(*skipwhite(p))) {\n      EMSG(_(e_trailing));\n      goto ret_free;\n    }\n    eap->nextcmd = check_nextcmd(p);\n    if (eap->nextcmd != NULL) {\n      *p = NUL;\n    }\n    if (!eap->skip && !got_int) {\n      fp = find_func(name);\n      if (fp != NULL) {\n        list_func_head(fp, !eap->forceit, eap->forceit);\n        for (int j = 0; j < fp->uf_lines.ga_len && !got_int; j++) {\n          if (FUNCLINE(fp, j) == NULL) {\n            continue;\n          }\n          msg_putchar('\\n');\n          if (!eap->forceit) {\n            msg_outnum((long)j + 1);\n            if (j < 9) {\n              msg_putchar(' ');\n            }\n            if (j < 99) {\n              msg_putchar(' ');\n            }\n          }\n          msg_prt_line(FUNCLINE(fp, j), false);\n          ui_flush();                  // show a line at a time\n          os_breakcheck();\n        }\n        if (!got_int) {\n          msg_putchar('\\n');\n          msg_puts(eap->forceit ? \"endfunction\" : \"   endfunction\");\n        }\n      } else {\n        emsg_funcname(N_(\"E123: Undefined function: %s\"), name);\n      }\n    }\n    goto ret_free;\n  }\n\n  /*\n   * \":function name(arg1, arg2)\" Define function.\n   */\n  p = skipwhite(p);\n  if (*p != '(') {\n    if (!eap->skip) {\n      EMSG2(_(\"E124: Missing '(': %s\"), eap->arg);\n      goto ret_free;\n    }\n    // attempt to continue by skipping some text\n    if (vim_strchr(p, '(') != NULL) {\n      p = vim_strchr(p, '(');\n    }\n  }\n  p = skipwhite(p + 1);\n\n  ga_init(&newargs, (int)sizeof(char_u *), 3);\n  ga_init(&newlines, (int)sizeof(char_u *), 3);\n\n  if (!eap->skip) {\n    /* Check the name of the function.  Unless it's a dictionary function\n     * (that we are overwriting). */\n    if (name != NULL) {\n      arg = name;\n    } else {\n      arg = fudi.fd_newkey;\n    }\n    if (arg != NULL && (fudi.fd_di == NULL || !tv_is_func(fudi.fd_di->di_tv))) {\n      int j = (*arg == K_SPECIAL) ? 3 : 0;\n      while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])\n                                      : eval_isnamec(arg[j]))) {\n        ++j;\n      }\n      if (arg[j] != NUL) {\n        emsg_funcname((char *)e_invarg2, arg);\n      }\n    }\n    // Disallow using the g: dict.\n    if (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE) {\n      EMSG(_(\"E862: Cannot use g: here\"));\n    }\n  }\n\n  if (get_function_args(&p, ')', &newargs, &varargs,\n                        &default_args, eap->skip) == FAIL) {\n    goto errret_2;\n  }\n\n  if (KeyTyped && ui_has(kUICmdline)) {\n    show_block = true;\n    ui_ext_cmdline_block_append(0, (const char *)eap->cmd);\n  }\n\n  // find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n  for (;; ) {\n    p = skipwhite(p);\n    if (STRNCMP(p, \"range\", 5) == 0) {\n      flags |= FC_RANGE;\n      p += 5;\n    } else if (STRNCMP(p, \"dict\", 4) == 0) {\n      flags |= FC_DICT;\n      p += 4;\n    } else if (STRNCMP(p, \"abort\", 5) == 0) {\n      flags |= FC_ABORT;\n      p += 5;\n    } else if (STRNCMP(p, \"closure\", 7) == 0) {\n      flags |= FC_CLOSURE;\n      p += 7;\n      if (current_funccal == NULL) {\n        emsg_funcname(N_\n                        (\"E932: Closure function should not be at top level: %s\"),\n                      name == NULL ? (char_u *)\"\" : name);\n        goto erret;\n      }\n    } else {\n      break;\n    }\n  }\n\n  /* When there is a line break use what follows for the function body.\n   * Makes 'exe \"func Test()\\n...\\nendfunc\"' work. */\n  if (*p == '\\n') {\n    line_arg = p + 1;\n  } else if (*p != NUL && *p != '\"' && !eap->skip && !did_emsg) {\n    EMSG(_(e_trailing));\n  }\n\n  /*\n   * Read the body of the function, until \":endfunction\" is found.\n   */\n  if (KeyTyped) {\n    /* Check if the function already exists, don't let the user type the\n     * whole function before telling him it doesn't work!  For a script we\n     * need to skip the body to be able to find what follows. */\n    if (!eap->skip && !eap->forceit) {\n      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL) {\n        EMSG(_(e_funcdict));\n      } else if (name != NULL && find_func(name) != NULL) {\n        emsg_funcname(e_funcexts, name);\n      }\n    }\n\n    if (!eap->skip && did_emsg) {\n      goto erret;\n    }\n\n    if (!ui_has(kUICmdline)) {\n      msg_putchar('\\n');              // don't overwrite the function name\n    }\n    cmdline_row = msg_row;\n  }\n\n  // Save the starting line number.\n  sourcing_lnum_top = sourcing_lnum;\n\n  indent = 2;\n  nesting = 0;\n  for (;; ) {\n    if (KeyTyped) {\n      msg_scroll = true;\n      saved_wait_return = false;\n    }\n    need_wait_return = false;\n\n    if (line_arg != NULL) {\n      // Use eap->arg, split up in parts by line breaks.\n      theline = line_arg;\n      p = vim_strchr(theline, '\\n');\n      if (p == NULL) {\n        line_arg += STRLEN(line_arg);\n      } else {\n        *p = NUL;\n        line_arg = p + 1;\n      }\n    } else {\n      xfree(line_to_free);\n      if (eap->getline == NULL) {\n        theline = getcmdline(':', 0L, indent, do_concat);\n      } else {\n        theline = eap->getline(':', eap->cookie, indent, do_concat);\n      }\n      line_to_free = theline;\n    }\n    if (KeyTyped) {\n      lines_left = Rows - 1;\n    }\n    if (theline == NULL) {\n      EMSG(_(\"E126: Missing :endfunction\"));\n      goto erret;\n    }\n    if (show_block) {\n      assert(indent >= 0);\n      ui_ext_cmdline_block_append((size_t)indent, (const char *)theline);\n    }\n\n    // Detect line continuation: sourcing_lnum increased more than one.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (sourcing_lnum < sourcing_lnum_off) {\n      sourcing_lnum_off -= sourcing_lnum;\n    } else {\n      sourcing_lnum_off = 0;\n    }\n\n    if (skip_until != NULL) {\n      // Don't check for \":endfunc\" between\n      // * \":append\" and \".\"\n      // * \":python <<EOF\" and \"EOF\"\n      // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n      if (heredoc_trimmed == NULL\n          || (is_heredoc && skipwhite(theline) == theline)\n          || STRNCMP(theline, heredoc_trimmed,\n                     STRLEN(heredoc_trimmed)) == 0) {\n        if (heredoc_trimmed == NULL) {\n          p = theline;\n        } else if (is_heredoc) {\n          p = skipwhite(theline) == theline\n            ? theline : theline + STRLEN(heredoc_trimmed);\n        } else {\n          p = theline + STRLEN(heredoc_trimmed);\n        }\n        if (STRCMP(p, skip_until) == 0) {\n          XFREE_CLEAR(skip_until);\n          XFREE_CLEAR(heredoc_trimmed);\n          do_concat = true;\n          is_heredoc = false;\n        }\n      }\n    } else {\n      // skip ':' and blanks\n      for (p = theline; ascii_iswhite(*p) || *p == ':'; p++) {\n      }\n\n      // Check for \"endfunction\".\n      if (checkforcmd(&p, \"endfunction\", 4) && nesting-- == 0) {\n        if (*p == '!') {\n          p++;\n        }\n        char_u *nextcmd = NULL;\n        if (*p == '|') {\n          nextcmd = p + 1;\n        } else if (line_arg != NULL && *skipwhite(line_arg) != NUL) {\n          nextcmd = line_arg;\n        } else if (*p != NUL && *p != '\"' && p_verbose > 0) {\n          give_warning2((char_u *)_(\"W22: Text found after :endfunction: %s\"),\n                        p, true);\n        }\n        if (nextcmd != NULL) {\n          // Another command follows. If the line came from \"eap\" we\n          // can simply point into it, otherwise we need to change\n          // \"eap->cmdlinep\".\n          eap->nextcmd = nextcmd;\n          if (line_to_free != NULL) {\n            xfree(*eap->cmdlinep);\n            *eap->cmdlinep = line_to_free;\n            line_to_free = NULL;\n          }\n        }\n        break;\n      }\n\n      /* Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n       * at \"end\". */\n      if (indent > 2 && STRNCMP(p, \"end\", 3) == 0) {\n        indent -= 2;\n      } else if (STRNCMP(p, \"if\", 2) == 0\n                 || STRNCMP(p, \"wh\", 2) == 0\n                 || STRNCMP(p, \"for\", 3) == 0\n                 || STRNCMP(p, \"try\", 3) == 0) {\n        indent += 2;\n      }\n\n      // Check for defining a function inside this function.\n      if (checkforcmd(&p, \"function\", 2)) {\n        if (*p == '!') {\n          p = skipwhite(p + 1);\n        }\n        p += eval_fname_script((const char *)p);\n        xfree(trans_function_name(&p, true, 0, NULL, NULL));\n        if (*skipwhite(p) == '(') {\n          nesting++;\n          indent += 2;\n        }\n      }\n\n      // Check for \":append\", \":change\", \":insert\".\n      p = skip_range(p, NULL);\n      if ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n          || (p[0] == 'c'\n              && (!ASCII_ISALPHA(p[1])\n                  || (p[1] == 'h' && (!ASCII_ISALPHA(p[2])\n                                      || (p[2] == 'a'\n                                          && (STRNCMP(&p[3], \"nge\", 3) != 0\n                                              || !ASCII_ISALPHA(p[6])))))))\n          || (p[0] == 'i'\n              && (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n                                           && (!ASCII_ISALPHA(p[2])\n                                               || (p[2] == 's')))))) {\n        skip_until = vim_strsave((char_u *)\".\");\n      }\n\n      // heredoc: Check for \":python <<EOF\", \":lua <<EOF\", etc.\n      arg = skipwhite(skiptowhite(p));\n      if (arg[0] == '<' && arg[1] =='<'\n          && ((p[0] == 'p' && p[1] == 'y'\n               && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n                   || ((p[2] == '3' || p[2] == 'x')\n                       && !ASCII_ISALPHA(p[3]))))\n              || (p[0] == 'p' && p[1] == 'e'\n                  && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n              || (p[0] == 't' && p[1] == 'c'\n                  && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n              || (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n                  && !ASCII_ISALPHA(p[3]))\n              || (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n                  && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n              || (p[0] == 'm' && p[1] == 'z'\n                  && (!ASCII_ISALPHA(p[2]) || p[2] == 's')))) {\n        // \":python <<\" continues until a dot, like \":append\"\n        p = skipwhite(arg + 2);\n        if (*p == NUL) {\n          skip_until = vim_strsave((char_u *)\".\");\n        } else {\n          skip_until = vim_strsave(p);\n        }\n      }\n\n      // Check for \":let v =<< [trim] EOF\"\n      //       and \":let [a, b] =<< [trim] EOF\"\n      arg = skipwhite(skiptowhite(p));\n      if (*arg == '[') {\n        arg = vim_strchr(arg, ']');\n      }\n      if (arg != NULL) {\n        arg = skipwhite(skiptowhite(arg));\n        if (arg[0] == '='\n            && arg[1] == '<'\n            && arg[2] =='<'\n            && (p[0] == 'l'\n                && p[1] == 'e'\n                && (!ASCII_ISALNUM(p[2])\n                    || (p[2] == 't' && !ASCII_ISALNUM(p[3]))))) {\n          p = skipwhite(arg + 3);\n          if (STRNCMP(p, \"trim\", 4) == 0) {\n            // Ignore leading white space.\n            p = skipwhite(p + 4);\n            heredoc_trimmed =\n              vim_strnsave(theline, skipwhite(theline) - theline);\n          }\n          skip_until = vim_strnsave(p, skiptowhite(p) - p);\n          do_concat = false;\n          is_heredoc = true;\n        }\n      }\n    }\n\n    // Add the line to the function.\n    ga_grow(&newlines, 1 + sourcing_lnum_off);\n\n    /* Copy the line to newly allocated memory.  get_one_sourceline()\n     * allocates 250 bytes per line, this saves 80% on average.  The cost\n     * is an extra alloc/free. */\n    p = vim_strsave(theline);\n    ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\n    /* Add NULL lines for continuation lines, so that the line count is\n     * equal to the index in the growarray.   */\n    while (sourcing_lnum_off-- > 0) {\n      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;\n    }\n\n    // Check for end of eap->arg.\n    if (line_arg != NULL && *line_arg == NUL) {\n      line_arg = NULL;\n    }\n  }\n\n  /* Don't define the function when skipping commands or when an error was\n   * detected. */\n  if (eap->skip || did_emsg) {\n    goto erret;\n  }\n\n  /*\n   * If there are no errors, add the function\n   */\n  if (fudi.fd_dict == NULL) {\n    v = find_var((const char *)name, STRLEN(name), &ht, false);\n    if (v != NULL && v->di_tv.v_type == VAR_FUNC) {\n      emsg_funcname(N_(\"E707: Function name conflicts with variable: %s\"),\n                    name);\n      goto erret;\n    }\n\n    fp = find_func(name);\n    if (fp != NULL) {\n      // Function can be replaced with \"function!\" and when sourcing the\n      // same script again, but only once.\n      if (!eap->forceit\n          && (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n              || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)) {\n        emsg_funcname(e_funcexts, name);\n        goto erret;\n      }\n      if (fp->uf_calls > 0) {\n        emsg_funcname(N_(\"E127: Cannot redefine function %s: It is in use\"),\n                      name);\n        goto erret;\n      }\n      if (fp->uf_refcount > 1) {\n        // This function is referenced somewhere, don't redefine it but\n        // create a new one.\n        (fp->uf_refcount)--;\n        fp->uf_flags |= FC_REMOVED;\n        fp = NULL;\n        overwrite = true;\n      } else {\n        // redefine existing function\n        XFREE_CLEAR(name);\n        func_clear_items(fp);\n        fp->uf_profiling = false;\n        fp->uf_prof_initialized = false;\n      }\n    }\n  } else {\n    char numbuf[20];\n\n    fp = NULL;\n    if (fudi.fd_newkey == NULL && !eap->forceit) {\n      EMSG(_(e_funcdict));\n      goto erret;\n    }\n    if (fudi.fd_di == NULL) {\n      if (var_check_lock(fudi.fd_dict->dv_lock, (const char *)eap->arg,\n                         TV_CSTRING)) {\n        // Can't add a function to a locked dictionary\n        goto erret;\n      }\n    } else if (var_check_lock(fudi.fd_di->di_tv.v_lock, (const char *)eap->arg,\n                              TV_CSTRING)) {\n      // Can't change an existing function if it is locked\n      goto erret;\n    }\n\n    /* Give the function a sequential number.  Can only be used with a\n     * Funcref! */\n    xfree(name);\n    sprintf(numbuf, \"%d\", ++func_nr);\n    name = vim_strsave((char_u *)numbuf);\n  }\n\n  if (fp == NULL) {\n    if (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL) {\n      int slen, plen;\n      char_u *scriptname;\n\n      // Check that the autoload name matches the script name.\n      int j = FAIL;\n      if (sourcing_name != NULL) {\n        scriptname = (char_u *)autoload_name((const char *)name, STRLEN(name));\n        p = vim_strchr(scriptname, '/');\n        plen = (int)STRLEN(p);\n        slen = (int)STRLEN(sourcing_name);\n        if (slen > plen && fnamecmp(p,\n                                    sourcing_name + slen - plen) == 0) {\n          j = OK;\n        }\n        xfree(scriptname);\n      }\n      if (j == FAIL) {\n        EMSG2(_(\"E746: Function name does not match script file name: %s\"),\n              name);\n        goto erret;\n      }\n    }\n\n    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\n    if (fudi.fd_dict != NULL) {\n      if (fudi.fd_di == NULL) {\n        // Add new dict entry\n        fudi.fd_di = tv_dict_item_alloc((const char *)fudi.fd_newkey);\n        if (tv_dict_add(fudi.fd_dict, fudi.fd_di) == FAIL) {\n          xfree(fudi.fd_di);\n          xfree(fp);\n          goto erret;\n        }\n      } else {\n        // Overwrite existing dict entry.\n        tv_clear(&fudi.fd_di->di_tv);\n      }\n      fudi.fd_di->di_tv.v_type = VAR_FUNC;\n      fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n      // behave like \"dict\" was used\n      flags |= FC_DICT;\n    }\n\n    // insert the new function in the function list\n    STRCPY(fp->uf_name, name);\n    if (overwrite) {\n      hi = hash_find(&func_hashtab, name);\n      hi->hi_key = UF2HIKEY(fp);\n    } else if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL) {\n      xfree(fp);\n      goto erret;\n    }\n    fp->uf_refcount = 1;\n  }\n  fp->uf_args = newargs;\n  fp->uf_def_args = default_args;\n  fp->uf_lines = newlines;\n  if ((flags & FC_CLOSURE) != 0) {\n    register_closure(fp);\n  } else {\n    fp->uf_scoped = NULL;\n  }\n  if (prof_def_func()) {\n    func_do_profile(fp);\n  }\n  fp->uf_varargs = varargs;\n  if (sandbox) {\n    flags |= FC_SANDBOX;\n  }\n  fp->uf_flags = flags;\n  fp->uf_calls = 0;\n  fp->uf_script_ctx = current_sctx;\n  fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n\n  goto ret_free;\n\nerret:\n  ga_clear_strings(&newargs);\n  ga_clear_strings(&default_args);\nerrret_2:\n  ga_clear_strings(&newlines);\nret_free:\n  xfree(skip_until);\n  xfree(heredoc_trimmed);\n  xfree(line_to_free);\n  xfree(fudi.fd_newkey);\n  xfree(name);\n  did_emsg |= saved_did_emsg;\n  need_wait_return |= saved_wait_return;\n  if (show_block) {\n    ui_ext_cmdline_block_leave();\n  }\n}  // NOLINT(readability/fn_size)\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\nint eval_fname_script(const char *const p)\n{\n  // Use mb_strnicmp() because in Turkish comparing the \"I\" may not work with\n  // the standard library function.\n  if (p[0] == '<'\n      && (mb_strnicmp((char_u *)p + 1, (char_u *)\"SID>\", 4) == 0\n          || mb_strnicmp((char_u *)p + 1, (char_u *)\"SNR>\", 4) == 0)) {\n    return 5;\n  }\n  if (p[0] == 's' && p[1] == ':') {\n    return 2;\n  }\n  return 0;\n}\n\nbool translated_function_exists(const char *name)\n{\n  if (builtin_function(name, -1)) {\n    return find_internal_func((char *)name) != NULL;\n  }\n  return find_func((const char_u *)name) != NULL;\n}\n\n/// Check whether function with the given name exists\n///\n/// @param[in]  name  Function name.\n/// @param[in]  no_deref  Whether to dereference a Funcref.\n///\n/// @return True if it exists, false otherwise.\nbool function_exists(const char *const name, bool no_deref)\n{\n  const char_u *nm = (const char_u *)name;\n  bool n = false;\n  int flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n\n  if (no_deref) {\n    flag |= TFN_NO_DEREF;\n  }\n  char *const p = (char *)trans_function_name((char_u **)&nm, false, flag, NULL,\n                                              NULL);\n  nm = skipwhite(nm);\n\n  /* Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n   * \"funcname(...\", not \"funcname!...\". */\n  if (p != NULL && (*nm == NUL || *nm == '(')) {\n    n = translated_function_exists(p);\n  }\n  xfree(p);\n  return n;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\nchar_u *get_user_func_name(expand_T *xp, int idx)\n{\n  static size_t done;\n  static hashitem_T *hi;\n  ufunc_T *fp;\n\n  if (idx == 0) {\n    done = 0;\n    hi = func_hashtab.ht_array;\n  }\n  assert(hi);\n  if (done < func_hashtab.ht_used) {\n    if (done++ > 0) {\n      ++hi;\n    }\n    while (HASHITEM_EMPTY(hi)) {\n      ++hi;\n    }\n    fp = HI2UF(hi);\n\n    if ((fp->uf_flags & FC_DICT)\n        || STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0) {\n      return (char_u *)\"\";       // don't show dict and lambda functions\n    }\n\n    if (STRLEN(fp->uf_name) + 4 >= IOSIZE) {\n      return fp->uf_name;  // Prevent overflow.\n    }\n\n    cat_func_name(IObuff, fp);\n    if (xp->xp_context != EXPAND_USER_FUNC) {\n      STRCAT(IObuff, \"(\");\n      if (!fp->uf_varargs && GA_EMPTY(&fp->uf_args)) {\n        STRCAT(IObuff, \")\");\n      }\n    }\n    return IObuff;\n  }\n  return NULL;\n}\n\n/// \":delfunction {name}\"\nvoid ex_delfunction(exarg_T *eap)\n{\n  ufunc_T *fp = NULL;\n  char_u *p;\n  char_u *name;\n  funcdict_T fudi;\n\n  p = eap->arg;\n  name = trans_function_name(&p, eap->skip, 0, &fudi, NULL);\n  xfree(fudi.fd_newkey);\n  if (name == NULL) {\n    if (fudi.fd_dict != NULL && !eap->skip) {\n      EMSG(_(e_funcref));\n    }\n    return;\n  }\n  if (!ends_excmd(*skipwhite(p))) {\n    xfree(name);\n    EMSG(_(e_trailing));\n    return;\n  }\n  eap->nextcmd = check_nextcmd(p);\n  if (eap->nextcmd != NULL) {\n    *p = NUL;\n  }\n\n  if (!eap->skip) {\n    fp = find_func(name);\n  }\n  xfree(name);\n\n  if (!eap->skip) {\n    if (fp == NULL) {\n      if (!eap->forceit) {\n        EMSG2(_(e_nofunc), eap->arg);\n      }\n      return;\n    }\n    if (fp->uf_calls > 0) {\n      EMSG2(_(\"E131: Cannot delete function %s: It is in use\"), eap->arg);\n      return;\n    }\n    // check `uf_refcount > 2` because deleting a function should also reduce\n    // the reference count, and 1 is the initial refcount.\n    if (fp->uf_refcount > 2) {\n      EMSG2(_(\"Cannot delete function %s: It is being used internally\"),\n            eap->arg);\n      return;\n    }\n\n    if (fudi.fd_dict != NULL) {\n      // Delete the dict item that refers to the function, it will\n      // invoke func_unref() and possibly delete the function.\n      tv_dict_item_remove(fudi.fd_dict, fudi.fd_di);\n    } else {\n      // A normal function (not a numbered function or lambda) has a\n      // refcount of 1 for the entry in the hashtable.  When deleting\n      // it and the refcount is more than one, it should be kept.\n      // A numbered function or lambda should be kept if the refcount is\n      // one or more.\n      if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1)) {\n        // Function is still referenced somewhere. Don't free it but\n        // do remove it from the hashtable.\n        if (func_remove(fp)) {\n          fp->uf_refcount--;\n        }\n        fp->uf_flags |= FC_DELETED;\n      } else {\n        func_clear_free(fp, false);\n      }\n    }\n  }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\nvoid func_unref(char_u *name)\n{\n  ufunc_T *fp = NULL;\n\n  if (name == NULL || !func_name_refcount(name)) {\n    return;\n  }\n\n  fp = find_func(name);\n  if (fp == NULL && isdigit(*name)) {\n#ifdef EXITFREE\n    if (!entered_free_all_mem) {\n      internal_error(\"func_unref()\");\n      abort();\n    }\n#else\n    internal_error(\"func_unref()\");\n    abort();\n#endif\n  }\n  func_ptr_unref(fp);\n}\n\n/// Unreference a Function: decrement the reference count and free it when it\n/// becomes zero.\n/// Unreference user function, freeing it if needed\n///\n/// Decrements the reference count and frees when it becomes zero.\n///\n/// @param  fp  Function to unreference.\nvoid func_ptr_unref(ufunc_T *fp)\n{\n  if (fp != NULL && --fp->uf_refcount <= 0) {\n    // Only delete it when it's not being used. Otherwise it's done\n    // when \"uf_calls\" becomes zero.\n    if (fp->uf_calls == 0) {\n      func_clear_free(fp, false);\n    }\n  }\n}\n\n/// Count a reference to a Function.\nvoid func_ref(char_u *name)\n{\n  ufunc_T *fp;\n\n  if (name == NULL || !func_name_refcount(name)) {\n    return;\n  }\n  fp = find_func(name);\n  if (fp != NULL) {\n    (fp->uf_refcount)++;\n  } else if (isdigit(*name)) {\n    // Only give an error for a numbered function.\n    // Fail silently, when named or lambda function isn't found.\n    internal_error(\"func_ref()\");\n  }\n}\n\n/// Count a reference to a Function.\nvoid func_ptr_ref(ufunc_T *fp)\n{\n  if (fp != NULL) {\n    (fp->uf_refcount)++;\n  }\n}\n\n/// Check whether funccall is still referenced outside\n///\n/// It is supposed to be referenced if either it is referenced itself or if l:,\n/// a: or a:000 are referenced as all these are statically allocated within\n/// funccall structure.\nstatic inline bool fc_referenced(const funccall_T *const fc)\n  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n  FUNC_ATTR_NONNULL_ALL\n{\n  return ((fc->l_varlist.lv_refcount  // NOLINT(runtime/deprecated)\n           != DO_NOT_FREE_CNT)\n          || fc->l_vars.dv_refcount != DO_NOT_FREE_CNT\n          || fc->l_avars.dv_refcount != DO_NOT_FREE_CNT\n          || fc->fc_refcount > 0);\n}\n\n/// @return true if items in \"fc\" do not have \"copyID\".  That means they are not\n/// referenced from anywhere that is in use.\nstatic int can_free_funccal(funccall_T *fc, int copyID)\n{\n  return fc->l_varlist.lv_copyID != copyID\n         && fc->l_vars.dv_copyID != copyID\n         && fc->l_avars.dv_copyID != copyID\n         && fc->fc_copyID != copyID;\n}\n\n/*\n * \":return [expr]\"\n */\nvoid ex_return(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  typval_T rettv;\n  int returning = FALSE;\n\n  if (current_funccal == NULL) {\n    EMSG(_(\"E133: :return not inside a function\"));\n    return;\n  }\n\n  if (eap->skip) {\n    ++emsg_skip;\n  }\n\n  eap->nextcmd = NULL;\n  if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n      && eval0(arg, &rettv, &eap->nextcmd, !eap->skip) != FAIL) {\n    if (!eap->skip) {\n      returning = do_return(eap, false, true, &rettv);\n    } else {\n      tv_clear(&rettv);\n    }\n  } else if (!eap->skip) {  // It's safer to return also on error.\n    // In return statement, cause_abort should be force_abort.\n    update_force_abort();\n\n    // Return unless the expression evaluation has been cancelled due to an\n    // aborting error, an interrupt, or an exception.\n    if (!aborting()) {\n      returning = do_return(eap, false, true, NULL);\n    }\n  }\n\n  /* When skipping or the return gets pending, advance to the next command\n   * in this line (!returning).  Otherwise, ignore the rest of the line.\n   * Following lines will be ignored by get_func_line(). */\n  if (returning) {\n    eap->nextcmd = NULL;\n  } else if (eap->nextcmd == NULL) {          // no argument\n    eap->nextcmd = check_nextcmd(arg);\n  }\n\n  if (eap->skip) {\n    --emsg_skip;\n  }\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/*\n * \":1,25call func(arg1, arg2)\" function call.\n */\nvoid ex_call(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  char_u *startarg;\n  char_u *name;\n  char_u *tofree;\n  int len;\n  typval_T rettv;\n  linenr_T lnum;\n  bool doesrange;\n  bool failed = false;\n  funcdict_T fudi;\n  partial_T *partial = NULL;\n\n  if (eap->skip) {\n    // trans_function_name() doesn't work well when skipping, use eval0()\n    // instead to skip to any following command, e.g. for:\n    //   :if 0 | call dict.foo().bar() | endif.\n    emsg_skip++;\n    if (eval0(eap->arg, &rettv, &eap->nextcmd, false) != FAIL) {\n      tv_clear(&rettv);\n    }\n    emsg_skip--;\n    return;\n  }\n\n  tofree = trans_function_name(&arg, false, TFN_INT, &fudi, &partial);\n  if (fudi.fd_newkey != NULL) {\n    // Still need to give an error message for missing key.\n    EMSG2(_(e_dictkey), fudi.fd_newkey);\n    xfree(fudi.fd_newkey);\n  }\n  if (tofree == NULL) {\n    return;\n  }\n\n  // Increase refcount on dictionary, it could get deleted when evaluating\n  // the arguments.\n  if (fudi.fd_dict != NULL) {\n    fudi.fd_dict->dv_refcount++;\n  }\n\n  // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n  // contents. For VAR_PARTIAL get its partial, unless we already have one\n  // from trans_function_name().\n  len = (int)STRLEN(tofree);\n  name = deref_func_name((const char *)tofree, &len,\n                         partial != NULL ? NULL : &partial, false);\n\n  // Skip white space to allow \":call func ()\".  Not good, but required for\n  // backward compatibility.\n  startarg = skipwhite(arg);\n  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this.\n\n  if (*startarg != '(') {\n    EMSG2(_(e_missingparen), eap->arg);\n    goto end;\n  }\n\n  lnum = eap->line1;\n  for (; lnum <= eap->line2; lnum++) {\n    if (eap->addr_count > 0) {  // -V560\n      if (lnum > curbuf->b_ml.ml_line_count) {\n        // If the function deleted lines or switched to another buffer\n        // the line number may become invalid.\n        EMSG(_(e_invrange));\n        break;\n      }\n      curwin->w_cursor.lnum = lnum;\n      curwin->w_cursor.col = 0;\n      curwin->w_cursor.coladd = 0;\n    }\n    arg = startarg;\n\n    funcexe_T funcexe = FUNCEXE_INIT;\n    funcexe.firstline = eap->line1;\n    funcexe.lastline = eap->line2;\n    funcexe.doesrange = &doesrange;\n    funcexe.evaluate = true;\n    funcexe.partial = partial;\n    funcexe.selfdict = fudi.fd_dict;\n    if (get_func_tv(name, -1, &rettv, &arg, &funcexe) == FAIL) {\n      failed = true;\n      break;\n    }\n\n    // Handle a function returning a Funcref, Dictionary or List.\n    if (handle_subscript((const char **)&arg, &rettv, true, true,\n                         (const char_u *)name, (const char_u **)&name)\n        == FAIL) {\n      failed = true;\n      break;\n    }\n\n    tv_clear(&rettv);\n    if (doesrange) {\n      break;\n    }\n\n    // Stop when immediately aborting on error, or when an interrupt\n    // occurred or an exception was thrown but not caught.\n    // get_func_tv() returned OK, so that the check for trailing\n    // characters below is executed.\n    if (aborting()) {\n      break;\n    }\n  }\n\n  // When inside :try we need to check for following \"| catch\".\n  if (!failed || eap->cstack->cs_trylevel > 0) {\n    // Check for trailing illegal characters and a following command.\n    if (!ends_excmd(*arg)) {\n      if (!failed) {\n        emsg_severe = true;\n        EMSG(_(e_trailing));\n      }\n    } else {\n      eap->nextcmd = check_nextcmd(arg);\n    }\n  }\n\nend:\n  tv_dict_unref(fudi.fd_dict);\n  xfree(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\nint do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv)\n{\n  int idx;\n  cstack_T *const cstack = eap->cstack;\n\n  if (reanimate) {\n    // Undo the return.\n    current_funccal->returned = false;\n  }\n\n  //\n  // Cleanup (and deactivate) conditionals, but stop when a try conditional\n  // not in its finally clause (which then is to be executed next) is found.\n  // In this case, make the \":return\" pending for execution at the \":endtry\".\n  // Otherwise, return normally.\n  //\n  idx = cleanup_conditionals(eap->cstack, 0, true);\n  if (idx >= 0) {\n    cstack->cs_pending[idx] = CSTP_RETURN;\n\n    if (!is_cmd && !reanimate) {\n      /* A pending return again gets pending.  \"rettv\" points to an\n       * allocated variable with the rettv of the original \":return\"'s\n       * argument if present or is NULL else. */\n      cstack->cs_rettv[idx] = rettv;\n    } else {\n      /* When undoing a return in order to make it pending, get the stored\n       * return rettv. */\n      if (reanimate) {\n        assert(current_funccal->rettv);\n        rettv = current_funccal->rettv;\n      }\n\n      if (rettv != NULL) {\n        // Store the value of the pending return.\n        cstack->cs_rettv[idx] = xcalloc(1, sizeof(typval_T));\n        *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n      } else {\n        cstack->cs_rettv[idx] = NULL;\n      }\n\n      if (reanimate) {\n        /* The pending return value could be overwritten by a \":return\"\n         * without argument in a finally clause; reset the default\n         * return value. */\n        current_funccal->rettv->v_type = VAR_NUMBER;\n        current_funccal->rettv->vval.v_number = 0;\n      }\n    }\n    report_make_pending(CSTP_RETURN, rettv);\n  } else {\n    current_funccal->returned = TRUE;\n\n    /* If the return is carried out now, store the return value.  For\n     * a return immediately after reanimation, the value is already\n     * there. */\n    if (!reanimate && rettv != NULL) {\n      tv_clear(current_funccal->rettv);\n      *current_funccal->rettv = *(typval_T *)rettv;\n      if (!is_cmd) {\n        xfree(rettv);\n      }\n    }\n  }\n\n  return idx < 0;\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\nchar_u *get_return_cmd(void *rettv)\n{\n  char_u *s = NULL;\n  char_u *tofree = NULL;\n\n  if (rettv != NULL) {\n    tofree = s = (char_u *)encode_tv2echo((typval_T *)rettv, NULL);\n  }\n  if (s == NULL) {\n    s = (char_u *)\"\";\n  }\n\n  STRCPY(IObuff, \":return \");\n  STRLCPY(IObuff + 8, s, IOSIZE - 8);\n  if (STRLEN(s) + 8 >= IOSIZE) {\n    STRCPY(IObuff + IOSIZE - 4, \"...\");\n  }\n  xfree(tofree);\n  return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\nchar_u *get_func_line(int c, void *cookie, int indent, bool do_concat)\n{\n  funccall_T *fcp = (funccall_T *)cookie;\n  ufunc_T *fp = fcp->func;\n  char_u *retval;\n  garray_T *gap;    // growarray with function lines\n\n  // If breakpoints have been added/deleted need to check for it.\n  if (fcp->dbg_tick != debug_tick) {\n    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n                                          sourcing_lnum);\n    fcp->dbg_tick = debug_tick;\n  }\n  if (do_profiling == PROF_YES) {\n    func_line_end(cookie);\n  }\n\n  gap = &fp->uf_lines;\n  if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n      || fcp->returned) {\n    retval = NULL;\n  } else {\n    // Skip NULL lines (continuation lines).\n    while (fcp->linenr < gap->ga_len\n           && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL) {\n      fcp->linenr++;\n    }\n    if (fcp->linenr >= gap->ga_len) {\n      retval = NULL;\n    } else {\n      retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n      sourcing_lnum = fcp->linenr;\n      if (do_profiling == PROF_YES) {\n        func_line_start(cookie);\n      }\n    }\n  }\n\n  // Did we encounter a breakpoint?\n  if (fcp->breakpoint != 0 && fcp->breakpoint <= sourcing_lnum) {\n    dbg_breakpoint(fp->uf_name, sourcing_lnum);\n    // Find next breakpoint.\n    fcp->breakpoint = dbg_find_breakpoint(false, fp->uf_name,\n                                          sourcing_lnum);\n    fcp->dbg_tick = debug_tick;\n  }\n\n  return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\nint func_has_ended(void *cookie)\n{\n  funccall_T *fcp = (funccall_T *)cookie;\n\n  /* Ignore the \"abort\" flag if the abortion behavior has been changed due to\n   * an error inside a try conditional. */\n  return ((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n         || fcp->returned;\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\nint func_has_abort(void *cookie)\n{\n  return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n/// Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n/// Changes \"rettv\" in-place.\nvoid make_partial(dict_T *const selfdict, typval_T *const rettv)\n{\n  char_u *fname;\n  char_u *tofree = NULL;\n  ufunc_T *fp;\n  char_u fname_buf[FLEN_FIXED + 1];\n  int error;\n\n  if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL) {\n    fp = rettv->vval.v_partial->pt_func;\n  } else {\n    fname = rettv->v_type == VAR_FUNC || rettv->v_type == VAR_STRING\n                                      ? rettv->vval.v_string\n                                      : rettv->vval.v_partial->pt_name;\n    // Translate \"s:func\" to the stored function name.\n    fname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n    fp = find_func(fname);\n    xfree(tofree);\n  }\n\n  // Turn \"dict.Func\" into a partial for \"Func\" with \"dict\".\n  if (fp != NULL && (fp->uf_flags & FC_DICT)) {\n    partial_T *pt = (partial_T *)xcalloc(1, sizeof(partial_T));\n    pt->pt_refcount = 1;\n    pt->pt_dict = selfdict;\n    (selfdict->dv_refcount)++;\n    pt->pt_auto = true;\n    if (rettv->v_type == VAR_FUNC || rettv->v_type == VAR_STRING) {\n      // Just a function: Take over the function name and use selfdict.\n      pt->pt_name = rettv->vval.v_string;\n    } else {\n      partial_T *ret_pt = rettv->vval.v_partial;\n      int i;\n\n      // Partial: copy the function name, use selfdict and copy\n      // args. Can't take over name or args, the partial might\n      // be referenced elsewhere.\n      if (ret_pt->pt_name != NULL) {\n        pt->pt_name = vim_strsave(ret_pt->pt_name);\n        func_ref(pt->pt_name);\n      } else {\n        pt->pt_func = ret_pt->pt_func;\n        func_ptr_ref(pt->pt_func);\n      }\n      if (ret_pt->pt_argc > 0) {\n        size_t arg_size = sizeof(typval_T) * ret_pt->pt_argc;\n        pt->pt_argv = (typval_T *)xmalloc(arg_size);\n        pt->pt_argc = ret_pt->pt_argc;\n        for (i = 0; i < pt->pt_argc; i++) {\n          tv_copy(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n        }\n      }\n      partial_unref(ret_pt);\n    }\n    rettv->v_type = VAR_PARTIAL;\n    rettv->vval.v_partial = pt;\n  }\n}\n\n/*\n * Return the name of the executed function.\n */\nchar_u *func_name(void *cookie)\n{\n  return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\nlinenr_T *func_breakpoint(void *cookie)\n{\n  return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\nint *func_dbg_tick(void *cookie)\n{\n  return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\nint func_level(void *cookie)\n{\n  return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\nint current_func_returned(void)\n{\n  return current_funccal->returned;\n}\n\nbool free_unref_funccal(int copyID, int testing)\n{\n  bool did_free = false;\n  bool did_free_funccal = false;\n\n  for (funccall_T **pfc = &previous_funccal; *pfc != NULL;) {\n    if (can_free_funccal(*pfc, copyID)) {\n      funccall_T *fc = *pfc;\n      *pfc = fc->caller;\n      free_funccal_contents(fc);\n      did_free = true;\n      did_free_funccal = true;\n    } else {\n      pfc = &(*pfc)->caller;\n    }\n  }\n  if (did_free_funccal) {\n    // When a funccal was freed some more items might be garbage\n    // collected, so run again.\n    (void)garbage_collect(testing);\n  }\n  return did_free;\n}\n\n// Get function call environment based on backtrace debug level\nfunccall_T *get_funccal(void)\n{\n  funccall_T *funccal = current_funccal;\n  if (debug_backtrace_level > 0) {\n    for (int i = 0; i < debug_backtrace_level; i++) {\n      funccall_T *temp_funccal = funccal->caller;\n      if (temp_funccal) {\n        funccal = temp_funccal;\n      } else {\n        // backtrace level overflow. reset to max\n        debug_backtrace_level = i;\n      }\n    }\n  }\n\n  return funccal;\n}\n\n/// Return the hashtable used for local variables in the current funccal.\n/// Return NULL if there is no current funccal.\nhashtab_T *get_funccal_local_ht(void)\n{\n  if (current_funccal == NULL) {\n    return NULL;\n  }\n  return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/// Return the l: scope variable.\n/// Return NULL if there is no current funccal.\ndictitem_T *get_funccal_local_var(void)\n{\n  if (current_funccal == NULL) {\n    return NULL;\n  }\n  return (dictitem_T *)&get_funccal()->l_vars_var;\n}\n\n/// Return the hashtable used for argument in the current funccal.\n/// Return NULL if there is no current funccal.\nhashtab_T *get_funccal_args_ht(void)\n{\n  if (current_funccal == NULL) {\n    return NULL;\n  }\n  return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/// Return the a: scope variable.\n/// Return NULL if there is no current funccal.\ndictitem_T *get_funccal_args_var(void)\n{\n  if (current_funccal == NULL) {\n    return NULL;\n  }\n  return (dictitem_T *)&current_funccal->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\nvoid list_func_vars(int *first)\n{\n  if (current_funccal != NULL) {\n    list_hashtable_vars(&current_funccal->l_vars.dv_hashtab, \"l:\", false,\n                        first);\n  }\n}\n\n/// If \"ht\" is the hashtable for local variables in the current funccal, return\n/// the dict that contains it.\n/// Otherwise return NULL.\ndict_T *get_current_funccal_dict(hashtab_T *ht)\n{\n  if (current_funccal != NULL && ht == &current_funccal->l_vars.dv_hashtab) {\n    return &current_funccal->l_vars;\n  }\n  return NULL;\n}\n\n/// Search hashitem in parent scope.\nhashitem_T *find_hi_in_scoped_ht(const char *name, hashtab_T **pht)\n{\n  if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL) {\n    return NULL;\n  }\n\n  funccall_T *old_current_funccal = current_funccal;\n  hashitem_T *hi = NULL;\n  const size_t namelen = strlen(name);\n  const char *varname;\n\n  // Search in parent scope which is possible to reference from lambda\n  current_funccal = current_funccal->func->uf_scoped;\n  while (current_funccal != NULL) {\n    hashtab_T *ht = find_var_ht(name, namelen, &varname);\n    if (ht != NULL && *varname != NUL) {\n      hi = hash_find_len(ht, varname, namelen - (varname - name));\n      if (!HASHITEM_EMPTY(hi)) {\n        *pht = ht;\n        break;\n      }\n    }\n    if (current_funccal == current_funccal->func->uf_scoped) {\n      break;\n    }\n    current_funccal = current_funccal->func->uf_scoped;\n  }\n  current_funccal = old_current_funccal;\n\n  return hi;\n}\n\n/// Search variable in parent scope.\ndictitem_T *find_var_in_scoped_ht(const char *name, const size_t namelen, int no_autoload)\n{\n  if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL) {\n    return NULL;\n  }\n\n  dictitem_T *v = NULL;\n  funccall_T *old_current_funccal = current_funccal;\n  const char *varname;\n\n  // Search in parent scope which is possible to reference from lambda\n  current_funccal = current_funccal->func->uf_scoped;\n  while (current_funccal) {\n    hashtab_T *ht = find_var_ht(name, namelen, &varname);\n    if (ht != NULL && *varname != NUL) {\n      v = find_var_in_ht(ht, *name, varname,\n                         namelen - (size_t)(varname - name), no_autoload);\n      if (v != NULL) {\n        break;\n      }\n    }\n    if (current_funccal == current_funccal->func->uf_scoped) {\n      break;\n    }\n    current_funccal = current_funccal->func->uf_scoped;\n  }\n  current_funccal = old_current_funccal;\n\n  return v;\n}\n\n/// Set \"copyID + 1\" in previous_funccal and callers.\nbool set_ref_in_previous_funccal(int copyID)\n{\n  for (funccall_T *fc = previous_funccal; fc != NULL;\n       fc = fc->caller) {\n    fc->fc_copyID = copyID + 1;\n    if (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n        || set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n        || set_ref_in_list(&fc->l_varlist, copyID + 1, NULL)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic bool set_ref_in_funccal(funccall_T *fc, int copyID)\n{\n  if (fc->fc_copyID != copyID) {\n    fc->fc_copyID = copyID;\n    if (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n        || set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n        || set_ref_in_list(&fc->l_varlist, copyID, NULL)\n        || set_ref_in_func(NULL, fc->func, copyID)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Set \"copyID\" in all local vars and arguments in the call stack.\nbool set_ref_in_call_stack(int copyID)\n{\n  for (funccall_T *fc = current_funccal; fc != NULL;\n       fc = fc->caller) {\n    if (set_ref_in_funccal(fc, copyID)) {\n      return true;\n    }\n  }\n\n  // Also go through the funccal_stack.\n  for (funccal_entry_T *entry = funccal_stack; entry != NULL;\n       entry = entry->next) {\n    for (funccall_T *fc = entry->top_funccal; fc != NULL;\n         fc = fc->caller) {\n      if (set_ref_in_funccal(fc, copyID)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/// Set \"copyID\" in all functions available by name.\nbool set_ref_in_functions(int copyID)\n{\n  int todo;\n  hashitem_T *hi = NULL;\n  ufunc_T *fp;\n\n  todo = (int)func_hashtab.ht_used;\n  for (hi = func_hashtab.ht_array; todo > 0 && !got_int; hi++) {\n    if (!HASHITEM_EMPTY(hi)) {\n      todo--;\n      fp = HI2UF(hi);\n      if (!func_name_refcount(fp->uf_name)\n          && set_ref_in_func(NULL, fp, copyID)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/// Set \"copyID\" in all function arguments.\nbool set_ref_in_func_args(int copyID)\n{\n  for (int i = 0; i < funcargs.ga_len; i++) {\n    if (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n                        copyID, NULL, NULL)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n/// \"list_stack\" is used to add lists to be marked.  Can be NULL.\n/// \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n///\n/// @return true if setting references failed somehow.\nbool set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n  ufunc_T *fp = fp_in;\n  funccall_T *fc;\n  int error = ERROR_NONE;\n  char_u fname_buf[FLEN_FIXED + 1];\n  char_u *tofree = NULL;\n  char_u *fname;\n  bool abort = false;\n  if (name == NULL && fp_in == NULL) {\n    return false;\n  }\n\n  if (fp_in == NULL) {\n    fname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    fp = find_func(fname);\n  }\n  if (fp != NULL) {\n    for (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped) {\n      abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n  }\n  xfree(tofree);\n  return abort;\n}\n\n/// Registers a C extension user function.\nchar_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n  char_u *name = get_lambda_name();\n  ufunc_T *fp = xcalloc(1, offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\n  fp->uf_refcount = 1;\n  fp->uf_varargs = true;\n  fp->uf_flags = FC_CFUNC;\n  fp->uf_calls = 0;\n  fp->uf_script_ctx = current_sctx;\n  fp->uf_cb = cb;\n  fp->uf_cb_free = cb_free;\n  fp->uf_cb_state = state;\n\n  STRCPY(fp->uf_name, name);\n  hash_add(&func_hashtab, UF2HIKEY(fp));\n\n  return fp->uf_name;\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 227}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "2f5699aed0390d6f0e4452c4c07f44dd", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 269}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "72e77380a97825da724cfc270d153351", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 285}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 285}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "90330f7d87c66fac9882d32d4fa6ed03", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 293}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 293}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "fc97af408c95dcb1de23f90c6b178381", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 0, "line": 520}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "f1f1974c9d19c4702fefac2c335caeea", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 532}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 532}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "1191029fe67204b9b6dbb01203f00c3e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 538}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 538}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "c363f992f0d80dd55c6dec62f79b5d11", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 568}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 568}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "7408b0a09102903a1caa7b712f290992", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 569}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 569}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "9c92d7e85abfc373c281cdc1b6c4a4ff", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 571}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 571}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "58352a33f797215c7d1cc1e0b6417c2e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 591}, "message": "function 'free_funccal' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "1a853c3c98307b1940be0994e0ec4e7e", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 613}, "message": "function 'free_funccal_contents' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "b8349e5d6fbc3d2c01c15c78832fde14", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 762}, "message": "example recursive call chain, starting from function 'func_clear'"}, {"location": {"col": 3, "file": 0, "line": 771}, "message": "Frame #1: function 'func_clear' calls function 'funccal_unref' here:"}, {"location": {"col": 9, "file": 0, "line": 714}, "message": "Frame #2: function 'funccal_unref' calls function 'free_funccal_contents' here:"}, {"location": {"col": 3, "file": 0, "line": 626}, "message": "Frame #3: function 'free_funccal_contents' calls function 'free_funccal' here:"}, {"location": {"col": 3, "file": 0, "line": 606}, "message": "Frame #4: function 'free_funccal' calls function 'func_ptr_unref' here:"}, {"location": {"col": 7, "file": 0, "line": 2812}, "message": "Frame #5: function 'func_ptr_unref' calls function 'func_clear_free' here:"}, {"location": {"col": 3, "file": 0, "line": 793}, "message": "Frame #6: function 'func_clear_free' calls function 'func_clear' here:"}, {"location": {"col": 3, "file": 0, "line": 793}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 13, "file": 0, "line": 700}, "message": "function 'funccal_unref' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "4275bd0ed7dd959932baf085a7a67bb1", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 762}, "message": "function 'func_clear' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "36b8b1ec629b590b1fb1352cbb2ec658", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 791}, "message": "function 'func_clear_free' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "dcc11c3fdcbaa12509c55b3a5935230a", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 969}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 969}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "31371b903e3409215959412532314e86", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1027}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1027}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "c52e2dd5303a55968f5e5b9998662339", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 0, "line": 1227}, "message": "const (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1227}, "message": "pointer parameter 'name' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "961d3f9e543855e94e092d75dd32f487", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1715}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "c4edce3b9547f5b59e949555cc0b897a", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1823}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "157ead3acd5ca2f022cb4860d47fcd82", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 0, "line": 1890}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "f87c46a77d6ae77b13acb66e4cbd320c", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2030}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "59920a6dcd487fda5f5bfc59ce9f7267", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2500}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "b68d69dfcce7faf4fbad3e1a081d069a", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2546}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2546}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "fc97af408c95dcb1de23f90c6b178381", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 2687}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 2687}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "856814cd42eb5d4f0452d10437b9176f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2689}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2689}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "2a56e609ae158ee0ff927454580067e8", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 2806}, "message": "function 'func_ptr_unref' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "67ca95a01013dbc3329738ab43a0122f", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3143}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3143}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "28d784024d387cc2027d7ee65530df4e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 3146}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 3146}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "d602697a9c21177352964b8283135da9", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 3591}, "message": "example recursive call chain, starting from function 'set_ref_in_func'"}, {"location": {"col": 24, "file": 0, "line": 3610}, "message": "Frame #1: function 'set_ref_in_func' calls function 'set_ref_in_funccal' here:"}, {"location": {"col": 12, "file": 0, "line": 3522}, "message": "Frame #2: function 'set_ref_in_funccal' calls function 'set_ref_in_func' here:"}, {"location": {"col": 12, "file": 0, "line": 3522}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 13, "file": 0, "line": 3515}, "message": "function 'set_ref_in_funccal' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "9c927ffcf42c36b506354542751abb93", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 0, "line": 3591}, "message": "function 'set_ref_in_func' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "b4148d7054ed4f9bf3d42ebc9fd819d4", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3632}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3632}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval/userfunc.c", "reportHash": "8a014de3c44a606544ba4122196919ee", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
