<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"11": {"id": 11, "path": "src/nvim/fileio.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// fileio.c: read from and write to a file\n\n#include <assert.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <string.h>\n#include <inttypes.h>\n#include <fcntl.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/buffer_updates.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/iconv.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memfile.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/sha256.h\"\n#include \"nvim/state.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/ui_compositor.h\"\n#include \"nvim/types.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/shada.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/os_defs.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os/input.h\"\n\n#define BUFSIZE         8192    /* size of normal write buffer */\n#define SMBUFSIZE       256     /* size of emergency write buffer */\n\n// For compatibility with libuv < 1.20.0 (tested on 1.18.0)\n#ifndef UV_FS_COPYFILE_FICLONE\n#define UV_FS_COPYFILE_FICLONE 0\n#endif\n\n#define HAS_BW_FLAGS\n#define FIO_LATIN1     0x01    /* convert Latin1 */\n#define FIO_UTF8       0x02    /* convert UTF-8 */\n#define FIO_UCS2       0x04    /* convert UCS-2 */\n#define FIO_UCS4       0x08    /* convert UCS-4 */\n#define FIO_UTF16      0x10    /* convert UTF-16 */\n#define FIO_ENDIAN_L   0x80    /* little endian */\n#define FIO_NOCONVERT  0x2000  /* skip encoding conversion */\n#define FIO_UCSBOM     0x4000  /* check for BOM at start of file */\n#define FIO_ALL        -1      /* allow all formats */\n\n/* When converting, a read() or write() may leave some bytes to be converted\n * for the next call.  The value is guessed... */\n#define CONV_RESTLEN 30\n\n/* We have to guess how much a sequence of bytes may expand when converting\n * with iconv() to be able to allocate a buffer. */\n#define ICONV_MULT 8\n\n/*\n * Structure to pass arguments from buf_write() to buf_write_bytes().\n */\nstruct bw_info {\n  int bw_fd;                     // file descriptor\n  char_u      *bw_buf;           // buffer with data to be written\n  int bw_len;                    // length of data\n#ifdef HAS_BW_FLAGS\n  int bw_flags;                  // FIO_ flags\n#endif\n  char_u bw_rest[CONV_RESTLEN];  // not converted bytes\n  int bw_restlen;                // nr of bytes in bw_rest[]\n  int bw_first;                  // first write call\n  char_u      *bw_conv_buf;      // buffer for writing converted chars\n  int bw_conv_buflen;            // size of bw_conv_buf\n  int bw_conv_error;             // set for conversion error\n  linenr_T bw_conv_error_lnum;   // first line with error or zero\n  linenr_T bw_start_lnum;        // line number at start of buffer\n# ifdef HAVE_ICONV\n  iconv_t bw_iconv_fd;           // descriptor for iconv() or -1\n# endif\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"fileio.c.generated.h\"\n#endif\n\nstatic char *e_auchangedbuf = N_(\n    \"E812: Autocommands changed buffer or buffer name\");\n\nvoid filemess(buf_T *buf, char_u *name, char_u *s, int attr)\n{\n  int msg_scroll_save;\n\n  if (msg_silent != 0) {\n    return;\n  }\n  add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)name);\n  // Avoid an over-long translation to cause trouble.\n  xstrlcat((char *)IObuff, (const char *)s, IOSIZE);\n  // For the first message may have to start a new line.\n  // For further ones overwrite the previous one, reset msg_scroll before\n  // calling filemess().\n  msg_scroll_save = msg_scroll;\n  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n    msg_scroll = FALSE;\n  if (!msg_scroll)      /* wait a bit when overwriting an error msg */\n    check_for_delay(FALSE);\n  msg_start();\n  msg_scroll = msg_scroll_save;\n  msg_scrolled_ign = TRUE;\n  /* may truncate the message to avoid a hit-return prompt */\n  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);\n  msg_clr_eos();\n  ui_flush();\n  msg_scrolled_ign = FALSE;\n}\n\n\n/*\n * Read lines from file \"fname\" into the buffer after line \"from\".\n *\n * 1. We allocate blocks with try_malloc, as big as possible.\n * 2. Each block is filled with characters from the file with a single read().\n * 3. The lines are inserted in the buffer with ml_append().\n *\n * (caller must check that fname != NULL, unless READ_STDIN is used)\n *\n * \"lines_to_skip\" is the number of lines that must be skipped\n * \"lines_to_read\" is the number of lines that are appended\n * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.\n *\n * flags:\n * READ_NEW\tstarting to edit a new buffer\n * READ_FILTER\treading filter output\n * READ_STDIN\tread from stdin instead of a file\n * READ_BUFFER\tread from curbuf instead of a file (converting after reading\n *\t\tstdin)\n * READ_DUMMY\tread into a dummy buffer (to check if file contents changed)\n * READ_KEEP_UNDO  don't clear undo info or read it from a file\n * READ_FIFO\tread from fifo/socket instead of a file\n *\n * return FAIL for failure, NOTDONE for directory (failure), or OK\n */\nint\nreadfile(\n    char_u *fname,\n    char_u *sfname,\n    linenr_T from,\n    linenr_T lines_to_skip,\n    linenr_T lines_to_read,\n    exarg_T *eap,                       // can be NULL!\n    int flags\n)\n{\n  int fd = 0;\n  int newfile = (flags & READ_NEW);\n  int check_readonly;\n  int filtering = (flags & READ_FILTER);\n  int read_stdin = (flags & READ_STDIN);\n  int read_buffer = (flags & READ_BUFFER);\n  int read_fifo = (flags & READ_FIFO);\n  int set_options = newfile || read_buffer\n                    || (eap != NULL && eap->read_edit);\n  linenr_T read_buf_lnum = 1;           /* next line to read from curbuf */\n  colnr_T read_buf_col = 0;             /* next char to read from this line */\n  char_u c;\n  linenr_T lnum = from;\n  char_u      *ptr = NULL;              /* pointer into read buffer */\n  char_u      *buffer = NULL;           /* read buffer */\n  char_u      *new_buffer = NULL;       /* init to shut up gcc */\n  char_u      *line_start = NULL;       /* init to shut up gcc */\n  int wasempty;                         /* buffer was empty before reading */\n  colnr_T len;\n  long size = 0;\n  uint8_t *p = NULL;\n  off_T filesize = 0;\n  int skip_read = false;\n  context_sha256_T sha_ctx;\n  int read_undo_file = false;\n  int split = 0;  // number of split lines\n  linenr_T linecnt;\n  int error = FALSE;                    /* errors encountered */\n  int ff_error = EOL_UNKNOWN;           /* file format with errors */\n  long linerest = 0;                    /* remaining chars in line */\n  int perm = 0;\n#ifdef UNIX\n  int swap_mode = -1;                   /* protection bits for swap file */\n#endif\n  int fileformat = 0;                   // end-of-line format\n  bool keep_fileformat = false;\n  FileInfo file_info;\n  int file_readonly;\n  linenr_T skip_count = 0;\n  linenr_T read_count = 0;\n  int msg_save = msg_scroll;\n  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of\n                                        // last read was missing the eol\n  bool file_rewind = false;\n  int can_retry;\n  linenr_T conv_error = 0;              // line nr with conversion error\n  linenr_T illegal_byte = 0;            // line nr with illegal byte\n  bool keep_dest_enc = false;           // don't retry when char doesn't fit\n                                        // in destination encoding\n  int bad_char_behavior = BAD_REPLACE;\n  /* BAD_KEEP, BAD_DROP or character to\n   * replace with */\n  char_u      *tmpname = NULL;          /* name of 'charconvert' output file */\n  int fio_flags = 0;\n  char_u      *fenc;                    // fileencoding to use\n  bool fenc_alloced;                    // fenc_next is in allocated memory\n  char_u      *fenc_next = NULL;        // next item in 'fencs' or NULL\n  bool advance_fenc = false;\n  long real_size = 0;\n# ifdef HAVE_ICONV\n  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1\n  int did_iconv = false;                // TRUE when iconv() failed and trying\n                                        // 'charconvert' next\n# endif\n  int converted = FALSE;                /* TRUE if conversion done */\n  int notconverted = FALSE;             /* TRUE if conversion wanted but it\n                                           wasn't possible */\n  char_u conv_rest[CONV_RESTLEN];\n  int conv_restlen = 0;                 /* nr of bytes in conv_rest[] */\n  buf_T       *old_curbuf;\n  char_u      *old_b_ffname;\n  char_u      *old_b_fname;\n  int using_b_ffname;\n  int using_b_fname;\n  static char *msg_is_a_directory = N_(\"is a directory\");\n\n  au_did_filetype = false;  // reset before triggering any autocommands\n\n  curbuf->b_no_eol_lnum = 0;    /* in case it was set by the previous read */\n\n  /*\n   * If there is no file name yet, use the one for the read file.\n   * BF_NOTEDITED is set to reflect this.\n   * Don't do this for a read from a filter.\n   * Only do this when 'cpoptions' contains the 'f' flag.\n   */\n  if (curbuf->b_ffname == NULL\n      && !filtering\n      && fname != NULL\n      && vim_strchr(p_cpo, CPO_FNAMER) != NULL\n      && !(flags & READ_DUMMY)) {\n    if (set_rw_fname(fname, sfname) == FAIL)\n      return FAIL;\n  }\n\n  /* Remember the initial values of curbuf, curbuf->b_ffname and\n   * curbuf->b_fname to detect whether they are altered as a result of\n   * executing nasty autocommands.  Also check if \"fname\" and \"sfname\"\n   * point to one of these values. */\n  old_curbuf = curbuf;\n  old_b_ffname = curbuf->b_ffname;\n  old_b_fname = curbuf->b_fname;\n  using_b_ffname = (fname == curbuf->b_ffname)\n                   || (sfname == curbuf->b_ffname);\n  using_b_fname = (fname == curbuf->b_fname) || (sfname == curbuf->b_fname);\n\n  /* After reading a file the cursor line changes but we don't want to\n   * display the line. */\n  ex_no_reprint = true;\n\n  // don't display the file info for another buffer now\n  need_fileinfo = false;\n\n  // For Unix: Use the short file name whenever possible.\n  // Avoids problems with networks and when directory names are changed.\n  // Don't do this for Windows, a \"cd\" in a sub-shell may have moved us to\n  // another directory, which we don't detect.\n  if (sfname == NULL) {\n    sfname = fname;\n  }\n#if defined(UNIX)\n  fname = sfname;\n#endif\n\n  /*\n   * The BufReadCmd and FileReadCmd events intercept the reading process by\n   * executing the associated commands instead.\n   */\n  if (!filtering && !read_stdin && !read_buffer) {\n    pos_T pos;\n\n    pos = curbuf->b_op_start;\n\n    /* Set '[ mark to the line above where the lines go (line 1 if zero). */\n    curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n    curbuf->b_op_start.col = 0;\n\n    if (newfile) {\n      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,\n                               false, curbuf, eap)) {\n        int status = OK;\n\n        if (aborting()) {\n          status = FAIL;\n        }\n\n        // The BufReadCmd code usually uses \":read\" to get the text and\n        // perhaps \":file\" to change the buffer name. But we should\n        // consider this to work like \":edit\", thus reset the\n        // BF_NOTEDITED flag.  Then \":write\" will work to overwrite the\n        // same file.\n        if (status == OK) {\n          curbuf->b_flags &= ~BF_NOTEDITED;\n        }\n        return status;\n      }\n    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,\n                                    false, NULL, eap)) {\n      return aborting() ? FAIL : OK;\n    }\n\n    curbuf->b_op_start = pos;\n  }\n\n  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)\n    msg_scroll = FALSE;         /* overwrite previous file message */\n  else\n    msg_scroll = TRUE;          /* don't overwrite previous file message */\n\n  // If the name is too long we might crash further on, quit here.\n  if (fname != NULL && *fname != NUL) {\n    size_t namelen = STRLEN(fname);\n\n    // If the name is too long we might crash further on, quit here.\n    if (namelen >= MAXPATHL) {\n      filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);\n      msg_end();\n      msg_scroll = msg_save;\n      return FAIL;\n    }\n\n    // If the name ends in a path separator, we can't open it.  Check here,\n    // because reading the file may actually work, but then creating the\n    // swap file may destroy it!  Reported on MS-DOS and Win 95.\n    if (after_pathsep((const char *)fname, (const char *)(fname + namelen))) {\n      filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);\n      msg_end();\n      msg_scroll = msg_save;\n      return FAIL;\n    }\n  }\n\n  if (!read_buffer && !read_stdin && !read_fifo) {\n    perm = os_getperm((const char *)fname);\n    // On Unix it is possible to read a directory, so we have to\n    // check for it before os_open().\n    if (perm >= 0 && !S_ISREG(perm)                 // not a regular file ...\n        && !S_ISFIFO(perm)                          // ... or fifo\n        && !S_ISSOCK(perm)                          // ... or socket\n# ifdef OPEN_CHR_FILES\n        && !(S_ISCHR(perm) && is_dev_fd_file(fname))\n        // ... or a character special file named /dev/fd/<n>\n# endif\n        ) {\n      if (S_ISDIR(perm)) {\n        filemess(curbuf, fname, (char_u *)_(msg_is_a_directory), 0);\n      } else {\n        filemess(curbuf, fname, (char_u *)_(\"is not a file\"), 0);\n      }\n      msg_end();\n      msg_scroll = msg_save;\n      return S_ISDIR(perm) ? NOTDONE : FAIL;\n    }\n  }\n\n  /* Set default or forced 'fileformat' and 'binary'. */\n  set_file_options(set_options, eap);\n\n  /*\n   * When opening a new file we take the readonly flag from the file.\n   * Default is r/w, can be set to r/o below.\n   * Don't reset it when in readonly mode\n   * Only set/reset b_p_ro when BF_CHECK_RO is set.\n   */\n  check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));\n  if (check_readonly && !readonlymode)\n    curbuf->b_p_ro = FALSE;\n\n  if (newfile && !read_stdin && !read_buffer && !read_fifo) {\n    // Remember time of file.\n    if (os_fileinfo((char *)fname, &file_info)) {\n      buf_store_file_info(curbuf, &file_info);\n      curbuf->b_mtime_read = curbuf->b_mtime;\n#ifdef UNIX\n      /*\n       * Use the protection bits of the original file for the swap file.\n       * This makes it possible for others to read the name of the\n       * edited file from the swapfile, but only if they can read the\n       * edited file.\n       * Remove the \"write\" and \"execute\" bits for group and others\n       * (they must not write the swapfile).\n       * Add the \"read\" and \"write\" bits for the user, otherwise we may\n       * not be able to write to the file ourselves.\n       * Setting the bits is done below, after creating the swap file.\n       */\n      swap_mode = (file_info.stat.st_mode & 0644) | 0600;\n#endif\n    } else {\n      curbuf->b_mtime = 0;\n      curbuf->b_mtime_read = 0;\n      curbuf->b_orig_size = 0;\n      curbuf->b_orig_mode = 0;\n    }\n\n    /* Reset the \"new file\" flag.  It will be set again below when the\n     * file doesn't exist. */\n    curbuf->b_flags &= ~(BF_NEW | BF_NEW_W);\n  }\n\n  // Check readonly.\n  file_readonly = false;\n  if (!read_buffer && !read_stdin) {\n    if (!newfile || readonlymode || !(perm & 0222)\n        || !os_file_is_writable((char *)fname)) {\n      file_readonly = true;\n    }\n    fd = os_open((char *)fname, O_RDONLY, 0);\n  }\n\n  if (fd < 0) {                     // cannot open at all\n    msg_scroll = msg_save;\n    if (!newfile) {\n      return FAIL;\n    }\n    if (perm == UV_ENOENT) {  // check if the file exists\n      // Set the 'new-file' flag, so that when the file has\n      // been created by someone else, a \":w\" will complain.\n      curbuf->b_flags |= BF_NEW;\n\n      /* Create a swap file now, so that other Vims are warned\n       * that we are editing this file.  Don't do this for a\n       * \"nofile\" or \"nowrite\" buffer type. */\n      if (!bt_dontwrite(curbuf)) {\n        check_need_swap(newfile);\n        /* SwapExists autocommand may mess things up */\n        if (curbuf != old_curbuf\n            || (using_b_ffname\n                && (old_b_ffname != curbuf->b_ffname))\n            || (using_b_fname\n                && (old_b_fname != curbuf->b_fname))) {\n          EMSG(_(e_auchangedbuf));\n          return FAIL;\n        }\n      }\n      if (dir_of_file_exists(fname)) {\n        filemess(curbuf, sfname, (char_u *)new_file_message(), 0);\n      } else {\n        filemess(curbuf, sfname, (char_u *)_(\"[New DIRECTORY]\"), 0);\n      }\n      // Even though this is a new file, it might have been\n      // edited before and deleted.  Get the old marks.\n      check_marks_read();\n      // Set forced 'fileencoding'.\n      if (eap != NULL) {\n        set_forced_fenc(eap);\n      }\n      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,\n                           false, curbuf, eap);\n      // remember the current fileformat\n      save_file_ff(curbuf);\n\n      if (aborting())               /* autocmds may abort script processing */\n        return FAIL;\n      return OK;                  /* a new file is not an error */\n    } else {\n      filemess(curbuf, sfname, (char_u *)(\n            (fd == UV_EFBIG) ? _(\"[File too big]\") :\n# if defined(UNIX) && defined(EOVERFLOW)\n            // libuv only returns -errno in Unix and in Windows open() does not\n            // set EOVERFLOW\n            (fd == -EOVERFLOW) ? _(\"[File too big]\") :\n# endif\n            _(\"[Permission Denied]\")), 0);\n      curbuf->b_p_ro = TRUE;                  /* must use \"w!\" now */\n    }\n\n    return FAIL;\n  }\n\n  /*\n   * Only set the 'ro' flag for readonly files the first time they are\n   * loaded.\tHelp files always get readonly mode\n   */\n  if ((check_readonly && file_readonly) || curbuf->b_help)\n    curbuf->b_p_ro = TRUE;\n\n  if (set_options) {\n    /* Don't change 'eol' if reading from buffer as it will already be\n     * correctly set when reading stdin. */\n    if (!read_buffer) {\n      curbuf->b_p_eol = TRUE;\n      curbuf->b_start_eol = TRUE;\n    }\n    curbuf->b_p_bomb = FALSE;\n    curbuf->b_start_bomb = FALSE;\n  }\n\n  /* Create a swap file now, so that other Vims are warned that we are\n   * editing this file.\n   * Don't do this for a \"nofile\" or \"nowrite\" buffer type. */\n  if (!bt_dontwrite(curbuf)) {\n    check_need_swap(newfile);\n    if (!read_stdin\n        && (curbuf != old_curbuf\n            || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n            || (using_b_fname && (old_b_fname != curbuf->b_fname)))) {\n      EMSG(_(e_auchangedbuf));\n      if (!read_buffer) {\n        close(fd);\n      }\n      return FAIL;\n    }\n#ifdef UNIX\n    // Set swap file protection bits after creating it.\n    if (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL\n        && curbuf->b_ml.ml_mfp->mf_fname != NULL) {\n      const char *swap_fname = (const char *)curbuf->b_ml.ml_mfp->mf_fname;\n\n      // If the group-read bit is set but not the world-read bit, then\n      // the group must be equal to the group of the original file.  If\n      // we can't make that happen then reset the group-read bit.  This\n      // avoids making the swap file readable to more users when the\n      // primary group of the user is too permissive.\n      if ((swap_mode & 044) == 040) {\n        FileInfo swap_info;\n\n        if (os_fileinfo(swap_fname, &swap_info)\n            && file_info.stat.st_gid != swap_info.stat.st_gid\n            && os_fchown(curbuf->b_ml.ml_mfp->mf_fd, -1, file_info.stat.st_gid)\n            == -1) {\n          swap_mode &= 0600;\n        }\n      }\n\n      (void)os_setperm(swap_fname, swap_mode);\n    }\n#endif\n  }\n\n  // If \"Quit\" selected at ATTENTION dialog, don't load the file.\n  if (swap_exists_action == SEA_QUIT) {\n    if (!read_buffer && !read_stdin)\n      close(fd);\n    return FAIL;\n  }\n\n  ++no_wait_return;         /* don't wait for return yet */\n\n  /*\n   * Set '[ mark to the line above where the lines go (line 1 if zero).\n   */\n  curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n  curbuf->b_op_start.col = 0;\n\n  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);\n  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);\n  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n  if (!read_buffer) {\n    int m = msg_scroll;\n    int n = msg_scrolled;\n\n    // The file must be closed again, the autocommands may want to change\n    // the file before reading it.\n    if (!read_stdin) {\n      close(fd);                // ignore errors\n    }\n\n    // The output from the autocommands should not overwrite anything and\n    // should not be overwritten: Set msg_scroll, restore its value if no\n    // output was done.\n    msg_scroll = true;\n    if (filtering) {\n      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,\n                           false, curbuf, eap);\n    } else if (read_stdin) {\n      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,\n                           false, curbuf, eap);\n    } else if (newfile) {\n      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,\n                           false, curbuf, eap);\n    } else {\n      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,\n                           false, NULL, eap);\n    }\n\n    // autocommands may have changed it\n    try_mac = (vim_strchr(p_ffs, 'm') != NULL);\n    try_dos = (vim_strchr(p_ffs, 'd') != NULL);\n    try_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n    if (msg_scrolled == n) {\n      msg_scroll = m;\n    }\n\n    if (aborting()) {       /* autocmds may abort script processing */\n      --no_wait_return;\n      msg_scroll = msg_save;\n      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */\n      return FAIL;\n    }\n    /*\n     * Don't allow the autocommands to change the current buffer.\n     * Try to re-open the file.\n     *\n     * Don't allow the autocommands to change the buffer name either\n     * (cd for example) if it invalidates fname or sfname.\n     */\n    if (!read_stdin && (curbuf != old_curbuf\n                        || (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n                        || (using_b_fname && (old_b_fname != curbuf->b_fname))\n                        || (fd = os_open((char *)fname, O_RDONLY, 0)) < 0)) {\n      --no_wait_return;\n      msg_scroll = msg_save;\n      if (fd < 0)\n        EMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));\n      else\n        EMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));\n      curbuf->b_p_ro = TRUE;            /* must use \"w!\" now */\n      return FAIL;\n    }\n  }\n\n  /* Autocommands may add lines to the file, need to check if it is empty */\n  wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n  if (!recoverymode && !filtering && !(flags & READ_DUMMY)) {\n    if (!read_stdin && !read_buffer) {\n      filemess(curbuf, sfname, (char_u *)\"\", 0);\n    }\n  }\n\n  msg_scroll = FALSE;                   /* overwrite the file message */\n\n  /*\n   * Set linecnt now, before the \"retry\" caused by a wrong guess for\n   * fileformat, and after the autocommands, which may change them.\n   */\n  linecnt = curbuf->b_ml.ml_line_count;\n\n  /* \"++bad=\" argument. */\n  if (eap != NULL && eap->bad_char != 0) {\n    bad_char_behavior = eap->bad_char;\n    if (set_options)\n      curbuf->b_bad_char = eap->bad_char;\n  } else\n    curbuf->b_bad_char = 0;\n\n  /*\n   * Decide which 'encoding' to use or use first.\n   */\n  if (eap != NULL && eap->force_enc != 0) {\n    fenc = enc_canonize(eap->cmd + eap->force_enc);\n    fenc_alloced = true;\n    keep_dest_enc = true;\n  } else if (curbuf->b_p_bin) {\n    fenc = (char_u *)\"\";                // binary: don't convert\n    fenc_alloced = false;\n  } else if (curbuf->b_help) {\n    // Help files are either utf-8 or latin1.  Try utf-8 first, if this\n    // fails it must be latin1.\n    // It is needed when the first line contains non-ASCII characters.\n    // That is only in *.??x files.\n    fenc_next = (char_u *)\"latin1\";\n    fenc = (char_u *)\"utf-8\";\n\n    fenc_alloced = false;\n  } else if (*p_fencs == NUL) {\n    fenc = curbuf->b_p_fenc;            // use format from buffer\n    fenc_alloced = false;\n  } else {\n    fenc_next = p_fencs;                // try items in 'fileencodings'\n    fenc = next_fenc(&fenc_next, &fenc_alloced);\n  }\n\n  /*\n   * Jump back here to retry reading the file in different ways.\n   * Reasons to retry:\n   * - encoding conversion failed: try another one from \"fenc_next\"\n   * - BOM detected and fenc was set, need to setup conversion\n   * - \"fileformat\" check failed: try another\n   *\n   * Variables set for special retry actions:\n   * \"file_rewind\"\tRewind the file to start reading it again.\n   * \"advance_fenc\"\tAdvance \"fenc\" using \"fenc_next\".\n   * \"skip_read\"\tRe-use already read bytes (BOM detected).\n   * \"did_iconv\"\ticonv() conversion failed, try 'charconvert'.\n   * \"keep_fileformat\" Don't reset \"fileformat\".\n   *\n   * Other status indicators:\n   * \"tmpname\"\tWhen != NULL did conversion with 'charconvert'.\n   *\t\t\tOutput file has to be deleted afterwards.\n   * \"iconv_fd\"\tWhen != -1 did conversion with iconv().\n   */\nretry:\n\n  if (file_rewind) {\n    if (read_buffer) {\n      read_buf_lnum = 1;\n      read_buf_col = 0;\n    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {\n      // Can't rewind the file, give up.\n      error = true;\n      goto failed;\n    }\n    // Delete the previously read lines.\n    while (lnum > from) {\n      ml_delete(lnum--, false);\n    }\n    file_rewind = false;\n    if (set_options) {\n      curbuf->b_p_bomb = FALSE;\n      curbuf->b_start_bomb = FALSE;\n    }\n    conv_error = 0;\n  }\n\n  /*\n   * When retrying with another \"fenc\" and the first time \"fileformat\"\n   * will be reset.\n   */\n  if (keep_fileformat) {\n    keep_fileformat = false;\n  } else {\n    if (eap != NULL && eap->force_ff != 0) {\n      fileformat = get_fileformat_force(curbuf, eap);\n      try_unix = try_dos = try_mac = FALSE;\n    } else if (curbuf->b_p_bin)\n      fileformat = EOL_UNIX;                    /* binary: use Unix format */\n    else if (*p_ffs == NUL)\n      fileformat = get_fileformat(curbuf);      /* use format from buffer */\n    else\n      fileformat = EOL_UNKNOWN;                 /* detect from file */\n  }\n\n# ifdef HAVE_ICONV\n  if (iconv_fd != (iconv_t)-1) {\n    /* aborted conversion with iconv(), close the descriptor */\n    iconv_close(iconv_fd);\n    iconv_fd = (iconv_t)-1;\n  }\n# endif\n\n  if (advance_fenc) {\n    /*\n     * Try the next entry in 'fileencodings'.\n     */\n    advance_fenc = false;\n\n    if (eap != NULL && eap->force_enc != 0) {\n      /* Conversion given with \"++cc=\" wasn't possible, read\n       * without conversion. */\n      notconverted = TRUE;\n      conv_error = 0;\n      if (fenc_alloced)\n        xfree(fenc);\n      fenc = (char_u *)\"\";\n      fenc_alloced = false;\n    } else {\n      if (fenc_alloced)\n        xfree(fenc);\n      if (fenc_next != NULL) {\n        fenc = next_fenc(&fenc_next, &fenc_alloced);\n      } else {\n        fenc = (char_u *)\"\";\n        fenc_alloced = false;\n      }\n    }\n    if (tmpname != NULL) {\n      os_remove((char *)tmpname);  // delete converted file\n      XFREE_CLEAR(tmpname);\n    }\n  }\n\n  /*\n   * Conversion may be required when the encoding of the file is different\n   * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.\n   */\n  fio_flags = 0;\n  converted = need_conversion(fenc);\n  if (converted) {\n\n    /* \"ucs-bom\" means we need to check the first bytes of the file\n     * for a BOM. */\n    if (STRCMP(fenc, ENC_UCSBOM) == 0) {\n      fio_flags = FIO_UCSBOM;\n    } else {\n      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be\n      // done.  This is handled below after read().  Prepare the\n      // fio_flags to avoid having to parse the string each time.\n      // Also check for Unicode to Latin1 conversion, because iconv()\n      // appears not to handle this correctly.  This works just like\n      // conversion to UTF-8 except how the resulting character is put in\n      // the buffer.\n      fio_flags = get_fio_flags(fenc);\n    }\n\n\n\n# ifdef HAVE_ICONV\n    // Try using iconv() if we can't convert internally.\n    if (fio_flags == 0\n        && !did_iconv\n        ) {\n      iconv_fd = (iconv_t)my_iconv_open((char_u *)\"utf-8\", fenc);\n    }\n# endif\n\n    /*\n     * Use the 'charconvert' expression when conversion is required\n     * and we can't do it internally or with iconv().\n     */\n    if (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL\n        && !read_fifo\n#  ifdef HAVE_ICONV\n        && iconv_fd == (iconv_t)-1\n#  endif\n        ) {\n#  ifdef HAVE_ICONV\n      did_iconv = false;\n#  endif\n      /* Skip conversion when it's already done (retry for wrong\n       * \"fileformat\"). */\n      if (tmpname == NULL) {\n        tmpname = readfile_charconvert(fname, fenc, &fd);\n        if (tmpname == NULL) {\n          // Conversion failed.  Try another one.\n          advance_fenc = true;\n          if (fd < 0) {\n            /* Re-opening the original file failed! */\n            EMSG(_(\"E202: Conversion made file unreadable!\"));\n            error = TRUE;\n            goto failed;\n          }\n          goto retry;\n        }\n      }\n    } else {\n      if (fio_flags == 0\n# ifdef HAVE_ICONV\n          && iconv_fd == (iconv_t)-1\n# endif\n          ) {\n        /* Conversion wanted but we can't.\n         * Try the next conversion in 'fileencodings' */\n        advance_fenc = true;\n        goto retry;\n      }\n    }\n  }\n\n  /* Set \"can_retry\" when it's possible to rewind the file and try with\n   * another \"fenc\" value.  It's FALSE when no other \"fenc\" to try, reading\n   * stdin or fixed at a specific encoding. */\n  can_retry = (*fenc != NUL && !read_stdin && !keep_dest_enc && !read_fifo);\n\n  if (!skip_read) {\n    linerest = 0;\n    filesize = 0;\n    skip_count = lines_to_skip;\n    read_count = lines_to_read;\n    conv_restlen = 0;\n    read_undo_file = (newfile && (flags & READ_KEEP_UNDO) == 0\n                      && curbuf->b_ffname != NULL\n                      && curbuf->b_p_udf\n                      && !filtering\n                      && !read_fifo\n                      && !read_stdin\n                      && !read_buffer);\n    if (read_undo_file)\n      sha256_start(&sha_ctx);\n  }\n\n  while (!error && !got_int) {\n    /*\n     * We allocate as much space for the file as we can get, plus\n     * space for the old line plus room for one terminating NUL.\n     * The amount is limited by the fact that read() only can read\n     * up to max_unsigned characters (and other things).\n     */\n    {\n      if (!skip_read) {\n        // Use buffer >= 64K.  Add linerest to double the size if the\n        // line gets very long, to avoid a lot of copying. But don't\n        // read more than 1 Mbyte at a time, so we can be interrupted.\n        size = 0x10000L + linerest;\n        if (size > 0x100000L) {\n          size = 0x100000L;\n        }\n      }\n\n      // Protect against the argument of lalloc() going negative.\n      if (size < 0 || size + linerest + 1 < 0 || linerest >= MAXCOL) {\n        split++;\n        *ptr = NL;  // split line by inserting a NL\n        size = 1;\n      } else if (!skip_read) {\n        for (; size >= 10; size /= 2) {\n          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);\n          if (new_buffer) {\n            break;\n          }\n        }\n        if (new_buffer == NULL) {\n          error = TRUE;\n          break;\n        }\n        if (linerest)           /* copy characters from the previous buffer */\n          memmove(new_buffer, ptr - linerest, (size_t)linerest);\n        xfree(buffer);\n        buffer = new_buffer;\n        ptr = buffer + linerest;\n        line_start = buffer;\n\n        /* May need room to translate into.\n         * For iconv() we don't really know the required space, use a\n         * factor ICONV_MULT.\n         * latin1 to utf-8: 1 byte becomes up to 2 bytes\n         * utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes\n         * become up to 4 bytes, size must be multiple of 2\n         * ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be\n         * multiple of 2\n         * ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be\n         * multiple of 4 */\n        real_size = (int)size;\n# ifdef HAVE_ICONV\n        if (iconv_fd != (iconv_t)-1) {\n          size = size / ICONV_MULT;\n        } else {\n# endif\n        if (fio_flags & FIO_LATIN1) {\n          size = size / 2;\n        } else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {\n          size = (size * 2 / 3) & ~1;\n        } else if (fio_flags & FIO_UCS4) {\n          size = (size * 2 / 3) & ~3;\n        } else if (fio_flags == FIO_UCSBOM) {\n          size = size / ICONV_MULT;  // worst case\n        }\n# ifdef HAVE_ICONV\n        }\n# endif\n        if (conv_restlen > 0) {\n          // Insert unconverted bytes from previous line.\n          memmove(ptr, conv_rest, conv_restlen);  // -V614\n          ptr += conv_restlen;\n          size -= conv_restlen;\n        }\n\n        if (read_buffer) {\n          /*\n           * Read bytes from curbuf.  Used for converting text read\n           * from stdin.\n           */\n          if (read_buf_lnum > from)\n            size = 0;\n          else {\n            int n, ni;\n            long tlen;\n\n            tlen = 0;\n            for (;; ) {\n              p = ml_get(read_buf_lnum) + read_buf_col;\n              n = (int)STRLEN(p);\n              if ((int)tlen + n + 1 > size) {\n                /* Filled up to \"size\", append partial line.\n                 * Change NL to NUL to reverse the effect done\n                 * below. */\n                n = (int)(size - tlen);\n                for (ni = 0; ni < n; ++ni) {\n                  if (p[ni] == NL)\n                    ptr[tlen++] = NUL;\n                  else\n                    ptr[tlen++] = p[ni];\n                }\n                read_buf_col += n;\n                break;\n              } else {\n                /* Append whole line and new-line.  Change NL\n                * to NUL to reverse the effect done below. */\n                for (ni = 0; ni < n; ++ni) {\n                  if (p[ni] == NL)\n                    ptr[tlen++] = NUL;\n                  else\n                    ptr[tlen++] = p[ni];\n                }\n                ptr[tlen++] = NL;\n                read_buf_col = 0;\n                if (++read_buf_lnum > from) {\n                  /* When the last line didn't have an\n                   * end-of-line don't add it now either. */\n                  if (!curbuf->b_p_eol)\n                    --tlen;\n                  size = tlen;\n                  break;\n                }\n              }\n            }\n          }\n        } else {\n          /*\n           * Read bytes from the file.\n           */\n          size = read_eintr(fd, ptr, size);\n        }\n\n        if (size <= 0) {\n          if (size < 0)                             /* read error */\n            error = TRUE;\n          else if (conv_restlen > 0) {\n            /*\n             * Reached end-of-file but some trailing bytes could\n             * not be converted.  Truncated file?\n             */\n\n            /* When we did a conversion report an error. */\n            if (fio_flags != 0\n# ifdef HAVE_ICONV\n                || iconv_fd != (iconv_t)-1\n# endif\n                ) {\n              if (can_retry)\n                goto rewind_retry;\n              if (conv_error == 0)\n                conv_error = curbuf->b_ml.ml_line_count\n                             - linecnt + 1;\n            }\n            /* Remember the first linenr with an illegal byte */\n            else if (illegal_byte == 0)\n              illegal_byte = curbuf->b_ml.ml_line_count\n                             - linecnt + 1;\n            if (bad_char_behavior == BAD_DROP) {\n              *(ptr - conv_restlen) = NUL;\n              conv_restlen = 0;\n            } else {\n              /* Replace the trailing bytes with the replacement\n               * character if we were converting; if we weren't,\n               * leave the UTF8 checking code to do it, as it\n               * works slightly differently. */\n              if (bad_char_behavior != BAD_KEEP && (fio_flags != 0\n# ifdef HAVE_ICONV\n                                                    || iconv_fd != (iconv_t)-1\n# endif\n                                                    )) {\n                while (conv_restlen > 0) {\n                  *(--ptr) = bad_char_behavior;\n                  --conv_restlen;\n                }\n              }\n              fio_flags = 0;  // don't convert this\n# ifdef HAVE_ICONV\n              if (iconv_fd != (iconv_t)-1) {\n                iconv_close(iconv_fd);\n                iconv_fd = (iconv_t)-1;\n              }\n# endif\n            }\n          }\n        }\n      }\n\n      skip_read = FALSE;\n\n      /*\n       * At start of file: Check for BOM.\n       * Also check for a BOM for other Unicode encodings, but not after\n       * converting with 'charconvert' or when a BOM has already been\n       * found.\n       */\n      if ((filesize == 0)\n          && (fio_flags == FIO_UCSBOM\n              || (!curbuf->b_p_bomb\n                  && tmpname == NULL\n                  && (*fenc == 'u' || *fenc == NUL)))) {\n        char_u  *ccname;\n        int blen;\n\n        /* no BOM detection in a short file or in binary mode */\n        if (size < 2 || curbuf->b_p_bin)\n          ccname = NULL;\n        else\n          ccname = check_for_bom(ptr, size, &blen,\n              fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));\n        if (ccname != NULL) {\n          /* Remove BOM from the text */\n          filesize += blen;\n          size -= blen;\n          memmove(ptr, ptr + blen, (size_t)size);\n          if (set_options) {\n            curbuf->b_p_bomb = TRUE;\n            curbuf->b_start_bomb = TRUE;\n          }\n        }\n\n        if (fio_flags == FIO_UCSBOM) {\n          if (ccname == NULL) {\n            // No BOM detected: retry with next encoding.\n            advance_fenc = true;\n          } else {\n            /* BOM detected: set \"fenc\" and jump back */\n            if (fenc_alloced)\n              xfree(fenc);\n            fenc = ccname;\n            fenc_alloced = false;\n          }\n          /* retry reading without getting new bytes or rewinding */\n          skip_read = TRUE;\n          goto retry;\n        }\n      }\n\n      /* Include not converted bytes. */\n      ptr -= conv_restlen;\n      size += conv_restlen;\n      conv_restlen = 0;\n      /*\n       * Break here for a read error or end-of-file.\n       */\n      if (size <= 0)\n        break;\n\n# ifdef HAVE_ICONV\n      if (iconv_fd != (iconv_t)-1) {\n        /*\n         * Attempt conversion of the read bytes to 'encoding' using\n         * iconv().\n         */\n        const char      *fromp;\n        char            *top;\n        size_t from_size;\n        size_t to_size;\n\n        fromp = (char *)ptr;\n        from_size = size;\n        ptr += size;\n        top = (char *)ptr;\n        to_size = real_size - size;\n\n        /*\n         * If there is conversion error or not enough room try using\n         * another conversion.  Except for when there is no\n         * alternative (help files).\n         */\n        while ((iconv(iconv_fd, (void *)&fromp, &from_size,\n                    &top, &to_size)\n                == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n               || from_size > CONV_RESTLEN) {\n          if (can_retry)\n            goto rewind_retry;\n          if (conv_error == 0)\n            conv_error = readfile_linenr(linecnt,\n                ptr, (char_u *)top);\n\n          /* Deal with a bad byte and continue with the next. */\n          ++fromp;\n          --from_size;\n          if (bad_char_behavior == BAD_KEEP) {\n            *top++ = *(fromp - 1);\n            --to_size;\n          } else if (bad_char_behavior != BAD_DROP) {\n            *top++ = bad_char_behavior;\n            --to_size;\n          }\n        }\n\n        if (from_size > 0) {\n          /* Some remaining characters, keep them for the next\n           * round. */\n          memmove(conv_rest, (char_u *)fromp, from_size);\n          conv_restlen = (int)from_size;\n        }\n\n        /* move the linerest to before the converted characters */\n        line_start = ptr - linerest;\n        memmove(line_start, buffer, (size_t)linerest);\n        size = (long)((char_u *)top - ptr);\n      }\n# endif\n\n      if (fio_flags != 0) {\n        unsigned int u8c;\n        char_u  *dest;\n        char_u  *tail = NULL;\n\n        // Convert Unicode or Latin1 to UTF-8.\n        // Go from end to start through the buffer, because the number\n        // of bytes may increase.\n        // \"dest\" points to after where the UTF-8 bytes go, \"p\" points\n        // to after the next character to convert.\n        dest = ptr + real_size;\n        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {\n          p = ptr + size;\n          if (fio_flags == FIO_UTF8) {\n            /* Check for a trailing incomplete UTF-8 sequence */\n            tail = ptr + size - 1;\n            while (tail > ptr && (*tail & 0xc0) == 0x80)\n              --tail;\n            if (tail + utf_byte2len(*tail) <= ptr + size)\n              tail = NULL;\n            else\n              p = tail;\n          }\n        } else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {\n          /* Check for a trailing byte */\n          p = ptr + (size & ~1);\n          if (size & 1)\n            tail = p;\n          if ((fio_flags & FIO_UTF16) && p > ptr) {\n            /* Check for a trailing leading word */\n            if (fio_flags & FIO_ENDIAN_L) {\n              u8c = (*--p << 8);\n              u8c += *--p;\n            } else {\n              u8c = *--p;\n              u8c += (*--p << 8);\n            }\n            if (u8c >= 0xd800 && u8c <= 0xdbff)\n              tail = p;\n            else\n              p += 2;\n          }\n        } else {   /*  FIO_UCS4 */\n                     /* Check for trailing 1, 2 or 3 bytes */\n          p = ptr + (size & ~3);\n          if (size & 3)\n            tail = p;\n        }\n\n        /* If there is a trailing incomplete sequence move it to\n         * conv_rest[]. */\n        if (tail != NULL) {\n          conv_restlen = (int)((ptr + size) - tail);\n          memmove(conv_rest, tail, conv_restlen);\n          size -= conv_restlen;\n        }\n\n\n        while (p > ptr) {\n          if (fio_flags & FIO_LATIN1)\n            u8c = *--p;\n          else if (fio_flags & (FIO_UCS2 | FIO_UTF16)) {\n            if (fio_flags & FIO_ENDIAN_L) {\n              u8c = (*--p << 8);\n              u8c += *--p;\n            } else {\n              u8c = *--p;\n              u8c += (*--p << 8);\n            }\n            if ((fio_flags & FIO_UTF16)\n                && u8c >= 0xdc00 && u8c <= 0xdfff) {\n              int u16c;\n\n              if (p == ptr) {\n                /* Missing leading word. */\n                if (can_retry)\n                  goto rewind_retry;\n                if (conv_error == 0)\n                  conv_error = readfile_linenr(linecnt,\n                      ptr, p);\n                if (bad_char_behavior == BAD_DROP)\n                  continue;\n                if (bad_char_behavior != BAD_KEEP)\n                  u8c = bad_char_behavior;\n              }\n\n              /* found second word of double-word, get the first\n               * word and compute the resulting character */\n              if (fio_flags & FIO_ENDIAN_L) {\n                u16c = (*--p << 8);\n                u16c += *--p;\n              } else {\n                u16c = *--p;\n                u16c += (*--p << 8);\n              }\n              u8c = 0x10000 + ((u16c & 0x3ff) << 10)\n                    + (u8c & 0x3ff);\n\n              /* Check if the word is indeed a leading word. */\n              if (u16c < 0xd800 || u16c > 0xdbff) {\n                if (can_retry)\n                  goto rewind_retry;\n                if (conv_error == 0)\n                  conv_error = readfile_linenr(linecnt,\n                      ptr, p);\n                if (bad_char_behavior == BAD_DROP)\n                  continue;\n                if (bad_char_behavior != BAD_KEEP)\n                  u8c = bad_char_behavior;\n              }\n            }\n          } else if (fio_flags & FIO_UCS4) {\n            if (fio_flags & FIO_ENDIAN_L) {\n              u8c = (unsigned)(*--p) << 24;\n              u8c += (unsigned)(*--p) << 16;\n              u8c += (unsigned)(*--p) << 8;\n              u8c += *--p;\n            } else {          /* big endian */\n              u8c = *--p;\n              u8c += (unsigned)(*--p) << 8;\n              u8c += (unsigned)(*--p) << 16;\n              u8c += (unsigned)(*--p) << 24;\n            }\n          } else {        /* UTF-8 */\n            if (*--p < 0x80)\n              u8c = *p;\n            else {\n              len = utf_head_off(ptr, p);\n              p -= len;\n              u8c = utf_ptr2char(p);\n              if (len == 0) {\n                /* Not a valid UTF-8 character, retry with\n                 * another fenc when possible, otherwise just\n                 * report the error. */\n                if (can_retry)\n                  goto rewind_retry;\n                if (conv_error == 0)\n                  conv_error = readfile_linenr(linecnt,\n                      ptr, p);\n                if (bad_char_behavior == BAD_DROP)\n                  continue;\n                if (bad_char_behavior != BAD_KEEP)\n                  u8c = bad_char_behavior;\n              }\n            }\n          }\n          assert(u8c <= INT_MAX);\n          // produce UTF-8\n          dest -= utf_char2len((int)u8c);\n          (void)utf_char2bytes((int)u8c, dest);\n        }\n\n        // move the linerest to before the converted characters\n        line_start = dest - linerest;\n        memmove(line_start, buffer, (size_t)linerest);\n        size = (long)((ptr + real_size) - dest);\n        ptr = dest;\n      } else if (!curbuf->b_p_bin) {\n        bool incomplete_tail = false;\n\n        // Reading UTF-8: Check if the bytes are valid UTF-8.\n        for (p = ptr;; p++) {\n          int todo = (int)((ptr + size) - p);\n          int l;\n\n          if (todo <= 0) {\n            break;\n          }\n          if (*p >= 0x80) {\n            // A length of 1 means it's an illegal byte.  Accept\n            // an incomplete character at the end though, the next\n            // read() will get the next bytes, we'll check it\n            // then.\n            l = utf_ptr2len_len(p, todo);\n            if (l > todo && !incomplete_tail) {\n              // Avoid retrying with a different encoding when\n              // a truncated file is more likely, or attempting\n              // to read the rest of an incomplete sequence when\n              // we have already done so.\n              if (p > ptr || filesize > 0) {\n                incomplete_tail = true;\n              }\n              // Incomplete byte sequence, move it to conv_rest[]\n              // and try to read the rest of it, unless we've\n              // already done so.\n              if (p > ptr) {\n                conv_restlen = todo;\n                memmove(conv_rest, p, conv_restlen);\n                size -= conv_restlen;\n                break;\n              }\n            }\n            if (l == 1 || l > todo) {\n              /* Illegal byte.  If we can try another encoding\n               * do that, unless at EOF where a truncated\n               * file is more likely than a conversion error. */\n              if (can_retry && !incomplete_tail)\n                break;\n# ifdef HAVE_ICONV\n              // When we did a conversion report an error.\n              if (iconv_fd != (iconv_t)-1 && conv_error == 0) {\n                conv_error = readfile_linenr(linecnt, ptr, p);\n              }\n# endif\n              /* Remember the first linenr with an illegal byte */\n              if (conv_error == 0 && illegal_byte == 0)\n                illegal_byte = readfile_linenr(linecnt, ptr, p);\n\n              /* Drop, keep or replace the bad byte. */\n              if (bad_char_behavior == BAD_DROP) {\n                memmove(p, p + 1, todo - 1);\n                --p;\n                --size;\n              } else if (bad_char_behavior != BAD_KEEP)\n                *p = bad_char_behavior;\n            } else\n              p += l - 1;\n          }\n        }\n        if (p < ptr + size && !incomplete_tail) {\n          /* Detected a UTF-8 error. */\nrewind_retry:\n          // Retry reading with another conversion.\n# ifdef HAVE_ICONV\n          if (*p_ccv != NUL && iconv_fd != (iconv_t)-1) {\n            // iconv() failed, try 'charconvert'\n            did_iconv = true;\n          } else {\n# endif\n          // use next item from 'fileencodings'\n          advance_fenc = true;\n# ifdef HAVE_ICONV\n          }\n# endif\n          file_rewind = true;\n          goto retry;\n        }\n      }\n\n      /* count the number of characters (after conversion!) */\n      filesize += size;\n\n      /*\n       * when reading the first part of a file: guess EOL type\n       */\n      if (fileformat == EOL_UNKNOWN) {\n        /* First try finding a NL, for Dos and Unix */\n        if (try_dos || try_unix) {\n          // Reset the carriage return counter.\n          if (try_mac) {\n            try_mac = 1;\n          }\n\n          for (p = ptr; p < ptr + size; ++p) {\n            if (*p == NL) {\n              if (!try_unix\n                  || (try_dos && p > ptr && p[-1] == CAR))\n                fileformat = EOL_DOS;\n              else\n                fileformat = EOL_UNIX;\n              break;\n            } else if (*p == CAR && try_mac) {\n              try_mac++;\n            }\n          }\n\n          /* Don't give in to EOL_UNIX if EOL_MAC is more likely */\n          if (fileformat == EOL_UNIX && try_mac) {\n            /* Need to reset the counters when retrying fenc. */\n            try_mac = 1;\n            try_unix = 1;\n            for (; p >= ptr && *p != CAR; p--)\n              ;\n            if (p >= ptr) {\n              for (p = ptr; p < ptr + size; ++p) {\n                if (*p == NL)\n                  try_unix++;\n                else if (*p == CAR)\n                  try_mac++;\n              }\n              if (try_mac > try_unix)\n                fileformat = EOL_MAC;\n            }\n          } else if (fileformat == EOL_UNKNOWN && try_mac == 1) {\n            // Looking for CR but found no end-of-line markers at all:\n            // use the default format.\n            fileformat = default_fileformat();\n          }\n        }\n\n        /* No NL found: may use Mac format */\n        if (fileformat == EOL_UNKNOWN && try_mac)\n          fileformat = EOL_MAC;\n\n        /* Still nothing found?  Use first format in 'ffs' */\n        if (fileformat == EOL_UNKNOWN)\n          fileformat = default_fileformat();\n\n        // May set 'p_ff' if editing a new file.\n        if (set_options) {\n          set_fileformat(fileformat, OPT_LOCAL);\n        }\n      }\n    }\n\n    /*\n     * This loop is executed once for every character read.\n     * Keep it fast!\n     */\n    if (fileformat == EOL_MAC) {\n      --ptr;\n      while (++ptr, --size >= 0) {\n        /* catch most common case first */\n        if ((c = *ptr) != NUL && c != CAR && c != NL)\n          continue;\n        if (c == NUL)\n          *ptr = NL;            /* NULs are replaced by newlines! */\n        else if (c == NL)\n          *ptr = CAR;           /* NLs are replaced by CRs! */\n        else {\n          if (skip_count == 0) {\n            *ptr = NUL;                     /* end of line */\n            len = (colnr_T) (ptr - line_start + 1);\n            if (ml_append(lnum, line_start, len, newfile) == FAIL) {\n              error = TRUE;\n              break;\n            }\n            if (read_undo_file)\n              sha256_update(&sha_ctx, line_start, len);\n            ++lnum;\n            if (--read_count == 0) {\n              error = TRUE;                     /* break loop */\n              line_start = ptr;                 /* nothing left to write */\n              break;\n            }\n          } else\n            --skip_count;\n          line_start = ptr + 1;\n        }\n      }\n    } else {\n      --ptr;\n      while (++ptr, --size >= 0) {\n        if ((c = *ptr) != NUL && c != NL)          /* catch most common case */\n          continue;\n        if (c == NUL)\n          *ptr = NL;            /* NULs are replaced by newlines! */\n        else {\n          if (skip_count == 0) {\n            *ptr = NUL;                         /* end of line */\n            len = (colnr_T)(ptr - line_start + 1);\n            if (fileformat == EOL_DOS) {\n              if (ptr > line_start && ptr[-1] == CAR) {\n                // remove CR before NL\n                ptr[-1] = NUL;\n                len--;\n              } else if (ff_error != EOL_DOS) {\n                // Reading in Dos format, but no CR-LF found!\n                // When 'fileformats' includes \"unix\", delete all\n                // the lines read so far and start all over again.\n                // Otherwise give an error message later.\n                if (try_unix\n                    && !read_stdin\n                    && (read_buffer\n                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {\n                  fileformat = EOL_UNIX;\n                  if (set_options)\n                    set_fileformat(EOL_UNIX, OPT_LOCAL);\n                  file_rewind = true;\n                  keep_fileformat = true;\n                  goto retry;\n                }\n                ff_error = EOL_DOS;\n              }\n            }\n            if (ml_append(lnum, line_start, len, newfile) == FAIL) {\n              error = TRUE;\n              break;\n            }\n            if (read_undo_file)\n              sha256_update(&sha_ctx, line_start, len);\n            ++lnum;\n            if (--read_count == 0) {\n              error = TRUE;                         /* break loop */\n              line_start = ptr;                 /* nothing left to write */\n              break;\n            }\n          } else\n            --skip_count;\n          line_start = ptr + 1;\n        }\n      }\n    }\n    linerest = (long)(ptr - line_start);\n    os_breakcheck();\n  }\n\nfailed:\n  /* not an error, max. number of lines reached */\n  if (error && read_count == 0)\n    error = FALSE;\n\n  /*\n   * If we get EOF in the middle of a line, note the fact and\n   * complete the line ourselves.\n   * In Dos format ignore a trailing CTRL-Z, unless 'binary' set.\n   */\n  if (!error\n      && !got_int\n      && linerest != 0\n      && !(!curbuf->b_p_bin\n           && fileformat == EOL_DOS\n           && *line_start == Ctrl_Z\n           && ptr == line_start + 1)) {\n    /* remember for when writing */\n    if (set_options)\n      curbuf->b_p_eol = FALSE;\n    *ptr = NUL;\n    len = (colnr_T)(ptr - line_start + 1);\n    if (ml_append(lnum, line_start, len, newfile) == FAIL)\n      error = TRUE;\n    else {\n      if (read_undo_file)\n        sha256_update(&sha_ctx, line_start, len);\n      read_no_eol_lnum = ++lnum;\n    }\n  }\n\n  if (set_options) {\n    // Remember the current file format.\n    save_file_ff(curbuf);\n    // If editing a new file: set 'fenc' for the current buffer.\n    // Also for \":read ++edit file\".\n    set_string_option_direct(\"fenc\", -1, fenc, OPT_FREE | OPT_LOCAL, 0);\n  }\n  if (fenc_alloced)\n    xfree(fenc);\n# ifdef HAVE_ICONV\n  if (iconv_fd != (iconv_t)-1) {\n    iconv_close(iconv_fd);\n  }\n# endif\n\n  if (!read_buffer && !read_stdin) {\n    close(fd);  // errors are ignored\n  } else {\n    (void)os_set_cloexec(fd);\n  }\n  xfree(buffer);\n\n  if (read_stdin) {\n    close(0);\n#ifndef WIN32\n    // On Unix, use stderr for stdin, makes shell commands work.\n    vim_ignored = dup(2);\n#else\n    // On Windows, use the console input handle for stdin.\n    HANDLE conin = CreateFile(\"CONIN$\", GENERIC_READ | GENERIC_WRITE,\n                              FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,\n                              OPEN_EXISTING, 0, (HANDLE)NULL);\n    vim_ignored = _open_osfhandle(conin, _O_RDONLY);\n#endif\n  }\n\n  if (tmpname != NULL) {\n    os_remove((char *)tmpname);  // delete converted file\n    xfree(tmpname);\n  }\n  --no_wait_return;                     /* may wait for return now */\n\n  /*\n   * In recovery mode everything but autocommands is skipped.\n   */\n  if (!recoverymode) {\n    /* need to delete the last line, which comes from the empty buffer */\n    if (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY)) {\n      ml_delete(curbuf->b_ml.ml_line_count, false);\n      linecnt--;\n    }\n    curbuf->deleted_bytes = 0;\n    curbuf->deleted_bytes2 = 0;\n    curbuf->deleted_codepoints = 0;\n    curbuf->deleted_codeunits = 0;\n    linecnt = curbuf->b_ml.ml_line_count - linecnt;\n    if (filesize == 0)\n      linecnt = 0;\n    if (newfile || read_buffer) {\n      redraw_curbuf_later(NOT_VALID);\n      /* After reading the text into the buffer the diff info needs to\n       * be updated. */\n      diff_invalidate(curbuf);\n      /* All folds in the window are invalid now.  Mark them for update\n       * before triggering autocommands. */\n      foldUpdateAll(curwin);\n    } else if (linecnt)                 /* appended at least one line */\n      appended_lines_mark(from, linecnt);\n\n    /*\n     * If we were reading from the same terminal as where messages go,\n     * the screen will have been messed up.\n     * Switch on raw mode now and clear the screen.\n     */\n    if (read_stdin) {\n      screenclear();\n    }\n\n    if (got_int) {\n      if (!(flags & READ_DUMMY)) {\n        filemess(curbuf, sfname, (char_u *)_(e_interr), 0);\n        if (newfile)\n          curbuf->b_p_ro = TRUE;                /* must use \"w!\" now */\n      }\n      msg_scroll = msg_save;\n      check_marks_read();\n      return OK;                /* an interrupt isn't really an error */\n    }\n\n    if (!filtering && !(flags & READ_DUMMY)) {\n      add_quoted_fname((char *)IObuff, IOSIZE, curbuf, (const char *)sfname);\n      c = false;\n\n#ifdef UNIX\n      if (S_ISFIFO(perm)) {             // fifo\n        STRCAT(IObuff, _(\"[fifo]\"));\n        c = TRUE;\n      }\n      if (S_ISSOCK(perm)) {            // or socket\n        STRCAT(IObuff, _(\"[socket]\"));\n        c = TRUE;\n      }\n# ifdef OPEN_CHR_FILES\n      if (S_ISCHR(perm)) {                          /* or character special */\n        STRCAT(IObuff, _(\"[character special]\"));\n        c = TRUE;\n      }\n# endif\n#endif\n      if (curbuf->b_p_ro) {\n        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));\n        c = TRUE;\n      }\n      if (read_no_eol_lnum) {\n        msg_add_eol();\n        c = TRUE;\n      }\n      if (ff_error == EOL_DOS) {\n        STRCAT(IObuff, _(\"[CR missing]\"));\n        c = TRUE;\n      }\n      if (split) {\n        STRCAT(IObuff, _(\"[long lines split]\"));\n        c = true;\n      }\n      if (notconverted) {\n        STRCAT(IObuff, _(\"[NOT converted]\"));\n        c = TRUE;\n      } else if (converted) {\n        STRCAT(IObuff, _(\"[converted]\"));\n        c = TRUE;\n      }\n      if (conv_error != 0) {\n        sprintf((char *)IObuff + STRLEN(IObuff),\n            _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);\n        c = TRUE;\n      } else if (illegal_byte > 0) {\n        sprintf((char *)IObuff + STRLEN(IObuff),\n            _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);\n        c = TRUE;\n      } else if (error)  {\n        STRCAT(IObuff, _(\"[READ ERRORS]\"));\n        c = TRUE;\n      }\n      if (msg_add_fileformat(fileformat))\n        c = TRUE;\n\n      msg_add_lines(c, (long)linecnt, filesize);\n\n      XFREE_CLEAR(keep_msg);\n      p = NULL;\n      msg_scrolled_ign = TRUE;\n\n      if (!read_stdin && !read_buffer) {\n        p = msg_trunc_attr(IObuff, FALSE, 0);\n      }\n\n      if (read_stdin || read_buffer || restart_edit != 0\n          || (msg_scrolled != 0 && !need_wait_return)) {\n        // Need to repeat the message after redrawing when:\n        // - When reading from stdin (the screen will be cleared next).\n        // - When restart_edit is set (otherwise there will be a delay before\n        //   redrawing).\n        // - When the screen was scrolled but there is no wait-return prompt.\n        set_keep_msg(p, 0);\n      }\n      msg_scrolled_ign = FALSE;\n    }\n\n    /* with errors writing the file requires \":w!\" */\n    if (newfile && (error\n                    || conv_error != 0\n                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)\n                    ))\n      curbuf->b_p_ro = TRUE;\n\n    u_clearline();          /* cannot use \"U\" command after adding lines */\n\n    /*\n     * In Ex mode: cursor at last new line.\n     * Otherwise: cursor at first new line.\n     */\n    if (exmode_active)\n      curwin->w_cursor.lnum = from + linecnt;\n    else\n      curwin->w_cursor.lnum = from + 1;\n    check_cursor_lnum();\n    beginline(BL_WHITE | BL_FIX);           /* on first non-blank */\n\n    /*\n     * Set '[ and '] marks to the newly read lines.\n     */\n    curbuf->b_op_start.lnum = from + 1;\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.lnum = from + linecnt;\n    curbuf->b_op_end.col = 0;\n\n  }\n  msg_scroll = msg_save;\n\n  /*\n   * Get the marks before executing autocommands, so they can be used there.\n   */\n  check_marks_read();\n\n  /*\n   * We remember if the last line of the read didn't have\n   * an eol even when 'binary' is off, to support turning 'fixeol' off,\n   * or writing the read again with 'binary' on.  The latter is required\n   * for \":autocmd FileReadPost *.gz set bin|'[,']!gunzip\" to work.\n   */\n  curbuf->b_no_eol_lnum = read_no_eol_lnum;\n\n  /* When reloading a buffer put the cursor at the first line that is\n   * different. */\n  if (flags & READ_KEEP_UNDO)\n    u_find_first_changed();\n\n  /*\n   * When opening a new file locate undo info and read it.\n   */\n  if (read_undo_file) {\n    char_u hash[UNDO_HASH_SIZE];\n\n    sha256_finish(&sha_ctx, hash);\n    u_read_undo(NULL, hash, fname);\n  }\n\n  if (!read_stdin && !read_fifo && (!read_buffer || sfname != NULL)) {\n    int m = msg_scroll;\n    int n = msg_scrolled;\n\n    /* Save the fileformat now, otherwise the buffer will be considered\n     * modified if the format/encoding was automatically detected. */\n    if (set_options)\n      save_file_ff(curbuf);\n\n    /*\n     * The output from the autocommands should not overwrite anything and\n     * should not be overwritten: Set msg_scroll, restore its value if no\n     * output was done.\n     */\n    msg_scroll = true;\n    if (filtering) {\n      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,\n                           false, curbuf, eap);\n    } else if (newfile || (read_buffer && sfname != NULL)) {\n      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,\n                           false, curbuf, eap);\n      if (!au_did_filetype && *curbuf->b_p_ft != NUL) {\n        // EVENT_FILETYPE was not triggered but the buffer already has a\n        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.\n        apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n                       true, curbuf);\n      }\n    } else {\n      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,\n                           false, NULL, eap);\n    }\n    if (msg_scrolled == n) {\n      msg_scroll = m;\n    }\n    if (aborting()) {       // autocmds may abort script processing\n      return FAIL;\n    }\n  }\n\n  if (recoverymode && error)\n    return FAIL;\n  return OK;\n}\n\n#ifdef OPEN_CHR_FILES\n/// Returns true if the file name argument is of the form \"/dev/fd/\\d\\+\",\n/// which is the name of files used for process substitution output by\n/// some shells on some operating systems, e.g., bash on SunOS.\n/// Do not accept \"/dev/fd/[012]\", opening these may hang Vim.\n///\n/// @param fname file name to check\nbool is_dev_fd_file(char_u *fname)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return STRNCMP(fname, \"/dev/fd/\", 8) == 0\n         && ascii_isdigit(fname[8])\n         && *skipdigits(fname + 9) == NUL\n         && (fname[9] != NUL\n             || (fname[8] != '0' && fname[8] != '1' && fname[8] != '2'));\n}\n#endif\n\n\n/*\n * From the current line count and characters read after that, estimate the\n * line number where we are now.\n * Used for error messages that include a line number.\n */\nstatic linenr_T\nreadfile_linenr(\n    linenr_T linecnt,         // line count before reading more bytes\n    char_u *p,                // start of more bytes read\n    char_u *endp              // end of more bytes read\n)\n{\n  char_u      *s;\n  linenr_T lnum;\n\n  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;\n  for (s = p; s < endp; ++s)\n    if (*s == '\\n')\n      ++lnum;\n  return lnum;\n}\n\n/*\n * Fill \"*eap\" to force the 'fileencoding', 'fileformat' and 'binary to be\n * equal to the buffer \"buf\".  Used for calling readfile().\n */\nvoid prep_exarg(exarg_T *eap, const buf_T *buf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const size_t cmd_len = 15 + STRLEN(buf->b_p_fenc);\n  eap->cmd = xmalloc(cmd_len);\n\n  snprintf((char *)eap->cmd, cmd_len, \"e ++enc=%s\", buf->b_p_fenc);\n  eap->force_enc = 8;\n  eap->bad_char = buf->b_bad_char;\n  eap->force_ff = *buf->b_p_ff;\n\n  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;\n  eap->read_edit = FALSE;\n  eap->forceit = FALSE;\n}\n\n/*\n * Set default or forced 'fileformat' and 'binary'.\n */\nvoid set_file_options(int set_options, exarg_T *eap)\n{\n  /* set default 'fileformat' */\n  if (set_options) {\n    if (eap != NULL && eap->force_ff != 0)\n      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);\n    else if (*p_ffs != NUL)\n      set_fileformat(default_fileformat(), OPT_LOCAL);\n  }\n\n  /* set or reset 'binary' */\n  if (eap != NULL && eap->force_bin != 0) {\n    int oldval = curbuf->b_p_bin;\n\n    curbuf->b_p_bin = (eap->force_bin == FORCE_BIN);\n    set_options_bin(oldval, curbuf->b_p_bin, OPT_LOCAL);\n  }\n}\n\n/*\n * Set forced 'fileencoding'.\n */\nvoid set_forced_fenc(exarg_T *eap)\n{\n  if (eap->force_enc != 0) {\n    char_u *fenc = enc_canonize(eap->cmd + eap->force_enc);\n    set_string_option_direct(\"fenc\", -1, fenc, OPT_FREE|OPT_LOCAL, 0);\n    xfree(fenc);\n  }\n}\n\n// Find next fileencoding to use from 'fileencodings'.\n// \"pp\" points to fenc_next.  It's advanced to the next item.\n// When there are no more items, an empty string is returned and *pp is set to\n// NULL.\n// When *pp is not set to NULL, the result is in allocated memory and \"alloced\"\n// is set to true.\nstatic char_u *next_fenc(char_u **pp, bool *alloced)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  char_u      *p;\n  char_u      *r;\n\n  *alloced = false;\n  if (**pp == NUL) {\n    *pp = NULL;\n    return (char_u *)\"\";\n  }\n  p = vim_strchr(*pp, ',');\n  if (p == NULL) {\n    r = enc_canonize(*pp);\n    *pp += STRLEN(*pp);\n  } else {\n    r = vim_strnsave(*pp, p - *pp);\n    *pp = p + 1;\n    p = enc_canonize(r);\n    xfree(r);\n    r = p;\n  }\n  *alloced = true;\n  return r;\n}\n\n/*\n * Convert a file with the 'charconvert' expression.\n * This closes the file which is to be read, converts it and opens the\n * resulting file for reading.\n * Returns name of the resulting converted file (the caller should delete it\n * after reading it).\n * Returns NULL if the conversion failed (\"*fdp\" is not set) .\n */\nstatic char_u *\nreadfile_charconvert (\n    char_u *fname,             /* name of input file */\n    char_u *fenc,              /* converted from */\n    int *fdp               /* in/out: file descriptor of file */\n)\n{\n  char_u      *tmpname;\n  char_u      *errmsg = NULL;\n\n  tmpname = vim_tempname();\n  if (tmpname == NULL)\n    errmsg = (char_u *)_(\"Can't find temp file for conversion\");\n  else {\n    close(*fdp);                /* close the input file, ignore errors */\n    *fdp = -1;\n    if (eval_charconvert((char *)fenc, \"utf-8\",\n                         (char *)fname, (char *)tmpname) == FAIL) {\n      errmsg = (char_u *)_(\"Conversion with 'charconvert' failed\");\n    }\n    if (errmsg == NULL && (*fdp = os_open((char *)tmpname, O_RDONLY, 0)) < 0) {\n      errmsg = (char_u *)_(\"can't read output of 'charconvert'\");\n    }\n  }\n\n  if (errmsg != NULL) {\n    /* Don't use emsg(), it breaks mappings, the retry with\n     * another type of conversion might still work. */\n    MSG(errmsg);\n    if (tmpname != NULL) {\n      os_remove((char *)tmpname);  // delete converted file\n      XFREE_CLEAR(tmpname);\n    }\n  }\n\n  /* If the input file is closed, open it (caller should check for error). */\n  if (*fdp < 0) {\n    *fdp = os_open((char *)fname, O_RDONLY, 0);\n  }\n\n  return tmpname;\n}\n\n\n/*\n * Read marks for the current buffer from the ShaDa file, when we support\n * buffer marks and the buffer has a name.\n */\nstatic void check_marks_read(void)\n{\n  if (!curbuf->b_marks_read && get_shada_parameter('\\'') > 0\n      && curbuf->b_ffname != NULL) {\n    shada_read_marks();\n  }\n\n  /* Always set b_marks_read; needed when 'shada' is changed to include\n   * the ' parameter after opening a buffer. */\n  curbuf->b_marks_read = true;\n}\n\nchar *new_file_message(void)\n{\n  return shortmess(SHM_NEW) ? _(\"[New]\") : _(\"[New File]\");\n}\n\n/*\n * buf_write() - write to file \"fname\" lines \"start\" through \"end\"\n *\n * We do our own buffering here because fwrite() is so slow.\n *\n * If \"forceit\" is true, we don't care for errors when attempting backups.\n * In case of an error everything possible is done to restore the original\n * file.  But when \"forceit\" is TRUE, we risk losing it.\n *\n * When \"reset_changed\" is TRUE and \"append\" == FALSE and \"start\" == 1 and\n * \"end\" == curbuf->b_ml.ml_line_count, reset curbuf->b_changed.\n *\n * This function must NOT use NameBuff (because it's called by autowrite()).\n *\n * return FAIL for failure, OK otherwise\n */\nint\nbuf_write(\n    buf_T *buf,\n    char_u *fname,\n    char_u *sfname,\n    linenr_T start,\n    linenr_T end,\n    exarg_T *eap,                   /* for forced 'ff' and 'fenc', can be\n                                           NULL! */\n    int append,                             /* append to the file */\n    int forceit,\n    int reset_changed,\n    int filtering\n)\n{\n  int fd;\n  char_u          *backup = NULL;\n  int backup_copy = FALSE;               /* copy the original file? */\n  int dobackup;\n  char_u          *ffname;\n  char_u          *wfname = NULL;       /* name of file to write to */\n  char_u          *s;\n  char_u          *ptr;\n  char_u c;\n  int len;\n  linenr_T lnum;\n  long nchars;\n#define SET_ERRMSG_NUM(num, msg) \\\n  errnum = num, errmsg = msg, errmsgarg = 0\n#define SET_ERRMSG_ARG(msg, error) \\\n  errnum = NULL, errmsg = msg, errmsgarg = error\n#define SET_ERRMSG(msg) \\\n  errnum = NULL, errmsg = msg, errmsgarg = 0\n  const char *errnum = NULL;\n  char *errmsg = NULL;\n  int errmsgarg = 0;\n  bool errmsg_allocated = false;\n  char_u          *buffer;\n  char_u smallbuf[SMBUFSIZE];\n  char_u          *backup_ext;\n  int bufsize;\n  long perm;                                // file permissions\n  int retval = OK;\n  int newfile = false;                      // TRUE if file doesn't exist yet\n  int msg_save = msg_scroll;\n  int overwriting;                          // TRUE if writing over original\n  int no_eol = false;                       // no end-of-line written\n  int device = false;                       // writing to a device\n  int prev_got_int = got_int;\n  int checking_conversion;\n  bool file_readonly = false;               // overwritten file is read-only\n  static char     *err_readonly =\n    \"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\";\n#if defined(UNIX)\n  int made_writable = FALSE;                /* 'w' bit has been set */\n#endif\n  /* writing everything */\n  int whole = (start == 1 && end == buf->b_ml.ml_line_count);\n  linenr_T old_line_count = buf->b_ml.ml_line_count;\n  int fileformat;\n  int write_bin;\n  struct bw_info write_info;            /* info for buf_write_bytes() */\n  int converted = FALSE;\n  int notconverted = FALSE;\n  char_u          *fenc;                /* effective 'fileencoding' */\n  char_u          *fenc_tofree = NULL;   /* allocated \"fenc\" */\n#ifdef HAS_BW_FLAGS\n  int wb_flags = 0;\n#endif\n#ifdef HAVE_ACL\n  vim_acl_T acl = NULL;                 /* ACL copied from original file to\n                                           backup or new file */\n#endif\n  int write_undo_file = FALSE;\n  context_sha256_T sha_ctx;\n  unsigned int bkc = get_bkc_value(buf);\n\n  if (fname == NULL || *fname == NUL)   /* safety check */\n    return FAIL;\n  if (buf->b_ml.ml_mfp == NULL) {\n    /* This can happen during startup when there is a stray \"w\" in the\n     * vimrc file. */\n    EMSG(_(e_emptybuf));\n    return FAIL;\n  }\n\n  /*\n   * Disallow writing from .exrc and .vimrc in current directory for\n   * security reasons.\n   */\n  if (check_secure())\n    return FAIL;\n\n  /* Avoid a crash for a long name. */\n  if (STRLEN(fname) >= MAXPATHL) {\n    EMSG(_(e_longname));\n    return FAIL;\n  }\n\n  /* must init bw_conv_buf and bw_iconv_fd before jumping to \"fail\" */\n  write_info.bw_conv_buf = NULL;\n  write_info.bw_conv_error = FALSE;\n  write_info.bw_conv_error_lnum = 0;\n  write_info.bw_restlen = 0;\n# ifdef HAVE_ICONV\n  write_info.bw_iconv_fd = (iconv_t)-1;\n# endif\n\n  /* After writing a file changedtick changes but we don't want to display\n   * the line. */\n  ex_no_reprint = true;\n\n  /*\n   * If there is no file name yet, use the one for the written file.\n   * BF_NOTEDITED is set to reflect this (in case the write fails).\n   * Don't do this when the write is for a filter command.\n   * Don't do this when appending.\n   * Only do this when 'cpoptions' contains the 'F' flag.\n   */\n  if (buf->b_ffname == NULL\n      && reset_changed\n      && whole\n      && buf == curbuf\n      && !bt_nofile(buf)\n      && !filtering\n      && (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)\n      && vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {\n    if (set_rw_fname(fname, sfname) == FAIL)\n      return FAIL;\n    buf = curbuf;           /* just in case autocmds made \"buf\" invalid */\n  }\n\n  if (sfname == NULL)\n    sfname = fname;\n\n  // For Unix: Use the short file name whenever possible.\n  // Avoids problems with networks and when directory names are changed.\n  // Don't do this for Windows, a \"cd\" in a sub-shell may have moved us to\n  // another directory, which we don't detect.\n  ffname = fname;                           // remember full fname\n#ifdef UNIX\n  fname = sfname;\n#endif\n\n  if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)\n    overwriting = TRUE;\n  else\n    overwriting = FALSE;\n\n  ++no_wait_return;                 /* don't wait for return yet */\n\n  /*\n   * Set '[ and '] marks to the lines to be written.\n   */\n  buf->b_op_start.lnum = start;\n  buf->b_op_start.col = 0;\n  buf->b_op_end.lnum = end;\n  buf->b_op_end.col = 0;\n\n  {\n    aco_save_T aco;\n    int buf_ffname = FALSE;\n    int buf_sfname = FALSE;\n    int buf_fname_f = FALSE;\n    int buf_fname_s = FALSE;\n    int did_cmd = FALSE;\n    int nofile_err = FALSE;\n    int empty_memline = (buf->b_ml.ml_mfp == NULL);\n    bufref_T bufref;\n\n    /*\n     * Apply PRE autocommands.\n     * Set curbuf to the buffer to be written.\n     * Careful: The autocommands may call buf_write() recursively!\n     */\n    if (ffname == buf->b_ffname)\n      buf_ffname = TRUE;\n    if (sfname == buf->b_sfname)\n      buf_sfname = TRUE;\n    if (fname == buf->b_ffname)\n      buf_fname_f = TRUE;\n    if (fname == buf->b_sfname)\n      buf_fname_s = TRUE;\n\n    // Set curwin/curbuf to buf and save a few things.\n    aucmd_prepbuf(&aco, buf);\n    set_bufref(&bufref, buf);\n\n    if (append) {\n      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,\n                sfname, sfname, FALSE, curbuf, eap))) {\n        if (overwriting && bt_nofile(curbuf))\n          nofile_err = TRUE;\n        else\n          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,\n              sfname, sfname, FALSE, curbuf, eap);\n      }\n    } else if (filtering) {\n      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,\n          NULL, sfname, FALSE, curbuf, eap);\n    } else if (reset_changed && whole)   {\n      int was_changed = curbufIsChanged();\n\n      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,\n          sfname, sfname, FALSE, curbuf, eap);\n      if (did_cmd) {\n        if (was_changed && !curbufIsChanged()) {\n          /* Written everything correctly and BufWriteCmd has reset\n           * 'modified': Correct the undo information so that an\n           * undo now sets 'modified'. */\n          u_unchanged(curbuf);\n          u_update_save_nr(curbuf);\n        }\n      } else {\n        if (overwriting && bt_nofile(curbuf))\n          nofile_err = TRUE;\n        else\n          apply_autocmds_exarg(EVENT_BUFWRITEPRE,\n              sfname, sfname, FALSE, curbuf, eap);\n      }\n    } else {\n      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,\n                sfname, sfname, FALSE, curbuf, eap))) {\n        if (overwriting && bt_nofile(curbuf))\n          nofile_err = TRUE;\n        else\n          apply_autocmds_exarg(EVENT_FILEWRITEPRE,\n              sfname, sfname, FALSE, curbuf, eap);\n      }\n    }\n\n    /* restore curwin/curbuf and a few other things */\n    aucmd_restbuf(&aco);\n\n    // In three situations we return here and don't write the file:\n    // 1. the autocommands deleted or unloaded the buffer.\n    // 2. The autocommands abort script processing.\n    // 3. If one of the \"Cmd\" autocommands was executed.\n    if (!bufref_valid(&bufref)) {\n      buf = NULL;\n    }\n    if (buf == NULL || (buf->b_ml.ml_mfp == NULL && !empty_memline)\n        || did_cmd || nofile_err\n        || aborting()\n        ) {\n      --no_wait_return;\n      msg_scroll = msg_save;\n      if (nofile_err)\n        EMSG(_(\"E676: No matching autocommands for acwrite buffer\"));\n\n      if (nofile_err\n          || aborting()\n          )\n        /* An aborting error, interrupt or exception in the\n         * autocommands. */\n        return FAIL;\n      if (did_cmd) {\n        if (buf == NULL)\n          /* The buffer was deleted.  We assume it was written\n           * (can't retry anyway). */\n          return OK;\n        if (overwriting) {\n          /* Assume the buffer was written, update the timestamp. */\n          ml_timestamp(buf);\n          if (append)\n            buf->b_flags &= ~BF_NEW;\n          else\n            buf->b_flags &= ~BF_WRITE_MASK;\n        }\n        if (reset_changed && buf->b_changed && !append\n            && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))\n          /* Buffer still changed, the autocommands didn't work\n           * properly. */\n          return FAIL;\n        return OK;\n      }\n      if (!aborting())\n        EMSG(_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\n      return FAIL;\n    }\n\n    /*\n     * The autocommands may have changed the number of lines in the file.\n     * When writing the whole file, adjust the end.\n     * When writing part of the file, assume that the autocommands only\n     * changed the number of lines that are to be written (tricky!).\n     */\n    if (buf->b_ml.ml_line_count != old_line_count) {\n      if (whole)                                                /* write all */\n        end = buf->b_ml.ml_line_count;\n      else if (buf->b_ml.ml_line_count > old_line_count)        /* more lines */\n        end += buf->b_ml.ml_line_count - old_line_count;\n      else {                                                    /* less lines */\n        end -= old_line_count - buf->b_ml.ml_line_count;\n        if (end < start) {\n          --no_wait_return;\n          msg_scroll = msg_save;\n          EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));\n          return FAIL;\n        }\n      }\n    }\n\n    /*\n     * The autocommands may have changed the name of the buffer, which may\n     * be kept in fname, ffname and sfname.\n     */\n    if (buf_ffname)\n      ffname = buf->b_ffname;\n    if (buf_sfname)\n      sfname = buf->b_sfname;\n    if (buf_fname_f)\n      fname = buf->b_ffname;\n    if (buf_fname_s)\n      fname = buf->b_sfname;\n  }\n\n\n  if (shortmess(SHM_OVER) && !exiting)\n    msg_scroll = FALSE;             /* overwrite previous file message */\n  else\n    msg_scroll = TRUE;              /* don't overwrite previous file message */\n  if (!filtering)\n    filemess(buf,\n#ifndef UNIX\n        sfname,\n#else\n        fname,\n#endif\n        (char_u *)\"\", 0);               /* show that we are busy */\n  msg_scroll = FALSE;               /* always overwrite the file message now */\n\n  buffer = verbose_try_malloc(BUFSIZE);\n  // can't allocate big buffer, use small one (to be able to write when out of\n  // memory)\n  if (buffer == NULL) {\n    buffer = smallbuf;\n    bufsize = SMBUFSIZE;\n  } else\n    bufsize = BUFSIZE;\n\n  /*\n   * Get information about original file (if there is one).\n   */\n  FileInfo file_info_old;\n#if defined(UNIX)\n  perm = -1;\n  if (!os_fileinfo((char *)fname, &file_info_old)) {\n    newfile = TRUE;\n  } else {\n    perm = file_info_old.stat.st_mode;\n    if (!S_ISREG(file_info_old.stat.st_mode)) {             /* not a file */\n      if (S_ISDIR(file_info_old.stat.st_mode)) {\n        SET_ERRMSG_NUM(\"E502\", _(\"is a directory\"));\n        goto fail;\n      }\n      if (os_nodetype((char *)fname) != NODE_WRITABLE) {\n        SET_ERRMSG_NUM(\"E503\", _(\"is not a file or writable device\"));\n        goto fail;\n      }\n      /* It's a device of some kind (or a fifo) which we can write to\n       * but for which we can't make a backup. */\n      device = TRUE;\n      newfile = TRUE;\n      perm = -1;\n    }\n  }\n#else  // win32\n  // Check for a writable device name.\n  c = fname == NULL ? NODE_OTHER : os_nodetype((char *)fname);\n  if (c == NODE_OTHER) {\n    SET_ERRMSG_NUM(\"E503\", _(\"is not a file or writable device\"));\n    goto fail;\n  }\n  if (c == NODE_WRITABLE) {\n    device = TRUE;\n    newfile = TRUE;\n    perm = -1;\n  } else {\n    perm = os_getperm((const char *)fname);\n    if (perm < 0) {\n      newfile = true;\n    } else if (os_isdir(fname)) {\n      SET_ERRMSG_NUM(\"E502\", _(\"is a directory\"));\n      goto fail;\n    }\n    if (overwriting) {\n      os_fileinfo((char *)fname, &file_info_old);\n    }\n  }\n#endif  // !UNIX\n\n  if (!device && !newfile) {\n    /*\n     * Check if the file is really writable (when renaming the file to\n     * make a backup we won't discover it later).\n     */\n    file_readonly = !os_file_is_writable((char *)fname);\n\n    if (!forceit && file_readonly) {\n      if (vim_strchr(p_cpo, CPO_FWRITE) != NULL) {\n        SET_ERRMSG_NUM(\"E504\", _(err_readonly));\n      } else {\n        SET_ERRMSG_NUM(\"E505\", _(\"is read-only (add ! to override)\"));\n      }\n      goto fail;\n    }\n\n    /*\n     * Check if the timestamp hasn't changed since reading the file.\n     */\n    if (overwriting) {\n      retval = check_mtime(buf, &file_info_old);\n      if (retval == FAIL)\n        goto fail;\n    }\n  }\n\n#ifdef HAVE_ACL\n  /*\n   * For systems that support ACL: get the ACL from the original file.\n   */\n  if (!newfile)\n    acl = mch_get_acl(fname);\n#endif\n\n  /*\n   * If 'backupskip' is not empty, don't make a backup for some files.\n   */\n  dobackup = (p_wb || p_bk || *p_pm != NUL);\n  if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))\n    dobackup = FALSE;\n\n  /*\n   * Save the value of got_int and reset it.  We don't want a previous\n   * interruption cancel writing, only hitting CTRL-C while writing should\n   * abort it.\n   */\n  prev_got_int = got_int;\n  got_int = FALSE;\n\n  /* Mark the buffer as 'being saved' to prevent changed buffer warnings */\n  buf->b_saving = true;\n\n  /*\n   * If we are not appending or filtering, the file exists, and the\n   * 'writebackup', 'backup' or 'patchmode' option is set, need a backup.\n   * When 'patchmode' is set also make a backup when appending.\n   *\n   * Do not make any backup, if 'writebackup' and 'backup' are both switched\n   * off.  This helps when editing large files on almost-full disks.\n   */\n  if (!(append && *p_pm == NUL) && !filtering && perm >= 0 && dobackup) {\n    FileInfo file_info;\n    const bool no_prepend_dot = false;\n\n    if ((bkc & BKC_YES) || append) {       /* \"yes\" */\n      backup_copy = TRUE;\n    } else if ((bkc & BKC_AUTO)) {          /* \"auto\" */\n      int i;\n\n      /*\n       * Don't rename the file when:\n       * - it's a hard link\n       * - it's a symbolic link\n       * - we don't have write permission in the directory\n       */\n      if (os_fileinfo_hardlinks(&file_info_old) > 1\n          || !os_fileinfo_link((char *)fname, &file_info)\n          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {\n        backup_copy = TRUE;\n      } else {\n        /*\n         * Check if we can create a file and set the owner/group to\n         * the ones from the original file.\n         * First find a file name that doesn't exist yet (use some\n         * arbitrary numbers).\n         */\n        STRCPY(IObuff, fname);\n        for (i = 4913;; i += 123) {\n          sprintf((char *)path_tail(IObuff), \"%d\", i);\n          if (!os_fileinfo_link((char *)IObuff, &file_info)) {\n            break;\n          }\n        }\n        fd = os_open((char *)IObuff,\n            O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n        if (fd < 0)             /* can't write in directory */\n          backup_copy = TRUE;\n        else {\n# ifdef UNIX\n          os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);\n          if (!os_fileinfo((char *)IObuff, &file_info)\n              || file_info.stat.st_uid != file_info_old.stat.st_uid\n              || file_info.stat.st_gid != file_info_old.stat.st_gid\n              || (long)file_info.stat.st_mode != perm) {\n            backup_copy = TRUE;\n          }\n# endif\n          /* Close the file before removing it, on MS-Windows we\n           * can't delete an open file. */\n          close(fd);\n          os_remove((char *)IObuff);\n        }\n      }\n    }\n\n    /*\n     * Break symlinks and/or hardlinks if we've been asked to.\n     */\n    if ((bkc & BKC_BREAKSYMLINK) || (bkc & BKC_BREAKHARDLINK)) {\n# ifdef UNIX\n      bool file_info_link_ok = os_fileinfo_link((char *)fname, &file_info);\n\n      /* Symlinks. */\n      if ((bkc & BKC_BREAKSYMLINK)\n          && file_info_link_ok\n          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {\n        backup_copy = FALSE;\n      }\n\n      /* Hardlinks. */\n      if ((bkc & BKC_BREAKHARDLINK)\n          && os_fileinfo_hardlinks(&file_info_old) > 1\n          && (!file_info_link_ok\n              || os_fileinfo_id_equal(&file_info, &file_info_old))) {\n        backup_copy = FALSE;\n      }\n# endif\n    }\n\n    /* make sure we have a valid backup extension to use */\n    if (*p_bex == NUL)\n      backup_ext = (char_u *)\".bak\";\n    else\n      backup_ext = p_bex;\n\n    if (backup_copy) {\n      char_u *wp;\n      int some_error = false;\n      char_u      *dirp;\n      char_u      *rootname;\n      char_u      *p;\n\n      /*\n       * Try to make the backup in each directory in the 'bdir' option.\n       *\n       * Unix semantics has it, that we may have a writable file,\n       * that cannot be recreated with a simple open(..., O_CREAT, ) e.g:\n       *  - the directory is not writable,\n       *  - the file may be a symbolic link,\n       *  - the file may belong to another user/group, etc.\n       *\n       * For these reasons, the existing writable file must be truncated\n       * and reused. Creation of a backup COPY will be attempted.\n       */\n      dirp = p_bdir;\n      while (*dirp) {\n        /*\n         * Isolate one directory name, using an entry in 'bdir'.\n         */\n        size_t dir_len = copy_option_part(&dirp, IObuff, IOSIZE, \",\");\n        p = IObuff + dir_len;\n        bool trailing_pathseps = after_pathsep((char *)IObuff, (char *)p) && p[-1] == p[-2];\n        if (trailing_pathseps) {\n          IObuff[dir_len - 2] = NUL;\n        }\n        if (*dirp == NUL && !os_isdir(IObuff)) {\n          int ret;\n          char *failed_dir;\n          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &failed_dir)) != 0) {\n            EMSG3(_(\"E303: Unable to create directory \\\"%s\\\" for backup file: %s\"),\n                  failed_dir, os_strerror(ret));\n            xfree(failed_dir);\n          }\n        }\n        if (trailing_pathseps) {\n          // Ends with '//', Use Full path\n          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))\n              != NULL) {\n            backup = (char_u *)modname((char *)p, (char *)backup_ext,\n                                       no_prepend_dot);\n            xfree(p);\n          }\n        }\n\n        rootname = get_file_in_dir(fname, IObuff);\n        if (rootname == NULL) {\n          some_error = TRUE;                /* out of memory */\n          goto nobackup;\n        }\n\n        FileInfo file_info_new;\n        {\n          //\n          // Make the backup file name.\n          //\n          if (backup == NULL) {\n            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,\n                                       no_prepend_dot);\n          }\n\n          if (backup == NULL) {\n            xfree(rootname);\n            some_error = TRUE;                          /* out of memory */\n            goto nobackup;\n          }\n\n          /*\n           * Check if backup file already exists.\n           */\n          if (os_fileinfo((char *)backup, &file_info_new)) {\n            if (os_fileinfo_id_equal(&file_info_new, &file_info_old)) {\n              //\n              // Backup file is same as original file.\n              // May happen when modname() gave the same file back (e.g. silly\n              // link). If we don't check here, we either ruin the file when\n              // copying or erase it after writing.\n              //\n              XFREE_CLEAR(backup);              // no backup file to delete\n            } else if (!p_bk) {\n              // We are not going to keep the backup file, so don't\n              // delete an existing one, and try to use another name instead.\n              // Change one character, just before the extension.\n              //\n              wp = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);\n              if (wp < backup) {                // empty file name ???\n                wp = backup;\n              }\n              *wp = 'z';\n              while (*wp > 'a'\n                     && os_fileinfo((char *)backup, &file_info_new)) {\n                --*wp;\n              }\n              // They all exist??? Must be something wrong.\n              if (*wp == 'a') {\n                XFREE_CLEAR(backup);\n              }\n            }\n          }\n        }\n        xfree(rootname);\n\n        /*\n         * Try to create the backup file\n         */\n        if (backup != NULL) {\n          /* remove old backup, if present */\n          os_remove((char *)backup);\n\n          // set file protection same as original file, but\n          // strip s-bit.\n          (void)os_setperm((const char *)backup, perm & 0777);\n\n#ifdef UNIX\n          //\n          // Try to set the group of the backup same as the original file. If\n          // this fails, set the protection bits for the group same as the\n          // protection bits for others.\n          //\n          if (file_info_new.stat.st_gid != file_info_old.stat.st_gid\n              && os_chown((char *)backup, -1, file_info_old.stat.st_gid) != 0) {\n            os_setperm((const char *)backup,\n                       (perm & 0707) | ((perm & 07) << 3));\n          }\n#endif\n\n          // copy the file\n          if (os_copy((char *)fname, (char *)backup, UV_FS_COPYFILE_FICLONE)\n              != 0) {\n            SET_ERRMSG(_(\"E506: Can't write to backup file \"\n                         \"(add ! to override)\"));\n          }\n\n#ifdef UNIX\n          os_file_settime((char *)backup,\n                          file_info_old.stat.st_atim.tv_sec,\n                          file_info_old.stat.st_mtim.tv_sec);\n#endif\n#ifdef HAVE_ACL\n          mch_set_acl(backup, acl);\n#endif\n          break;\n        }\n      }\n\nnobackup:\n      if (backup == NULL && errmsg == NULL) {\n        SET_ERRMSG(_(\n            \"E509: Cannot create backup file (add ! to override)\"));\n      }\n      // Ignore errors when forceit is TRUE.\n      if ((some_error || errmsg != NULL) && !forceit) {\n        retval = FAIL;\n        goto fail;\n      }\n      SET_ERRMSG(NULL);\n    } else {\n      char_u      *dirp;\n      char_u      *p;\n      char_u      *rootname;\n\n      /*\n       * Make a backup by renaming the original file.\n       */\n      /*\n       * If 'cpoptions' includes the \"W\" flag, we don't want to\n       * overwrite a read-only file.  But rename may be possible\n       * anyway, thus we need an extra check here.\n       */\n      if (file_readonly && vim_strchr(p_cpo, CPO_FWRITE) != NULL) {\n        SET_ERRMSG_NUM(\"E504\", _(err_readonly));\n        goto fail;\n      }\n\n      /*\n       *\n       * Form the backup file name - change path/fo.o.h to\n       * path/fo.o.h.bak Try all directories in 'backupdir', first one\n       * that works is used.\n       */\n      dirp = p_bdir;\n      while (*dirp) {\n        /*\n         * Isolate one directory name and make the backup file name.\n         */\n        size_t dir_len = copy_option_part(&dirp, IObuff, IOSIZE, \",\");\n        p = IObuff + dir_len;\n        bool trailing_pathseps = after_pathsep((char *)IObuff, (char *)p) && p[-1] == p[-2];\n        if (trailing_pathseps) {\n          IObuff[dir_len - 2] = NUL;\n        }\n        if (*dirp == NUL && !os_isdir(IObuff)) {\n          int ret;\n          char *failed_dir;\n          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &failed_dir)) != 0) {\n            EMSG3(_(\"E303: Unable to create directory \\\"%s\\\" for backup file: %s\"),\n                  failed_dir, os_strerror(ret));\n            xfree(failed_dir);\n          }\n        }\n        if (trailing_pathseps) {\n          // path ends with '//', use full path\n          if ((p = (char_u *)make_percent_swname((char *)IObuff, (char *)fname))\n              != NULL) {\n            backup = (char_u *)modname((char *)p, (char *)backup_ext,\n                                       no_prepend_dot);\n            xfree(p);\n          }\n        }\n\n        if (backup == NULL) {\n          rootname = get_file_in_dir(fname, IObuff);\n          if (rootname == NULL) {\n            backup = NULL;\n          } else {\n            backup = (char_u *)modname((char *)rootname, (char *)backup_ext,\n                                       no_prepend_dot);\n            xfree(rootname);\n          }\n        }\n\n        if (backup != NULL) {\n          /*\n           * If we are not going to keep the backup file, don't\n           * delete an existing one, try to use another name.\n           * Change one character, just before the extension.\n           */\n          if (!p_bk && os_path_exists(backup)) {\n            p = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);\n            if (p < backup)             /* empty file name ??? */\n              p = backup;\n            *p = 'z';\n            while (*p > 'a' && os_path_exists(backup)) {\n              (*p)--;\n            }\n            // They all exist??? Must be something wrong!\n            if (*p == 'a') {\n              XFREE_CLEAR(backup);\n            }\n          }\n        }\n        if (backup != NULL) {\n          // Delete any existing backup and move the current version\n          // to the backup. For safety, we don't remove the backup\n          // until the write has finished successfully. And if the\n          // 'backup' option is set, leave it around.\n\n          // If the renaming of the original file to the backup file\n          // works, quit here.\n          ///\n          if (vim_rename(fname, backup) == 0) {\n            break;\n          }\n\n          XFREE_CLEAR(backup);             // don't do the rename below\n        }\n      }\n      if (backup == NULL && !forceit) {\n        SET_ERRMSG(_(\"E510: Can't make backup file (add ! to override)\"));\n        goto fail;\n      }\n    }\n  }\n\n#if defined(UNIX)\n  // When using \":w!\" and the file was read-only: make it writable\n  if (forceit && perm >= 0 && !(perm & 0200)\n      && file_info_old.stat.st_uid == getuid()\n      && vim_strchr(p_cpo, CPO_FWRITE) == NULL) {\n    perm |= 0200;\n    (void)os_setperm((const char *)fname, perm);\n    made_writable = true;\n  }\n#endif\n\n  // When using \":w!\" and writing to the current file, 'readonly' makes no\n  // sense, reset it, unless 'Z' appears in 'cpoptions'.\n  if (forceit && overwriting && vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {\n    buf->b_p_ro = false;\n    need_maketitle = true;          // set window title later\n    status_redraw_all();            // redraw status lines later\n  }\n\n  if (end > buf->b_ml.ml_line_count)\n    end = buf->b_ml.ml_line_count;\n  if (buf->b_ml.ml_flags & ML_EMPTY)\n    start = end + 1;\n\n  // If the original file is being overwritten, there is a small chance that\n  // we crash in the middle of writing. Therefore the file is preserved now.\n  // This makes all block numbers positive so that recovery does not need\n  // the original file.\n  // Don't do this if there is a backup file and we are exiting.\n  if (reset_changed && !newfile && overwriting\n      && !(exiting && backup != NULL)) {\n    ml_preserve(buf, false, !!p_fs);\n    if (got_int) {\n      SET_ERRMSG(_(e_interr));\n      goto restore_backup;\n    }\n  }\n\n\n  // Default: write the file directly.  May write to a temp file for\n  // multi-byte conversion.\n  wfname = fname;\n\n  // Check for forced 'fileencoding' from \"++opt=val\" argument.\n  if (eap != NULL && eap->force_enc != 0) {\n    fenc = eap->cmd + eap->force_enc;\n    fenc = enc_canonize(fenc);\n    fenc_tofree = fenc;\n  } else {\n    fenc = buf->b_p_fenc;\n  }\n\n  // Check if the file needs to be converted.\n  converted = need_conversion(fenc);\n\n  // Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or\n  // Latin1 to Unicode conversion.  This is handled in buf_write_bytes().\n  // Prepare the flags for it and allocate bw_conv_buf when needed.\n  if (converted) {\n    wb_flags = get_fio_flags(fenc);\n    if (wb_flags & (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8)) {\n      // Need to allocate a buffer to translate into.\n      if (wb_flags & (FIO_UCS2 | FIO_UTF16 | FIO_UTF8)) {\n        write_info.bw_conv_buflen = bufsize * 2;\n      } else {       // FIO_UCS4\n        write_info.bw_conv_buflen = bufsize * 4;\n      }\n      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);\n      if (!write_info.bw_conv_buf) {\n        end = 0;\n      }\n    }\n  }\n\n\n\n  if (converted && wb_flags == 0) {\n#  ifdef HAVE_ICONV\n    // Use iconv() conversion when conversion is needed and it's not done\n    // internally.\n    write_info.bw_iconv_fd = (iconv_t)my_iconv_open(fenc, (char_u *)\"utf-8\");\n    if (write_info.bw_iconv_fd != (iconv_t)-1) {\n      /* We're going to use iconv(), allocate a buffer to convert in. */\n      write_info.bw_conv_buflen = bufsize * ICONV_MULT;\n      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);\n      if (!write_info.bw_conv_buf) {\n        end = 0;\n      }\n      write_info.bw_first = TRUE;\n    } else\n#  endif\n\n    /*\n     * When the file needs to be converted with 'charconvert' after\n     * writing, write to a temp file instead and let the conversion\n     * overwrite the original file.\n     */\n    if (*p_ccv != NUL) {\n      wfname = vim_tempname();\n      if (wfname == NULL) {  // Can't write without a tempfile!\n        SET_ERRMSG(_(\"E214: Can't find temp file for writing\"));\n        goto restore_backup;\n      }\n    }\n  }\n  if (converted && wb_flags == 0\n#  ifdef HAVE_ICONV\n      && write_info.bw_iconv_fd == (iconv_t)-1\n#  endif\n      && wfname == fname\n      ) {\n    if (!forceit) {\n      SET_ERRMSG(_(\n          \"E213: Cannot convert (add ! to write without conversion)\"));\n      goto restore_backup;\n    }\n    notconverted = TRUE;\n  }\n\n  // If conversion is taking place, we may first pretend to write and check\n  // for conversion errors.  Then loop again to write for real.\n  // When not doing conversion this writes for real right away.\n  for (checking_conversion = true; ; checking_conversion = false) {\n    // There is no need to check conversion when:\n    // - there is no conversion\n    // - we make a backup file, that can be restored in case of conversion\n    // failure.\n    if (!converted || dobackup) {\n      checking_conversion = false;\n    }\n\n    if (checking_conversion) {\n      // Make sure we don't write anything.\n      fd = -1;\n      write_info.bw_fd = fd;\n    } else {\n      // Open the file \"wfname\" for writing.\n      // We may try to open the file twice: If we can't write to the file\n      // and forceit is TRUE we delete the existing file and try to\n      // create a new one. If this still fails we may have lost the\n      // original file!  (this may happen when the user reached his\n      // quotum for number of files).\n      // Appending will fail if the file does not exist and forceit is\n      // FALSE.\n      while ((fd = os_open((char *)wfname,\n                           O_WRONLY |\n                           (append ?\n                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)\n                            : (O_CREAT | O_TRUNC))\n                           , perm < 0 ? 0666 : (perm & 0777))) < 0) {\n        // A forced write will try to create a new file if the old one\n        // is still readonly. This may also happen when the directory\n        // is read-only. In that case the mch_remove() will fail.\n        if (errmsg == NULL) {\n#ifdef UNIX\n          FileInfo file_info;\n\n          // Don't delete the file when it's a hard or symbolic link.\n          if ((!newfile && os_fileinfo_hardlinks(&file_info_old) > 1)\n              || (os_fileinfo_link((char *)fname, &file_info)\n                  && !os_fileinfo_id_equal(&file_info, &file_info_old))) {\n            SET_ERRMSG(_(\"E166: Can't open linked file for writing\"));\n          } else {\n#endif\n            SET_ERRMSG_ARG(_(\"E212: Can't open file for writing: %s\"), fd);\n            if (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL\n                && perm >= 0) {\n#ifdef UNIX\n              // we write to the file, thus it should be marked\n              // writable after all\n              if (!(perm & 0200)) {\n                made_writable = true;\n              }\n              perm |= 0200;\n              if (file_info_old.stat.st_uid != getuid()\n                  || file_info_old.stat.st_gid != getgid()) {\n                perm &= 0777;\n              }\n#endif\n              if (!append) {                    // don't remove when appending\n                os_remove((char *)wfname);\n              }\n              continue;\n            }\n#ifdef UNIX\n          }\n#endif\n        }\n\nrestore_backup:\n        {\n          // If we failed to open the file, we don't need a backup. Throw it\n          // away.  If we moved or removed the original file try to put the\n          // backup in its place.\n          if (backup != NULL && wfname == fname) {\n            if (backup_copy) {\n              // There is a small chance that we removed the original,\n              // try to move the copy in its place.\n              // This may not work if the vim_rename() fails.\n              // In that case we leave the copy around.\n              // If file does not exist, put the copy in its place\n              if (!os_path_exists(fname)) {\n                vim_rename(backup, fname);\n              }\n              // if original file does exist throw away the copy\n              if (os_path_exists(fname)) {\n                os_remove((char *)backup);\n              }\n            } else {\n              // try to put the original file back\n              vim_rename(backup, fname);\n            }\n          }\n\n          // if original file no longer exists give an extra warning\n          if (!newfile && !os_path_exists(fname)) {\n            end = 0;\n          }\n        }\n\n        if (wfname != fname) {\n          xfree(wfname);\n        }\n        goto fail;\n      }\n      write_info.bw_fd = fd;\n    }\n    SET_ERRMSG(NULL);\n\n    write_info.bw_buf = buffer;\n    nchars = 0;\n\n    // use \"++bin\", \"++nobin\" or 'binary'\n    if (eap != NULL && eap->force_bin != 0) {\n      write_bin = (eap->force_bin == FORCE_BIN);\n    } else {\n      write_bin = buf->b_p_bin;\n    }\n\n    // Skip the BOM when appending and the file already existed, the BOM\n    // only makes sense at the start of the file.\n    if (buf->b_p_bomb && !write_bin && (!append || perm < 0)) {\n      write_info.bw_len = make_bom(buffer, fenc);\n      if (write_info.bw_len > 0) {\n        // don't convert\n        write_info.bw_flags = FIO_NOCONVERT | wb_flags;\n        if (buf_write_bytes(&write_info) == FAIL) {\n          end = 0;\n        } else {\n          nchars += write_info.bw_len;\n        }\n      }\n    }\n    write_info.bw_start_lnum = start;\n\n    write_undo_file = (buf->b_p_udf && overwriting && !append\n                       && !filtering && reset_changed && !checking_conversion);\n    if (write_undo_file) {\n      // Prepare for computing the hash value of the text.\n      sha256_start(&sha_ctx);\n    }\n\n    write_info.bw_len = bufsize;\n#ifdef HAS_BW_FLAGS\n    write_info.bw_flags = wb_flags;\n#endif\n    fileformat = get_fileformat_force(buf, eap);\n    s = buffer;\n    len = 0;\n    for (lnum = start; lnum <= end; lnum++) {\n      // The next while loop is done once for each character written.\n      // Keep it fast!\n      ptr = ml_get_buf(buf, lnum, false) - 1;\n      if (write_undo_file) {\n        sha256_update(&sha_ctx, ptr + 1, (uint32_t)(STRLEN(ptr + 1) + 1));\n      }\n      while ((c = *++ptr) != NUL) {\n        if (c == NL) {\n          *s = NUL;                       // replace newlines with NULs\n        } else if (c == CAR && fileformat == EOL_MAC) {\n          *s = NL;                        // Mac: replace CRs with NLs\n        } else {\n          *s = c;\n        }\n        s++;\n        if (++len != bufsize) {\n          continue;\n        }\n        if (buf_write_bytes(&write_info) == FAIL) {\n          end = 0;                        // write error: break loop\n          break;\n        }\n        nchars += bufsize;\n        s = buffer;\n        len = 0;\n        write_info.bw_start_lnum = lnum;\n      }\n      // write failed or last line has no EOL: stop here\n      if (end == 0\n          || (lnum == end\n              && (write_bin || !buf->b_p_fixeol)\n              && (lnum == buf->b_no_eol_lnum\n                  || (lnum == buf->b_ml.ml_line_count && !buf->b_p_eol)))) {\n        lnum++;                           // written the line, count it\n        no_eol = true;\n        break;\n      }\n      if (fileformat == EOL_UNIX) {\n        *s++ = NL;\n      } else {\n        *s++ = CAR;                       // EOL_MAC or EOL_DOS: write CR\n        if (fileformat == EOL_DOS) {      // write CR-NL\n          if (++len == bufsize) {\n            if (buf_write_bytes(&write_info) == FAIL) {\n              end = 0;                    // write error: break loop\n              break;\n            }\n            nchars += bufsize;\n            s = buffer;\n            len = 0;\n          }\n          *s++ = NL;\n        }\n      }\n      if (++len == bufsize) {\n        if (buf_write_bytes(&write_info) == FAIL) {\n          end = 0;  // Write error: break loop.\n          break;\n        }\n        nchars += bufsize;\n        s = buffer;\n        len = 0;\n\n        os_breakcheck();\n        if (got_int) {\n          end = 0;  // Interrupted, break loop.\n          break;\n        }\n      }\n    }\n    if (len > 0 && end > 0) {\n      write_info.bw_len = len;\n      if (buf_write_bytes(&write_info) == FAIL) {\n        end = 0;                      // write error\n      }\n      nchars += len;\n    }\n\n    // Stop when writing done or an error was encountered.\n    if (!checking_conversion || end == 0) {\n        break;\n    }\n\n    // If no error happened until now, writing should be ok, so loop to\n    // really write the buffer.\n  }\n\n  // If we started writing, finish writing. Also when an error was\n  // encountered.\n  if (!checking_conversion) {\n    // On many journalling file systems there is a bug that causes both the\n    // original and the backup file to be lost when halting the system right\n    // after writing the file.  That's because only the meta-data is\n    // journalled.  Syncing the file slows down the system, but assures it has\n    // been written to disk and we don't lose it.\n    // For a device do try the fsync() but don't complain if it does not work\n    // (could be a pipe).\n    // If the 'fsync' option is FALSE, don't fsync().  Useful for laptops.\n    int error;\n    if (p_fs && (error = os_fsync(fd)) != 0 && !device\n        // fsync not supported on this storage.\n        && error != UV_ENOTSUP) {\n      SET_ERRMSG_ARG(e_fsync, error);\n      end = 0;\n    }\n\n#ifdef UNIX\n    // When creating a new file, set its owner/group to that of the original\n    // file.  Get the new device and inode number.\n    if (backup != NULL && !backup_copy) {\n      // don't change the owner when it's already OK, some systems remove\n      // permission or ACL stuff\n      FileInfo file_info;\n      if (!os_fileinfo((char *)wfname, &file_info)\n          || file_info.stat.st_uid != file_info_old.stat.st_uid\n          || file_info.stat.st_gid != file_info_old.stat.st_gid) {\n        os_fchown(fd, file_info_old.stat.st_uid, file_info_old.stat.st_gid);\n        if (perm >= 0) {  // Set permission again, may have changed.\n          (void)os_setperm((const char *)wfname, perm);\n        }\n      }\n      buf_set_file_id(buf);\n    } else if (!buf->file_id_valid) {\n      // Set the file_id when creating a new file.\n      buf_set_file_id(buf);\n    }\n#endif\n\n    if ((error = os_close(fd)) != 0) {\n      SET_ERRMSG_ARG(_(\"E512: Close failed: %s\"), error);\n      end = 0;\n    }\n\n#ifdef UNIX\n    if (made_writable) {\n      perm &= ~0200;              // reset 'w' bit for security reasons\n    }\n#endif\n    if (perm >= 0) {  // Set perm. of new file same as old file.\n      (void)os_setperm((const char *)wfname, perm);\n    }\n#ifdef HAVE_ACL\n    // Probably need to set the ACL before changing the user (can't set the\n    // ACL on a file the user doesn't own).\n    if (!backup_copy) {\n      mch_set_acl(wfname, acl);\n    }\n#endif\n\n    if (wfname != fname) {\n      // The file was written to a temp file, now it needs to be converted\n      // with 'charconvert' to (overwrite) the output file.\n      if (end != 0) {\n        if (eval_charconvert(\"utf-8\", (char *)fenc,\n                             (char *)wfname, (char *)fname) == FAIL) {\n          write_info.bw_conv_error = true;\n          end = 0;\n        }\n      }\n      os_remove((char *)wfname);\n      xfree(wfname);\n    }\n  }\n\n  if (end == 0) {\n    // Error encountered.\n    if (errmsg == NULL) {\n      if (write_info.bw_conv_error) {\n        if (write_info.bw_conv_error_lnum == 0) {\n          SET_ERRMSG(_(\n              \"E513: write error, conversion failed \"\n              \"(make 'fenc' empty to override)\"));\n        } else {\n          errmsg_allocated = true;\n          SET_ERRMSG(xmalloc(300));\n          vim_snprintf(\n              errmsg, 300,\n              _(\"E513: write error, conversion failed in line %\" PRIdLINENR\n                \" (make 'fenc' empty to override)\"),\n              write_info.bw_conv_error_lnum);\n        }\n      } else if (got_int) {\n        SET_ERRMSG(_(e_interr));\n      } else {\n        SET_ERRMSG(_(\"E514: write error (file system full?)\"));\n      }\n    }\n\n    // If we have a backup file, try to put it in place of the new file,\n    // because the new file is probably corrupt.  This avoids losing the\n    // original file when trying to make a backup when writing the file a\n    // second time.\n    // When \"backup_copy\" is set we need to copy the backup over the new\n    // file.  Otherwise rename the backup file.\n    // If this is OK, don't give the extra warning message.\n    if (backup != NULL) {\n      if (backup_copy) {\n        // This may take a while, if we were interrupted let the user\n        // know we got the message.\n        if (got_int) {\n          MSG(_(e_interr));\n          ui_flush();\n        }\n\n        // copy the file.\n        if (os_copy((char *)backup, (char *)fname, UV_FS_COPYFILE_FICLONE)\n            == 0) {\n          end = 1;  // success\n        }\n      } else {\n        if (vim_rename(backup, fname) == 0) {\n          end = 1;\n        }\n      }\n    }\n    goto fail;\n  }\n\n  lnum -= start;            /* compute number of written lines */\n  --no_wait_return;         /* may wait for return now */\n\n#if !defined(UNIX)\n  fname = sfname;           /* use shortname now, for the messages */\n#endif\n  if (!filtering) {\n    add_quoted_fname((char *)IObuff, IOSIZE, buf, (const char *)fname);\n    c = false;\n    if (write_info.bw_conv_error) {\n      STRCAT(IObuff, _(\" CONVERSION ERROR\"));\n      c = TRUE;\n      if (write_info.bw_conv_error_lnum != 0)\n        vim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %\" PRId64 \";\"),\n            (int64_t)write_info.bw_conv_error_lnum);\n    } else if (notconverted) {\n      STRCAT(IObuff, _(\"[NOT converted]\"));\n      c = TRUE;\n    } else if (converted) {\n      STRCAT(IObuff, _(\"[converted]\"));\n      c = TRUE;\n    }\n    if (device) {\n      STRCAT(IObuff, _(\"[Device]\"));\n      c = TRUE;\n    } else if (newfile) {\n      STRCAT(IObuff, new_file_message());\n      c = true;\n    }\n    if (no_eol) {\n      msg_add_eol();\n      c = TRUE;\n    }\n    /* may add [unix/dos/mac] */\n    if (msg_add_fileformat(fileformat))\n      c = TRUE;\n    msg_add_lines(c, (long)lnum, nchars);       /* add line/char count */\n    if (!shortmess(SHM_WRITE)) {\n      if (append)\n        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));\n      else\n        STRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [w]\") : _(\" written\"));\n    }\n\n    set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);\n  }\n\n  /* When written everything correctly: reset 'modified'.  Unless not\n   * writing to the original file and '+' is not in 'cpoptions'. */\n  if (reset_changed && whole && !append\n      && !write_info.bw_conv_error\n      && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {\n    unchanged(buf, true, false);\n    const varnumber_T changedtick = buf_get_changedtick(buf);\n    if (buf->b_last_changedtick + 1 == changedtick) {\n      // b:changedtick may be incremented in unchanged() but that\n      // should not trigger a TextChanged event.\n      buf->b_last_changedtick = changedtick;\n    }\n    u_unchanged(buf);\n    u_update_save_nr(buf);\n  }\n\n  /*\n   * If written to the current file, update the timestamp of the swap file\n   * and reset the BF_WRITE_MASK flags. Also sets buf->b_mtime.\n   */\n  if (overwriting) {\n    ml_timestamp(buf);\n    if (append)\n      buf->b_flags &= ~BF_NEW;\n    else\n      buf->b_flags &= ~BF_WRITE_MASK;\n  }\n\n  /*\n   * If we kept a backup until now, and we are in patch mode, then we make\n   * the backup file our 'original' file.\n   */\n  if (*p_pm && dobackup) {\n    char *const org = modname((char *)fname, (char *)p_pm, false);\n\n    if (backup != NULL) {\n      /*\n       * If the original file does not exist yet\n       * the current backup file becomes the original file\n       */\n      if (org == NULL) {\n        EMSG(_(\"E205: Patchmode: can't save original file\"));\n      } else if (!os_path_exists((char_u *)org)) {\n        vim_rename(backup, (char_u *)org);\n        XFREE_CLEAR(backup);                   // don't delete the file\n#ifdef UNIX\n        os_file_settime(org,\n                        file_info_old.stat.st_atim.tv_sec,\n                        file_info_old.stat.st_mtim.tv_sec);\n#endif\n      }\n    }\n    /*\n     * If there is no backup file, remember that a (new) file was\n     * created.\n     */\n    else {\n      int empty_fd;\n\n      if (org == NULL\n          || (empty_fd = os_open(org,\n                  O_CREAT | O_EXCL | O_NOFOLLOW,\n                  perm < 0 ? 0666 : (perm & 0777))) < 0)\n        EMSG(_(\"E206: patchmode: can't touch empty original file\"));\n      else\n        close(empty_fd);\n    }\n    if (org != NULL) {\n      os_setperm(org, os_getperm((const char *)fname) & 0777);\n      xfree(org);\n    }\n  }\n\n  /*\n   * Remove the backup unless 'backup' option is set\n   */\n  if (!p_bk && backup != NULL\n      && !write_info.bw_conv_error\n      && os_remove((char *)backup) != 0) {\n    EMSG(_(\"E207: Can't delete backup file\"));\n  }\n\n  goto nofail;\n\n  /*\n   * Finish up.  We get here either after failure or success.\n   */\nfail:\n  --no_wait_return;             /* may wait for return now */\nnofail:\n\n  /* Done saving, we accept changed buffer warnings again */\n  buf->b_saving = false;\n\n  xfree(backup);\n  if (buffer != smallbuf)\n    xfree(buffer);\n  xfree(fenc_tofree);\n  xfree(write_info.bw_conv_buf);\n# ifdef HAVE_ICONV\n  if (write_info.bw_iconv_fd != (iconv_t)-1) {\n    iconv_close(write_info.bw_iconv_fd);\n    write_info.bw_iconv_fd = (iconv_t)-1;\n  }\n# endif\n#ifdef HAVE_ACL\n  mch_free_acl(acl);\n#endif\n\n  if (errmsg != NULL) {\n    // - 100 to save some space for further error message\n#ifndef UNIX\n    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)sfname);\n#else\n    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)fname);\n#endif\n    if (errnum != NULL) {\n      if (errmsgarg != 0) {\n        emsgf(\"%s: %s%s: %s\", errnum, IObuff, errmsg, os_strerror(errmsgarg));\n      } else {\n        emsgf(\"%s: %s%s\", errnum, IObuff, errmsg);\n      }\n    } else if (errmsgarg != 0) {\n      emsgf(errmsg, os_strerror(errmsgarg));\n    } else {\n      EMSG(errmsg);\n    }\n    if (errmsg_allocated) {\n      xfree(errmsg);\n    }\n\n    retval = FAIL;\n    if (end == 0) {\n      const int attr = HL_ATTR(HLF_E);  // Set highlight for error messages.\n      MSG_PUTS_ATTR(_(\"\\nWARNING: Original file may be lost or damaged\\n\"),\n                    attr | MSG_HIST);\n      MSG_PUTS_ATTR(_(\n              \"don't quit the editor until the file is successfully written!\"),\n          attr | MSG_HIST);\n\n      /* Update the timestamp to avoid an \"overwrite changed file\"\n       * prompt when writing again. */\n      if (os_fileinfo((char *)fname, &file_info_old)) {\n        buf_store_file_info(buf, &file_info_old);\n        buf->b_mtime_read = buf->b_mtime;\n      }\n    }\n  }\n  msg_scroll = msg_save;\n\n  /*\n   * When writing the whole file and 'undofile' is set, also write the undo\n   * file.\n   */\n  if (retval == OK && write_undo_file) {\n    char_u hash[UNDO_HASH_SIZE];\n\n    sha256_finish(&sha_ctx, hash);\n    u_write_undo(NULL, FALSE, buf, hash);\n  }\n\n  if (!should_abort(retval)) {\n    aco_save_T aco;\n\n    curbuf->b_no_eol_lnum = 0;      /* in case it was set by the previous read */\n\n    /*\n     * Apply POST autocommands.\n     * Careful: The autocommands may call buf_write() recursively!\n     */\n    aucmd_prepbuf(&aco, buf);\n\n    if (append)\n      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,\n          FALSE, curbuf, eap);\n    else if (filtering)\n      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,\n          FALSE, curbuf, eap);\n    else if (reset_changed && whole)\n      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,\n          FALSE, curbuf, eap);\n    else\n      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,\n          FALSE, curbuf, eap);\n\n    /* restore curwin/curbuf and a few other things */\n    aucmd_restbuf(&aco);\n\n    if (aborting())         /* autocmds may abort script processing */\n      retval = FALSE;\n  }\n\n  got_int |= prev_got_int;\n\n  return retval;\n#undef SET_ERRMSG\n#undef SET_ERRMSG_ARG\n#undef SET_ERRMSG_NUM\n}\n\n/*\n * Set the name of the current buffer.  Use when the buffer doesn't have a\n * name and a \":r\" or \":w\" command with a file name is used.\n */\nstatic int set_rw_fname(char_u *fname, char_u *sfname)\n{\n  buf_T       *buf = curbuf;\n\n  /* It's like the unnamed buffer is deleted.... */\n  if (curbuf->b_p_bl)\n    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);\n  if (aborting())           /* autocmds may abort script processing */\n    return FAIL;\n  if (curbuf != buf) {\n    /* We are in another buffer now, don't do the renaming. */\n    EMSG(_(e_auchangedbuf));\n    return FAIL;\n  }\n\n  if (setfname(curbuf, fname, sfname, false) == OK) {\n    curbuf->b_flags |= BF_NOTEDITED;\n  }\n\n  /* ....and a new named one is created */\n  apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);\n  if (curbuf->b_p_bl)\n    apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n  if (aborting())           /* autocmds may abort script processing */\n    return FAIL;\n\n  /* Do filetype detection now if 'filetype' is empty. */\n  if (*curbuf->b_p_ft == NUL) {\n    if (au_has_group((char_u *)\"filetypedetect\")) {\n      (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", false, NULL);\n    }\n    do_modelines(0);\n  }\n\n  return OK;\n}\n\n/// Put file name into the specified buffer with quotes\n///\n/// Replaces home directory at the start with `~`.\n///\n/// @param[out]  ret_buf  Buffer to save results to.\n/// @param[in]  buf_len  ret_buf length.\n/// @param[in]  buf  buf_T file name is coming from.\n/// @param[in]  fname  File name to write.\nstatic void add_quoted_fname(char *const ret_buf, const size_t buf_len,\n                             const buf_T *const buf, const char *fname)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (fname == NULL) {\n    fname = \"-stdin-\";\n  }\n  ret_buf[0] = '\"';\n  home_replace(buf, (const char_u *)fname, (char_u *)ret_buf + 1,\n               (int)buf_len - 4, true);\n  xstrlcat(ret_buf, \"\\\" \", buf_len);\n}\n\n/// Append message for text mode to IObuff.\n///\n/// @param eol_type line ending type\n///\n/// @return true if something was appended.\nstatic bool msg_add_fileformat(int eol_type)\n{\n#ifndef USE_CRNL\n  if (eol_type == EOL_DOS) {\n    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[dos]\") : _(\"[dos format]\"));\n    return true;\n  }\n#endif\n  if (eol_type == EOL_MAC) {\n    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[mac]\") : _(\"[mac format]\"));\n    return true;\n  }\n#ifdef USE_CRNL\n  if (eol_type == EOL_UNIX) {\n    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[unix]\") : _(\"[unix format]\"));\n    return true;\n  }\n#endif\n  return false;\n}\n\n/*\n * Append line and character count to IObuff.\n */\nvoid msg_add_lines(int insert_space, long lnum, off_T nchars)\n{\n  char_u  *p;\n\n  p = IObuff + STRLEN(IObuff);\n\n  if (insert_space)\n    *p++ = ' ';\n  if (shortmess(SHM_LINES)) {\n     sprintf((char *)p, \"%\" PRId64 \"L, %\" PRId64 \"C\",\n             (int64_t)lnum, (int64_t)nchars);\n  }\n  else {\n    if (lnum == 1)\n      STRCPY(p, _(\"1 line, \"));\n    else\n      sprintf((char *)p, _(\"%\" PRId64 \" lines, \"), (int64_t)lnum);\n    p += STRLEN(p);\n    if (nchars == 1)\n      STRCPY(p, _(\"1 character\"));\n    else {\n      sprintf((char *)p, _(\"%\" PRId64 \" characters\"), (int64_t)nchars);\n    }\n  }\n}\n\n/*\n * Append message for missing line separator to IObuff.\n */\nstatic void msg_add_eol(void)\n{\n  STRCAT(IObuff,\n      shortmess(SHM_LAST) ? _(\"[noeol]\") : _(\"[Incomplete last line]\"));\n}\n\n/*\n * Check modification time of file, before writing to it.\n * The size isn't checked, because using a tool like \"gzip\" takes care of\n * using the same timestamp but can't set the size.\n */\nstatic int check_mtime(buf_T *buf, FileInfo *file_info)\n{\n  if (buf->b_mtime_read != 0\n      && time_differs(file_info->stat.st_mtim.tv_sec,\n                      buf->b_mtime_read)) {\n    msg_scroll = true;  // Don't overwrite messages here.\n    msg_silent = 0;     // Must give this prompt.\n    // Don't use emsg() here, don't want to flush the buffers.\n    msg_attr(_(\"WARNING: The file has been changed since reading it!!!\"),\n             HL_ATTR(HLF_E));\n    if (ask_yesno(_(\"Do you really want to write to it\"), true) == 'n') {\n      return FAIL;\n    }\n    msg_scroll = false;  // Always overwrite the file message now.\n  }\n  return OK;\n}\n\n/// Return true if the times differ\n///\n/// @param t1 first time\n/// @param t2 second time\nstatic bool time_differs(long t1, long t2) FUNC_ATTR_CONST\n{\n#if defined(__linux__) || defined(MSWIN)\n  /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store\n   * the seconds.  Since the roundoff is done when flushing the inode, the\n   * time may change unexpectedly by one second!!! */\n  return t1 - t2 > 1 || t2 - t1 > 1;\n#else\n  return t1 != t2;\n#endif\n}\n\n/*\n * Call write() to write a number of bytes to the file.\n * Handles 'encoding' conversion.\n *\n * Return FAIL for failure, OK otherwise.\n */\nstatic int buf_write_bytes(struct bw_info *ip)\n{\n  int wlen;\n  char_u      *buf = ip->bw_buf;        /* data to write */\n  int len = ip->bw_len;                 /* length of data */\n#ifdef HAS_BW_FLAGS\n  int flags = ip->bw_flags;             /* extra flags */\n#endif\n\n  /*\n   * Skip conversion when writing the BOM.\n   */\n  if (!(flags & FIO_NOCONVERT)) {\n    char_u          *p;\n    unsigned c;\n    int n;\n\n    if (flags & FIO_UTF8) {\n      /*\n       * Convert latin1 in the buffer to UTF-8 in the file.\n       */\n      p = ip->bw_conv_buf;              /* translate to buffer */\n      for (wlen = 0; wlen < len; ++wlen)\n        p += utf_char2bytes(buf[wlen], p);\n      buf = ip->bw_conv_buf;\n      len = (int)(p - ip->bw_conv_buf);\n    } else if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {\n      /*\n       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or\n       * Latin1 chars in the file.\n       */\n      if (flags & FIO_LATIN1)\n        p = buf;                /* translate in-place (can only get shorter) */\n      else\n        p = ip->bw_conv_buf;            /* translate to buffer */\n      for (wlen = 0; wlen < len; wlen += n) {\n        if (wlen == 0 && ip->bw_restlen != 0) {\n          int l;\n\n          /* Use remainder of previous call.  Append the start of\n           * buf[] to get a full sequence.  Might still be too\n           * short! */\n          l = CONV_RESTLEN - ip->bw_restlen;\n          if (l > len)\n            l = len;\n          memmove(ip->bw_rest + ip->bw_restlen, buf, (size_t)l);\n          n = utf_ptr2len_len(ip->bw_rest, ip->bw_restlen + l);\n          if (n > ip->bw_restlen + len) {\n            /* We have an incomplete byte sequence at the end to\n             * be written.  We can't convert it without the\n             * remaining bytes.  Keep them for the next call. */\n            if (ip->bw_restlen + len > CONV_RESTLEN)\n              return FAIL;\n            ip->bw_restlen += len;\n            break;\n          }\n          if (n > 1)\n            c = utf_ptr2char(ip->bw_rest);\n          else\n            c = ip->bw_rest[0];\n          if (n >= ip->bw_restlen) {\n            n -= ip->bw_restlen;\n            ip->bw_restlen = 0;\n          } else {\n            ip->bw_restlen -= n;\n            memmove(ip->bw_rest, ip->bw_rest + n,\n                (size_t)ip->bw_restlen);\n            n = 0;\n          }\n        } else {\n          n = utf_ptr2len_len(buf + wlen, len - wlen);\n          if (n > len - wlen) {\n            /* We have an incomplete byte sequence at the end to\n             * be written.  We can't convert it without the\n             * remaining bytes.  Keep them for the next call. */\n            if (len - wlen > CONV_RESTLEN)\n              return FAIL;\n            ip->bw_restlen = len - wlen;\n            memmove(ip->bw_rest, buf + wlen,\n                (size_t)ip->bw_restlen);\n            break;\n          }\n          if (n > 1)\n            c = utf_ptr2char(buf + wlen);\n          else\n            c = buf[wlen];\n        }\n\n        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {\n          ip->bw_conv_error = TRUE;\n          ip->bw_conv_error_lnum = ip->bw_start_lnum;\n        }\n        if (c == NL)\n          ++ip->bw_start_lnum;\n      }\n      if (flags & FIO_LATIN1)\n        len = (int)(p - buf);\n      else {\n        buf = ip->bw_conv_buf;\n        len = (int)(p - ip->bw_conv_buf);\n      }\n    }\n\n# ifdef HAVE_ICONV\n    if (ip->bw_iconv_fd != (iconv_t)-1) {\n      const char  *from;\n      size_t fromlen;\n      char        *to;\n      size_t tolen;\n\n      /* Convert with iconv(). */\n      if (ip->bw_restlen > 0) {\n        char *fp;\n\n        /* Need to concatenate the remainder of the previous call and\n         * the bytes of the current call.  Use the end of the\n         * conversion buffer for this. */\n        fromlen = len + ip->bw_restlen;\n        fp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n        memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);\n        memmove(fp + ip->bw_restlen, buf, (size_t)len);\n        from = fp;\n        tolen = ip->bw_conv_buflen - fromlen;\n      } else {\n        from = (const char *)buf;\n        fromlen = len;\n        tolen = ip->bw_conv_buflen;\n      }\n      to = (char *)ip->bw_conv_buf;\n\n      if (ip->bw_first) {\n        size_t save_len = tolen;\n\n        /* output the initial shift state sequence */\n        (void)iconv(ip->bw_iconv_fd, NULL, NULL, &to, &tolen);\n\n        /* There is a bug in iconv() on Linux (which appears to be\n         * wide-spread) which sets \"to\" to NULL and messes up \"tolen\".\n         */\n        if (to == NULL) {\n          to = (char *)ip->bw_conv_buf;\n          tolen = save_len;\n        }\n        ip->bw_first = FALSE;\n      }\n\n      /*\n       * If iconv() has an error or there is not enough room, fail.\n       */\n      if ((iconv(ip->bw_iconv_fd, (void *)&from, &fromlen, &to, &tolen)\n           == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n          || fromlen > CONV_RESTLEN) {\n        ip->bw_conv_error = TRUE;\n        return FAIL;\n      }\n\n      /* copy remainder to ip->bw_rest[] to be used for the next call. */\n      if (fromlen > 0)\n        memmove(ip->bw_rest, (void *)from, fromlen);\n      ip->bw_restlen = (int)fromlen;\n\n      buf = ip->bw_conv_buf;\n      len = (int)((char_u *)to - ip->bw_conv_buf);\n    }\n# endif\n  }\n\n  if (ip->bw_fd < 0) {\n    // Only checking conversion, which is OK if we get here.\n    return OK;\n  }\n  wlen = write_eintr(ip->bw_fd, buf, len);\n  return (wlen < len) ? FAIL : OK;\n}\n\n/// Convert a Unicode character to bytes.\n///\n/// @param c character to convert\n/// @param[in,out] pp pointer to store the result at\n/// @param flags FIO_ flags that specify which encoding to use\n///\n/// @return true for an error, false when it's OK.\nstatic bool ucs2bytes(unsigned c, char_u **pp, int flags) FUNC_ATTR_NONNULL_ALL\n{\n  char_u      *p = *pp;\n  bool error = false;\n  int cc;\n\n\n  if (flags & FIO_UCS4) {\n    if (flags & FIO_ENDIAN_L) {\n      *p++ = c;\n      *p++ = (c >> 8);\n      *p++ = (c >> 16);\n      *p++ = (c >> 24);\n    } else {\n      *p++ = (c >> 24);\n      *p++ = (c >> 16);\n      *p++ = (c >> 8);\n      *p++ = c;\n    }\n  } else if (flags & (FIO_UCS2 | FIO_UTF16)) {\n    if (c >= 0x10000) {\n      if (flags & FIO_UTF16) {\n        /* Make two words, ten bits of the character in each.  First\n         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */\n        c -= 0x10000;\n        if (c >= 0x100000) {\n          error = true;\n        }\n        cc = ((c >> 10) & 0x3ff) + 0xd800;\n        if (flags & FIO_ENDIAN_L) {\n          *p++ = cc;\n          *p++ = ((unsigned)cc >> 8);\n        } else {\n          *p++ = ((unsigned)cc >> 8);\n          *p++ = cc;\n        }\n        c = (c & 0x3ff) + 0xdc00;\n      } else {\n        error = true;\n      }\n    }\n    if (flags & FIO_ENDIAN_L) {\n      *p++ = c;\n      *p++ = (c >> 8);\n    } else {\n      *p++ = (c >> 8);\n      *p++ = c;\n    }\n  } else { /* Latin1 */\n    if (c >= 0x100) {\n      error = true;\n      *p++ = 0xBF;\n    } else\n      *p++ = c;\n  }\n\n  *pp = p;\n  return error;\n}\n\n/// Return true if file encoding \"fenc\" requires conversion from or to\n/// 'encoding'.\n///\n/// @param fenc file encoding to check\n///\n/// @return true if conversion is required\nstatic bool need_conversion(const char_u *fenc)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int same_encoding;\n  int enc_flags;\n  int fenc_flags;\n\n  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {\n    same_encoding = TRUE;\n    fenc_flags = 0;\n  } else {\n    /* Ignore difference between \"ansi\" and \"latin1\", \"ucs-4\" and\n     * \"ucs-4be\", etc. */\n    enc_flags = get_fio_flags(p_enc);\n    fenc_flags = get_fio_flags(fenc);\n    same_encoding = (enc_flags != 0 && fenc_flags == enc_flags);\n  }\n  if (same_encoding) {\n    // Specified file encoding matches UTF-8.\n    return false;\n  }\n\n  /* Encodings differ.  However, conversion is not needed when 'enc' is any\n   * Unicode encoding and the file is UTF-8. */\n  return !(fenc_flags == FIO_UTF8);\n}\n\n/// Return the FIO_ flags needed for the internal conversion if 'name' was\n/// unicode or latin1, otherwise 0. If \"name\" is an empty string,\n/// use 'encoding'.\n///\n/// @param name string to check for encoding\nstatic int get_fio_flags(const char_u *name)\n{\n  int prop;\n\n  if (*name == NUL) {\n    name = p_enc;\n  }\n  prop = enc_canon_props(name);\n  if (prop & ENC_UNICODE) {\n    if (prop & ENC_2BYTE) {\n      if (prop & ENC_ENDIAN_L)\n        return FIO_UCS2 | FIO_ENDIAN_L;\n      return FIO_UCS2;\n    }\n    if (prop & ENC_4BYTE) {\n      if (prop & ENC_ENDIAN_L)\n        return FIO_UCS4 | FIO_ENDIAN_L;\n      return FIO_UCS4;\n    }\n    if (prop & ENC_2WORD) {\n      if (prop & ENC_ENDIAN_L)\n        return FIO_UTF16 | FIO_ENDIAN_L;\n      return FIO_UTF16;\n    }\n    return FIO_UTF8;\n  }\n  if (prop & ENC_LATIN1)\n    return FIO_LATIN1;\n  /* must be ENC_DBCS, requires iconv() */\n  return 0;\n}\n\n\n\n/*\n * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].\n * \"size\" must be at least 2.\n * Return the name of the encoding and set \"*lenp\" to the length.\n * Returns NULL when no BOM found.\n */\nstatic char_u *check_for_bom(char_u *p, long size, int *lenp, int flags)\n{\n  char        *name = NULL;\n  int len = 2;\n\n  if (p[0] == 0xef && p[1] == 0xbb && size >= 3 && p[2] == 0xbf\n      && (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {\n    name = \"utf-8\";             /* EF BB BF */\n    len = 3;\n  } else if (p[0] == 0xff && p[1] == 0xfe) {\n    if (size >= 4 && p[2] == 0 && p[3] == 0\n        && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {\n      name = \"ucs-4le\";         /* FF FE 00 00 */\n      len = 4;\n    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))\n      name = \"ucs-2le\";         /* FF FE */\n    else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))\n      /* utf-16le is preferred, it also works for ucs-2le text */\n      name = \"utf-16le\";        /* FF FE */\n  } else if (p[0] == 0xfe && p[1] == 0xff\n             && (flags == FIO_ALL || flags == FIO_UCS2 || flags ==\n                 FIO_UTF16)) {\n    /* Default to utf-16, it works also for ucs-2 text. */\n    if (flags == FIO_UCS2)\n      name = \"ucs-2\";           /* FE FF */\n    else\n      name = \"utf-16\";          /* FE FF */\n  } else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe\n             && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4)) {\n    name = \"ucs-4\";             /* 00 00 FE FF */\n    len = 4;\n  }\n\n  *lenp = len;\n  return (char_u *)name;\n}\n\n/*\n * Generate a BOM in \"buf[4]\" for encoding \"name\".\n * Return the length of the BOM (zero when no BOM).\n */\nstatic int make_bom(char_u *buf, char_u *name)\n{\n  int flags;\n  char_u      *p;\n\n  flags = get_fio_flags(name);\n\n  /* Can't put a BOM in a non-Unicode file. */\n  if (flags == FIO_LATIN1 || flags == 0)\n    return 0;\n\n  if (flags == FIO_UTF8) {      /* UTF-8 */\n    buf[0] = 0xef;\n    buf[1] = 0xbb;\n    buf[2] = 0xbf;\n    return 3;\n  }\n  p = buf;\n  (void)ucs2bytes(0xfeff, &p, flags);\n  return (int)(p - buf);\n}\n\n/// Shorten filename of a buffer.\n/// When \"force\" is TRUE: Use full path from now on for files currently being\n/// edited, both for file name and swap file name.  Try to shorten the file\n/// names a bit, if safe to do so.\n/// When \"force\" is FALSE: Only try to shorten absolute file names.\n/// For buffers that have buftype \"nofile\" or \"scratch\": never change the file\n/// name.\nvoid shorten_buf_fname(buf_T *buf, char_u *dirname, int force)\n{\n  char_u      *p;\n\n  if (buf->b_fname != NULL\n      && !bt_nofile(buf)\n      && !path_with_url((char *)buf->b_fname)\n      && (force\n          || buf->b_sfname == NULL\n          || path_is_absolute(buf->b_sfname))) {\n    if (buf->b_sfname != buf->b_ffname) {\n      XFREE_CLEAR(buf->b_sfname);\n    }\n    p = path_shorten_fname(buf->b_ffname, dirname);\n    if (p != NULL) {\n      buf->b_sfname = vim_strsave(p);\n      buf->b_fname = buf->b_sfname;\n    }\n    if (p == NULL) {\n      buf->b_fname = buf->b_ffname;\n    }\n  }\n}\n\n/// Shorten filenames for all buffers.\nvoid shorten_fnames(int force)\n{\n  char_u dirname[MAXPATHL];\n\n  os_dirname(dirname, MAXPATHL);\n  FOR_ALL_BUFFERS(buf) {\n      shorten_buf_fname(buf, dirname, force);\n\n    // Always make the swap file name a full path, a \"nofile\" buffer may\n    // also have a swap file.\n    mf_fullname(buf->b_ml.ml_mfp);\n  }\n  status_redraw_all();\n  redraw_tabline = true;\n}\n\n/// Get new filename ended by given extension.\n///\n/// @param fname        The original filename.\n///                     If NULL, use current directory name and ext to\n///                     compute new filename.\n/// @param ext          The extension to add to the filename.\n///                     4 chars max if prefixed with a dot, 3 otherwise.\n/// @param prepend_dot  If true, prefix ext with a dot.\n///                     Does nothing if ext already starts with a dot, or\n///                     if fname is NULL.\n///\n/// @return [allocated] - A new filename, made up from:\n///                       * fname + ext, if fname not NULL.\n///                       * current dir + ext, if fname is NULL.\n///                       Result is guaranteed to:\n///                       * be ended by <ext>.\n///                       * have a basename with at most BASENAMELEN chars:\n///                         original basename is truncated if necessary.\n///                       * be different than original: basename chars are\n///                         replaced by \"_\" if necessary. If that can't be done\n///                         because truncated value of original filename was\n///                         made of all underscores, replace first \"_\" by \"v\".\n///                     - NULL, if fname is NULL and there was a problem trying\n///                       to get current directory.\nchar *modname(const char *fname, const char *ext, bool prepend_dot)\n  FUNC_ATTR_NONNULL_ARG(2)\n{\n  char *retval;\n  size_t fnamelen;\n  size_t extlen = strlen(ext);\n\n  // If there is no file name we must get the name of the current directory\n  // (we need the full path in case :cd is used).\n  if (fname == NULL || *fname == NUL) {\n    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, \"_\" (Win), NUL\n    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL\n        || strlen(retval) == 0) {\n      xfree(retval);\n      return NULL;\n    }\n    add_pathsep(retval);\n    fnamelen = strlen(retval);\n    prepend_dot = FALSE;  // nothing to prepend a dot to\n  } else {\n    fnamelen = strlen(fname);\n    retval = xmalloc(fnamelen + extlen + 3);\n    strcpy(retval, fname);\n  }\n\n  // Search backwards until we hit a '/', '\\' or ':'.\n  // Then truncate what is after the '/', '\\' or ':' to BASENAMELEN characters.\n  char *ptr = NULL;\n  for (ptr = retval + fnamelen; ptr > retval; MB_PTR_BACK(retval, ptr)) {\n    if (vim_ispathsep(*ptr)) {\n      ptr++;\n      break;\n    }\n  }\n\n  // the file name has at most BASENAMELEN characters.\n  if (strlen(ptr) > BASENAMELEN) {\n    ptr[BASENAMELEN] = '\\0';\n  }\n\n  char *s;\n  s = ptr + strlen(ptr);\n\n  // Append the extension.\n  // ext can start with '.' and cannot exceed 3 more characters.\n  strcpy(s, ext);\n\n  char *e;\n  // Prepend the dot if needed.\n  if (prepend_dot && *(e = (char *)path_tail((char_u *)retval)) != '.') {\n    STRMOVE(e + 1, e);\n    *e = '.';\n  }\n\n  // Check that, after appending the extension, the file name is really\n  // different.\n  if (fname != NULL && strcmp(fname, retval) == 0) {\n    // we search for a character that can be replaced by '_'\n    while (--s >= ptr) {\n      if (*s != '_') {\n        *s = '_';\n        break;\n      }\n    }\n    if (s < ptr) {  // fname was \"________.<ext>\", how tricky!\n      *ptr = 'v';\n    }\n  }\n  return retval;\n}\n\n/// Like fgets(), but if the file line is too long, it is truncated and the\n/// rest of the line is thrown away.\n///\n/// @param[out] buf buffer to fill\n/// @param size size of the buffer\n/// @param fp file to read from\n///\n/// @return true for EOF or error\nbool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL\n{\n  char *retval;\n\n  assert(size > 0);\n  buf[size - 2] = NUL;\n\n  do {\n    errno = 0;\n    retval = fgets((char *)buf, size, fp);\n  } while (retval == NULL && errno == EINTR && ferror(fp));\n\n  if (buf[size - 2] != NUL && buf[size - 2] != '\\n') {\n    char tbuf[200];\n\n    buf[size - 1] = NUL;  // Truncate the line.\n\n    // Now throw away the rest of the line:\n    do {\n      tbuf[sizeof(tbuf) - 2] = NUL;\n      errno = 0;\n      retval = fgets((char *)tbuf, sizeof(tbuf), fp);\n      if (retval == NULL && (feof(fp) || errno != EINTR)) {\n        break;\n      }\n    } while (tbuf[sizeof(tbuf) - 2] != NUL && tbuf[sizeof(tbuf) - 2] != '\\n');\n  }\n  return retval == NULL;\n}\n\n/// Read 2 bytes from \"fd\" and turn them into an int, MSB first.\n/// Returns -1 when encountering EOF.\nint get2c(FILE *fd)\n{\n  const int n = getc(fd);\n  if (n == EOF) {\n    return -1;\n  }\n  const int c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  return (n << 8) + c;\n}\n\n/// Read 3 bytes from \"fd\" and turn them into an int, MSB first.\n/// Returns -1 when encountering EOF.\nint get3c(FILE *fd)\n{\n  int n = getc(fd);\n  if (n == EOF) {\n    return -1;\n  }\n  int c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  n = (n << 8) + c;\n  c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  return (n << 8) + c;\n}\n\n/// Read 4 bytes from \"fd\" and turn them into an int, MSB first.\n/// Returns -1 when encountering EOF.\nint get4c(FILE *fd)\n{\n  // Use unsigned rather than int otherwise result is undefined\n  // when left-shift sets the MSB.\n  unsigned n;\n\n  int c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  n = (unsigned)c;\n  c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  n = (n << 8) + (unsigned)c;\n  c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  n = (n << 8) + (unsigned)c;\n  c = getc(fd);\n  if (c == EOF) {\n    return -1;\n  }\n  n = (n << 8) + (unsigned)c;\n  return (int)n;\n}\n\n/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.\n/// Returns -1 when encountering EOF.\ntime_t get8ctime(FILE *fd)\n{\n  time_t n = 0;\n\n  for (int i = 0; i < 8; i++) {\n    const int c = getc(fd);\n    if (c == EOF) {\n      return -1;\n    }\n    n = (n << 8) + c;\n  }\n  return n;\n}\n\n/// Reads a string of length \"cnt\" from \"fd\" into allocated memory.\n/// @return pointer to the string or NULL when unable to read that many bytes.\nchar *read_string(FILE *fd, size_t cnt)\n{\n  char *str = xmallocz(cnt);\n  for (size_t i = 0; i < cnt; i++) {\n    int c = getc(fd);\n    if (c == EOF) {\n      xfree(str);\n      return NULL;\n    }\n    str[i] = (char)c;\n  }\n  return str;\n}\n\n/// Writes a number to file \"fd\", most significant bit first, in \"len\" bytes.\n/// @returns false in case of an error.\nbool put_bytes(FILE *fd, uintmax_t number, size_t len)\n{\n  assert(len > 0);\n  for (size_t i = len - 1; i < len; i--) {\n    if (putc((int)(number >> (i * 8)), fd) == EOF) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Writes time_t to file \"fd\" in 8 bytes.\n/// @returns FAIL when the write failed.\nint put_time(FILE *fd, time_t time_)\n{\n  uint8_t buf[8];\n  time_to_bytes(time_, buf);\n  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;\n}\n\n/// os_rename() only works if both files are on the same file system, this\n/// function will (attempts to?) copy the file across if rename fails -- webb\n///\n/// @return -1 for failure, 0 for success\nint vim_rename(const char_u *from, const char_u *to)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int fd_in;\n  int fd_out;\n  int n;\n  char        *errmsg = NULL;\n  char        *buffer;\n  long perm;\n#ifdef HAVE_ACL\n  vim_acl_T acl;                /* ACL from original file */\n#endif\n  bool use_tmp_file = false;\n\n  /*\n   * When the names are identical, there is nothing to do.  When they refer\n   * to the same file (ignoring case and slash/backslash differences) but\n   * the file name differs we need to go through a temp file.\n   */\n  if (fnamecmp(from, to) == 0) {\n    if (p_fic && (STRCMP(path_tail((char_u *)from), path_tail((char_u *)to))\n                  != 0)) {\n      use_tmp_file = true;\n    } else {\n      return 0;\n    }\n  }\n\n  // Fail if the \"from\" file doesn't exist. Avoids that \"to\" is deleted.\n  FileInfo from_info;\n  if (!os_fileinfo((char *)from, &from_info)) {\n    return -1;\n  }\n\n  // It's possible for the source and destination to be the same file.\n  // This happens when \"from\" and \"to\" differ in case and are on a FAT32\n  // filesystem. In that case go through a temp file name.\n  FileInfo to_info;\n  if (os_fileinfo((char *)to, &to_info)\n      && os_fileinfo_id_equal(&from_info,  &to_info)) {\n    use_tmp_file = true;\n  }\n\n  if (use_tmp_file) {\n    char_u tempname[MAXPATHL + 1];\n\n    /*\n     * Find a name that doesn't exist and is in the same directory.\n     * Rename \"from\" to \"tempname\" and then rename \"tempname\" to \"to\".\n     */\n    if (STRLEN(from) >= MAXPATHL - 5)\n      return -1;\n    STRCPY(tempname, from);\n    for (n = 123; n < 99999; n++) {\n      char * tail = (char *)path_tail(tempname);\n      snprintf(tail, (MAXPATHL + 1) - (tail - (char *)tempname - 1), \"%d\", n);\n\n      if (!os_path_exists(tempname)) {\n        if (os_rename(from, tempname) == OK) {\n          if (os_rename(tempname, to) == OK) {\n            return 0;\n          }\n          // Strange, the second step failed.  Try moving the\n          // file back and return failure.\n          (void)os_rename(tempname, from);\n          return -1;\n        }\n        /* If it fails for one temp name it will most likely fail\n         * for any temp name, give up. */\n        return -1;\n      }\n    }\n    return -1;\n  }\n\n  /*\n   * Delete the \"to\" file, this is required on some systems to make the\n   * os_rename() work, on other systems it makes sure that we don't have\n   * two files when the os_rename() fails.\n   */\n\n  os_remove((char *)to);\n\n  /*\n   * First try a normal rename, return if it works.\n   */\n  if (os_rename(from, to) == OK)\n    return 0;\n\n  /*\n   * Rename() failed, try copying the file.\n   */\n  perm = os_getperm((const char *)from);\n#ifdef HAVE_ACL\n  // For systems that support ACL: get the ACL from the original file.\n  acl = mch_get_acl(from);\n#endif\n  fd_in = os_open((char *)from, O_RDONLY, 0);\n  if (fd_in < 0) {\n#ifdef HAVE_ACL\n    mch_free_acl(acl);\n#endif\n    return -1;\n  }\n\n  /* Create the new file with same permissions as the original. */\n  fd_out = os_open((char *)to,\n      O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);\n  if (fd_out < 0) {\n    close(fd_in);\n#ifdef HAVE_ACL\n    mch_free_acl(acl);\n#endif\n    return -1;\n  }\n\n  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim\n  // is `preserve_exit()`ing.\n  buffer = try_malloc(BUFSIZE);\n  if (buffer == NULL) {\n    close(fd_out);\n    close(fd_in);\n#ifdef HAVE_ACL\n    mch_free_acl(acl);\n#endif\n    return -1;\n  }\n\n  while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)\n    if (write_eintr(fd_out, buffer, n) != n) {\n      errmsg = _(\"E208: Error writing to \\\"%s\\\"\");\n      break;\n    }\n\n  xfree(buffer);\n  close(fd_in);\n  if (close(fd_out) < 0)\n    errmsg = _(\"E209: Error closing \\\"%s\\\"\");\n  if (n < 0) {\n    errmsg = _(\"E210: Error reading \\\"%s\\\"\");\n    to = from;\n  }\n#ifndef UNIX  // For Unix os_open() already set the permission.\n  os_setperm((const char *)to, perm);\n#endif\n#ifdef HAVE_ACL\n  mch_set_acl(to, acl);\n  mch_free_acl(acl);\n#endif\n  if (errmsg != NULL) {\n    EMSG2(errmsg, to);\n    return -1;\n  }\n  os_remove((char *)from);\n  return 0;\n}\n\nstatic int already_warned = FALSE;\n\n// Check if any not hidden buffer has been changed.\n// Postpone the check if there are characters in the stuff buffer, a global\n// command is being executed, a mapping is being executed or an autocommand is\n// busy.\n// Returns TRUE if some message was written (screen should be redrawn and\n// cursor positioned).\nint\ncheck_timestamps(\n    int focus                      // called for GUI focus event\n)\n{\n  int didit = 0;\n\n  /* Don't check timestamps while system() or another low-level function may\n   * cause us to lose and gain focus. */\n  if (no_check_timestamps > 0)\n    return FALSE;\n\n  /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus\n   * event and we would keep on checking if the file is steadily growing.\n   * Do check again after typing something. */\n  if (focus && did_check_timestamps) {\n    need_check_timestamps = TRUE;\n    return FALSE;\n  }\n\n  if (!stuff_empty() || global_busy || !typebuf_typed()\n      || autocmd_busy || curbuf->b_ro_locked > 0 || allbuf_lock > 0\n      ) {\n    need_check_timestamps = true;               // check later\n  } else {\n    no_wait_return++;\n    did_check_timestamps = true;\n    already_warned = false;\n    FOR_ALL_BUFFERS(buf) {\n      // Only check buffers in a window.\n      if (buf->b_nwindows > 0) {\n        bufref_T bufref;\n        set_bufref(&bufref, buf);\n        const int n = buf_check_timestamp(buf);\n        if (didit < n) {\n          didit = n;\n        }\n        if (n > 0 && !bufref_valid(&bufref)) {\n          // Autocommands have removed the buffer, start at the first one again.\n          buf = firstbuf;\n          continue;\n        }\n      }\n    }\n    --no_wait_return;\n    need_check_timestamps = FALSE;\n    if (need_wait_return && didit == 2) {\n      // make sure msg isn't overwritten\n      msg_puts(\"\\n\");\n      ui_flush();\n    }\n  }\n  return didit;\n}\n\n/*\n * Move all the lines from buffer \"frombuf\" to buffer \"tobuf\".\n * Return OK or FAIL.  When FAIL \"tobuf\" is incomplete and/or \"frombuf\" is not\n * empty.\n */\nstatic int move_lines(buf_T *frombuf, buf_T *tobuf)\n{\n  buf_T       *tbuf = curbuf;\n  int retval = OK;\n  linenr_T lnum;\n  char_u      *p;\n\n  /* Copy the lines in \"frombuf\" to \"tobuf\". */\n  curbuf = tobuf;\n  for (lnum = 1; lnum <= frombuf->b_ml.ml_line_count; lnum++) {\n    p = vim_strsave(ml_get_buf(frombuf, lnum, false));\n    if (ml_append(lnum - 1, p, 0, false) == FAIL) {\n      xfree(p);\n      retval = FAIL;\n      break;\n    }\n    xfree(p);\n  }\n\n  /* Delete all the lines in \"frombuf\". */\n  if (retval != FAIL) {\n    curbuf = frombuf;\n    for (lnum = curbuf->b_ml.ml_line_count; lnum > 0; lnum--) {\n      if (ml_delete(lnum, false) == FAIL) {\n        // Oops!  We could try putting back the saved lines, but that\n        // might fail again...\n        retval = FAIL;\n        break;\n      }\n    }\n  }\n\n  curbuf = tbuf;\n  return retval;\n}\n\n/*\n * Check if buffer \"buf\" has been changed.\n * Also check if the file for a new buffer unexpectedly appeared.\n * return 1 if a changed buffer was found.\n * return 2 if a message has been displayed.\n * return 0 otherwise.\n */\nint buf_check_timestamp(buf_T *buf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int retval = 0;\n  char_u      *path;\n  char        *mesg = NULL;\n  char        *mesg2 = \"\";\n  bool helpmesg = false;\n  bool reload = false;\n  bool can_reload = false;\n  uint64_t orig_size = buf->b_orig_size;\n  int orig_mode = buf->b_orig_mode;\n  static bool busy = false;\n  char_u      *s;\n  char        *reason;\n\n  bufref_T bufref;\n  set_bufref(&bufref, buf);\n\n  // If its a terminal, there is no file name, the buffer is not loaded,\n  // 'buftype' is set, we are in the middle of a save or being called\n  // recursively: ignore this buffer.\n  if (buf->terminal\n      || buf->b_ffname == NULL\n      || buf->b_ml.ml_mfp == NULL\n      || !bt_normal(buf)\n      || buf->b_saving\n      || busy\n      )\n    return 0;\n\n  FileInfo file_info;\n  bool file_info_ok;\n  if (!(buf->b_flags & BF_NOTEDITED)\n      && buf->b_mtime != 0\n      && (!(file_info_ok = os_fileinfo((char *)buf->b_ffname, &file_info))\n          || time_differs(file_info.stat.st_mtim.tv_sec, buf->b_mtime)\n          || (int)file_info.stat.st_mode != buf->b_orig_mode)) {\n    const long prev_b_mtime = buf->b_mtime;\n\n    retval = 1;\n\n    // set b_mtime to stop further warnings (e.g., when executing\n    // FileChangedShell autocmd)\n    if (!file_info_ok) {\n      // Check the file again later to see if it re-appears.\n      buf->b_mtime = -1;\n      buf->b_orig_size = 0;\n      buf->b_orig_mode = 0;\n    } else {\n      buf_store_file_info(buf, &file_info);\n    }\n\n    /* Don't do anything for a directory.  Might contain the file\n     * explorer. */\n    if (os_isdir(buf->b_fname)) {\n    } else if ((buf->b_p_ar >= 0 ? buf->b_p_ar : p_ar)\n               && !bufIsChanged(buf) && file_info_ok) {\n      // If 'autoread' is set, the buffer has no changes and the file still\n      // exists, reload the buffer.  Use the buffer-local option value if it\n      // was set, the global option value otherwise.\n      reload = true;\n    } else {\n      if (!file_info_ok) {\n        reason = \"deleted\";\n      } else if (bufIsChanged(buf)) {\n        reason = \"conflict\";\n      } else if (orig_size != buf->b_orig_size || buf_contents_changed(buf)) {\n        reason = \"changed\";\n      } else if (orig_mode != buf->b_orig_mode) {\n        reason = \"mode\";\n      } else {\n        reason = \"time\";\n      }\n\n      // Only give the warning if there are no FileChangedShell\n      // autocommands.\n      // Avoid being called recursively by setting \"busy\".\n      busy = true;\n      set_vim_var_string(VV_FCS_REASON, reason, -1);\n      set_vim_var_string(VV_FCS_CHOICE, \"\", -1);\n      allbuf_lock++;\n      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL,\n                              buf->b_fname, buf->b_fname, false, buf);\n      allbuf_lock--;\n      busy = false;\n      if (n) {\n        if (!bufref_valid(&bufref)) {\n          EMSG(_(\"E246: FileChangedShell autocommand deleted buffer\"));\n        }\n        s = get_vim_var_str(VV_FCS_CHOICE);\n        if (STRCMP(s, \"reload\") == 0 && *reason != 'd') {\n          reload = true;\n        } else if (STRCMP(s, \"ask\") == 0) {\n          n = false;\n        } else {\n          return 2;\n        }\n      }\n      if (!n) {\n        if (*reason == 'd') {\n          // Only give the message once.\n          if (prev_b_mtime != -1) {\n            mesg = _(\"E211: File \\\"%s\\\" no longer available\");\n          }\n        } else {\n          helpmesg = true;\n          can_reload = true;\n\n          // Check if the file contents really changed to avoid\n          // giving a warning when only the timestamp was set (e.g.,\n          // checked out of CVS).  Always warn when the buffer was\n          // changed.\n          if (reason[2] == 'n') {\n            mesg = _(\n                \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");\n            mesg2 = _(\"See \\\":help W12\\\" for more info.\");\n          } else if (reason[1] == 'h') {\n            mesg = _(\n                \"W11: Warning: File \\\"%s\\\" has changed since editing started\");\n            mesg2 = _(\"See \\\":help W11\\\" for more info.\");\n          } else if (*reason == 'm') {\n            mesg = _(\n                \"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");\n            mesg2 = _(\"See \\\":help W16\\\" for more info.\");\n          } else\n            /* Only timestamp changed, store it to avoid a warning\n             * in check_mtime() later. */\n            buf->b_mtime_read = buf->b_mtime;\n        }\n      }\n    }\n\n  } else if ((buf->b_flags & BF_NEW) && !(buf->b_flags & BF_NEW_W)\n             && os_path_exists(buf->b_ffname)) {\n    retval = 1;\n    mesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");\n    buf->b_flags |= BF_NEW_W;\n    can_reload = true;\n  }\n\n  if (mesg != NULL) {\n    path = home_replace_save(buf, buf->b_fname);\n    if (!helpmesg) {\n      mesg2 = \"\";\n    }\n    const size_t tbuf_len = STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2;\n    char *const tbuf = xmalloc(tbuf_len);\n    snprintf(tbuf, tbuf_len, mesg, path);\n    // Set warningmsg here, before the unimportant and output-specific\n    // mesg2 has been appended.\n    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);\n    if (can_reload) {\n      if (*mesg2 != NUL) {\n        xstrlcat(tbuf, \"\\n\", tbuf_len - 1);\n        xstrlcat(tbuf, mesg2, tbuf_len - 1);\n      }\n      if (do_dialog(VIM_WARNING, (char_u *) _(\"Warning\"), (char_u *) tbuf,\n                    (char_u *) _(\"&OK\\n&Load File\"), 1, NULL, true) == 2) {\n        reload = true;\n      }\n    } else if (State > NORMAL_BUSY || (State & CMDLINE) || already_warned) {\n      if (*mesg2 != NUL) {\n        xstrlcat(tbuf, \"; \", tbuf_len - 1);\n        xstrlcat(tbuf, mesg2, tbuf_len - 1);\n      }\n      EMSG(tbuf);\n      retval = 2;\n    } else {\n      if (!autocmd_busy) {\n        msg_start();\n        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);\n        if (*mesg2 != NUL) {\n          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);\n        }\n        msg_clr_eos();\n        (void)msg_end();\n        if (emsg_silent == 0) {\n          ui_flush();\n          // give the user some time to think about it\n          os_delay(1004L, true);\n\n          // don't redraw and erase the message\n          redraw_cmdline = false;\n        }\n      }\n      already_warned = TRUE;\n    }\n\n    xfree(path);\n    xfree(tbuf);\n  }\n\n  if (reload) {\n    /* Reload the buffer. */\n    buf_reload(buf, orig_mode);\n    if (buf->b_p_udf && buf->b_ffname != NULL) {\n      char_u hash[UNDO_HASH_SIZE];\n\n      // Any existing undo file is unusable, write it now.\n      u_compute_hash(buf, hash);\n      u_write_undo(NULL, false, buf, hash);\n    }\n  }\n\n  // Trigger FileChangedShell when the file was changed in any way.\n  if (bufref_valid(&bufref) && retval != 0) {\n    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf->b_fname, buf->b_fname,\n                         false, buf);\n  }\n  return retval;\n}\n\n/*\n * Reload a buffer that is already loaded.\n * Used when the file was changed outside of Vim.\n * \"orig_mode\" is buf->b_orig_mode before the need for reloading was detected.\n * buf->b_orig_mode may have been reset already.\n */\nvoid buf_reload(buf_T *buf, int orig_mode)\n{\n  exarg_T ea;\n  pos_T old_cursor;\n  linenr_T old_topline;\n  int old_ro = buf->b_p_ro;\n  buf_T       *savebuf;\n  bufref_T bufref;\n  int saved = OK;\n  aco_save_T aco;\n  int flags = READ_NEW;\n\n  /* set curwin/curbuf for \"buf\" and save some things */\n  aucmd_prepbuf(&aco, buf);\n\n  // We only want to read the text from the file, not reset the syntax\n  // highlighting, clear marks, diff status, etc.  Force the fileformat and\n  // encoding to be the same.\n\n  prep_exarg(&ea, buf);\n  old_cursor = curwin->w_cursor;\n  old_topline = curwin->w_topline;\n\n  if (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur) {\n    // Save all the text, so that the reload can be undone.\n    // Sync first so that this is a separate undo-able action.\n    u_sync(false);\n    saved = u_savecommon(curbuf, 0, curbuf->b_ml.ml_line_count + 1, 0, true);\n    flags |= READ_KEEP_UNDO;\n  }\n\n  // To behave like when a new file is edited (matters for\n  // BufReadPost autocommands) we first need to delete the current\n  // buffer contents.  But if reading the file fails we should keep\n  // the old contents.  Can't use memory only, the file might be\n  // too big.  Use a hidden buffer to move the buffer contents to.\n  if (buf_is_empty(curbuf) || saved == FAIL) {\n    savebuf = NULL;\n  } else {\n    // Allocate a buffer without putting it in the buffer list.\n    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    set_bufref(&bufref, savebuf);\n    if (savebuf != NULL && buf == curbuf) {\n      /* Open the memline. */\n      curbuf = savebuf;\n      curwin->w_buffer = savebuf;\n      saved = ml_open(curbuf);\n      curbuf = buf;\n      curwin->w_buffer = buf;\n    }\n    if (savebuf == NULL || saved == FAIL || buf != curbuf\n        || move_lines(buf, savebuf) == FAIL) {\n      EMSG2(_(\"E462: Could not prepare for reloading \\\"%s\\\"\"),\n          buf->b_fname);\n      saved = FAIL;\n    }\n  }\n\n  if (saved == OK) {\n    curbuf->b_flags |= BF_CHECK_RO;           // check for RO again\n    keep_filetype = true;                     // don't detect 'filetype'\n    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0, (linenr_T)0,\n                 (linenr_T)MAXLNUM, &ea, flags) != OK) {\n      if (!aborting()) {\n        EMSG2(_(\"E321: Could not reload \\\"%s\\\"\"), buf->b_fname);\n      }\n      if (savebuf != NULL && bufref_valid(&bufref) && buf == curbuf) {\n        // Put the text back from the save buffer.  First\n        // delete any lines that readfile() added.\n        while (!buf_is_empty(curbuf)) {\n          if (ml_delete(buf->b_ml.ml_line_count, false) == FAIL) {\n            break;\n          }\n        }\n        (void)move_lines(savebuf, buf);\n      }\n    } else if (buf == curbuf) {  // \"buf\" still valid.\n      // Mark the buffer as unmodified and free undo info.\n      unchanged(buf, true, true);\n      if ((flags & READ_KEEP_UNDO) == 0) {\n        u_blockfree(buf);\n        u_clearall(buf);\n      } else {\n        // Mark all undo states as changed.\n        u_unchanged(curbuf);\n      }\n      buf_updates_unload(curbuf, true);\n      curbuf->b_mod_set = true;\n    }\n  }\n  xfree(ea.cmd);\n\n  if (savebuf != NULL && bufref_valid(&bufref)) {\n    wipe_buffer(savebuf, false);\n  }\n\n  /* Invalidate diff info if necessary. */\n  diff_invalidate(curbuf);\n\n  /* Restore the topline and cursor position and check it (lines may\n   * have been removed). */\n  if (old_topline > curbuf->b_ml.ml_line_count)\n    curwin->w_topline = curbuf->b_ml.ml_line_count;\n  else\n    curwin->w_topline = old_topline;\n  curwin->w_cursor = old_cursor;\n  check_cursor();\n  update_topline(curwin);\n  keep_filetype = false;\n\n  /* Update folds unless they are defined manually. */\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_buffer == curwin->w_buffer\n        && !foldmethodIsManual(wp)) {\n      foldUpdateAll(wp);\n    }\n  }\n\n  /* If the mode didn't change and 'readonly' was set, keep the old\n   * value; the user probably used the \":view\" command.  But don't\n   * reset it, might have had a read error. */\n  if (orig_mode == curbuf->b_orig_mode)\n    curbuf->b_p_ro |= old_ro;\n\n  /* Modelines must override settings done by autocommands. */\n  do_modelines(0);\n\n  /* restore curwin/curbuf and a few other things */\n  aucmd_restbuf(&aco);\n  /* Careful: autocommands may have made \"buf\" invalid! */\n}\n\nvoid buf_store_file_info(buf_T *buf, FileInfo *file_info)\n  FUNC_ATTR_NONNULL_ALL\n{\n  buf->b_mtime = file_info->stat.st_mtim.tv_sec;\n  buf->b_orig_size = os_fileinfo_size(file_info);\n  buf->b_orig_mode = (int)file_info->stat.st_mode;\n}\n\n/*\n * Adjust the line with missing eol, used for the next write.\n * Used for do_filter(), when the input lines for the filter are deleted.\n */\nvoid write_lnum_adjust(linenr_T offset)\n{\n  if (curbuf->b_no_eol_lnum != 0)       /* only if there is a missing eol */\n    curbuf->b_no_eol_lnum += offset;\n}\n\n#if defined(BACKSLASH_IN_FILENAME)\n/// Convert all backslashes in fname to forward slashes in-place,\n/// unless when it looks like a URL.\nvoid forward_slash(char_u *fname)\n{\n  char_u      *p;\n\n  if (path_with_url((const char *)fname)) {\n    return;\n  }\n  for (p = fname; *p != NUL; p++) {\n    // The Big5 encoding can have '\\' in the trail byte.\n    if (*p == '\\\\') {\n      *p = '/';\n    }\n  }\n}\n#endif\n\n/// Name of Vim's own temp dir. Ends in a slash.\nstatic char_u *vim_tempdir = NULL;\n\n/// Create a directory for private use by this instance of Neovim.\n/// This is done once, and the same directory is used for all temp files.\n/// This method avoids security problems because of symlink attacks et al.\n/// It's also a bit faster, because we only need to check for an existing\n/// file when creating the directory and not for each temp file.\nstatic void vim_maketempdir(void)\n{\n  static const char *temp_dirs[] = TEMP_DIR_NAMES;\n  // Try the entries in `TEMP_DIR_NAMES` to create the temp directory.\n  char_u template[TEMP_FILE_PATH_MAXLEN];\n  char_u path[TEMP_FILE_PATH_MAXLEN];\n\n  // Make sure the umask doesn't remove the executable bit.\n  // \"repl\" has been reported to use \"0177\".\n  mode_t umask_save = umask(0077);\n  for (size_t i = 0; i < ARRAY_SIZE(temp_dirs); i++) {\n    // Expand environment variables, leave room for \"/nvimXXXXXX/999999999\"\n    expand_env((char_u *)temp_dirs[i], template, TEMP_FILE_PATH_MAXLEN - 22);\n    if (!os_isdir(template)) {  // directory doesn't exist\n      continue;\n    }\n\n    add_pathsep((char *)template);\n    // Concatenate with temporary directory name pattern\n    STRCAT(template, \"nvimXXXXXX\");\n\n    if (os_mkdtemp((const char *)template, (char *)path) != 0) {\n      continue;\n    }\n\n    if (vim_settempdir((char *)path)) {\n      // Successfully created and set temporary directory so stop trying.\n      break;\n    } else {\n      // Couldn't set `vim_tempdir` to `path` so remove created directory.\n      os_rmdir((char *)path);\n    }\n  }\n  (void)umask(umask_save);\n}\n\n/// Delete \"name\" and everything in it, recursively.\n/// @param name The path which should be deleted.\n/// @return 0 for success, -1 if some file was not deleted.\nint delete_recursive(const char *name)\n{\n  int result = 0;\n\n  if (os_isrealdir(name)) {\n    snprintf((char *)NameBuff, MAXPATHL, \"%s/*\", name);  // NOLINT\n\n    char_u **files;\n    int file_count;\n    char_u *exp = vim_strsave(NameBuff);\n    if (gen_expand_wildcards(1, &exp, &file_count, &files,\n                             EW_DIR | EW_FILE | EW_SILENT | EW_ALLLINKS\n                             | EW_DODOT | EW_EMPTYOK) == OK) {\n      for (int i = 0; i < file_count; i++) {\n        if (delete_recursive((const char *)files[i]) != 0) {\n          result = -1;\n        }\n      }\n      FreeWild(file_count, files);\n    } else {\n      result = -1;\n    }\n\n    xfree(exp);\n    os_rmdir(name);\n  } else {\n    result = os_remove(name) == 0 ? 0 : -1;\n  }\n\n  return result;\n}\n\n/// Delete the temp directory and all files it contains.\nvoid vim_deltempdir(void)\n{\n  if (vim_tempdir != NULL) {\n    // remove the trailing path separator\n    path_tail(vim_tempdir)[-1] = NUL;\n    delete_recursive((const char *)vim_tempdir);\n    XFREE_CLEAR(vim_tempdir);\n  }\n}\n\n/// Get the name of temp directory. This directory would be created on the first\n/// call to this function.\nchar_u *vim_gettempdir(void)\n{\n  if (vim_tempdir == NULL) {\n    vim_maketempdir();\n  }\n\n  return vim_tempdir;\n}\n\n/// Set Neovim own temporary directory name to `tempdir`. This directory should\n/// be already created. Expand this name to a full path and put it in\n/// `vim_tempdir`. This avoids that using `:cd` would confuse us.\n///\n/// @param tempdir must be no longer than MAXPATHL.\n///\n/// @return false if we run out of memory.\nstatic bool vim_settempdir(char *tempdir)\n{\n  char *buf = verbose_try_malloc(MAXPATHL + 2);\n  if (!buf) {\n    return false;\n  }\n  vim_FullName(tempdir, buf, MAXPATHL, false);\n  add_pathsep(buf);\n  vim_tempdir = (char_u *)xstrdup(buf);\n  xfree(buf);\n  return true;\n}\n\n/// Return a unique name that can be used for a temp file.\n///\n/// @note The temp file is NOT created.\n///\n/// @return pointer to the temp file name or NULL if Neovim can't create\n///         temporary directory for its own temporary files.\nchar_u *vim_tempname(void)\n{\n  // Temp filename counter.\n  static uint64_t temp_count;\n\n  char_u *tempdir = vim_gettempdir();\n  if (!tempdir) {\n    return NULL;\n  }\n\n  // There is no need to check if the file exists, because we own the directory\n  // and nobody else creates a file in it.\n  char_u template[TEMP_FILE_PATH_MAXLEN];\n  snprintf((char *)template, TEMP_FILE_PATH_MAXLEN,\n           \"%s%\" PRIu64, tempdir, temp_count++);\n  return vim_strsave(template);\n}\n\n\n\n/// Tries matching a filename with a \"pattern\" (\"prog\" is NULL), or use the\n/// precompiled regprog \"prog\" (\"pattern\" is NULL).  That avoids calling\n/// vim_regcomp() often.\n///\n/// Used for autocommands and 'wildignore'.\n///\n/// @param pattern pattern to match with\n/// @param prog pre-compiled regprog or NULL\n/// @param fname full path of the file name\n/// @param sfname short file name or NULL\n/// @param tail tail of the path\n/// @param allow_dirs Allow matching with dir\n///\n/// @return true if there is a match, false otherwise\nbool match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname,\n                    char_u *sfname, char_u *tail, int allow_dirs)\n{\n  regmatch_T regmatch;\n  bool result = false;\n\n  regmatch.rm_ic = p_fic;   /* ignore case if 'fileignorecase' is set */\n  {\n    if (prog != NULL)\n      regmatch.regprog = *prog;\n    else\n      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);\n  }\n\n  /*\n   * Try for a match with the pattern with:\n   * 1. the full file name, when the pattern has a '/'.\n   * 2. the short file name, when the pattern has a '/'.\n   * 3. the tail of the file name, when the pattern has no '/'.\n   */\n  if (regmatch.regprog != NULL\n      && ((allow_dirs\n           && (vim_regexec(&regmatch, fname, (colnr_T)0)\n               || (sfname != NULL\n                   && vim_regexec(&regmatch, sfname, (colnr_T)0))))\n          || (!allow_dirs && vim_regexec(&regmatch, tail, (colnr_T)0)))) {\n    result = true;\n  }\n\n  if (prog != NULL) {\n    *prog = regmatch.regprog;\n  } else {\n    vim_regfree(regmatch.regprog);\n  }\n  return result;\n}\n\n/// Check if a file matches with a pattern in \"list\".\n/// \"list\" is a comma-separated list of patterns, like 'wildignore'.\n/// \"sfname\" is the short file name or NULL, \"ffname\" the long file name.\n///\n/// @param list list of patterns to match\n/// @param sfname short file name\n/// @param ffname full file name\n///\n/// @return true if there was a match\nbool match_file_list(char_u *list, char_u *sfname, char_u *ffname)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)\n{\n  char_u buf[100];\n  char_u      *tail;\n  char_u      *regpat;\n  char allow_dirs;\n  bool match;\n  char_u      *p;\n\n  tail = path_tail(sfname);\n\n  // try all patterns in 'wildignore'\n  p = list;\n  while (*p) {\n    copy_option_part(&p, buf, ARRAY_SIZE(buf), \",\");\n    regpat = file_pat_to_reg_pat(buf, NULL, &allow_dirs, false);\n    if (regpat == NULL) {\n      break;\n    }\n    match = match_file_pat(regpat, NULL, ffname, sfname, tail, (int)allow_dirs);\n    xfree(regpat);\n    if (match) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Convert the given pattern \"pat\" which has shell style wildcards in it, into\n/// a regular expression, and return the result in allocated memory.  If there\n/// is a directory path separator to be matched, then TRUE is put in\n/// allow_dirs, otherwise FALSE is put there -- webb.\n/// Handle backslashes before special characters, like \"\\*\" and \"\\ \".\n///\n/// Returns NULL on failure.\nchar_u * file_pat_to_reg_pat(\n    const char_u *pat,\n    const char_u *pat_end,   // first char after pattern or NULL\n    char *allow_dirs,        // Result passed back out in here\n    int no_bslash            // Don't use a backward slash as pathsep\n)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  const char_u *endp;\n  char_u      *reg_pat;\n  const char_u *p;\n  int nested = 0;\n  int add_dollar = TRUE;\n\n  if (allow_dirs != NULL)\n    *allow_dirs = FALSE;\n  if (pat_end == NULL)\n    pat_end = pat + STRLEN(pat);\n\n  if (pat_end == pat) {\n    return (char_u *)xstrdup(\"^$\");\n  }\n\n  size_t size = 2;  // '^' at start, '$' at end.\n\n  for (p = pat; p < pat_end; p++) {\n    switch (*p) {\n    case '*':\n    case '.':\n    case ',':\n    case '{':\n    case '}':\n    case '~':\n      size += 2;                /* extra backslash */\n      break;\n#ifdef BACKSLASH_IN_FILENAME\n    case '\\\\':\n    case '/':\n      size += 4;                /* could become \"[\\/]\" */\n      break;\n#endif\n    default:\n      size++;\n      break;\n    }\n  }\n  reg_pat = xmalloc(size + 1);\n\n  size_t i = 0;\n\n  if (pat[0] == '*')\n    while (pat[0] == '*' && pat < pat_end - 1)\n      pat++;\n  else\n    reg_pat[i++] = '^';\n  endp = pat_end - 1;\n  if (endp >= pat && *endp == '*') {\n    while (endp - pat > 0 && *endp == '*') {\n      endp--;\n    }\n    add_dollar = false;\n  }\n  for (p = pat; *p && nested >= 0 && p <= endp; p++) {\n    switch (*p) {\n    case '*':\n      reg_pat[i++] = '.';\n      reg_pat[i++] = '*';\n      while (p[1] == '*')               /* \"**\" matches like \"*\" */\n        ++p;\n      break;\n    case '.':\n    case '~':\n      reg_pat[i++] = '\\\\';\n      reg_pat[i++] = *p;\n      break;\n    case '?':\n      reg_pat[i++] = '.';\n      break;\n    case '\\\\':\n      if (p[1] == NUL)\n        break;\n#ifdef BACKSLASH_IN_FILENAME\n      if (!no_bslash) {\n        /* translate:\n         * \"\\x\" to \"\\\\x\"  e.g., \"dir\\file\"\n         * \"\\*\" to \"\\\\.*\" e.g., \"dir\\*.c\"\n         * \"\\?\" to \"\\\\.\"  e.g., \"dir\\??.c\"\n         * \"\\+\" to \"\\+\"   e.g., \"fileX\\+.c\"\n         */\n        if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')\n            && p[1] != '+') {\n          reg_pat[i++] = '[';\n          reg_pat[i++] = '\\\\';\n          reg_pat[i++] = '/';\n          reg_pat[i++] = ']';\n          if (allow_dirs != NULL)\n            *allow_dirs = TRUE;\n          break;\n        }\n      }\n#endif\n      /* Undo escaping from ExpandEscape():\n       * foo\\?bar -> foo?bar\n       * foo\\%bar -> foo%bar\n       * foo\\,bar -> foo,bar\n       * foo\\ bar -> foo bar\n       * Don't unescape \\, * and others that are also special in a\n       * regexp.\n       * An escaped { must be unescaped since we use magic not\n       * verymagic.  Use \"\\\\\\{n,m\\}\"\" to get \"\\{n,m}\".\n       */\n      if (*++p == '?'\n#ifdef BACKSLASH_IN_FILENAME\n          && no_bslash\n#endif\n          ) {\n        reg_pat[i++] = '?';\n      } else if (*p == ',' || *p == '%' || *p == '#'\n                 || ascii_isspace(*p) || *p == '{' || *p == '}') {\n        reg_pat[i++] = *p;\n      } else if (*p == '\\\\' && p[1] == '\\\\' && p[2] == '{') {\n        reg_pat[i++] = '\\\\';\n        reg_pat[i++] = '{';\n        p += 2;\n      } else {\n        if (allow_dirs != NULL && vim_ispathsep(*p)\n#ifdef BACKSLASH_IN_FILENAME\n            && (!no_bslash || *p != '\\\\')\n#endif\n            )\n          *allow_dirs = TRUE;\n        reg_pat[i++] = '\\\\';\n        reg_pat[i++] = *p;\n      }\n      break;\n#ifdef BACKSLASH_IN_FILENAME\n    case '/':\n      reg_pat[i++] = '[';\n      reg_pat[i++] = '\\\\';\n      reg_pat[i++] = '/';\n      reg_pat[i++] = ']';\n      if (allow_dirs != NULL)\n        *allow_dirs = TRUE;\n      break;\n#endif\n    case '{':\n      reg_pat[i++] = '\\\\';\n      reg_pat[i++] = '(';\n      nested++;\n      break;\n    case '}':\n      reg_pat[i++] = '\\\\';\n      reg_pat[i++] = ')';\n      --nested;\n      break;\n    case ',':\n      if (nested) {\n        reg_pat[i++] = '\\\\';\n        reg_pat[i++] = '|';\n      } else\n        reg_pat[i++] = ',';\n      break;\n    default:\n      if (allow_dirs != NULL && vim_ispathsep(*p)) {\n        *allow_dirs = true;\n      }\n      reg_pat[i++] = *p;\n      break;\n    }\n  }\n  if (add_dollar)\n    reg_pat[i++] = '$';\n  reg_pat[i] = NUL;\n  if (nested != 0) {\n    if (nested < 0) {\n      EMSG(_(\"E219: Missing {.\"));\n    } else {\n      EMSG(_(\"E220: Missing }.\"));\n    }\n    XFREE_CLEAR(reg_pat);\n  }\n  return reg_pat;\n}\n\n#if defined(EINTR)\n/*\n * Version of read() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\nlong read_eintr(int fd, void *buf, size_t bufsize)\n{\n  long ret;\n\n  for (;; ) {\n    ret = read(fd, buf, bufsize);\n    if (ret >= 0 || errno != EINTR)\n      break;\n  }\n  return ret;\n}\n\n/*\n * Version of write() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\nlong write_eintr(int fd, void *buf, size_t bufsize)\n{\n  long ret = 0;\n  long wlen;\n\n  /* Repeat the write() so long it didn't fail, other than being interrupted\n   * by a signal. */\n  while (ret < (long)bufsize) {\n    wlen = write(fd, (char *)buf + ret, bufsize - ret);\n    if (wlen < 0) {\n      if (errno != EINTR)\n        break;\n    } else\n      ret += wlen;\n  }\n  return ret;\n}\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 24, "file": 11, "line": 80}, "message": "( ) (fixit)"}, {"location": {"col": 24, "file": 11, "line": 80}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "9c44df839b6dcbe5257050c561abeadc", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 11, "line": 245}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "89bb6a92b220f8513b068696d0f7366b", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 11, "line": 430}, "message": "narrowing conversion from 'unsigned long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "a456cf8abd430385cd4a89c1e967a793", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 11, "line": 771}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "48f94ea5ec0c7955d40ee255a5737b9f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 11, "line": 774}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "a94aeb8f7f52f5873a53f3296a8e0a5f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 11, "line": 850}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "8584e691c433a02c2246fad73e5e91ee", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 11, "line": 875}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "eda30d8c741e46af38ef7907a24582a3", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 11, "line": 961}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "6493e1d32a328fc06682dab9889599f1", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 11, "line": 1053}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "6c7be3eea0c6334114c4f8f5512db360", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 68, "file": 11, "line": 1076}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "b43000ad87e9f8970cff3fe370d9a2fe", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 11, "line": 1086}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "7ef1d0c8128b90312aec99f1df7be23f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 11, "line": 1088}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "cfa944d61aed8939df6892a67683abbb", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 23, "file": 11, "line": 1157}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "4fec29ec8db49dd50a8df78c108cd8c5", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 11, "line": 1195}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "e527e525047e7128e619ec5d7310e867", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 1414}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "7635a70a06c73f17bc613c56ae4f47a5", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 44, "file": 11, "line": 1438}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "6efd6a985fb3f4ce5aca8c39456bf38a", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 11, "line": 1652}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "48f94ea5ec0c7955d40ee255a5737b9f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 11, "line": 2158}, "message": "(  ) (fixit)"}, {"location": {"col": 12, "file": 11, "line": 2158}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "ca546f79540bf7cd768704120a01d865", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 11, "line": 2158}, "message": "(  ) (fixit)"}, {"location": {"col": 26, "file": 11, "line": 2158}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "a61b80a921febd48577eb8c9a3b5a268", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 11, "line": 2160}, "message": "(  ) (fixit)"}, {"location": {"col": 27, "file": 11, "line": 2160}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "07614ef9ab26b6a53f735fc76164efae", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 11, "line": 2162}, "message": "(  ) (fixit)"}, {"location": {"col": 27, "file": 11, "line": 2162}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "e8f8922181c11b3bdbc1f11ec7e925dd", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 11, "line": 2235}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "0b74b385bc937a34c1bc32da815d126d", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 11, "line": 2480}, "message": "narrowing conversion from 'uint64_t' (aka 'unsigned long') to signed type 'long' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "ab6d97c1759346cc4d799deda03ed1db", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 11, "line": 2616}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "c8332705e2ca0341ac1e5ad0714877e9", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 50, "file": 11, "line": 2782}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "91861b68a2827b96c1ee27d0c00b06cc", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 11, "line": 2793}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "b3e0bfcb1c43346d2dfd6e7b47539429", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 11, "line": 2806}, "message": "narrowing conversion from 'long' to 'double'"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "37551d97c83f14e698d0fda0f72c7f1f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 11, "line": 2807}, "message": "narrowing conversion from 'long' to 'double'"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "18d5862d5de075819923831f5c03dccd", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 43, "file": 11, "line": 2941}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "35a116e5db178899c59b63b4d37da258", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 11, "line": 3016}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "89bb06d86a9ecf1bd1b0e688f541fafe", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 36, "file": 11, "line": 3042}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "13feb96a9a2fccfa38a4aa280c0c5557", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 48, "file": 11, "line": 3084}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "d42474174c06ab94d4825d5cc98194b2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 50, "file": 11, "line": 3323}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "6f69888f1f51f2b47bdaf28a9095bdba", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 46, "file": 11, "line": 3344}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "3dfe91d13f71b3a15f7c5f31a5a9d9c4", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 11, "line": 3517}, "message": "narrowing conversion from 'long' to 'double'"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "189678bfb66f8a84af407bf3f3973078", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 11, "line": 3518}, "message": "narrowing conversion from 'long' to 'double'"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "e043840959b96debf6c630ff7784e22a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 37, "file": 11, "line": 3532}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "4f50b561fbdfc2e3f635a432c56978b1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 33, "file": 11, "line": 3570}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "f70d178e5740aef188a4d722095abaf9", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 11, "line": 3572}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "42f722b8790078ee490e3b203128cb08", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 28, "file": 11, "line": 3946}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "0290ee209e75ea8f7113c798ec1d9707", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 11, "line": 4013}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "fd103041caec0fc11b0419dcf8273514", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 11, "line": 4052}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "5173e308a5a380602fb6e9e2104c4d2c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 11, "line": 4658}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/fileio.c", "reportHash": "816e9b3defcf0ad6633ee08f6a285b0f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
