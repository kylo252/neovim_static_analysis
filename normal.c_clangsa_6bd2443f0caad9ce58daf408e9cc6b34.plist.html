<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/normal.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n//\n// normal.c:    Contains the main routine for processing characters in command\n//              mode.  Communicates closely with the code in ops.c to handle\n//              the operators.\n//\n\n#include <assert.h>\n#include <inttypes.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"nvim/log.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/option.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/spellfile.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/tag.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/state.h\"\n#include \"nvim/event/loop.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/api/private/helpers.h\"\n\ntypedef struct normal_state {\n  VimState state;\n  bool command_finished;\n  bool ctrl_w;\n  bool need_flushbuf;\n  bool set_prevcount;\n  bool previous_got_int;             // `got_int` was true\n  bool cmdwin;                       // command-line window normal mode\n  bool noexmode;                     // true if the normal mode was pushed from\n                                     // ex mode(:global or :visual for example)\n  bool toplevel;                     // top-level normal mode\n  oparg_T oa;                        // operator arguments\n  cmdarg_T ca;                       // command arguments\n  int mapped_len;\n  int old_mapped_len;\n  int idx;\n  int c;\n  int old_col;\n  pos_T old_pos;\n} NormalState;\n\n/*\n * The Visual area is remembered for reselection.\n */\nstatic int resel_VIsual_mode = NUL;             /* 'v', 'V', or Ctrl-V */\nstatic linenr_T resel_VIsual_line_count;        /* number of lines */\nstatic colnr_T resel_VIsual_vcol;               /* nr of cols or end col */\nstatic int VIsual_mode_orig = NUL;              /* saved Visual mode */\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"normal.c.generated.h\"\n#endif\n\nstatic inline void normal_state_init(NormalState *s)\n{\n  memset(s, 0, sizeof(NormalState));\n  s->state.check = normal_check;\n  s->state.execute = normal_execute;\n}\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\n\nstatic char *e_noident = N_(\"E349: No identifier under cursor\");\n\n/*\n * Function to be called for a Normal or Visual mode command.\n * The argument is a cmdarg_T.\n */\ntypedef void (*nv_func_T)(cmdarg_T *cap);\n\n/* Values for cmd_flags. */\n#define NV_NCH      0x01          /* may need to get a second char */\n#define NV_NCH_NOP  (0x02|NV_NCH) /* get second char when no operator pending */\n#define NV_NCH_ALW  (0x04|NV_NCH) /* always get a second char */\n#define NV_LANG     0x08        /* second char needs language adjustment */\n\n#define NV_SS       0x10        /* may start selection */\n#define NV_SSS      0x20        /* may start selection with shift modifier */\n#define NV_STS      0x40        /* may stop selection without shift modif. */\n#define NV_RL       0x80        /* 'rightleft' modifies command */\n#define NV_KEEPREG  0x100       /* don't clear regname */\n#define NV_NCW      0x200       /* not allowed in command-line window */\n\n/*\n * Generally speaking, every Normal mode command should either clear any\n * pending operator (with *clearop*()), or set the motion type variable\n * oap->motion_type.\n *\n * When a cursor motion command is made, it is marked as being a character or\n * line oriented motion.  Then, if an operator is in effect, the operation\n * becomes character or line oriented accordingly.\n */\n\n/*\n * This table contains one entry for every Normal or Visual mode command.\n * The order doesn't matter, init_normal_cmds() will create a sorted index.\n * It is faster when all keys from zero to '~' are present.\n */\nstatic const struct nv_cmd {\n  int cmd_char;                 /* (first) command character */\n  nv_func_T cmd_func;           /* function for this command */\n  uint16_t cmd_flags;           /* NV_ flags */\n  short cmd_arg;                /* value for ca.arg */\n} nv_cmds[] =\n{\n  { NUL,       nv_error,       0,                      0 },\n  { Ctrl_A,    nv_addsub,      0,                      0 },\n  { Ctrl_B,    nv_page,        NV_STS,                 BACKWARD },\n  { Ctrl_C,    nv_esc,         0,                      true },\n  { Ctrl_D,    nv_halfpage,    0,                      0 },\n  { Ctrl_E,    nv_scroll_line, 0,                      true },\n  { Ctrl_F,    nv_page,        NV_STS,                 FORWARD },\n  { Ctrl_G,    nv_ctrlg,       0,                      0 },\n  { Ctrl_H,    nv_ctrlh,       0,                      0 },\n  { Ctrl_I,    nv_pcmark,      0,                      0 },\n  { NL,        nv_down,        0,                      false },\n  { Ctrl_K,    nv_error,       0,                      0 },\n  { Ctrl_L,    nv_clear,       0,                      0 },\n  { CAR,       nv_down,        0,                      true },\n  { Ctrl_N,    nv_down,        NV_STS,                 false },\n  { Ctrl_O,    nv_ctrlo,       0,                      0 },\n  { Ctrl_P,    nv_up,          NV_STS,                 false },\n  { Ctrl_Q,    nv_visual,      0,                      false },\n  { Ctrl_R,    nv_redo,        0,                      0 },\n  { Ctrl_S,    nv_ignore,      0,                      0 },\n  { Ctrl_T,    nv_tagpop,      NV_NCW,                 0 },\n  { Ctrl_U,    nv_halfpage,    0,                      0 },\n  { Ctrl_V,    nv_visual,      0,                      false },\n  { 'V',       nv_visual,      0,                      false },\n  { 'v',       nv_visual,      0,                      false },\n  { Ctrl_W,    nv_window,      0,                      0 },\n  { Ctrl_X,    nv_addsub,      0,                      0 },\n  { Ctrl_Y,    nv_scroll_line, 0,                      false },\n  { Ctrl_Z,    nv_suspend,     0,                      0 },\n  { ESC,       nv_esc,         0,                      false },\n  { Ctrl_BSL,  nv_normal,      NV_NCH_ALW,             0 },\n  { Ctrl_RSB,  nv_ident,       NV_NCW,                 0 },\n  { Ctrl_HAT,  nv_hat,         NV_NCW,                 0 },\n  { Ctrl__,    nv_error,       0,                      0 },\n  { ' ',       nv_right,       0,                      0 },\n  { '!',       nv_operator,    0,                      0 },\n  { '\"',       nv_regname,     NV_NCH_NOP|NV_KEEPREG,  0 },\n  { '#',       nv_ident,       0,                      0 },\n  { '$',       nv_dollar,      0,                      0 },\n  { '%',       nv_percent,     0,                      0 },\n  { '&',       nv_optrans,     0,                      0 },\n  { '\\'',      nv_gomark,      NV_NCH_ALW,             true },\n  { '(',       nv_brace,       0,                      BACKWARD },\n  { ')',       nv_brace,       0,                      FORWARD },\n  { '*',       nv_ident,       0,                      0 },\n  { '+',       nv_down,        0,                      true },\n  { ',',       nv_csearch,     0,                      true },\n  { '-',       nv_up,          0,                      true },\n  { '.',       nv_dot,         NV_KEEPREG,             0 },\n  { '/',       nv_search,      0,                      false },\n  { '0',       nv_beginline,   0,                      0 },\n  { '1',       nv_ignore,      0,                      0 },\n  { '2',       nv_ignore,      0,                      0 },\n  { '3',       nv_ignore,      0,                      0 },\n  { '4',       nv_ignore,      0,                      0 },\n  { '5',       nv_ignore,      0,                      0 },\n  { '6',       nv_ignore,      0,                      0 },\n  { '7',       nv_ignore,      0,                      0 },\n  { '8',       nv_ignore,      0,                      0 },\n  { '9',       nv_ignore,      0,                      0 },\n  { ':',       nv_colon,       0,                      0 },\n  { ';',       nv_csearch,     0,                      false },\n  { '<',       nv_operator,    NV_RL,                  0 },\n  { '=',       nv_operator,    0,                      0 },\n  { '>',       nv_operator,    NV_RL,                  0 },\n  { '?',       nv_search,      0,                      false },\n  { '@',       nv_at,          NV_NCH_NOP,             false },\n  { 'A',       nv_edit,        0,                      0 },\n  { 'B',       nv_bck_word,    0,                      1 },\n  { 'C',       nv_abbrev,      NV_KEEPREG,             0 },\n  { 'D',       nv_abbrev,      NV_KEEPREG,             0 },\n  { 'E',       nv_wordcmd,     0,                      true },\n  { 'F',       nv_csearch,     NV_NCH_ALW|NV_LANG,     BACKWARD },\n  { 'G',       nv_goto,        0,                      true },\n  { 'H',       nv_scroll,      0,                      0 },\n  { 'I',       nv_edit,        0,                      0 },\n  { 'J',       nv_join,        0,                      0 },\n  { 'K',       nv_ident,       0,                      0 },\n  { 'L',       nv_scroll,      0,                      0 },\n  { 'M',       nv_scroll,      0,                      0 },\n  { 'N',       nv_next,        0,                      SEARCH_REV },\n  { 'O',       nv_open,        0,                      0 },\n  { 'P',       nv_put,         0,                      0 },\n  { 'Q',       nv_exmode,      NV_NCW,                 0 },\n  { 'R',       nv_Replace,     0,                      false },\n  { 'S',       nv_subst,       NV_KEEPREG,             0 },\n  { 'T',       nv_csearch,     NV_NCH_ALW|NV_LANG,     BACKWARD },\n  { 'U',       nv_Undo,        0,                      0 },\n  { 'W',       nv_wordcmd,     0,                      true },\n  { 'X',       nv_abbrev,      NV_KEEPREG,             0 },\n  { 'Y',       nv_abbrev,      NV_KEEPREG,             0 },\n  { 'Z',       nv_Zet,         NV_NCH_NOP|NV_NCW,      0 },\n  { '[',       nv_brackets,    NV_NCH_ALW,             BACKWARD },\n  { '\\\\',      nv_error,       0,                      0 },\n  { ']',       nv_brackets,    NV_NCH_ALW,             FORWARD },\n  { '^',       nv_beginline,   0,                      BL_WHITE | BL_FIX },\n  { '_',       nv_lineop,      0,                      0 },\n  { '`',       nv_gomark,      NV_NCH_ALW,             false },\n  { 'a',       nv_edit,        NV_NCH,                 0 },\n  { 'b',       nv_bck_word,    0,                      0 },\n  { 'c',       nv_operator,    0,                      0 },\n  { 'd',       nv_operator,    0,                      0 },\n  { 'e',       nv_wordcmd,     0,                      false },\n  { 'f',       nv_csearch,     NV_NCH_ALW|NV_LANG,     FORWARD },\n  { 'g',       nv_g_cmd,       NV_NCH_ALW,             false },\n  { 'h',       nv_left,        NV_RL,                  0 },\n  { 'i',       nv_edit,        NV_NCH,                 0 },\n  { 'j',       nv_down,        0,                      false },\n  { 'k',       nv_up,          0,                      false },\n  { 'l',       nv_right,       NV_RL,                  0 },\n  { 'm',       nv_mark,        NV_NCH_NOP,             0 },\n  { 'n',       nv_next,        0,                      0 },\n  { 'o',       nv_open,        0,                      0 },\n  { 'p',       nv_put,         0,                      0 },\n  { 'q',       nv_record,      NV_NCH,                 0 },\n  { 'r',       nv_replace,     NV_NCH_NOP|NV_LANG,     0 },\n  { 's',       nv_subst,       NV_KEEPREG,             0 },\n  { 't',       nv_csearch,     NV_NCH_ALW|NV_LANG,     FORWARD },\n  { 'u',       nv_undo,        0,                      0 },\n  { 'w',       nv_wordcmd,     0,                      false },\n  { 'x',       nv_abbrev,      NV_KEEPREG,             0 },\n  { 'y',       nv_operator,    0,                      0 },\n  { 'z',       nv_zet,         NV_NCH_ALW,             0 },\n  { '{',       nv_findpar,     0,                      BACKWARD },\n  { '|',       nv_pipe,        0,                      0 },\n  { '}',       nv_findpar,     0,                      FORWARD },\n  { '~',       nv_tilde,       0,                      0 },\n\n  // pound sign\n  { POUND,     nv_ident,       0,                      0 },\n  { K_MOUSEUP, nv_mousescroll, 0,                      MSCR_UP },\n  { K_MOUSEDOWN, nv_mousescroll, 0,                    MSCR_DOWN },\n  { K_MOUSELEFT, nv_mousescroll, 0,                    MSCR_LEFT },\n  { K_MOUSERIGHT, nv_mousescroll, 0,                   MSCR_RIGHT },\n  { K_LEFTMOUSE, nv_mouse,     0,                      0 },\n  { K_LEFTMOUSE_NM, nv_mouse,  0,                      0 },\n  { K_LEFTDRAG, nv_mouse,      0,                      0 },\n  { K_LEFTRELEASE, nv_mouse,   0,                      0 },\n  { K_LEFTRELEASE_NM, nv_mouse, 0,                     0 },\n  { K_MOUSEMOVE, nv_mouse,     0,                      0 },\n  { K_MIDDLEMOUSE, nv_mouse,   0,                      0 },\n  { K_MIDDLEDRAG, nv_mouse,    0,                      0 },\n  { K_MIDDLERELEASE, nv_mouse, 0,                      0 },\n  { K_RIGHTMOUSE, nv_mouse,    0,                      0 },\n  { K_RIGHTDRAG, nv_mouse,     0,                      0 },\n  { K_RIGHTRELEASE, nv_mouse,  0,                      0 },\n  { K_X1MOUSE, nv_mouse,       0,                      0 },\n  { K_X1DRAG, nv_mouse,        0,                      0 },\n  { K_X1RELEASE, nv_mouse,     0,                      0 },\n  { K_X2MOUSE, nv_mouse,       0,                      0 },\n  { K_X2DRAG, nv_mouse,        0,                      0 },\n  { K_X2RELEASE, nv_mouse,     0,                      0 },\n  { K_IGNORE,  nv_ignore,      NV_KEEPREG,             0 },\n  { K_NOP,     nv_nop,         0,                      0 },\n  { K_INS,     nv_edit,        0,                      0 },\n  { K_KINS,    nv_edit,        0,                      0 },\n  { K_BS,      nv_ctrlh,       0,                      0 },\n  { K_UP,      nv_up,          NV_SSS|NV_STS,          false },\n  { K_S_UP,    nv_page,        NV_SS,                  BACKWARD },\n  { K_DOWN,    nv_down,        NV_SSS|NV_STS,          false },\n  { K_S_DOWN,  nv_page,        NV_SS,                  FORWARD },\n  { K_LEFT,    nv_left,        NV_SSS|NV_STS|NV_RL,    0 },\n  { K_S_LEFT,  nv_bck_word,    NV_SS|NV_RL,            0 },\n  { K_C_LEFT,  nv_bck_word,    NV_SSS|NV_RL|NV_STS,    1 },\n  { K_RIGHT,   nv_right,       NV_SSS|NV_STS|NV_RL,    0 },\n  { K_S_RIGHT, nv_wordcmd,     NV_SS|NV_RL,            false },\n  { K_C_RIGHT, nv_wordcmd,     NV_SSS|NV_RL|NV_STS,    true },\n  { K_PAGEUP,  nv_page,        NV_SSS|NV_STS,          BACKWARD },\n  { K_KPAGEUP, nv_page,        NV_SSS|NV_STS,          BACKWARD },\n  { K_PAGEDOWN, nv_page,       NV_SSS|NV_STS,          FORWARD },\n  { K_KPAGEDOWN, nv_page,      NV_SSS|NV_STS,          FORWARD },\n  { K_END,     nv_end,         NV_SSS|NV_STS,          false },\n  { K_KEND,    nv_end,         NV_SSS|NV_STS,          false },\n  { K_S_END,   nv_end,         NV_SS,                  false },\n  { K_C_END,   nv_end,         NV_SSS|NV_STS,          true },\n  { K_HOME,    nv_home,        NV_SSS|NV_STS,          0 },\n  { K_KHOME,   nv_home,        NV_SSS|NV_STS,          0 },\n  { K_S_HOME,  nv_home,        NV_SS,                  0 },\n  { K_C_HOME,  nv_goto,        NV_SSS|NV_STS,          false },\n  { K_DEL,     nv_abbrev,      0,                      0 },\n  { K_KDEL,    nv_abbrev,      0,                      0 },\n  { K_UNDO,    nv_kundo,       0,                      0 },\n  { K_HELP,    nv_help,        NV_NCW,                 0 },\n  { K_F1,      nv_help,        NV_NCW,                 0 },\n  { K_XF1,     nv_help,        NV_NCW,                 0 },\n  { K_SELECT,  nv_select,      0,                      0 },\n  { K_EVENT,   nv_event,       NV_KEEPREG,             0 },\n  { K_COMMAND, nv_colon,       0,                      0 },\n};\n\n/* Number of commands in nv_cmds[]. */\n#define NV_CMDS_SIZE ARRAY_SIZE(nv_cmds)\n\n/* Sorted index of commands in nv_cmds[]. */\nstatic short nv_cmd_idx[NV_CMDS_SIZE];\n\n/* The highest index for which\n * nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char] */\nstatic int nv_max_linear;\n\n/*\n * Compare functions for qsort() below, that checks the command character\n * through the index in nv_cmd_idx[].\n */\nstatic int nv_compare(const void *s1, const void *s2)\n{\n  int c1, c2;\n\n  /* The commands are sorted on absolute value. */\n  c1 = nv_cmds[*(const short *)s1].cmd_char;\n  c2 = nv_cmds[*(const short *)s2].cmd_char;\n  if (c1 < 0)\n    c1 = -c1;\n  if (c2 < 0)\n    c2 = -c2;\n  return c1 - c2;\n}\n\n/*\n * Initialize the nv_cmd_idx[] table.\n */\nvoid init_normal_cmds(void)\n{\n  assert(NV_CMDS_SIZE <= SHRT_MAX);\n\n  /* Fill the index table with a one to one relation. */\n  for (short int i = 0; i < (short int)NV_CMDS_SIZE; ++i) {\n    nv_cmd_idx[i] = i;\n  }\n\n  /* Sort the commands by the command character.  */\n  qsort(&nv_cmd_idx, NV_CMDS_SIZE, sizeof(short), nv_compare);\n\n  /* Find the first entry that can't be indexed by the command character. */\n  short int i;\n  for (i = 0; i < (short int)NV_CMDS_SIZE; ++i) {\n    if (i != nv_cmds[nv_cmd_idx[i]].cmd_char) {\n      break;\n    }\n  }\n  nv_max_linear = i - 1;\n}\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\nstatic int find_command(int cmdchar)\n{\n  int i;\n  int idx;\n  int top, bot;\n  int c;\n\n  /* A multi-byte character is never a command. */\n  if (cmdchar >= 0x100)\n    return -1;\n\n  /* We use the absolute value of the character.  Special keys have a\n   * negative value, but are sorted on their absolute value. */\n  if (cmdchar < 0)\n    cmdchar = -cmdchar;\n\n  /* If the character is in the first part: The character is the index into\n   * nv_cmd_idx[]. */\n  assert(nv_max_linear < (int)NV_CMDS_SIZE);\n  if (cmdchar <= nv_max_linear)\n    return nv_cmd_idx[cmdchar];\n\n  /* Perform a binary search. */\n  bot = nv_max_linear + 1;\n  top = NV_CMDS_SIZE - 1;\n  idx = -1;\n  while (bot <= top) {\n    i = (top + bot) / 2;\n    c = nv_cmds[nv_cmd_idx[i]].cmd_char;\n    if (c < 0)\n      c = -c;\n    if (cmdchar == c) {\n      idx = nv_cmd_idx[i];\n      break;\n    }\n    if (cmdchar > c)\n      bot = i + 1;\n    else\n      top = i - 1;\n  }\n  return idx;\n}\n\n// Normal state entry point. This is called on:\n//\n// - Startup, In this case the function never returns.\n// - The command-line window is opened(`q:`). Returns when `cmdwin_result` != 0.\n// - The :visual command is called from :global in ex mode, `:global/PAT/visual`\n//   for example. Returns when re-entering ex mode(because ex mode recursion is\n//   not allowed)\n//\n// This used to be called main_loop on main.c\nvoid normal_enter(bool cmdwin, bool noexmode)\n{\n  NormalState state;\n  normal_state_init(&state);\n  state.cmdwin = cmdwin;\n  state.noexmode = noexmode;\n  state.toplevel = (!cmdwin || cmdwin_result == 0) && !noexmode;\n  state_enter(&state.state);\n}\n\nstatic void normal_prepare(NormalState *s)\n{\n  memset(&s->ca, 0, sizeof(s->ca));  // also resets ca.retval\n  s->ca.oap = &s->oa;\n\n  // Use a count remembered from before entering an operator. After typing \"3d\"\n  // we return from normal_cmd() and come back here, the \"3\" is remembered in\n  // \"opcount\".\n  s->ca.opcount = opcount;\n\n  // If there is an operator pending, then the command we take this time will\n  // terminate it. Finish_op tells us to finish the operation before returning\n  // this time (unless the operation was cancelled).\n  int c = finish_op;\n  finish_op = (s->oa.op_type != OP_NOP);\n  if (finish_op != c) {\n    ui_cursor_shape();  // may show different cursor shape\n  }\n\n  // When not finishing an operator and no register name typed, reset the count.\n  if (!finish_op && !s->oa.regname) {\n    s->ca.opcount = 0;\n    s->set_prevcount = true;\n  }\n\n  // Restore counts from before receiving K_EVENT.  This means after\n  // typing \"3\", handling K_EVENT and then typing \"2\" we get \"32\", not\n  // \"3 * 2\".\n  if (s->oa.prev_opcount > 0 || s->oa.prev_count0 > 0) {\n    s->ca.opcount = s->oa.prev_opcount;\n    s->ca.count0 = s->oa.prev_count0;\n    s->oa.prev_opcount = 0;\n    s->oa.prev_count0 = 0;\n  }\n\n  s->mapped_len = typebuf_maplen();\n  State = NORMAL_BUSY;\n\n  // Set v:count here, when called from main() and not a stuffed command, so\n  // that v:count can be used in an expression mapping when there is no count.\n  // Do set it for redo\n  if (s->toplevel && readbuf1_empty()) {\n    set_vcount_ca(&s->ca, &s->set_prevcount);\n  }\n}\n\nstatic bool normal_handle_special_visual_command(NormalState *s)\n{\n  // when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n  if (km_stopsel\n      && (nv_cmds[s->idx].cmd_flags & NV_STS)\n      && !(mod_mask & MOD_MASK_SHIFT)) {\n    end_visual_mode();\n    redraw_curbuf_later(INVERTED);\n  }\n\n  // Keys that work different when 'keymodel' contains \"startsel\"\n  if (km_startsel) {\n    if (nv_cmds[s->idx].cmd_flags & NV_SS) {\n      unshift_special(&s->ca);\n      s->idx = find_command(s->ca.cmdchar);\n      if (s->idx < 0) {\n        // Just in case\n        clearopbeep(&s->oa);\n        return true;\n      }\n    } else if ((nv_cmds[s->idx].cmd_flags & NV_SSS)\n               && (mod_mask & MOD_MASK_SHIFT)) {\n      mod_mask &= ~MOD_MASK_SHIFT;\n    }\n  }\n  return false;\n}\n\nstatic bool normal_need_additional_char(NormalState *s)\n{\n  int flags = nv_cmds[s->idx].cmd_flags;\n  bool pending_op = s->oa.op_type != OP_NOP;\n  int cmdchar = s->ca.cmdchar;\n  // without NV_NCH we never need to check for an additional char\n  return flags & NV_NCH && (\n      // NV_NCH_NOP is set and no operator is pending, get a second char\n      ((flags & NV_NCH_NOP) == NV_NCH_NOP && !pending_op)\n      // NV_NCH_ALW is set, always get a second char\n      || (flags & NV_NCH_ALW) == NV_NCH_ALW\n      // 'q' without a pending operator, recording or executing a register,\n      // needs to be followed by a second char, examples:\n      // - qc => record using register c\n      // - q: => open command-line window\n      || (cmdchar == 'q'\n          && !pending_op\n          && reg_recording == 0\n          && reg_executing == 0)\n      // 'a' or 'i' after an operator is a text object, examples:\n      // - ciw => change inside word\n      // - da( => delete parenthesis and everything inside.\n      // Also, don't do anything when these keys are received in visual mode\n      // so just get another char.\n      //\n      // TODO(tarruda): Visual state needs to be refactored into a\n      // separate state that \"inherits\" from normal state.\n      || ((cmdchar == 'a' || cmdchar == 'i') && (pending_op || VIsual_active)));\n}\n\nstatic bool normal_need_redraw_mode_message(NormalState *s)\n{\n  return (\n      // 'showmode' is set and messages can be printed\n      ((p_smd && msg_silent == 0\n        // must restart insert mode(ctrl+o or ctrl+l) or we just entered visual\n        // mode\n        && (restart_edit != 0 || (VIsual_active\n                                  && s->old_pos.lnum == curwin->w_cursor.lnum\n                                  && s->old_pos.col == curwin->w_cursor.col))\n        // command-line must be cleared or redrawn\n        && (clear_cmdline || redraw_cmdline)\n        // some message was printed or scrolled\n        && (msg_didout || (msg_didany && msg_scroll))\n        // it is fine to remove the current message\n        && !msg_nowait\n        // the command was the result of direct user input and not a mapping\n        && KeyTyped)\n       // must restart insert mode, not in visual mode and error message is\n       // being shown\n       || (restart_edit != 0 && !VIsual_active && msg_scroll\n           && emsg_on_display))\n      // no register was used\n      && s->oa.regname == 0\n      && !(s->ca.retval & CA_COMMAND_BUSY)\n      && stuff_empty()\n      && typebuf_typed()\n      && emsg_silent == 0\n      && !did_wait_return\n      && s->oa.op_type == OP_NOP);\n}\n\nstatic void normal_redraw_mode_message(NormalState *s)\n{\n  int save_State = State;\n\n  // Draw the cursor with the right shape here\n  if (restart_edit != 0) {\n    State = INSERT;\n  }\n\n  // If need to redraw, and there is a \"keep_msg\", redraw before the\n  // delay\n  if (must_redraw && keep_msg != NULL && !emsg_on_display) {\n    char_u      *kmsg;\n\n    kmsg = keep_msg;\n    keep_msg = NULL;\n    // Showmode() will clear keep_msg, but we want to use it anyway.\n    // First update w_topline.\n    setcursor();\n    update_screen(0);\n    // now reset it, otherwise it's put in the history again\n    keep_msg = kmsg;\n\n    kmsg = vim_strsave(keep_msg);\n    msg_attr((const char *)kmsg, keep_msg_attr);\n    xfree(kmsg);\n  }\n  setcursor();\n  ui_cursor_shape();                  // show different cursor shape\n  ui_flush();\n  if (msg_scroll || emsg_on_display) {\n    os_delay(1003L, true);            // wait at least one second\n  }\n  os_delay(3003L, false);             // wait up to three seconds\n  State = save_State;\n\n  msg_scroll = false;\n  emsg_on_display = false;\n}\n\n// TODO(tarruda): Split into a \"normal pending\" state that can handle K_EVENT\nstatic void normal_get_additional_char(NormalState *s)\n{\n  int *cp;\n  bool repl = false;            // get character for replace mode\n  bool lit = false;             // get extra character literally\n  bool langmap_active = false;  // using :lmap mappings\n  int lang;                     // getting a text character\n\n  no_mapping++;\n  // Don't generate a CursorHold event here, most commands can't handle\n  // it, e.g., nv_replace(), nv_csearch().\n  did_cursorhold = true;\n  if (s->ca.cmdchar == 'g') {\n    // For 'g' get the next character now, so that we can check for\n    // \"gr\", \"g'\" and \"g`\".\n    s->ca.nchar = plain_vgetc();\n    LANGMAP_ADJUST(s->ca.nchar, true);\n    s->need_flushbuf |= add_to_showcmd(s->ca.nchar);\n    if (s->ca.nchar == 'r' || s->ca.nchar == '\\'' || s->ca.nchar == '`'\n        || s->ca.nchar == Ctrl_BSL) {\n      cp = &s->ca.extra_char;            // need to get a third character\n      if (s->ca.nchar != 'r') {\n        lit = true;                           // get it literally\n      } else {\n        repl = true;                          // get it in replace mode\n      }\n    } else {\n      cp = NULL;                      // no third character needed\n    }\n  } else {\n    if (s->ca.cmdchar == 'r') {\n      // get it in replace mode\n      repl = true;\n    }\n    cp = &s->ca.nchar;\n  }\n  lang = (repl || (nv_cmds[s->idx].cmd_flags & NV_LANG));\n\n  // Get a second or third character.\n  if (cp != NULL) {\n    if (repl) {\n      State = REPLACE;                // pretend Replace mode\n      ui_cursor_shape();              // show different cursor shape\n    }\n    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP) {\n      // Allow mappings defined with \":lmap\".\n      no_mapping--;\n      if (repl) {\n        State = LREPLACE;\n      } else {\n        State = LANGMAP;\n      }\n      langmap_active = true;\n    }\n\n    *cp = plain_vgetc();\n\n    if (langmap_active) {\n      // Undo the decrement done above\n      no_mapping++;\n    }\n    State = NORMAL_BUSY;\n    s->need_flushbuf |= add_to_showcmd(*cp);\n\n    if (!lit) {\n      // Typing CTRL-K gets a digraph.\n      if (*cp == Ctrl_K && ((nv_cmds[s->idx].cmd_flags & NV_LANG)\n              || cp == &s->ca.extra_char)\n          && vim_strchr(p_cpo, CPO_DIGRAPH) == NULL) {\n        s->c = get_digraph(false);\n        if (s->c > 0) {\n          *cp = s->c;\n          // Guessing how to update showcmd here...\n          del_from_showcmd(3);\n          s->need_flushbuf |= add_to_showcmd(*cp);\n        }\n      }\n\n      // adjust chars > 127, except after \"tTfFr\" commands\n      LANGMAP_ADJUST(*cp, !lang);\n      // adjust Hebrew mapped char\n      if (p_hkmap && lang && KeyTyped) {\n        *cp = hkmap(*cp);\n      }\n    }\n\n    // When the next character is CTRL-\\ a following CTRL-N means the\n    // command is aborted and we go to Normal mode.\n    if (cp == &s->ca.extra_char\n        && s->ca.nchar == Ctrl_BSL\n        && (s->ca.extra_char == Ctrl_N || s->ca.extra_char == Ctrl_G)) {\n      s->ca.cmdchar = Ctrl_BSL;\n      s->ca.nchar = s->ca.extra_char;\n      s->idx = find_command(s->ca.cmdchar);\n    } else if ((s->ca.nchar == 'n' || s->ca.nchar == 'N')\n        && s->ca.cmdchar == 'g') {\n      s->ca.oap->op_type = get_op_type(*cp, NUL);\n    } else if (*cp == Ctrl_BSL) {\n      long towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n      // There is a busy wait here when typing \"f<C-\\>\" and then\n      // something different from CTRL-N.  Can't be avoided.\n      while ((s->c = vpeekc()) <= 0 && towait > 0L) {\n        do_sleep(towait > 50L ? 50L : towait);\n        towait -= 50L;\n      }\n      if (s->c > 0) {\n        s->c = plain_vgetc();\n        if (s->c != Ctrl_N && s->c != Ctrl_G) {\n          vungetc(s->c);\n        } else {\n          s->ca.cmdchar = Ctrl_BSL;\n          s->ca.nchar = s->c;\n          s->idx = find_command(s->ca.cmdchar);\n          assert(s->idx >= 0);\n        }\n      }\n    }\n\n    // When getting a text character and the next character is a\n    // multi-byte character, it could be a composing character.\n    // However, don't wait for it to arrive. Also, do enable mapping,\n    // because if it's put back with vungetc() it's too late to apply\n    // mapping.\n    no_mapping--;\n    while (lang && (s->c = vpeekc()) > 0\n           && (s->c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1)) {\n      s->c = plain_vgetc();\n      if (!utf_iscomposing(s->c)) {\n        vungetc(s->c);                   /* it wasn't, put it back */\n        break;\n      } else if (s->ca.ncharC1 == 0) {\n        s->ca.ncharC1 = s->c;\n      } else {\n        s->ca.ncharC2 = s->c;\n      }\n    }\n    no_mapping++;\n  }\n  no_mapping--;\n}\n\nstatic void normal_invert_horizontal(NormalState *s)\n{\n  switch (s->ca.cmdchar) {\n    case 'l':       s->ca.cmdchar = 'h'; break;\n    case K_RIGHT:   s->ca.cmdchar = K_LEFT; break;\n    case K_S_RIGHT: s->ca.cmdchar = K_S_LEFT; break;\n    case K_C_RIGHT: s->ca.cmdchar = K_C_LEFT; break;\n    case 'h':       s->ca.cmdchar = 'l'; break;\n    case K_LEFT:    s->ca.cmdchar = K_RIGHT; break;\n    case K_S_LEFT:  s->ca.cmdchar = K_S_RIGHT; break;\n    case K_C_LEFT:  s->ca.cmdchar = K_C_RIGHT; break;\n    case '>':       s->ca.cmdchar = '<'; break;\n    case '<':       s->ca.cmdchar = '>'; break;\n  }\n  s->idx = find_command(s->ca.cmdchar);\n}\n\nstatic bool normal_get_command_count(NormalState *s)\n{\n  if (VIsual_active && VIsual_select) {\n    return false;\n  }\n  // Handle a count before a command and compute ca.count0.\n  // Note that '0' is a command and not the start of a count, but it's\n  // part of a count after other digits.\n  while ((s->c >= '1' && s->c <= '9') || (s->ca.count0 != 0\n        && (s->c == K_DEL || s->c == K_KDEL || s->c == '0'))) {\n    if (s->c == K_DEL || s->c == K_KDEL) {\n      s->ca.count0 /= 10;\n      del_from_showcmd(4);            // delete the digit and ~@%\n    } else {\n      s->ca.count0 = s->ca.count0 * 10 + (s->c - '0');\n    }\n\n    if (s->ca.count0 < 0) {\n      // overflow\n      s->ca.count0 = 999999999L;\n    }\n\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // right after the count. Do set it for redo.\n    if (s->toplevel && readbuf1_empty()) {\n      set_vcount_ca(&s->ca, &s->set_prevcount);\n    }\n\n    if (s->ctrl_w) {\n      no_mapping++;\n    }\n\n    ++no_zero_mapping;                // don't map zero here\n    s->c = plain_vgetc();\n    LANGMAP_ADJUST(s->c, true);\n    --no_zero_mapping;\n    if (s->ctrl_w) {\n      no_mapping--;\n    }\n    s->need_flushbuf |= add_to_showcmd(s->c);\n  }\n\n  // If we got CTRL-W there may be a/another count\n  if (s->c == Ctrl_W && !s->ctrl_w && s->oa.op_type == OP_NOP) {\n    s->ctrl_w = true;\n    s->ca.opcount = s->ca.count0;           // remember first count\n    s->ca.count0 = 0;\n    no_mapping++;\n    s->c = plain_vgetc();                // get next character\n    LANGMAP_ADJUST(s->c, true);\n    no_mapping--;\n    s->need_flushbuf |= add_to_showcmd(s->c);\n    return true;\n  }\n\n  return false;\n}\n\nstatic void normal_finish_command(NormalState *s)\n{\n  if (s->command_finished) {\n    goto normal_end;\n  }\n\n  // If we didn't start or finish an operator, reset oap->regname, unless we\n  // need it later.\n  if (!finish_op\n      && !s->oa.op_type\n      && (s->idx < 0 || !(nv_cmds[s->idx].cmd_flags & NV_KEEPREG))) {\n    clearop(&s->oa);\n    set_reg_var(get_default_register_name());\n  }\n\n  // Get the length of mapped chars again after typing a count, second\n  // character or \"z333<cr>\".\n  if (s->old_mapped_len > 0) {\n    s->old_mapped_len = typebuf_maplen();\n  }\n\n  // If an operation is pending, handle it.  But not for K_IGNORE or\n  // K_MOUSEMOVE.\n  if (s->ca.cmdchar != K_IGNORE && s->ca.cmdchar != K_MOUSEMOVE) {\n    do_pending_operator(&s->ca, s->old_col, false);\n  }\n\n  // Wait for a moment when a message is displayed that will be overwritten\n  // by the mode message.\n  // In Visual mode and with \"^O\" in Insert mode, a short message will be\n  // overwritten by the mode message.  Wait a bit, until a key is hit.\n  // In Visual mode, it's more important to keep the Visual area updated\n  // than keeping a message (e.g. from a /pat search).\n  // Only do this if the command was typed, not from a mapping.\n  // Don't wait when emsg_silent is non-zero.\n  // Also wait a bit after an error message, e.g. for \"^O:\".\n  // Don't redraw the screen, it would remove the message.\n  if (normal_need_redraw_mode_message(s)) {\n    normal_redraw_mode_message(s);\n  }\n\n  // Finish up after executing a Normal mode command.\nnormal_end:\n\n  msg_nowait = false;\n\n  if (finish_op) {\n    set_reg_var(get_default_register_name());\n  }\n\n  // Reset finish_op, in case it was set\n  s->c = finish_op;\n  finish_op = false;\n  // Redraw the cursor with another shape, if we were in Operator-pending\n  // mode or did a replace command.\n  if (s->c || s->ca.cmdchar == 'r') {\n    ui_cursor_shape();                  // may show different cursor shape\n  }\n\n  if (s->oa.op_type == OP_NOP && s->oa.regname == 0\n      && s->ca.cmdchar != K_EVENT) {\n    clear_showcmd();\n  }\n\n  checkpcmark();                // check if we moved since setting pcmark\n  xfree(s->ca.searchbuf);\n\n  mb_check_adjust_col(curwin);  // #6203\n\n  if (curwin->w_p_scb && s->toplevel) {\n    validate_cursor();          // may need to update w_leftcol\n    do_check_scrollbind(true);\n  }\n\n  if (curwin->w_p_crb && s->toplevel) {\n    validate_cursor();          // may need to update w_leftcol\n    do_check_cursorbind();\n  }\n\n  // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n  // if still inside a mapping that started in Visual mode).\n  // May switch from Visual to Select mode after CTRL-O command.\n  if (s->oa.op_type == OP_NOP\n             && ((restart_edit != 0 && !VIsual_active && s->old_mapped_len == 0)\n                 || restart_VIsual_select == 1)\n             && !(s->ca.retval & CA_COMMAND_BUSY)\n             && stuff_empty()\n             && s->oa.regname == 0) {\n    if (restart_VIsual_select == 1) {\n      VIsual_select = true;\n      showmode();\n      restart_VIsual_select = 0;\n    }\n    if (restart_edit != 0 && !VIsual_active && s->old_mapped_len == 0) {\n      (void)edit(restart_edit, false, 1L);\n    }\n  }\n\n  if (restart_VIsual_select == 2) {\n    restart_VIsual_select = 1;\n  }\n\n  // Save count before an operator for next time\n  opcount = s->ca.opcount;\n}\n\nstatic int normal_execute(VimState *state, int key)\n{\n  NormalState *s = (NormalState *)state;\n  s->command_finished = false;\n  s->ctrl_w = false;                  /* got CTRL-W command */\n  s->old_col = curwin->w_curswant;\n  s->c = key;\n\n  LANGMAP_ADJUST(s->c, get_real_state() != SELECTMODE);\n\n  // If a mapping was started in Visual or Select mode, remember the length\n  // of the mapping.  This is used below to not return to Insert mode for as\n  // long as the mapping is being executed.\n  if (restart_edit == 0) {\n    s->old_mapped_len = 0;\n  } else if (s->old_mapped_len || (VIsual_active && s->mapped_len == 0\n        && typebuf_maplen() > 0)) {\n    s->old_mapped_len = typebuf_maplen();\n  }\n\n  if (s->c == NUL) {\n    s->c = K_ZERO;\n  }\n\n  // In Select mode, typed text replaces the selection.\n  if (VIsual_active && VIsual_select && (vim_isprintc(s->c)\n        || s->c == NL || s->c == CAR || s->c == K_KENTER)) {\n    // Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n    // 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n    // restart automatically.\n    // Insert the typed character in the typeahead buffer, so that it can\n    // be mapped in Insert mode.  Required for \":lmap\" to work.\n    ins_char_typebuf(s->c);\n    if (restart_edit != 0) {\n      s->c = 'd';\n    } else {\n      s->c = 'c';\n    }\n    msg_nowait = true;          // don't delay going to insert mode\n    s->old_mapped_len = 0;      // do go to Insert mode\n  }\n\n  s->need_flushbuf = add_to_showcmd(s->c);\n\n  while (normal_get_command_count(s)) continue;\n\n  if (s->c == K_EVENT) {\n    // Save the count values so that ca.opcount and ca.count0 are exactly\n    // the same when coming back here after handling K_EVENT.\n    s->oa.prev_opcount = s->ca.opcount;\n    s->oa.prev_count0 = s->ca.count0;\n  } else if (s->ca.opcount != 0)  {\n    // If we're in the middle of an operator (including after entering a\n    // yank buffer with '\"') AND we had a count before the operator, then\n    // that count overrides the current value of ca.count0.\n    // What this means effectively, is that commands like \"3dw\" get turned\n    // into \"d3w\" which makes things fall into place pretty neatly.\n    // If you give a count before AND after the operator, they are\n    // multiplied.\n    if (s->ca.count0) {\n      s->ca.count0 = (long)((uint64_t)s->ca.count0 * (uint64_t)s->ca.opcount);\n    } else {\n      s->ca.count0 = s->ca.opcount;\n    }\n    if (s->ca.count0 < 0) {\n      // overflow\n      s->ca.count0 = 999999999L;\n    }\n  }\n\n  // Always remember the count.  It will be set to zero (on the next call,\n  // above) when there is no pending operator.\n  // When called from main(), save the count for use by the \"count\" built-in\n  // variable.\n  s->ca.opcount = s->ca.count0;\n  s->ca.count1 = (s->ca.count0 == 0 ? 1 : s->ca.count0);\n\n  // Only set v:count when called from main() and not a stuffed command.\n  // Do set it for redo.\n  if (s->toplevel && readbuf1_empty()) {\n    set_vcount(s->ca.count0, s->ca.count1, s->set_prevcount);\n  }\n\n  // Find the command character in the table of commands.\n  // For CTRL-W we already got nchar when looking for a count.\n  if (s->ctrl_w) {\n    s->ca.nchar = s->c;\n    s->ca.cmdchar = Ctrl_W;\n  } else {\n    s->ca.cmdchar = s->c;\n  }\n\n  s->idx = find_command(s->ca.cmdchar);\n\n  if (s->idx < 0) {\n    // Not a known command: beep.\n    clearopbeep(&s->oa);\n    s->command_finished = true;\n    goto finish;\n  }\n\n  if (text_locked() && (nv_cmds[s->idx].cmd_flags & NV_NCW)) {\n    // This command is not allowed while editing a cmdline: beep.\n    clearopbeep(&s->oa);\n    text_locked_msg();\n    s->command_finished = true;\n    goto finish;\n  }\n\n  if ((nv_cmds[s->idx].cmd_flags & NV_NCW) && curbuf_locked()) {\n    s->command_finished = true;\n    goto finish;\n  }\n\n  // In Visual/Select mode, a few keys are handled in a special way.\n  if (VIsual_active && normal_handle_special_visual_command(s)) {\n    s->command_finished = true;\n    goto finish;\n  }\n\n  if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n      && (nv_cmds[s->idx].cmd_flags & NV_RL)) {\n    // Invert horizontal movements and operations.  Only when typed by the\n    // user directly, not when the result of a mapping or \"x\" translated\n    // to \"dl\".\n    normal_invert_horizontal(s);\n  }\n\n  // Get an additional character if we need one.\n  if (normal_need_additional_char(s)) {\n    normal_get_additional_char(s);\n  }\n\n  // Flush the showcmd characters onto the screen so we can see them while\n  // the command is being executed.  Only do this when the shown command was\n  // actually displayed, otherwise this will slow down a lot when executing\n  // mappings.\n  if (s->need_flushbuf) {\n    ui_flush();\n  }\n  if (s->ca.cmdchar != K_IGNORE && s->ca.cmdchar != K_EVENT) {\n    did_cursorhold = false;\n  }\n\n  State = NORMAL;\n\n  if (s->ca.nchar == ESC) {\n    clearop(&s->oa);\n    if (restart_edit == 0 && goto_im()) {\n      restart_edit = 'a';\n    }\n    s->command_finished = true;\n    goto finish;\n  }\n\n  if (s->ca.cmdchar != K_IGNORE) {\n    msg_didout = false;        // don't scroll screen up for normal command\n    msg_col = 0;\n  }\n\n  s->old_pos = curwin->w_cursor;           // remember where cursor was\n\n  // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n  // mode.\n  if (!VIsual_active && km_startsel) {\n    if (nv_cmds[s->idx].cmd_flags & NV_SS) {\n      start_selection();\n      unshift_special(&s->ca);\n      s->idx = find_command(s->ca.cmdchar);\n      assert(s->idx >= 0);\n    } else if ((nv_cmds[s->idx].cmd_flags & NV_SSS)\n               && (mod_mask & MOD_MASK_SHIFT)) {\n      start_selection();\n      mod_mask &= ~MOD_MASK_SHIFT;\n    }\n  }\n\n  // Execute the command!\n  // Call the command function found in the commands table.\n  s->ca.arg = nv_cmds[s->idx].cmd_arg;\n  (nv_cmds[s->idx].cmd_func)(&s->ca);\n\nfinish:\n  normal_finish_command(s);\n  return 1;\n}\n\nstatic void normal_check_stuff_buffer(NormalState *s)\n{\n  if (stuff_empty()) {\n    did_check_timestamps = false;\n\n    if (need_check_timestamps) {\n      check_timestamps(false);\n    }\n\n    if (need_wait_return) {\n      // if wait_return still needed call it now\n      wait_return(false);\n    }\n\n    if (need_start_insertmode && goto_im() && !VIsual_active) {\n      need_start_insertmode = false;\n      stuffReadbuff(\"i\");  // start insert mode next\n      // skip the fileinfo message now, because it would be shown\n      // after insert mode finishes!\n      need_fileinfo = false;\n    }\n  }\n}\n\nstatic void normal_check_interrupt(NormalState *s)\n{\n  // Reset \"got_int\" now that we got back to the main loop.  Except when\n  // inside a \":g/pat/cmd\" command, then the \"got_int\" needs to abort\n  // the \":g\" command.\n  // For \":g/pat/vi\" we reset \"got_int\" when used once.  When used\n  // a second time we go back to Ex mode and abort the \":g\" command.\n  if (got_int) {\n    if (s->noexmode && global_busy && !exmode_active\n        && s->previous_got_int) {\n      // Typed two CTRL-C in a row: go back to ex mode as if \"Q\" was\n      // used and keep \"got_int\" set, so that it aborts \":g\".\n      exmode_active = true;\n      State = NORMAL;\n    } else if (!global_busy || !exmode_active) {\n      if (!quit_more) {\n        // flush all buffers\n        (void)vgetc();\n      }\n      got_int = false;\n    }\n    s->previous_got_int = true;\n  } else {\n    s->previous_got_int = false;\n  }\n}\n\nstatic void normal_check_window_scrolled(NormalState *s)\n{\n  // Trigger Scroll if the viewport changed.\n  if (!finish_op && has_event(EVENT_WINSCROLLED)\n      && win_did_scroll(curwin)) {\n    do_autocmd_winscrolled(curwin);\n  }\n}\n\nstatic void normal_check_cursor_moved(NormalState *s)\n{\n  // Trigger CursorMoved if the cursor moved.\n  if (!finish_op && (has_event(EVENT_CURSORMOVED) || curwin->w_p_cole > 0)\n      && !equalpos(curwin->w_last_cursormoved, curwin->w_cursor)) {\n    if (has_event(EVENT_CURSORMOVED)) {\n      apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, false, curbuf);\n    }\n\n    curwin->w_last_cursormoved = curwin->w_cursor;\n  }\n}\n\nstatic void normal_check_text_changed(NormalState *s)\n{\n  // Trigger TextChanged if changedtick differs.\n  if (!finish_op && has_event(EVENT_TEXTCHANGED)\n      && curbuf->b_last_changedtick != buf_get_changedtick(curbuf)) {\n    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL, false, curbuf);\n    curbuf->b_last_changedtick = buf_get_changedtick(curbuf);\n  }\n}\n\nstatic void normal_check_buffer_modified(NormalState *s)\n{\n  // Trigger BufModified if b_modified changed\n  if (!finish_op && has_event(EVENT_BUFMODIFIEDSET)\n      && curbuf->b_changed_invalid == true) {\n    apply_autocmds(EVENT_BUFMODIFIEDSET, NULL, NULL, false, curbuf);\n    curbuf->b_changed_invalid = false;\n  }\n}\n\nstatic void normal_check_folds(NormalState *s)\n{\n  // Include a closed fold completely in the Visual area.\n  foldAdjustVisual();\n\n  // When 'foldclose' is set, apply 'foldlevel' to folds that don't\n  // contain the cursor.\n  // When 'foldopen' is \"all\", open the fold(s) under the cursor.\n  // This may mark the window for redrawing.\n  if (hasAnyFolding(curwin) && !char_avail()) {\n    foldCheckClose();\n\n    if (fdo_flags & FDO_ALL) {\n      foldOpenCursor();\n    }\n  }\n}\n\nstatic void normal_redraw(NormalState *s)\n{\n  // Before redrawing, make sure w_topline is correct, and w_leftcol\n  // if lines don't wrap, and w_skipcol if lines wrap.\n  update_topline(curwin);\n  validate_cursor();\n\n  // If the cursor moves horizontally when 'concealcursor' is active, then the\n  // current line needs to be redrawn in order to calculate the correct\n  // cursor position.\n  if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin)) {\n    redrawWinline(curwin, curwin->w_cursor.lnum);\n  }\n\n  // Might need to update for 'cursorline'.\n  // When 'cursorlineopt' is \"screenline\" need to redraw always.\n  if (curwin->w_p_cul\n      && (curwin->w_last_cursorline != curwin->w_cursor.lnum\n          || (curwin->w_p_culopt_flags & CULOPT_SCRLINE))\n      && !char_avail()) {\n    redraw_later(curwin, VALID);\n  }\n\n  if (VIsual_active) {\n    update_curbuf(INVERTED);  // update inverted part\n  } else if (must_redraw) {\n    update_screen(0);\n  } else if (redraw_cmdline || clear_cmdline) {\n    showmode();\n  }\n\n  redraw_statuslines();\n\n  if (need_maketitle) {\n    maketitle();\n  }\n\n  curbuf->b_last_used = time(NULL);\n\n  // Display message after redraw. If an external message is still visible,\n  // it contains the kept message already.\n  if (keep_msg != NULL && !msg_ext_is_visible()) {\n    char_u *const p = vim_strsave(keep_msg);\n\n    // msg_start() will set keep_msg to NULL, make a copy\n    // first.  Don't reset keep_msg, msg_attr_keep() uses it to\n    // check for duplicates.  Never put this message in\n    // history.\n    msg_hist_off = true;\n    msg_attr((const char *)p, keep_msg_attr);\n    msg_hist_off = false;\n    xfree(p);\n  }\n\n  // show fileinfo after redraw\n  if (need_fileinfo && !shortmess(SHM_FILEINFO)) {\n    fileinfo(false, true, false);\n    need_fileinfo = false;\n  }\n\n  emsg_on_display = false;  // can delete error message now\n  did_emsg = false;\n  msg_didany = false;  // reset lines_left in msg_start()\n  may_clear_sb_text();  // clear scroll-back text on next msg\n  showruler(false);\n\n  setcursor();\n}\n\n// Function executed before each iteration of normal mode.\n// Return:\n//   1 if the iteration should continue normally\n//   -1 if the iteration should be skipped\n//   0 if the main loop must exit\nstatic int normal_check(VimState *state)\n{\n  NormalState *s = (NormalState *)state;\n  normal_check_stuff_buffer(s);\n  normal_check_interrupt(s);\n\n  if (!exmode_active) {\n    msg_scroll = false;\n  }\n  quit_more = false;\n\n  // If skip redraw is set (for \":\" in wait_return()), don't redraw now.\n  // If there is nothing in the stuff_buffer or do_redraw is true,\n  // update cursor and redraw.\n  if (skip_redraw || exmode_active) {\n    skip_redraw = false;\n  } else if (do_redraw || stuff_empty()) {\n    // Need to make sure w_topline and w_leftcol are correct before\n    // normal_check_window_scrolled() is called.\n    update_topline(curwin);\n\n    normal_check_cursor_moved(s);\n    normal_check_text_changed(s);\n    normal_check_window_scrolled(s);\n    normal_check_buffer_modified(s);\n\n    // Updating diffs from changed() does not always work properly,\n    // esp. updating folds.  Do an update just before redrawing if\n    // needed.\n    if (curtab->tp_diff_update || curtab->tp_diff_invalid) {\n      ex_diffupdate(NULL);\n      curtab->tp_diff_update = false;\n    }\n\n    // Scroll-binding for diff mode may have been postponed until\n    // here.  Avoids doing it for every change.\n    if (diff_need_scrollbind) {\n      check_scrollbind((linenr_T)0, 0L);\n      diff_need_scrollbind = false;\n    }\n\n    normal_check_folds(s);\n    normal_redraw(s);\n    do_redraw = false;\n\n    // Now that we have drawn the first screen all the startup stuff\n    // has been done, close any file for startup messages.\n    if (time_fd != NULL) {\n      TIME_MSG(\"first screen update\");\n      TIME_MSG(\"--- NVIM STARTED ---\");\n      fclose(time_fd);\n      time_fd = NULL;\n    }\n  }\n\n  // May perform garbage collection when waiting for a character, but\n  // only at the very toplevel.  Otherwise we may be using a List or\n  // Dict internally somewhere.\n  // \"may_garbage_collect\" is reset in vgetc() which is invoked through\n  // do_exmode() and normal_cmd().\n  may_garbage_collect = !s->cmdwin && !s->noexmode;\n\n  // Update w_curswant if w_set_curswant has been set.\n  // Postponed until here to avoid computing w_virtcol too often.\n  update_curswant();\n\n  if (exmode_active) {\n    if (s->noexmode) {\n      return 0;\n    }\n    do_exmode();\n    return -1;\n  }\n\n  if (s->cmdwin && cmdwin_result != 0) {\n    // command-line window and cmdwin_result is set\n    return 0;\n  }\n\n  normal_prepare(s);\n  return 1;\n}\n\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is true.\n */\nstatic void set_vcount_ca(cmdarg_T *cap, bool *set_prevcount)\n{\n  long count = cap->count0;\n\n  /* multiply with cap->opcount the same way as above */\n  if (cap->opcount != 0)\n    count = cap->opcount * (count == 0 ? 1 : count);\n  set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n  *set_prevcount = false;    /* only set v:prevcount once */\n}\n\n// Handle an operator after Visual mode or when the movement is finished.\n// \"gui_yank\" is true when yanking text for the clipboard.\nvoid do_pending_operator(cmdarg_T *cap, int old_col, bool gui_yank)\n{\n  oparg_T     *oap = cap->oap;\n  pos_T old_cursor;\n  bool empty_region_error;\n  int restart_edit_save;\n  int lbr_saved = curwin->w_p_lbr;\n\n\n  // The visual area is remembered for redo\n  static int redo_VIsual_mode = NUL;        // 'v', 'V', or Ctrl-V\n  static linenr_T redo_VIsual_line_count;   // number of lines\n  static colnr_T redo_VIsual_vcol;          // number of cols or end column\n  static long redo_VIsual_count;            // count for Visual operator\n  static int redo_VIsual_arg;               // extra argument\n  bool include_line_break = false;\n\n  old_cursor = curwin->w_cursor;\n\n  /*\n   * If an operation is pending, handle it...\n   */\n  if ((finish_op\n       || VIsual_active)\n      && oap->op_type != OP_NOP) {\n    // Yank can be redone when 'y' is in 'cpoptions', but not when yanking\n    // for the clipboard.\n    const bool redo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL && !gui_yank;\n\n    // Avoid a problem with unwanted linebreaks in block mode\n    if (curwin->w_p_lbr) {\n      curwin->w_valid &= ~VALID_VIRTCOL;\n    }\n    curwin->w_p_lbr = false;\n    oap->is_VIsual = VIsual_active;\n    if (oap->motion_force == 'V') {\n      oap->motion_type = kMTLineWise;\n    } else if (oap->motion_force == 'v') {\n      // If the motion was linewise, \"inclusive\" will not have been set.\n      // Use \"exclusive\" to be consistent.  Makes \"dvj\" work nice.\n      if (oap->motion_type == kMTLineWise) {\n        oap->inclusive = false;\n      } else if (oap->motion_type == kMTCharWise) {\n        // If the motion already was charwise, toggle \"inclusive\"\n        oap->inclusive = !oap->inclusive;\n      }\n      oap->motion_type = kMTCharWise;\n    } else if (oap->motion_force == Ctrl_V) {\n      // Change line- or charwise motion into Visual block mode.\n      if (!VIsual_active) {\n        VIsual_active = true;\n        VIsual = oap->start;\n      }\n      VIsual_mode = Ctrl_V;\n      VIsual_select = false;\n      VIsual_reselect = false;\n    }\n\n    // Only redo yank when 'y' flag is in 'cpoptions'.\n    // Never redo \"zf\" (define fold).\n    if ((redo_yank || oap->op_type != OP_YANK)\n        && ((!VIsual_active || oap->motion_force)\n            // Also redo Operator-pending Visual mode mappings.\n            || ((cap->cmdchar == ':' || cap->cmdchar == K_COMMAND)\n                && oap->op_type != OP_COLON))\n        && cap->cmdchar != 'D'\n        && oap->op_type != OP_FOLD\n        && oap->op_type != OP_FOLDOPEN\n        && oap->op_type != OP_FOLDOPENREC\n        && oap->op_type != OP_FOLDCLOSE\n        && oap->op_type != OP_FOLDCLOSEREC\n        && oap->op_type != OP_FOLDDEL\n        && oap->op_type != OP_FOLDDELREC\n        ) {\n      prep_redo(oap->regname, cap->count0,\n          get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n          oap->motion_force, cap->cmdchar, cap->nchar);\n      if (cap->cmdchar == '/' || cap->cmdchar == '?') {     /* was a search */\n        /*\n         * If 'cpoptions' does not contain 'r', insert the search\n         * pattern to really repeat the same command.\n         */\n        if (vim_strchr(p_cpo, CPO_REDO) == NULL) {\n          AppendToRedobuffLit(cap->searchbuf, -1);\n        }\n        AppendToRedobuff(NL_STR);\n      } else if (cap->cmdchar == ':' || cap->cmdchar == K_COMMAND) {\n        // do_cmdline() has stored the first typed line in\n        // \"repeat_cmdline\".  When several lines are typed repeating\n        // won't be possible.\n        if (repeat_cmdline == NULL) {\n          ResetRedobuff();\n        } else {\n          AppendToRedobuffLit(repeat_cmdline, -1);\n          AppendToRedobuff(NL_STR);\n          XFREE_CLEAR(repeat_cmdline);\n        }\n      }\n    }\n\n    if (redo_VIsual_busy) {\n      /* Redo of an operation on a Visual area. Use the same size from\n       * redo_VIsual_line_count and redo_VIsual_vcol. */\n      oap->start = curwin->w_cursor;\n      curwin->w_cursor.lnum += redo_VIsual_line_count - 1;\n      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      VIsual_mode = redo_VIsual_mode;\n      if (redo_VIsual_vcol == MAXCOL || VIsual_mode == 'v') {\n        if (VIsual_mode == 'v') {\n          if (redo_VIsual_line_count <= 1) {\n            validate_virtcol();\n            curwin->w_curswant =\n              curwin->w_virtcol + redo_VIsual_vcol - 1;\n          } else\n            curwin->w_curswant = redo_VIsual_vcol;\n        } else {\n          curwin->w_curswant = MAXCOL;\n        }\n        coladvance(curwin->w_curswant);\n      }\n      cap->count0 = redo_VIsual_count;\n      cap->count1 = (cap->count0 == 0 ? 1 : cap->count0);\n    } else if (VIsual_active) {\n      if (!gui_yank) {\n        /* Save the current VIsual area for '< and '> marks, and \"gv\" */\n        curbuf->b_visual.vi_start = VIsual;\n        curbuf->b_visual.vi_end = curwin->w_cursor;\n        curbuf->b_visual.vi_mode = VIsual_mode;\n        if (VIsual_mode_orig != NUL) {\n          curbuf->b_visual.vi_mode = VIsual_mode_orig;\n          VIsual_mode_orig = NUL;\n        }\n        curbuf->b_visual.vi_curswant = curwin->w_curswant;\n        curbuf->b_visual_mode_eval = VIsual_mode;\n      }\n\n      // In Select mode, a linewise selection is operated upon like a\n      // charwise selection.\n      // Special case: gH<Del> deletes the last line.\n      if (VIsual_select && VIsual_mode == 'V'\n          && cap->oap->op_type != OP_DELETE) {\n        if (lt(VIsual, curwin->w_cursor)) {\n          VIsual.col = 0;\n          curwin->w_cursor.col =\n            (colnr_T)STRLEN(ml_get(curwin->w_cursor.lnum));\n        } else {\n          curwin->w_cursor.col = 0;\n          VIsual.col = (colnr_T)STRLEN(ml_get(VIsual.lnum));\n        }\n        VIsual_mode = 'v';\n      }\n      /* If 'selection' is \"exclusive\", backup one character for\n       * charwise selections. */\n      else if (VIsual_mode == 'v') {\n        include_line_break =\n          unadjust_for_sel();\n      }\n\n      oap->start = VIsual;\n      if (VIsual_mode == 'V') {\n        oap->start.col = 0;\n        oap->start.coladd = 0;\n      }\n    }\n\n    /*\n     * Set oap->start to the first position of the operated text, oap->end\n     * to the end of the operated text.  w_cursor is equal to oap->start.\n     */\n    if (lt(oap->start, curwin->w_cursor)) {\n      /* Include folded lines completely. */\n      if (!VIsual_active) {\n        if (hasFolding(oap->start.lnum, &oap->start.lnum, NULL))\n          oap->start.col = 0;\n        if ((curwin->w_cursor.col > 0\n             || oap->inclusive\n             || oap->motion_type == kMTLineWise)\n            && hasFolding(curwin->w_cursor.lnum, NULL,\n                          &curwin->w_cursor.lnum)) {\n          curwin->w_cursor.col = (colnr_T)STRLEN(get_cursor_line_ptr());\n        }\n      }\n      oap->end = curwin->w_cursor;\n      curwin->w_cursor = oap->start;\n\n      /* w_virtcol may have been updated; if the cursor goes back to its\n       * previous position w_virtcol becomes invalid and isn't updated\n       * automatically. */\n      curwin->w_valid &= ~VALID_VIRTCOL;\n    } else {\n      // Include folded lines completely.\n      if (!VIsual_active && oap->motion_type == kMTLineWise) {\n        if (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum,\n                       NULL)) {\n          curwin->w_cursor.col = 0;\n        }\n        if (hasFolding(oap->start.lnum, NULL, &oap->start.lnum)) {\n          oap->start.col = (colnr_T)STRLEN(ml_get(oap->start.lnum));\n        }\n      }\n      oap->end = oap->start;\n      oap->start = curwin->w_cursor;\n    }\n\n    // Just in case lines were deleted that make the position invalid.\n    check_pos(curwin->w_buffer, &oap->end);\n    oap->line_count = oap->end.lnum - oap->start.lnum + 1;\n\n    /* Set \"virtual_op\" before resetting VIsual_active. */\n    virtual_op = virtual_active();\n\n    if (VIsual_active || redo_VIsual_busy) {\n      get_op_vcol(oap, redo_VIsual_vcol, true);\n\n      if (!redo_VIsual_busy && !gui_yank) {\n        /*\n         * Prepare to reselect and redo Visual: this is based on the\n         * size of the Visual text\n         */\n        resel_VIsual_mode = VIsual_mode;\n        if (curwin->w_curswant == MAXCOL)\n          resel_VIsual_vcol = MAXCOL;\n        else {\n          if (VIsual_mode != Ctrl_V)\n            getvvcol(curwin, &(oap->end),\n                NULL, NULL, &oap->end_vcol);\n          if (VIsual_mode == Ctrl_V || oap->line_count <= 1) {\n            if (VIsual_mode != Ctrl_V)\n              getvvcol(curwin, &(oap->start),\n                  &oap->start_vcol, NULL, NULL);\n            resel_VIsual_vcol = oap->end_vcol - oap->start_vcol + 1;\n          } else\n            resel_VIsual_vcol = oap->end_vcol;\n        }\n        resel_VIsual_line_count = oap->line_count;\n      }\n\n      // can't redo yank (unless 'y' is in 'cpoptions') and \":\"\n      if ((redo_yank || oap->op_type != OP_YANK)\n          && oap->op_type != OP_COLON\n          && oap->op_type != OP_FOLD\n          && oap->op_type != OP_FOLDOPEN\n          && oap->op_type != OP_FOLDOPENREC\n          && oap->op_type != OP_FOLDCLOSE\n          && oap->op_type != OP_FOLDCLOSEREC\n          && oap->op_type != OP_FOLDDEL\n          && oap->op_type != OP_FOLDDELREC\n          && oap->motion_force == NUL\n          ) {\n        /* Prepare for redoing.  Only use the nchar field for \"r\",\n         * otherwise it might be the second char of the operator. */\n        if (cap->cmdchar == 'g' && (cap->nchar == 'n'\n                                    || cap->nchar == 'N')) {\n          prep_redo(oap->regname, cap->count0,\n                    get_op_char(oap->op_type), get_extra_op_char(oap->op_type),\n                    oap->motion_force, cap->cmdchar, cap->nchar);\n        } else if (cap->cmdchar != ':' && cap->cmdchar != K_COMMAND) {\n          int nchar = oap->op_type == OP_REPLACE ? cap->nchar : NUL;\n\n          // reverse what nv_replace() did\n          if (nchar == REPLACE_CR_NCHAR) {\n            nchar = CAR;\n          } else if (nchar == REPLACE_NL_NCHAR) {\n            nchar = NL;\n          }\n          prep_redo(oap->regname, 0L, NUL, 'v', get_op_char(oap->op_type),\n                    get_extra_op_char(oap->op_type), nchar);\n        }\n        if (!redo_VIsual_busy) {\n          redo_VIsual_mode = resel_VIsual_mode;\n          redo_VIsual_vcol = resel_VIsual_vcol;\n          redo_VIsual_line_count = resel_VIsual_line_count;\n          redo_VIsual_count = cap->count0;\n          redo_VIsual_arg = cap->arg;\n        }\n      }\n\n      // oap->inclusive defaults to true.\n      // If oap->end is on a NUL (empty line) oap->inclusive becomes\n      // false.  This makes \"d}P\" and \"v}dP\" work the same.\n      if (oap->motion_force == NUL || oap->motion_type == kMTLineWise) {\n        oap->inclusive = true;\n      }\n      if (VIsual_mode == 'V') {\n        oap->motion_type = kMTLineWise;\n      } else if (VIsual_mode == 'v') {\n        oap->motion_type = kMTCharWise;\n        if (*ml_get_pos(&(oap->end)) == NUL\n            && (include_line_break || !virtual_op)\n            ) {\n          oap->inclusive = false;\n          // Try to include the newline, unless it's an operator\n          // that works on lines only.\n          if (*p_sel != 'o'\n              && !op_on_lines(oap->op_type)\n              && oap->end.lnum < curbuf->b_ml.ml_line_count) {\n            oap->end.lnum++;\n            oap->end.col = 0;\n            oap->end.coladd = 0;\n            oap->line_count++;\n          }\n        }\n      }\n\n      redo_VIsual_busy = false;\n\n      /*\n       * Switch Visual off now, so screen updating does\n       * not show inverted text when the screen is redrawn.\n       * With OP_YANK and sometimes with OP_COLON and OP_FILTER there is\n       * no screen redraw, so it is done here to remove the inverted\n       * part.\n       */\n      if (!gui_yank) {\n        VIsual_active = false;\n        setmouse();\n        mouse_dragging = 0;\n        may_clear_cmdline();\n        if ((oap->op_type == OP_YANK\n             || oap->op_type == OP_COLON\n             || oap->op_type == OP_FUNCTION\n             || oap->op_type == OP_FILTER)\n            && oap->motion_force == NUL) {\n          // Make sure redrawing is correct.\n          curwin->w_p_lbr = lbr_saved;\n          redraw_curbuf_later(INVERTED);\n        }\n      }\n    }\n\n    // Include the trailing byte of a multi-byte char.\n    if (oap->inclusive) {\n      const int l = utfc_ptr2len(ml_get_pos(&oap->end));\n      if (l > 1) {\n        oap->end.col += l - 1;\n      }\n    }\n    curwin->w_set_curswant = true;\n\n    /*\n     * oap->empty is set when start and end are the same.  The inclusive\n     * flag affects this too, unless yanking and the end is on a NUL.\n     */\n    oap->empty = (oap->motion_type != kMTLineWise\n                  && (!oap->inclusive\n                      || (oap->op_type == OP_YANK\n                          && gchar_pos(&oap->end) == NUL))\n                  && equalpos(oap->start, oap->end)\n                  && !(virtual_op && oap->start.coladd != oap->end.coladd)\n                  );\n    /*\n     * For delete, change and yank, it's an error to operate on an\n     * empty region, when 'E' included in 'cpoptions' (Vi compatible).\n     */\n    empty_region_error = (oap->empty\n                          && vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);\n\n    /* Force a redraw when operating on an empty Visual region, when\n     * 'modifiable is off or creating a fold. */\n    if (oap->is_VIsual && (oap->empty || !MODIFIABLE(curbuf)\n                           || oap->op_type == OP_FOLD\n                           )) {\n      curwin->w_p_lbr = lbr_saved;\n      redraw_curbuf_later(INVERTED);\n    }\n\n    /*\n     * If the end of an operator is in column one while oap->motion_type\n     * is kMTCharWise and oap->inclusive is false, we put op_end after the last\n     * character in the previous line. If op_start is on or before the\n     * first non-blank in the line, the operator becomes linewise\n     * (strange, but that's the way vi does it).\n     */\n    if (oap->motion_type == kMTCharWise\n        && oap->inclusive == false\n        && !(cap->retval & CA_NO_ADJ_OP_END)\n        && oap->end.col == 0\n        && (!oap->is_VIsual || *p_sel == 'o')\n        && oap->line_count > 1) {\n      oap->end_adjusted = true;  // remember that we did this\n      oap->line_count--;\n      oap->end.lnum--;\n      if (inindent(0)) {\n        oap->motion_type = kMTLineWise;\n      } else {\n        oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n        if (oap->end.col) {\n          --oap->end.col;\n          oap->inclusive = true;\n        }\n      }\n    } else\n      oap->end_adjusted = false;\n\n    switch (oap->op_type) {\n    case OP_LSHIFT:\n    case OP_RSHIFT:\n      op_shift(oap, true,\n          oap->is_VIsual ? (int)cap->count1 :\n          1);\n      auto_format(false, true);\n      break;\n\n    case OP_JOIN_NS:\n    case OP_JOIN:\n      if (oap->line_count < 2)\n        oap->line_count = 2;\n      if (curwin->w_cursor.lnum + oap->line_count - 1 >\n          curbuf->b_ml.ml_line_count) {\n        beep_flush();\n      } else {\n        do_join((size_t)oap->line_count, oap->op_type == OP_JOIN,\n                true, true, true);\n        auto_format(false, true);\n      }\n      break;\n\n    case OP_DELETE:\n      VIsual_reselect = false;              /* don't reselect now */\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else {\n        (void)op_delete(oap);\n        // save cursor line for undo if it wasn't saved yet\n        if (oap->motion_type == kMTLineWise\n            && has_format_option(FO_AUTO)\n            && u_save_cursor() == OK) {\n          auto_format(false, true);\n        }\n      }\n      break;\n\n    case OP_YANK:\n      if (empty_region_error) {\n        if (!gui_yank) {\n          vim_beep(BO_OPER);\n          CancelRedo();\n        }\n      } else {\n        curwin->w_p_lbr = lbr_saved;\n        oap->excl_tr_ws = cap->cmdchar == 'z';\n        (void)op_yank(oap, !gui_yank, false);\n      }\n      check_cursor_col();\n      break;\n\n    case OP_CHANGE:\n      VIsual_reselect = false;              /* don't reselect now */\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else {\n        /* This is a new edit command, not a restart.  Need to\n         * remember it to make 'insertmode' work with mappings for\n         * Visual mode.  But do this only once and not when typed and\n         * 'insertmode' isn't set. */\n        if (p_im || !KeyTyped)\n          restart_edit_save = restart_edit;\n        else\n          restart_edit_save = 0;\n        restart_edit = 0;\n\n        // Restore linebreak, so that when the user edits it looks as before.\n        curwin->w_p_lbr = lbr_saved;\n\n        // Reset finish_op now, don't want it set inside edit().\n        finish_op = false;\n        if (op_change(oap))             /* will call edit() */\n          cap->retval |= CA_COMMAND_BUSY;\n        if (restart_edit == 0)\n          restart_edit = restart_edit_save;\n      }\n      break;\n\n    case OP_FILTER:\n      if (vim_strchr(p_cpo, CPO_FILTER) != NULL) {\n        AppendToRedobuff(\"!\\r\");  // Use any last used !cmd.\n      } else {\n        bangredo = true;  // do_bang() will put cmd in redo buffer.\n      }\n      FALLTHROUGH;\n\n    case OP_INDENT:\n    case OP_COLON:\n\n      /*\n       * If 'equalprg' is empty, do the indenting internally.\n       */\n      if (oap->op_type == OP_INDENT && *get_equalprg() == NUL) {\n        if (curbuf->b_p_lisp) {\n          op_reindent(oap, get_lisp_indent);\n          break;\n        }\n        op_reindent(oap,\n            *curbuf->b_p_inde != NUL ? get_expr_indent :\n            get_c_indent);\n        break;\n      }\n\n      op_colon(oap);\n      break;\n\n    case OP_TILDE:\n    case OP_UPPER:\n    case OP_LOWER:\n    case OP_ROT13:\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else\n        op_tilde(oap);\n      check_cursor_col();\n      break;\n\n    case OP_FORMAT:\n      if (*curbuf->b_p_fex != NUL) {\n        op_formatexpr(oap);             // use expression\n      } else {\n        if (*p_fp != NUL || *curbuf->b_p_fp != NUL) {\n          op_colon(oap);                // use external command\n        } else {\n          op_format(oap, false);        // use internal function\n        }\n      }\n      break;\n\n    case OP_FORMAT2:\n      op_format(oap, true);             /* use internal function */\n      break;\n\n    case OP_FUNCTION:\n      // Restore linebreak, so that when the user edits it looks as\n      // before.\n      curwin->w_p_lbr = lbr_saved;\n      op_function(oap);                 // call 'operatorfunc'\n      break;\n\n    case OP_INSERT:\n    case OP_APPEND:\n      VIsual_reselect = false;          /* don't reselect now */\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else {\n        /* This is a new edit command, not a restart.  Need to\n         * remember it to make 'insertmode' work with mappings for\n         * Visual mode.  But do this only once. */\n        restart_edit_save = restart_edit;\n        restart_edit = 0;\n\n        // Restore linebreak, so that when the user edits it looks as before.\n        curwin->w_p_lbr = lbr_saved;\n\n        op_insert(oap, cap->count1);\n\n        // Reset linebreak, so that formatting works correctly.\n        curwin->w_p_lbr = false;\n\n        /* TODO: when inserting in several lines, should format all\n         * the lines. */\n        auto_format(false, true);\n\n        if (restart_edit == 0) {\n          restart_edit = restart_edit_save;\n        } else {\n          cap->retval |= CA_COMMAND_BUSY;\n        }\n      }\n      break;\n\n    case OP_REPLACE:\n      VIsual_reselect = false;          /* don't reselect now */\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else {\n        // Restore linebreak, so that when the user edits it looks as before.\n        curwin->w_p_lbr = lbr_saved;\n\n        op_replace(oap, cap->nchar);\n      }\n      break;\n\n    case OP_FOLD:\n      VIsual_reselect = false;          // don't reselect now\n      foldCreate(curwin, oap->start, oap->end);\n      break;\n\n    case OP_FOLDOPEN:\n    case OP_FOLDOPENREC:\n    case OP_FOLDCLOSE:\n    case OP_FOLDCLOSEREC:\n      VIsual_reselect = false;          // don't reselect now\n      opFoldRange(oap->start, oap->end,\n                  oap->op_type == OP_FOLDOPEN\n                  || oap->op_type == OP_FOLDOPENREC,\n                  oap->op_type == OP_FOLDOPENREC\n                  || oap->op_type == OP_FOLDCLOSEREC,\n                  oap->is_VIsual);\n      break;\n\n    case OP_FOLDDEL:\n    case OP_FOLDDELREC:\n      VIsual_reselect = false;          // don't reselect now\n      deleteFold(curwin, oap->start.lnum, oap->end.lnum,\n                 oap->op_type == OP_FOLDDELREC, oap->is_VIsual);\n      break;\n\n    case OP_NR_ADD:\n    case OP_NR_SUB:\n      if (empty_region_error) {\n        vim_beep(BO_OPER);\n        CancelRedo();\n      } else {\n        VIsual_active = true;\n        curwin->w_p_lbr = lbr_saved;\n        op_addsub(oap, cap->count1, redo_VIsual_arg);\n        VIsual_active = false;\n      }\n      check_cursor_col();\n      break;\n    default:\n      clearopbeep(oap);\n    }\n    virtual_op = kNone;\n    if (!gui_yank) {\n      /*\n       * if 'sol' not set, go back to old column for some commands\n       */\n      if (!p_sol && oap->motion_type == kMTLineWise && !oap->end_adjusted\n          && (oap->op_type == OP_LSHIFT || oap->op_type == OP_RSHIFT\n              || oap->op_type == OP_DELETE)) {\n        curwin->w_p_lbr = false;\n        coladvance(curwin->w_curswant = old_col);\n      }\n    } else {\n      curwin->w_cursor = old_cursor;\n    }\n    clearop(oap);\n    motion_force = NUL;\n  }\n  curwin->w_p_lbr = lbr_saved;\n}\n\n/*\n * Handle indent and format operators and visual mode \":\".\n */\nstatic void op_colon(oparg_T *oap)\n{\n  stuffcharReadbuff(':');\n  if (oap->is_VIsual) {\n    stuffReadbuff(\"'<,'>\");\n  } else {\n    // Make the range look nice, so it can be repeated.\n    if (oap->start.lnum == curwin->w_cursor.lnum) {\n      stuffcharReadbuff('.');\n    } else {\n      stuffnumReadbuff((long)oap->start.lnum);\n    }\n    if (oap->end.lnum != oap->start.lnum) {\n      stuffcharReadbuff(',');\n      if (oap->end.lnum == curwin->w_cursor.lnum) {\n        stuffcharReadbuff('.');\n      } else if (oap->end.lnum == curbuf->b_ml.ml_line_count) {\n        stuffcharReadbuff('$');\n      } else if (oap->start.lnum == curwin->w_cursor.lnum) {\n        stuffReadbuff(\".+\");\n        stuffnumReadbuff(oap->line_count - 1);\n      } else {\n        stuffnumReadbuff((long)oap->end.lnum);\n      }\n    }\n  }\n  if (oap->op_type != OP_COLON) {\n    stuffReadbuff(\"!\");\n  }\n  if (oap->op_type == OP_INDENT) {\n    stuffReadbuff((const char *)get_equalprg());\n    stuffReadbuff(\"\\n\");\n  } else if (oap->op_type == OP_FORMAT) {\n    if (*curbuf->b_p_fp != NUL) {\n      stuffReadbuff((const char *)curbuf->b_p_fp);\n    } else if (*p_fp != NUL) {\n      stuffReadbuff((const char *)p_fp);\n    } else {\n      stuffReadbuff(\"fmt\");\n    }\n    stuffReadbuff(\"\\n']\");\n  }\n\n  /*\n   * do_cmdline() does the rest\n   */\n}\n\n/*\n * Handle the \"g@\" operator: call 'operatorfunc'.\n */\nstatic void op_function(const oparg_T *oap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const TriState save_virtual_op = virtual_op;\n\n  if (*p_opfunc == NUL)\n    EMSG(_(\"E774: 'operatorfunc' is empty\"));\n  else {\n    /* Set '[ and '] marks to text to be operated on. */\n    curbuf->b_op_start = oap->start;\n    curbuf->b_op_end = oap->end;\n    if (oap->motion_type != kMTLineWise && !oap->inclusive) {\n      // Exclude the end position.\n      decl(&curbuf->b_op_end);\n    }\n\n    typval_T argv[2];\n    argv[0].v_type = VAR_STRING;\n    argv[1].v_type = VAR_UNKNOWN;\n    argv[0].vval.v_string =\n      (char_u *)(((const char *const[]) {\n        [kMTBlockWise] = \"block\",\n        [kMTLineWise] = \"line\",\n        [kMTCharWise] = \"char\",\n      })[oap->motion_type]);\n\n    // Reset virtual_op so that 'virtualedit' can be changed in the\n    // function.\n    virtual_op = kNone;\n\n    (void)call_func_retnr(p_opfunc, 1, argv);\n\n    virtual_op = save_virtual_op;\n  }\n}\n\n// Move the current tab to tab in same column as mouse or to end of the\n// tabline if there is no tab there.\nstatic void move_tab_to_mouse(void)\n{\n  int tabnr = tab_page_click_defs[mouse_col].tabnr;\n  if (tabnr <= 0) {\n      tabpage_move(9999);\n  } else if (tabnr < tabpage_index(curtab)) {\n      tabpage_move(tabnr - 1);\n  } else {\n      tabpage_move(tabnr);\n  }\n}\n\n/*\n * Do the appropriate action for the current mouse click in the current mode.\n * Not used for Command-line mode.\n *\n * Normal Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t    end\t\t    yes\n * left press\t  C\tyes\t    end\t\t    yes\t    \"^]\" (2)\n * left press\t  S\tyes\t    end\t\t    yes\t    \"*\" (2)\n * left drag\t  -\tyes\tstart if moved\t    no\n * left relse\t  -\tyes\tstart if moved\t    no\n * middle press\t  -\tyes\t if not active\t    no\t    put register\n * middle press\t  -\tyes\t if active\t    no\t    yank and put\n * right press\t  -\tyes\tstart or extend\t    yes\n * right press\t  S\tyes\tno change\t    yes\t    \"#\" (2)\n * right drag\t  -\tyes\textend\t\t    no\n * right relse\t  -\tyes\textend\t\t    no\n *\n * Insert or Replace Mode:\n * event\t modi-\tposition      visual\t   change   action\n *\t\t fier\tcursor\t\t\t   window\n * left press\t  -\tyes\t(cannot be active)  yes\n * left press\t  C\tyes\t(cannot be active)  yes\t    \"CTRL-O^]\" (2)\n * left press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O*\" (2)\n * left drag\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * left relse\t  -\tyes\tstart or extend (1) no\t    CTRL-O (1)\n * middle press\t  -\tno\t(cannot be active)  no\t    put register\n * right press\t  -\tyes\tstart or extend\t    yes\t    CTRL-O\n * right press\t  S\tyes\t(cannot be active)  yes\t    \"CTRL-O#\" (2)\n *\n * (1) only if mouse pointer moved since press\n * (2) only if click is in same buffer\n *\n * Return true if start_arrow() should be called for edit mode.\n */\nbool\ndo_mouse (\n    oparg_T *oap,               /* operator argument, can be NULL */\n    int c,                          /* K_LEFTMOUSE, etc */\n    int dir,                        /* Direction to 'put' if necessary */\n    long count,\n    bool fixindent                  /* PUT_FIXINDENT if fixing indent necessary */\n)\n{\n  static bool got_click = false;        /* got a click some time back */\n\n  int which_button;             /* MOUSE_LEFT, _MIDDLE or _RIGHT */\n  bool is_click;                /* If false it's a drag or release event */\n  bool is_drag;                 /* If true it's a drag event */\n  int jump_flags = 0;           /* flags for jump_to_mouse() */\n  pos_T start_visual;\n  bool moved;                   /* Has cursor moved? */\n  bool in_status_line;          /* mouse in status line */\n  static bool in_tab_line = false;   /* mouse clicked in tab line */\n  bool in_sep_line;             /* mouse in vertical separator line */\n  int c1, c2;\n  pos_T save_cursor;\n  win_T       *old_curwin = curwin;\n  static pos_T orig_cursor;\n  colnr_T leftcol, rightcol;\n  pos_T end_visual;\n  long diff;\n  int old_active = VIsual_active;\n  int old_mode = VIsual_mode;\n  int regname;\n\n  save_cursor = curwin->w_cursor;\n\n  for (;; ) {\n    which_button = get_mouse_button(KEY2TERMCAP1(c), &is_click, &is_drag);\n    if (is_drag) {\n      /* If the next character is the same mouse event then use that\n       * one. Speeds up dragging the status line. */\n      if (vpeekc() != NUL) {\n        int nc;\n        int save_mouse_grid = mouse_grid;\n        int save_mouse_row = mouse_row;\n        int save_mouse_col = mouse_col;\n\n        /* Need to get the character, peeking doesn't get the actual\n         * one. */\n        nc = safe_vgetc();\n        if (c == nc)\n          continue;\n        vungetc(nc);\n        mouse_grid = save_mouse_grid;\n        mouse_row = save_mouse_row;\n        mouse_col = save_mouse_col;\n      }\n    }\n    break;\n  }\n\n  if (c == K_MOUSEMOVE) {\n    // Mouse moved without a button pressed.\n    return false;\n  }\n\n  /*\n   * Ignore drag and release events if we didn't get a click.\n   */\n  if (is_click)\n    got_click = true;\n  else {\n    if (!got_click)                     /* didn't get click, ignore */\n      return false;\n    if (!is_drag) {                     /* release, reset got_click */\n      got_click = false;\n      if (in_tab_line) {\n        in_tab_line = false;\n        return false;\n      }\n    }\n  }\n\n\n  /*\n   * CTRL right mouse button does CTRL-T\n   */\n  if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT) {\n    if (State & INSERT)\n      stuffcharReadbuff(Ctrl_O);\n    if (count > 1)\n      stuffnumReadbuff(count);\n    stuffcharReadbuff(Ctrl_T);\n    got_click = false;                  /* ignore drag&release now */\n    return false;\n  }\n\n  /*\n   * CTRL only works with left mouse button\n   */\n  if ((mod_mask & MOD_MASK_CTRL) && which_button != MOUSE_LEFT)\n    return false;\n\n  /*\n   * When a modifier is down, ignore drag and release events, as well as\n   * multiple clicks and the middle mouse button.\n   * Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\".\n   */\n  if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n                   | MOD_MASK_META))\n      && (!is_click\n          || (mod_mask & MOD_MASK_MULTI_CLICK)\n          || which_button == MOUSE_MIDDLE)\n      && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n           && mouse_model_popup()\n           && which_button == MOUSE_LEFT)\n      && !((mod_mask & MOD_MASK_ALT)\n           && !mouse_model_popup()\n           && which_button == MOUSE_RIGHT)\n      )\n    return false;\n\n  /*\n   * If the button press was used as the movement command for an operator\n   * (eg \"d<MOUSE>\"), or it is the middle button that is held down, ignore\n   * drag/release events.\n   */\n  if (!is_click && which_button == MOUSE_MIDDLE)\n    return false;\n\n  if (oap != NULL)\n    regname = oap->regname;\n  else\n    regname = 0;\n\n  /*\n   * Middle mouse button does a 'put' of the selected text\n   */\n  if (which_button == MOUSE_MIDDLE) {\n    if (State == NORMAL) {\n      /*\n       * If an operator was pending, we don't know what the user wanted\n       * to do. Go back to normal mode: Clear the operator and beep().\n       */\n      if (oap != NULL && oap->op_type != OP_NOP) {\n        clearopbeep(oap);\n        return false;\n      }\n\n      /*\n       * If visual was active, yank the highlighted text and put it\n       * before the mouse pointer position.\n       * In Select mode replace the highlighted text with the clipboard.\n       */\n      if (VIsual_active) {\n        if (VIsual_select) {\n          stuffcharReadbuff(Ctrl_G);\n          stuffReadbuff(\"\\\"+p\");\n        } else {\n          stuffcharReadbuff('y');\n          stuffcharReadbuff(K_MIDDLEMOUSE);\n        }\n        return false;\n      }\n      /*\n       * The rest is below jump_to_mouse()\n       */\n    } else if ((State & INSERT) == 0)\n      return false;\n\n    /*\n     * Middle click in insert mode doesn't move the mouse, just insert the\n     * contents of a register.  '.' register is special, can't insert that\n     * with do_put().\n     * Also paste at the cursor if the current mode isn't in 'mouse' (only\n     * happens for the GUI).\n     */\n    if ((State & INSERT)) {\n      if (regname == '.') {\n        insert_reg(regname, true);\n      } else {\n        if (regname == 0 && eval_has_provider(\"clipboard\")) {\n          regname = '*';\n        }\n        if ((State & REPLACE_FLAG) && !yank_register_mline(regname)) {\n          insert_reg(regname, true);\n        } else {\n          do_put(regname, NULL, BACKWARD, 1L,\n                 (fixindent ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n\n          /* Repeat it with CTRL-R CTRL-O r or CTRL-R CTRL-P r */\n          AppendCharToRedobuff(Ctrl_R);\n          AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n          AppendCharToRedobuff(regname == 0 ? '\"' : regname);\n        }\n      }\n      return false;\n    }\n  }\n\n  /* When dragging or button-up stay in the same window. */\n  if (!is_click)\n    jump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n  start_visual.lnum = 0;\n\n  // Check for clicking in the tab page line.\n  if (mouse_grid <= 1 && mouse_row == 0 && firstwin->w_winrow > 0) {\n    if (is_drag) {\n      if (in_tab_line) {\n        move_tab_to_mouse();\n      }\n      return false;\n    }\n\n    /* click in a tab selects that tab page */\n    if (is_click\n        && cmdwin_type == 0\n        && mouse_col < Columns) {\n      in_tab_line = true;\n      c1 = tab_page_click_defs[mouse_col].tabnr;\n      switch (tab_page_click_defs[mouse_col].type) {\n        case kStlClickDisabled: {\n          break;\n        }\n        case kStlClickTabClose: {\n          tabpage_T *tp;\n\n          // Close the current or specified tab page.\n          if (c1 == 999) {\n            tp = curtab;\n          } else {\n            tp = find_tabpage(c1);\n          }\n          if (tp == curtab) {\n            if (first_tabpage->tp_next != NULL) {\n              tabpage_close(false);\n            }\n          } else if (tp != NULL) {\n            tabpage_close_other(tp, false);\n          }\n          break;\n        }\n        case kStlClickTabSwitch: {\n          if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {\n            // double click opens new page\n            end_visual_mode();\n            tabpage_new();\n            tabpage_move(c1 == 0 ? 9999 : c1 - 1);\n          } else {\n            // Go to specified tab page, or next one if not clicking\n            // on a label.\n            goto_tabpage(c1);\n\n            // It's like clicking on the status line of a window.\n            if (curwin != old_curwin) {\n              end_visual_mode();\n            }\n          }\n          break;\n        }\n        case kStlClickFuncRun: {\n          typval_T argv[] = {\n            {\n              .v_lock = VAR_FIXED,\n              .v_type = VAR_NUMBER,\n              .vval = {\n                .v_number = (varnumber_T) tab_page_click_defs[mouse_col].tabnr\n              },\n            },\n            {\n              .v_lock = VAR_FIXED,\n              .v_type = VAR_NUMBER,\n              .vval = {\n                .v_number = (((mod_mask & MOD_MASK_MULTI_CLICK)\n                              == MOD_MASK_4CLICK)\n                             ? 4\n                             : ((mod_mask & MOD_MASK_MULTI_CLICK)\n                                == MOD_MASK_3CLICK)\n                             ? 3\n                             : ((mod_mask & MOD_MASK_MULTI_CLICK)\n                                == MOD_MASK_2CLICK)\n                             ? 2\n                             : 1)\n              },\n            },\n            {\n              .v_lock = VAR_FIXED,\n              .v_type = VAR_STRING,\n              .vval = { .v_string = (char_u *) (which_button == MOUSE_LEFT\n                                                ? \"l\"\n                                                : which_button == MOUSE_RIGHT\n                                                ? \"r\"\n                                                : which_button == MOUSE_MIDDLE\n                                                ? \"m\"\n                                                : \"?\") },\n            },\n            {\n              .v_lock = VAR_FIXED,\n              .v_type = VAR_STRING,\n              .vval = {\n                .v_string = (char_u[]) {\n                  (char_u) (mod_mask & MOD_MASK_SHIFT ? 's' : ' '),\n                  (char_u) (mod_mask & MOD_MASK_CTRL ? 'c' : ' '),\n                  (char_u) (mod_mask & MOD_MASK_ALT ? 'a' : ' '),\n                  (char_u) (mod_mask & MOD_MASK_META ? 'm' : ' '),\n                  NUL\n                }\n              },\n            }\n          };\n          typval_T rettv;\n          funcexe_T funcexe = FUNCEXE_INIT;\n          funcexe.firstline = curwin->w_cursor.lnum;\n          funcexe.lastline = curwin->w_cursor.lnum;\n          funcexe.evaluate = true;\n          (void)call_func((char_u *)tab_page_click_defs[mouse_col].func, -1,\n                          &rettv, ARRAY_SIZE(argv), argv, &funcexe);\n          tv_clear(&rettv);\n          break;\n        }\n      }\n    }\n    return true;\n  } else if (is_drag && in_tab_line) {\n    move_tab_to_mouse();\n    return false;\n  }\n\n\n  /*\n   * When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n   * right button up   -> pop-up menu\n   * shift-left button -> right button\n   * alt-left button   -> alt-right button\n   */\n  if (mouse_model_popup()) {\n    if (which_button == MOUSE_RIGHT\n        && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {\n      /*\n       * NOTE: Ignore right button down and drag mouse events.\n       * Windows only shows the popup menu on the button up event.\n       */\n      return false;\n    }\n    if (which_button == MOUSE_LEFT\n        && (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))) {\n      which_button = MOUSE_RIGHT;\n      mod_mask &= ~MOD_MASK_SHIFT;\n    }\n  }\n\n  if ((State & (NORMAL | INSERT))\n      && !(mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))) {\n    if (which_button == MOUSE_LEFT) {\n      if (is_click) {\n        /* stop Visual mode for a left click in a window, but not when\n         * on a status line */\n        if (VIsual_active)\n          jump_flags |= MOUSE_MAY_STOP_VIS;\n      } else {\n        jump_flags |= MOUSE_MAY_VIS;\n      }\n    } else if (which_button == MOUSE_RIGHT) {\n      if (is_click && VIsual_active) {\n        /*\n         * Remember the start and end of visual before moving the\n         * cursor.\n         */\n        if (lt(curwin->w_cursor, VIsual)) {\n          start_visual = curwin->w_cursor;\n          end_visual = VIsual;\n        } else {\n          start_visual = VIsual;\n          end_visual = curwin->w_cursor;\n        }\n      }\n      jump_flags |= MOUSE_FOCUS;\n      jump_flags |= MOUSE_MAY_VIS;\n    }\n  }\n\n  /*\n   * If an operator is pending, ignore all drags and releases until the\n   * next mouse click.\n   */\n  if (!is_drag && oap != NULL && oap->op_type != OP_NOP) {\n    got_click = false;\n    oap->motion_type = kMTCharWise;\n  }\n\n  /* When releasing the button let jump_to_mouse() know. */\n  if (!is_click && !is_drag)\n    jump_flags |= MOUSE_RELEASED;\n\n  /*\n   * JUMP!\n   */\n  jump_flags = jump_to_mouse(jump_flags,\n                             oap == NULL ? NULL : &(oap->inclusive),\n                             which_button);\n\n  moved = (jump_flags & CURSOR_MOVED);\n  in_status_line = (jump_flags & IN_STATUS_LINE);\n  in_sep_line = (jump_flags & IN_SEP_LINE);\n\n\n  /* When jumping to another window, clear a pending operator.  That's a bit\n   * friendlier than beeping and not jumping to that window. */\n  if (curwin != old_curwin && oap != NULL && oap->op_type != OP_NOP)\n    clearop(oap);\n\n  if (mod_mask == 0\n      && !is_drag\n      && (jump_flags & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))\n      && which_button == MOUSE_LEFT) {\n    // open or close a fold at this line\n    if (jump_flags & MOUSE_FOLD_OPEN) {\n      openFold(curwin->w_cursor, 1L);\n    } else {\n      closeFold(curwin->w_cursor, 1L);\n    }\n    // don't move the cursor if still in the same window\n    if (curwin == old_curwin) {\n      curwin->w_cursor = save_cursor;\n    }\n  }\n\n\n  /* Set global flag that we are extending the Visual area with mouse\n   * dragging; temporarily minimize 'scrolloff'. */\n  if (VIsual_active && is_drag && get_scrolloff_value(curwin)) {\n    // In the very first line, allow scrolling one line\n    if (mouse_row == 0) {\n      mouse_dragging = 2;\n    } else {\n      mouse_dragging = 1;\n    }\n  }\n\n  /* When dragging the mouse above the window, scroll down. */\n  if (is_drag && mouse_row < 0 && !in_status_line) {\n    scroll_redraw(false, 1L);\n    mouse_row = 0;\n  }\n\n  if (start_visual.lnum) {              /* right click in visual mode */\n    /* When ALT is pressed make Visual mode blockwise. */\n    if (mod_mask & MOD_MASK_ALT)\n      VIsual_mode = Ctrl_V;\n\n    /*\n     * In Visual-block mode, divide the area in four, pick up the corner\n     * that is in the quarter that the cursor is in.\n     */\n    if (VIsual_mode == Ctrl_V) {\n      getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n      if (curwin->w_curswant > (leftcol + rightcol) / 2)\n        end_visual.col = leftcol;\n      else\n        end_visual.col = rightcol;\n      if (curwin->w_cursor.lnum >=\n          (start_visual.lnum + end_visual.lnum) / 2) {\n        end_visual.lnum = start_visual.lnum;\n      }\n\n      /* move VIsual to the right column */\n      start_visual = curwin->w_cursor;              /* save the cursor pos */\n      curwin->w_cursor = end_visual;\n      coladvance(end_visual.col);\n      VIsual = curwin->w_cursor;\n      curwin->w_cursor = start_visual;              /* restore the cursor */\n    } else {\n      /*\n       * If the click is before the start of visual, change the start.\n       * If the click is after the end of visual, change the end.  If\n       * the click is inside the visual, change the closest side.\n       */\n      if (lt(curwin->w_cursor, start_visual))\n        VIsual = end_visual;\n      else if (lt(end_visual, curwin->w_cursor))\n        VIsual = start_visual;\n      else {\n        /* In the same line, compare column number */\n        if (end_visual.lnum == start_visual.lnum) {\n          if (curwin->w_cursor.col - start_visual.col >\n              end_visual.col - curwin->w_cursor.col)\n            VIsual = start_visual;\n          else\n            VIsual = end_visual;\n        }\n        /* In different lines, compare line number */\n        else {\n          diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n                 (end_visual.lnum - curwin->w_cursor.lnum);\n\n          if (diff > 0)                         /* closest to end */\n            VIsual = start_visual;\n          else if (diff < 0)            /* closest to start */\n            VIsual = end_visual;\n          else {                                /* in the middle line */\n            if (curwin->w_cursor.col <\n                (start_visual.col + end_visual.col) / 2)\n              VIsual = end_visual;\n            else\n              VIsual = start_visual;\n          }\n        }\n      }\n    }\n  }\n  /*\n   * If Visual mode started in insert mode, execute \"CTRL-O\"\n   */\n  else if ((State & INSERT) && VIsual_active)\n    stuffcharReadbuff(Ctrl_O);\n\n  /*\n   * Middle mouse click: Put text before cursor.\n   */\n  if (which_button == MOUSE_MIDDLE) {\n    if (regname == 0 && eval_has_provider(\"clipboard\")) {\n      regname = '*';\n    }\n    if (yank_register_mline(regname)) {\n      if (mouse_past_bottom)\n        dir = FORWARD;\n    } else if (mouse_past_eol)\n      dir = FORWARD;\n\n    if (fixindent) {\n      c1 = (dir == BACKWARD) ? '[' : ']';\n      c2 = 'p';\n    } else {\n      c1 = (dir == FORWARD) ? 'p' : 'P';\n      c2 = NUL;\n    }\n    prep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n    /*\n     * Remember where the paste started, so in edit() Insstart can be set\n     * to this position\n     */\n    if (restart_edit != 0)\n      where_paste_started = curwin->w_cursor;\n    do_put(regname, NULL, dir, count,\n           (fixindent ? PUT_FIXINDENT : 0)| PUT_CURSEND);\n  }\n  /*\n   * Ctrl-Mouse click or double click in a quickfix window jumps to the\n   * error under the mouse pointer.\n   */\n  else if (((mod_mask & MOD_MASK_CTRL)\n            || (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n           && bt_quickfix(curbuf)) {\n    if (curwin->w_llist_ref == NULL) {          // quickfix window\n      do_cmdline_cmd(\".cc\");\n    } else {                                    // location list window\n      do_cmdline_cmd(\".ll\");\n    }\n    got_click = false;                  // ignore drag&release now\n  }\n  /*\n   * Ctrl-Mouse click (or double click in a help window) jumps to the tag\n   * under the mouse pointer.\n   */\n  else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n                                          && (mod_mask &\n                                              MOD_MASK_MULTI_CLICK) ==\n                                          MOD_MASK_2CLICK)) {\n    if (State & INSERT)\n      stuffcharReadbuff(Ctrl_O);\n    stuffcharReadbuff(Ctrl_RSB);\n    got_click = false;                  /* ignore drag&release now */\n  }\n  /*\n   * Shift-Mouse click searches for the next occurrence of the word under\n   * the mouse pointer\n   */\n  else if ((mod_mask & MOD_MASK_SHIFT)) {\n    if (State & INSERT\n        || (VIsual_active && VIsual_select)\n        )\n      stuffcharReadbuff(Ctrl_O);\n    if (which_button == MOUSE_LEFT)\n      stuffcharReadbuff('*');\n    else        /* MOUSE_RIGHT */\n      stuffcharReadbuff('#');\n  }\n  /* Handle double clicks, unless on status line */\n  else if (in_status_line) {\n  } else if (in_sep_line) {\n  } else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))) {\n    if (is_click || !VIsual_active) {\n      if (VIsual_active) {\n        orig_cursor = VIsual;\n      } else {\n        VIsual = curwin->w_cursor;\n        orig_cursor = VIsual;\n        VIsual_active = true;\n        VIsual_reselect = true;\n        /* start Select mode if 'selectmode' contains \"mouse\" */\n        may_start_select('o');\n        setmouse();\n      }\n      if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {\n        /* Double click with ALT pressed makes it blockwise. */\n        if (mod_mask & MOD_MASK_ALT)\n          VIsual_mode = Ctrl_V;\n        else\n          VIsual_mode = 'v';\n      } else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n        VIsual_mode = 'V';\n      else if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n        VIsual_mode = Ctrl_V;\n    }\n    /*\n     * A double click selects a word or a block.\n     */\n    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK) {\n      pos_T       *pos = NULL;\n      int gc;\n\n      if (is_click) {\n        /* If the character under the cursor (skipping white space) is\n         * not a word character, try finding a match and select a (),\n         * {}, [], #if/#endif, etc. block. */\n        end_visual = curwin->w_cursor;\n        while (gc = gchar_pos(&end_visual), ascii_iswhite(gc))\n          inc(&end_visual);\n        if (oap != NULL) {\n          oap->motion_type = kMTCharWise;\n        }\n        if (oap != NULL\n            && VIsual_mode == 'v'\n            && !vim_iswordc(gchar_pos(&end_visual))\n            && equalpos(curwin->w_cursor, VIsual)\n            && (pos = findmatch(oap, NUL)) != NULL) {\n          curwin->w_cursor = *pos;\n          if (oap->motion_type == kMTLineWise) {\n            VIsual_mode = 'V';\n          } else if (*p_sel == 'e') {\n            if (lt(curwin->w_cursor, VIsual)) {\n              VIsual.col++;\n            } else {\n              curwin->w_cursor.col++;\n            }\n          }\n        }\n      }\n\n      if (pos == NULL && (is_click || is_drag)) {\n        /* When not found a match or when dragging: extend to include\n         * a word. */\n        if (lt(curwin->w_cursor, orig_cursor)) {\n          find_start_of_word(&curwin->w_cursor);\n          find_end_of_word(&VIsual);\n        } else {\n          find_start_of_word(&VIsual);\n          if (*p_sel == 'e' && *get_cursor_pos_ptr() != NUL)\n            curwin->w_cursor.col +=\n              (*mb_ptr2len)(get_cursor_pos_ptr());\n          find_end_of_word(&curwin->w_cursor);\n        }\n      }\n      curwin->w_set_curswant = true;\n    }\n    if (is_click)\n      redraw_curbuf_later(INVERTED);            /* update the inversion */\n  } else if (VIsual_active && !old_active) {\n    if (mod_mask & MOD_MASK_ALT)\n      VIsual_mode = Ctrl_V;\n    else\n      VIsual_mode = 'v';\n  }\n\n  /* If Visual mode changed show it later. */\n  if ((!VIsual_active && old_active && mode_displayed)\n      || (VIsual_active && p_smd && msg_silent == 0\n          && (!old_active || VIsual_mode != old_mode)))\n    redraw_cmdline = true;\n\n  return moved;\n}\n\n/*\n * Move \"pos\" back to the start of the word it's in.\n */\nstatic void find_start_of_word(pos_T *pos)\n{\n  char_u      *line;\n  int cclass;\n  int col;\n\n  line = ml_get(pos->lnum);\n  cclass = get_mouse_class(line + pos->col);\n\n  while (pos->col > 0) {\n    col = pos->col - 1;\n    col -= utf_head_off(line, line + col);\n    if (get_mouse_class(line + col) != cclass) {\n      break;\n    }\n    pos->col = col;\n  }\n}\n\n/*\n * Move \"pos\" forward to the end of the word it's in.\n * When 'selection' is \"exclusive\", the position is just after the word.\n */\nstatic void find_end_of_word(pos_T *pos)\n{\n  char_u      *line;\n  int cclass;\n  int col;\n\n  line = ml_get(pos->lnum);\n  if (*p_sel == 'e' && pos->col > 0) {\n    pos->col--;\n    pos->col -= utf_head_off(line, line + pos->col);\n  }\n  cclass = get_mouse_class(line + pos->col);\n  while (line[pos->col] != NUL) {\n    col = pos->col + (*mb_ptr2len)(line + pos->col);\n    if (get_mouse_class(line + col) != cclass) {\n      if (*p_sel == 'e')\n        pos->col = col;\n      break;\n    }\n    pos->col = col;\n  }\n}\n\n/*\n * Get class of a character for selection: same class means same word.\n * 0: blank\n * 1: punctuation groups\n * 2: normal word character\n * >2: multi-byte word character.\n */\nstatic int get_mouse_class(char_u *p)\n{\n  if (MB_BYTE2LEN(p[0]) > 1) {\n    return mb_get_class(p);\n  }\n\n  const int c = *p;\n  if (c == ' ' || c == '\\t') {\n    return 0;\n  }\n  if (vim_iswordc(c)) {\n    return 2;\n  }\n\n  /*\n   * There are a few special cases where we want certain combinations of\n   * characters to be considered as a single word.  These are things like\n   * \"->\", \"/ *\", \"*=\", \"+=\", \"&=\", \"<=\", \">=\", \"!=\" etc.  Otherwise, each\n   * character is in its own class.\n   */\n  if (c != NUL && vim_strchr((char_u *)\"-+*/%<>&|^!=\", c) != NULL)\n    return 1;\n  return c;\n}\n\n/*\n * End Visual mode.\n * This function should ALWAYS be called to end Visual mode, except from\n * do_pending_operator().\n */\nvoid end_visual_mode(void)\n{\n\n  VIsual_active = false;\n  setmouse();\n  mouse_dragging = 0;\n\n  /* Save the current VIsual area for '< and '> marks, and \"gv\" */\n  curbuf->b_visual.vi_mode = VIsual_mode;\n  curbuf->b_visual.vi_start = VIsual;\n  curbuf->b_visual.vi_end = curwin->w_cursor;\n  curbuf->b_visual.vi_curswant = curwin->w_curswant;\n  curbuf->b_visual_mode_eval = VIsual_mode;\n  if (!virtual_active())\n    curwin->w_cursor.coladd = 0;\n\n  may_clear_cmdline();\n\n  adjust_cursor_eol();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\nvoid reset_VIsual_and_resel(void)\n{\n  if (VIsual_active) {\n    end_visual_mode();\n    redraw_curbuf_later(INVERTED);      /* delete the inversion later */\n  }\n  VIsual_reselect = false;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\nvoid reset_VIsual(void)\n{\n  if (VIsual_active) {\n    end_visual_mode();\n    redraw_curbuf_later(INVERTED);      /* delete the inversion later */\n    VIsual_reselect = false;\n  }\n}\n\n// Check for a balloon-eval special item to include when searching for an\n// identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n// Returns true if the character at \"*ptr\" should be included.\n// \"dir\" is FORWARD or BACKWARD, the direction of searching.\n// \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n// \"bnp\" points to a counter for square brackets.\nstatic bool find_is_eval_item(\n    const char_u *const ptr,\n    int *const colp,\n    int *const bnp,\n    const int dir)\n{\n  // Accept everything inside [].\n  if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD)) {\n    *bnp += 1;\n  }\n  if (*bnp > 0) {\n    if ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD)) {\n      *bnp -= 1;\n    }\n    return true;\n  }\n\n  // skip over \"s.var\"\n  if (*ptr == '.') {\n    return true;\n  }\n\n  // two-character item: s->var\n  if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n      && ptr[dir == BACKWARD ? -1 : 0] == '-') {\n    *colp += dir;\n    return true;\n  }\n  return false;\n}\n\n// Find the identifier under or to the right of the cursor.\n// \"find_type\" can have one of three values:\n// FIND_IDENT:   find an identifier (keyword)\n// FIND_STRING:  find any non-white text\n// FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n// FIND_EVAL:  find text useful for C program debugging\n//\n// There are three steps:\n// 1. Search forward for the start of an identifier/text.  Doesn't move if\n//    already on one.\n// 2. Search backward for the start of this identifier/text.\n//    This doesn't match the real Vi but I like it a little better and it\n//    shouldn't bother anyone.\n// 3. Search forward to the end of this identifier/text.\n//    When FIND_IDENT isn't defined, we backup until a blank.\n//\n// Returns the length of the text, or zero if no text is found.\n// If text is found, a pointer to the text is put in \"*text\".  This\n// points into the current buffer line and is not always NUL terminated.\nsize_t find_ident_under_cursor(char_u **text, int find_type)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n                           curwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\nsize_t find_ident_at_pos(\n    win_T *wp,\n    linenr_T lnum,\n    colnr_T startcol,\n    char_u **text,\n    int *textcol,      // column where \"text\" starts, can be NULL\n    int find_type)\n  FUNC_ATTR_NONNULL_ARG(1, 4)\n{\n  int col = 0;         // init to shut up GCC\n  int i;\n  int this_class = 0;\n  int prev_class;\n  int prevcol;\n  int bn = 0;                       // bracket nesting\n\n  // if i == 0: try to find an identifier\n  // if i == 1: try to find any non-white text\n  char_u *ptr = ml_get_buf(wp->w_buffer, lnum, false);\n  for (i = (find_type & FIND_IDENT) ? 0 : 1; i < 2; i++) {\n    // 1. skip to start of identifier/text\n    col = startcol;\n    while (ptr[col] != NUL) {\n      // Stop at a ']' to evaluate \"a[x]\".\n      if ((find_type & FIND_EVAL) && ptr[col] == ']') {\n        break;\n      }\n      this_class = mb_get_class(ptr + col);\n      if (this_class != 0 && (i == 1 || this_class != 1)) {\n        break;\n      }\n      col += utfc_ptr2len(ptr + col);\n    }\n\n    // When starting on a ']' count it, so that we include the '['.\n    bn = ptr[col] == ']';\n\n    //\n    // 2. Back up to start of identifier/text.\n    //\n    // Remember class of character under cursor.\n    if ((find_type & FIND_EVAL) && ptr[col] == ']') {\n      this_class = mb_get_class((char_u *)\"a\");\n    } else {\n      this_class = mb_get_class(ptr + col);\n    }\n    while (col > 0 && this_class != 0) {\n      prevcol = col - 1 - utf_head_off(ptr, ptr + col - 1);\n      prev_class = mb_get_class(ptr + prevcol);\n      if (this_class != prev_class\n          && (i == 0\n              || prev_class == 0\n              || (find_type & FIND_IDENT))\n          && (!(find_type & FIND_EVAL)\n              || prevcol == 0\n              || !find_is_eval_item(ptr + prevcol, &prevcol, &bn, BACKWARD))) {\n        break;\n      }\n      col = prevcol;\n    }\n\n    // If we don't want just any old text, or we've found an\n    // identifier, stop searching.\n    if (this_class > 2) {\n      this_class = 2;\n    }\n    if (!(find_type & FIND_STRING) || this_class == 2) {\n      break;\n    }\n  }\n\n  if (ptr[col] == NUL || (i == 0 && this_class != 2)) {\n    // Didn't find an identifier or text.\n    if (find_type & FIND_STRING) {\n      EMSG(_(\"E348: No string under cursor\"));\n    } else {\n      EMSG(_(e_noident));\n    }\n    return 0;\n  }\n  ptr += col;\n  *text = ptr;\n  if (textcol != NULL) {\n    *textcol = col;\n  }\n\n  // 3. Find the end if the identifier/text.\n  bn = 0;\n  startcol -= col;\n  col = 0;\n  // Search for point of changing multibyte character class.\n  this_class = mb_get_class(ptr);\n  while (ptr[col] != NUL\n         && ((i == 0\n              ? mb_get_class(ptr + col) == this_class\n              : mb_get_class(ptr + col) != 0)\n             || ((find_type & FIND_EVAL)\n                 && col <= (int)startcol\n                 && find_is_eval_item(ptr + col, &col, &bn, FORWARD)))) {\n    col += utfc_ptr2len(ptr + col);\n  }\n\n  assert(col >= 0);\n  return (size_t)col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\nstatic void prep_redo_cmd(cmdarg_T *cap)\n{\n  prep_redo(cap->oap->regname, cap->count0,\n      NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\nstatic void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5)\n{\n  ResetRedobuff();\n  if (regname != 0) {   /* yank from specified buffer */\n    AppendCharToRedobuff('\"');\n    AppendCharToRedobuff(regname);\n  }\n  if (num)\n    AppendNumberToRedobuff(num);\n\n  if (cmd1 != NUL)\n    AppendCharToRedobuff(cmd1);\n  if (cmd2 != NUL)\n    AppendCharToRedobuff(cmd2);\n  if (cmd3 != NUL)\n    AppendCharToRedobuff(cmd3);\n  if (cmd4 != NUL)\n    AppendCharToRedobuff(cmd4);\n  if (cmd5 != NUL)\n    AppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return true if operator was active\n */\nstatic bool checkclearop(oparg_T *oap)\n{\n  if (oap->op_type == OP_NOP)\n    return false;\n  clearopbeep(oap);\n  return true;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return true if operator or Visual was active.\n */\nstatic bool checkclearopq(oparg_T *oap)\n{\n  if (oap->op_type == OP_NOP\n      && !VIsual_active\n      )\n    return false;\n  clearopbeep(oap);\n  return true;\n}\n\nstatic void clearop(oparg_T *oap)\n{\n  oap->op_type = OP_NOP;\n  oap->regname = 0;\n  oap->motion_force = NUL;\n  oap->use_reg_one = false;\n  motion_force = NUL;\n}\n\nstatic void clearopbeep(oparg_T *oap)\n{\n  clearop(oap);\n  beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\nstatic void unshift_special(cmdarg_T *cap)\n{\n  switch (cap->cmdchar) {\n  case K_S_RIGHT: cap->cmdchar = K_RIGHT; break;\n  case K_S_LEFT:  cap->cmdchar = K_LEFT; break;\n  case K_S_UP:    cap->cmdchar = K_UP; break;\n  case K_S_DOWN:  cap->cmdchar = K_DOWN; break;\n  case K_S_HOME:  cap->cmdchar = K_HOME; break;\n  case K_S_END:   cap->cmdchar = K_END; break;\n  }\n  cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/// If the mode is currently displayed clear the command line or update the\n/// command displayed.\nstatic void may_clear_cmdline(void)\n{\n  if (mode_displayed) {\n    // unshow visual mode later\n    clear_cmdline = true;\n  } else {\n    clear_showcmd();\n  }\n}\n\n// Routines for displaying a partly typed command\n# define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30\nstatic char_u showcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u old_showcmd_buf[SHOWCMD_BUFLEN];    /* For push_showcmd() */\nstatic bool showcmd_is_clear = true;\nstatic bool showcmd_visual = false;\n\n\nvoid clear_showcmd(void)\n{\n  if (!p_sc)\n    return;\n\n  if (VIsual_active && !char_avail()) {\n    int cursor_bot = lt(VIsual, curwin->w_cursor);\n    long lines;\n    colnr_T leftcol, rightcol;\n    linenr_T top, bot;\n\n    /* Show the size of the Visual area. */\n    if (cursor_bot) {\n      top = VIsual.lnum;\n      bot = curwin->w_cursor.lnum;\n    } else {\n      top = curwin->w_cursor.lnum;\n      bot = VIsual.lnum;\n    }\n    // Include closed folds as a whole.\n    (void)hasFolding(top, &top, NULL);\n    (void)hasFolding(bot, NULL, &bot);\n    lines = bot - top + 1;\n\n    if (VIsual_mode == Ctrl_V) {\n      char_u *saved_sbr = p_sbr;\n\n      /* Make 'sbr' empty for a moment to get the correct size. */\n      p_sbr = empty_option;\n      getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n      p_sbr = saved_sbr;\n      snprintf((char *)showcmd_buf, SHOWCMD_BUFLEN, \"%\" PRId64 \"x%\" PRId64,\n               (int64_t)lines, (int64_t)rightcol - leftcol + 1);\n    } else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum) {\n      snprintf((char *)showcmd_buf, SHOWCMD_BUFLEN, \"%\" PRId64, (int64_t)lines);\n    } else {\n      char_u  *s, *e;\n      int l;\n      int bytes = 0;\n      int chars = 0;\n\n      if (cursor_bot) {\n        s = ml_get_pos(&VIsual);\n        e = get_cursor_pos_ptr();\n      } else {\n        s = get_cursor_pos_ptr();\n        e = ml_get_pos(&VIsual);\n      }\n      while ((*p_sel != 'e') ? s <= e : s < e) {\n        l = (*mb_ptr2len)(s);\n        if (l == 0) {\n          ++bytes;\n          ++chars;\n          break;            /* end of line */\n        }\n        bytes += l;\n        ++chars;\n        s += l;\n      }\n      if (bytes == chars)\n        sprintf((char *)showcmd_buf, \"%d\", chars);\n      else\n        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n    }\n    int limit = ui_has(kUIMessages) ? SHOWCMD_BUFLEN-1 : SHOWCMD_COLS;\n    showcmd_buf[limit] = NUL;  // truncate\n    showcmd_visual = true;\n  } else {\n    showcmd_buf[0] = NUL;\n    showcmd_visual = false;\n\n    /* Don't actually display something if there is nothing to clear. */\n    if (showcmd_is_clear)\n      return;\n  }\n\n  display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return true if output has been written (and setcursor() has been called).\n */\nbool add_to_showcmd(int c)\n{\n  char_u      *p;\n  int i;\n  static int ignore[] =\n  {\n    K_IGNORE,\n    K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n    K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n    K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n    K_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n    K_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n    K_EVENT,\n    0\n  };\n\n  if (!p_sc || msg_silent != 0)\n    return false;\n\n  if (showcmd_visual) {\n    showcmd_buf[0] = NUL;\n    showcmd_visual = false;\n  }\n\n  /* Ignore keys that are scrollbar updates and mouse clicks */\n  if (IS_SPECIAL(c))\n    for (i = 0; ignore[i] != 0; ++i)\n      if (ignore[i] == c)\n        return false;\n\n  p = transchar(c);\n  if (*p == ' ')\n    STRCPY(p, \"<20>\");\n  size_t old_len = STRLEN(showcmd_buf);\n  size_t extra_len = STRLEN(p);\n  size_t limit = ui_has(kUIMessages) ? SHOWCMD_BUFLEN-1 : SHOWCMD_COLS;\n  if (old_len + extra_len > limit) {\n    size_t overflow = old_len + extra_len - limit;\n    memmove(showcmd_buf, showcmd_buf + overflow, old_len - overflow + 1);\n  }\n  STRCAT(showcmd_buf, p);\n\n  if (char_avail())\n    return false;\n\n  display_showcmd();\n\n  return true;\n}\n\nvoid add_to_showcmd_c(int c)\n{\n  add_to_showcmd(c);\n  setcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\nstatic void del_from_showcmd(int len)\n{\n  int old_len;\n\n  if (!p_sc)\n    return;\n\n  old_len = (int)STRLEN(showcmd_buf);\n  if (len > old_len)\n    len = old_len;\n  showcmd_buf[old_len - len] = NUL;\n\n  if (!char_avail())\n    display_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\nvoid push_showcmd(void)\n{\n  if (p_sc)\n    STRCPY(old_showcmd_buf, showcmd_buf);\n}\n\nvoid pop_showcmd(void)\n{\n  if (!p_sc)\n    return;\n\n  STRCPY(showcmd_buf, old_showcmd_buf);\n\n  display_showcmd();\n}\n\nstatic void display_showcmd(void)\n{\n  int len;\n  len = (int)STRLEN(showcmd_buf);\n  showcmd_is_clear = (len == 0);\n\n  if (ui_has(kUIMessages)) {\n    Array content = ARRAY_DICT_INIT;\n    if (len > 0) {\n      Array chunk = ARRAY_DICT_INIT;\n      // placeholder for future highlight support\n      ADD(chunk, INTEGER_OBJ(0));\n      ADD(chunk, STRING_OBJ(cstr_to_string((char *)showcmd_buf)));\n      ADD(content, ARRAY_OBJ(chunk));\n    }\n    ui_call_msg_showcmd(content);\n    return;\n  }\n\n  msg_grid_validate();\n  int showcmd_row = Rows - 1;\n  grid_puts_line_start(&msg_grid_adj, showcmd_row);\n\n  if (!showcmd_is_clear) {\n    grid_puts(&msg_grid_adj, showcmd_buf, showcmd_row, sc_col,\n              HL_ATTR(HLF_MSG));\n  }\n\n  // clear the rest of an old message by outputting up to SHOWCMD_COLS spaces\n  grid_puts(&msg_grid_adj, (char_u *)\"          \" + len, showcmd_row,\n            sc_col + len, HL_ATTR(HLF_MSG));\n\n  grid_puts_line_flush(false);\n}\n\n/*\n * When \"check\" is false, prepare for commands that scroll the window.\n * When \"check\" is true, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\nvoid do_check_scrollbind(bool check)\n{\n  static win_T        *old_curwin = NULL;\n  static linenr_T old_topline = 0;\n  static int old_topfill = 0;\n  static buf_T        *old_buf = NULL;\n  static colnr_T old_leftcol = 0;\n\n  if (check && curwin->w_p_scb) {\n    /* If a \":syncbind\" command was just used, don't scroll, only reset\n     * the values. */\n    if (did_syncbind)\n      did_syncbind = false;\n    else if (curwin == old_curwin) {\n      /*\n       * Synchronize other windows, as necessary according to\n       * 'scrollbind'.  Don't do this after an \":edit\" command, except\n       * when 'diff' is set.\n       */\n      if ((curwin->w_buffer == old_buf\n           || curwin->w_p_diff\n           )\n          && (curwin->w_topline != old_topline\n              || curwin->w_topfill != old_topfill\n              || curwin->w_leftcol != old_leftcol)) {\n        check_scrollbind(curwin->w_topline - old_topline,\n            (long)(curwin->w_leftcol - old_leftcol));\n      }\n    } else if (vim_strchr(p_sbo, 'j')) { /* jump flag set in 'scrollopt' */\n      /*\n       * When switching between windows, make sure that the relative\n       * vertical offset is valid for the new window.  The relative\n       * offset is invalid whenever another 'scrollbind' window has\n       * scrolled to a point that would force the current window to\n       * scroll past the beginning or end of its buffer.  When the\n       * resync is performed, some of the other 'scrollbind' windows may\n       * need to jump so that the current window's relative position is\n       * visible on-screen.\n       */\n      check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n    }\n    curwin->w_scbind_pos = curwin->w_topline;\n  }\n\n  old_curwin = curwin;\n  old_topline = curwin->w_topline;\n  old_topfill = curwin->w_topfill;\n  old_buf = curwin->w_buffer;\n  old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\nvoid check_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n  bool want_ver;\n  bool want_hor;\n  win_T       *old_curwin = curwin;\n  buf_T       *old_curbuf = curbuf;\n  int old_VIsual_select = VIsual_select;\n  int old_VIsual_active = VIsual_active;\n  colnr_T tgt_leftcol = curwin->w_leftcol;\n  long topline;\n  long y;\n\n  /*\n   * check 'scrollopt' string for vertical and horizontal scroll options\n   */\n  want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n  want_ver |= old_curwin->w_p_diff;\n  want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n  /*\n   * loop through the scrollbound windows and scroll accordingly\n   */\n  VIsual_select = VIsual_active = 0;\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    /* skip original window  and windows with 'noscrollbind' */\n    if (curwin == old_curwin || !curwin->w_p_scb) {\n      continue;\n    }\n    /*\n     * do the vertical scroll\n     */\n    if (want_ver) {\n      if (old_curwin->w_p_diff && curwin->w_p_diff) {\n        diff_set_topline(old_curwin, curwin);\n      } else {\n        curwin->w_scbind_pos += topline_diff;\n        topline = curwin->w_scbind_pos;\n        if (topline > curbuf->b_ml.ml_line_count)\n          topline = curbuf->b_ml.ml_line_count;\n        if (topline < 1)\n          topline = 1;\n\n        y = topline - curwin->w_topline;\n        if (y > 0)\n          scrollup(y, false);\n        else\n          scrolldown(-y, false);\n      }\n\n      redraw_later(curwin, VALID);\n      cursor_correct();\n      curwin->w_redr_status = true;\n    }\n\n    /*\n     * do the horizontal scroll\n     */\n    if (want_hor && curwin->w_leftcol != tgt_leftcol) {\n      curwin->w_leftcol = tgt_leftcol;\n      leftcol_changed();\n    }\n  }\n\n  /*\n   * reset current-window\n   */\n  VIsual_select = old_VIsual_select;\n  VIsual_active = old_VIsual_active;\n  curwin = old_curwin;\n  curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\nstatic void nv_ignore(cmdarg_T *cap)\n{\n  cap->retval |= CA_COMMAND_BUSY;       /* don't call edit() now */\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\nstatic void nv_nop(cmdarg_T *cap)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\nstatic void nv_error(cmdarg_T *cap)\n{\n  clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\nstatic void nv_help(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap))\n    ex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\nstatic void nv_addsub(cmdarg_T *cap)\n{\n  if (bt_prompt(curbuf) && !prompt_curpos_editable()) {\n    clearopbeep(cap->oap);\n  } else if (!VIsual_active && cap->oap->op_type == OP_NOP) {\n    prep_redo_cmd(cap);\n    cap->oap->op_type = cap->cmdchar == Ctrl_A ? OP_NR_ADD : OP_NR_SUB;\n    op_addsub(cap->oap, cap->count1, cap->arg);\n    cap->oap->op_type = OP_NOP;\n  } else if (VIsual_active) {\n    nv_operator(cap);\n  } else {\n    clearop(cap->oap);\n  }\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\nstatic void nv_page(cmdarg_T *cap)\n{\n  if (!checkclearop(cap->oap)) {\n    if (mod_mask & MOD_MASK_CTRL) {\n      /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */\n      if (cap->arg == BACKWARD)\n        goto_tabpage(-(int)cap->count1);\n      else\n        goto_tabpage((int)cap->count0);\n    } else\n      (void)onepage(cap->arg, cap->count1);\n  }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\nstatic void\nnv_gd (\n    oparg_T *oap,\n    int nchar,\n    int thisblock                  /* 1 for \"1gd\" and \"1gD\" */\n)\n{\n  size_t len;\n  char_u *ptr;\n  if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n      || !find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)) {\n    clearopbeep(oap);\n  } else if ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP) {\n    foldOpenCursor();\n  }\n}\n\n// Return true if line[offset] is not inside a C-style comment or string, false\n// otherwise.\nstatic bool is_ident(char_u *line, int offset)\n{\n  bool incomment = false;\n  int instring = 0;\n  int prev = 0;\n\n  for (int i = 0; i < offset && line[i] != NUL; i++) {\n    if (instring != 0) {\n      if (prev != '\\\\' && line[i] == instring) {\n        instring = 0;\n      }\n    } else if ((line[i] == '\"' || line[i] == '\\'') && !incomment) {\n      instring = line[i];\n    } else {\n      if (incomment) {\n        if (prev == '*' && line[i] == '/') {\n          incomment = false;\n        }\n      } else if (prev == '/' && line[i] == '*') {\n        incomment = true;\n      } else if (prev == '/' && line[i] == '/') {\n        return false;\n      }\n    }\n\n    prev = line[i];\n  }\n\n  return incomment == false && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is true in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is true check the {} block scope.\n * Return fail when not found.\n */\nbool\nfind_decl (\n    char_u *ptr,\n    size_t len,\n    bool locally,\n    bool thisblock,\n    int flags_arg                  // flags passed to searchit()\n)\n{\n  char_u      *pat;\n  pos_T old_pos;\n  pos_T par_pos;\n  pos_T found_pos;\n  bool t;\n  bool save_p_ws;\n  bool save_p_scs;\n  bool retval = true;\n  bool incll;\n  int searchflags = flags_arg;\n\n  pat = xmalloc(len + 7);\n\n  /* Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n   * and \"~\" causes trouble. */\n  assert(len <= INT_MAX);\n  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n          (int)len, ptr);\n  old_pos = curwin->w_cursor;\n  save_p_ws = p_ws;\n  save_p_scs = p_scs;\n  p_ws = false;         /* don't wrap around end of file now */\n  p_scs = false;        /* don't switch ignorecase off now */\n\n  /*\n   * With \"gD\" go to line 1.\n   * With \"gd\" Search back for the start of the current function, then go\n   * back until a blank line.  If this fails go to line 1.\n   */\n  if (!locally || !findpar(&incll, BACKWARD, 1L, '{', false)) {\n    setpcmark();                        /* Set in findpar() otherwise */\n    curwin->w_cursor.lnum = 1;\n    par_pos = curwin->w_cursor;\n  } else {\n    par_pos = curwin->w_cursor;\n    while (curwin->w_cursor.lnum > 1\n           && *skipwhite(get_cursor_line_ptr()) != NUL)\n      --curwin->w_cursor.lnum;\n  }\n  curwin->w_cursor.col = 0;\n\n  /* Search forward for the identifier, ignore comment lines. */\n  clearpos(&found_pos);\n  for (;; ) {\n    t = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n                 pat, 1L, searchflags, RE_LAST, NULL);\n    if (curwin->w_cursor.lnum >= old_pos.lnum) {\n      t = false;         // match after start is failure too\n    }\n\n    if (thisblock && t != false) {\n      const int64_t maxtravel = old_pos.lnum - curwin->w_cursor.lnum + 1;\n      const pos_T *pos = findmatchlimit(NULL, '}', FM_FORWARD, maxtravel);\n\n      // Check that the block the match is in doesn't end before the\n      // position where we started the search from.\n      if (pos != NULL && pos->lnum < old_pos.lnum) {\n        // There can't be a useful match before the end of this block.\n        // Skip to the end\n        curwin->w_cursor = *pos;\n        continue;\n      }\n    }\n\n    if (t == false) {\n      /* If we previously found a valid position, use it. */\n      if (found_pos.lnum != 0) {\n        curwin->w_cursor = found_pos;\n        t = true;\n      }\n      break;\n    }\n    if (get_leader_len(get_cursor_line_ptr(), NULL, false, true) > 0) {\n      /* Ignore this line, continue at start of next line. */\n      ++curwin->w_cursor.lnum;\n      curwin->w_cursor.col = 0;\n      continue;\n    }\n    bool valid = is_ident(get_cursor_line_ptr(), curwin->w_cursor.col);\n\n    // If the current position is not a valid identifier and a previous match is\n    // present, favor that one instead.\n    if (!valid && found_pos.lnum != 0) {\n      curwin->w_cursor = found_pos;\n      break;\n    }\n    // global search: use first match found\n    if (valid && !locally) {\n      break;\n    }\n    if (valid && curwin->w_cursor.lnum >= par_pos.lnum) {\n      // If we previously found a valid position, use it.\n      if (found_pos.lnum != 0) {\n        curwin->w_cursor = found_pos;\n      }\n      break;\n    }\n\n    // For finding a local variable and the match is before the \"{\" or\n    // inside a comment, continue searching.  For K&R style function\n    // declarations this skips the function header without types.\n    if (!valid) {\n      clearpos(&found_pos);\n    } else {\n      found_pos = curwin->w_cursor;\n    }\n    // Remove SEARCH_START from flags to avoid getting stuck at one position.\n    searchflags &= ~SEARCH_START;\n  }\n\n  if (t == false) {\n    retval = false;\n    curwin->w_cursor = old_pos;\n  } else {\n    curwin->w_set_curswant = true;\n    /* \"n\" searches forward now */\n    reset_search_dir();\n  }\n\n  xfree(pat);\n  p_ws = save_p_ws;\n  p_scs = save_p_scs;\n\n  return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return true if able to move cursor, false otherwise.\n */\nstatic bool nv_screengo(oparg_T *oap, int dir, long dist)\n{\n  int linelen = linetabsize(get_cursor_line_ptr());\n  bool retval = true;\n  bool atend = false;\n  int n;\n  int col_off1;                 /* margin offset for first screen line */\n  int col_off2;                 /* margin offset for wrapped screen line */\n  int width1;                   /* text width for first screen line */\n  int width2;                   /* test width for wrapped screen line */\n\n  oap->motion_type = kMTCharWise;\n  oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n  col_off1 = curwin_col_off();\n  col_off2 = col_off1 - curwin_col_off2();\n  width1 = curwin->w_width_inner - col_off1;\n  width2 = curwin->w_width_inner - col_off2;\n\n  if (width2 == 0) {\n    width2 = 1;  // Avoid divide by zero.\n  }\n\n  if (curwin->w_width_inner != 0) {\n    // Instead of sticking at the last character of the buffer line we\n    // try to stick in the last column of the screen.\n    if (curwin->w_curswant == MAXCOL) {\n      atend = true;\n      validate_virtcol();\n      if (width1 <= 0)\n        curwin->w_curswant = 0;\n      else {\n        curwin->w_curswant = width1 - 1;\n        if (curwin->w_virtcol > curwin->w_curswant)\n          curwin->w_curswant += ((curwin->w_virtcol\n                                  - curwin->w_curswant -\n                                  1) / width2 + 1) * width2;\n      }\n    } else {\n      if (linelen > width1)\n        n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n      else\n        n = width1;\n      if (curwin->w_curswant >= n) {\n        curwin->w_curswant = n - 1;\n      }\n    }\n\n    while (dist--) {\n      if (dir == BACKWARD) {\n        if (curwin->w_curswant >= width1\n            && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)) {\n          // Move back within the line. This can give a negative value\n          // for w_curswant if width1 < width2 (with cpoptions+=n),\n          // which will get clipped to column 0.\n          curwin->w_curswant -= width2;\n        } else {\n          // to previous line\n\n          // Move to the start of a closed fold.  Don't do that when\n          // 'foldopen' contains \"all\": it will open in a moment.\n          if (!(fdo_flags & FDO_ALL)) {\n            (void)hasFolding(curwin->w_cursor.lnum,\n                             &curwin->w_cursor.lnum, NULL);\n          }\n          if (curwin->w_cursor.lnum == 1) {\n            retval = false;\n            break;\n          }\n          curwin->w_cursor.lnum--;\n\n          linelen = linetabsize(get_cursor_line_ptr());\n          if (linelen > width1) {\n            int w = (((linelen - width1 - 1) / width2) + 1) * width2;\n            assert(curwin->w_curswant <= INT_MAX - w);\n            curwin->w_curswant += w;\n          }\n        }\n      } else { /* dir == FORWARD */\n        if (linelen > width1)\n          n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n        else\n          n = width1;\n        if (curwin->w_curswant + width2 < (colnr_T)n\n            && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)) {\n          // move forward within line\n          curwin->w_curswant += width2;\n        } else {\n          // to next line\n\n          // Move to the end of a closed fold.\n          (void)hasFolding(curwin->w_cursor.lnum, NULL,\n                           &curwin->w_cursor.lnum);\n          if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {\n            retval = false;\n            break;\n          }\n          curwin->w_cursor.lnum++;\n          curwin->w_curswant %= width2;\n          // Check if the cursor has moved below the number display\n          // when width1 < width2 (with cpoptions+=n). Subtract width2\n          // to get a negative value for w_curswant, which will get\n          // clipped to column 0.\n          if (curwin->w_curswant >= width1) {\n            curwin->w_curswant -= width2;\n          }\n          linelen = linetabsize(get_cursor_line_ptr());\n        }\n      }\n    }\n  }\n\n  if (virtual_active() && atend)\n    coladvance(MAXCOL);\n  else\n    coladvance(curwin->w_curswant);\n\n  if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {\n    /*\n     * Check for landing on a character that got split at the end of the\n     * last line.  We want to advance a screenline, not end up in the same\n     * screenline or move two screenlines.\n     */\n    validate_virtcol();\n    colnr_T virtcol = curwin->w_virtcol;\n    if (virtcol > (colnr_T)width1 && *p_sbr != NUL)\n        virtcol -= vim_strsize(p_sbr);\n\n    if (virtcol > curwin->w_curswant\n        && (curwin->w_curswant < (colnr_T)width1\n            ? (curwin->w_curswant > (colnr_T)width1 / 2)\n            : ((curwin->w_curswant - width1) % width2\n               > (colnr_T)width2 / 2)))\n      --curwin->w_cursor.col;\n  }\n\n  if (atend)\n    curwin->w_curswant = MAXCOL;            /* stick in the last column */\n\n  return retval;\n}\n\n/*\n * Mouse scroll wheel: Default action is to scroll three lines, or one page\n * when Shift or Ctrl is used.\n * K_MOUSEUP (cap->arg == 1) or K_MOUSEDOWN (cap->arg == 0) or\n * K_MOUSELEFT (cap->arg == -1) or K_MOUSERIGHT (cap->arg == -2)\n */\nstatic void nv_mousescroll(cmdarg_T *cap)\n{\n  win_T *old_curwin = curwin;\n\n  if (mouse_row >= 0 && mouse_col >= 0) {\n    int grid, row, col;\n\n    grid = mouse_grid;\n    row = mouse_row;\n    col = mouse_col;\n\n    // find the window at the pointer coordinates\n    win_T *wp = mouse_find_win(&grid, &row, &col);\n    if (wp == NULL) {\n      return;\n    }\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n  }\n\n  if (cap->arg == MSCR_UP || cap->arg == MSCR_DOWN) {\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {\n      (void)onepage(cap->arg ? FORWARD : BACKWARD, 1L);\n    } else {\n      cap->count1 = 3;\n      cap->count0 = 3;\n      nv_scroll_line(cap);\n    }\n  } else {\n    mouse_scroll_horiz(cap->arg);\n  }\n  if (curwin != old_curwin && curwin->w_p_cul) {\n    redraw_for_cursorline(curwin);\n  }\n\n  curwin->w_redr_status = true;\n\n  curwin = old_curwin;\n  curbuf = curwin->w_buffer;\n}\n\n/*\n * Mouse clicks and drags.\n */\nstatic void nv_mouse(cmdarg_T *cap)\n{\n  (void)do_mouse(cap->oap, cap->cmdchar, BACKWARD, cap->count1, 0);\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be true for CTRL-E.\n */\nstatic void nv_scroll_line(cmdarg_T *cap)\n{\n  if (!checkclearop(cap->oap))\n    scroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\nvoid scroll_redraw(int up, long count)\n{\n  linenr_T prev_topline = curwin->w_topline;\n  int prev_topfill = curwin->w_topfill;\n  linenr_T prev_lnum = curwin->w_cursor.lnum;\n\n  bool moved = up ?\n    scrollup(count, true) :\n    scrolldown(count, true);\n\n  if (get_scrolloff_value(curwin)) {\n    // Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n    // valid, otherwise the screen jumps back at the end of the file.\n    cursor_correct();\n    check_cursor_moved(curwin);\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /* If moved back to where we were, at least move the cursor, otherwise\n     * we get stuck at one position.  Don't move the cursor up if the\n     * first line of the buffer is already on the screen */\n    while (curwin->w_topline == prev_topline\n           && curwin->w_topfill == prev_topfill\n           ) {\n      if (up) {\n        if (curwin->w_cursor.lnum > prev_lnum\n            || cursor_down(1L, false) == false)\n          break;\n      } else {\n        if (curwin->w_cursor.lnum < prev_lnum\n            || prev_topline == 1L\n            || cursor_up(1L, false) == false)\n          break;\n      }\n      /* Mark w_topline as valid, otherwise the screen jumps back at the\n       * end of the file. */\n      check_cursor_moved(curwin);\n      curwin->w_valid |= VALID_TOPLINE;\n    }\n  }\n  if (curwin->w_cursor.lnum != prev_lnum) {\n    coladvance(curwin->w_curswant);\n  }\n  if (moved) {\n    curwin->w_viewport_invalid = true;\n  }\n  redraw_later(curwin, VALID);\n}\n\n/*\n * Commands that start with \"z\".\n */\nstatic void nv_zet(cmdarg_T *cap)\n{\n  int n;\n  colnr_T col;\n  int nchar = cap->nchar;\n  long old_fdl = curwin->w_p_fdl;\n  int old_fen = curwin->w_p_fen;\n  bool undo = false;\n\n  int l_p_siso = (int)get_sidescrolloff_value(curwin);\n  assert(l_p_siso <= INT_MAX);\n\n  if (ascii_isdigit(nchar)) {\n    /*\n     * \"z123{nchar}\": edit the count before obtaining {nchar}\n     */\n    if (checkclearop(cap->oap))\n      return;\n    n = nchar - '0';\n    for (;; ) {\n      no_mapping++;\n      nchar = plain_vgetc();\n      LANGMAP_ADJUST(nchar, true);\n      no_mapping--;\n      (void)add_to_showcmd(nchar);\n      if (nchar == K_DEL || nchar == K_KDEL)\n        n /= 10;\n      else if (ascii_isdigit(nchar))\n        n = n * 10 + (nchar - '0');\n      else if (nchar == CAR) {\n        win_setheight(n);\n        break;\n      } else if (nchar == 'l'\n                 || nchar == 'h'\n                 || nchar == K_LEFT\n                 || nchar == K_RIGHT) {\n        cap->count1 = n ? n * cap->count1 : cap->count1;\n        goto dozet;\n      } else {\n        clearopbeep(cap->oap);\n        break;\n      }\n    }\n    cap->oap->op_type = OP_NOP;\n    return;\n  }\n\ndozet:\n  // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n  // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n  // commands. */\n  if (cap->nchar != 'f' && cap->nchar != 'F'\n      && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n      && cap->nchar != 'j' && cap->nchar != 'k'\n      && checkclearop(cap->oap)) {\n    return;\n  }\n\n  /*\n   * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n   * If line number given, set cursor.\n   */\n  if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n      && cap->count0\n      && cap->count0 != curwin->w_cursor.lnum) {\n    setpcmark();\n    if (cap->count0 > curbuf->b_ml.ml_line_count)\n      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    else\n      curwin->w_cursor.lnum = cap->count0;\n    check_cursor_col();\n  }\n\n  switch (nchar) {\n  /* \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen */\n  case '+':\n    if (cap->count0 == 0) {\n      // No count given: put cursor at the line below screen\n      validate_botline(curwin);               // make sure w_botline is valid\n      if (curwin->w_botline > curbuf->b_ml.ml_line_count) {\n        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      } else {\n        curwin->w_cursor.lnum = curwin->w_botline;\n      }\n    }\n    FALLTHROUGH;\n  case NL:\n  case CAR:\n  case K_KENTER:\n    beginline(BL_WHITE | BL_FIX);\n    FALLTHROUGH;\n\n  case 't':   scroll_cursor_top(0, true);\n    redraw_later(curwin, VALID);\n    set_fraction(curwin);\n    break;\n\n  /* \"z.\" and \"zz\": put cursor in middle of screen */\n  case '.':   beginline(BL_WHITE | BL_FIX);\n  FALLTHROUGH;\n\n  case 'z':   scroll_cursor_halfway(true);\n    redraw_later(curwin, VALID);\n    set_fraction(curwin);\n    break;\n\n  // \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n  case '^':     // Strange Vi behavior: <count>z^ finds line at top of window\n                // when <count> is at bottom of window, and puts that one at\n                // bottom of window.\n    if (cap->count0 != 0) {\n      scroll_cursor_bot(0, true);\n      curwin->w_cursor.lnum = curwin->w_topline;\n    } else if (curwin->w_topline == 1)\n      curwin->w_cursor.lnum = 1;\n    else\n      curwin->w_cursor.lnum = curwin->w_topline - 1;\n    FALLTHROUGH;\n  case '-':\n    beginline(BL_WHITE | BL_FIX);\n    FALLTHROUGH;\n\n  case 'b':   scroll_cursor_bot(0, true);\n    redraw_later(curwin, VALID);\n    set_fraction(curwin);\n    break;\n\n  /* \"zH\" - scroll screen right half-page */\n  case 'H':\n    cap->count1 *= curwin->w_width_inner / 2;\n    FALLTHROUGH;\n\n  /* \"zh\" - scroll screen to the right */\n  case 'h':\n  case K_LEFT:\n    if (!curwin->w_p_wrap) {\n      if ((colnr_T)cap->count1 > curwin->w_leftcol)\n        curwin->w_leftcol = 0;\n      else\n        curwin->w_leftcol -= (colnr_T)cap->count1;\n      leftcol_changed();\n    }\n    break;\n\n  // \"zL\" - scroll screen left half-page\n  case 'L':   cap->count1 *= curwin->w_width_inner / 2;\n    FALLTHROUGH;\n\n  /* \"zl\" - scroll screen to the left */\n  case 'l':\n  case K_RIGHT:\n    if (!curwin->w_p_wrap) {\n      /* scroll the window left */\n      curwin->w_leftcol += (colnr_T)cap->count1;\n      leftcol_changed();\n    }\n    break;\n\n  /* \"zs\" - scroll screen, cursor at the start */\n  case 's':   if (!curwin->w_p_wrap) {\n      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n        col = 0;                        /* like the cursor is in col 0 */\n      else\n        getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n      if (col > l_p_siso)\n        col -= l_p_siso;\n      else\n        col = 0;\n      if (curwin->w_leftcol != col) {\n        curwin->w_leftcol = col;\n        redraw_later(curwin, NOT_VALID);\n      }\n  }\n    break;\n\n  /* \"ze\" - scroll screen, cursor at the end */\n  case 'e':   if (!curwin->w_p_wrap) {\n      if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n        col = 0;                        /* like the cursor is in col 0 */\n      else\n        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n      n = curwin->w_width_inner - curwin_col_off();\n      if (col + l_p_siso < n) {\n        col = 0;\n      } else {\n        col = col + l_p_siso - n + 1;\n      }\n      if (curwin->w_leftcol != col) {\n        curwin->w_leftcol = col;\n        redraw_later(curwin, NOT_VALID);\n      }\n  }\n    break;\n\n  // \"zp\", \"zP\" in block mode put without addind trailing spaces\n  case 'P':\n  case 'p':\n    nv_put(cap);\n    break;\n  // \"zy\" Yank without trailing spaces\n  case 'y':  nv_operator(cap);\n             break;\n\n  /* \"zF\": create fold command */\n  /* \"zf\": create fold operator */\n  case 'F':\n  case 'f':   if (foldManualAllowed(true)) {\n      cap->nchar = 'f';\n      nv_operator(cap);\n      curwin->w_p_fen = true;\n\n      /* \"zF\" is like \"zfzf\" */\n      if (nchar == 'F' && cap->oap->op_type == OP_FOLD) {\n        nv_operator(cap);\n        finish_op = true;\n      }\n  } else\n      clearopbeep(cap->oap);\n    break;\n\n  /* \"zd\": delete fold at cursor */\n  /* \"zD\": delete fold at cursor recursively */\n  case 'd':\n  case 'D':   if (foldManualAllowed(false)) {\n      if (VIsual_active) {\n        nv_operator(cap);\n      } else {\n        deleteFold(curwin, curwin->w_cursor.lnum,\n                   curwin->w_cursor.lnum, nchar == 'D', false);\n      }\n  }\n    break;\n\n  /* \"zE\": erase all folds */\n  case 'E':   if (foldmethodIsManual(curwin)) {\n      clearFolding(curwin);\n      changed_window_setting();\n    } else if (foldmethodIsMarker(curwin)) {\n      deleteFold(curwin, (linenr_T)1, curbuf->b_ml.ml_line_count, true, false);\n    } else {\n      EMSG(_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n    }\n    break;\n\n  /* \"zn\": fold none: reset 'foldenable' */\n  case 'n':   curwin->w_p_fen = false;\n    break;\n\n  /* \"zN\": fold Normal: set 'foldenable' */\n  case 'N':   curwin->w_p_fen = true;\n    break;\n\n  /* \"zi\": invert folding: toggle 'foldenable' */\n  case 'i':   curwin->w_p_fen = !curwin->w_p_fen;\n    break;\n\n  // \"za\": open closed fold or close open fold at cursor\n  case 'a':   if (hasFolding(curwin->w_cursor.lnum, NULL, NULL)) {\n      openFold(curwin->w_cursor, cap->count1);\n    } else {\n      closeFold(curwin->w_cursor, cap->count1);\n      curwin->w_p_fen = true;\n    }\n    break;\n\n  // \"zA\": open fold at cursor recursively\n  case 'A':   if (hasFolding(curwin->w_cursor.lnum, NULL, NULL)) {\n      openFoldRecurse(curwin->w_cursor);\n    } else {\n      closeFoldRecurse(curwin->w_cursor);\n      curwin->w_p_fen = true;\n    }\n    break;\n\n  // \"zo\": open fold at cursor or Visual area\n  case 'o':   if (VIsual_active) {\n      nv_operator(cap);\n    } else {\n      openFold(curwin->w_cursor, cap->count1);\n    }\n    break;\n\n  // \"zO\": open fold recursively\n  case 'O':   if (VIsual_active) {\n      nv_operator(cap);\n    } else {\n      openFoldRecurse(curwin->w_cursor);\n    }\n    break;\n\n  // \"zc\": close fold at cursor or Visual area\n  case 'c':   if (VIsual_active) {\n      nv_operator(cap);\n              } else {\n      closeFold(curwin->w_cursor, cap->count1);\n    }\n    curwin->w_p_fen = true;\n    break;\n\n  // \"zC\": close fold recursively\n  case 'C':   if (VIsual_active) {\n      nv_operator(cap);\n    } else {\n      closeFoldRecurse(curwin->w_cursor);\n    }\n    curwin->w_p_fen = true;\n    break;\n\n  /* \"zv\": open folds at the cursor */\n  case 'v':   foldOpenCursor();\n    break;\n\n  /* \"zx\": re-apply 'foldlevel' and open folds at the cursor */\n  case 'x':   curwin->w_p_fen = true;\n    curwin->w_foldinvalid = true;               /* recompute folds */\n    newFoldLevel();                             /* update right now */\n    foldOpenCursor();\n    break;\n\n  /* \"zX\": undo manual opens/closes, re-apply 'foldlevel' */\n  case 'X':   curwin->w_p_fen = true;\n    curwin->w_foldinvalid = true;               /* recompute folds */\n    old_fdl = -1;                               /* force an update */\n    break;\n\n  /* \"zm\": fold more */\n  case 'm':\n    if (curwin->w_p_fdl > 0) {\n      curwin->w_p_fdl -= cap->count1;\n      if (curwin->w_p_fdl < 0) {\n        curwin->w_p_fdl = 0;\n      }\n    }\n    old_fdl = -1;                       /* force an update */\n    curwin->w_p_fen = true;\n    break;\n\n  /* \"zM\": close all folds */\n  case 'M':   curwin->w_p_fdl = 0;\n    old_fdl = -1;                       /* force an update */\n    curwin->w_p_fen = true;\n    break;\n\n  /* \"zr\": reduce folding */\n  case 'r':\n    curwin->w_p_fdl += cap->count1;\n    {\n      int d = getDeepestNesting(curwin);\n      if (curwin->w_p_fdl >= d) {\n        curwin->w_p_fdl = d;\n      }\n    }\n    break;\n\n  case 'R':     //  \"zR\": open all folds\n    curwin->w_p_fdl = getDeepestNesting(curwin);\n    old_fdl = -1;                       // force an update\n    break;\n\n  case 'j':     /* \"zj\" move to next fold downwards */\n  case 'k':     /* \"zk\" move to next fold upwards */\n    if (foldMoveTo(true, nchar == 'j' ? FORWARD : BACKWARD,\n            cap->count1) == false)\n      clearopbeep(cap->oap);\n    break;\n\n\n  case 'u':     // \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n    no_mapping++;\n    nchar = plain_vgetc();\n    LANGMAP_ADJUST(nchar, true);\n    no_mapping--;\n    (void)add_to_showcmd(nchar);\n    if (vim_strchr((char_u *)\"gGwW\", nchar) == NULL) {\n      clearopbeep(cap->oap);\n      break;\n    }\n    undo = true;\n    FALLTHROUGH;\n\n  case 'g':     /* \"zg\": add good word to word list */\n  case 'w':     /* \"zw\": add wrong word to word list */\n  case 'G':     /* \"zG\": add good word to temp word list */\n  case 'W':     /* \"zW\": add wrong word to temp word list */\n  {\n    char_u  *ptr = NULL;\n    size_t len;\n\n    if (checkclearop(cap->oap))\n      break;\n    if (VIsual_active && !get_visual_text(cap, &ptr, &len))\n      return;\n    if (ptr == NULL) {\n      pos_T pos = curwin->w_cursor;\n\n      /* Find bad word under the cursor.  When 'spell' is\n       * off this fails and find_ident_under_cursor() is\n       * used below. */\n      emsg_off++;\n      len = spell_move_to(curwin, FORWARD, true, true, NULL);\n      emsg_off--;\n      if (len != 0 && curwin->w_cursor.col <= pos.col)\n        ptr = ml_get_pos(&curwin->w_cursor);\n      curwin->w_cursor = pos;\n    }\n\n    if (ptr == NULL && (len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n      return;\n    assert(len <= INT_MAX);\n    spell_add_word(ptr, (int)len,\n                   nchar == 'w' || nchar == 'W'\n                   ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n                   (nchar == 'G' || nchar == 'W') ? 0 : (int)cap->count1,\n                   undo);\n  }\n  break;\n\n  case '=':     /* \"z=\": suggestions for a badly spelled word  */\n    if (!checkclearop(cap->oap))\n      spell_suggest((int)cap->count0);\n    break;\n\n  default:    clearopbeep(cap->oap);\n  }\n\n  /* Redraw when 'foldenable' changed */\n  if (old_fen != curwin->w_p_fen) {\n    if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {\n      /* Adjust 'foldenable' in diff-synced windows. */\n      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n        if (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb) {\n          wp->w_p_fen = curwin->w_p_fen;\n          changed_window_setting_win(wp);\n        }\n      }\n    }\n    changed_window_setting();\n  }\n\n  /* Redraw when 'foldlevel' changed. */\n  if (old_fdl != curwin->w_p_fdl)\n    newFoldLevel();\n}\n\n\n\n/*\n * \"Q\" command.\n */\nstatic void nv_exmode(cmdarg_T *cap)\n{\n  /*\n   * Ignore 'Q' in Visual mode, just give a beep.\n   */\n  if (VIsual_active) {\n    vim_beep(BO_EX);\n  } else if (!checkclearop(cap->oap)) {\n    do_exmode();\n  }\n}\n\n/// Handle a \":\" command and <Cmd>.\nstatic void nv_colon(cmdarg_T *cap)\n{\n  int old_p_im;\n  bool cmd_result;\n  bool is_cmdkey = cap->cmdchar == K_COMMAND;\n\n  if (VIsual_active && !is_cmdkey) {\n    nv_operator(cap);\n  } else {\n    if (cap->oap->op_type != OP_NOP) {\n      // Using \":\" as a movement is charwise exclusive.\n      cap->oap->motion_type = kMTCharWise;\n      cap->oap->inclusive = false;\n    } else if (cap->count0 && !is_cmdkey) {\n      // translate \"count:\" into \":.,.+(count - 1)\"\n      stuffcharReadbuff('.');\n      if (cap->count0 > 1) {\n        stuffReadbuff(\",.+\");\n        stuffnumReadbuff(cap->count0 - 1L);\n      }\n    }\n\n    /* When typing, don't type below an old message */\n    if (KeyTyped)\n      compute_cmdrow();\n\n    old_p_im = p_im;\n\n    // get a command line and execute it\n    cmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,\n                            cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);\n\n    /* If 'insertmode' changed, enter or exit Insert mode */\n    if (p_im != old_p_im) {\n      if (p_im)\n        restart_edit = 'i';\n      else\n        restart_edit = 0;\n    }\n\n    if (cmd_result == false)\n      /* The Ex command failed, do not execute the operator. */\n      clearop(cap->oap);\n    else if (cap->oap->op_type != OP_NOP\n             && (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n                 || cap->oap->start.col >\n                 (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n                 || did_emsg\n                 ))\n      /* The start of the operator has become invalid by the Ex command.\n       */\n      clearopbeep(cap->oap);\n  }\n}\n\n/*\n * Handle CTRL-G command.\n */\nstatic void nv_ctrlg(cmdarg_T *cap)\n{\n  if (VIsual_active) {  /* toggle Selection/Visual mode */\n    VIsual_select = !VIsual_select;\n    showmode();\n  } else if (!checkclearop(cap->oap))\n    /* print full name if count given or :cd used */\n    fileinfo((int)cap->count0, false, true);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\nstatic void nv_ctrlh(cmdarg_T *cap)\n{\n  if (VIsual_active && VIsual_select) {\n    cap->cmdchar = 'x';         /* BS key behaves like 'x' in Select mode */\n    v_visop(cap);\n  } else\n    nv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\nstatic void nv_clear(cmdarg_T *cap)\n{\n  if (!checkclearop(cap->oap)) {\n    /* Clear all syntax states to force resyncing. */\n    syn_stack_free_all(curwin->w_s);\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      wp->w_s->b_syn_slow = false;\n    }\n    redraw_later(curwin, CLEAR);\n  }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\nstatic void nv_ctrlo(cmdarg_T *cap)\n{\n  if (VIsual_active && VIsual_select) {\n    VIsual_select = false;\n    showmode();\n    restart_VIsual_select = 2;          /* restart Select mode later */\n  } else {\n    cap->count1 = -cap->count1;\n    nv_pcmark(cap);\n  }\n}\n\n// CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n// not named.\nstatic void nv_hat(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap))\n    (void)buflist_getfile((int)cap->count0, (linenr_T)0,\n        GETF_SETMARK|GETF_ALT, false);\n}\n\n/*\n * \"Z\" commands.\n */\nstatic void nv_Zet(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap)) {\n    switch (cap->nchar) {\n    /* \"ZZ\": equivalent to \":x\". */\n    case 'Z':   do_cmdline_cmd(\"x\");\n      break;\n\n    /* \"ZQ\": equivalent to \":q!\" (Elvis compatible). */\n    case 'Q':   do_cmdline_cmd(\"q!\");\n      break;\n\n    default:    clearopbeep(cap->oap);\n    }\n  }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\nvoid do_nv_ident(int c1, int c2)\n{\n  oparg_T oa;\n  cmdarg_T ca;\n\n  clear_oparg(&oa);\n  memset(&ca, 0, sizeof(ca));\n  ca.oap = &oa;\n  ca.cmdchar = c1;\n  ca.nchar = c2;\n  nv_ident(&ca);\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\nstatic void nv_ident(cmdarg_T *cap)\n{\n  char_u      *ptr = NULL;\n  char_u      *p;\n  size_t n = 0;                 /* init for GCC */\n  int cmdchar;\n  bool g_cmd;                   /* \"g\" command */\n  bool tag_cmd = false;\n  char_u      *aux_ptr;\n\n  if (cap->cmdchar == 'g') {    /* \"g*\", \"g#\", \"g]\" and \"gCTRL-]\" */\n    cmdchar = cap->nchar;\n    g_cmd = true;\n  } else {\n    cmdchar = cap->cmdchar;\n    g_cmd = false;\n  }\n\n  if (cmdchar == POUND)         /* the pound sign, '#' for English keyboards */\n    cmdchar = '#';\n\n  /*\n   * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n   */\n  if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K') {\n    if (VIsual_active && get_visual_text(cap, &ptr, &n) == false)\n      return;\n    if (checkclearopq(cap->oap))\n      return;\n  }\n\n  if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n                                                  ((cmdchar == '*'\n                                                    || cmdchar == '#')\n                                                   ? FIND_IDENT|FIND_STRING\n                                                   : FIND_IDENT))) == 0) {\n    clearop(cap->oap);\n    return;\n  }\n\n  /* Allocate buffer to put the command in.  Inserting backslashes can\n   * double the length of the word.  p_kp / curbuf->b_p_kp could be added\n   * and some numbers. */\n  char_u *kp = *curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp;  // 'keywordprg'\n  assert(*kp != NUL);  // option.c:do_set() should default to \":help\" if empty.\n  bool kp_ex = (*kp == ':');  // 'keywordprg' is an ex command\n  bool kp_help = (STRCMP(kp, \":he\") == 0 || STRCMP(kp, \":help\") == 0);\n  if (kp_help && *skipwhite(ptr) == NUL) {\n    EMSG(_(e_noident));   // found white space only\n    return;\n  }\n  size_t buf_size = n * 2 + 30 + STRLEN(kp);\n  char *buf = xmalloc(buf_size);\n  buf[0] = NUL;\n\n  switch (cmdchar) {\n  case '*':\n  case '#':\n    /*\n     * Put cursor at start of word, makes search skip the word\n     * under the cursor.\n     * Call setpcmark() first, so \"*``\" puts the cursor back where\n     * it was.\n     */\n    setpcmark();\n    curwin->w_cursor.col = (colnr_T) (ptr - get_cursor_line_ptr());\n\n    if (!g_cmd && vim_iswordp(ptr))\n      STRCPY(buf, \"\\\\<\");\n    no_smartcase = true;                /* don't use 'smartcase' now */\n    break;\n\n  case 'K':\n    if (kp_help) {\n      STRCPY(buf, \"he! \");\n    } else if (kp_ex) {\n      if (cap->count0 != 0) {  // Send the count to the ex command.\n        snprintf(buf, buf_size, \"%\" PRId64, (int64_t)(cap->count0));\n      }\n      STRCAT(buf, kp);\n      STRCAT(buf, \" \");\n    } else {\n      /* An external command will probably use an argument starting\n       * with \"-\" as an option.  To avoid trouble we skip the \"-\". */\n      while (*ptr == '-' && n > 0) {\n        ++ptr;\n        --n;\n      }\n      if (n == 0) {\n        EMSG(_(e_noident));              /* found dashes only */\n        xfree(buf);\n        return;\n      }\n\n      /* When a count is given, turn it into a range.  Is this\n       * really what we want? */\n      bool isman = (STRCMP(kp, \"man\") == 0);\n      bool isman_s = (STRCMP(kp, \"man -s\") == 0);\n      if (cap->count0 != 0 && !(isman || isman_s)) {\n        snprintf(buf, buf_size, \".,.+%\" PRId64, (int64_t)(cap->count0 - 1));\n      }\n\n      do_cmdline_cmd(\"tabnew\");\n      STRCAT(buf, \"terminal \");\n      if (cap->count0 == 0 && isman_s) {\n        STRCAT(buf, \"man\");\n      } else {\n        STRCAT(buf, kp);\n      }\n      STRCAT(buf, \" \");\n      if (cap->count0 != 0 && (isman || isman_s)) {\n        snprintf(buf + STRLEN(buf), buf_size - STRLEN(buf), \"%\" PRId64,\n            (int64_t)cap->count0);\n        STRCAT(buf, \" \");\n      }\n    }\n    break;\n\n  case ']':\n    tag_cmd = true;\n    if (p_cst)\n      STRCPY(buf, \"cstag \");\n    else\n      STRCPY(buf, \"ts \");\n    break;\n\n  default:\n    tag_cmd = true;\n    if (curbuf->b_help)\n      STRCPY(buf, \"he! \");\n    else {\n      if (g_cmd)\n        STRCPY(buf, \"tj \");\n      else\n        snprintf(buf, buf_size, \"%\" PRId64 \"ta \", (int64_t)cap->count0);\n    }\n  }\n\n  // Now grab the chars in the identifier\n  if (cmdchar == 'K' && !kp_help) {\n    ptr = vim_strnsave(ptr, n);\n    if (kp_ex) {\n      // Escape the argument properly for an Ex command\n      p = (char_u *)vim_strsave_fnameescape((const char *)ptr, false);\n    } else {\n      // Escape the argument properly for a shell command\n      p = vim_strsave_shellescape(ptr, true, true);\n    }\n    xfree(ptr);\n    char *newbuf = xrealloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n    buf = newbuf;\n    STRCAT(buf, p);\n    xfree(p);\n  } else {\n    if (cmdchar == '*')\n      aux_ptr = (char_u *)(p_magic ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n    else if (cmdchar == '#')\n      aux_ptr = (char_u *)(p_magic ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n    else if (tag_cmd) {\n      if (curbuf->b_help)\n        /* \":help\" handles unescaped argument */\n        aux_ptr = (char_u *)\"\";\n      else\n        aux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n    } else\n      aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n    p = (char_u *)buf + STRLEN(buf);\n    while (n-- > 0) {\n      /* put a backslash before \\ and some others */\n      if (vim_strchr(aux_ptr, *ptr) != NULL)\n        *p++ = '\\\\';\n      /* When current byte is a part of multibyte character, copy all\n       * bytes of that character. */\n      const size_t len = (size_t)(utfc_ptr2len(ptr) - 1);\n      for (size_t i = 0; i < len && n > 0; i++, n--) {\n        *p++ = *ptr++;\n      }\n      *p++ = *ptr++;\n    }\n    *p = NUL;\n  }\n\n  /*\n   * Execute the command.\n   */\n  if (cmdchar == '*' || cmdchar == '#') {\n    if (!g_cmd\n        && vim_iswordp(mb_prevptr(get_cursor_line_ptr(), ptr))) {\n      STRCAT(buf, \"\\\\>\");\n    }\n    // put pattern in search history\n    init_history();\n    add_to_history(HIST_SEARCH, (char_u *)buf, true, NUL);\n    (void)normal_search(cap, cmdchar == '*' ? '/' : '?', (char_u *)buf, 0,\n                        NULL);\n  } else {\n    g_tag_at_cursor = true;\n    do_cmdline_cmd(buf);\n    g_tag_at_cursor = false;\n\n    if (cmdchar == 'K' && !kp_ex && !kp_help) {\n      // Start insert mode in terminal buffer\n      restart_edit = 'i';\n\n      add_map((char_u *)\"<buffer> <esc> <Cmd>call jobstop(&channel)<CR>\", TERM_FOCUS, true);\n      do_cmdline_cmd(\"autocmd TermClose <buffer> \"\n                     \" if !v:event.status |\"\n                     \"   exec 'bdelete! ' .. expand('<abuf>') |\"\n                     \" endif\");\n    }\n  }\n\n  xfree(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns false if more than one line selected.\n */\nbool\nget_visual_text (\n    cmdarg_T *cap,\n    char_u **pp,           /* return: start of selected text */\n    size_t *lenp           /* return: length of selected text */\n)\n{\n  if (VIsual_mode != 'V')\n    unadjust_for_sel();\n  if (VIsual.lnum != curwin->w_cursor.lnum) {\n    if (cap != NULL)\n      clearopbeep(cap->oap);\n    return false;\n  }\n  if (VIsual_mode == 'V') {\n    *pp = get_cursor_line_ptr();\n    *lenp = STRLEN(*pp);\n  } else {\n    if (lt(curwin->w_cursor, VIsual)) {\n      *pp = ml_get_pos(&curwin->w_cursor);\n      *lenp = (size_t)VIsual.col - (size_t)curwin->w_cursor.col + 1;\n    } else {\n      *pp = ml_get_pos(&VIsual);\n      *lenp = (size_t)curwin->w_cursor.col - (size_t)VIsual.col + 1;\n    }\n    // Correct the length to include the whole last character.\n    *lenp += (size_t)(utfc_ptr2len(*pp + (*lenp - 1)) - 1);\n  }\n  reset_VIsual_and_resel();\n  return true;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\nstatic void nv_tagpop(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap))\n    do_tag((char_u *)\"\", DT_POP, (int)cap->count1, false, true);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\nstatic void nv_scroll(cmdarg_T *cap)\n{\n  int used = 0;\n  long n;\n  linenr_T lnum;\n  int half;\n\n  cap->oap->motion_type = kMTLineWise;\n  setpcmark();\n\n  if (cap->cmdchar == 'L') {\n    validate_botline(curwin);          // make sure curwin->w_botline is valid\n    curwin->w_cursor.lnum = curwin->w_botline - 1;\n    if (cap->count1 - 1 >= curwin->w_cursor.lnum)\n      curwin->w_cursor.lnum = 1;\n    else {\n      if (hasAnyFolding(curwin)) {\n        /* Count a fold for one screen line. */\n        for (n = cap->count1 - 1; n > 0\n             && curwin->w_cursor.lnum > curwin->w_topline; --n) {\n          (void)hasFolding(curwin->w_cursor.lnum,\n              &curwin->w_cursor.lnum, NULL);\n          --curwin->w_cursor.lnum;\n        }\n      } else\n        curwin->w_cursor.lnum -= cap->count1 - 1;\n    }\n  } else {\n    if (cap->cmdchar == 'M') {\n      /* Don't count filler lines above the window. */\n      used -= diff_check_fill(curwin, curwin->w_topline)\n              - curwin->w_topfill;\n      validate_botline(curwin);  // make sure w_empty_rows is valid\n      half = (curwin->w_height_inner - curwin->w_empty_rows + 1) / 2;\n      for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; n++) {\n        // Count half he number of filler lines to be \"below this\n        // line\" and half to be \"above the next line\".\n        if (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n                + n) / 2 >= half) {\n          --n;\n          break;\n        }\n        used += plines_win(curwin, curwin->w_topline + n, true);\n        if (used >= half) {\n          break;\n        }\n        if (hasFolding(curwin->w_topline + n, NULL, &lnum)) {\n          n = lnum - curwin->w_topline;\n        }\n      }\n      if (n > 0 && used > curwin->w_height_inner) {\n        n--;\n      }\n    } else {  // (cap->cmdchar == 'H')\n      n = cap->count1 - 1;\n      if (hasAnyFolding(curwin)) {\n        /* Count a fold for one screen line. */\n        lnum = curwin->w_topline;\n        while (n-- > 0 && lnum < curwin->w_botline - 1) {\n          (void)hasFolding(lnum, NULL, &lnum);\n          lnum++;\n        }\n        n = lnum - curwin->w_topline;\n      }\n    }\n    curwin->w_cursor.lnum = curwin->w_topline + n;\n    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n      curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n  }\n\n  // Correct for 'so', except when an operator is pending.\n  if (cap->oap->op_type == OP_NOP) {\n    cursor_correct();\n  }\n  beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\nstatic void nv_right(cmdarg_T *cap)\n{\n  long n;\n  int PAST_LINE;\n\n  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {\n    /* <C-Right> and <S-Right> move a word or WORD right */\n    if (mod_mask & MOD_MASK_CTRL)\n      cap->arg = true;\n    nv_wordcmd(cap);\n    return;\n  }\n\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  PAST_LINE = (VIsual_active && *p_sel != 'o');\n\n  /*\n   * In virtual mode, there's no such thing as \"PAST_LINE\", as lines are\n   * (theoretically) infinitely long.\n   */\n  if (virtual_active())\n    PAST_LINE = 0;\n\n  for (n = cap->count1; n > 0; --n) {\n    if ((!PAST_LINE && oneright() == false)\n        || (PAST_LINE && *get_cursor_pos_ptr() == NUL)\n        ) {\n      //          <Space> wraps to next line if 'whichwrap' has 's'.\n      //              'l' wraps to next line if 'whichwrap' has 'l'.\n      // CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n      if (((cap->cmdchar == ' ' && vim_strchr(p_ww, 's') != NULL)\n           || (cap->cmdchar == 'l' && vim_strchr(p_ww, 'l') != NULL)\n           || (cap->cmdchar == K_RIGHT && vim_strchr(p_ww, '>') != NULL))\n          && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {\n        // When deleting we also count the NL as a character.\n        // Set cap->oap->inclusive when last char in the line is\n        // included, move to next line after that\n        if (cap->oap->op_type != OP_NOP\n            && !cap->oap->inclusive\n            && !LINEEMPTY(curwin->w_cursor.lnum)) {\n          cap->oap->inclusive = true;\n        } else {\n          ++curwin->w_cursor.lnum;\n          curwin->w_cursor.col = 0;\n          curwin->w_cursor.coladd = 0;\n          curwin->w_set_curswant = true;\n          cap->oap->inclusive = false;\n        }\n        continue;\n      }\n      if (cap->oap->op_type == OP_NOP) {\n        // Only beep and flush if not moved at all\n        if (n == cap->count1) {\n          beep_flush();\n        }\n      } else {\n        if (!LINEEMPTY(curwin->w_cursor.lnum)) {\n          cap->oap->inclusive = true;\n        }\n      }\n      break;\n    } else if (PAST_LINE) {\n      curwin->w_set_curswant = true;\n      if (virtual_active()) {\n        oneright();\n      } else {\n        curwin->w_cursor.col += (*mb_ptr2len)(get_cursor_pos_ptr());\n      }\n    }\n  }\n  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n      && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n}\n\n/*\n * Cursor left commands.\n *\n * Returns true when operator end should not be adjusted.\n */\nstatic void nv_left(cmdarg_T *cap)\n{\n  long n;\n\n  if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL)) {\n    /* <C-Left> and <S-Left> move a word or WORD left */\n    if (mod_mask & MOD_MASK_CTRL)\n      cap->arg = 1;\n    nv_bck_word(cap);\n    return;\n  }\n\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  for (n = cap->count1; n > 0; --n) {\n    if (oneleft() == false) {\n      /* <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n       *\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n       *\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n       */\n      if ((((cap->cmdchar == K_BS || cap->cmdchar == Ctrl_H)\n            && vim_strchr(p_ww, 'b') != NULL)\n           || (cap->cmdchar == 'h' && vim_strchr(p_ww, 'h') != NULL)\n           || (cap->cmdchar == K_LEFT && vim_strchr(p_ww, '<') != NULL))\n          && curwin->w_cursor.lnum > 1) {\n        curwin->w_cursor.lnum--;\n        coladvance(MAXCOL);\n        curwin->w_set_curswant = true;\n\n        // When the NL before the first char has to be deleted we\n        // put the cursor on the NUL after the previous line.\n        // This is a very special case, be careful!\n        // Don't adjust op_end now, otherwise it won't work.\n        if ((cap->oap->op_type == OP_DELETE || cap->oap->op_type == OP_CHANGE)\n            && !LINEEMPTY(curwin->w_cursor.lnum)) {\n          char_u *cp = get_cursor_pos_ptr();\n\n          if (*cp != NUL) {\n            curwin->w_cursor.col += utfc_ptr2len(cp);\n          }\n          cap->retval |= CA_NO_ADJ_OP_END;\n        }\n        continue;\n      }\n      /* Only beep and flush if not moved at all */\n      else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n        beep_flush();\n      break;\n    }\n  }\n  if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n      && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n}\n\n/*\n * Cursor up commands.\n * cap->arg is true for \"-\": Move cursor to first non-blank.\n */\nstatic void nv_up(cmdarg_T *cap)\n{\n  if (mod_mask & MOD_MASK_SHIFT) {\n    /* <S-Up> is page up */\n    cap->arg = BACKWARD;\n    nv_page(cap);\n  } else {\n    cap->oap->motion_type = kMTLineWise;\n    if (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == false) {\n      clearopbeep(cap->oap);\n    } else if (cap->arg) {\n      beginline(BL_WHITE | BL_FIX);\n    }\n  }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is true for CR and \"+\": Move cursor to first non-blank.\n */\nstatic void nv_down(cmdarg_T *cap)\n{\n  if (mod_mask & MOD_MASK_SHIFT) {\n    /* <S-Down> is page down */\n    cap->arg = FORWARD;\n    nv_page(cap);\n  } else if (bt_quickfix(curbuf) && cap->cmdchar == CAR) {\n    // Quickfix window only: view the result under the cursor.\n    qf_view_result(false);\n  } else {\n    // In the cmdline window a <CR> executes the command.\n    if (cmdwin_type != 0 && cap->cmdchar == CAR) {\n      cmdwin_result = CAR;\n    } else if (bt_prompt(curbuf) && cap->cmdchar == CAR\n               && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {\n      // In a prompt buffer a <CR> in the last line invokes the callback.\n      invoke_prompt_callback();\n      if (restart_edit == 0) {\n        restart_edit = 'a';\n      }\n    } else {\n      cap->oap->motion_type = kMTLineWise;\n      if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == false) {\n        clearopbeep(cap->oap);\n      } else if (cap->arg) {\n        beginline(BL_WHITE | BL_FIX);\n      }\n    }\n  }\n}\n\n/*\n * Grab the file name under the cursor and edit it.\n */\nstatic void nv_gotofile(cmdarg_T *cap)\n{\n  char_u      *ptr;\n  linenr_T lnum = -1;\n\n  if (text_locked()) {\n    clearopbeep(cap->oap);\n    text_locked_msg();\n    return;\n  }\n  if (curbuf_locked()) {\n    clearop(cap->oap);\n    return;\n  }\n\n  ptr = grab_file_name(cap->count1, &lnum);\n\n  if (ptr != NULL) {\n    // do autowrite if necessary\n    if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf)) {\n      (void)autowrite(curbuf, false);\n    }\n    setpcmark();\n    if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n                buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n        && cap->nchar == 'F' && lnum >= 0) {\n      curwin->w_cursor.lnum = lnum;\n      check_cursor_lnum();\n      beginline(BL_SOL | BL_FIX);\n    }\n    xfree(ptr);\n  } else\n    clearop(cap->oap);\n}\n\n/*\n * <End> command: to end of current line or last line.\n */\nstatic void nv_end(cmdarg_T *cap)\n{\n  if (cap->arg || (mod_mask & MOD_MASK_CTRL)) { /* CTRL-END = goto last line */\n    cap->arg = true;\n    nv_goto(cap);\n    cap->count1 = 1;                    /* to end of current line */\n  }\n  nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\nstatic void nv_dollar(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = true;\n  /* In virtual mode when off the edge of a line and an operator\n   * is pending (whew!) keep the cursor where it is.\n   * Otherwise, send it to the end of the line. */\n  if (!virtual_active() || gchar_cursor() != NUL\n      || cap->oap->op_type == OP_NOP)\n    curwin->w_curswant = MAXCOL;        /* so we stay at the end */\n  if (cursor_down(cap->count1 - 1,\n          cap->oap->op_type == OP_NOP) == false)\n    clearopbeep(cap->oap);\n  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is true don't set PC mark.\n */\nstatic void nv_search(cmdarg_T *cap)\n{\n  oparg_T     *oap = cap->oap;\n  pos_T save_cursor = curwin->w_cursor;\n\n  if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13) {\n    /* Translate \"g??\" to \"g?g?\" */\n    cap->cmdchar = 'g';\n    cap->nchar = '?';\n    nv_operator(cap);\n    return;\n  }\n\n  // When using 'incsearch' the cursor may be moved to set a different search\n  // start position.\n  cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, true);\n\n  if (cap->searchbuf == NULL) {\n    clearop(oap);\n    return;\n  }\n\n  (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n                      (cap->arg || !equalpos(save_cursor, curwin->w_cursor))\n                      ? 0 : SEARCH_MARK, NULL);\n}\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\nstatic void nv_next(cmdarg_T *cap)\n{\n  pos_T old = curwin->w_cursor;\n  int wrapped = false;\n  int i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n  if (i == 1 && !wrapped && equalpos(old, curwin->w_cursor)) {\n    // Avoid getting stuck on the current cursor position, which can happen when\n    // an offset is given and the cursor is on the last char in the buffer:\n    // Repeat with count + 1.\n    cap->count1 += 1;\n    (void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n    cap->count1 -= 1;\n  }\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\nstatic int normal_search(\n    cmdarg_T *cap,\n    int dir,\n    char_u *pat,\n    int opt,        // extra flags for do_search()\n    int *wrapped\n)\n{\n  int i;\n  searchit_arg_T sia;\n\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  cap->oap->use_reg_one = true;\n  curwin->w_set_curswant = true;\n\n  memset(&sia, 0, sizeof(sia));\n  i = do_search(cap->oap, dir, dir, pat, cap->count1,\n                opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n  if (wrapped != NULL) {\n    *wrapped = sia.sa_wrapped;\n  }\n  if (i == 0) {\n    clearop(cap->oap);\n  } else {\n    if (i == 2) {\n      cap->oap->motion_type = kMTLineWise;\n    }\n    curwin->w_cursor.coladd = 0;\n    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n      foldOpenCursor();\n  }\n\n  /* \"/$\" will put the cursor after the end of the line, may need to\n   * correct that here */\n  check_cursor();\n  return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', true for\n * ',' and false for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\nstatic void nv_csearch(cmdarg_T *cap)\n{\n  bool t_cmd;\n\n  if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n    t_cmd = true;\n  else\n    t_cmd = false;\n\n  cap->oap->motion_type = kMTCharWise;\n  if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == false) {\n    clearopbeep(cap->oap);\n  } else {\n    curwin->w_set_curswant = true;\n    /* Include a Tab for \"tx\" and for \"dfx\". */\n    if (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n        && (t_cmd || cap->oap->op_type != OP_NOP)) {\n      colnr_T scol, ecol;\n\n      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n      curwin->w_cursor.coladd = ecol - scol;\n    } else\n      curwin->w_cursor.coladd = 0;\n    adjust_for_sel(cap);\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n      foldOpenCursor();\n  }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\nstatic void nv_brackets(cmdarg_T *cap)\n{\n  pos_T new_pos = { 0, 0, 0 };\n  pos_T prev_pos;\n  pos_T       *pos = NULL;          /* init for GCC */\n  pos_T old_pos;                    /* cursor position before command */\n  int flag;\n  long n;\n  int findc;\n  int c;\n\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  old_pos = curwin->w_cursor;\n  curwin->w_cursor.coladd = 0;              /* TODO: don't do this for an error. */\n\n  /*\n   * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n   */\n  if (cap->nchar == 'f')\n    nv_gotofile(cap);\n  else\n  /*\n   * Find the occurrence(s) of the identifier or define under cursor\n   * in current and included files or jump to the first occurrence.\n   *\n   *\t\t\tsearch\t     list\t    jump\n   *\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n   * identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n   * define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n   */\n  if (vim_strchr((char_u *)\n          \"iI\\011dD\\004\",\n          cap->nchar) != NULL) {\n    char_u  *ptr;\n    size_t len;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n      clearop(cap->oap);\n    else {\n      find_pattern_in_path(ptr, 0, len, true,\n                           cap->count0 == 0 ? !isupper(cap->nchar) : false,\n                           (((cap->nchar & 0xf) == ('d' & 0xf))\n                            ? FIND_DEFINE\n                            : FIND_ANY),\n                           cap->count1,\n                           (isupper(cap->nchar) ? ACTION_SHOW_ALL :\n                            islower(cap->nchar) ? ACTION_SHOW :\n                            ACTION_GOTO),\n                           (cap->cmdchar == ']'\n                            ? curwin->w_cursor.lnum + 1\n                            : (linenr_T)1),\n                           MAXLNUM);\n      curwin->w_set_curswant = true;\n    }\n  } else\n  /*\n   * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n   * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n   * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n   * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n   * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n   */\n  if (  (cap->cmdchar == '['\n         && vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n        || (cap->cmdchar == ']'\n            && vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL)) {\n    if (cap->nchar == '*')\n      cap->nchar = '/';\n    prev_pos.lnum = 0;\n    if (cap->nchar == 'm' || cap->nchar == 'M') {\n      if (cap->cmdchar == '[')\n        findc = '{';\n      else\n        findc = '}';\n      n = 9999;\n    } else {\n      findc = cap->nchar;\n      n = cap->count1;\n    }\n    for (; n > 0; --n) {\n      if ((pos = findmatchlimit(cap->oap, findc,\n               (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL) {\n        if (new_pos.lnum == 0) {        /* nothing found */\n          if (cap->nchar != 'm' && cap->nchar != 'M')\n            clearopbeep(cap->oap);\n        } else\n          pos = &new_pos;               /* use last one found */\n        break;\n      }\n      prev_pos = new_pos;\n      curwin->w_cursor = *pos;\n      new_pos = *pos;\n    }\n    curwin->w_cursor = old_pos;\n\n    /*\n     * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n     * brought us to the match for \"[m\" and \"]M\" when inside a method.\n     * Try finding the '{' or '}' we want to be at.\n     * Also repeat for the given count.\n     */\n    if (cap->nchar == 'm' || cap->nchar == 'M') {\n      /* norm is true for \"]M\" and \"[m\" */\n      int norm = ((findc == '{') == (cap->nchar == 'm'));\n\n      n = cap->count1;\n      /* found a match: we were inside a method */\n      if (prev_pos.lnum != 0) {\n        pos = &prev_pos;\n        curwin->w_cursor = prev_pos;\n        if (norm)\n          --n;\n      } else\n        pos = NULL;\n      while (n > 0) {\n        for (;; ) {\n          if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0) {\n            /* if not found anything, that's an error */\n            if (pos == NULL)\n              clearopbeep(cap->oap);\n            n = 0;\n            break;\n          }\n          c = gchar_cursor();\n          if (c == '{' || c == '}') {\n            /* Must have found end/start of class: use it.\n             * Or found the place to be at. */\n            if ((c == findc && norm) || (n == 1 && !norm)) {\n              new_pos = curwin->w_cursor;\n              pos = &new_pos;\n              n = 0;\n            }\n            /* if no match found at all, we started outside of the\n             * class and we're inside now.  Just go on. */\n            else if (new_pos.lnum == 0) {\n              new_pos = curwin->w_cursor;\n              pos = &new_pos;\n            }\n            /* found start/end of other method: go to match */\n            else if ((pos = findmatchlimit(cap->oap, findc,\n                          (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n                          0)) == NULL)\n              n = 0;\n            else\n              curwin->w_cursor = *pos;\n            break;\n          }\n        }\n        --n;\n      }\n      curwin->w_cursor = old_pos;\n      if (pos == NULL && new_pos.lnum != 0)\n        clearopbeep(cap->oap);\n    }\n    if (pos != NULL) {\n      setpcmark();\n      curwin->w_cursor = *pos;\n      curwin->w_set_curswant = true;\n      if ((fdo_flags & FDO_BLOCK) && KeyTyped\n          && cap->oap->op_type == OP_NOP)\n        foldOpenCursor();\n    }\n  }\n  /*\n   * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n   */\n  else if (cap->nchar == '[' || cap->nchar == ']') {\n    if (cap->nchar == cap->cmdchar)                 /* \"]]\" or \"[[\" */\n      flag = '{';\n    else\n      flag = '}';                   /* \"][\" or \"[]\" */\n\n    curwin->w_set_curswant = true;\n    /*\n     * Imitate strange Vi behaviour: When using \"]]\" with an operator\n     * we also stop at '}'.\n     */\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n            (cap->oap->op_type != OP_NOP\n             && cap->arg == FORWARD && flag == '{')))\n      clearopbeep(cap->oap);\n    else {\n      if (cap->oap->op_type == OP_NOP)\n        beginline(BL_WHITE | BL_FIX);\n      if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n        foldOpenCursor();\n    }\n  } else if (cap->nchar == 'p' || cap->nchar == 'P') {\n    // \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n    nv_put_opt(cap, true);\n  }\n  /*\n   * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n   */\n  else if (cap->nchar == '\\'' || cap->nchar == '`') {\n    pos = &curwin->w_cursor;\n    for (n = cap->count1; n > 0; --n) {\n      prev_pos = *pos;\n      pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n          cap->nchar == '\\'');\n      if (pos == NULL)\n        break;\n    }\n    if (pos == NULL)\n      pos = &prev_pos;\n    nv_cursormark(cap, cap->nchar == '\\'', pos);\n  }\n  /*\n   * [ or ] followed by a middle mouse click: put selected text with\n   * indent adjustment.  Any other button just does as usual.\n   */\n  else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE) {\n    (void)do_mouse(cap->oap, cap->nchar,\n        (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n        cap->count1, PUT_FIXINDENT);\n  }\n  /*\n   * \"[z\" and \"]z\": move to start or end of open fold.\n   */\n  else if (cap->nchar == 'z') {\n    if (foldMoveTo(false, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n            cap->count1) == false)\n      clearopbeep(cap->oap);\n  }\n  /*\n   * \"[c\" and \"]c\": move to next or previous diff-change.\n   */\n  else if (cap->nchar == 'c') {\n    if (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n            cap->count1) == false)\n      clearopbeep(cap->oap);\n  }\n  /*\n   * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n   */\n  else if (cap->nchar == 's' || cap->nchar == 'S') {\n    setpcmark();\n    for (n = 0; n < cap->count1; ++n)\n      if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n                        cap->nchar == 's', false, NULL) == 0) {\n        clearopbeep(cap->oap);\n        break;\n      } else {\n        curwin->w_set_curswant = true;\n      }\n    if (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n      foldOpenCursor();\n  }\n  /* Not a valid cap->nchar. */\n  else\n    clearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\nstatic void nv_percent(cmdarg_T *cap)\n{\n  pos_T       *pos;\n  linenr_T lnum = curwin->w_cursor.lnum;\n\n  cap->oap->inclusive = true;\n  if (cap->count0) {  // {cnt}% : goto {cnt} percentage in file\n    if (cap->count0 > 100) {\n      clearopbeep(cap->oap);\n    } else {\n      cap->oap->motion_type = kMTLineWise;\n      setpcmark();\n      // Round up, so 'normal 100%' always jumps at the line line.\n      // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n      // overflow on 32-bits, so use a formula with less accuracy\n      // to avoid overflows.\n      if (curbuf->b_ml.ml_line_count >= 21474836) {\n        curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n                                / 100L * cap->count0;\n      } else {\n        curwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n                                 cap->count0 + 99L) / 100L;\n      }\n      if (curwin->w_cursor.lnum < 1) {\n        curwin->w_cursor.lnum = 1;\n      }\n      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {\n        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      }\n      beginline(BL_SOL | BL_FIX);\n    }\n  } else {  // \"%\" : go to matching paren\n    cap->oap->motion_type = kMTCharWise;\n    cap->oap->use_reg_one = true;\n    if ((pos = findmatch(cap->oap, NUL)) == NULL)\n      clearopbeep(cap->oap);\n    else {\n      setpcmark();\n      curwin->w_cursor = *pos;\n      curwin->w_set_curswant = true;\n      curwin->w_cursor.coladd = 0;\n      adjust_for_sel(cap);\n    }\n  }\n  if (cap->oap->op_type == OP_NOP\n      && lnum != curwin->w_cursor.lnum\n      && (fdo_flags & FDO_PERCENT)\n      && KeyTyped)\n    foldOpenCursor();\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\nstatic void nv_brace(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->use_reg_one = true;\n  /* The motion used to be inclusive for \"(\", but that is not what Vi does. */\n  cap->oap->inclusive = false;\n  curwin->w_set_curswant = true;\n\n  if (findsent(cap->arg, cap->count1) == false)\n    clearopbeep(cap->oap);\n  else {\n    /* Don't leave the cursor on the NUL past end of line. */\n    adjust_cursor(cap->oap);\n    curwin->w_cursor.coladd = 0;\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n      foldOpenCursor();\n  }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\nstatic void nv_mark(cmdarg_T *cap)\n{\n  if (!checkclearop(cap->oap)) {\n    if (setmark(cap->nchar) == false)\n      clearopbeep(cap->oap);\n  }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\nstatic void nv_findpar(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  cap->oap->use_reg_one = true;\n  curwin->w_set_curswant = true;\n  if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, false))\n    clearopbeep(cap->oap);\n  else {\n    curwin->w_cursor.coladd = 0;\n    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n      foldOpenCursor();\n  }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\nstatic void nv_undo(cmdarg_T *cap)\n{\n  if (cap->oap->op_type == OP_LOWER\n      || VIsual_active\n      ) {\n    /* translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\" */\n    cap->cmdchar = 'g';\n    cap->nchar = 'u';\n    nv_operator(cap);\n  } else\n    nv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\nstatic void nv_kundo(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap)) {\n    if (bt_prompt(curbuf)) {\n      clearopbeep(cap->oap);\n      return;\n    }\n    u_undo((int)cap->count1);\n    curwin->w_set_curswant = true;\n  }\n}\n\n/*\n * Handle the \"r\" command.\n */\nstatic void nv_replace(cmdarg_T *cap)\n{\n  char_u      *ptr;\n  int had_ctrl_v;\n\n  if (checkclearop(cap->oap)) {\n    return;\n  }\n  if (bt_prompt(curbuf) && !prompt_curpos_editable()) {\n    clearopbeep(cap->oap);\n    return;\n  }\n\n  /* get another character */\n  if (cap->nchar == Ctrl_V) {\n    had_ctrl_v = Ctrl_V;\n    cap->nchar = get_literal();\n    /* Don't redo a multibyte character with CTRL-V. */\n    if (cap->nchar > DEL)\n      had_ctrl_v = NUL;\n  } else\n    had_ctrl_v = NUL;\n\n  /* Abort if the character is a special key. */\n  if (IS_SPECIAL(cap->nchar)) {\n    clearopbeep(cap->oap);\n    return;\n  }\n\n  /* Visual mode \"r\" */\n  if (VIsual_active) {\n    if (got_int)\n      reset_VIsual();\n    if (had_ctrl_v) {\n      // Use a special (negative) number to make a difference between a\n      // literal CR or NL and a line break.\n      if (cap->nchar == CAR) {\n        cap->nchar = REPLACE_CR_NCHAR;\n      } else if (cap->nchar == NL) {\n        cap->nchar = REPLACE_NL_NCHAR;\n      }\n    }\n    nv_operator(cap);\n    return;\n  }\n\n  /* Break tabs, etc. */\n  if (virtual_active()) {\n    if (u_save_cursor() == false)\n      return;\n    if (gchar_cursor() == NUL) {\n      /* Add extra space and put the cursor on the first one. */\n      coladvance_force((colnr_T)(getviscol() + cap->count1));\n      assert(cap->count1 <= INT_MAX);\n      curwin->w_cursor.col -= (colnr_T)cap->count1;\n    } else if (gchar_cursor() == TAB)\n      coladvance_force(getviscol());\n  }\n\n  /* Abort if not enough characters to replace. */\n  ptr = get_cursor_pos_ptr();\n  if (STRLEN(ptr) < (unsigned)cap->count1\n      || (mb_charlen(ptr) < cap->count1)\n      ) {\n    clearopbeep(cap->oap);\n    return;\n  }\n\n  // Replacing with a TAB is done by edit() when it is complicated because\n  // 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n  // Other characters are done below to avoid problems with things like\n  // CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n  if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta)) {\n    stuffnumReadbuff(cap->count1);\n    stuffcharReadbuff('R');\n    stuffcharReadbuff('\\t');\n    stuffcharReadbuff(ESC);\n    return;\n  }\n\n  /* save line for undo */\n  if (u_save_cursor() == false)\n    return;\n\n  if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n')) {\n    /*\n     * Replace character(s) by a single newline.\n     * Strange vi behaviour: Only one newline is inserted.\n     * Delete the characters here.\n     * Insert the newline with an insert command, takes care of\n     * autoindent.\tThe insert command depends on being on the last\n     * character of a line or not.\n     */\n    (void)del_chars(cap->count1, false);        /* delete the characters */\n    stuffcharReadbuff('\\r');\n    stuffcharReadbuff(ESC);\n\n    /* Give 'r' to edit(), to get the redo command right. */\n    invoke_edit(cap, true, 'r', false);\n  } else {\n    prep_redo(cap->oap->regname, cap->count1,\n        NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n    curbuf->b_op_start = curwin->w_cursor;\n    const int old_State = State;\n\n    if (cap->ncharC1 != 0) {\n      AppendCharToRedobuff(cap->ncharC1);\n    }\n    if (cap->ncharC2 != 0) {\n      AppendCharToRedobuff(cap->ncharC2);\n    }\n\n    // This is slow, but it handles replacing a single-byte with a\n    // multi-byte and the other way around.  Also handles adding\n    // composing characters for utf-8.\n    for (long n = cap->count1; n > 0; n--) {\n      State = REPLACE;\n      if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) {\n        int c = ins_copychar(curwin->w_cursor.lnum\n                             + (cap->nchar == Ctrl_Y ? -1 : 1));\n        if (c != NUL) {\n          ins_char(c);\n        } else {\n          // will be decremented further down\n          curwin->w_cursor.col++;\n        }\n      } else {\n        ins_char(cap->nchar);\n      }\n      State = old_State;\n      if (cap->ncharC1 != 0) {\n        ins_char(cap->ncharC1);\n      }\n      if (cap->ncharC2 != 0) {\n        ins_char(cap->ncharC2);\n      }\n    }\n    --curwin->w_cursor.col;         /* cursor on the last replaced char */\n    /* if the character on the left of the current cursor is a multi-byte\n     * character, move two characters left */\n    mb_adjust_cursor();\n    curbuf->b_op_end = curwin->w_cursor;\n    curwin->w_set_curswant = true;\n    set_last_insert(cap->nchar);\n  }\n\n  foldUpdateAfterInsert();\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\nstatic void v_swap_corners(int cmdchar)\n{\n  pos_T old_cursor;\n  colnr_T left, right;\n\n  if (cmdchar == 'O' && VIsual_mode == Ctrl_V) {\n    old_cursor = curwin->w_cursor;\n    getvcols(curwin, &old_cursor, &VIsual, &left, &right);\n    curwin->w_cursor.lnum = VIsual.lnum;\n    coladvance(left);\n    VIsual = curwin->w_cursor;\n\n    curwin->w_cursor.lnum = old_cursor.lnum;\n    curwin->w_curswant = right;\n    /* 'selection \"exclusive\" and cursor at right-bottom corner: move it\n     * right one column */\n    if (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n      ++curwin->w_curswant;\n    coladvance(curwin->w_curswant);\n    if (curwin->w_cursor.col == old_cursor.col\n        && (!virtual_active()\n            || curwin->w_cursor.coladd == old_cursor.coladd)\n        ) {\n      curwin->w_cursor.lnum = VIsual.lnum;\n      if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n        ++right;\n      coladvance(right);\n      VIsual = curwin->w_cursor;\n\n      curwin->w_cursor.lnum = old_cursor.lnum;\n      coladvance(left);\n      curwin->w_curswant = left;\n    }\n  } else {\n    old_cursor = curwin->w_cursor;\n    curwin->w_cursor = VIsual;\n    VIsual = old_cursor;\n    curwin->w_set_curswant = true;\n  }\n}\n\n/*\n * \"R\" (cap->arg is false) and \"gR\" (cap->arg is true).\n */\nstatic void nv_Replace(cmdarg_T *cap)\n{\n  if (VIsual_active) {          /* \"R\" is replace lines */\n    cap->cmdchar = 'c';\n    cap->nchar = NUL;\n    VIsual_mode_orig = VIsual_mode;     /* remember original area for gv */\n    VIsual_mode = 'V';\n    nv_operator(cap);\n  } else if (!checkclearopq(cap->oap)) {\n    if (!MODIFIABLE(curbuf)) {\n      EMSG(_(e_modifiable));\n    } else {\n      if (virtual_active())\n        coladvance(getviscol());\n      invoke_edit(cap, false, cap->arg ? 'V' : 'R', false);\n    }\n  }\n}\n\n/*\n * \"gr\".\n */\nstatic void nv_vreplace(cmdarg_T *cap)\n{\n  if (VIsual_active) {\n    cap->cmdchar = 'r';\n    cap->nchar = cap->extra_char;\n    nv_replace(cap);            /* Do same as \"r\" in Visual mode for now */\n  } else if (!checkclearopq(cap->oap)) {\n    if (!MODIFIABLE(curbuf)) {\n      EMSG(_(e_modifiable));\n    } else {\n      if (cap->extra_char == Ctrl_V)            /* get another character */\n        cap->extra_char = get_literal();\n      stuffcharReadbuff(cap->extra_char);\n      stuffcharReadbuff(ESC);\n      if (virtual_active())\n        coladvance(getviscol());\n      invoke_edit(cap, true, 'v', false);\n    }\n  }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\nstatic void n_swapchar(cmdarg_T *cap)\n{\n  long n;\n  pos_T startpos;\n  int did_change = 0;\n\n  if (checkclearopq(cap->oap)) {\n    return;\n  }\n\n  if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL) {\n    clearopbeep(cap->oap);\n    return;\n  }\n\n  prep_redo_cmd(cap);\n\n  if (u_save_cursor() == false)\n    return;\n\n  startpos = curwin->w_cursor;\n  for (n = cap->count1; n > 0; --n) {\n    did_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n    inc_cursor();\n    if (gchar_cursor() == NUL) {\n      if (vim_strchr(p_ww, '~') != NULL\n          && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {\n        ++curwin->w_cursor.lnum;\n        curwin->w_cursor.col = 0;\n        if (n > 1) {\n          if (u_savesub(curwin->w_cursor.lnum) == false)\n            break;\n          u_clearline();\n        }\n      } else\n        break;\n    }\n  }\n\n\n  check_cursor();\n  curwin->w_set_curswant = true;\n  if (did_change) {\n    changed_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n                  0L, true);\n    curbuf->b_op_start = startpos;\n    curbuf->b_op_end = curwin->w_cursor;\n    if (curbuf->b_op_end.col > 0)\n      --curbuf->b_op_end.col;\n  }\n}\n\n/*\n * Move cursor to mark.\n */\nstatic void nv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n  if (check_mark(pos) == false)\n    clearop(cap->oap);\n  else {\n    if (cap->cmdchar == '\\''\n        || cap->cmdchar == '`'\n        || cap->cmdchar == '['\n        || cap->cmdchar == ']')\n      setpcmark();\n    curwin->w_cursor = *pos;\n    if (flag)\n      beginline(BL_WHITE | BL_FIX);\n    else\n      check_cursor();\n  }\n  cap->oap->motion_type = flag ? kMTLineWise : kMTCharWise;\n  if (cap->cmdchar == '`') {\n    cap->oap->use_reg_one = true;\n  }\n  cap->oap->inclusive = false;  // ignored if not kMTCharWise\n  curwin->w_set_curswant = true;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\nstatic void v_visop(cmdarg_T *cap)\n{\n  static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n  /* Uppercase means linewise, except in block mode, then \"D\" deletes till\n   * the end of the line, and \"C\" replaces till EOL */\n  if (isupper(cap->cmdchar)) {\n    if (VIsual_mode != Ctrl_V) {\n      VIsual_mode_orig = VIsual_mode;\n      VIsual_mode = 'V';\n    } else if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n      curwin->w_curswant = MAXCOL;\n  }\n  cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n  nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\nstatic void nv_subst(cmdarg_T *cap)\n{\n  if (bt_prompt(curbuf) && !prompt_curpos_editable()) {\n    clearopbeep(cap->oap);\n    return;\n  }\n  if (VIsual_active) {  // \"vs\" and \"vS\" are the same as \"vc\"\n    if (cap->cmdchar == 'S') {\n      VIsual_mode_orig = VIsual_mode;\n      VIsual_mode = 'V';\n    }\n    cap->cmdchar = 'c';\n    nv_operator(cap);\n  } else\n    nv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\nstatic void nv_abbrev(cmdarg_T *cap)\n{\n  if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n    cap->cmdchar = 'x';                 /* DEL key behaves like 'x' */\n\n  /* in Visual mode these commands are operators */\n  if (VIsual_active)\n    v_visop(cap);\n  else\n    nv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\nstatic void nv_optrans(cmdarg_T *cap)\n{\n  static const char *(ar[]) = { \"dl\", \"dh\", \"d$\", \"c$\", \"cl\", \"cc\", \"yy\",\n                                \":s\\r\" };\n  static const char *str = \"xXDCsSY&\";\n\n  if (!checkclearopq(cap->oap)) {\n    if (cap->count0) {\n      stuffnumReadbuff(cap->count0);\n    }\n    stuffReadbuff(ar[strchr(str, (char)cap->cmdchar) - str]);\n  }\n  cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is true for \"'\" and \"g'\".\n */\nstatic void nv_gomark(cmdarg_T *cap)\n{\n  pos_T       *pos;\n  int c;\n  pos_T old_cursor = curwin->w_cursor;\n  const bool old_KeyTyped = KeyTyped;       // getting file may reset it\n\n  if (cap->cmdchar == 'g')\n    c = cap->extra_char;\n  else\n    c = cap->nchar;\n  pos = getmark(c, (cap->oap->op_type == OP_NOP));\n  if (pos == (pos_T *)-1) {         /* jumped to other file */\n    if (cap->arg) {\n      check_cursor_lnum();\n      beginline(BL_WHITE | BL_FIX);\n    } else\n      check_cursor();\n  } else\n    nv_cursormark(cap, cap->arg, pos);\n\n  // May need to clear the coladd that a mark includes.\n  if (!virtual_active()) {\n    curwin->w_cursor.coladd = 0;\n  }\n  check_cursor_col();\n  if (cap->oap->op_type == OP_NOP\n      && pos != NULL\n      && (pos == (pos_T *)-1 || !equalpos(old_cursor, *pos))\n      && (fdo_flags & FDO_MARK)\n      && old_KeyTyped) {\n    foldOpenCursor();\n  }\n}\n\n// Handle CTRL-O, CTRL-I, \"g;\", \"g,\", and \"CTRL-Tab\" commands.\nstatic void nv_pcmark(cmdarg_T *cap)\n{\n  pos_T       *pos;\n  linenr_T lnum = curwin->w_cursor.lnum;\n  const bool old_KeyTyped = KeyTyped;       // getting file may reset it\n\n  if (!checkclearopq(cap->oap)) {\n    if (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL) {\n      goto_tabpage_lastused();\n      return;\n    }\n    if (cap->cmdchar == 'g') {\n      pos = movechangelist((int)cap->count1);\n    } else {\n      pos = movemark((int)cap->count1);\n    }\n    if (pos == (pos_T *)-1) {           // jump to other file\n      curwin->w_set_curswant = true;\n      check_cursor();\n    } else if (pos != NULL)                 /* can jump */\n      nv_cursormark(cap, false, pos);\n    else if (cap->cmdchar == 'g') {\n      if (curbuf->b_changelistlen == 0)\n        EMSG(_(\"E664: changelist is empty\"));\n      else if (cap->count1 < 0)\n        EMSG(_(\"E662: At start of changelist\"));\n      else\n        EMSG(_(\"E663: At end of changelist\"));\n    } else\n      clearopbeep(cap->oap);\n    if (cap->oap->op_type == OP_NOP\n        && (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n        && (fdo_flags & FDO_MARK)\n        && old_KeyTyped)\n      foldOpenCursor();\n  }\n}\n\n/*\n * Handle '\"' command.\n */\nstatic void nv_regname(cmdarg_T *cap)\n{\n  if (checkclearop(cap->oap))\n    return;\n  if (cap->nchar == '=')\n    cap->nchar = get_expr_register();\n  if (cap->nchar != NUL && valid_yank_reg(cap->nchar, false)) {\n    cap->oap->regname = cap->nchar;\n    cap->opcount = cap->count0;         /* remember count before '\"' */\n    set_reg_var(cap->oap->regname);\n  } else\n    clearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is true.\n * Handle CTRL-Q just like CTRL-V.\n */\nstatic void nv_visual(cmdarg_T *cap)\n{\n  if (cap->cmdchar == Ctrl_Q)\n    cap->cmdchar = Ctrl_V;\n\n  // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n  // charwise, linewise, or blockwise.\n  if (cap->oap->op_type != OP_NOP) {\n    motion_force = cap->oap->motion_force = cap->cmdchar;\n    finish_op = false;          // operator doesn't finish now but later\n    return;\n  }\n\n  VIsual_select = cap->arg;\n  if (VIsual_active) {      /* change Visual mode */\n    if (VIsual_mode == cap->cmdchar)        /* stop visual mode */\n      end_visual_mode();\n    else {                                  /* toggle char/block mode */\n                                            /*\t   or char/line mode */\n      VIsual_mode = cap->cmdchar;\n      showmode();\n    }\n    redraw_curbuf_later(INVERTED);          // update the inversion\n  } else {                // start Visual mode\n    if (cap->count0 > 0 && resel_VIsual_mode != NUL) {\n      /* use previously selected part */\n      VIsual = curwin->w_cursor;\n\n      VIsual_active = true;\n      VIsual_reselect = true;\n      if (!cap->arg)\n        /* start Select mode when 'selectmode' contains \"cmd\" */\n        may_start_select('c');\n      setmouse();\n      if (p_smd && msg_silent == 0)\n        redraw_cmdline = true;              /* show visual mode later */\n      /*\n       * For V and ^V, we multiply the number of lines even if there\n       * was only one -- webb\n       */\n      if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1) {\n        curwin->w_cursor.lnum +=\n          resel_VIsual_line_count * cap->count0 - 1;\n        if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n          curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      }\n      VIsual_mode = resel_VIsual_mode;\n      if (VIsual_mode == 'v') {\n        if (resel_VIsual_line_count <= 1) {\n          validate_virtcol();\n          assert(cap->count0 >= INT_MIN && cap->count0 <= INT_MAX);\n          curwin->w_curswant = (curwin->w_virtcol\n                                + resel_VIsual_vcol * (int)cap->count0 - 1);\n        } else\n          curwin->w_curswant = resel_VIsual_vcol;\n        coladvance(curwin->w_curswant);\n      }\n      if (resel_VIsual_vcol == MAXCOL) {\n        curwin->w_curswant = MAXCOL;\n        coladvance(MAXCOL);\n      } else if (VIsual_mode == Ctrl_V) {\n        validate_virtcol();\n        assert(cap->count0 >= INT_MIN && cap->count0 <= INT_MAX);\n        curwin->w_curswant = (curwin->w_virtcol\n                              + resel_VIsual_vcol * (int)cap->count0 - 1);\n        coladvance(curwin->w_curswant);\n      } else\n        curwin->w_set_curswant = true;\n      redraw_curbuf_later(INVERTED);            /* show the inversion */\n    } else {\n      if (!cap->arg)\n        /* start Select mode when 'selectmode' contains \"cmd\" */\n        may_start_select('c');\n      n_start_visual_mode(cap->cmdchar);\n      if (VIsual_mode != 'V' && *p_sel == 'e')\n        ++cap->count1;          /* include one more char */\n      if (cap->count0 > 0 && --cap->count1 > 0) {\n        /* With a count select that many characters or lines. */\n        if (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n          nv_right(cap);\n        else if (VIsual_mode == 'V')\n          nv_down(cap);\n      }\n    }\n  }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\nvoid start_selection(void)\n{\n  /* if 'selectmode' contains \"key\", start Select mode */\n  may_start_select('k');\n  n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n */\nvoid may_start_select(int c)\n{\n  VIsual_select = (stuff_empty() && typebuf_typed()\n                   && (vim_strchr(p_slm, c) != NULL));\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\nstatic void n_start_visual_mode(int c)\n{\n  VIsual_mode = c;\n  VIsual_active = true;\n  VIsual_reselect = true;\n  // Corner case: the 0 position in a tab may change when going into\n  // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n  //\n  if (c == Ctrl_V && (ve_flags & VE_BLOCK) && gchar_cursor() == TAB) {\n    validate_virtcol();\n    coladvance(curwin->w_virtcol);\n  }\n  VIsual = curwin->w_cursor;\n\n  foldAdjustVisual();\n\n  setmouse();\n  // Check for redraw after changing the state.\n  conceal_check_cursor_line();\n\n  if (p_smd && msg_silent == 0)\n    redraw_cmdline = true;      /* show visual mode later */\n\n  /* Only need to redraw this line, unless still need to redraw an old\n   * Visual area (when 'lazyredraw' is set). */\n  if (curwin->w_redr_type < INVERTED) {\n    curwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n    curwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n  }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\nstatic void nv_window(cmdarg_T *cap)\n{\n  if (cap->nchar == ':') {\n    // \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n    cap->cmdchar = ':';\n    cap->nchar = NUL;\n    nv_colon(cap);\n  } else if (!checkclearop(cap->oap)) {\n    do_window(cap->nchar, cap->count0, NUL);  // everything is in window.c\n  }\n}\n\n/*\n * CTRL-Z: Suspend\n */\nstatic void nv_suspend(cmdarg_T *cap)\n{\n  clearop(cap->oap);\n  if (VIsual_active)\n    end_visual_mode();                  /* stop Visual mode */\n  do_cmdline_cmd(\"st\");\n}\n\n/*\n * Commands starting with \"g\".\n */\nstatic void nv_g_cmd(cmdarg_T *cap)\n{\n  oparg_T     *oap = cap->oap;\n  pos_T tpos;\n  int i;\n  bool flag = false;\n\n  switch (cap->nchar) {\n  // \"g^A/g^X\": Sequentially increment visually selected region.\n  case Ctrl_A:\n  case Ctrl_X:\n    if (VIsual_active) {\n      cap->arg = true;\n      cap->cmdchar = cap->nchar;\n      cap->nchar = NUL;\n      nv_addsub(cap);\n    } else {\n      clearopbeep(oap);\n    }\n    break;\n\n  // \"gR\": Enter virtual replace mode.\n  case 'R':\n    cap->arg = true;\n    nv_Replace(cap);\n    break;\n\n  case 'r':\n    nv_vreplace(cap);\n    break;\n\n  case '&':\n    do_cmdline_cmd(\"%s//~/&\");\n    break;\n\n  /*\n   * \"gv\": Reselect the previous Visual area.  If Visual already active,\n   *\t     exchange previous and current Visual area.\n   */\n  case 'v':\n    if (checkclearop(oap))\n      break;\n\n    if (       curbuf->b_visual.vi_start.lnum == 0\n               || curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n               || curbuf->b_visual.vi_end.lnum == 0)\n      beep_flush();\n    else {\n      /* set w_cursor to the start of the Visual area, tpos to the end */\n      if (VIsual_active) {\n        i = VIsual_mode;\n        VIsual_mode = curbuf->b_visual.vi_mode;\n        curbuf->b_visual.vi_mode = i;\n        curbuf->b_visual_mode_eval = i;\n        i = curwin->w_curswant;\n        curwin->w_curswant = curbuf->b_visual.vi_curswant;\n        curbuf->b_visual.vi_curswant = i;\n\n        tpos = curbuf->b_visual.vi_end;\n        curbuf->b_visual.vi_end = curwin->w_cursor;\n        curwin->w_cursor = curbuf->b_visual.vi_start;\n        curbuf->b_visual.vi_start = VIsual;\n      } else {\n        VIsual_mode = curbuf->b_visual.vi_mode;\n        curwin->w_curswant = curbuf->b_visual.vi_curswant;\n        tpos = curbuf->b_visual.vi_end;\n        curwin->w_cursor = curbuf->b_visual.vi_start;\n      }\n\n      VIsual_active = true;\n      VIsual_reselect = true;\n\n      /* Set Visual to the start and w_cursor to the end of the Visual\n       * area.  Make sure they are on an existing character. */\n      check_cursor();\n      VIsual = curwin->w_cursor;\n      curwin->w_cursor = tpos;\n      check_cursor();\n      update_topline(curwin);\n      // When called from normal \"g\" command: start Select mode when\n      // 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n      // start Select mode.\n      if (cap->arg) {\n        VIsual_select = true;\n      } else {\n        may_start_select('c');\n      }\n      setmouse();\n      redraw_curbuf_later(INVERTED);\n      showmode();\n    }\n    break;\n  /*\n   * \"gV\": Don't reselect the previous Visual area after a Select mode\n   *\t     mapping of menu.\n   */\n  case 'V':\n    VIsual_reselect = false;\n    break;\n\n  /*\n   * \"gh\":  start Select mode.\n   * \"gH\":  start Select line mode.\n   * \"g^H\": start Select block mode.\n   */\n  case K_BS:\n    cap->nchar = Ctrl_H;\n    FALLTHROUGH;\n  case 'h':\n  case 'H':\n  case Ctrl_H:\n    cap->cmdchar = cap->nchar + ('v' - 'h');\n    cap->arg = true;\n    nv_visual(cap);\n    break;\n\n  /* \"gn\", \"gN\" visually select next/previous search match\n   * \"gn\" selects next match\n   * \"gN\" selects previous match\n   */\n  case 'N':\n  case 'n':\n    if (!current_search(cap->count1, cap->nchar == 'n'))\n      clearopbeep(oap);\n    break;\n\n  /*\n   * \"gj\" and \"gk\" two new funny movement keys -- up and down\n   * movement based on *screen* line rather than *file* line.\n   */\n  case 'j':\n  case K_DOWN:\n    // with 'nowrap' it works just like the normal \"j\" command.\n    if (!curwin->w_p_wrap) {\n      oap->motion_type = kMTLineWise;\n      i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n    } else\n      i = nv_screengo(oap, FORWARD, cap->count1);\n    if (!i)\n      clearopbeep(oap);\n    break;\n\n  case 'k':\n  case K_UP:\n    // with 'nowrap' it works just like the normal \"k\" command.\n    if (!curwin->w_p_wrap) {\n      oap->motion_type = kMTLineWise;\n      i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n    } else\n      i = nv_screengo(oap, BACKWARD, cap->count1);\n    if (!i)\n      clearopbeep(oap);\n    break;\n\n  /*\n   * \"gJ\": join two lines without inserting a space.\n   */\n  case 'J':\n    nv_join(cap);\n    break;\n\n  /*\n   * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines.\n   * \"gm\": middle of \"g0\" and \"g$\".\n   */\n  case '^':\n    flag = true;\n    FALLTHROUGH;\n\n  case '0':\n  case 'm':\n  case K_HOME:\n  case K_KHOME:\n    oap->motion_type = kMTCharWise;\n    oap->inclusive = false;\n    if (curwin->w_p_wrap\n        && curwin->w_width_inner != 0\n        ) {\n      int width1 = curwin->w_width_inner - curwin_col_off();\n      int width2 = width1 + curwin_col_off2();\n\n      validate_virtcol();\n      i = 0;\n      if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)\n        i = (curwin->w_virtcol - width1) / width2 * width2 + width1;\n    } else\n      i = curwin->w_leftcol;\n    /* Go to the middle of the screen line.  When 'number' or\n     * 'relativenumber' is on and lines are wrapping the middle can be more\n     * to the left. */\n    if (cap->nchar == 'm') {\n      i += (curwin->w_width_inner - curwin_col_off()\n            + ((curwin->w_p_wrap && i > 0)\n               ? curwin_col_off2() : 0)) / 2;\n    }\n    coladvance((colnr_T)i);\n    if (flag) {\n      do {\n        i = gchar_cursor();\n      } while (ascii_iswhite(i) && oneright());\n      curwin->w_valid &= ~VALID_WCOL;\n    }\n    curwin->w_set_curswant = true;\n    break;\n\n  case 'M':\n    {\n      const char_u *const ptr = get_cursor_line_ptr();\n\n      oap->motion_type = kMTCharWise;\n      oap->inclusive = false;\n      i = (int)mb_string2cells_len(ptr, STRLEN(ptr));\n      if (cap->count0 > 0 && cap->count0 <= 100) {\n        coladvance((colnr_T)(i * cap->count0 / 100));\n      } else {\n        coladvance((colnr_T)(i / 2));\n      }\n      curwin->w_set_curswant = true;\n    }\n    break;\n\n  case '_':\n    /* \"g_\": to the last non-blank character in the line or <count> lines\n     * downward. */\n    cap->oap->motion_type = kMTCharWise;\n    cap->oap->inclusive = true;\n    curwin->w_curswant = MAXCOL;\n    if (cursor_down(cap->count1 - 1,\n            cap->oap->op_type == OP_NOP) == false)\n      clearopbeep(cap->oap);\n    else {\n      char_u  *ptr = get_cursor_line_ptr();\n\n      /* In Visual mode we may end up after the line. */\n      if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n        --curwin->w_cursor.col;\n\n      /* Decrease the cursor column until it's on a non-blank. */\n      while (curwin->w_cursor.col > 0\n             && ascii_iswhite(ptr[curwin->w_cursor.col]))\n        --curwin->w_cursor.col;\n      curwin->w_set_curswant = true;\n      adjust_for_sel(cap);\n    }\n    break;\n\n  case '$':\n  case K_END:\n  case K_KEND:\n  {\n    int col_off = curwin_col_off();\n\n    oap->motion_type = kMTCharWise;\n    oap->inclusive = true;\n    if (curwin->w_p_wrap\n        && curwin->w_width_inner != 0\n        ) {\n      curwin->w_curswant = MAXCOL;              /* so we stay at the end */\n      if (cap->count1 == 1) {\n        int width1 = curwin->w_width_inner - col_off;\n        int width2 = width1 + curwin_col_off2();\n\n        validate_virtcol();\n        i = width1 - 1;\n        if (curwin->w_virtcol >= (colnr_T)width1)\n          i += ((curwin->w_virtcol - width1) / width2 + 1)\n               * width2;\n        coladvance((colnr_T)i);\n\n        /* Make sure we stick in this column. */\n        validate_virtcol();\n        curwin->w_curswant = curwin->w_virtcol;\n        curwin->w_set_curswant = false;\n        if (curwin->w_cursor.col > 0 && curwin->w_p_wrap) {\n          /*\n           * Check for landing on a character that got split at\n           * the end of the line.  We do not want to advance to\n           * the next screen line.\n           */\n          if (curwin->w_virtcol > (colnr_T)i)\n            --curwin->w_cursor.col;\n        }\n      } else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == false)\n        clearopbeep(oap);\n    } else {\n      if (cap->count1 > 1) {\n        // if it fails, let the cursor still move to the last char\n        (void)cursor_down(cap->count1 - 1, false);\n      }\n      i = curwin->w_leftcol + curwin->w_width_inner - col_off - 1;\n      coladvance((colnr_T)i);\n\n      // Make sure we stick in this column.\n      validate_virtcol();\n      curwin->w_curswant = curwin->w_virtcol;\n      curwin->w_set_curswant = false;\n    }\n  }\n  break;\n\n  /*\n   * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n   */\n  case '*':\n  case '#':\n#if POUND != '#'\n  case POUND:           /* pound sign (sometimes equal to '#') */\n#endif\n  case Ctrl_RSB:                /* :tag or :tselect for current identifier */\n  case ']':                     /* :tselect for current identifier */\n    nv_ident(cap);\n    break;\n\n  /*\n   * ge and gE: go back to end of word\n   */\n  case 'e':\n  case 'E':\n    oap->motion_type = kMTCharWise;\n    curwin->w_set_curswant = true;\n    oap->inclusive = true;\n    if (bckend_word(cap->count1, cap->nchar == 'E', false) == false)\n      clearopbeep(oap);\n    break;\n\n  // \"g CTRL-G\": display info about cursor position\n  case Ctrl_G:\n    cursor_pos_info(NULL);\n    break;\n\n  // \"gi\": start Insert at the last position.\n  case 'i':\n    if (curbuf->b_last_insert.mark.lnum != 0) {\n      curwin->w_cursor = curbuf->b_last_insert.mark;\n      check_cursor_lnum();\n      i = (int)STRLEN(get_cursor_line_ptr());\n      if (curwin->w_cursor.col > (colnr_T)i) {\n        if (virtual_active())\n          curwin->w_cursor.coladd += curwin->w_cursor.col - i;\n        curwin->w_cursor.col = i;\n      }\n    }\n    cap->cmdchar = 'i';\n    nv_edit(cap);\n    break;\n\n  /*\n   * \"gI\": Start insert in column 1.\n   */\n  case 'I':\n    beginline(0);\n    if (!checkclearopq(oap))\n      invoke_edit(cap, false, 'g', false);\n    break;\n\n  /*\n   * \"gf\": goto file, edit file under cursor\n   * \"]f\" and \"[f\": can also be used.\n   */\n  case 'f':\n  case 'F':\n    nv_gotofile(cap);\n    break;\n\n  /* \"g'm\" and \"g`m\": jump to mark without setting pcmark */\n  case '\\'':\n    cap->arg = true;\n    FALLTHROUGH;\n  case '`':\n    nv_gomark(cap);\n    break;\n\n  /*\n   * \"gs\": Goto sleep.\n   */\n  case 's':\n    do_sleep(cap->count1 * 1000L);\n    break;\n\n  /*\n   * \"ga\": Display the ascii value of the character under the\n   * cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n   */\n  case 'a':\n    do_ascii(NULL);\n    break;\n\n  /*\n   * \"g8\": Display the bytes used for the UTF-8 character under the\n   * cursor.\tIt is displayed in hex.\n   * \"8g8\" finds illegal byte sequence.\n   */\n  case '8':\n    if (cap->count0 == 8)\n      utf_find_illegal();\n    else\n      show_utf8();\n    break;\n  // \"g<\": show scrollback text\n  case '<':\n    show_sb_text();\n    break;\n\n  /*\n   * \"gg\": Goto the first line in file.  With a count it goes to\n   * that line number like for \"G\". -- webb\n   */\n  case 'g':\n    cap->arg = false;\n    nv_goto(cap);\n    break;\n\n  /*\n   *\t Two-character operators:\n   *\t \"gq\"\t    Format text\n   *\t \"gw\"\t    Format text and keep cursor position\n   *\t \"g~\"\t    Toggle the case of the text.\n   *\t \"gu\"\t    Change text to lower case.\n   *\t \"gU\"\t    Change text to upper case.\n   *   \"g?\"\t    rot13 encoding\n   *   \"g@\"\t    call 'operatorfunc'\n   */\n  case 'q':\n  case 'w':\n    oap->cursor_start = curwin->w_cursor;\n    FALLTHROUGH;\n  case '~':\n  case 'u':\n  case 'U':\n  case '?':\n  case '@':\n    nv_operator(cap);\n    break;\n\n  /*\n   * \"gd\": Find first occurrence of pattern under the cursor in the\n   *\t current function\n   * \"gD\": idem, but in the current file.\n   */\n  case 'd':\n  case 'D':\n    nv_gd(oap, cap->nchar, (int)cap->count0);\n    break;\n\n  /*\n   * g<*Mouse> : <C-*mouse>\n   */\n  case K_MIDDLEMOUSE:\n  case K_MIDDLEDRAG:\n  case K_MIDDLERELEASE:\n  case K_LEFTMOUSE:\n  case K_LEFTDRAG:\n  case K_LEFTRELEASE:\n  case K_MOUSEMOVE:\n  case K_RIGHTMOUSE:\n  case K_RIGHTDRAG:\n  case K_RIGHTRELEASE:\n  case K_X1MOUSE:\n  case K_X1DRAG:\n  case K_X1RELEASE:\n  case K_X2MOUSE:\n  case K_X2DRAG:\n  case K_X2RELEASE:\n    mod_mask = MOD_MASK_CTRL;\n    (void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n    break;\n\n  case K_IGNORE:\n    break;\n\n  /*\n   * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n   */\n  case 'p':\n  case 'P':\n    nv_put(cap);\n    break;\n\n  /* \"go\": goto byte count from start of buffer */\n  case 'o':\n    goto_byte(cap->count0);\n    break;\n\n  /* \"gQ\": improved Ex mode */\n  case 'Q':\n    if (text_locked()) {\n      clearopbeep(cap->oap);\n      text_locked_msg();\n      break;\n    }\n\n    if (!checkclearopq(oap)) {\n      do_exmode();\n    }\n    break;\n\n  case ',':\n    nv_pcmark(cap);\n    break;\n\n  case ';':\n    cap->count1 = -cap->count1;\n    nv_pcmark(cap);\n    break;\n\n  case 't':\n    if (!checkclearop(oap))\n      goto_tabpage((int)cap->count0);\n    break;\n  case 'T':\n    if (!checkclearop(oap))\n      goto_tabpage(-(int)cap->count1);\n    break;\n  case TAB:\n    if (!checkclearop(oap)) {\n      goto_tabpage_lastused();\n    }\n    break;\n\n  case '+':\n  case '-':   /* \"g+\" and \"g-\": undo or redo along the timeline */\n    if (!checkclearopq(oap))\n      undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n          false, false, false);\n    break;\n\n  default:\n    clearopbeep(oap);\n    break;\n  }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\nstatic void n_opencmd(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap)) {\n    if (cap->cmdchar == 'O')\n      /* Open above the first line of a folded sequence of lines */\n      (void)hasFolding(curwin->w_cursor.lnum,\n          &curwin->w_cursor.lnum, NULL);\n    else\n      /* Open below the last line of a folded sequence of lines */\n      (void)hasFolding(curwin->w_cursor.lnum,\n          NULL, &curwin->w_cursor.lnum);\n    if (u_save((linenr_T)(curwin->w_cursor.lnum -\n                          (cap->cmdchar == 'O' ? 1 : 0)),\n            (linenr_T)(curwin->w_cursor.lnum +\n                       (cap->cmdchar == 'o' ? 1 : 0))\n            )\n        && open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n                     has_format_option(FO_OPEN_COMS)\n                     ? OPENLINE_DO_COM : 0,\n                     0)) {\n      if (win_cursorline_standout(curwin)) {\n        // force redraw of cursorline\n        curwin->w_valid &= ~VALID_CROW;\n      }\n      invoke_edit(cap, false, cap->cmdchar, true);\n    }\n  }\n}\n\n/*\n * \".\" command: redo last change.\n */\nstatic void nv_dot(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap)) {\n    /*\n     * If \"restart_edit\" is true, the last but one command is repeated\n     * instead of the last command (inserting text). This is used for\n     * CTRL-O <.> in insert mode.\n     */\n    if (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == false)\n      clearopbeep(cap->oap);\n  }\n}\n\n/*\n * CTRL-R: undo undo\n */\nstatic void nv_redo(cmdarg_T *cap)\n{\n  if (!checkclearopq(cap->oap)) {\n    u_redo((int)cap->count1);\n    curwin->w_set_curswant = true;\n  }\n}\n\n/*\n * Handle \"U\" command.\n */\nstatic void nv_Undo(cmdarg_T *cap)\n{\n  /* In Visual mode and typing \"gUU\" triggers an operator */\n  if (cap->oap->op_type == OP_UPPER\n      || VIsual_active\n      ) {\n    /* translate \"gUU\" to \"gUgU\" */\n    cap->cmdchar = 'g';\n    cap->nchar = 'U';\n    nv_operator(cap);\n  } else if (!checkclearopq(cap->oap)) {\n    u_undoline();\n    curwin->w_set_curswant = true;\n  }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\nstatic void nv_tilde(cmdarg_T *cap)\n{\n  if (!p_to\n      && !VIsual_active\n      && cap->oap->op_type != OP_TILDE) {\n    if (bt_prompt(curbuf) && !prompt_curpos_editable()) {\n      clearopbeep(cap->oap);\n      return;\n    }\n    n_swapchar(cap);\n  } else {\n    nv_operator(cap);\n  }\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\nstatic void nv_operator(cmdarg_T *cap)\n{\n  int op_type;\n\n  op_type = get_op_type(cap->cmdchar, cap->nchar);\n\n  if (bt_prompt(curbuf) && op_is_change(op_type)\n      && !prompt_curpos_editable()) {\n    clearopbeep(cap->oap);\n    return;\n  }\n\n  if (op_type == cap->oap->op_type)         /* double operator works on lines */\n    nv_lineop(cap);\n  else if (!checkclearop(cap->oap)) {\n    cap->oap->start = curwin->w_cursor;\n    cap->oap->op_type = op_type;\n    set_op_var(op_type);\n  }\n}\n\n/*\n * Set v:operator to the characters for \"optype\".\n */\nstatic void set_op_var(int optype)\n{\n  if (optype == OP_NOP) {\n    set_vim_var_string(VV_OP, NULL, 0);\n  } else {\n    char opchars[3];\n    int opchar0 = get_op_char(optype);\n    assert(opchar0 >= 0 && opchar0 <= UCHAR_MAX);\n    opchars[0] = (char) opchar0;\n\n    int opchar1 = get_extra_op_char(optype);\n    assert(opchar1 >= 0 && opchar1 <= UCHAR_MAX);\n    opchars[1] = (char) opchar1;\n\n    opchars[2] = NUL;\n    set_vim_var_string(VV_OP, opchars, -1);\n  }\n}\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\nstatic void nv_lineop(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTLineWise;\n  if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == false) {\n    clearopbeep(cap->oap);\n  } else if ((cap->oap->op_type == OP_DELETE\n              // only with linewise motions\n              && cap->oap->motion_force != 'v'\n              && cap->oap->motion_force != Ctrl_V)\n             || cap->oap->op_type == OP_LSHIFT\n             || cap->oap->op_type == OP_RSHIFT) {\n    beginline(BL_SOL | BL_FIX);\n  } else if (cap->oap->op_type != OP_YANK) {  // 'Y' does not move cursor\n    beginline(BL_WHITE | BL_FIX);\n  }\n}\n\n/*\n * <Home> command.\n */\nstatic void nv_home(cmdarg_T *cap)\n{\n  /* CTRL-HOME is like \"gg\" */\n  if (mod_mask & MOD_MASK_CTRL)\n    nv_goto(cap);\n  else {\n    cap->count0 = 1;\n    nv_pipe(cap);\n  }\n  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a\n                               one-character line). */\n}\n\n/*\n * \"|\" command.\n */\nstatic void nv_pipe(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  beginline(0);\n  if (cap->count0 > 0) {\n    coladvance((colnr_T)(cap->count0 - 1));\n    curwin->w_curswant = (colnr_T)(cap->count0 - 1);\n  } else\n    curwin->w_curswant = 0;\n  /* keep curswant at the column where we wanted to go, not where\n   * we ended; differs if line is too short */\n  curwin->w_set_curswant = false;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\nstatic void nv_bck_word(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  curwin->w_set_curswant = true;\n  if (bck_word(cap->count1, cap->arg, false) == false)\n    clearopbeep(cap->oap);\n  else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is true for \"E\" and \"W\".\n */\nstatic void nv_wordcmd(cmdarg_T *cap)\n{\n  int n;\n  bool word_end;\n  bool flag = false;\n  pos_T startpos = curwin->w_cursor;\n\n  /*\n   * Set inclusive for the \"E\" and \"e\" command.\n   */\n  if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n    word_end = true;\n  else\n    word_end = false;\n  cap->oap->inclusive = word_end;\n\n  /*\n   * \"cw\" and \"cW\" are a special case.\n   */\n  if (!word_end && cap->oap->op_type == OP_CHANGE) {\n    n = gchar_cursor();\n    if (n != NUL && !ascii_iswhite(n)) {\n      // This is a little strange.  To match what the real Vi does, we\n      // effectively map \"cw\" to \"ce\", and \"cW\" to \"cE\", provided that we are\n      // not on a space or a TAB.  This seems impolite at first, but it's\n      // really more what we mean when we say \"cw\".\n      //\n      // Another strangeness: When standing on the end of a word \"ce\" will\n      // change until the end of the next word, but \"cw\" will change only one\n      // character!  This is done by setting \"flag\".\n      if (vim_strchr(p_cpo, CPO_CHANGEW) != NULL) {\n        cap->oap->inclusive = true;\n        word_end = true;\n      }\n      flag = true;\n    }\n  }\n\n  cap->oap->motion_type = kMTCharWise;\n  curwin->w_set_curswant = true;\n  if (word_end)\n    n = end_word(cap->count1, cap->arg, flag, false);\n  else\n    n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n  /* Don't leave the cursor on the NUL past the end of line. Unless we\n   * didn't move it forward. */\n  if (lt(startpos, curwin->w_cursor))\n    adjust_cursor(cap->oap);\n\n  if (n == false && cap->oap->op_type == OP_NOP)\n    clearopbeep(cap->oap);\n  else {\n    adjust_for_sel(cap);\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n      foldOpenCursor();\n  }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\nstatic void adjust_cursor(oparg_T *oap)\n{\n  /* The cursor cannot remain on the NUL when:\n   * - the column is > 0\n   * - not in Visual mode or 'selection' is \"o\"\n   * - 'virtualedit' is not \"all\" and not \"onemore\".\n   */\n  if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n      && (!VIsual_active || *p_sel == 'o')\n      && !virtual_active() && (ve_flags & VE_ONEMORE) == 0\n      ) {\n    curwin->w_cursor.col--;\n    // prevent cursor from moving on the trail byte\n    mb_adjust_cursor();\n    oap->inclusive = true;\n  }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\nstatic void nv_beginline(cmdarg_T *cap)\n{\n  cap->oap->motion_type = kMTCharWise;\n  cap->oap->inclusive = false;\n  beginline(cap->arg);\n  if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n  ins_at_eol = false;       /* Don't move cursor past eol (only necessary in a\n                               one-character line). */\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\nstatic void adjust_for_sel(cmdarg_T *cap)\n{\n  if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n      && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor)) {\n    inc_cursor();\n    cap->oap->inclusive = false;\n  }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns true when backed up to the previous line.\n */\nstatic bool unadjust_for_sel(void)\n{\n  pos_T       *pp;\n\n  if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor)) {\n    if (lt(VIsual, curwin->w_cursor))\n      pp = &curwin->w_cursor;\n    else\n      pp = &VIsual;\n    if (pp->coladd > 0) {\n      pp->coladd--;\n    } else if (pp->col > 0) {\n      pp->col--;\n      mark_mb_adjustpos(curbuf, pp);\n    } else if (pp->lnum > 1) {\n      --pp->lnum;\n      pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n      return true;\n    }\n  }\n  return false;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\nstatic void nv_select(cmdarg_T *cap)\n{\n  if (VIsual_active)\n    VIsual_select = true;\n  else if (VIsual_reselect) {\n    cap->nchar = 'v';               /* fake \"gv\" command */\n    cap->arg = true;\n    nv_g_cmd(cap);\n  }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is true for \"G\".\n */\nstatic void nv_goto(cmdarg_T *cap)\n{\n  linenr_T lnum;\n\n  if (cap->arg)\n    lnum = curbuf->b_ml.ml_line_count;\n  else\n    lnum = 1L;\n  cap->oap->motion_type = kMTLineWise;\n  setpcmark();\n\n  /* When a count is given, use it instead of the default lnum */\n  if (cap->count0 != 0)\n    lnum = cap->count0;\n  if (lnum < 1L)\n    lnum = 1L;\n  else if (lnum > curbuf->b_ml.ml_line_count)\n    lnum = curbuf->b_ml.ml_line_count;\n  curwin->w_cursor.lnum = lnum;\n  beginline(BL_SOL | BL_FIX);\n  if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n    foldOpenCursor();\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\nstatic void nv_normal(cmdarg_T *cap)\n{\n  if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G) {\n    clearop(cap->oap);\n    if (restart_edit != 0 && mode_displayed)\n      clear_cmdline = true;                     /* unshow mode later */\n    restart_edit = 0;\n    if (cmdwin_type != 0)\n      cmdwin_result = Ctrl_C;\n    if (VIsual_active) {\n      end_visual_mode();                /* stop Visual */\n      redraw_curbuf_later(INVERTED);\n    }\n    /* CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set. */\n    if (cap->nchar == Ctrl_G && p_im)\n      restart_edit = 'a';\n  } else\n    clearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\nstatic void nv_esc(cmdarg_T *cap)\n{\n  int no_reason;\n\n  no_reason = (cap->oap->op_type == OP_NOP\n               && cap->opcount == 0\n               && cap->count0 == 0\n               && cap->oap->regname == 0\n               && !p_im);\n\n  if (cap->arg) {               /* true for CTRL-C */\n    if (restart_edit == 0\n        && cmdwin_type == 0\n        && !VIsual_active\n        && no_reason) {\n      if (anyBufIsChanged()) {\n        MSG(_(\"Type  :qa!  and press <Enter> to abandon all changes\"\n              \" and exit Nvim\"));\n      } else {\n        MSG(_(\"Type  :qa  and press <Enter> to exit Nvim\"));\n      }\n    }\n\n    /* Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n     * set again below when halfway through a mapping. */\n    if (!p_im)\n      restart_edit = 0;\n    if (cmdwin_type != 0) {\n      cmdwin_result = K_IGNORE;\n      got_int = false;          /* don't stop executing autocommands et al. */\n      return;\n    }\n  } else if (cmdwin_type != 0 && ex_normal_busy) {\n    // When :normal runs out of characters while in the command line window\n    // vgetorpeek() will return ESC.  Exit the cmdline window to break the\n    // loop.\n    cmdwin_result = K_IGNORE;\n    return;\n  }\n\n  if (VIsual_active) {\n    end_visual_mode();          /* stop Visual */\n    check_cursor_col();         /* make sure cursor is not beyond EOL */\n    curwin->w_set_curswant = true;\n    redraw_curbuf_later(INVERTED);\n  } else if (no_reason) {\n    vim_beep(BO_ESC);\n  }\n  clearop(cap->oap);\n\n  /* A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n   * set return to Insert mode afterwards. */\n  if (restart_edit == 0 && goto_im()\n      && ex_normal_busy == 0\n      )\n    restart_edit = 'a';\n}\n\n// Move the cursor for the \"A\" command.\nvoid set_cursor_for_append_to_line(void)\n{\n  curwin->w_set_curswant = true;\n  if (ve_flags == VE_ALL) {\n    const int save_State = State;\n\n    // Pretend Insert mode here to allow the cursor on the\n    // character past the end of the line\n    State = INSERT;\n    coladvance(MAXCOL);\n    State = save_State;\n  } else {\n    curwin->w_cursor.col += (colnr_T)STRLEN(get_cursor_pos_ptr());\n  }\n}\n\n/// Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\nstatic void nv_edit(cmdarg_T *cap)\n{\n  // <Insert> is equal to \"i\"\n  if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS) {\n    cap->cmdchar = 'i';\n  }\n\n  // in Visual mode \"A\" and \"I\" are an operator\n  if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I')) {\n    v_visop(cap);\n  // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n  } else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n             && (cap->oap->op_type != OP_NOP || VIsual_active)) {\n    nv_object(cap);\n  } else if (!curbuf->b_p_ma && !p_im && !curbuf->terminal) {\n    // Only give this error when 'insertmode' is off.\n    EMSG(_(e_modifiable));\n    clearop(cap->oap);\n  } else if (!checkclearopq(cap->oap)) {\n    switch (cap->cmdchar) {\n    case 'A':           // \"A\"ppend after the line\n      set_cursor_for_append_to_line();\n      break;\n\n    case 'I':           /* \"I\"nsert before the first non-blank */\n      beginline(BL_WHITE);\n      break;\n\n    case 'a':           /* \"a\"ppend is like \"i\"nsert on the next character. */\n      /* increment coladd when in virtual space, increment the\n       * column otherwise, also to append after an unprintable char */\n      if (virtual_active()\n          && (curwin->w_cursor.coladd > 0\n              || *get_cursor_pos_ptr() == NUL\n              || *get_cursor_pos_ptr() == TAB))\n        curwin->w_cursor.coladd++;\n      else if (*get_cursor_pos_ptr() != NUL)\n        inc_cursor();\n      break;\n    }\n\n    if (curwin->w_cursor.coladd && cap->cmdchar != 'A') {\n      int save_State = State;\n\n      /* Pretend Insert mode here to allow the cursor on the\n       * character past the end of the line */\n      State = INSERT;\n      coladvance(getviscol());\n      State = save_State;\n    }\n\n    invoke_edit(cap, false, cap->cmdchar, false);\n  }\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\nstatic void\ninvoke_edit (\n    cmdarg_T *cap,\n    int repl,                       /* \"r\" or \"gr\" command */\n    int cmd,\n    int startln\n)\n{\n  int restart_edit_save = 0;\n\n  /* Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n   * mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n   * it. */\n  if (repl || !stuff_empty())\n    restart_edit_save = restart_edit;\n  else\n    restart_edit_save = 0;\n\n  /* Always reset \"restart_edit\", this is not a restarted edit. */\n  restart_edit = 0;\n\n  if (edit(cmd, startln, cap->count1))\n    cap->retval |= CA_COMMAND_BUSY;\n\n  if (restart_edit == 0)\n    restart_edit = restart_edit_save;\n}\n\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\nstatic void nv_object(cmdarg_T *cap)\n{\n  bool flag;\n  bool include;\n  char_u      *mps_save;\n\n  if (cap->cmdchar == 'i')\n    include = false;        /* \"ix\" = inner object: exclude white space */\n  else\n    include = true;         /* \"ax\" = an object: include white space */\n\n  /* Make sure (), [], {} and <> are in 'matchpairs' */\n  mps_save = curbuf->b_p_mps;\n  curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n  switch (cap->nchar) {\n  case 'w':       /* \"aw\" = a word */\n    flag = current_word(cap->oap, cap->count1, include, false);\n    break;\n  case 'W':       /* \"aW\" = a WORD */\n    flag = current_word(cap->oap, cap->count1, include, true);\n    break;\n  case 'b':       /* \"ab\" = a braces block */\n  case '(':\n  case ')':\n    flag = current_block(cap->oap, cap->count1, include, '(', ')');\n    break;\n  case 'B':       /* \"aB\" = a Brackets block */\n  case '{':\n  case '}':\n    flag = current_block(cap->oap, cap->count1, include, '{', '}');\n    break;\n  case '[':       /* \"a[\" = a [] block */\n  case ']':\n    flag = current_block(cap->oap, cap->count1, include, '[', ']');\n    break;\n  case '<':       /* \"a<\" = a <> block */\n  case '>':\n    flag = current_block(cap->oap, cap->count1, include, '<', '>');\n    break;\n  case 't':       /* \"at\" = a tag block (xml and html) */\n    // Do not adjust oap->end in do_pending_operator()\n    // otherwise there are different results for 'dit'\n    // (note leading whitespace in last line):\n    // 1) <b>      2) <b>\n    //    foobar      foobar\n    //    </b>            </b>\n    cap->retval |= CA_NO_ADJ_OP_END;\n    flag = current_tagblock(cap->oap, cap->count1, include);\n    break;\n  case 'p':       /* \"ap\" = a paragraph */\n    flag = current_par(cap->oap, cap->count1, include, 'p');\n    break;\n  case 's':       /* \"as\" = a sentence */\n    flag = current_sent(cap->oap, cap->count1, include);\n    break;\n  case '\"':       /* \"a\"\" = a double quoted string */\n  case '\\'':       /* \"a'\" = a single quoted string */\n  case '`':       /* \"a`\" = a backtick quoted string */\n    flag = current_quote(cap->oap, cap->count1, include,\n        cap->nchar);\n    break;\n  default:\n    flag = false;\n    break;\n  }\n\n  curbuf->b_p_mps = mps_save;\n  if (!flag)\n    clearopbeep(cap->oap);\n  adjust_cursor_col();\n  curwin->w_set_curswant = true;\n}\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\nstatic void nv_record(cmdarg_T *cap)\n{\n  if (cap->oap->op_type == OP_FORMAT) {\n    /* \"gqq\" is the same as \"gqgq\": format line */\n    cap->cmdchar = 'g';\n    cap->nchar = 'q';\n    nv_operator(cap);\n  } else if (!checkclearop(cap->oap)) {\n    if (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?') {\n      stuffcharReadbuff(cap->nchar);\n      stuffcharReadbuff(K_CMDWIN);\n    } else {\n      // (stop) recording into a named register, unless executing a\n      // register.\n      if (reg_executing == 0 && do_record(cap->nchar) == FAIL) {\n        clearopbeep(cap->oap);\n      }\n    }\n  }\n}\n\n/*\n * Handle the \"@r\" command.\n */\nstatic void nv_at(cmdarg_T *cap)\n{\n  if (checkclearop(cap->oap))\n    return;\n  if (cap->nchar == '=') {\n    if (get_expr_register() == NUL)\n      return;\n  }\n  while (cap->count1-- && !got_int) {\n    if (do_execreg(cap->nchar, false, false, false) == false) {\n      clearopbeep(cap->oap);\n      break;\n    }\n    line_breakcheck();\n  }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\nstatic void nv_halfpage(cmdarg_T *cap)\n{\n  if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n      || (cap->cmdchar == Ctrl_D\n          && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n    clearopbeep(cap->oap);\n  else if (!checkclearop(cap->oap))\n    halfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\nstatic void nv_join(cmdarg_T *cap)\n{\n  if (VIsual_active) {  // join the visual lines\n    nv_operator(cap);\n  } else if (!checkclearop(cap->oap)) {\n    if (cap->count0 <= 1) {\n      cap->count0 = 2;  // default for join is two lines!\n    }\n    if (curwin->w_cursor.lnum + cap->count0 - 1 >\n        curbuf->b_ml.ml_line_count) {\n      // can't join when on the last line\n      if (cap->count0 <= 2) {\n        clearopbeep(cap->oap);\n        return;\n      }\n      cap->count0 = curbuf->b_ml.ml_line_count - curwin->w_cursor.lnum + 1;\n    }\n\n    prep_redo(cap->oap->regname, cap->count0,\n              NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n    do_join((size_t)cap->count0, cap->nchar == NUL, true, true, true);\n  }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\nstatic void nv_put(cmdarg_T *cap)\n{\n  nv_put_opt(cap, false);\n}\n\n// \"P\", \"gP\", \"p\" and \"gp\" commands.\n// \"fix_indent\" is true for \"[p\", \"[P\", \"]p\" and \"]P\".\nstatic void nv_put_opt(cmdarg_T *cap, bool fix_indent)\n{\n  int regname = 0;\n  yankreg_T *savereg = NULL;\n  bool empty = false;\n  bool was_visual = false;\n  int dir;\n  int flags = 0;\n\n  if (cap->oap->op_type != OP_NOP) {\n    /* \"dp\" is \":diffput\" */\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p') {\n      clearop(cap->oap);\n      assert(cap->opcount >= 0);\n      nv_diffgetput(true, (size_t)cap->opcount);\n    } else {\n      clearopbeep(cap->oap);\n    }\n  } else if (bt_prompt(curbuf) && !prompt_curpos_editable()) {\n    clearopbeep(cap->oap);\n  } else {\n    if (fix_indent) {\n      dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n        ? FORWARD : BACKWARD;\n      flags |= PUT_FIXINDENT;\n    } else {\n      dir = (cap->cmdchar == 'P'\n             || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n                 && cap->nchar == 'P')) ? BACKWARD : FORWARD;\n    }\n    prep_redo_cmd(cap);\n    if (cap->cmdchar == 'g') {\n      flags |= PUT_CURSEND;\n    } else if (cap->cmdchar == 'z') {\n      flags |= PUT_BLOCK_INNER;\n    }\n\n    if (VIsual_active) {\n      /* Putting in Visual mode: The put text replaces the selected\n       * text.  First delete the selected text, then put the new text.\n       * Need to save and restore the registers that the delete\n       * overwrites if the old contents is being put.\n       */\n      was_visual = true;\n      regname = cap->oap->regname;\n      // '+' and '*' could be the same selection\n      bool clipoverwrite = (regname == '+' || regname == '*')\n          && (cb_flags & CB_UNNAMEDMASK);\n      if (regname == 0 || regname == '\"' || clipoverwrite\n          || ascii_isdigit(regname) || regname == '-') {\n        // The delete might overwrite the register we want to put, save it first\n        savereg = copy_register(regname);\n      }\n\n      // To place the cursor correctly after a blockwise put, and to leave the\n      // text in the correct position when putting over a selection with\n      // 'virtualedit' and past the end of the line, we use the 'c' operator in\n      // do_put(), which requires the visual selection to still be active.\n      if (!VIsual_active || VIsual_mode == 'V' || regname != '.') {\n        // Now delete the selected text. Avoid messages here.\n        cap->cmdchar = 'd';\n        cap->nchar = NUL;\n        cap->oap->regname = NUL;\n        msg_silent++;\n        nv_operator(cap);\n        do_pending_operator(cap, 0, false);\n        empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n        msg_silent--;\n\n        // delete PUT_LINE_BACKWARD;\n        cap->oap->regname = regname;\n      }\n\n      // When deleted a linewise Visual area, put the register as\n      // lines to avoid it joined with the next line.  When deletion was\n      // charwise, split a line when putting lines.\n      if (VIsual_mode == 'V') {\n        flags |= PUT_LINE;\n      } else if (VIsual_mode == 'v') {\n        flags |= PUT_LINE_SPLIT;\n      }\n      if (VIsual_mode == Ctrl_V && dir == FORWARD) {\n        flags |= PUT_LINE_FORWARD;\n      }\n      dir = BACKWARD;\n      if ((VIsual_mode != 'V'\n           && curwin->w_cursor.col < curbuf->b_op_start.col)\n          || (VIsual_mode == 'V'\n              && curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n        /* cursor is at the end of the line or end of file, put\n         * forward. */\n        dir = FORWARD;\n      /* May have been reset in do_put(). */\n      VIsual_active = true;\n    }\n    do_put(cap->oap->regname, savereg, dir, cap->count1, flags);\n\n    // If a register was saved, free it\n    if (savereg != NULL) {\n      free_register(savereg);\n      xfree(savereg);\n    }\n\n    /* What to reselect with \"gv\"?  Selecting the just put text seems to\n     * be the most useful, since the original text was removed. */\n    if (was_visual) {\n      curbuf->b_visual.vi_start = curbuf->b_op_start;\n      curbuf->b_visual.vi_end = curbuf->b_op_end;\n      // need to adjust cursor position\n      if (*p_sel == 'e') {\n        inc(&curbuf->b_visual.vi_end);\n      }\n    }\n\n    /* When all lines were selected and deleted do_put() leaves an empty\n     * line that needs to be deleted now. */\n    if (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL) {\n      ml_delete(curbuf->b_ml.ml_line_count, true);\n      deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n      /* If the cursor was in that line, move it to the end of the last\n       * line. */\n      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {\n        curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n        coladvance(MAXCOL);\n      }\n    }\n    auto_format(false, true);\n  }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\nstatic void nv_open(cmdarg_T *cap)\n{\n  /* \"do\" is \":diffget\" */\n  if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o') {\n    clearop(cap->oap);\n    assert(cap->opcount >= 0);\n    nv_diffgetput(false, (size_t)cap->opcount);\n  } else if (VIsual_active) {\n    // switch start and end of visual/\n    v_swap_corners(cap->cmdchar);\n  } else if (bt_prompt(curbuf)) {\n    clearopbeep(cap->oap);\n  } else {\n    n_opencmd(cap);\n  }\n}\n\n// Calculate start/end virtual columns for operating in block mode.\nstatic void get_op_vcol(\n    oparg_T *oap,\n    colnr_T redo_VIsual_vcol,\n    bool initial  // when true: adjust position for 'selectmode'\n)\n{\n  colnr_T start;\n  colnr_T end;\n\n  if (VIsual_mode != Ctrl_V\n      || (!initial && oap->end.col < curwin->w_width_inner)) {\n    return;\n  }\n\n  oap->motion_type = kMTBlockWise;\n\n  // prevent from moving onto a trail byte\n  mark_mb_adjustpos(curwin->w_buffer, &oap->end);\n\n  getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);\n  if (!redo_VIsual_busy) {\n    getvvcol(curwin, &(oap->end), &start, NULL, &end);\n\n    if (start < oap->start_vcol) {\n      oap->start_vcol = start;\n    }\n    if (end > oap->end_vcol) {\n      if (initial && *p_sel == 'e'\n          && start >= 1\n          && start - 1 >= oap->end_vcol) {\n        oap->end_vcol = start - 1;\n      } else {\n        oap->end_vcol = end;\n      }\n    }\n  }\n\n  // if '$' was used, get oap->end_vcol from longest line\n  if (curwin->w_curswant == MAXCOL) {\n    curwin->w_cursor.col = MAXCOL;\n    oap->end_vcol = 0;\n    for (curwin->w_cursor.lnum = oap->start.lnum;\n         curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum) {\n      getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);\n      if (end > oap->end_vcol) {\n        oap->end_vcol = end;\n      }\n    }\n  } else if (redo_VIsual_busy) {\n    oap->end_vcol = oap->start_vcol + redo_VIsual_vcol - 1;\n  }\n\n  // Correct oap->end.col and oap->start.col to be the\n  // upper-left and lower-right corner of the block area.\n  //\n  // (Actually, this does convert column positions into character\n  // positions)\n  curwin->w_cursor.lnum = oap->end.lnum;\n  coladvance(oap->end_vcol);\n  oap->end = curwin->w_cursor;\n\n  curwin->w_cursor = oap->start;\n  coladvance(oap->start_vcol);\n  oap->start = curwin->w_cursor;\n}\n\n// Handle an arbitrary event in normal mode\nstatic void nv_event(cmdarg_T *cap)\n{\n  // Garbage collection should have been executed before blocking for events in\n  // the `os_inchar` in `state_enter`, but we also disable it here in case the\n  // `os_inchar` branch was not executed (!multiqueue_empty(loop.events), which\n  // could have `may_garbage_collect` set to true in `normal_check`).\n  //\n  // That is because here we may run code that calls `os_inchar`\n  // later(`f_confirm` or `get_keystroke` for example), but in these cases it is\n  // not safe to perform garbage collection because there could be unreferenced\n  // lists or dicts being used.\n  may_garbage_collect = false;\n  bool may_restart = (restart_edit != 0);\n  state_handle_k_event();\n  finish_op = false;\n  if (may_restart) {\n    // Tricky: if restart_edit was set before the handler we are in ctrl-o mode,\n    // but if not, the event should be allowed to trigger :startinsert.\n    cap->retval |= CA_COMMAND_BUSY;  // don't call edit() now\n  }\n}\n\n/// @return true when 'mousemodel' is set to \"popup\" or \"popup_setpos\".\nstatic bool mouse_model_popup(void)\n{\n  return p_mousem[0] == 'p';\n}\n\nvoid normal_cmd(oparg_T *oap, bool toplevel)\n{\n  NormalState s;\n  normal_state_init(&s);\n  s.toplevel = toplevel;\n  s.oa = *oap;\n  normal_prepare(&s);\n  (void)normal_execute(&s.state, safe_vgetc());\n  *oap = s.oa;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 1345}, "message": "Assuming 'exmode_active' is false"}, {"location": {"col": 7, "file": 0, "line": 1353}, "message": "Assuming 'skip_redraw' is false"}, {"location": {"col": 14, "file": 0, "line": 1355}, "message": "Assuming 'do_redraw' is true"}, {"location": {"col": 9, "file": 0, "line": 1368}, "message": "Assuming field 'tp_diff_update' is 0"}, {"location": {"col": 35, "file": 0, "line": 1368}, "message": "Assuming field 'tp_diff_invalid' is 0"}, {"location": {"col": 9, "file": 0, "line": 1375}, "message": "Assuming 'diff_need_scrollbind' is false"}, {"location": {"col": 9, "file": 0, "line": 1386}, "message": "Assuming 'time_fd' is not equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 1388}, "message": "Assuming 'time_fd' is equal to null"}, {"location": {"col": 7, "file": 0, "line": 1389}, "message": "Stream pointer might be NULL"}], "macros": [{"location": {"col": 7, "file": 0, "line": 1387}, "expansion": "do { if (time_fd !=((void*)0)) time_msg(\"first screen update\",((void*)0)); } while (0)", "name": "TIME_MSG"}, {"location": {"col": 7, "file": 0, "line": 1388}, "expansion": "do { if (time_fd !=((void*)0)) time_msg(\"--- NVIM STARTED ---\",((void*)0)); } while (0)", "name": "TIME_MSG"}], "notes": [], "path": "src/nvim/normal.c", "reportHash": "d3a5bf680d39852cca24d46776004771", "checkerName": "alpha.unix.Stream", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
