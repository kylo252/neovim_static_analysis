<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/spellfile.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// spellfile.c: code for reading and writing spell files.\n//\n// See spell.c for information about spell checking.\n\n// Vim spell file format: <HEADER>\n//                        <SECTIONS>\n//                        <LWORDTREE>\n//                        <KWORDTREE>\n//                        <PREFIXTREE>\n//\n// <HEADER>: <fileID> <versionnr>\n//\n// <fileID>     8 bytes    \"VIMspell\"\n// <versionnr>  1 byte      VIMSPELLVERSION\n//\n//\n// Sections make it possible to add information to the .spl file without\n// making it incompatible with previous versions.  There are two kinds of\n// sections:\n// 1. Not essential for correct spell checking.  E.g. for making suggestions.\n//    These are skipped when not supported.\n// 2. Optional information, but essential for spell checking when present.\n//    E.g. conditions for affixes.  When this section is present but not\n//    supported an error message is given.\n//\n// <SECTIONS>: <section> ... <sectionend>\n//\n// <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n//\n// <sectionID>    1 byte    number from 0 to 254 identifying the section\n//\n// <sectionflags> 1 byte    SNF_REQUIRED: this section is required for correct\n//                                          spell checking\n//\n// <sectionlen>   4 bytes   length of section contents, MSB first\n//\n// <sectionend>   1 byte    SN_END\n//\n//\n// sectionID == SN_INFO: <infotext>\n// <infotext>    N bytes    free format text with spell file info (version,\n//                          website, etc)\n//\n// sectionID == SN_REGION: <regionname> ...\n// <regionname>  2 bytes    Up to MAXREGIONS region names: ca, au, etc.\n//                          Lower case.\n//                          First <regionname> is region 1.\n//\n// sectionID == SN_CHARFLAGS: <charflagslen> <charflags>\n//                              <folcharslen> <folchars>\n// <charflagslen> 1 byte    Number of bytes in <charflags> (should be 128).\n// <charflags>  N bytes     List of flags (first one is for character 128):\n//                          0x01  word character        CF_WORD\n//                          0x02  upper-case character  CF_UPPER\n// <folcharslen>  2 bytes   Number of bytes in <folchars>.\n// <folchars>     N bytes   Folded characters, first one is for character 128.\n//\n// sectionID == SN_MIDWORD: <midword>\n// <midword>     N bytes    Characters that are word characters only when used\n//                          in the middle of a word.\n//\n// sectionID == SN_PREFCOND: <prefcondcnt> <prefcond> ...\n// <prefcondcnt> 2 bytes    Number of <prefcond> items following.\n// <prefcond> : <condlen> <condstr>\n// <condlen>    1 byte      Length of <condstr>.\n// <condstr>    N bytes     Condition for the prefix.\n//\n// sectionID == SN_REP: <repcount> <rep> ...\n// <repcount>    2 bytes    number of <rep> items, MSB first.\n// <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n// <repfromlen>  1 byte     length of <repfrom>\n// <repfrom>     N bytes    \"from\" part of replacement\n// <reptolen>    1 byte     length of <repto>\n// <repto>       N bytes    \"to\" part of replacement\n//\n// sectionID == SN_REPSAL: <repcount> <rep> ...\n//   just like SN_REP but for soundfolded words\n//\n// sectionID == SN_SAL: <salflags> <salcount> <sal> ...\n// <salflags>    1 byte     flags for soundsalike conversion:\n//                          SAL_F0LLOWUP\n//                          SAL_COLLAPSE\n//                          SAL_REM_ACCENTS\n// <salcount>    2 bytes    number of <sal> items following\n// <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n// <salfromlen>  1 byte     length of <salfrom>\n// <salfrom>     N bytes    \"from\" part of soundsalike\n// <saltolen>    1 byte     length of <salto>\n// <salto>       N bytes    \"to\" part of soundsalike\n//\n// sectionID == SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n// <sofofromlen> 2 bytes    length of <sofofrom>\n// <sofofrom>    N bytes    \"from\" part of soundfold\n// <sofotolen>   2 bytes    length of <sofoto>\n// <sofoto>      N bytes    \"to\" part of soundfold\n//\n// sectionID == SN_SUGFILE: <timestamp>\n// <timestamp>   8 bytes    time in seconds that must match with .sug file\n//\n// sectionID == SN_NOSPLITSUGS: nothing\n//\n// sectionID == SN_NOCOMPOUNDSUGS: nothing\n//\n// sectionID == SN_WORDS: <word> ...\n// <word>        N bytes    NUL terminated common word\n//\n// sectionID == SN_MAP: <mapstr>\n// <mapstr>      N bytes    String with sequences of similar characters,\n//                          separated by slashes.\n//\n// sectionID == SN_COMPOUND: <compmax> <compminlen> <compsylmax> <compoptions>\n//                              <comppatcount> <comppattern> ... <compflags>\n// <compmax>     1 byte     Maximum nr of words in compound word.\n// <compminlen>  1 byte     Minimal word length for compounding.\n// <compsylmax>  1 byte     Maximum nr of syllables in compound word.\n// <compoptions> 2 bytes    COMP_ flags.\n// <comppatcount> 2 bytes   number of <comppattern> following\n// <compflags>   N bytes    Flags from COMPOUNDRULE items, separated by\n//                          slashes.\n//\n// <comppattern>: <comppatlen> <comppattext>\n// <comppatlen>  1 byte     length of <comppattext>\n// <comppattext> N bytes    end or begin chars from CHECKCOMPOUNDPATTERN\n//\n// sectionID == SN_NOBREAK: (empty, its presence is what matters)\n//\n// sectionID == SN_SYLLABLE: <syllable>\n// <syllable>    N bytes    String from SYLLABLE item.\n//\n// <LWORDTREE>: <wordtree>\n//\n// <KWORDTREE>: <wordtree>\n//\n// <PREFIXTREE>: <wordtree>\n//\n//\n// <wordtree>: <nodecount> <nodedata> ...\n//\n// <nodecount>  4 bytes     Number of nodes following.  MSB first.\n//\n// <nodedata>: <siblingcount> <sibling> ...\n//\n// <siblingcount> 1 byte    Number of siblings in this node.  The siblings\n//                          follow in sorted order.\n//\n// <sibling>: <byte> [ <nodeidx> <xbyte>\n//                    | <flags> [<flags2>] [<region>] [<affixID>]\n//                    | [<pflags>] <affixID> <prefcondnr> ]\n//\n// <byte>       1 byte      Byte value of the sibling.  Special cases:\n//                          BY_NOFLAGS: End of word without flags and for all\n//                                      regions.\n//                                      For PREFIXTREE <affixID> and\n//                                      <prefcondnr> follow.\n//                          BY_FLAGS:   End of word, <flags> follow.\n//                                      For PREFIXTREE <pflags>, <affixID>\n//                                      and <prefcondnr> follow.\n//                          BY_FLAGS2:  End of word, <flags> and <flags2>\n//                                      follow.  Not used in PREFIXTREE.\n//                          BY_INDEX:   Child of sibling is shared, <nodeidx>\n//                                      and <xbyte> follow.\n//\n// <nodeidx>    3 bytes     Index of child for this sibling, MSB first.\n//\n// <xbyte>      1 byte      Byte value of the sibling.\n//\n// <flags>      1 byte      Bitmask of:\n//                          WF_ALLCAP   word must have only capitals\n//                          WF_ONECAP   first char of word must be capital\n//                          WF_KEEPCAP  keep-case word\n//                          WF_FIXCAP   keep-case word, all caps not allowed\n//                          WF_RARE     rare word\n//                          WF_BANNED   bad word\n//                          WF_REGION   <region> follows\n//                          WF_AFX      <affixID> follows\n//\n// <flags2>     1 byte      Bitmask of:\n//                          WF_HAS_AFF >> 8   word includes affix\n//                          WF_NEEDCOMP >> 8  word only valid in compound\n//                          WF_NOSUGGEST >> 8  word not used for suggestions\n//                          WF_COMPROOT >> 8  word already a compound\n//                          WF_NOCOMPBEF >> 8 no compounding before this word\n//                          WF_NOCOMPAFT >> 8 no compounding after this word\n//\n// <pflags>     1 byte      Bitmask of:\n//                          WFP_RARE    rare prefix\n//                          WFP_NC      non-combining prefix\n//                          WFP_UP      letter after prefix made upper case\n//\n// <region>     1 byte      Bitmask for regions in which word is valid.  When\n//                          omitted it's valid in all regions.\n//                          Lowest bit is for region 1.\n//\n// <affixID>    1 byte      ID of affix that can be used with this word.  In\n//                          PREFIXTREE used for the required prefix ID.\n//\n// <prefcondnr> 2 bytes     Prefix condition number, index in <prefcond> list\n//                          from HEADER.\n//\n// All text characters are in 'encoding', but stored as single bytes.\n\n// Vim .sug file format:  <SUGHEADER>\n//                        <SUGWORDTREE>\n//                        <SUGTABLE>\n//\n// <SUGHEADER>: <fileID> <versionnr> <timestamp>\n//\n// <fileID>     6 bytes     \"VIMsug\"\n// <versionnr>  1 byte      VIMSUGVERSION\n// <timestamp>  8 bytes     timestamp that must match with .spl file\n//\n//\n// <SUGWORDTREE>: <wordtree>  (see above, no flags or region used)\n//\n//\n// <SUGTABLE>: <sugwcount> <sugline> ...\n//\n// <sugwcount>  4 bytes     number of <sugline> following\n//\n// <sugline>: <sugnr> ... NUL\n//\n// <sugnr>:     X bytes     word number that results in this soundfolded word,\n//                          stored as an offset to the previous number in as\n//                          few bytes as possible, see offset2bytes())\n\n#include <stdio.h>\n#include <stdint.h>\n#include <wctype.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/spell_defs.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/spellfile.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n\n#ifndef UNIX            // it's in os/unix_defs.h for Unix\n# include <time.h>      // for time_t\n#endif\n\n// Special byte values for <byte>.  Some are only used in the tree for\n// postponed prefixes, some only in the other trees.  This is a bit messy...\n#define BY_NOFLAGS      0       // end of word without flags or region; for\n                                // postponed prefix: no <pflags>\n#define BY_INDEX        1       // child is shared, index follows\n#define BY_FLAGS        2       // end of word, <flags> byte follows; for\n                                // postponed prefix: <pflags> follows\n#define BY_FLAGS2       3       // end of word, <flags> and <flags2> bytes\n                                // follow; never used in prefix tree\n#define BY_SPECIAL  BY_FLAGS2   // highest special byte value\n\n#define ZERO_FLAG   65009       // used when flag is zero: \"0\"\n\n// Flags used in .spl file for soundsalike flags.\n#define SAL_F0LLOWUP            1\n#define SAL_COLLAPSE            2\n#define SAL_REM_ACCENTS         4\n\n#define VIMSPELLMAGIC \"VIMspell\"  // string at start of Vim spell file\n#define VIMSPELLMAGICL (sizeof(VIMSPELLMAGIC) - 1)\n#define VIMSPELLVERSION 50\n\n// Section IDs.  Only renumber them when VIMSPELLVERSION changes!\n#define SN_REGION       0       // <regionname> section\n#define SN_CHARFLAGS    1       // charflags section\n#define SN_MIDWORD      2       // <midword> section\n#define SN_PREFCOND     3       // <prefcond> section\n#define SN_REP          4       // REP items section\n#define SN_SAL          5       // SAL items section\n#define SN_SOFO         6       // soundfolding section\n#define SN_MAP          7       // MAP items section\n#define SN_COMPOUND     8       // compound words section\n#define SN_SYLLABLE     9       // syllable section\n#define SN_NOBREAK      10      // NOBREAK section\n#define SN_SUGFILE      11      // timestamp for .sug file\n#define SN_REPSAL       12      // REPSAL items section\n#define SN_WORDS        13      // common words\n#define SN_NOSPLITSUGS  14      // don't split word for suggestions\n#define SN_INFO         15      // info section\n#define SN_NOCOMPOUNDSUGS 16    // don't compound for suggestions\n#define SN_END          255     // end of sections\n\n#define SNF_REQUIRED    1       // <sectionflags>: required section\n\n#define CF_WORD         0x01\n#define CF_UPPER        0x02\n\nstatic char *e_spell_trunc = N_(\"E758: Truncated spell file\");\nstatic char *e_afftrailing = N_(\"Trailing text in %s line %d: %s\");\nstatic char *e_affname = N_(\"Affix name too long in %s line %d: %s\");\nstatic char *msg_compressing = N_(\"Compressing word tree...\");\n\n#define MAXLINELEN  500         // Maximum length in bytes of a line in a .aff\n                                // and .dic file.\n// Main structure to store the contents of a \".aff\" file.\ntypedef struct afffile_S {\n  char_u      *af_enc;          // \"SET\", normalized, alloc'ed string or NULL\n  int af_flagtype;              // AFT_CHAR, AFT_LONG, AFT_NUM or AFT_CAPLONG\n  unsigned af_rare;             // RARE ID for rare word\n  unsigned af_keepcase;         // KEEPCASE ID for keep-case word\n  unsigned af_bad;              // BAD ID for banned word\n  unsigned af_needaffix;        // NEEDAFFIX ID\n  unsigned af_circumfix;        // CIRCUMFIX ID\n  unsigned af_needcomp;         // NEEDCOMPOUND ID\n  unsigned af_comproot;         // COMPOUNDROOT ID\n  unsigned af_compforbid;       // COMPOUNDFORBIDFLAG ID\n  unsigned af_comppermit;       // COMPOUNDPERMITFLAG ID\n  unsigned af_nosuggest;        // NOSUGGEST ID\n  int af_pfxpostpone;           // postpone prefixes without chop string and\n                                // without flags\n  bool af_ignoreextra;          // IGNOREEXTRA present\n  hashtab_T af_pref;            // hashtable for prefixes, affheader_T\n  hashtab_T af_suff;            // hashtable for suffixes, affheader_T\n  hashtab_T af_comp;            // hashtable for compound flags, compitem_T\n} afffile_T;\n\n#define AFT_CHAR        0       // flags are one character\n#define AFT_LONG        1       // flags are two characters\n#define AFT_CAPLONG     2       // flags are one or two characters\n#define AFT_NUM         3       // flags are numbers, comma separated\n\ntypedef struct affentry_S affentry_T;\n// Affix entry from \".aff\" file.  Used for prefixes and suffixes.\nstruct affentry_S {\n  affentry_T  *ae_next;         // next affix with same name/number\n  char_u      *ae_chop;         // text to chop off basic word (can be NULL)\n  char_u      *ae_add;          // text to add to basic word (can be NULL)\n  char_u      *ae_flags;        // flags on the affix (can be NULL)\n  char_u      *ae_cond;         // condition (NULL for \".\")\n  regprog_T   *ae_prog;         // regexp program for ae_cond or NULL\n  char ae_compforbid;           // COMPOUNDFORBIDFLAG found\n  char ae_comppermit;           // COMPOUNDPERMITFLAG found\n};\n\n# define AH_KEY_LEN 17          // 2 x 8 bytes + NUL\n\n// Affix header from \".aff\" file.  Used for af_pref and af_suff.\ntypedef struct affheader_S {\n  char_u ah_key[AH_KEY_LEN];    // key for hashtab == name of affix\n  unsigned ah_flag;             // affix name as number, uses \"af_flagtype\"\n  int ah_newID;                 // prefix ID after renumbering; 0 if not used\n  int ah_combine;               // suffix may combine with prefix\n  int ah_follows;               // another affix block should be following\n  affentry_T  *ah_first;        // first affix entry\n} affheader_T;\n\n#define HI2AH(hi)   ((affheader_T *)(hi)->hi_key)\n\n// Flag used in compound items.\ntypedef struct compitem_S {\n  char_u ci_key[AH_KEY_LEN];    // key for hashtab == name of compound\n  unsigned ci_flag;             // affix name as number, uses \"af_flagtype\"\n  int ci_newID;                 // affix ID after renumbering.\n} compitem_T;\n\n#define HI2CI(hi)   ((compitem_T *)(hi)->hi_key)\n\n// Structure that is used to store the items in the word tree.  This avoids\n// the need to keep track of each allocated thing, everything is freed all at\n// once after \":mkspell\" is done.\n// Note: \"sb_next\" must be just before \"sb_data\" to make sure the alignment of\n// \"sb_data\" is correct for systems where pointers must be aligned on\n// pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).\n#define  SBLOCKSIZE 16000       // size of sb_data\ntypedef struct sblock_S sblock_T;\nstruct sblock_S {\n  int sb_used;                  // nr of bytes already in use\n  sblock_T    *sb_next;         // next block in list\n  char_u sb_data[1];            // data, actually longer\n};\n\n// A node in the tree.\ntypedef struct wordnode_S wordnode_T;\nstruct wordnode_S {\n  union {   // shared to save space\n    char_u hashkey[6];          // the hash key, only used while compressing\n    int index;                  // index in written nodes (valid after first\n                                // round)\n  } wn_u1;\n  union {   // shared to save space\n    wordnode_T *next;           // next node with same hash key\n    wordnode_T *wnode;          // parent node that will write this node\n  } wn_u2;\n  wordnode_T  *wn_child;        // child (next byte in word)\n  wordnode_T  *wn_sibling;      // next sibling (alternate byte in word,\n                                //   always sorted)\n  int wn_refs;                  // Nr. of references to this node.  Only\n                                //   relevant for first node in a list of\n                                //   siblings, in following siblings it is\n                                //   always one.\n  char_u wn_byte;               // Byte for this node. NUL for word end\n\n  // Info for when \"wn_byte\" is NUL.\n  // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n  // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n  // \"wn_region\" the LSW of the wordnr.\n  char_u wn_affixID;            // supported/required prefix ID or 0\n  uint16_t wn_flags;            // WF_ flags\n  short wn_region;              // region mask\n\n#ifdef SPELL_PRINTTREE\n  int wn_nr;                    // sequence nr for printing\n#endif\n};\n\n#define WN_MASK  0xffff         // mask relevant bits of \"wn_flags\"\n\n#define HI2WN(hi)    (wordnode_T *)((hi)->hi_key)\n\n// Info used while reading the spell files.\ntypedef struct spellinfo_S {\n  wordnode_T  *si_foldroot;     // tree with case-folded words\n  long si_foldwcount;           // nr of words in si_foldroot\n\n  wordnode_T  *si_keeproot;     // tree with keep-case words\n  long si_keepwcount;           // nr of words in si_keeproot\n\n  wordnode_T  *si_prefroot;     // tree with postponed prefixes\n\n  long si_sugtree;              // creating the soundfolding trie\n\n  sblock_T    *si_blocks;       // memory blocks used\n  long si_blocks_cnt;           // memory blocks allocated\n  int si_did_emsg;              // TRUE when ran out of memory\n\n  long si_compress_cnt;         // words to add before lowering\n                                // compression limit\n  wordnode_T  *si_first_free;   // List of nodes that have been freed during\n                                // compression, linked by \"wn_child\" field.\n  long si_free_count;           // number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n  int si_wordnode_nr;           // sequence nr for nodes\n#endif\n  buf_T       *si_spellbuf;     // buffer used to store soundfold word table\n\n  int si_ascii;                 // handling only ASCII words\n  int si_add;                   // addition file\n  int si_clear_chartab;             // when TRUE clear char tables\n  int si_region;                // region mask\n  vimconv_T si_conv;            // for conversion to 'encoding'\n  int si_memtot;                // runtime memory used\n  int si_verbose;               // verbose messages\n  int si_msg_count;             // number of words added since last message\n  char_u      *si_info;         // info text chars or NULL\n  int si_region_count;          // number of regions supported (1 when there\n                                // are no regions)\n  char_u si_region_name[MAXREGIONS * 2 + 1];\n                                // region names; used only if\n                                // si_region_count > 1)\n\n  garray_T si_rep;              // list of fromto_T entries from REP lines\n  garray_T si_repsal;           // list of fromto_T entries from REPSAL lines\n  garray_T si_sal;              // list of fromto_T entries from SAL lines\n  char_u      *si_sofofr;       // SOFOFROM text\n  char_u      *si_sofoto;       // SOFOTO text\n  int si_nosugfile;             // NOSUGFILE item found\n  int si_nosplitsugs;           // NOSPLITSUGS item found\n  int si_nocompoundsugs;        // NOCOMPOUNDSUGS item found\n  int si_followup;              // soundsalike: ?\n  int si_collapse;              // soundsalike: ?\n  hashtab_T si_commonwords;     // hashtable for common words\n  time_t si_sugtime;            // timestamp for .sug file\n  int si_rem_accents;           // soundsalike: remove accents\n  garray_T si_map;              // MAP info concatenated\n  char_u      *si_midword;      // MIDWORD chars or NULL\n  int si_compmax;               // max nr of words for compounding\n  int si_compminlen;            // minimal length for compounding\n  int si_compsylmax;            // max nr of syllables for compounding\n  int si_compoptions;           // COMP_ flags\n  garray_T si_comppat;          // CHECKCOMPOUNDPATTERN items, each stored as\n                                // a string\n  char_u      *si_compflags;    // flags used for compounding\n  char_u si_nobreak;            // NOBREAK\n  char_u      *si_syllable;     // syllable string\n  garray_T si_prefcond;         // table with conditions for postponed\n                                // prefixes, each stored as a string\n  int si_newprefID;             // current value for ah_newID\n  int si_newcompID;             // current value for compound ID\n} spellinfo_T;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"spellfile.c.generated.h\"\n#endif\n\n/// Read n bytes from fd to buf, returning on errors\n///\n/// @param[out]  buf  Buffer to read to, must be at least n bytes long.\n/// @param[in]  n  Amount of bytes to read.\n/// @param  fd  FILE* to read from.\n/// @param  exit_code  Code to run before returning.\n///\n/// @return Allows to proceed if everything is OK, returns SP_TRUNCERROR if\n///         there are not enough bytes, returns SP_OTHERERROR if reading failed.\n#define SPELL_READ_BYTES(buf, n, fd, exit_code) \\\n    do { \\\n      const size_t n__SPRB = (n); \\\n      FILE *const fd__SPRB = (fd); \\\n      char *const buf__SPRB = (buf); \\\n      const size_t read_bytes__SPRB = fread(buf__SPRB, 1, n__SPRB, fd__SPRB); \\\n      if (read_bytes__SPRB != n__SPRB) { \\\n        exit_code; \\\n        return feof(fd__SPRB) ? SP_TRUNCERROR : SP_OTHERERROR; \\\n      } \\\n    } while (0)\n\n/// Like #SPELL_READ_BYTES, but also error out if NUL byte was read\n///\n/// @return Allows to proceed if everything is OK, returns SP_TRUNCERROR if\n///         there are not enough bytes, returns SP_OTHERERROR if reading failed,\n///         returns SP_FORMERROR if read out a NUL byte.\n#define SPELL_READ_NONNUL_BYTES(buf, n, fd, exit_code) \\\n    do { \\\n      const size_t n__SPRNB = (n); \\\n      FILE *const fd__SPRNB = (fd); \\\n      char *const buf__SPRNB = (buf); \\\n      SPELL_READ_BYTES(buf__SPRNB, n__SPRNB, fd__SPRNB, exit_code); \\\n      if (memchr(buf__SPRNB, NUL, (size_t)n__SPRNB)) { \\\n        exit_code; \\\n        return SP_FORMERROR; \\\n      } \\\n    } while (0)\n\n/// Check that spell file starts with a magic string\n///\n/// Does not check for version of the file.\n///\n/// @param  fd  File to check.\n///\n/// @return 0 in case of success, SP_TRUNCERROR if file contains not enough\n///         bytes, SP_FORMERROR if it does not match magic string and\n///         SP_OTHERERROR if reading file failed.\nstatic inline int spell_check_magic_string(FILE *const fd)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE\n{\n  char buf[VIMSPELLMAGICL];\n  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd, ;);\n  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {\n    return SP_FORMERROR;\n  }\n  return 0;\n}\n\n// Load one spell file and store the info into a slang_T.\n//\n// This is invoked in three ways:\n// - From spell_load_cb() to load a spell file for the first time.  \"lang\" is\n//   the language name, \"old_lp\" is NULL.  Will allocate an slang_T.\n// - To reload a spell file that was changed.  \"lang\" is NULL and \"old_lp\"\n//   points to the existing slang_T.\n// - Just after writing a .spl file; it's read back to produce the .sug file.\n//   \"old_lp\" is NULL and \"lang\" is NULL.  Will allocate an slang_T.\n//\n// Returns the slang_T the spell file was loaded into.  NULL for error.\nslang_T *\nspell_load_file (\n    char_u *fname,\n    char_u *lang,\n    slang_T *old_lp,\n    bool silent                     // no error if file doesn't exist\n)\n{\n  FILE        *fd;\n  char_u      *p;\n  int n;\n  int len;\n  char_u      *save_sourcing_name = sourcing_name;\n  linenr_T save_sourcing_lnum = sourcing_lnum;\n  slang_T     *lp = NULL;\n  int c = 0;\n  int res;\n\n  fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    if (!silent)\n      EMSG2(_(e_notopen), fname);\n    else if (p_verbose > 2) {\n      verbose_enter();\n      smsg((char *)e_notopen, fname);\n      verbose_leave();\n    }\n    goto endFAIL;\n  }\n  if (p_verbose > 2) {\n    verbose_enter();\n    smsg(_(\"Reading spell file \\\"%s\\\"\"), fname);\n    verbose_leave();\n  }\n\n  if (old_lp == NULL) {\n    lp = slang_alloc(lang);\n\n    // Remember the file name, used to reload the file when it's updated.\n    lp->sl_fname = vim_strsave(fname);\n\n    // Check for .add.spl.\n    lp->sl_add = strstr((char *)path_tail(fname), SPL_FNAME_ADD) != NULL;\n  } else\n    lp = old_lp;\n\n  // Set sourcing_name, so that error messages mention the file name.\n  sourcing_name = fname;\n  sourcing_lnum = 0;\n\n  // <HEADER>: <fileID>\n  const int scms_ret = spell_check_magic_string(fd);\n  switch (scms_ret) {\n    case SP_FORMERROR:\n    case SP_TRUNCERROR: {\n      emsgf(\"%s\", _(\"E757: This does not look like a spell file\"));\n      goto endFAIL;\n    }\n    case SP_OTHERERROR: {\n      emsgf(_(\"E5042: Failed to read spell file %s: %s\"),\n            fname, strerror(ferror(fd)));\n      goto endFAIL;\n    }\n    case 0: {\n      break;\n    }\n  }\n  c = getc(fd);                                         // <versionnr>\n  if (c < VIMSPELLVERSION) {\n    EMSG(_(\"E771: Old spell file, needs to be updated\"));\n    goto endFAIL;\n  } else if (c > VIMSPELLVERSION) {\n    EMSG(_(\"E772: Spell file is for newer version of Vim\"));\n    goto endFAIL;\n  }\n\n\n  // <SECTIONS>: <section> ... <sectionend>\n  // <section>: <sectionID> <sectionflags> <sectionlen> (section contents)\n  for (;; ) {\n    n = getc(fd);                           // <sectionID> or <sectionend>\n    if (n == SN_END)\n      break;\n    c = getc(fd);                                       // <sectionflags>\n    len = get4c(fd);                                    // <sectionlen>\n    if (len < 0)\n      goto truncerr;\n\n    res = 0;\n    switch (n) {\n    case SN_INFO:\n      lp->sl_info = READ_STRING(fd, len);               // <infotext>\n      if (lp->sl_info == NULL)\n        goto endFAIL;\n      break;\n\n    case SN_REGION:\n      res = read_region_section(fd, lp, len);\n      break;\n\n    case SN_CHARFLAGS:\n      res = read_charflags_section(fd);\n      break;\n\n    case SN_MIDWORD:\n      lp->sl_midword = READ_STRING(fd, len);            // <midword>\n      if (lp->sl_midword == NULL)\n        goto endFAIL;\n      break;\n\n    case SN_PREFCOND:\n      res = read_prefcond_section(fd, lp);\n      break;\n\n    case SN_REP:\n      res = read_rep_section(fd, &lp->sl_rep, lp->sl_rep_first);\n      break;\n\n    case SN_REPSAL:\n      res = read_rep_section(fd, &lp->sl_repsal, lp->sl_repsal_first);\n      break;\n\n    case SN_SAL:\n      res = read_sal_section(fd, lp);\n      break;\n\n    case SN_SOFO:\n      res = read_sofo_section(fd, lp);\n      break;\n\n    case SN_MAP:\n      p = READ_STRING(fd, len);                         // <mapstr>\n      if (p == NULL)\n        goto endFAIL;\n      set_map_str(lp, p);\n      xfree(p);\n      break;\n\n    case SN_WORDS:\n      res = read_words_section(fd, lp, len);\n      break;\n\n    case SN_SUGFILE:\n      lp->sl_sugtime = get8ctime(fd);                   // <timestamp>\n      break;\n\n    case SN_NOSPLITSUGS:\n      lp->sl_nosplitsugs = true;\n      break;\n\n    case SN_NOCOMPOUNDSUGS:\n      lp->sl_nocompoundsugs = true;\n      break;\n\n    case SN_COMPOUND:\n      res = read_compound(fd, lp, len);\n      break;\n\n    case SN_NOBREAK:\n      lp->sl_nobreak = true;\n      break;\n\n    case SN_SYLLABLE:\n      lp->sl_syllable = READ_STRING(fd, len);           // <syllable>\n      if (lp->sl_syllable == NULL)\n        goto endFAIL;\n      if (init_syl_tab(lp) == FAIL)\n        goto endFAIL;\n      break;\n\n    default:\n      // Unsupported section.  When it's required give an error\n      // message.  When it's not required skip the contents.\n      if (c & SNF_REQUIRED) {\n        EMSG(_(\"E770: Unsupported section in spell file\"));\n        goto endFAIL;\n      }\n      while (--len >= 0)\n        if (getc(fd) < 0)\n          goto truncerr;\n      break;\n    }\nsomeerror:\n    if (res == SP_FORMERROR) {\n      EMSG(_(e_format));\n      goto endFAIL;\n    }\n    if (res == SP_TRUNCERROR) {\ntruncerr:\n      EMSG(_(e_spell_trunc));\n      goto endFAIL;\n    }\n    if (res == SP_OTHERERROR)\n      goto endFAIL;\n  }\n\n  // <LWORDTREE>\n  res = spell_read_tree(fd, &lp->sl_fbyts, &lp->sl_fbyts_len,\n                        &lp->sl_fidxs, false, 0);\n  if (res != 0) {\n    goto someerror;\n  }\n\n  // <KWORDTREE>\n  res = spell_read_tree(fd, &lp->sl_kbyts, NULL, &lp->sl_kidxs, false, 0);\n  if (res != 0) {\n    goto someerror;\n  }\n\n  // <PREFIXTREE>\n  res = spell_read_tree(fd, &lp->sl_pbyts, NULL, &lp->sl_pidxs, true,\n                        lp->sl_prefixcnt);\n  if (res != 0) {\n    goto someerror;\n  }\n\n  // For a new file link it in the list of spell files.\n  if (old_lp == NULL && lang != NULL) {\n    lp->sl_next = first_lang;\n    first_lang = lp;\n  }\n\n  goto endOK;\n\nendFAIL:\n  if (lang != NULL)\n    // truncating the name signals the error to spell_load_lang()\n    *lang = NUL;\n  if (lp != NULL && old_lp == NULL)\n    slang_free(lp);\n  lp = NULL;\n\nendOK:\n  if (fd != NULL)\n    fclose(fd);\n  sourcing_name = save_sourcing_name;\n  sourcing_lnum = save_sourcing_lnum;\n\n  return lp;\n}\n\n// Fill in the wordcount fields for a trie.\n// Returns the total number of words.\nstatic void tree_count_words(char_u *byts, idx_T *idxs)\n{\n  int depth;\n  idx_T arridx[MAXWLEN];\n  int curi[MAXWLEN];\n  int c;\n  idx_T n;\n  int wordcount[MAXWLEN];\n\n  arridx[0] = 0;\n  curi[0] = 1;\n  wordcount[0] = 0;\n  depth = 0;\n  while (depth >= 0 && !got_int) {\n    if (curi[depth] > byts[arridx[depth]]) {\n      // Done all bytes at this node, go up one level.\n      idxs[arridx[depth]] = wordcount[depth];\n      if (depth > 0)\n        wordcount[depth - 1] += wordcount[depth];\n\n      --depth;\n      fast_breakcheck();\n    } else {\n      // Do one more byte at this node.\n      n = arridx[depth] + curi[depth];\n      ++curi[depth];\n\n      c = byts[n];\n      if (c == 0) {\n        // End of word, count it.\n        ++wordcount[depth];\n\n        // Skip over any other NUL bytes (same word with different\n        // flags).\n        while (byts[n + 1] == 0) {\n          ++n;\n          ++curi[depth];\n        }\n      } else {\n        // Normal char, go one level deeper to count the words.\n        ++depth;\n        arridx[depth] = idxs[n];\n        curi[depth] = 1;\n        wordcount[depth] = 0;\n      }\n    }\n  }\n}\n\n// Load the .sug files for languages that have one and weren't loaded yet.\nvoid suggest_load_files(void)\n{\n  langp_T     *lp;\n  slang_T     *slang;\n  char_u      *dotp;\n  FILE        *fd;\n  char_u buf[MAXWLEN];\n  int i;\n  time_t timestamp;\n  int wcount;\n  int wordnr;\n  garray_T ga;\n  int c;\n\n  // Do this for all languages that support sound folding.\n  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {\n    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n    slang = lp->lp_slang;\n    if (slang->sl_sugtime != 0 && !slang->sl_sugloaded) {\n      // Change \".spl\" to \".sug\" and open the file.  When the file isn't\n      // found silently skip it.  Do set \"sl_sugloaded\" so that we\n      // don't try again and again.\n      slang->sl_sugloaded = true;\n\n      dotp = STRRCHR(slang->sl_fname, '.');\n      if (dotp == NULL || fnamecmp(dotp, \".spl\") != 0) {\n        continue;\n      }\n      STRCPY(dotp, \".sug\");\n      fd = os_fopen((char *)slang->sl_fname, \"r\");\n      if (fd == NULL) {\n        goto nextone;\n      }\n\n      // <SUGHEADER>: <fileID> <versionnr> <timestamp>\n      for (i = 0; i < VIMSUGMAGICL; ++i)\n        buf[i] = getc(fd);                              // <fileID>\n      if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0) {\n        EMSG2(_(\"E778: This does not look like a .sug file: %s\"),\n            slang->sl_fname);\n        goto nextone;\n      }\n      c = getc(fd);                                     // <versionnr>\n      if (c < VIMSUGVERSION) {\n        EMSG2(_(\"E779: Old .sug file, needs to be updated: %s\"),\n            slang->sl_fname);\n        goto nextone;\n      } else if (c > VIMSUGVERSION)   {\n        EMSG2(_(\"E780: .sug file is for newer version of Vim: %s\"),\n            slang->sl_fname);\n        goto nextone;\n      }\n\n      // Check the timestamp, it must be exactly the same as the one in\n      // the .spl file.  Otherwise the word numbers won't match.\n      timestamp = get8ctime(fd);                        // <timestamp>\n      if (timestamp != slang->sl_sugtime) {\n        EMSG2(_(\"E781: .sug file doesn't match .spl file: %s\"),\n            slang->sl_fname);\n        goto nextone;\n      }\n\n      // <SUGWORDTREE>: <wordtree>\n      // Read the trie with the soundfolded words.\n      if (spell_read_tree(fd, &slang->sl_sbyts, NULL, &slang->sl_sidxs,\n                          false, 0) != 0) {\nsomeerror:\n        EMSG2(_(\"E782: error while reading .sug file: %s\"),\n            slang->sl_fname);\n        slang_clear_sug(slang);\n        goto nextone;\n      }\n\n      // <SUGTABLE>: <sugwcount> <sugline> ...\n      //\n      // Read the table with word numbers.  We use a file buffer for\n      // this, because it's so much like a file with lines.  Makes it\n      // possible to swap the info and save on memory use.\n      slang->sl_sugbuf = open_spellbuf();\n\n      // <sugwcount>\n      wcount = get4c(fd);\n      if (wcount < 0)\n        goto someerror;\n\n      // Read all the wordnr lists into the buffer, one NUL terminated\n      // list per line.\n      ga_init(&ga, 1, 100);\n      for (wordnr = 0; wordnr < wcount; ++wordnr) {\n        ga.ga_len = 0;\n        for (;; ) {\n          c = getc(fd);                                     // <sugline>\n          if (c < 0) {\n            goto someerror;\n          }\n          GA_APPEND(char_u, &ga, c);\n          if (c == NUL)\n            break;\n        }\n        if (ml_append_buf(slang->sl_sugbuf, (linenr_T)wordnr,\n                          ga.ga_data, ga.ga_len, true) == FAIL) {\n          goto someerror;\n        }\n      }\n      ga_clear(&ga);\n\n      // Need to put word counts in the word tries, so that we can find\n      // a word by its number.\n      tree_count_words(slang->sl_fbyts, slang->sl_fidxs);\n      tree_count_words(slang->sl_sbyts, slang->sl_sidxs);\n\nnextone:\n      if (fd != NULL)\n        fclose(fd);\n      STRCPY(dotp, \".spl\");\n    }\n  }\n}\n\n\n// Read a length field from \"fd\" in \"cnt_bytes\" bytes.\n// Allocate memory, read the string into it and add a NUL at the end.\n// Returns NULL when the count is zero.\n// Sets \"*cntp\" to SP_*ERROR when there is an error, length of the result\n// otherwise.\nstatic char_u *read_cnt_string(FILE *fd, int cnt_bytes, int *cntp)\n{\n  int cnt = 0;\n  char_u      *str;\n\n  // read the length bytes, MSB first\n  for (int i = 0; i < cnt_bytes; i++) {\n    const int c = getc(fd);\n\n    if (c == EOF) {\n      *cntp = SP_TRUNCERROR;\n      return NULL;\n    }\n    cnt = (cnt << 8) + (unsigned)c;\n  }\n  *cntp = cnt;\n  if (cnt == 0)\n    return NULL;            // nothing to read, return NULL\n\n  str = READ_STRING(fd, cnt);\n  if (str == NULL)\n    *cntp = SP_OTHERERROR;\n  return str;\n}\n\n// Read SN_REGION: <regionname> ...\n// Return SP_*ERROR flags.\nstatic int read_region_section(FILE *fd, slang_T *lp, int len)\n{\n  if (len > MAXREGIONS * 2) {\n    return SP_FORMERROR;\n  }\n  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd, ;);\n  lp->sl_regions[len] = NUL;\n  return 0;\n}\n\n// Read SN_CHARFLAGS section: <charflagslen> <charflags>\n//                              <folcharslen> <folchars>\n// Return SP_*ERROR flags.\nstatic int read_charflags_section(FILE *fd)\n{\n  char_u      *flags;\n  char_u      *fol;\n  int flagslen, follen;\n\n  // <charflagslen> <charflags>\n  flags = read_cnt_string(fd, 1, &flagslen);\n  if (flagslen < 0)\n    return flagslen;\n\n  // <folcharslen> <folchars>\n  fol = read_cnt_string(fd, 2, &follen);\n  if (follen < 0) {\n    xfree(flags);\n    return follen;\n  }\n\n  // Set the word-char flags and fill SPELL_ISUPPER() table.\n  if (flags != NULL && fol != NULL)\n    set_spell_charflags(flags, flagslen, fol);\n\n  xfree(flags);\n  xfree(fol);\n\n  // When <charflagslen> is zero then <fcharlen> must also be zero.\n  if ((flags == NULL) != (fol == NULL))\n    return SP_FORMERROR;\n  return 0;\n}\n\n// Read SN_PREFCOND section.\n// Return SP_*ERROR flags.\nstatic int read_prefcond_section(FILE *fd, slang_T *lp)\n{\n  // <prefcondcnt> <prefcond> ...\n  const int cnt = get2c(fd);  // <prefcondcnt>\n  if (cnt <= 0) {\n    return SP_FORMERROR;\n  }\n\n  lp->sl_prefprog = xcalloc(cnt, sizeof(regprog_T *));\n  lp->sl_prefixcnt = cnt;\n\n  for (int i = 0; i < cnt; i++) {\n    // <prefcond> : <condlen> <condstr>\n    const int n = getc(fd);  // <condlen>\n    if (n < 0 || n >= MAXWLEN) {\n      return SP_FORMERROR;\n    }\n\n    // When <condlen> is zero we have an empty condition.  Otherwise\n    // compile the regexp program used to check for the condition.\n    if (n > 0) {\n      char buf[MAXWLEN + 1];\n      buf[0] = '^';  // always match at one position only\n      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd, ;);\n      buf[n + 1] = NUL;\n      lp->sl_prefprog[i] = vim_regcomp((char_u *)buf, RE_MAGIC | RE_STRING);\n    }\n  }\n  return 0;\n}\n\n// Read REP or REPSAL items section from \"fd\": <repcount> <rep> ...\n// Return SP_*ERROR flags.\nstatic int read_rep_section(FILE *fd, garray_T *gap, int16_t *first)\n{\n  int cnt;\n  fromto_T    *ftp;\n\n  cnt = get2c(fd);                                      // <repcount>\n  if (cnt < 0)\n    return SP_TRUNCERROR;\n\n  ga_grow(gap, cnt);\n\n  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n  for (; gap->ga_len < cnt; ++gap->ga_len) {\n    int c;\n    ftp = &((fromto_T *)gap->ga_data)[gap->ga_len];\n    ftp->ft_from = read_cnt_string(fd, 1, &c);\n    if (c < 0)\n      return c;\n    if (c == 0)\n      return SP_FORMERROR;\n    ftp->ft_to = read_cnt_string(fd, 1, &c);\n    if (c <= 0) {\n      xfree(ftp->ft_from);\n      if (c < 0)\n        return c;\n      return SP_FORMERROR;\n    }\n  }\n\n  // Fill the first-index table.\n  for (int i = 0; i < 256; ++i) {\n    first[i] = -1;\n  }\n  for (int i = 0; i < gap->ga_len; ++i) {\n    ftp = &((fromto_T *)gap->ga_data)[i];\n    if (first[*ftp->ft_from] == -1)\n      first[*ftp->ft_from] = i;\n  }\n  return 0;\n}\n\n// Read SN_SAL section: <salflags> <salcount> <sal> ...\n// Return SP_*ERROR flags.\nstatic int read_sal_section(FILE *fd, slang_T *slang)\n{\n  int cnt;\n  garray_T    *gap;\n  salitem_T   *smp;\n  int ccnt;\n  char_u      *p;\n\n  slang->sl_sofo = false;\n\n  const int flags = getc(fd);                   // <salflags>\n  if (flags & SAL_F0LLOWUP) {\n    slang->sl_followup = true;\n  }\n  if (flags & SAL_COLLAPSE) {\n    slang->sl_collapse = true;\n  }\n  if (flags & SAL_REM_ACCENTS) {\n    slang->sl_rem_accents = true;\n  }\n\n  cnt = get2c(fd);                              // <salcount>\n  if (cnt < 0)\n    return SP_TRUNCERROR;\n\n  gap = &slang->sl_sal;\n  ga_init(gap, sizeof(salitem_T), 10);\n  ga_grow(gap, cnt + 1);\n\n  // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n  for (; gap->ga_len < cnt; gap->ga_len++) {\n    int c = NUL;\n\n    smp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n    ccnt = getc(fd);                            // <salfromlen>\n    if (ccnt < 0)\n      return SP_TRUNCERROR;\n    p = xmalloc(ccnt + 2);\n    smp->sm_lead = p;\n\n    // Read up to the first special char into sm_lead.\n    int i = 0;\n    for (; i < ccnt; ++i) {\n      c = getc(fd);                             // <salfrom>\n      if (vim_strchr((char_u *)\"0123456789(-<^$\", c) != NULL)\n        break;\n      *p++ = c;\n    }\n    smp->sm_leadlen = (int)(p - smp->sm_lead);\n    *p++ = NUL;\n\n    // Put (abc) chars in sm_oneof, if any.\n    if (c == '(') {\n      smp->sm_oneof = p;\n      for (++i; i < ccnt; ++i) {\n        c = getc(fd);                           // <salfrom>\n        if (c == ')')\n          break;\n        *p++ = c;\n      }\n      *p++ = NUL;\n      if (++i < ccnt)\n        c = getc(fd);\n    } else\n      smp->sm_oneof = NULL;\n\n    // Any following chars go in sm_rules.\n    smp->sm_rules = p;\n    if (i < ccnt) {\n      // store the char we got while checking for end of sm_lead\n      *p++ = c;\n    }\n    i++;\n    if (i < ccnt) {\n      SPELL_READ_NONNUL_BYTES(                  // <salfrom>\n          (char *)p, (size_t)(ccnt - i), fd, xfree(smp->sm_lead));\n      p += (ccnt - i);\n    }\n    *p++ = NUL;\n\n    // <saltolen> <salto>\n    smp->sm_to = read_cnt_string(fd, 1, &ccnt);\n    if (ccnt < 0) {\n      xfree(smp->sm_lead);\n      return ccnt;\n    }\n\n    // convert the multi-byte strings to wide char strings\n    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n    smp->sm_leadlen = mb_charlen(smp->sm_lead);\n    if (smp->sm_oneof == NULL) {\n      smp->sm_oneof_w = NULL;\n    } else {\n      smp->sm_oneof_w = mb_str2wide(smp->sm_oneof);\n    }\n    if (smp->sm_to == NULL) {\n      smp->sm_to_w = NULL;\n    } else {\n      smp->sm_to_w = mb_str2wide(smp->sm_to);\n    }\n  }\n\n  if (!GA_EMPTY(gap)) {\n    // Add one extra entry to mark the end with an empty sm_lead.  Avoids\n    // that we need to check the index every time.\n    smp = &((salitem_T *)gap->ga_data)[gap->ga_len];\n    p = xmalloc(1);\n    p[0] = NUL;\n    smp->sm_lead = p;\n    smp->sm_lead_w = mb_str2wide(smp->sm_lead);\n    smp->sm_leadlen = 0;\n    smp->sm_oneof = NULL;\n    smp->sm_oneof_w = NULL;\n    smp->sm_rules = p;\n    smp->sm_to = NULL;\n    smp->sm_to_w = NULL;\n    gap->ga_len++;\n  }\n\n  // Fill the first-index table.\n  set_sal_first(slang);\n\n  return 0;\n}\n\n// Read SN_WORDS: <word> ...\n// Return SP_*ERROR flags.\nstatic int read_words_section(FILE *fd, slang_T *lp, int len)\n{\n  int done = 0;\n  int i;\n  int c;\n  char_u word[MAXWLEN];\n\n  while (done < len) {\n    // Read one word at a time.\n    for (i = 0;; ++i) {\n      c = getc(fd);\n      if (c == EOF)\n        return SP_TRUNCERROR;\n      word[i] = c;\n      if (word[i] == NUL)\n        break;\n      if (i == MAXWLEN - 1)\n        return SP_FORMERROR;\n    }\n\n    // Init the count to 10.\n    count_common_word(lp, word, -1, 10);\n    done += i + 1;\n  }\n  return 0;\n}\n\n// SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n// Return SP_*ERROR flags.\nstatic int read_sofo_section(FILE *fd, slang_T *slang)\n{\n  int cnt;\n  char_u      *from, *to;\n  int res;\n\n  slang->sl_sofo = true;\n\n  // <sofofromlen> <sofofrom>\n  from = read_cnt_string(fd, 2, &cnt);\n  if (cnt < 0)\n    return cnt;\n\n  // <sofotolen> <sofoto>\n  to = read_cnt_string(fd, 2, &cnt);\n  if (cnt < 0) {\n    xfree(from);\n    return cnt;\n  }\n\n  // Store the info in slang->sl_sal and/or slang->sl_sal_first.\n  if (from != NULL && to != NULL)\n    res = set_sofo(slang, from, to);\n  else if (from != NULL || to != NULL)\n    res = SP_FORMERROR;        // only one of two strings is an error\n  else\n    res = 0;\n\n  xfree(from);\n  xfree(to);\n  return res;\n}\n\n// Read the compound section from the .spl file:\n//      <compmax> <compminlen> <compsylmax> <compoptions> <compflags>\n// Returns SP_*ERROR flags.\nstatic int read_compound(FILE *fd, slang_T *slang, int len)\n{\n  int todo = len;\n  int c;\n  int atstart;\n  char_u      *pat;\n  char_u      *pp;\n  char_u      *cp;\n  char_u      *ap;\n  char_u      *crp;\n  int cnt;\n  garray_T    *gap;\n\n  if (todo < 2)\n    return SP_FORMERROR;        // need at least two bytes\n\n  --todo;\n  c = getc(fd);                                         // <compmax>\n  if (c < 2)\n    c = MAXWLEN;\n  slang->sl_compmax = c;\n\n  --todo;\n  c = getc(fd);                                         // <compminlen>\n  if (c < 1)\n    c = 0;\n  slang->sl_compminlen = c;\n\n  --todo;\n  c = getc(fd);                                         // <compsylmax>\n  if (c < 1)\n    c = MAXWLEN;\n  slang->sl_compsylmax = c;\n\n  c = getc(fd);                                         // <compoptions>\n  if (c != 0)\n    ungetc(c, fd);          // be backwards compatible with Vim 7.0b\n  else {\n    --todo;\n    c = getc(fd);           // only use the lower byte for now\n    --todo;\n    slang->sl_compoptions = c;\n\n    gap = &slang->sl_comppat;\n    c = get2c(fd);                                      // <comppatcount>\n    if (c < 0) {\n      return SP_TRUNCERROR;\n    }\n    todo -= 2;\n    ga_init(gap, sizeof(char_u *), c);\n    ga_grow(gap, c);\n    while (--c >= 0) {\n      ((char_u **)(gap->ga_data))[gap->ga_len++] =\n        read_cnt_string(fd, 1, &cnt);\n      // <comppatlen> <comppattext>\n      if (cnt < 0)\n        return cnt;\n      todo -= cnt + 1;\n    }\n  }\n  if (todo < 0)\n    return SP_FORMERROR;\n\n  // Turn the COMPOUNDRULE items into a regexp pattern:\n  // \"a[bc]/a*b+\" -> \"^\\(a[bc]\\|a*b\\+\\)$\".\n  // Inserting backslashes may double the length, \"^\\(\\)$<Nul>\" is 7 bytes.\n  // Conversion to utf-8 may double the size.\n  c = todo * 2 + 7;\n  c += todo * 2;\n  pat = xmalloc(c);\n\n  // We also need a list of all flags that can appear at the start and one\n  // for all flags.\n  cp = xmalloc(todo + 1);\n  slang->sl_compstartflags = cp;\n  *cp = NUL;\n\n  ap = xmalloc(todo + 1);\n  slang->sl_compallflags = ap;\n  *ap = NUL;\n\n  // And a list of all patterns in their original form, for checking whether\n  // compounding may work in match_compoundrule().  This is freed when we\n  // encounter a wildcard, the check doesn't work then.\n  crp = xmalloc(todo + 1);\n  slang->sl_comprules = crp;\n\n  pp = pat;\n  *pp++ = '^';\n  *pp++ = '\\\\';\n  *pp++ = '(';\n\n  atstart = 1;\n  while (todo-- > 0) {\n    c = getc(fd);                                       // <compflags>\n    if (c == EOF) {\n      xfree(pat);\n      return SP_TRUNCERROR;\n    }\n\n    // Add all flags to \"sl_compallflags\".\n    if (vim_strchr((char_u *)\"?*+[]/\", c) == NULL\n        && !byte_in_str(slang->sl_compallflags, c)) {\n      *ap++ = c;\n      *ap = NUL;\n    }\n\n    if (atstart != 0) {\n      // At start of item: copy flags to \"sl_compstartflags\".  For a\n      // [abc] item set \"atstart\" to 2 and copy up to the ']'.\n      if (c == '[')\n        atstart = 2;\n      else if (c == ']')\n        atstart = 0;\n      else {\n        if (!byte_in_str(slang->sl_compstartflags, c)) {\n          *cp++ = c;\n          *cp = NUL;\n        }\n        if (atstart == 1)\n          atstart = 0;\n      }\n    }\n\n    // Copy flag to \"sl_comprules\", unless we run into a wildcard.\n    if (crp != NULL) {\n      if (c == '?' || c == '+' || c == '*') {\n        XFREE_CLEAR(slang->sl_comprules);\n        crp = NULL;\n      } else\n        *crp++ = c;\n    }\n\n    if (c == '/') {         // slash separates two items\n      *pp++ = '\\\\';\n      *pp++ = '|';\n      atstart = 1;\n    } else {              // normal char, \"[abc]\" and '*' are copied as-is\n      if (c == '?' || c == '+' || c == '~') {\n        *pp++ = '\\\\';               // \"a?\" becomes \"a\\?\", \"a+\" becomes \"a\\+\"\n      }\n      pp += utf_char2bytes(c, pp);\n    }\n  }\n\n  *pp++ = '\\\\';\n  *pp++ = ')';\n  *pp++ = '$';\n  *pp = NUL;\n\n  if (crp != NULL)\n    *crp = NUL;\n\n  slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);\n  xfree(pat);\n  if (slang->sl_compprog == NULL)\n    return SP_FORMERROR;\n\n  return 0;\n}\n\n// Set the SOFOFROM and SOFOTO items in language \"lp\".\n// Returns SP_*ERROR flags when there is something wrong.\nstatic int set_sofo(slang_T *lp, char_u *from, char_u *to)\n{\n  char_u      *s;\n  char_u      *p;\n\n  // Use \"sl_sal\" as an array with 256 pointers to a list of wide\n  // characters.  The index is the low byte of the character.\n  // The list contains from-to pairs with a terminating NUL.\n  // sl_sal_first[] is used for latin1 \"from\" characters.\n  garray_T *gap = &lp->sl_sal;\n  ga_init(gap, sizeof(int *), 1);\n  ga_grow(gap, 256);\n  memset(gap->ga_data, 0, sizeof(int *) * 256);\n  gap->ga_len = 256;\n\n  // First count the number of items for each list.  Temporarily use\n  // sl_sal_first[] for this.\n  for (p = from, s = to; *p != NUL && *s != NUL; ) {\n    const int c = mb_cptr2char_adv((const char_u **)&p);\n    MB_CPTR_ADV(s);\n    if (c >= 256) {\n      lp->sl_sal_first[c & 0xff]++;\n    }\n  }\n  if (*p != NUL || *s != NUL) {  // lengths differ\n    return SP_FORMERROR;\n  }\n\n  // Allocate the lists.\n  for (int i = 0; i < 256; i++) {\n    if (lp->sl_sal_first[i] > 0) {\n      p = xmalloc(sizeof(int) * (lp->sl_sal_first[i] * 2 + 1));\n      ((int **)gap->ga_data)[i] = (int *)p;\n      *(int *)p = 0;\n    }\n  }\n\n  // Put the characters up to 255 in sl_sal_first[] the rest in a sl_sal\n  // list.\n  memset(lp->sl_sal_first, 0, sizeof(salfirst_T) * 256);\n  for (p = from, s = to; *p != NUL && *s != NUL; ) {\n    const int c = mb_cptr2char_adv((const char_u **)&p);\n    const int i = mb_cptr2char_adv((const char_u **)&s);\n    if (c >= 256) {\n      // Append the from-to chars at the end of the list with\n      // the low byte.\n      int *inp = ((int **)gap->ga_data)[c & 0xff];\n      while (*inp != 0) {\n        inp++;\n      }\n      *inp++ = c;                     // from char\n      *inp++ = i;                     // to char\n      *inp++ = NUL;                   // NUL at the end\n    } else {\n      // mapping byte to char is done in sl_sal_first[]\n      lp->sl_sal_first[c] = i;\n    }\n  }\n\n  return 0;\n}\n\n// Fill the first-index table for \"lp\".\nstatic void set_sal_first(slang_T *lp)\n{\n  salfirst_T  *sfirst;\n  salitem_T   *smp;\n  int c;\n  garray_T    *gap = &lp->sl_sal;\n\n  sfirst = lp->sl_sal_first;\n  for (int i = 0; i < 256; ++i) {\n    sfirst[i] = -1;\n  }\n  smp = (salitem_T *)gap->ga_data;\n  for (int i = 0; i < gap->ga_len; i++) {\n    // Use the lowest byte of the first character.  For latin1 it's\n    // the character, for other encodings it should differ for most\n    // characters.\n    c = *smp[i].sm_lead_w & 0xff;\n    if (sfirst[c] == -1) {\n      sfirst[c] = i;\n\n      // Make sure all entries with this byte are following each\n      // other.  Move the ones that are in the wrong position.  Do\n      // keep the same ordering!\n      while (i + 1 < gap->ga_len\n             && (*smp[i + 1].sm_lead_w & 0xff) == c) {\n        // Skip over entry with same index byte.\n        i++;\n      }\n\n      for (int n = 1; i + n < gap->ga_len; n++) {\n        if ((*smp[i + n].sm_lead_w & 0xff) == c) {\n          salitem_T tsal;\n\n          // Move entry with same index byte after the entries\n          // we already found.\n          i++;\n          n--;\n          tsal = smp[i + n];\n          memmove(smp + i + 1, smp + i, sizeof(salitem_T) * n);\n          smp[i] = tsal;\n        }\n      }\n    }\n  }\n}\n\n// Turn a multi-byte string into a wide character string.\n// Return it in allocated memory.\nstatic int *mb_str2wide(char_u *s)\n{\n  int i = 0;\n\n  int *res = xmalloc((mb_charlen(s) + 1) * sizeof(int));\n  for (char_u *p = s; *p != NUL; ) {\n    res[i++] = mb_ptr2char_adv((const char_u **)&p);\n  }\n  res[i] = NUL;\n\n  return res;\n}\n\n// Reads a tree from the .spl or .sug file.\n// Allocates the memory and stores pointers in \"bytsp\" and \"idxsp\".\n// This is skipped when the tree has zero length.\n// Returns zero when OK, SP_ value for an error.\nstatic int\nspell_read_tree (\n    FILE *fd,\n    char_u **bytsp,\n    long *bytsp_len,\n    idx_T **idxsp,\n    bool prefixtree,               // true for the prefix tree\n    int prefixcnt                  // when \"prefixtree\" is true: prefix count\n)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 4)\n{\n  int idx;\n  char_u      *bp;\n  idx_T       *ip;\n\n  // The tree size was computed when writing the file, so that we can\n  // allocate it as one long block. <nodecount>\n  long len = get4c(fd);\n  if (len < 0) {\n    return SP_TRUNCERROR;\n  }\n  if ((size_t)len >= SIZE_MAX / sizeof(int)) {  // -V547\n    // Invalid length, multiply with sizeof(int) would overflow.\n    return SP_FORMERROR;\n  }\n  if (len > 0) {\n    // Allocate the byte array.\n    bp = xmalloc(len);\n    *bytsp = bp;\n    if (bytsp_len != NULL) {\n      *bytsp_len = len;\n    }\n\n    // Allocate the index array.\n    ip = xcalloc(len, sizeof(*ip));\n    *idxsp = ip;\n\n    // Recursively read the tree and store it in the array.\n    idx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n    if (idx < 0)\n      return idx;\n  }\n  return 0;\n}\n\n// Read one row of siblings from the spell file and store it in the byte array\n// \"byts\" and index array \"idxs\".  Recursively read the children.\n//\n// NOTE: The code here must match put_node()!\n//\n// Returns the index (>= 0) following the siblings.\n// Returns SP_TRUNCERROR if the file is shorter than expected.\n// Returns SP_FORMERROR if there is a format error.\nstatic idx_T\nread_tree_node (\n    FILE *fd,\n    char_u *byts,\n    idx_T *idxs,\n    int maxidx,                         // size of arrays\n    idx_T startidx,                     // current index in \"byts\" and \"idxs\"\n    bool prefixtree,                    // true for reading PREFIXTREE\n    int maxprefcondnr                   // maximum for <prefcondnr>\n)\n{\n  int len;\n  int i;\n  int n;\n  idx_T idx = startidx;\n  int c;\n  int c2;\n#define SHARED_MASK     0x8000000\n\n  len = getc(fd);                                       // <siblingcount>\n  if (len <= 0)\n    return SP_TRUNCERROR;\n\n  if (startidx + len >= maxidx)\n    return SP_FORMERROR;\n  byts[idx++] = len;\n\n  // Read the byte values, flag/region bytes and shared indexes.\n  for (i = 1; i <= len; ++i) {\n    c = getc(fd);                                       // <byte>\n    if (c < 0)\n      return SP_TRUNCERROR;\n    if (c <= BY_SPECIAL) {\n      if (c == BY_NOFLAGS && !prefixtree) {\n        // No flags, all regions.\n        idxs[idx] = 0;\n      } else if (c != BY_INDEX) {\n        if (prefixtree) {\n          // Read the optional pflags byte, the prefix ID and the\n          // condition nr.  In idxs[] store the prefix ID in the low\n          // byte, the condition index shifted up 8 bits, the flags\n          // shifted up 24 bits.\n          if (c == BY_FLAGS)\n            c = getc(fd) << 24;                         // <pflags>\n          else\n            c = 0;\n\n          c |= getc(fd);                                // <affixID>\n\n          n = get2c(fd);                                // <prefcondnr>\n          if (n >= maxprefcondnr)\n            return SP_FORMERROR;\n          c |= (n << 8);\n        } else {    // c must be BY_FLAGS or BY_FLAGS2\n                    // Read flags and optional region and prefix ID.  In\n                    // idxs[] the flags go in the low two bytes, region above\n                    // that and prefix ID above the region.\n          c2 = c;\n          c = getc(fd);                                 // <flags>\n          if (c2 == BY_FLAGS2)\n            c = (getc(fd) << 8) + c;                    // <flags2>\n          if (c & WF_REGION)\n            c = (getc(fd) << 16) + c;                   // <region>\n          if (c & WF_AFX)\n            c = (getc(fd) << 24) + c;                   // <affixID>\n        }\n\n        idxs[idx] = c;\n        c = 0;\n      } else { // c == BY_INDEX\n        // <nodeidx>\n        n = get3c(fd);\n        if (n < 0 || n >= maxidx)\n          return SP_FORMERROR;\n        idxs[idx] = n + SHARED_MASK;\n        c = getc(fd);                                   // <xbyte>\n      }\n    }\n    byts[idx++] = c;\n  }\n\n  // Recursively read the children for non-shared siblings.\n  // Skip the end-of-word ones (zero byte value) and the shared ones (and\n  // remove SHARED_MASK)\n  for (i = 1; i <= len; ++i)\n    if (byts[startidx + i] != 0) {\n      if (idxs[startidx + i] & SHARED_MASK)\n        idxs[startidx + i] &= ~SHARED_MASK;\n      else {\n        idxs[startidx + i] = idx;\n        idx = read_tree_node(fd, byts, idxs, maxidx, idx,\n            prefixtree, maxprefcondnr);\n        if (idx < 0)\n          break;\n      }\n    }\n\n  return idx;\n}\n\n// Reload the spell file \"fname\" if it's loaded.\nstatic void\nspell_reload_one (\n    char_u *fname,\n    bool added_word                // invoked through \"zg\"\n)\n{\n  slang_T     *slang;\n  bool didit = false;\n\n  for (slang = first_lang; slang != NULL; slang = slang->sl_next) {\n    if (path_full_compare(fname, slang->sl_fname, false, true) == kEqualFiles) {\n      slang_clear(slang);\n      if (spell_load_file(fname, NULL, slang, false) == NULL)\n        // reloading failed, clear the language\n        slang_clear(slang);\n      redraw_all_later(SOME_VALID);\n      didit = true;\n    }\n  }\n\n  // When \"zg\" was used and the file wasn't loaded yet, should redo\n  // 'spelllang' to load it now.\n  if (added_word && !didit)\n    did_set_spelllang(curwin);\n}\n\n// Functions for \":mkspell\".\n\n// In the postponed prefixes tree wn_flags is used to store the WFP_ flags,\n// but it must be negative to indicate the prefix tree to tree_add_word().\n// Use a negative number with the lower 8 bits zero.\n#define PFX_FLAGS       -256\n\n// flags for \"condit\" argument of store_aff_word()\n#define CONDIT_COMB     1       // affix must combine\n#define CONDIT_CFIX     2       // affix must have CIRCUMFIX flag\n#define CONDIT_SUF      4       // add a suffix for matching flags\n#define CONDIT_AFF      8       // word already has an affix\n\n// Tunable parameters for when the tree is compressed.  Filled from the\n// 'mkspellmem' option.\nstatic long compress_start = 30000;     // memory / SBLOCKSIZE\nstatic long compress_inc = 100;         // memory / SBLOCKSIZE\nstatic long compress_added = 500000;    // word count\n\n// Check the 'mkspellmem' option.  Return FAIL if it's wrong.\n// Sets \"sps_flags\".\nint spell_check_msm(void)\n{\n  char_u      *p = p_msm;\n  long start = 0;\n  long incr = 0;\n  long added = 0;\n\n  if (!ascii_isdigit(*p))\n    return FAIL;\n  // block count = (value * 1024) / SBLOCKSIZE (but avoid overflow)\n  start = (getdigits_long(&p, true, 0) * 10) / (SBLOCKSIZE / 102);\n  if (*p != ',') {\n    return FAIL;\n  }\n  p++;\n  if (!ascii_isdigit(*p)) {\n    return FAIL;\n  }\n  incr = (getdigits_long(&p, true, 0) * 102) / (SBLOCKSIZE / 10);\n  if (*p != ',') {\n    return FAIL;\n  }\n  p++;\n  if (!ascii_isdigit(*p)) {\n    return FAIL;\n  }\n  added = getdigits_long(&p, true, 0) * 1024;\n  if (*p != NUL) {\n    return FAIL;\n  }\n\n  if (start == 0 || incr == 0 || added == 0 || incr > start) {\n    return FAIL;\n  }\n\n  compress_start = start;\n  compress_inc = incr;\n  compress_added = added;\n  return OK;\n}\n\n#ifdef SPELL_PRINTTREE\n// For debugging the tree code: print the current tree in a (more or less)\n// readable format, so that we can see what happens when adding a word and/or\n// compressing the tree.\n// Based on code from Olaf Seibert.\n#define PRINTLINESIZE   1000\n#define PRINTWIDTH      6\n\n#define PRINTSOME(l, depth, fmt, a1, a2) vim_snprintf(l + depth * PRINTWIDTH, \\\n    PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)\n\nstatic char line1[PRINTLINESIZE];\nstatic char line2[PRINTLINESIZE];\nstatic char line3[PRINTLINESIZE];\n\nstatic void spell_clear_flags(wordnode_T *node)\n{\n  wordnode_T  *np;\n\n  for (np = node; np != NULL; np = np->wn_sibling) {\n    np->wn_u1.index = FALSE;\n    spell_clear_flags(np->wn_child);\n  }\n}\n\nstatic void spell_print_node(wordnode_T *node, int depth)\n{\n  if (node->wn_u1.index) {\n    // Done this node before, print the reference.\n    PRINTSOME(line1, depth, \"(%d)\", node->wn_nr, 0);\n    PRINTSOME(line2, depth, \"    \", 0, 0);\n    PRINTSOME(line3, depth, \"    \", 0, 0);\n    msg((char_u *)line1);\n    msg((char_u *)line2);\n    msg((char_u *)line3);\n  } else {\n    node->wn_u1.index = TRUE;\n\n    if (node->wn_byte != NUL) {\n      if (node->wn_child != NULL)\n        PRINTSOME(line1, depth, \" %c -> \", node->wn_byte, 0);\n      else\n        // Cannot happen?\n        PRINTSOME(line1, depth, \" %c ???\", node->wn_byte, 0);\n    } else\n      PRINTSOME(line1, depth, \" $    \", 0, 0);\n\n    PRINTSOME(line2, depth, \"%d/%d    \", node->wn_nr, node->wn_refs);\n\n    if (node->wn_sibling != NULL)\n      PRINTSOME(line3, depth, \" |    \", 0, 0);\n    else\n      PRINTSOME(line3, depth, \"      \", 0, 0);\n\n    if (node->wn_byte == NUL) {\n      msg((char_u *)line1);\n      msg((char_u *)line2);\n      msg((char_u *)line3);\n    }\n\n    // do the children\n    if (node->wn_byte != NUL && node->wn_child != NULL)\n      spell_print_node(node->wn_child, depth + 1);\n\n    // do the siblings\n    if (node->wn_sibling != NULL) {\n      // get rid of all parent details except |\n      STRCPY(line1, line3);\n      STRCPY(line2, line3);\n      spell_print_node(node->wn_sibling, depth);\n    }\n  }\n}\n\nstatic void spell_print_tree(wordnode_T *root)\n{\n  if (root != NULL) {\n    // Clear the \"wn_u1.index\" fields, used to remember what has been\n    // done.\n    spell_clear_flags(root);\n\n    // Recursively print the tree.\n    spell_print_node(root, 0);\n  }\n}\n\n#endif // SPELL_PRINTTREE\n\n// Reads the affix file \"fname\".\n// Returns an afffile_T, NULL for complete failure.\nstatic afffile_T *spell_read_aff(spellinfo_T *spin, char_u *fname)\n{\n  FILE        *fd;\n  char_u rline[MAXLINELEN];\n  char_u      *line;\n  char_u      *pc = NULL;\n#define MAXITEMCNT  30\n  char_u      *(items[MAXITEMCNT]);\n  int itemcnt;\n  char_u      *p;\n  int lnum = 0;\n  affheader_T *cur_aff = NULL;\n  bool did_postpone_prefix = false;\n  int aff_todo = 0;\n  hashtab_T   *tp;\n  char_u      *low = NULL;\n  char_u      *fol = NULL;\n  char_u      *upp = NULL;\n  int do_rep;\n  int do_repsal;\n  int do_sal;\n  int do_mapline;\n  bool found_map = false;\n  hashitem_T  *hi;\n  int l;\n  int compminlen = 0;                   // COMPOUNDMIN value\n  int compsylmax = 0;                   // COMPOUNDSYLMAX value\n  int compoptions = 0;                  // COMP_ flags\n  int compmax = 0;                      // COMPOUNDWORDMAX value\n  char_u      *compflags = NULL;        // COMPOUNDFLAG and COMPOUNDRULE\n                                        // concatenated\n  char_u      *midword = NULL;          // MIDWORD value\n  char_u      *syllable = NULL;         // SYLLABLE value\n  char_u      *sofofrom = NULL;         // SOFOFROM value\n  char_u      *sofoto = NULL;           // SOFOTO value\n\n  // Open the file.\n  fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return NULL;\n  }\n\n  vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading affix file %s...\"), fname);\n  spell_message(spin, IObuff);\n\n  // Only do REP lines when not done in another .aff file already.\n  do_rep = GA_EMPTY(&spin->si_rep);\n\n  // Only do REPSAL lines when not done in another .aff file already.\n  do_repsal = GA_EMPTY(&spin->si_repsal);\n\n  // Only do SAL lines when not done in another .aff file already.\n  do_sal = GA_EMPTY(&spin->si_sal);\n\n  // Only do MAP lines when not done in another .aff file already.\n  do_mapline = GA_EMPTY(&spin->si_map);\n\n  // Allocate and init the afffile_T structure.\n  afffile_T *aff = getroom(spin, sizeof(*aff), true);\n  hash_init(&aff->af_pref);\n  hash_init(&aff->af_suff);\n  hash_init(&aff->af_comp);\n\n  // Read all the lines in the file one by one.\n  while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int) {\n    line_breakcheck();\n    ++lnum;\n\n    // Skip comment lines.\n    if (*rline == '#')\n      continue;\n\n    // Convert from \"SET\" to 'encoding' when needed.\n    xfree(pc);\n    if (spin->si_conv.vc_type != CONV_NONE) {\n      pc = string_convert(&spin->si_conv, rline, NULL);\n      if (pc == NULL) {\n        smsg(_(\"Conversion failure for word in %s line %d: %s\"),\n             fname, lnum, rline);\n        continue;\n      }\n      line = pc;\n    } else {\n      pc = NULL;\n      line = rline;\n    }\n\n    // Split the line up in white separated items.  Put a NUL after each\n    // item.\n    itemcnt = 0;\n    for (p = line;; ) {\n      while (*p != NUL && *p <= ' ')        // skip white space and CR/NL\n        ++p;\n      if (*p == NUL)\n        break;\n      if (itemcnt == MAXITEMCNT)            // too many items\n        break;\n      items[itemcnt++] = p;\n      // A few items have arbitrary text argument, don't split them.\n      if (itemcnt == 2 && spell_info_item(items[0]))\n        while (*p >= ' ' || *p == TAB)            // skip until CR/NL\n          ++p;\n      else\n        while (*p > ' ')            // skip until white space or CR/NL\n          ++p;\n      if (*p == NUL)\n        break;\n      *p++ = NUL;\n    }\n\n    // Handle non-empty lines.\n    if (itemcnt > 0) {\n      if (is_aff_rule(items, itemcnt, \"SET\", 2) && aff->af_enc == NULL) {\n        // Setup for conversion from \"ENC\" to 'encoding'.\n        aff->af_enc = enc_canonize(items[1]);\n        if (!spin->si_ascii\n            && convert_setup(&spin->si_conv, aff->af_enc,\n                p_enc) == FAIL)\n          smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n               fname, aff->af_enc, p_enc);\n        spin->si_conv.vc_fail = true;\n      } else if (is_aff_rule(items, itemcnt, \"FLAG\", 2)\n                 && aff->af_flagtype == AFT_CHAR) {\n        if (STRCMP(items[1], \"long\") == 0)\n          aff->af_flagtype = AFT_LONG;\n        else if (STRCMP(items[1], \"num\") == 0)\n          aff->af_flagtype = AFT_NUM;\n        else if (STRCMP(items[1], \"caplong\") == 0)\n          aff->af_flagtype = AFT_CAPLONG;\n        else\n          smsg(_(\"Invalid value for FLAG in %s line %d: %s\"),\n               fname, lnum, items[1]);\n        if (aff->af_rare != 0\n            || aff->af_keepcase != 0\n            || aff->af_bad != 0\n            || aff->af_needaffix != 0\n            || aff->af_circumfix != 0\n            || aff->af_needcomp != 0\n            || aff->af_comproot != 0\n            || aff->af_nosuggest != 0\n            || compflags != NULL\n            || aff->af_suff.ht_used > 0\n            || aff->af_pref.ht_used > 0)\n          smsg(_(\"FLAG after using flags in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (spell_info_item(items[0]) && itemcnt > 1)   {\n        p = getroom(spin,\n                    (spin->si_info == NULL ? 0 : STRLEN(spin->si_info))\n                    + STRLEN(items[0])\n                    + STRLEN(items[1]) + 3, false);\n        if (spin->si_info != NULL) {\n          STRCPY(p, spin->si_info);\n          STRCAT(p, \"\\n\");\n        }\n        STRCAT(p, items[0]);\n        STRCAT(p, \" \");\n        STRCAT(p, items[1]);\n        spin->si_info = p;\n      } else if (is_aff_rule(items, itemcnt, \"MIDWORD\", 2)\n                 && midword == NULL) {\n        midword = getroom_save(spin, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"TRY\", 2))   {\n        // ignored, we look in the tree for what chars may appear\n      }\n      // TODO: remove \"RAR\" later\n      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)\n                || is_aff_rule(items, itemcnt, \"RARE\", 2))\n               && aff->af_rare == 0) {\n        aff->af_rare = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      }\n      // TODO: remove \"KEP\" later\n      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)\n                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))\n               && aff->af_keepcase == 0) {\n        aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if ((is_aff_rule(items, itemcnt, \"BAD\", 2)\n                  || is_aff_rule(items, itemcnt, \"FORBIDDENWORD\", 2))\n                 && aff->af_bad == 0) {\n        aff->af_bad = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"NEEDAFFIX\", 2)\n                 && aff->af_needaffix == 0) {\n        aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"CIRCUMFIX\", 2)\n                 && aff->af_circumfix == 0) {\n        aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"NOSUGGEST\", 2)\n                 && aff->af_nosuggest == 0) {\n        aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if ((is_aff_rule(items, itemcnt, \"NEEDCOMPOUND\", 2)\n                  || is_aff_rule(items, itemcnt, \"ONLYINCOMPOUND\", 2))\n                 && aff->af_needcomp == 0) {\n        aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDROOT\", 2)\n                 && aff->af_comproot == 0) {\n        aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDFORBIDFLAG\", 2)\n                 && aff->af_compforbid == 0) {\n        aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n        if (aff->af_pref.ht_used > 0)\n          smsg(_(\"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d\"),\n               fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDPERMITFLAG\", 2)\n                 && aff->af_comppermit == 0) {\n        aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],\n            fname, lnum);\n        if (aff->af_pref.ht_used > 0)\n          smsg(_(\"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d\"),\n               fname, lnum);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDFLAG\", 2)\n                 && compflags == NULL) {\n        // Turn flag \"c\" into COMPOUNDRULE compatible string \"c+\",\n        // \"Na\" into \"Na+\", \"1234\" into \"1234+\".\n        p = getroom(spin, STRLEN(items[1]) + 2, false);\n        STRCPY(p, items[1]);\n        STRCAT(p, \"+\");\n        compflags = p;\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULES\", 2))   {\n        // We don't use the count, but do check that it's a number and\n        // not COMPOUNDRULE mistyped.\n        if (atoi((char *)items[1]) == 0)\n          smsg(_(\"Wrong COMPOUNDRULES value in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDRULE\", 2))   {\n        // Don't use the first rule if it is a number.\n        if (compflags != NULL || *skipdigits(items[1]) != NUL) {\n          // Concatenate this string to previously defined ones,\n          // using a slash to separate them.\n          l = (int)STRLEN(items[1]) + 1;\n          if (compflags != NULL)\n            l += (int)STRLEN(compflags) + 1;\n          p = getroom(spin, l, false);\n          if (compflags != NULL) {\n            STRCPY(p, compflags);\n            STRCAT(p, \"/\");\n          }\n          STRCAT(p, items[1]);\n          compflags = p;\n        }\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDWORDMAX\", 2)\n                 && compmax == 0) {\n        compmax = atoi((char *)items[1]);\n        if (compmax == 0)\n          smsg(_(\"Wrong COMPOUNDWORDMAX value in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDMIN\", 2)\n                 && compminlen == 0) {\n        compminlen = atoi((char *)items[1]);\n        if (compminlen == 0)\n          smsg(_(\"Wrong COMPOUNDMIN value in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"COMPOUNDSYLMAX\", 2)\n                 && compsylmax == 0) {\n        compsylmax = atoi((char *)items[1]);\n        if (compsylmax == 0)\n          smsg(_(\"Wrong COMPOUNDSYLMAX value in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDDUP\", 1))   {\n        compoptions |= COMP_CHECKDUP;\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDREP\", 1))   {\n        compoptions |= COMP_CHECKREP;\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDCASE\", 1))   {\n        compoptions |= COMP_CHECKCASE;\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDTRIPLE\", 1))   {\n        compoptions |= COMP_CHECKTRIPLE;\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 2))   {\n        if (atoi((char *)items[1]) == 0)\n          smsg(_(\"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s\"),\n               fname, lnum, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"CHECKCOMPOUNDPATTERN\", 3))   {\n        garray_T    *gap = &spin->si_comppat;\n        int i;\n\n        // Only add the couple if it isn't already there.\n        for (i = 0; i < gap->ga_len - 1; i += 2)\n          if (STRCMP(((char_u **)(gap->ga_data))[i], items[1]) == 0\n              && STRCMP(((char_u **)(gap->ga_data))[i + 1],\n                  items[2]) == 0)\n            break;\n        if (i >= gap->ga_len) {\n          ga_grow(gap, 2);\n          ((char_u **)(gap->ga_data))[gap->ga_len++]\n            = getroom_save(spin, items[1]);\n          ((char_u **)(gap->ga_data))[gap->ga_len++]\n            = getroom_save(spin, items[2]);\n        }\n      } else if (is_aff_rule(items, itemcnt, \"SYLLABLE\", 2)\n                 && syllable == NULL) {\n        syllable = getroom_save(spin, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"NOBREAK\", 1))   {\n        spin->si_nobreak = true;\n      } else if (is_aff_rule(items, itemcnt, \"NOSPLITSUGS\", 1))   {\n        spin->si_nosplitsugs = true;\n      } else if (is_aff_rule(items, itemcnt, \"NOCOMPOUNDSUGS\", 1)) {\n        spin->si_nocompoundsugs = true;\n      } else if (is_aff_rule(items, itemcnt, \"NOSUGFILE\", 1))   {\n        spin->si_nosugfile = true;\n      } else if (is_aff_rule(items, itemcnt, \"PFXPOSTPONE\", 1))   {\n        aff->af_pfxpostpone = true;\n      } else if (is_aff_rule(items, itemcnt, \"IGNOREEXTRA\", 1)) {\n        aff->af_ignoreextra = true;\n      } else if ((STRCMP(items[0], \"PFX\") == 0\n                  || STRCMP(items[0], \"SFX\") == 0)\n                 && aff_todo == 0\n                 && itemcnt >= 4) {\n        int lasti = 4;\n        char_u key[AH_KEY_LEN];\n\n        if (*items[0] == 'P')\n          tp = &aff->af_pref;\n        else\n          tp = &aff->af_suff;\n\n        // Myspell allows the same affix name to be used multiple\n        // times.  The affix files that do this have an undocumented\n        // \"S\" flag on all but the last block, thus we check for that\n        // and store it in ah_follows.\n        STRLCPY(key, items[1], AH_KEY_LEN);\n        hi = hash_find(tp, key);\n        if (!HASHITEM_EMPTY(hi)) {\n          cur_aff = HI2AH(hi);\n          if (cur_aff->ah_combine != (*items[2] == 'Y'))\n            smsg(_(\"Different combining flag in continued affix block in %s line %d: %s\"),\n                 fname, lnum, items[1]);\n          if (!cur_aff->ah_follows)\n            smsg(_(\"Duplicate affix in %s line %d: %s\"),\n                 fname, lnum, items[1]);\n        } else {\n          // New affix letter.\n          cur_aff = getroom(spin, sizeof(*cur_aff), true);\n          cur_aff->ah_flag = affitem2flag(aff->af_flagtype, items[1],\n                                          fname, lnum);\n          if (cur_aff->ah_flag == 0 || STRLEN(items[1]) >= AH_KEY_LEN) {\n            break;\n          }\n          if (cur_aff->ah_flag == aff->af_bad\n              || cur_aff->ah_flag == aff->af_rare\n              || cur_aff->ah_flag == aff->af_keepcase\n              || cur_aff->ah_flag == aff->af_needaffix\n              || cur_aff->ah_flag == aff->af_circumfix\n              || cur_aff->ah_flag == aff->af_nosuggest\n              || cur_aff->ah_flag == aff->af_needcomp\n              || cur_aff->ah_flag == aff->af_comproot) {\n            smsg(_(\"Affix also used for \"\n                   \"BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST\"\n                   \"in %s line %d: %s\"),\n                 fname, lnum, items[1]);\n          }\n          STRCPY(cur_aff->ah_key, items[1]);\n          hash_add(tp, cur_aff->ah_key);\n\n          cur_aff->ah_combine = (*items[2] == 'Y');\n        }\n\n        // Check for the \"S\" flag, which apparently means that another\n        // block with the same affix name is following.\n        if (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0) {\n          ++lasti;\n          cur_aff->ah_follows = true;\n        } else\n          cur_aff->ah_follows = false;\n\n        // Myspell allows extra text after the item, but that might\n        // mean mistakes go unnoticed.  Require a comment-starter,\n        // unless IGNOREEXTRA is used.  Hunspell uses a \"-\" item.\n        if (itemcnt > lasti\n            && !aff->af_ignoreextra\n            && *items[lasti] != '#')\n          smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n        if (STRCMP(items[2], \"Y\") != 0 && STRCMP(items[2], \"N\") != 0)\n          smsg(_(\"Expected Y or N in %s line %d: %s\"),\n              fname, lnum, items[2]);\n\n        if (*items[0] == 'P' && aff->af_pfxpostpone) {\n          if (cur_aff->ah_newID == 0) {\n            // Use a new number in the .spl file later, to be able\n            // to handle multiple .aff files.\n            check_renumber(spin);\n            cur_aff->ah_newID = ++spin->si_newprefID;\n\n            // We only really use ah_newID if the prefix is\n            // postponed.  We know that only after handling all\n            // the items.\n            did_postpone_prefix = false;\n          } else\n            // Did use the ID in a previous block.\n            did_postpone_prefix = true;\n        }\n\n        aff_todo = atoi((char *)items[3]);\n      } else if ((STRCMP(items[0], \"PFX\") == 0\n                  || STRCMP(items[0], \"SFX\") == 0)\n                 && aff_todo > 0\n                 && STRCMP(cur_aff->ah_key, items[1]) == 0\n                 && itemcnt >= 5) {\n        affentry_T      *aff_entry;\n        bool upper = false;\n        int lasti = 5;\n\n        // Myspell allows extra text after the item, but that might\n        // mean mistakes go unnoticed.  Require a comment-starter.\n        // Hunspell uses a \"-\" item.\n        if (itemcnt > lasti && *items[lasti] != '#'\n            && (STRCMP(items[lasti], \"-\") != 0\n                || itemcnt != lasti + 1))\n          smsg(_(e_afftrailing), fname, lnum, items[lasti]);\n\n        // New item for an affix letter.\n        aff_todo--;\n        aff_entry = getroom(spin, sizeof(*aff_entry), true);\n\n        if (STRCMP(items[2], \"0\") != 0)\n          aff_entry->ae_chop = getroom_save(spin, items[2]);\n        if (STRCMP(items[3], \"0\") != 0) {\n          aff_entry->ae_add = getroom_save(spin, items[3]);\n\n          // Recognize flags on the affix: abcd/XYZ\n          aff_entry->ae_flags = vim_strchr(aff_entry->ae_add, '/');\n          if (aff_entry->ae_flags != NULL) {\n            *aff_entry->ae_flags++ = NUL;\n            aff_process_flags(aff, aff_entry);\n          }\n        }\n\n        // Don't use an affix entry with non-ASCII characters when\n        // \"spin->si_ascii\" is true.\n        if (!spin->si_ascii || !(has_non_ascii(aff_entry->ae_chop)\n                                 || has_non_ascii(aff_entry->ae_add))) {\n          aff_entry->ae_next = cur_aff->ah_first;\n          cur_aff->ah_first = aff_entry;\n\n          if (STRCMP(items[4], \".\") != 0) {\n            char_u buf[MAXLINELEN];\n\n            aff_entry->ae_cond = getroom_save(spin, items[4]);\n            if (*items[0] == 'P')\n              sprintf((char *)buf, \"^%s\", items[4]);\n            else\n              sprintf((char *)buf, \"%s$\", items[4]);\n            aff_entry->ae_prog = vim_regcomp(buf,\n                RE_MAGIC + RE_STRING + RE_STRICT);\n            if (aff_entry->ae_prog == NULL)\n              smsg(_(\"Broken condition in %s line %d: %s\"),\n                   fname, lnum, items[4]);\n          }\n\n          // For postponed prefixes we need an entry in si_prefcond\n          // for the condition.  Use an existing one if possible.\n          // Can't be done for an affix with flags, ignoring\n          // COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG.\n          if (*items[0] == 'P' && aff->af_pfxpostpone\n              && aff_entry->ae_flags == NULL) {\n            // When the chop string is one lower-case letter and\n            // the add string ends in the upper-case letter we set\n            // the \"upper\" flag, clear \"ae_chop\" and remove the\n            // letters from \"ae_add\".  The condition must either\n            // be empty or start with the same letter.\n            if (aff_entry->ae_chop != NULL\n                && aff_entry->ae_add != NULL\n                && aff_entry->ae_chop[(*mb_ptr2len)(\n                                        aff_entry->ae_chop)] == NUL\n                ) {\n              int c, c_up;\n\n              c = PTR2CHAR(aff_entry->ae_chop);\n              c_up = SPELL_TOUPPER(c);\n              if (c_up != c\n                  && (aff_entry->ae_cond == NULL\n                      || PTR2CHAR(aff_entry->ae_cond) == c)) {\n                p = aff_entry->ae_add\n                    + STRLEN(aff_entry->ae_add);\n                MB_PTR_BACK(aff_entry->ae_add, p);\n                if (PTR2CHAR(p) == c_up) {\n                  upper = true;\n                  aff_entry->ae_chop = NULL;\n                  *p = NUL;\n\n                  // The condition is matched with the\n                  // actual word, thus must check for the\n                  // upper-case letter.\n                  if (aff_entry->ae_cond != NULL) {\n                    char_u buf[MAXLINELEN];\n                    onecap_copy(items[4], buf, true);\n                    aff_entry->ae_cond = getroom_save(spin, buf);\n                    if (aff_entry->ae_cond != NULL) {\n                      sprintf((char *)buf, \"^%s\",\n                          aff_entry->ae_cond);\n                      vim_regfree(aff_entry->ae_prog);\n                      aff_entry->ae_prog = vim_regcomp(\n                          buf, RE_MAGIC + RE_STRING);\n                    }\n                  }\n                }\n              }\n            }\n\n            if (aff_entry->ae_chop == NULL) {\n              int idx;\n              char_u      **pp;\n              int n;\n\n              // Find a previously used condition.\n              for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;\n                   --idx) {\n                p = ((char_u **)spin->si_prefcond.ga_data)[idx];\n                if (str_equal(p, aff_entry->ae_cond))\n                  break;\n              }\n              if (idx < 0) {\n                // Not found, add a new condition.\n                idx = spin->si_prefcond.ga_len;\n                pp = GA_APPEND_VIA_PTR(char_u *, &spin->si_prefcond);\n                *pp = (aff_entry->ae_cond == NULL) ?\n                  NULL : getroom_save(spin, aff_entry->ae_cond);\n              }\n\n              // Add the prefix to the prefix tree.\n              if (aff_entry->ae_add == NULL)\n                p = (char_u *)\"\";\n              else\n                p = aff_entry->ae_add;\n\n              // PFX_FLAGS is a negative number, so that\n              // tree_add_word() knows this is the prefix tree.\n              n = PFX_FLAGS;\n              if (!cur_aff->ah_combine)\n                n |= WFP_NC;\n              if (upper)\n                n |= WFP_UP;\n              if (aff_entry->ae_comppermit)\n                n |= WFP_COMPPERMIT;\n              if (aff_entry->ae_compforbid)\n                n |= WFP_COMPFORBID;\n              tree_add_word(spin, p, spin->si_prefroot, n,\n                  idx, cur_aff->ah_newID);\n              did_postpone_prefix = true;\n            }\n\n            // Didn't actually use ah_newID, backup si_newprefID.\n            if (aff_todo == 0 && !did_postpone_prefix) {\n              --spin->si_newprefID;\n              cur_aff->ah_newID = 0;\n            }\n          }\n        }\n      } else if (is_aff_rule(items, itemcnt, \"FOL\", 2) && fol == NULL)   {\n        fol = vim_strsave(items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"LOW\", 2) && low == NULL)   {\n        low = vim_strsave(items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"UPP\", 2) && upp == NULL)   {\n        upp = vim_strsave(items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"REP\", 2)\n                 || is_aff_rule(items, itemcnt, \"REPSAL\", 2)) {\n        /* Ignore REP/REPSAL count */;\n        if (!isdigit(*items[1]))\n          smsg(_(\"Expected REP(SAL) count in %s line %d\"),\n               fname, lnum);\n      } else if ((STRCMP(items[0], \"REP\") == 0\n                  || STRCMP(items[0], \"REPSAL\") == 0)\n                 && itemcnt >= 3) {\n        // REP/REPSAL item\n        // Myspell ignores extra arguments, we require it starts with\n        // # to detect mistakes.\n        if (itemcnt > 3 && items[3][0] != '#')\n          smsg(_(e_afftrailing), fname, lnum, items[3]);\n        if (items[0][3] == 'S' ? do_repsal : do_rep) {\n          // Replace underscore with space (can't include a space\n          // directly).\n          for (p = items[1]; *p != NUL; MB_PTR_ADV(p)) {\n            if (*p == '_') {\n              *p = ' ';\n            }\n          }\n          for (p = items[2]; *p != NUL; MB_PTR_ADV(p)) {\n            if (*p == '_') {\n              *p = ' ';\n            }\n          }\n          add_fromto(spin, items[0][3] == 'S'\n              ? &spin->si_repsal\n              : &spin->si_rep, items[1], items[2]);\n        }\n      } else if (is_aff_rule(items, itemcnt, \"MAP\", 2))   {\n        // MAP item or count\n        if (!found_map) {\n          // First line contains the count.\n          found_map = true;\n          if (!isdigit(*items[1]))\n            smsg(_(\"Expected MAP count in %s line %d\"),\n                 fname, lnum);\n        } else if (do_mapline)   {\n          int c;\n\n          // Check that every character appears only once.\n          for (p = items[1]; *p != NUL; ) {\n            c = mb_ptr2char_adv((const char_u **)&p);\n            if ((!GA_EMPTY(&spin->si_map)\n                 && vim_strchr(spin->si_map.ga_data, c)\n                 != NULL)\n                || vim_strchr(p, c) != NULL) {\n              smsg(_(\"Duplicate character in MAP in %s line %d\"),\n                   fname, lnum);\n            }\n          }\n\n          // We simply concatenate all the MAP strings, separated by\n          // slashes.\n          ga_concat(&spin->si_map, items[1]);\n          ga_append(&spin->si_map, '/');\n        }\n      }\n      // Accept \"SAL from to\" and \"SAL from to  #comment\".\n      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {\n        if (do_sal) {\n          // SAL item (sounds-a-like)\n          // Either one of the known keys or a from-to pair.\n          if (STRCMP(items[1], \"followup\") == 0)\n            spin->si_followup = sal_to_bool(items[2]);\n          else if (STRCMP(items[1], \"collapse_result\") == 0)\n            spin->si_collapse = sal_to_bool(items[2]);\n          else if (STRCMP(items[1], \"remove_accents\") == 0)\n            spin->si_rem_accents = sal_to_bool(items[2]);\n          else\n            // when \"to\" is \"_\" it means empty\n            add_fromto(spin, &spin->si_sal, items[1],\n                STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"\n                : items[2]);\n        }\n      } else if (is_aff_rule(items, itemcnt, \"SOFOFROM\", 2)\n                 && sofofrom == NULL) {\n        sofofrom = getroom_save(spin, items[1]);\n      } else if (is_aff_rule(items, itemcnt, \"SOFOTO\", 2)\n                 && sofoto == NULL) {\n        sofoto = getroom_save(spin, items[1]);\n      } else if (STRCMP(items[0], \"COMMON\") == 0)   {\n        int i;\n\n        for (i = 1; i < itemcnt; ++i) {\n          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,\n                      items[i]))) {\n            p = vim_strsave(items[i]);\n            hash_add(&spin->si_commonwords, p);\n          }\n        }\n      } else\n        smsg(_(\"Unrecognized or duplicate item in %s line %d: %s\"),\n             fname, lnum, items[0]);\n    }\n  }\n\n  if (fol != NULL || low != NULL || upp != NULL) {\n    if (spin->si_clear_chartab) {\n      // Clear the char type tables, don't want to use any of the\n      // currently used spell properties.\n      init_spell_chartab();\n      spin->si_clear_chartab = false;\n    }\n\n    xfree(fol);\n    xfree(low);\n    xfree(upp);\n  }\n\n  // Use compound specifications of the .aff file for the spell info.\n  if (compmax != 0) {\n    aff_check_number(spin->si_compmax, compmax, \"COMPOUNDWORDMAX\");\n    spin->si_compmax = compmax;\n  }\n\n  if (compminlen != 0) {\n    aff_check_number(spin->si_compminlen, compminlen, \"COMPOUNDMIN\");\n    spin->si_compminlen = compminlen;\n  }\n\n  if (compsylmax != 0) {\n    if (syllable == NULL) {\n      smsg(\"%s\", _(\"COMPOUNDSYLMAX used without SYLLABLE\"));\n    }\n    aff_check_number(spin->si_compsylmax, compsylmax, \"COMPOUNDSYLMAX\");\n    spin->si_compsylmax = compsylmax;\n  }\n\n  if (compoptions != 0) {\n    aff_check_number(spin->si_compoptions, compoptions, \"COMPOUND options\");\n    spin->si_compoptions |= compoptions;\n  }\n\n  if (compflags != NULL)\n    process_compflags(spin, aff, compflags);\n\n  // Check that we didn't use too many renumbered flags.\n  if (spin->si_newcompID < spin->si_newprefID) {\n    if (spin->si_newcompID == 127 || spin->si_newcompID == 255)\n      MSG(_(\"Too many postponed prefixes\"));\n    else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)\n      MSG(_(\"Too many compound flags\"));\n    else\n      MSG(_(\"Too many postponed prefixes and/or compound flags\"));\n  }\n\n  if (syllable != NULL) {\n    aff_check_string(spin->si_syllable, syllable, \"SYLLABLE\");\n    spin->si_syllable = syllable;\n  }\n\n  if (sofofrom != NULL || sofoto != NULL) {\n    if (sofofrom == NULL || sofoto == NULL)\n      smsg(_(\"Missing SOFO%s line in %s\"),\n           sofofrom == NULL ? \"FROM\" : \"TO\", fname);\n    else if (!GA_EMPTY(&spin->si_sal))\n      smsg(_(\"Both SAL and SOFO lines in %s\"), fname);\n    else {\n      aff_check_string(spin->si_sofofr, sofofrom, \"SOFOFROM\");\n      aff_check_string(spin->si_sofoto, sofoto, \"SOFOTO\");\n      spin->si_sofofr = sofofrom;\n      spin->si_sofoto = sofoto;\n    }\n  }\n\n  if (midword != NULL) {\n    aff_check_string(spin->si_midword, midword, \"MIDWORD\");\n    spin->si_midword = midword;\n  }\n\n  xfree(pc);\n  fclose(fd);\n  return aff;\n}\n\n// Returns true when items[0] equals \"rulename\", there are \"mincount\" items or\n// a comment is following after item \"mincount\".\nstatic bool is_aff_rule(char_u **items, int itemcnt, char *rulename, int mincount)\n{\n  return STRCMP(items[0], rulename) == 0\n         && (itemcnt == mincount\n             || (itemcnt > mincount && items[mincount][0] == '#'));\n}\n\n// For affix \"entry\" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from\n// ae_flags to ae_comppermit and ae_compforbid.\nstatic void aff_process_flags(afffile_T *affile, affentry_T *entry)\n{\n  char_u      *p;\n  char_u      *prevp;\n  unsigned flag;\n\n  if (entry->ae_flags != NULL\n      && (affile->af_compforbid != 0 || affile->af_comppermit != 0)) {\n    for (p = entry->ae_flags; *p != NUL; ) {\n      prevp = p;\n      flag = get_affitem(affile->af_flagtype, &p);\n      if (flag == affile->af_comppermit || flag == affile->af_compforbid) {\n        STRMOVE(prevp, p);\n        p = prevp;\n        if (flag == affile->af_comppermit)\n          entry->ae_comppermit = true;\n        else\n          entry->ae_compforbid = true;\n      }\n      if (affile->af_flagtype == AFT_NUM && *p == ',')\n        ++p;\n    }\n    if (*entry->ae_flags == NUL)\n      entry->ae_flags = NULL;           // nothing left\n  }\n}\n\n// Returns true if \"s\" is the name of an info item in the affix file.\nstatic bool spell_info_item(char_u *s)\n{\n  return STRCMP(s, \"NAME\") == 0\n         || STRCMP(s, \"HOME\") == 0\n         || STRCMP(s, \"VERSION\") == 0\n         || STRCMP(s, \"AUTHOR\") == 0\n         || STRCMP(s, \"EMAIL\") == 0\n         || STRCMP(s, \"COPYRIGHT\") == 0;\n}\n\n// Turn an affix flag name into a number, according to the FLAG type.\n// returns zero for failure.\nstatic unsigned affitem2flag(int flagtype, char_u *item, char_u *fname, int lnum)\n{\n  unsigned res;\n  char_u      *p = item;\n\n  res = get_affitem(flagtype, &p);\n  if (res == 0) {\n    if (flagtype == AFT_NUM)\n      smsg(_(\"Flag is not a number in %s line %d: %s\"),\n           fname, lnum, item);\n    else\n      smsg(_(\"Illegal flag in %s line %d: %s\"),\n           fname, lnum, item);\n  }\n  if (*p != NUL) {\n    smsg(_(e_affname), fname, lnum, item);\n    return 0;\n  }\n\n  return res;\n}\n\n// Get one affix name from \"*pp\" and advance the pointer.\n// Returns ZERO_FLAG for \"0\".\n// Returns zero for an error, still advances the pointer then.\nstatic unsigned get_affitem(int flagtype, char_u **pp)\n{\n  int res;\n\n  if (flagtype == AFT_NUM) {\n    if (!ascii_isdigit(**pp)) {\n      ++*pp;            // always advance, avoid getting stuck\n      return 0;\n    }\n    res = getdigits_int(pp, true, 0);\n    if (res == 0) {\n      res = ZERO_FLAG;\n    }\n  } else {\n    res = mb_ptr2char_adv((const char_u **)pp);\n    if (flagtype == AFT_LONG || (flagtype == AFT_CAPLONG\n                                 && res >= 'A' && res <= 'Z')) {\n      if (**pp == NUL)\n        return 0;\n      res = mb_ptr2char_adv((const char_u **)pp) + (res << 16);\n    }\n  }\n  return res;\n}\n\n// Process the \"compflags\" string used in an affix file and append it to\n// spin->si_compflags.\n// The processing involves changing the affix names to ID numbers, so that\n// they fit in one byte.\nstatic void process_compflags(spellinfo_T *spin, afffile_T *aff, char_u *compflags)\n{\n  char_u      *p;\n  char_u      *prevp;\n  unsigned flag;\n  compitem_T  *ci;\n  int id;\n  int len;\n  char_u      *tp;\n  char_u key[AH_KEY_LEN];\n  hashitem_T  *hi;\n\n  // Make room for the old and the new compflags, concatenated with a / in\n  // between.  Processing it makes it shorter, but we don't know by how\n  // much, thus allocate the maximum.\n  len = (int)STRLEN(compflags) + 1;\n  if (spin->si_compflags != NULL)\n    len += (int)STRLEN(spin->si_compflags) + 1;\n  p = getroom(spin, len, false);\n  if (spin->si_compflags != NULL) {\n    STRCPY(p, spin->si_compflags);\n    STRCAT(p, \"/\");\n  }\n  spin->si_compflags = p;\n  tp = p + STRLEN(p);\n\n  for (p = compflags; *p != NUL; ) {\n    if (vim_strchr((char_u *)\"/?*+[]\", *p) != NULL)\n      // Copy non-flag characters directly.\n      *tp++ = *p++;\n    else {\n      // First get the flag number, also checks validity.\n      prevp = p;\n      flag = get_affitem(aff->af_flagtype, &p);\n      if (flag != 0) {\n        // Find the flag in the hashtable.  If it was used before, use\n        // the existing ID.  Otherwise add a new entry.\n        STRLCPY(key, prevp, p - prevp + 1);\n        hi = hash_find(&aff->af_comp, key);\n        if (!HASHITEM_EMPTY(hi)) {\n          id = HI2CI(hi)->ci_newID;\n        } else {\n          ci = getroom(spin, sizeof(compitem_T), true);\n          STRCPY(ci->ci_key, key);\n          ci->ci_flag = flag;\n          // Avoid using a flag ID that has a special meaning in a\n          // regexp (also inside []).\n          do {\n            check_renumber(spin);\n            id = spin->si_newcompID--;\n          } while (vim_strchr((char_u *)\"/?*+[]\\\\-^\", id) != NULL);\n          ci->ci_newID = id;\n          hash_add(&aff->af_comp, ci->ci_key);\n        }\n        *tp++ = id;\n      }\n      if (aff->af_flagtype == AFT_NUM && *p == ',')\n        ++p;\n    }\n  }\n\n  *tp = NUL;\n}\n\n// Check that the new IDs for postponed affixes and compounding don't overrun\n// each other.  We have almost 255 available, but start at 0-127 to avoid\n// using two bytes for utf-8.  When the 0-127 range is used up go to 128-255.\n// When that is used up an error message is given.\nstatic void check_renumber(spellinfo_T *spin)\n{\n  if (spin->si_newprefID == spin->si_newcompID && spin->si_newcompID < 128) {\n    spin->si_newprefID = 127;\n    spin->si_newcompID = 255;\n  }\n}\n\n// Returns true if flag \"flag\" appears in affix list \"afflist\".\nstatic bool flag_in_afflist(int flagtype, char_u *afflist, unsigned flag)\n{\n  char_u      *p;\n  unsigned n;\n\n  switch (flagtype) {\n  case AFT_CHAR:\n    return vim_strchr(afflist, flag) != NULL;\n\n  case AFT_CAPLONG:\n  case AFT_LONG:\n    for (p = afflist; *p != NUL; ) {\n      n = mb_ptr2char_adv((const char_u **)&p);\n      if ((flagtype == AFT_LONG || (n >= 'A' && n <= 'Z'))\n          && *p != NUL) {\n        n = mb_ptr2char_adv((const char_u **)&p) + (n << 16);\n      }\n      if (n == flag) {\n        return true;\n      }\n    }\n    break;\n\n  case AFT_NUM:\n    for (p = afflist; *p != NUL; ) {\n      int digits = getdigits_int(&p, true, 0);\n      assert(digits >= 0);\n      n = (unsigned int)digits;\n      if (n == 0) {\n        n = ZERO_FLAG;\n      }\n      if (n == flag) {\n        return true;\n      }\n      if (*p != NUL) {          // skip over comma\n        p++;\n      }\n    }\n    break;\n  }\n  return false;\n}\n\n// Give a warning when \"spinval\" and \"affval\" numbers are set and not the same.\nstatic void aff_check_number(int spinval, int affval, char *name)\n{\n  if (spinval != 0 && spinval != affval)\n    smsg(_(\"%s value differs from what is used in another .aff file\"),\n         name);\n}\n\n// Give a warning when \"spinval\" and \"affval\" strings are set and not the same.\nstatic void aff_check_string(char_u *spinval, char_u *affval, char *name)\n{\n  if (spinval != NULL && STRCMP(spinval, affval) != 0)\n    smsg(_(\"%s value differs from what is used in another .aff file\"),\n         name);\n}\n\n// Returns true if strings \"s1\" and \"s2\" are equal.  Also consider both being\n// NULL as equal.\nstatic bool str_equal(char_u *s1, char_u *s2)\n{\n  if (s1 == NULL || s2 == NULL)\n    return s1 == s2;\n  return STRCMP(s1, s2) == 0;\n}\n\n// Add a from-to item to \"gap\".  Used for REP and SAL items.\n// They are stored case-folded.\nstatic void add_fromto(spellinfo_T *spin, garray_T *gap, char_u *from, char_u *to)\n{\n  char_u word[MAXWLEN];\n\n  fromto_T *ftp = GA_APPEND_VIA_PTR(fromto_T, gap);\n  (void)spell_casefold(curwin, from, (int)STRLEN(from), word, MAXWLEN);\n  ftp->ft_from = getroom_save(spin, word);\n  (void)spell_casefold(curwin, to, (int)STRLEN(to), word, MAXWLEN);\n  ftp->ft_to = getroom_save(spin, word);\n}\n\n// Converts a boolean argument in a SAL line to true or false;\nstatic bool sal_to_bool(char_u *s)\n{\n  return STRCMP(s, \"1\") == 0 || STRCMP(s, \"true\") == 0;\n}\n\n// Free the structure filled by spell_read_aff().\nstatic void spell_free_aff(afffile_T *aff)\n{\n  hashtab_T   *ht;\n  hashitem_T  *hi;\n  int todo;\n  affheader_T *ah;\n  affentry_T  *ae;\n\n  xfree(aff->af_enc);\n\n  // All this trouble to free the \"ae_prog\" items...\n  for (ht = &aff->af_pref;; ht = &aff->af_suff) {\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0; ++hi) {\n      if (!HASHITEM_EMPTY(hi)) {\n        --todo;\n        ah = HI2AH(hi);\n        for (ae = ah->ah_first; ae != NULL; ae = ae->ae_next)\n          vim_regfree(ae->ae_prog);\n      }\n    }\n    if (ht == &aff->af_suff)\n      break;\n  }\n\n  hash_clear(&aff->af_pref);\n  hash_clear(&aff->af_suff);\n  hash_clear(&aff->af_comp);\n}\n\n// Read dictionary file \"fname\".\n// Returns OK or FAIL;\nstatic int spell_read_dic(spellinfo_T *spin, char_u *fname, afffile_T *affile)\n{\n  hashtab_T ht;\n  char_u line[MAXLINELEN];\n  char_u      *p;\n  char_u      *afflist;\n  char_u store_afflist[MAXWLEN];\n  int pfxlen;\n  bool need_affix;\n  char_u      *dw;\n  char_u      *pc;\n  char_u      *w;\n  int l;\n  hash_T hash;\n  hashitem_T  *hi;\n  FILE        *fd;\n  int lnum = 1;\n  int non_ascii = 0;\n  int retval = OK;\n  char_u message[MAXLINELEN + MAXWLEN];\n  int flags;\n  int duplicate = 0;\n  Timestamp last_msg_time = 0;\n\n  // Open the file.\n  fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return FAIL;\n  }\n\n  // The hashtable is only used to detect duplicated words.\n  hash_init(&ht);\n\n  vim_snprintf((char *)IObuff, IOSIZE,\n               _(\"Reading dictionary file %s...\"), fname);\n  spell_message(spin, IObuff);\n\n  // start with a message for the first line\n  spin->si_msg_count = 999999;\n\n  // Read and ignore the first line: word count.\n  if (vim_fgets(line, MAXLINELEN, fd) || !ascii_isdigit(*skipwhite(line))) {\n    EMSG2(_(\"E760: No word count in %s\"), fname);\n  }\n\n  // Read all the lines in the file one by one.\n  // The words are converted to 'encoding' here, before being added to\n  // the hashtable.\n  while (!vim_fgets(line, MAXLINELEN, fd) && !got_int) {\n    line_breakcheck();\n    ++lnum;\n    if (line[0] == '#' || line[0] == '/')\n      continue;         // comment line\n\n    // Remove CR, LF and white space from the end.  White space halfway through\n    // the word is kept to allow multi-word terms like \"et al.\".\n    l = (int)STRLEN(line);\n    while (l > 0 && line[l - 1] <= ' ')\n      --l;\n    if (l == 0)\n      continue;         // empty line\n    line[l] = NUL;\n\n    // Convert from \"SET\" to 'encoding' when needed.\n    if (spin->si_conv.vc_type != CONV_NONE) {\n      pc = string_convert(&spin->si_conv, line, NULL);\n      if (pc == NULL) {\n        smsg(_(\"Conversion failure for word in %s line %d: %s\"),\n             fname, lnum, line);\n        continue;\n      }\n      w = pc;\n    } else {\n      pc = NULL;\n      w = line;\n    }\n\n    // Truncate the word at the \"/\", set \"afflist\" to what follows.\n    // Replace \"\\/\" by \"/\" and \"\\\\\" by \"\\\".\n    afflist = NULL;\n    for (p = w; *p != NUL; MB_PTR_ADV(p)) {\n      if (*p == '\\\\' && (p[1] == '\\\\' || p[1] == '/')) {\n        STRMOVE(p, p + 1);\n      } else if (*p == '/') {\n        *p = NUL;\n        afflist = p + 1;\n        break;\n      }\n    }\n\n    // Skip non-ASCII words when \"spin->si_ascii\" is true.\n    if (spin->si_ascii && has_non_ascii(w)) {\n      ++non_ascii;\n      xfree(pc);\n      continue;\n    }\n\n    // This takes time, print a message every 10000 words, but not more\n    // often than once per second.\n    if (spin->si_verbose && spin->si_msg_count > 10000) {\n      spin->si_msg_count = 0;\n      if (os_time() > last_msg_time) {\n        last_msg_time = os_time();\n        vim_snprintf((char *)message, sizeof(message),\n                     _(\"line %6d, word %6ld - %s\"),\n                     lnum, spin->si_foldwcount + spin->si_keepwcount, w);\n        msg_start();\n        msg_puts_long_attr(message, 0);\n        msg_clr_eos();\n        msg_didout = false;\n        msg_col = 0;\n        ui_flush();\n      }\n    }\n\n    // Store the word in the hashtable to be able to find duplicates.\n    dw = getroom_save(spin, w);\n    if (dw == NULL) {\n      retval = FAIL;\n      xfree(pc);\n      break;\n    }\n\n    hash = hash_hash(dw);\n    hi = hash_lookup(&ht, (const char *)dw, STRLEN(dw), hash);\n    if (!HASHITEM_EMPTY(hi)) {\n      if (p_verbose > 0)\n        smsg(_(\"Duplicate word in %s line %d: %s\"),\n             fname, lnum, dw);\n      else if (duplicate == 0)\n        smsg(_(\"First duplicate word in %s line %d: %s\"),\n             fname, lnum, dw);\n      ++duplicate;\n    } else\n      hash_add_item(&ht, hi, dw, hash);\n\n    flags = 0;\n    store_afflist[0] = NUL;\n    pfxlen = 0;\n    need_affix = false;\n    if (afflist != NULL) {\n      // Extract flags from the affix list.\n      flags |= get_affix_flags(affile, afflist);\n\n      if (affile->af_needaffix != 0 && flag_in_afflist(\n              affile->af_flagtype, afflist, affile->af_needaffix))\n        need_affix = true;\n\n      if (affile->af_pfxpostpone)\n        // Need to store the list of prefix IDs with the word.\n        pfxlen = get_pfxlist(affile, afflist, store_afflist);\n\n      if (spin->si_compflags != NULL)\n        // Need to store the list of compound flags with the word.\n        // Concatenate them to the list of prefix IDs.\n        get_compflags(affile, afflist, store_afflist + pfxlen);\n    }\n\n    // Add the word to the word tree(s).\n    if (store_word(spin, dw, flags, spin->si_region,\n            store_afflist, need_affix) == FAIL)\n      retval = FAIL;\n\n    if (afflist != NULL) {\n      // Find all matching suffixes and add the resulting words.\n      // Additionally do matching prefixes that combine.\n      if (store_aff_word(spin, dw, afflist, affile,\n              &affile->af_suff, &affile->af_pref,\n              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n        retval = FAIL;\n\n      // Find all matching prefixes and add the resulting words.\n      if (store_aff_word(spin, dw, afflist, affile,\n              &affile->af_pref, NULL,\n              CONDIT_SUF, flags, store_afflist, pfxlen) == FAIL)\n        retval = FAIL;\n    }\n\n    xfree(pc);\n  }\n\n  if (duplicate > 0)\n    smsg(_(\"%d duplicate word(s) in %s\"), duplicate, fname);\n  if (spin->si_ascii && non_ascii > 0)\n    smsg(_(\"Ignored %d word(s) with non-ASCII characters in %s\"),\n         non_ascii, fname);\n  hash_clear(&ht);\n\n  fclose(fd);\n  return retval;\n}\n\n// Check for affix flags in \"afflist\" that are turned into word flags.\n// Return WF_ flags.\nstatic int get_affix_flags(afffile_T *affile, char_u *afflist)\n{\n  int flags = 0;\n\n  if (affile->af_keepcase != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_keepcase))\n    flags |= WF_KEEPCAP | WF_FIXCAP;\n  if (affile->af_rare != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_rare))\n    flags |= WF_RARE;\n  if (affile->af_bad != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_bad))\n    flags |= WF_BANNED;\n  if (affile->af_needcomp != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_needcomp))\n    flags |= WF_NEEDCOMP;\n  if (affile->af_comproot != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_comproot))\n    flags |= WF_COMPROOT;\n  if (affile->af_nosuggest != 0 && flag_in_afflist(\n          affile->af_flagtype, afflist, affile->af_nosuggest))\n    flags |= WF_NOSUGGEST;\n  return flags;\n}\n\n// Get the list of prefix IDs from the affix list \"afflist\".\n// Used for PFXPOSTPONE.\n// Put the resulting flags in \"store_afflist[MAXWLEN]\" with a terminating NUL\n// and return the number of affixes.\nstatic int get_pfxlist(afffile_T *affile, char_u *afflist, char_u *store_afflist)\n{\n  char_u      *p;\n  char_u      *prevp;\n  int cnt = 0;\n  int id;\n  char_u key[AH_KEY_LEN];\n  hashitem_T  *hi;\n\n  for (p = afflist; *p != NUL; ) {\n    prevp = p;\n    if (get_affitem(affile->af_flagtype, &p) != 0) {\n      // A flag is a postponed prefix flag if it appears in \"af_pref\"\n      // and its ID is not zero.\n      STRLCPY(key, prevp, p - prevp + 1);\n      hi = hash_find(&affile->af_pref, key);\n      if (!HASHITEM_EMPTY(hi)) {\n        id = HI2AH(hi)->ah_newID;\n        if (id != 0)\n          store_afflist[cnt++] = id;\n      }\n    }\n    if (affile->af_flagtype == AFT_NUM && *p == ',')\n      ++p;\n  }\n\n  store_afflist[cnt] = NUL;\n  return cnt;\n}\n\n// Get the list of compound IDs from the affix list \"afflist\" that are used\n// for compound words.\n// Puts the flags in \"store_afflist[]\".\nstatic void get_compflags(afffile_T *affile, char_u *afflist, char_u *store_afflist)\n{\n  char_u      *p;\n  char_u      *prevp;\n  int cnt = 0;\n  char_u key[AH_KEY_LEN];\n  hashitem_T  *hi;\n\n  for (p = afflist; *p != NUL; ) {\n    prevp = p;\n    if (get_affitem(affile->af_flagtype, &p) != 0) {\n      // A flag is a compound flag if it appears in \"af_comp\".\n      STRLCPY(key, prevp, p - prevp + 1);\n      hi = hash_find(&affile->af_comp, key);\n      if (!HASHITEM_EMPTY(hi))\n        store_afflist[cnt++] = HI2CI(hi)->ci_newID;\n    }\n    if (affile->af_flagtype == AFT_NUM && *p == ',')\n      ++p;\n  }\n\n  store_afflist[cnt] = NUL;\n}\n\n// Apply affixes to a word and store the resulting words.\n// \"ht\" is the hashtable with affentry_T that need to be applied, either\n// prefixes or suffixes.\n// \"xht\", when not NULL, is the prefix hashtable, to be used additionally on\n// the resulting words for combining affixes.\n//\n// Returns FAIL when out of memory.\nstatic int\nstore_aff_word (\n    spellinfo_T *spin,         // spell info\n    char_u *word,              // basic word start\n    char_u *afflist,           // list of names of supported affixes\n    afffile_T *affile,\n    hashtab_T *ht,\n    hashtab_T *xht,\n    int condit,                // CONDIT_SUF et al.\n    int flags,                 // flags for the word\n    char_u *pfxlist,           // list of prefix IDs\n    int pfxlen                 // nr of flags in \"pfxlist\" for prefixes, rest\n                               // is compound flags\n)\n{\n  int todo;\n  hashitem_T  *hi;\n  affheader_T *ah;\n  affentry_T  *ae;\n  char_u newword[MAXWLEN];\n  int retval = OK;\n  int i, j;\n  char_u      *p;\n  int use_flags;\n  char_u      *use_pfxlist;\n  int use_pfxlen;\n  bool need_affix;\n  char_u store_afflist[MAXWLEN];\n  char_u pfx_pfxlist[MAXWLEN];\n  size_t wordlen = STRLEN(word);\n  int use_condit;\n\n  todo = (int)ht->ht_used;\n  for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi) {\n    if (!HASHITEM_EMPTY(hi)) {\n      --todo;\n      ah = HI2AH(hi);\n\n      // Check that the affix combines, if required, and that the word\n      // supports this affix.\n      if (((condit & CONDIT_COMB) == 0 || ah->ah_combine)\n          && flag_in_afflist(affile->af_flagtype, afflist,\n              ah->ah_flag)) {\n        // Loop over all affix entries with this name.\n        for (ae = ah->ah_first; ae != NULL; ae = ae->ae_next) {\n          // Check the condition.  It's not logical to match case\n          // here, but it is required for compatibility with\n          // Myspell.\n          // Another requirement from Myspell is that the chop\n          // string is shorter than the word itself.\n          // For prefixes, when \"PFXPOSTPONE\" was used, only do\n          // prefixes with a chop string and/or flags.\n          // When a previously added affix had CIRCUMFIX this one\n          // must have it too, if it had not then this one must not\n          // have one either.\n          if ((xht != NULL || !affile->af_pfxpostpone\n               || ae->ae_chop != NULL\n               || ae->ae_flags != NULL)\n              && (ae->ae_chop == NULL\n                  || STRLEN(ae->ae_chop) < wordlen)\n              && (ae->ae_prog == NULL\n                  || vim_regexec_prog(&ae->ae_prog, false, word, (colnr_T)0))\n              && (((condit & CONDIT_CFIX) == 0)\n                  == ((condit & CONDIT_AFF) == 0\n                      || ae->ae_flags == NULL\n                      || !flag_in_afflist(affile->af_flagtype,\n                          ae->ae_flags, affile->af_circumfix)))) {\n            // Match.  Remove the chop and add the affix.\n            if (xht == NULL) {\n              // prefix: chop/add at the start of the word\n              if (ae->ae_add == NULL) {\n                *newword = NUL;\n              } else {\n                STRLCPY(newword, ae->ae_add, MAXWLEN);\n              }\n              p = word;\n              if (ae->ae_chop != NULL) {\n                // Skip chop string.\n                i = mb_charlen(ae->ae_chop);\n                for (; i > 0; i--) {\n                  MB_PTR_ADV(p);\n                }\n              }\n              STRCAT(newword, p);\n            } else {\n              // suffix: chop/add at the end of the word\n              STRLCPY(newword, word, MAXWLEN);\n              if (ae->ae_chop != NULL) {\n                // Remove chop string.\n                p = newword + STRLEN(newword);\n                i = (int)MB_CHARLEN(ae->ae_chop);\n                for (; i > 0; i--) {\n                  MB_PTR_BACK(newword, p);\n                }\n                *p = NUL;\n              }\n              if (ae->ae_add != NULL)\n                STRCAT(newword, ae->ae_add);\n            }\n\n            use_flags = flags;\n            use_pfxlist = pfxlist;\n            use_pfxlen = pfxlen;\n            need_affix = false;\n            use_condit = condit | CONDIT_COMB | CONDIT_AFF;\n            if (ae->ae_flags != NULL) {\n              // Extract flags from the affix list.\n              use_flags |= get_affix_flags(affile, ae->ae_flags);\n\n              if (affile->af_needaffix != 0 && flag_in_afflist(\n                      affile->af_flagtype, ae->ae_flags,\n                      affile->af_needaffix))\n                need_affix = true;\n\n              // When there is a CIRCUMFIX flag the other affix\n              // must also have it and we don't add the word\n              // with one affix.\n              if (affile->af_circumfix != 0 && flag_in_afflist(\n                      affile->af_flagtype, ae->ae_flags,\n                      affile->af_circumfix)) {\n                use_condit |= CONDIT_CFIX;\n                if ((condit & CONDIT_CFIX) == 0)\n                  need_affix = true;\n              }\n\n              if (affile->af_pfxpostpone\n                  || spin->si_compflags != NULL) {\n                if (affile->af_pfxpostpone)\n                  // Get prefix IDS from the affix list.\n                  use_pfxlen = get_pfxlist(affile,\n                      ae->ae_flags, store_afflist);\n                else\n                  use_pfxlen = 0;\n                use_pfxlist = store_afflist;\n\n                // Combine the prefix IDs. Avoid adding the\n                // same ID twice.\n                for (i = 0; i < pfxlen; ++i) {\n                  for (j = 0; j < use_pfxlen; ++j)\n                    if (pfxlist[i] == use_pfxlist[j])\n                      break;\n                  if (j == use_pfxlen)\n                    use_pfxlist[use_pfxlen++] = pfxlist[i];\n                }\n\n                if (spin->si_compflags != NULL)\n                  // Get compound IDS from the affix list.\n                  get_compflags(affile, ae->ae_flags,\n                      use_pfxlist + use_pfxlen);\n                else\n                  use_pfxlist[use_pfxlen] = NUL;\n\n                // Combine the list of compound flags.\n                // Concatenate them to the prefix IDs list.\n                // Avoid adding the same ID twice.\n                for (i = pfxlen; pfxlist[i] != NUL; ++i) {\n                  for (j = use_pfxlen;\n                       use_pfxlist[j] != NUL; ++j)\n                    if (pfxlist[i] == use_pfxlist[j])\n                      break;\n                  if (use_pfxlist[j] == NUL) {\n                    use_pfxlist[j++] = pfxlist[i];\n                    use_pfxlist[j] = NUL;\n                  }\n                }\n              }\n            }\n\n            // Obey a \"COMPOUNDFORBIDFLAG\" of the affix: don't\n            // use the compound flags.\n            if (use_pfxlist != NULL && ae->ae_compforbid) {\n              STRLCPY(pfx_pfxlist, use_pfxlist, use_pfxlen + 1);\n              use_pfxlist = pfx_pfxlist;\n            }\n\n            // When there are postponed prefixes...\n            if (spin->si_prefroot != NULL\n                && spin->si_prefroot->wn_sibling != NULL) {\n              // ... add a flag to indicate an affix was used.\n              use_flags |= WF_HAS_AFF;\n\n              // ... don't use a prefix list if combining\n              // affixes is not allowed.  But do use the\n              // compound flags after them.\n              if (!ah->ah_combine && use_pfxlist != NULL)\n                use_pfxlist += use_pfxlen;\n            }\n\n            // When compounding is supported and there is no\n            // \"COMPOUNDPERMITFLAG\" then forbid compounding on the\n            // side where the affix is applied.\n            if (spin->si_compflags != NULL && !ae->ae_comppermit) {\n              if (xht != NULL)\n                use_flags |= WF_NOCOMPAFT;\n              else\n                use_flags |= WF_NOCOMPBEF;\n            }\n\n            // Store the modified word.\n            if (store_word(spin, newword, use_flags,\n                    spin->si_region, use_pfxlist,\n                    need_affix) == FAIL)\n              retval = FAIL;\n\n            // When added a prefix or a first suffix and the affix\n            // has flags may add a(nother) suffix.  RECURSIVE!\n            if ((condit & CONDIT_SUF) && ae->ae_flags != NULL)\n              if (store_aff_word(spin, newword, ae->ae_flags,\n                      affile, &affile->af_suff, xht,\n                      use_condit & (xht == NULL\n                                    ? ~0 :  ~CONDIT_SUF),\n                      use_flags, use_pfxlist, pfxlen) == FAIL)\n                retval = FAIL;\n\n            // When added a suffix and combining is allowed also\n            // try adding a prefix additionally.  Both for the\n            // word flags and for the affix flags.  RECURSIVE!\n            if (xht != NULL && ah->ah_combine) {\n              if (store_aff_word(spin, newword,\n                      afflist, affile,\n                      xht, NULL, use_condit,\n                      use_flags, use_pfxlist,\n                      pfxlen) == FAIL\n                  || (ae->ae_flags != NULL\n                      && store_aff_word(spin, newword,\n                          ae->ae_flags, affile,\n                          xht, NULL, use_condit,\n                          use_flags, use_pfxlist,\n                          pfxlen) == FAIL))\n                retval = FAIL;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return retval;\n}\n\n// Read a file with a list of words.\nstatic int spell_read_wordfile(spellinfo_T *spin, char_u *fname)\n{\n  FILE        *fd;\n  long lnum = 0;\n  char_u rline[MAXLINELEN];\n  char_u      *line;\n  char_u      *pc = NULL;\n  char_u      *p;\n  int l;\n  int retval = OK;\n  bool did_word = false;\n  int non_ascii = 0;\n  int flags;\n  int regionmask;\n\n  // Open the file.\n  fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return FAIL;\n  }\n\n  vim_snprintf((char *)IObuff, IOSIZE, _(\"Reading word file %s...\"), fname);\n  spell_message(spin, IObuff);\n\n  // Read all the lines in the file one by one.\n  while (!vim_fgets(rline, MAXLINELEN, fd) && !got_int) {\n    line_breakcheck();\n    ++lnum;\n\n    // Skip comment lines.\n    if (*rline == '#')\n      continue;\n\n    // Remove CR, LF and white space from the end.\n    l = (int)STRLEN(rline);\n    while (l > 0 && rline[l - 1] <= ' ')\n      --l;\n    if (l == 0)\n      continue;         // empty or blank line\n    rline[l] = NUL;\n\n    // Convert from \"/encoding={encoding}\" to 'encoding' when needed.\n    xfree(pc);\n    if (spin->si_conv.vc_type != CONV_NONE) {\n      pc = string_convert(&spin->si_conv, rline, NULL);\n      if (pc == NULL) {\n        smsg(_(\"Conversion failure for word in %s line %ld: %s\"),\n             fname, lnum, rline);\n        continue;\n      }\n      line = pc;\n    } else {\n      pc = NULL;\n      line = rline;\n    }\n\n    if (*line == '/') {\n      ++line;\n      if (STRNCMP(line, \"encoding=\", 9) == 0) {\n        if (spin->si_conv.vc_type != CONV_NONE) {\n          smsg(_(\"Duplicate /encoding= line ignored in %s line %ld: %s\"),\n               fname, lnum, line - 1);\n        } else if (did_word) {\n          smsg(_(\"/encoding= line after word ignored in %s line %ld: %s\"),\n               fname, lnum, line - 1);\n        } else {\n          char_u      *enc;\n\n          // Setup for conversion to 'encoding'.\n          line += 9;\n          enc = enc_canonize(line);\n          if (!spin->si_ascii\n              && convert_setup(&spin->si_conv, enc,\n                  p_enc) == FAIL)\n            smsg(_(\"Conversion in %s not supported: from %s to %s\"),\n                 fname, line, p_enc);\n          xfree(enc);\n          spin->si_conv.vc_fail = true;\n        }\n        continue;\n      }\n\n      if (STRNCMP(line, \"regions=\", 8) == 0) {\n        if (spin->si_region_count > 1) {\n          smsg(_(\"Duplicate /regions= line ignored in %s line %ld: %s\"),\n               fname, lnum, line);\n        } else {\n          line += 8;\n          if (STRLEN(line) > MAXREGIONS * 2) {\n            smsg(_(\"Too many regions in %s line %ld: %s\"),\n                 fname, lnum, line);\n          } else {\n            spin->si_region_count = (int)STRLEN(line) / 2;\n            STRCPY(spin->si_region_name, line);\n\n            // Adjust the mask for a word valid in all regions.\n            spin->si_region = (1 << spin->si_region_count) - 1;\n          }\n        }\n        continue;\n      }\n\n      smsg(_(\"/ line ignored in %s line %ld: %s\"),\n           fname, lnum, line - 1);\n      continue;\n    }\n\n    flags = 0;\n    regionmask = spin->si_region;\n\n    // Check for flags and region after a slash.\n    p = vim_strchr(line, '/');\n    if (p != NULL) {\n      *p++ = NUL;\n      while (*p != NUL) {\n        if (*p == '=')                  // keep-case word\n          flags |= WF_KEEPCAP | WF_FIXCAP;\n        else if (*p == '!')             // Bad, bad, wicked word.\n          flags |= WF_BANNED;\n        else if (*p == '?')             // Rare word.\n          flags |= WF_RARE;\n        else if (ascii_isdigit(*p)) {       // region number(s)\n          if ((flags & WF_REGION) == 0)             // first one\n            regionmask = 0;\n          flags |= WF_REGION;\n\n          l = *p - '0';\n          if (l == 0 || l > spin->si_region_count) {\n            smsg(_(\"Invalid region nr in %s line %ld: %s\"),\n                 fname, lnum, p);\n            break;\n          }\n          regionmask |= 1 << (l - 1);\n        } else {\n          smsg(_(\"Unrecognized flags in %s line %ld: %s\"),\n               fname, lnum, p);\n          break;\n        }\n        ++p;\n      }\n    }\n\n    // Skip non-ASCII words when \"spin->si_ascii\" is true.\n    if (spin->si_ascii && has_non_ascii(line)) {\n      ++non_ascii;\n      continue;\n    }\n\n    // Normal word: store it.\n    if (store_word(spin, line, flags, regionmask, NULL, false) == FAIL) {\n      retval = FAIL;\n      break;\n    }\n    did_word = true;\n  }\n\n  xfree(pc);\n  fclose(fd);\n\n  if (spin->si_ascii && non_ascii > 0) {\n    vim_snprintf((char *)IObuff, IOSIZE,\n        _(\"Ignored %d words with non-ASCII characters\"), non_ascii);\n    spell_message(spin, IObuff);\n  }\n\n  return retval;\n}\n\n/// Get part of an sblock_T, \"len\" bytes long.\n/// This avoids calling free() for every little struct we use (and keeping\n/// track of them).\n/// The memory is cleared to all zeros.\n///\n/// @param len Length needed (<= SBLOCKSIZE).\n/// @param align Align for pointer.\n/// @return Pointer into block data.\nstatic void *getroom(spellinfo_T *spin, size_t len, bool align)\n  FUNC_ATTR_NONNULL_RET\n{\n  char_u      *p;\n  sblock_T    *bl = spin->si_blocks;\n\n  assert(len <= SBLOCKSIZE);\n  \n  if (align && bl != NULL)\n    // Round size up for alignment.  On some systems structures need to be\n    // aligned to the size of a pointer (e.g., SPARC).\n    bl->sb_used = (bl->sb_used + sizeof(char *) - 1)\n                  & ~(sizeof(char *) - 1);\n\n  if (bl == NULL || bl->sb_used + len > SBLOCKSIZE) {\n    // Allocate a block of memory. It is not freed until much later.\n    bl = xcalloc(1, (sizeof(sblock_T) + SBLOCKSIZE));\n    bl->sb_next = spin->si_blocks;\n    spin->si_blocks = bl;\n    bl->sb_used = 0;\n    ++spin->si_blocks_cnt;\n  }\n\n  p = bl->sb_data + bl->sb_used;\n  bl->sb_used += (int)len;\n\n  return p;\n}\n\n// Make a copy of a string into memory allocated with getroom().\n// Returns NULL when out of memory.\nstatic char_u *getroom_save(spellinfo_T *spin, char_u *s)\n{\n  const size_t s_size = STRLEN(s) + 1;\n  return memcpy(getroom(spin, s_size, false), s, s_size);\n}\n\n\n// Free the list of allocated sblock_T.\nstatic void free_blocks(sblock_T *bl)\n{\n  sblock_T    *next;\n\n  while (bl != NULL) {\n    next = bl->sb_next;\n    xfree(bl);\n    bl = next;\n  }\n}\n\n// Allocate the root of a word tree.\n// Returns NULL when out of memory.\nstatic wordnode_T *wordtree_alloc(spellinfo_T *spin)\n  FUNC_ATTR_NONNULL_RET\n{\n  return (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);\n}\n\n// Store a word in the tree(s).\n// Always store it in the case-folded tree.  For a keep-case word this is\n// useful when the word can also be used with all caps (no WF_FIXCAP flag) and\n// used to find suggestions.\n// For a keep-case word also store it in the keep-case tree.\n// When \"pfxlist\" is not NULL store the word for each postponed prefix ID and\n// compound flag.\nstatic int\nstore_word (\n    spellinfo_T *spin,\n    char_u *word,\n    int flags,                      // extra flags, WF_BANNED\n    int region,                     // supported region(s)\n    const char_u *pfxlist,          // list of prefix IDs or NULL\n    bool need_affix                 // only store word with affix ID\n)\n{\n  int len = (int)STRLEN(word);\n  int ct = captype(word, word + len);\n  char_u foldword[MAXWLEN];\n  int res = OK;\n\n  (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n  for (const char_u *p = pfxlist; res == OK; p++) {\n    if (!need_affix || (p != NULL && *p != NUL)) {\n      res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n                          region, p == NULL ? 0 : *p);\n    }\n    if (p == NULL || *p == NUL) {\n      break;\n    }\n  }\n  ++spin->si_foldwcount;\n\n  if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP))) {\n    for (const char_u *p = pfxlist; res == OK; p++) {\n      if (!need_affix || (p != NULL && *p != NUL)) {\n        res = tree_add_word(spin, word, spin->si_keeproot, flags,\n                            region, p == NULL ? 0 : *p);\n      }\n      if (p == NULL || *p == NUL) {\n        break;\n      }\n    }\n    ++spin->si_keepwcount;\n  }\n  return res;\n}\n\n// Add word \"word\" to a word tree at \"root\".\n// When \"flags\" < 0 we are adding to the prefix tree where \"flags\" is used for\n// \"rare\" and \"region\" is the condition nr.\n// Returns FAIL when out of memory.\nstatic int tree_add_word(spellinfo_T *spin, char_u *word, wordnode_T *root, int flags, int region, int affixID)\n{\n  wordnode_T  *node = root;\n  wordnode_T  *np;\n  wordnode_T  *copyp, **copyprev;\n  wordnode_T  **prev = NULL;\n  int i;\n\n  // Add each byte of the word to the tree, including the NUL at the end.\n  for (i = 0;; ++i) {\n    // When there is more than one reference to this node we need to make\n    // a copy, so that we can modify it.  Copy the whole list of siblings\n    // (we don't optimize for a partly shared list of siblings).\n    if (node != NULL && node->wn_refs > 1) {\n      --node->wn_refs;\n      copyprev = prev;\n      for (copyp = node; copyp != NULL; copyp = copyp->wn_sibling) {\n        // Allocate a new node and copy the info.\n        np = get_wordnode(spin);\n        if (np == NULL)\n          return FAIL;\n        np->wn_child = copyp->wn_child;\n        if (np->wn_child != NULL)\n          ++np->wn_child->wn_refs;              // child gets extra ref\n        np->wn_byte = copyp->wn_byte;\n        if (np->wn_byte == NUL) {\n          np->wn_flags = copyp->wn_flags;\n          np->wn_region = copyp->wn_region;\n          np->wn_affixID = copyp->wn_affixID;\n        }\n\n        // Link the new node in the list, there will be one ref.\n        np->wn_refs = 1;\n        if (copyprev != NULL)\n          *copyprev = np;\n        copyprev = &np->wn_sibling;\n\n        // Let \"node\" point to the head of the copied list.\n        if (copyp == node)\n          node = np;\n      }\n    }\n\n    // Look for the sibling that has the same character.  They are sorted\n    // on byte value, thus stop searching when a sibling is found with a\n    // higher byte value.  For zero bytes (end of word) the sorting is\n    // done on flags and then on affixID.\n    while (node != NULL\n           && (node->wn_byte < word[i]\n               || (node->wn_byte == NUL\n                   && (flags < 0\n                       ? node->wn_affixID < (unsigned)affixID\n                       : (node->wn_flags < (unsigned)(flags & WN_MASK)\n                          || (node->wn_flags == (flags & WN_MASK)\n                              && (spin->si_sugtree\n                                  ? (node->wn_region & 0xffff) < region\n                                  : node->wn_affixID\n                                  < (unsigned)affixID))))))) {\n      prev = &node->wn_sibling;\n      node = *prev;\n    }\n    if (node == NULL\n        || node->wn_byte != word[i]\n        || (word[i] == NUL\n            && (flags < 0\n                || spin->si_sugtree\n                || node->wn_flags != (flags & WN_MASK)\n                || node->wn_affixID != affixID))) {\n      // Allocate a new node.\n      np = get_wordnode(spin);\n      if (np == NULL)\n        return FAIL;\n      np->wn_byte = word[i];\n\n      // If \"node\" is NULL this is a new child or the end of the sibling\n      // list: ref count is one.  Otherwise use ref count of sibling and\n      // make ref count of sibling one (matters when inserting in front\n      // of the list of siblings).\n      if (node == NULL)\n        np->wn_refs = 1;\n      else {\n        np->wn_refs = node->wn_refs;\n        node->wn_refs = 1;\n      }\n      if (prev != NULL)\n        *prev = np;\n      np->wn_sibling = node;\n      node = np;\n    }\n\n    if (word[i] == NUL) {\n      node->wn_flags = flags;\n      node->wn_region |= region;\n      node->wn_affixID = affixID;\n      break;\n    }\n    prev = &node->wn_child;\n    node = *prev;\n  }\n#ifdef SPELL_PRINTTREE\n  smsg((char_u *)\"Added \\\"%s\\\"\", word);\n  spell_print_tree(root->wn_sibling);\n#endif\n\n  // count nr of words added since last message\n  ++spin->si_msg_count;\n\n  if (spin->si_compress_cnt > 1) {\n    if (--spin->si_compress_cnt == 1) {\n      // Did enough words to lower the block count limit.\n      spin->si_blocks_cnt += compress_inc;\n    }\n  }\n\n  // When we have allocated lots of memory we need to compress the word tree\n  // to free up some room.  But compression is slow, and we might actually\n  // need that room, thus only compress in the following situations:\n  // 1. When not compressed before (si_compress_cnt == 0): when using\n  //    \"compress_start\" blocks.\n  // 2. When compressed before and used \"compress_inc\" blocks before\n  //    adding \"compress_added\" words (si_compress_cnt > 1).\n  // 3. When compressed before, added \"compress_added\" words\n  //    (si_compress_cnt == 1) and the number of free nodes drops below the\n  //    maximum word length.\n#ifndef SPELL_COMPRESS_ALLWAYS\n  if (spin->si_compress_cnt == 1       // NOLINT(readability/braces)\n      ? spin->si_free_count < MAXWLEN\n                              : spin->si_blocks_cnt >= compress_start)\n#endif\n  {\n    // Decrement the block counter.  The effect is that we compress again\n    // when the freed up room has been used and another \"compress_inc\"\n    // blocks have been allocated.  Unless \"compress_added\" words have\n    // been added, then the limit is put back again.\n    spin->si_blocks_cnt -= compress_inc;\n    spin->si_compress_cnt = compress_added;\n\n    if (spin->si_verbose) {\n      msg_start();\n      msg_puts(_(msg_compressing));\n      msg_clr_eos();\n      msg_didout = false;\n      msg_col = 0;\n      ui_flush();\n    }\n\n    // Compress both trees.  Either they both have many nodes, which makes\n    // compression useful, or one of them is small, which means\n    // compression goes fast.  But when filling the soundfold word tree\n    // there is no keep-case tree.\n    wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n    if (affixID >= 0) {\n      wordtree_compress(spin, spin->si_keeproot, \"keep-case\");\n    }\n  }\n\n  return OK;\n}\n\n// Get a wordnode_T, either from the list of previously freed nodes or\n// allocate a new one.\n// Returns NULL when out of memory.\nstatic wordnode_T *get_wordnode(spellinfo_T *spin)\n{\n  wordnode_T *n;\n\n  if (spin->si_first_free == NULL)\n    n = (wordnode_T *)getroom(spin, sizeof(wordnode_T), true);\n  else {\n    n = spin->si_first_free;\n    spin->si_first_free = n->wn_child;\n    memset(n, 0, sizeof(wordnode_T));\n    --spin->si_free_count;\n  }\n#ifdef SPELL_PRINTTREE\n  if (n != NULL)\n    n->wn_nr = ++spin->si_wordnode_nr;\n#endif\n  return n;\n}\n\n// Decrement the reference count on a node (which is the head of a list of\n// siblings).  If the reference count becomes zero free the node and its\n// siblings.\n// Returns the number of nodes actually freed.\nstatic int deref_wordnode(spellinfo_T *spin, wordnode_T *node)\n  FUNC_ATTR_NONNULL_ALL\n{\n  wordnode_T  *np;\n  int cnt = 0;\n\n  if (--node->wn_refs == 0) {\n    for (np = node; np != NULL; np = np->wn_sibling) {\n      if (np->wn_child != NULL)\n        cnt += deref_wordnode(spin, np->wn_child);\n      free_wordnode(spin, np);\n      ++cnt;\n    }\n    ++cnt;          // length field\n  }\n  return cnt;\n}\n\n// Free a wordnode_T for re-use later.\n// Only the \"wn_child\" field becomes invalid.\nstatic void free_wordnode(spellinfo_T *spin, wordnode_T *n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  n->wn_child = spin->si_first_free;\n  spin->si_first_free = n;\n  ++spin->si_free_count;\n}\n\n// Compress a tree: find tails that are identical and can be shared.\nstatic void wordtree_compress(spellinfo_T *spin, wordnode_T *root,\n                              const char *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  hashtab_T ht;\n  long tot = 0;\n  long perc;\n\n  // Skip the root itself, it's not actually used.  The first sibling is the\n  // start of the tree.\n  if (root->wn_sibling != NULL) {\n    hash_init(&ht);\n    const long n = node_compress(spin, root->wn_sibling, &ht, &tot);\n\n#ifndef SPELL_PRINTTREE\n    if (spin->si_verbose || p_verbose > 2)\n#endif\n    {\n      if (tot > 1000000)\n        perc = (tot - n) / (tot / 100);\n      else if (tot == 0)\n        perc = 0;\n      else\n        perc = (tot - n) * 100 / tot;\n      vim_snprintf((char *)IObuff, IOSIZE,\n                   _(\"Compressed %s of %ld nodes; %ld (%ld%%) remaining\"),\n                   name, tot, tot - n, perc);\n      spell_message(spin, IObuff);\n    }\n#ifdef SPELL_PRINTTREE\n    spell_print_tree(root->wn_sibling);\n#endif\n    hash_clear(&ht);\n  }\n}\n\n// Compress a node, its siblings and its children, depth first.\n// Returns the number of compressed nodes.\nstatic long node_compress(\n    spellinfo_T *spin,\n    wordnode_T *node,\n    hashtab_T *ht,\n    long *tot           // total count of nodes before compressing,\n                        // incremented while going through the tree\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  wordnode_T  *np;\n  wordnode_T  *tp;\n  wordnode_T  *child;\n  hash_T hash;\n  hashitem_T  *hi;\n  long len = 0;\n  unsigned nr, n;\n  long compressed = 0;\n\n  // Go through the list of siblings.  Compress each child and then try\n  // finding an identical child to replace it.\n  // Note that with \"child\" we mean not just the node that is pointed to,\n  // but the whole list of siblings of which the child node is the first.\n  for (np = node; np != NULL && !got_int; np = np->wn_sibling) {\n    ++len;\n    if ((child = np->wn_child) != NULL) {\n      // Compress the child first.  This fills hashkey.\n      compressed += node_compress(spin, child, ht, tot);\n\n      // Try to find an identical child.\n      hash = hash_hash(child->wn_u1.hashkey);\n      hi = hash_lookup(ht, (const char *)child->wn_u1.hashkey,\n                       STRLEN(child->wn_u1.hashkey), hash);\n      if (!HASHITEM_EMPTY(hi)) {\n        // There are children we encountered before with a hash value\n        // identical to the current child.  Now check if there is one\n        // that is really identical.\n        for (tp = HI2WN(hi); tp != NULL; tp = tp->wn_u2.next)\n          if (node_equal(child, tp)) {\n            // Found one!  Now use that child in place of the\n            // current one.  This means the current child and all\n            // its siblings is unlinked from the tree.\n            ++tp->wn_refs;\n            compressed += deref_wordnode(spin, child);\n            np->wn_child = tp;\n            break;\n          }\n        if (tp == NULL) {\n          // No other child with this hash value equals the child of\n          // the node, add it to the linked list after the first\n          // item.\n          tp = HI2WN(hi);\n          child->wn_u2.next = tp->wn_u2.next;\n          tp->wn_u2.next = child;\n        }\n      } else\n        // No other child has this hash value, add it to the\n        // hashtable.\n        hash_add_item(ht, hi, child->wn_u1.hashkey, hash);\n    }\n  }\n  *tot += len + 1;      // add one for the node that stores the length\n\n  // Make a hash key for the node and its siblings, so that we can quickly\n  // find a lookalike node.  This must be done after compressing the sibling\n  // list, otherwise the hash key would become invalid by the compression.\n  node->wn_u1.hashkey[0] = len;\n  nr = 0;\n  for (np = node; np != NULL; np = np->wn_sibling) {\n    if (np->wn_byte == NUL)\n      // end node: use wn_flags, wn_region and wn_affixID\n      n = np->wn_flags + (np->wn_region << 8) + (np->wn_affixID << 16);\n    else\n      // byte node: use the byte value and the child pointer\n      n = (unsigned)(np->wn_byte + ((uintptr_t)np->wn_child << 8));\n    nr = nr * 101 + n;\n  }\n\n  // Avoid NUL bytes, it terminates the hash key.\n  n = nr & 0xff;\n  node->wn_u1.hashkey[1] = n == 0 ? 1 : n;\n  n = (nr >> 8) & 0xff;\n  node->wn_u1.hashkey[2] = n == 0 ? 1 : n;\n  n = (nr >> 16) & 0xff;\n  node->wn_u1.hashkey[3] = n == 0 ? 1 : n;\n  n = (nr >> 24) & 0xff;\n  node->wn_u1.hashkey[4] = n == 0 ? 1 : n;\n  node->wn_u1.hashkey[5] = NUL;\n\n  // Check for CTRL-C pressed now and then.\n  veryfast_breakcheck();\n\n  return compressed;\n}\n\n// Returns true when two nodes have identical siblings and children.\nstatic bool node_equal(wordnode_T *n1, wordnode_T *n2)\n{\n  wordnode_T  *p1;\n  wordnode_T  *p2;\n\n  for (p1 = n1, p2 = n2; p1 != NULL && p2 != NULL;\n       p1 = p1->wn_sibling, p2 = p2->wn_sibling)\n    if (p1->wn_byte != p2->wn_byte\n        || (p1->wn_byte == NUL\n            ? (p1->wn_flags != p2->wn_flags\n               || p1->wn_region != p2->wn_region\n               || p1->wn_affixID != p2->wn_affixID)\n            : (p1->wn_child != p2->wn_child)))\n      break;\n\n  return p1 == NULL && p2 == NULL;\n}\n\n\n// Function given to qsort() to sort the REP items on \"from\" string.\nstatic int rep_compare(const void *s1, const void *s2)\n{\n  fromto_T    *p1 = (fromto_T *)s1;\n  fromto_T    *p2 = (fromto_T *)s2;\n\n  return STRCMP(p1->ft_from, p2->ft_from);\n}\n\n// Write the Vim .spl file \"fname\".\n// Return OK/FAIL.\nstatic int write_vim_spell(spellinfo_T *spin, char_u *fname)\n{\n  int retval = OK;\n  int regionmask;\n\n  FILE *fd = os_fopen((char *)fname, \"w\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return FAIL;\n  }\n\n  // <HEADER>: <fileID> <versionnr>\n  // <fileID>\n  size_t fwv = fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, 1, fd);\n  if (fwv != (size_t)1)\n    // Catch first write error, don't try writing more.\n    goto theend;\n\n  putc(VIMSPELLVERSION, fd);                                // <versionnr>\n\n  // <SECTIONS>: <section> ... <sectionend>\n\n  // SN_INFO: <infotext>\n  if (spin->si_info != NULL) {\n    putc(SN_INFO, fd);                                  // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n    size_t i = STRLEN(spin->si_info);\n    put_bytes(fd, i, 4);                                // <sectionlen>\n    fwv &= fwrite(spin->si_info, i, 1, fd);             // <infotext>\n  }\n\n  // SN_REGION: <regionname> ...\n  // Write the region names only if there is more than one.\n  if (spin->si_region_count > 1) {\n    putc(SN_REGION, fd);                                // <sectionID>\n    putc(SNF_REQUIRED, fd);                             // <sectionflags>\n    size_t l = (size_t)spin->si_region_count * 2;\n    put_bytes(fd, l, 4);                                // <sectionlen>\n    fwv &= fwrite(spin->si_region_name, l, 1, fd);\n    // <regionname> ...\n    regionmask = (1 << spin->si_region_count) - 1;\n  } else\n    regionmask = 0;\n\n  // SN_CHARFLAGS: <charflagslen> <charflags> <folcharslen> <folchars>\n  //\n  // The table with character flags and the table for case folding.\n  // This makes sure the same characters are recognized as word characters\n  // when generating an when using a spell file.\n  // Skip this for ASCII, the table may conflict with the one used for\n  // 'encoding'.\n  // Also skip this for an .add.spl file, the main spell file must contain\n  // the table (avoids that it conflicts).  File is shorter too.\n  if (!spin->si_ascii && !spin->si_add) {\n    char_u folchars[128 * 8];\n    int flags;\n\n    putc(SN_CHARFLAGS, fd);                             // <sectionID>\n    putc(SNF_REQUIRED, fd);                             // <sectionflags>\n\n    // Form the <folchars> string first, we need to know its length.\n    size_t l = 0;\n    for (size_t i = 128; i < 256; i++) {\n      l += (size_t)utf_char2bytes(spelltab.st_fold[i], folchars + l);\n    }\n    put_bytes(fd, 1 + 128 + 2 + l, 4);                  // <sectionlen>\n\n    fputc(128, fd);                                     // <charflagslen>\n    for (size_t i = 128; i < 256; ++i) {\n      flags = 0;\n      if (spelltab.st_isw[i])\n        flags |= CF_WORD;\n      if (spelltab.st_isu[i])\n        flags |= CF_UPPER;\n      fputc(flags, fd);                                 // <charflags>\n    }\n\n    put_bytes(fd, l, 2);                                // <folcharslen>\n    fwv &= fwrite(folchars, l, 1, fd);                  // <folchars>\n  }\n\n  // SN_MIDWORD: <midword>\n  if (spin->si_midword != NULL) {\n    putc(SN_MIDWORD, fd);                               // <sectionID>\n    putc(SNF_REQUIRED, fd);                             // <sectionflags>\n\n    size_t i = STRLEN(spin->si_midword);\n    put_bytes(fd, i, 4);                                // <sectionlen>\n    fwv &= fwrite(spin->si_midword, i, 1, fd);\n    // <midword>\n  }\n\n  // SN_PREFCOND: <prefcondcnt> <prefcond> ...\n  if (!GA_EMPTY(&spin->si_prefcond)) {\n    putc(SN_PREFCOND, fd);                              // <sectionID>\n    putc(SNF_REQUIRED, fd);                             // <sectionflags>\n\n    size_t l = (size_t)write_spell_prefcond(NULL, &spin->si_prefcond);\n    put_bytes(fd, l, 4);                                // <sectionlen>\n\n    write_spell_prefcond(fd, &spin->si_prefcond);\n  }\n\n  // SN_REP: <repcount> <rep> ...\n  // SN_SAL: <salflags> <salcount> <sal> ...\n  // SN_REPSAL: <repcount> <rep> ...\n\n  // round 1: SN_REP section\n  // round 2: SN_SAL section (unless SN_SOFO is used)\n  // round 3: SN_REPSAL section\n  for (unsigned int round = 1; round <= 3; ++round) {\n    garray_T *gap;\n    if (round == 1)\n      gap = &spin->si_rep;\n    else if (round == 2) {\n      // Don't write SN_SAL when using a SN_SOFO section\n      if (spin->si_sofofr != NULL && spin->si_sofoto != NULL)\n        continue;\n      gap = &spin->si_sal;\n    } else\n      gap = &spin->si_repsal;\n\n    // Don't write the section if there are no items.\n    if (GA_EMPTY(gap))\n      continue;\n\n    // Sort the REP/REPSAL items.\n    if (round != 2)\n      qsort(gap->ga_data, (size_t)gap->ga_len,\n          sizeof(fromto_T), rep_compare);\n\n    int sect_id = round == 1 ? SN_REP : (round == 2 ? SN_SAL : SN_REPSAL);\n    putc(sect_id, fd);                                  // <sectionID>\n\n    // This is for making suggestions, section is not required.\n    putc(0, fd);                                        // <sectionflags>\n\n    // Compute the length of what follows.\n    size_t l = 2;  // count <repcount> or <salcount>\n    assert(gap->ga_len >= 0);\n    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {\n      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];\n      l += 1 + STRLEN(ftp->ft_from);  // count <*fromlen> and <*from>\n      l += 1 + STRLEN(ftp->ft_to);    // count <*tolen> and <*to>\n    }\n    if (round == 2)\n      ++l;                            // count <salflags>\n    put_bytes(fd, l, 4);                                // <sectionlen>\n\n    if (round == 2) {\n      int i = 0;\n      if (spin->si_followup)\n        i |= SAL_F0LLOWUP;\n      if (spin->si_collapse)\n        i |= SAL_COLLAPSE;\n      if (spin->si_rem_accents)\n        i |= SAL_REM_ACCENTS;\n      putc(i, fd);                                      // <salflags>\n    }\n\n    put_bytes(fd, (uintmax_t)gap->ga_len, 2);    // <repcount> or <salcount>\n    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {\n      // <rep> : <repfromlen> <repfrom> <reptolen> <repto>\n      // <sal> : <salfromlen> <salfrom> <saltolen> <salto>\n      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];\n      for (unsigned int rr = 1; rr <= 2; ++rr) {\n        char_u *p = rr == 1 ? ftp->ft_from : ftp->ft_to;\n        l = STRLEN(p);\n        assert(l < INT_MAX);\n        putc((int)l, fd);\n        if (l > 0)\n          fwv &= fwrite(p, l, 1, fd);\n      }\n    }\n\n  }\n\n  // SN_SOFO: <sofofromlen> <sofofrom> <sofotolen> <sofoto>\n  // This is for making suggestions, section is not required.\n  if (spin->si_sofofr != NULL && spin->si_sofoto != NULL) {\n    putc(SN_SOFO, fd);                                  // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n\n    size_t l = STRLEN(spin->si_sofofr);\n    put_bytes(fd, l + STRLEN(spin->si_sofoto) + 4, 4);  // <sectionlen>\n\n    put_bytes(fd, l, 2);                                // <sofofromlen>\n    fwv &= fwrite(spin->si_sofofr, l, 1, fd);           // <sofofrom>\n\n    l = STRLEN(spin->si_sofoto);\n    put_bytes(fd, l, 2);                                // <sofotolen>\n    fwv &= fwrite(spin->si_sofoto, l, 1, fd);           // <sofoto>\n  }\n\n  // SN_WORDS: <word> ...\n  // This is for making suggestions, section is not required.\n  if (spin->si_commonwords.ht_used > 0) {\n    putc(SN_WORDS, fd);                                 // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n\n    // round 1: count the bytes\n    // round 2: write the bytes\n    for (unsigned int round = 1; round <= 2; ++round) {\n      size_t todo;\n      size_t len = 0;\n      hashitem_T  *hi;\n\n      todo = spin->si_commonwords.ht_used;\n      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi)\n        if (!HASHITEM_EMPTY(hi)) {\n          size_t l = STRLEN(hi->hi_key) + 1;\n          len += l;\n          if (round == 2)                               // <word>\n            fwv &= fwrite(hi->hi_key, l, 1, fd);\n          --todo;\n        }\n      if (round == 1)\n        put_bytes(fd, len, 4);                          // <sectionlen>\n    }\n  }\n\n  // SN_MAP: <mapstr>\n  // This is for making suggestions, section is not required.\n  if (!GA_EMPTY(&spin->si_map)) {\n    putc(SN_MAP, fd);                                   // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n    size_t l = (size_t)spin->si_map.ga_len;\n    put_bytes(fd, l, 4);                                // <sectionlen>\n    fwv &= fwrite(spin->si_map.ga_data, l, 1, fd);      // <mapstr>\n  }\n\n  // SN_SUGFILE: <timestamp>\n  // This is used to notify that a .sug file may be available and at the\n  // same time allows for checking that a .sug file that is found matches\n  // with this .spl file.  That's because the word numbers must be exactly\n  // right.\n  if (!spin->si_nosugfile\n      && (!GA_EMPTY(&spin->si_sal)\n          || (spin->si_sofofr != NULL && spin->si_sofoto != NULL))) {\n    putc(SN_SUGFILE, fd);                               // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n    put_bytes(fd, 8, 4);                                // <sectionlen>\n\n    // Set si_sugtime and write it to the file.\n    spin->si_sugtime = time(NULL);\n    put_time(fd, spin->si_sugtime);                     // <timestamp>\n  }\n\n  // SN_NOSPLITSUGS: nothing\n  // This is used to notify that no suggestions with word splits are to be\n  // made.\n  if (spin->si_nosplitsugs) {\n    putc(SN_NOSPLITSUGS, fd);                           // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n    put_bytes(fd, 0, 4);                                // <sectionlen>\n  }\n\n  // SN_NOCOMPUNDSUGS: nothing\n  // This is used to notify that no suggestions with compounds are to be\n  // made.\n  if (spin->si_nocompoundsugs) {\n    putc(SN_NOCOMPOUNDSUGS, fd);                        // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n    put_bytes(fd, 0, 4);                                // <sectionlen>\n  }\n\n  // SN_COMPOUND: compound info.\n  // We don't mark it required, when not supported all compound words will\n  // be bad words.\n  if (spin->si_compflags != NULL) {\n    putc(SN_COMPOUND, fd);                              // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n\n    size_t l = STRLEN(spin->si_compflags);\n    assert(spin->si_comppat.ga_len >= 0);\n    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {\n      l += STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;\n    }\n    put_bytes(fd, l + 7, 4);                            // <sectionlen>\n\n    putc(spin->si_compmax, fd);                         // <compmax>\n    putc(spin->si_compminlen, fd);                      // <compminlen>\n    putc(spin->si_compsylmax, fd);                      // <compsylmax>\n    putc(0, fd);                // for Vim 7.0b compatibility\n    putc(spin->si_compoptions, fd);                     // <compoptions>\n    put_bytes(fd, (uintmax_t)spin->si_comppat.ga_len, 2);  // <comppatcount>\n    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {\n      char_u *p = ((char_u **)(spin->si_comppat.ga_data))[i];\n      assert(STRLEN(p) < INT_MAX);\n      putc((int)STRLEN(p), fd);                         // <comppatlen>\n      fwv &= fwrite(p, STRLEN(p), 1, fd);               // <comppattext>\n    }\n    // <compflags>\n    fwv &= fwrite(spin->si_compflags, STRLEN(spin->si_compflags), 1, fd);\n  }\n\n  // SN_NOBREAK: NOBREAK flag\n  if (spin->si_nobreak) {\n    putc(SN_NOBREAK, fd);                               // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n\n    // It's empty, the presence of the section flags the feature.\n    put_bytes(fd, 0, 4);                                // <sectionlen>\n  }\n\n  // SN_SYLLABLE: syllable info.\n  // We don't mark it required, when not supported syllables will not be\n  // counted.\n  if (spin->si_syllable != NULL) {\n    putc(SN_SYLLABLE, fd);                              // <sectionID>\n    putc(0, fd);                                        // <sectionflags>\n\n    size_t l = STRLEN(spin->si_syllable);\n    put_bytes(fd, l, 4);                                // <sectionlen>\n    fwv &= fwrite(spin->si_syllable, l, 1, fd);         // <syllable>\n  }\n\n  // end of <SECTIONS>\n  putc(SN_END, fd);                                     // <sectionend>\n\n\n  // <LWORDTREE>  <KWORDTREE>  <PREFIXTREE>\n  spin->si_memtot = 0;\n  for (unsigned int round = 1; round <= 3; ++round) {\n    wordnode_T *tree;\n    if (round == 1)\n      tree = spin->si_foldroot->wn_sibling;\n    else if (round == 2)\n      tree = spin->si_keeproot->wn_sibling;\n    else\n      tree = spin->si_prefroot->wn_sibling;\n\n    // Clear the index and wnode fields in the tree.\n    clear_node(tree);\n\n    // Count the number of nodes.  Needed to be able to allocate the\n    // memory when reading the nodes.  Also fills in index for shared\n    // nodes.\n    size_t nodecount = (size_t)put_node(NULL, tree, 0, regionmask, round == 3);\n\n    // number of nodes in 4 bytes\n    put_bytes(fd, nodecount, 4);                        // <nodecount>\n    assert(nodecount + nodecount * sizeof(int) < INT_MAX);\n    spin->si_memtot += (int)(nodecount + nodecount * sizeof(int));\n\n    // Write the nodes.\n    (void)put_node(fd, tree, 0, regionmask, round == 3);\n  }\n\n  // Write another byte to check for errors (file system full).\n  if (putc(0, fd) == EOF)\n    retval = FAIL;\ntheend:\n  if (fclose(fd) == EOF)\n    retval = FAIL;\n\n  if (fwv != (size_t)1)\n    retval = FAIL;\n  if (retval == FAIL)\n    EMSG(_(e_write));\n\n  return retval;\n}\n\n// Clear the index and wnode fields of \"node\", it siblings and its\n// children.  This is needed because they are a union with other items to save\n// space.\nstatic void clear_node(wordnode_T *node)\n{\n  wordnode_T  *np;\n\n  if (node != NULL)\n    for (np = node; np != NULL; np = np->wn_sibling) {\n      np->wn_u1.index = 0;\n      np->wn_u2.wnode = NULL;\n\n      if (np->wn_byte != NUL)\n        clear_node(np->wn_child);\n    }\n}\n\n\n// Dump a word tree at node \"node\".\n//\n// This first writes the list of possible bytes (siblings).  Then for each\n// byte recursively write the children.\n//\n// NOTE: The code here must match the code in read_tree_node(), since\n// assumptions are made about the indexes (so that we don't have to write them\n// in the file).\n//\n// Returns the number of nodes used.\nstatic int\nput_node (\n    FILE *fd,                // NULL when only counting\n    wordnode_T *node,\n    int idx,\n    int regionmask,\n    bool prefixtree                 // true for PREFIXTREE\n)\n{\n  // If \"node\" is zero the tree is empty.\n  if (node == NULL)\n    return 0;\n\n  // Store the index where this node is written.\n  node->wn_u1.index = idx;\n\n  // Count the number of siblings.\n  int siblingcount = 0;\n  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)\n    ++siblingcount;\n\n  // Write the sibling count.\n  if (fd != NULL)\n    putc(siblingcount, fd);                             // <siblingcount>\n\n  // Write each sibling byte and optionally extra info.\n  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling) {\n    if (np->wn_byte == 0) {\n      if (fd != NULL) {\n        // For a NUL byte (end of word) write the flags etc.\n        if (prefixtree) {\n          // In PREFIXTREE write the required affixID and the\n          // associated condition nr (stored in wn_region).  The\n          // byte value is misused to store the \"rare\" and \"not\n          // combining\" flags\n          if (np->wn_flags == (uint16_t)PFX_FLAGS)\n            putc(BY_NOFLAGS, fd);                       // <byte>\n          else {\n            putc(BY_FLAGS, fd);                         // <byte>\n            putc(np->wn_flags, fd);                     // <pflags>\n          }\n          putc(np->wn_affixID, fd);                     // <affixID>\n          put_bytes(fd, (uintmax_t)np->wn_region, 2);   // <prefcondnr>\n        } else {\n          // For word trees we write the flag/region items.\n          int flags = np->wn_flags;\n          if (regionmask != 0 && np->wn_region != regionmask)\n            flags |= WF_REGION;\n          if (np->wn_affixID != 0)\n            flags |= WF_AFX;\n          if (flags == 0) {\n            // word without flags or region\n            putc(BY_NOFLAGS, fd);                               // <byte>\n          } else {\n            if (np->wn_flags >= 0x100) {\n              putc(BY_FLAGS2, fd);                              // <byte>\n              putc(flags, fd);                                  // <flags>\n              putc((int)((unsigned)flags >> 8), fd);            // <flags2>\n            } else {\n              putc(BY_FLAGS, fd);                               // <byte>\n              putc(flags, fd);                                  // <flags>\n            }\n            if (flags & WF_REGION)\n              putc(np->wn_region, fd);                          // <region>\n            if (flags & WF_AFX)\n              putc(np->wn_affixID, fd);                         // <affixID>\n          }\n        }\n      }\n    } else {\n      if (np->wn_child->wn_u1.index != 0\n          && np->wn_child->wn_u2.wnode != node) {\n        // The child is written elsewhere, write the reference.\n        if (fd != NULL) {\n          putc(BY_INDEX, fd);                                      // <byte>\n          put_bytes(fd, (uintmax_t)np->wn_child->wn_u1.index, 3);  // <nodeidx>\n        }\n      } else if (np->wn_child->wn_u2.wnode == NULL)\n        // We will write the child below and give it an index.\n        np->wn_child->wn_u2.wnode = node;\n\n      if (fd != NULL)\n        if (putc(np->wn_byte, fd) == EOF) {       // <byte> or <xbyte>\n          EMSG(_(e_write));\n          return 0;\n        }\n    }\n  }\n\n  // Space used in the array when reading: one for each sibling and one for\n  // the count.\n  int newindex = idx + siblingcount + 1;\n\n  // Recursively dump the children of each sibling.\n  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling)\n    if (np->wn_byte != 0 && np->wn_child->wn_u2.wnode == node)\n      newindex = put_node(fd, np->wn_child, newindex, regionmask,\n          prefixtree);\n\n  return newindex;\n}\n\n\n// \":mkspell [-ascii] outfile  infile ...\"\n// \":mkspell [-ascii] addfile\"\nvoid ex_mkspell(exarg_T *eap)\n{\n  int fcount;\n  char_u      **fnames;\n  char_u      *arg = eap->arg;\n  bool ascii = false;\n\n  if (STRNCMP(arg, \"-ascii\", 6) == 0) {\n    ascii = true;\n    arg = skipwhite(arg + 6);\n  }\n\n  // Expand all the remaining arguments (e.g., $VIMRUNTIME).\n  if (get_arglist_exp(arg, &fcount, &fnames, false) == OK) {\n    mkspell(fcount, fnames, ascii, eap->forceit, false);\n    FreeWild(fcount, fnames);\n  }\n}\n\n// Create the .sug file.\n// Uses the soundfold info in \"spin\".\n// Writes the file with the name \"wfname\", with \".spl\" changed to \".sug\".\nstatic void spell_make_sugfile(spellinfo_T *spin, char_u *wfname)\n{\n  char_u      *fname = NULL;\n  int len;\n  slang_T     *slang;\n  bool free_slang = false;\n\n  // Read back the .spl file that was written.  This fills the required\n  // info for soundfolding.  This also uses less memory than the\n  // pointer-linked version of the trie.  And it avoids having two versions\n  // of the code for the soundfolding stuff.\n  // It might have been done already by spell_reload_one().\n  for (slang = first_lang; slang != NULL; slang = slang->sl_next) {\n    if (path_full_compare(wfname, slang->sl_fname, false, true)\n        == kEqualFiles) {\n      break;\n    }\n  }\n  if (slang == NULL) {\n    spell_message(spin, (char_u *)_(\"Reading back spell file...\"));\n    slang = spell_load_file(wfname, NULL, NULL, false);\n    if (slang == NULL)\n      return;\n    free_slang = true;\n  }\n\n  // Clear the info in \"spin\" that is used.\n  spin->si_blocks = NULL;\n  spin->si_blocks_cnt = 0;\n  spin->si_compress_cnt = 0;        // will stay at 0 all the time\n  spin->si_free_count = 0;\n  spin->si_first_free = NULL;\n  spin->si_foldwcount = 0;\n\n  // Go through the trie of good words, soundfold each word and add it to\n  // the soundfold trie.\n  spell_message(spin, (char_u *)_(\"Performing soundfolding...\"));\n  if (sug_filltree(spin, slang) == FAIL)\n    goto theend;\n\n  // Create the table which links each soundfold word with a list of the\n  // good words it may come from.  Creates buffer \"spin->si_spellbuf\".\n  // This also removes the wordnr from the NUL byte entries to make\n  // compression possible.\n  if (sug_maketable(spin) == FAIL)\n    goto theend;\n\n  smsg(_(\"Number of words after soundfolding: %\" PRId64),\n       (int64_t)spin->si_spellbuf->b_ml.ml_line_count);\n\n  // Compress the soundfold trie.\n  spell_message(spin, (char_u *)_(msg_compressing));\n  wordtree_compress(spin, spin->si_foldroot, \"case-folded\");\n\n  // Write the .sug file.\n  // Make the file name by changing \".spl\" to \".sug\".\n  fname = xmalloc(MAXPATHL);\n  STRLCPY(fname, wfname, MAXPATHL);\n  len = (int)STRLEN(fname);\n  fname[len - 2] = 'u';\n  fname[len - 1] = 'g';\n  sug_write(spin, fname);\n\ntheend:\n  xfree(fname);\n  if (free_slang)\n    slang_free(slang);\n  free_blocks(spin->si_blocks);\n  close_spellbuf(spin->si_spellbuf);\n}\n\n// Build the soundfold trie for language \"slang\".\nstatic int sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n  char_u      *byts;\n  idx_T       *idxs;\n  int depth;\n  idx_T arridx[MAXWLEN];\n  int curi[MAXWLEN];\n  char_u tword[MAXWLEN];\n  char_u tsalword[MAXWLEN];\n  int c;\n  idx_T n;\n  unsigned words_done = 0;\n  int wordcount[MAXWLEN];\n\n  // We use si_foldroot for the soundfolded trie.\n  spin->si_foldroot = wordtree_alloc(spin);\n\n  // Let tree_add_word() know we're adding to the soundfolded tree\n  spin->si_sugtree = true;\n\n  // Go through the whole case-folded tree, soundfold each word and put it\n  // in the trie.\n  byts = slang->sl_fbyts;\n  idxs = slang->sl_fidxs;\n\n  arridx[0] = 0;\n  curi[0] = 1;\n  wordcount[0] = 0;\n\n  depth = 0;\n  while (depth >= 0 && !got_int) {\n    if (curi[depth] > byts[arridx[depth]]) {\n      // Done all bytes at this node, go up one level.\n      idxs[arridx[depth]] = wordcount[depth];\n      if (depth > 0)\n        wordcount[depth - 1] += wordcount[depth];\n\n      --depth;\n      line_breakcheck();\n    } else {\n\n      // Do one more byte at this node.\n      n = arridx[depth] + curi[depth];\n      ++curi[depth];\n\n      c = byts[n];\n      if (c == 0) {\n        // Sound-fold the word.\n        tword[depth] = NUL;\n        spell_soundfold(slang, tword, true, tsalword);\n\n        // We use the \"flags\" field for the MSB of the wordnr,\n        // \"region\" for the LSB of the wordnr.\n        if (tree_add_word(spin, tsalword, spin->si_foldroot,\n                words_done >> 16, words_done & 0xffff,\n                0) == FAIL)\n          return FAIL;\n\n        ++words_done;\n        ++wordcount[depth];\n\n        // Reset the block count each time to avoid compression\n        // kicking in.\n        spin->si_blocks_cnt = 0;\n\n        // Skip over any other NUL bytes (same word with different\n        // flags).  But don't go over the end.\n        while (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0) {\n          n++;\n          curi[depth]++;\n        }\n      } else {\n        // Normal char, go one level deeper.\n        tword[depth++] = c;\n        arridx[depth] = idxs[n];\n        curi[depth] = 1;\n        wordcount[depth] = 0;\n      }\n    }\n  }\n\n  smsg(_(\"Total number of words: %d\"), words_done);\n\n  return OK;\n}\n\n// Make the table that links each word in the soundfold trie to the words it\n// can be produced from.\n// This is not unlike lines in a file, thus use a memfile to be able to access\n// the table efficiently.\n// Returns FAIL when out of memory.\nstatic int sug_maketable(spellinfo_T *spin)\n{\n  garray_T ga;\n  int res = OK;\n\n  // Allocate a buffer, open a memline for it and create the swap file\n  // (uses a temp file, not a .swp file).\n  spin->si_spellbuf = open_spellbuf();\n\n  // Use a buffer to store the line info, avoids allocating many small\n  // pieces of memory.\n  ga_init(&ga, 1, 100);\n\n  // recursively go through the tree\n  if (sug_filltable(spin, spin->si_foldroot->wn_sibling, 0, &ga) == -1)\n    res = FAIL;\n\n  ga_clear(&ga);\n  return res;\n}\n\n// Fill the table for one node and its children.\n// Returns the wordnr at the start of the node.\n// Returns -1 when out of memory.\nstatic int\nsug_filltable (\n    spellinfo_T *spin,\n    wordnode_T *node,\n    int startwordnr,\n    garray_T *gap           // place to store line of numbers\n)\n{\n  wordnode_T  *p, *np;\n  int wordnr = startwordnr;\n  int nr;\n  int prev_nr;\n\n  for (p = node; p != NULL; p = p->wn_sibling) {\n    if (p->wn_byte == NUL) {\n      gap->ga_len = 0;\n      prev_nr = 0;\n      for (np = p; np != NULL && np->wn_byte == NUL; np = np->wn_sibling) {\n        ga_grow(gap, 10);\n\n        nr = (np->wn_flags << 16) + (np->wn_region & 0xffff);\n        // Compute the offset from the previous nr and store the\n        // offset in a way that it takes a minimum number of bytes.\n        // It's a bit like utf-8, but without the need to mark\n        // following bytes.\n        nr -= prev_nr;\n        prev_nr += nr;\n        gap->ga_len += offset2bytes(nr,\n            (char_u *)gap->ga_data + gap->ga_len);\n      }\n\n      // add the NUL byte\n      ((char_u *)gap->ga_data)[gap->ga_len++] = NUL;\n\n      if (ml_append_buf(spin->si_spellbuf, (linenr_T)wordnr,\n                        gap->ga_data, gap->ga_len, true) == FAIL) {\n        return -1;\n      }\n      wordnr++;\n\n      // Remove extra NUL entries, we no longer need them. We don't\n      // bother freeing the nodes, the won't be reused anyway.\n      while (p->wn_sibling != NULL && p->wn_sibling->wn_byte == NUL)\n        p->wn_sibling = p->wn_sibling->wn_sibling;\n\n      // Clear the flags on the remaining NUL node, so that compression\n      // works a lot better.\n      p->wn_flags = 0;\n      p->wn_region = 0;\n    } else {\n      wordnr = sug_filltable(spin, p->wn_child, wordnr, gap);\n      if (wordnr == -1)\n        return -1;\n    }\n  }\n  return wordnr;\n}\n\n// Convert an offset into a minimal number of bytes.\n// Similar to utf_char2byters, but use 8 bits in followup bytes and avoid NUL\n// bytes.\nstatic int offset2bytes(int nr, char_u *buf)\n{\n  int rem;\n  int b1, b2, b3, b4;\n\n  // Split the number in parts of base 255.  We need to avoid NUL bytes.\n  b1 = nr % 255 + 1;\n  rem = nr / 255;\n  b2 = rem % 255 + 1;\n  rem = rem / 255;\n  b3 = rem % 255 + 1;\n  b4 = rem / 255 + 1;\n\n  if (b4 > 1 || b3 > 0x1f) {    // 4 bytes\n    buf[0] = 0xe0 + b4;\n    buf[1] = b3;\n    buf[2] = b2;\n    buf[3] = b1;\n    return 4;\n  }\n  if (b3 > 1 || b2 > 0x3f ) {   // 3 bytes\n    buf[0] = 0xc0 + b3;\n    buf[1] = b2;\n    buf[2] = b1;\n    return 3;\n  }\n  if (b2 > 1 || b1 > 0x7f ) {   // 2 bytes\n    buf[0] = 0x80 + b2;\n    buf[1] = b1;\n    return 2;\n  }\n  // 1 byte\n  buf[0] = b1;\n  return 1;\n}\n\n// Write the .sug file in \"fname\".\nstatic void sug_write(spellinfo_T *spin, char_u *fname)\n{\n  // Create the file.  Note that an existing file is silently overwritten!\n  FILE *fd = os_fopen((char *)fname, \"w\");\n  if (fd == NULL) {\n    EMSG2(_(e_notopen), fname);\n    return;\n  }\n\n  vim_snprintf((char *)IObuff, IOSIZE,\n               _(\"Writing suggestion file %s...\"), fname);\n  spell_message(spin, IObuff);\n\n  // <SUGHEADER>: <fileID> <versionnr> <timestamp>\n  if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) { // <fileID>\n    EMSG(_(e_write));\n    goto theend;\n  }\n  putc(VIMSUGVERSION, fd);                              // <versionnr>\n\n  // Write si_sugtime to the file.\n  put_time(fd, spin->si_sugtime);                       // <timestamp>\n\n  // <SUGWORDTREE>\n  spin->si_memtot = 0;\n  wordnode_T *tree = spin->si_foldroot->wn_sibling;\n\n  // Clear the index and wnode fields in the tree.\n  clear_node(tree);\n\n  // Count the number of nodes.  Needed to be able to allocate the\n  // memory when reading the nodes.  Also fills in index for shared\n  // nodes.\n  size_t nodecount = (size_t)put_node(NULL, tree, 0, 0, false);\n\n  // number of nodes in 4 bytes\n  put_bytes(fd, nodecount, 4);                          // <nodecount>\n  assert(nodecount + nodecount * sizeof(int) < INT_MAX);\n  spin->si_memtot += (int)(nodecount + nodecount * sizeof(int));\n\n  // Write the nodes.\n  (void)put_node(fd, tree, 0, 0, false);\n\n  // <SUGTABLE>: <sugwcount> <sugline> ...\n  linenr_T wcount = spin->si_spellbuf->b_ml.ml_line_count;\n  assert(wcount >= 0);\n  put_bytes(fd, (uintmax_t)wcount, 4);                  // <sugwcount>\n\n  for (linenr_T lnum = 1; lnum <= wcount; ++lnum) {\n    // <sugline>: <sugnr> ... NUL\n    char_u *line = ml_get_buf(spin->si_spellbuf, lnum, false);\n    size_t len = STRLEN(line) + 1;\n    if (fwrite(line, len, 1, fd) == 0) {\n      EMSG(_(e_write));\n      goto theend;\n    }\n    assert((size_t)spin->si_memtot + len <= INT_MAX);\n    spin->si_memtot += (int)len;\n  }\n\n  // Write another byte to check for errors.\n  if (putc(0, fd) == EOF)\n    EMSG(_(e_write));\n\n  vim_snprintf((char *)IObuff, IOSIZE,\n      _(\"Estimated runtime memory use: %d bytes\"), spin->si_memtot);\n  spell_message(spin, IObuff);\n\ntheend:\n  // close the file\n  fclose(fd);\n}\n\n\n// Create a Vim spell file from one or more word lists.\n// \"fnames[0]\" is the output file name.\n// \"fnames[fcount - 1]\" is the last input file name.\n// Exception: when \"fnames[0]\" ends in \".add\" it's used as the input file name\n// and \".spl\" is appended to make the output file name.\nstatic void\nmkspell (\n    int fcount,\n    char_u **fnames,\n    bool ascii,                         // -ascii argument given\n    bool over_write,                    // overwrite existing output file\n    bool added_word                     // invoked through \"zg\"\n)\n{\n  char_u      *fname = NULL;\n  char_u      *wfname;\n  char_u      **innames;\n  int incount;\n  afffile_T *(afile[MAXREGIONS]);\n  int i;\n  int len;\n  bool error = false;\n  spellinfo_T spin;\n\n  memset(&spin, 0, sizeof(spin));\n  spin.si_verbose = !added_word;\n  spin.si_ascii = ascii;\n  spin.si_followup = true;\n  spin.si_rem_accents = true;\n  ga_init(&spin.si_rep, (int)sizeof(fromto_T), 20);\n  ga_init(&spin.si_repsal, (int)sizeof(fromto_T), 20);\n  ga_init(&spin.si_sal, (int)sizeof(fromto_T), 20);\n  ga_init(&spin.si_map, (int)sizeof(char_u), 100);\n  ga_init(&spin.si_comppat, (int)sizeof(char_u *), 20);\n  ga_init(&spin.si_prefcond, (int)sizeof(char_u *), 50);\n  hash_init(&spin.si_commonwords);\n  spin.si_newcompID = 127;      // start compound ID at first maximum\n\n  // default: fnames[0] is output file, following are input files\n  // When \"fcount\" is 1 there is only one file.\n  innames = &fnames[fcount == 1 ? 0 : 1];\n  incount = fcount - 1;\n\n  wfname = xmalloc(MAXPATHL);\n\n  if (fcount >= 1) {\n    len = (int)STRLEN(fnames[0]);\n    if (fcount == 1 && len > 4 && STRCMP(fnames[0] + len - 4, \".add\") == 0) {\n      // For \":mkspell path/en.latin1.add\" output file is\n      // \"path/en.latin1.add.spl\".\n      incount = 1;\n      vim_snprintf((char *)wfname, MAXPATHL, \"%s.spl\", fnames[0]);\n    } else if (fcount == 1)   {\n      // For \":mkspell path/vim\" output file is \"path/vim.latin1.spl\".\n      incount = 1;\n      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n    } else if (len > 4 && STRCMP(fnames[0] + len - 4, \".spl\") == 0)   {\n      // Name ends in \".spl\", use as the file name.\n      STRLCPY(wfname, fnames[0], MAXPATHL);\n    } else\n      // Name should be language, make the file name from it.\n      vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,\n          fnames[0], spin.si_ascii ? (char_u *)\"ascii\" : spell_enc());\n\n    // Check for .ascii.spl.\n    if (strstr((char *)path_tail(wfname), SPL_FNAME_ASCII) != NULL)\n      spin.si_ascii = true;\n\n    // Check for .add.spl.\n    if (strstr((char *)path_tail(wfname), SPL_FNAME_ADD) != NULL)\n      spin.si_add = true;\n  }\n\n  if (incount <= 0) {\n    EMSG(_(e_invarg));          // need at least output and input names\n  } else if (vim_strchr(path_tail(wfname), '_') != NULL) {\n    EMSG(_(\"E751: Output file name must not have region name\"));\n  } else if (incount > MAXREGIONS) {\n    emsgf(_(\"E754: Only up to %d regions supported\"), MAXREGIONS);\n  } else {\n    // Check for overwriting before doing things that may take a lot of\n    // time.\n    if (!over_write && os_path_exists(wfname)) {\n      EMSG(_(e_exists));\n      goto theend;\n    }\n    if (os_isdir(wfname)) {\n      EMSG2(_(e_isadir2), wfname);\n      goto theend;\n    }\n\n    fname = xmalloc(MAXPATHL);\n\n    // Init the aff and dic pointers.\n    // Get the region names if there are more than 2 arguments.\n    for (i = 0; i < incount; ++i) {\n      afile[i] = NULL;\n\n      if (incount > 1) {\n        len = (int)STRLEN(innames[i]);\n        if (STRLEN(path_tail(innames[i])) < 5\n            || innames[i][len - 3] != '_') {\n          EMSG2(_(\"E755: Invalid region in %s\"), innames[i]);\n          goto theend;\n        }\n        spin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);\n        spin.si_region_name[i * 2 + 1] =\n          TOLOWER_ASC(innames[i][len - 1]);\n      }\n    }\n    spin.si_region_count = incount;\n\n    spin.si_foldroot = wordtree_alloc(&spin);\n    spin.si_keeproot = wordtree_alloc(&spin);\n    spin.si_prefroot = wordtree_alloc(&spin);\n\n    // When not producing a .add.spl file clear the character table when\n    // we encounter one in the .aff file.  This means we dump the current\n    // one in the .spl file if the .aff file doesn't define one.  That's\n    // better than guessing the contents, the table will match a\n    // previously loaded spell file.\n    if (!spin.si_add)\n      spin.si_clear_chartab = true;\n\n    // Read all the .aff and .dic files.\n    // Text is converted to 'encoding'.\n    // Words are stored in the case-folded and keep-case trees.\n    for (i = 0; i < incount && !error; ++i) {\n      spin.si_conv.vc_type = CONV_NONE;\n      spin.si_region = 1 << i;\n\n      vim_snprintf((char *)fname, MAXPATHL, \"%s.aff\", innames[i]);\n      if (os_path_exists(fname)) {\n        // Read the .aff file.  Will init \"spin->si_conv\" based on the\n        // \"SET\" line.\n        afile[i] = spell_read_aff(&spin, fname);\n        if (afile[i] == NULL)\n          error = true;\n        else {\n          // Read the .dic file and store the words in the trees.\n          vim_snprintf((char *)fname, MAXPATHL, \"%s.dic\",\n              innames[i]);\n          if (spell_read_dic(&spin, fname, afile[i]) == FAIL)\n            error = true;\n        }\n      } else {\n        // No .aff file, try reading the file as a word list.  Store\n        // the words in the trees.\n        if (spell_read_wordfile(&spin, innames[i]) == FAIL)\n          error = true;\n      }\n\n      // Free any conversion stuff.\n      convert_setup(&spin.si_conv, NULL, NULL);\n    }\n\n    if (spin.si_compflags != NULL && spin.si_nobreak)\n      MSG(_(\"Warning: both compounding and NOBREAK specified\"));\n\n    if (!error && !got_int) {\n      // Combine tails in the tree.\n      spell_message(&spin, (char_u *)_(msg_compressing));\n      wordtree_compress(&spin, spin.si_foldroot, \"case-folded\");\n      wordtree_compress(&spin, spin.si_keeproot, \"keep-case\");\n      wordtree_compress(&spin, spin.si_prefroot, \"prefixes\");\n    }\n\n    if (!error && !got_int) {\n      // Write the info in the spell file.\n      vim_snprintf((char *)IObuff, IOSIZE,\n                   _(\"Writing spell file %s...\"), wfname);\n      spell_message(&spin, IObuff);\n\n      error = write_vim_spell(&spin, wfname) == FAIL;\n\n      spell_message(&spin, (char_u *)_(\"Done!\"));\n      vim_snprintf((char *)IObuff, IOSIZE,\n          _(\"Estimated runtime memory use: %d bytes\"), spin.si_memtot);\n      spell_message(&spin, IObuff);\n\n      // If the file is loaded need to reload it.\n      if (!error)\n        spell_reload_one(wfname, added_word);\n    }\n\n    // Free the allocated memory.\n    ga_clear(&spin.si_rep);\n    ga_clear(&spin.si_repsal);\n    ga_clear(&spin.si_sal);\n    ga_clear(&spin.si_map);\n    ga_clear(&spin.si_comppat);\n    ga_clear(&spin.si_prefcond);\n    hash_clear_all(&spin.si_commonwords, 0);\n\n    // Free the .aff file structures.\n    for (i = 0; i < incount; ++i)\n      if (afile[i] != NULL)\n        spell_free_aff(afile[i]);\n\n    // Free all the bits and pieces at once.\n    free_blocks(spin.si_blocks);\n\n    // If there is soundfolding info and no NOSUGFILE item create the\n    // .sug file with the soundfolded word trie.\n    if (spin.si_sugtime != 0 && !error && !got_int)\n      spell_make_sugfile(&spin, wfname);\n\n  }\n\ntheend:\n  xfree(fname);\n  xfree(wfname);\n}\n\n// Display a message for spell file processing when 'verbose' is set or using\n// \":mkspell\".  \"str\" can be IObuff.\nstatic void spell_message(const spellinfo_T *spin, char_u *str)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (spin->si_verbose || p_verbose > 2) {\n    if (!spin->si_verbose)\n      verbose_enter();\n    MSG(str);\n    ui_flush();\n    if (!spin->si_verbose)\n      verbose_leave();\n  }\n}\n\n// \":[count]spellgood  {word}\"\n// \":[count]spellwrong {word}\"\n// \":[count]spellundo  {word}\"\n// \":[count]spellrare  {word}\"\nvoid ex_spell(exarg_T *eap)\n{\n  spell_add_word(eap->arg, (int)STRLEN(eap->arg),\n                 eap->cmdidx == CMD_spellwrong ? SPELL_ADD_BAD :\n                 eap->cmdidx == CMD_spellrare ? SPELL_ADD_RARE : SPELL_ADD_GOOD,\n                 eap->forceit ? 0 : (int)eap->line2,\n                 eap->cmdidx == CMD_spellundo);\n}\n\n// Add \"word[len]\" to 'spellfile' as a good or bad word.\nvoid\nspell_add_word (\n    char_u *word,\n    int len,\n    SpellAddType what,        // SPELL_ADD_ values\n    int idx,                  // \"zG\" and \"zW\": zero, otherwise index in\n                              // 'spellfile'\n    bool undo                 // true for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n)\n{\n  FILE        *fd = NULL;\n  buf_T       *buf = NULL;\n  bool new_spf = false;\n  char_u      *fname;\n  char_u      *fnamebuf = NULL;\n  char_u line[MAXWLEN * 2];\n  long fpos, fpos_next = 0;\n  int i;\n  char_u      *spf;\n\n  if (idx == 0) {           // use internal wordlist\n    if (int_wordlist == NULL) {\n      int_wordlist = vim_tempname();\n      if (int_wordlist == NULL)\n        return;\n    }\n    fname = int_wordlist;\n  } else {\n    // If 'spellfile' isn't set figure out a good default value.\n    if (*curwin->w_s->b_p_spf == NUL) {\n      init_spellfile();\n      new_spf = true;\n    }\n\n    if (*curwin->w_s->b_p_spf == NUL) {\n      EMSG2(_(e_notset), \"spellfile\");\n      return;\n    }\n    fnamebuf = xmalloc(MAXPATHL);\n\n    for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i) {\n      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n      if (i == idx)\n        break;\n      if (*spf == NUL) {\n        EMSGN(_(\"E765: 'spellfile' does not have %\" PRId64 \" entries\"), idx);\n        xfree(fnamebuf);\n        return;\n      }\n    }\n\n    // Check that the user isn't editing the .add file somewhere.\n    buf = buflist_findname_exp(fnamebuf);\n    if (buf != NULL && buf->b_ml.ml_mfp == NULL)\n      buf = NULL;\n    if (buf != NULL && bufIsChanged(buf)) {\n      EMSG(_(e_bufloaded));\n      xfree(fnamebuf);\n      return;\n    }\n\n    fname = fnamebuf;\n  }\n\n  if (what == SPELL_ADD_BAD || undo) {\n    // When the word appears as good word we need to remove that one,\n    // since its flags sort before the one with WF_BANNED.\n    fd = os_fopen((char *)fname, \"r\");\n    if (fd != NULL) {\n      while (!vim_fgets(line, MAXWLEN * 2, fd)) {\n        fpos = fpos_next;\n        fpos_next = ftell(fd);\n        if (STRNCMP(word, line, len) == 0\n            && (line[len] == '/' || line[len] < ' ')) {\n          // Found duplicate word.  Remove it by writing a '#' at\n          // the start of the line.  Mixing reading and writing\n          // doesn't work for all systems, close the file first.\n          fclose(fd);\n          fd = os_fopen((char *)fname, \"r+\");\n          if (fd == NULL) {\n            break;\n          }\n          if (fseek(fd, fpos, SEEK_SET) == 0) {\n            fputc('#', fd);\n            if (undo) {\n              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n              smsg(_(\"Word '%.*s' removed from %s\"),\n                   len, word, NameBuff);\n            }\n          }\n          if (fseek(fd, fpos_next, SEEK_SET) != 0) {\n            PERROR(_(\"Seek error in spellfile\"));\n            break;\n          }\n        }\n      }\n      if (fd != NULL)\n        fclose(fd);\n    }\n  }\n\n  if (!undo) {\n    fd = os_fopen((char *)fname, \"a\");\n    if (fd == NULL && new_spf) {\n      char_u *p;\n\n      // We just initialized the 'spellfile' option and can't open the\n      // file.  We may need to create the \"spell\" directory first.  We\n      // already checked the runtime directory is writable in\n      // init_spellfile().\n      if (!dir_of_file_exists(fname) && (p = path_tail_with_sep(fname)) != fname) {\n        int c = *p;\n\n        // The directory doesn't exist.  Try creating it and opening\n        // the file again.\n        *p = NUL;\n        os_mkdir((char *)fname, 0755);\n        *p = c;\n        fd = os_fopen((char *)fname, \"a\");\n      }\n    }\n\n    if (fd == NULL) {\n      EMSG2(_(e_notopen), fname);\n    } else {\n      if (what == SPELL_ADD_BAD) {\n        fprintf(fd, \"%.*s/!\\n\", len, word);\n      } else if (what == SPELL_ADD_RARE) {\n        fprintf(fd, \"%.*s/?\\n\", len, word);\n      } else {\n        fprintf(fd, \"%.*s\\n\", len, word);\n      }\n      fclose(fd);\n\n      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n    }\n  }\n\n  if (fd != NULL) {\n    // Update the .add.spl file.\n    mkspell(1, &fname, false, true, true);\n\n    // If the .add file is edited somewhere, reload it.\n    if (buf != NULL)\n      buf_reload(buf, buf->b_orig_mode);\n\n    redraw_all_later(SOME_VALID);\n  }\n  xfree(fnamebuf);\n}\n\n// Initialize 'spellfile' for the current buffer.\nstatic void init_spellfile(void)\n{\n  char_u      *buf;\n  int l;\n  char_u      *fname;\n  char_u      *rtp;\n  char_u      *lend;\n  bool aspath = false;\n  char_u      *lstart = curbuf->b_s.b_p_spl;\n\n  if (*curwin->w_s->b_p_spl != NUL && !GA_EMPTY(&curwin->w_s->b_langp)) {\n    buf = xmalloc(MAXPATHL);\n\n    // Find the end of the language name.  Exclude the region.  If there\n    // is a path separator remember the start of the tail.\n    for (lend = curwin->w_s->b_p_spl; *lend != NUL\n         && vim_strchr((char_u *)\",._\", *lend) == NULL; ++lend)\n      if (vim_ispathsep(*lend)) {\n        aspath = true;\n        lstart = lend + 1;\n      }\n\n    // Loop over all entries in 'runtimepath'.  Use the first one where we\n    // are allowed to write.\n    rtp = p_rtp;\n    while (*rtp != NUL) {\n      if (aspath)\n        // Use directory of an entry with path, e.g., for\n        // \"/dir/lg.utf-8.spl\" use \"/dir\".\n        STRLCPY(buf, curbuf->b_s.b_p_spl,\n            lstart - curbuf->b_s.b_p_spl);\n      else\n        // Copy the path from 'runtimepath' to buf[].\n        copy_option_part(&rtp, buf, MAXPATHL, \",\");\n      if (os_file_is_writable((char *)buf) == 2) {\n        // Use the first language name from 'spelllang' and the\n        // encoding used in the first loaded .spl file.\n        if (aspath)\n          STRLCPY(buf, curbuf->b_s.b_p_spl,\n              lend - curbuf->b_s.b_p_spl + 1);\n        else {\n          // Create the \"spell\" directory if it doesn't exist yet.\n          l = (int)STRLEN(buf);\n          vim_snprintf((char *)buf + l, MAXPATHL - l, \"/spell\");\n          if (os_file_is_writable((char *)buf) != 2) {\n            os_mkdir((char *)buf, 0755);\n          }\n\n          l = (int)STRLEN(buf);\n          vim_snprintf((char *)buf + l, MAXPATHL - l,\n              \"/%.*s\", (int)(lend - lstart), lstart);\n        }\n        l = (int)STRLEN(buf);\n        fname = LANGP_ENTRY(curwin->w_s->b_langp, 0)\n                ->lp_slang->sl_fname;\n        vim_snprintf((char *)buf + l, MAXPATHL - l, \".%s.add\",\n                     ((fname != NULL\n                       && strstr((char *)path_tail(fname), \".ascii.\") != NULL)\n                      ? \"ascii\"\n                      : (const char *)spell_enc()));\n        set_option_value(\"spellfile\", 0L, (const char *)buf, OPT_LOCAL);\n        break;\n      }\n      aspath = false;\n    }\n\n    xfree(buf);\n  }\n}\n\n// Set the spell character tables from strings in the .spl file.\nstatic void\nset_spell_charflags (\n    char_u *flags,\n    int cnt,                    // length of \"flags\"\n    char_u *fol\n)\n{\n  // We build the new tables here first, so that we can compare with the\n  // previous one.\n  spelltab_T new_st;\n  int i;\n  char_u      *p = fol;\n  int c;\n\n  clear_spell_chartab(&new_st);\n\n  for (i = 0; i < 128; ++i) {\n    if (i < cnt) {\n      new_st.st_isw[i + 128] = (flags[i] & CF_WORD) != 0;\n      new_st.st_isu[i + 128] = (flags[i] & CF_UPPER) != 0;\n    }\n\n    if (*p != NUL) {\n      c = mb_ptr2char_adv((const char_u **)&p);\n      new_st.st_fold[i + 128] = c;\n      if (i + 128 != c && new_st.st_isu[i + 128] && c < 256)\n        new_st.st_upper[c] = i + 128;\n    }\n  }\n\n  (void)set_spell_finish(&new_st);\n}\n\nstatic int set_spell_finish(spelltab_T *new_st)\n{\n  int i;\n\n  if (did_set_spelltab) {\n    // check that it's the same table\n    for (i = 0; i < 256; ++i) {\n      if (spelltab.st_isw[i] != new_st->st_isw[i]\n          || spelltab.st_isu[i] != new_st->st_isu[i]\n          || spelltab.st_fold[i] != new_st->st_fold[i]\n          || spelltab.st_upper[i] != new_st->st_upper[i]) {\n        EMSG(_(\"E763: Word characters differ between spell files\"));\n        return FAIL;\n      }\n    }\n  } else {\n    // copy the new spelltab into the one being used\n    spelltab = *new_st;\n    did_set_spelltab = true;\n  }\n\n  return OK;\n}\n\n// Write the table with prefix conditions to the .spl file.\n// When \"fd\" is NULL only count the length of what is written.\nstatic int write_spell_prefcond(FILE *fd, garray_T *gap)\n{\n  assert(gap->ga_len >= 0);\n\n  if (fd != NULL)\n    put_bytes(fd, (uintmax_t)gap->ga_len, 2);           // <prefcondcnt>\n\n  size_t totlen = 2 + (size_t)gap->ga_len;  // <prefcondcnt> and <condlen> bytes\n  size_t x = 1;  // collect return value of fwrite()\n  for (int i = 0; i < gap->ga_len; ++i) {\n    // <prefcond> : <condlen> <condstr>\n    char_u *p = ((char_u **)gap->ga_data)[i];\n    if (p != NULL) {\n      size_t len = STRLEN(p);\n      if (fd != NULL) {\n        assert(len <= INT_MAX);\n        fputc((int)len, fd);\n        x &= fwrite(p, len, 1, fd);\n      }\n      totlen += len;\n    } else if (fd != NULL)\n      fputc(0, fd);\n  }\n\n  assert(totlen <= INT_MAX);\n  return (int)totlen;\n}\n\n// Use map string \"map\" for languages \"lp\".\nstatic void set_map_str(slang_T *lp, char_u *map)\n{\n  char_u      *p;\n  int headc = 0;\n  int c;\n  int i;\n\n  if (*map == NUL) {\n    lp->sl_has_map = false;\n    return;\n  }\n  lp->sl_has_map = true;\n\n  // Init the array and hash tables empty.\n  for (i = 0; i < 256; ++i)\n    lp->sl_map_array[i] = 0;\n  hash_init(&lp->sl_map_hash);\n\n  // The similar characters are stored separated with slashes:\n  // \"aaa/bbb/ccc/\".  Fill sl_map_array[c] with the character before c and\n  // before the same slash.  For characters above 255 sl_map_hash is used.\n  for (p = map; *p != NUL; ) {\n    c = mb_cptr2char_adv((const char_u **)&p);\n    if (c == '/') {\n      headc = 0;\n    } else {\n      if (headc == 0) {\n        headc = c;\n      }\n\n      // Characters above 255 don't fit in sl_map_array[], put them in\n      // the hash table.  Each entry is the char, a NUL the headchar and\n      // a NUL.\n      if (c >= 256) {\n        int cl = mb_char2len(c);\n        int headcl = mb_char2len(headc);\n        char_u      *b;\n        hash_T hash;\n        hashitem_T  *hi;\n\n        b = xmalloc(cl + headcl + 2);\n        utf_char2bytes(c, b);\n        b[cl] = NUL;\n        utf_char2bytes(headc, b + cl + 1);\n        b[cl + 1 + headcl] = NUL;\n        hash = hash_hash(b);\n        hi = hash_lookup(&lp->sl_map_hash, (const char *)b, STRLEN(b), hash);\n        if (HASHITEM_EMPTY(hi)) {\n          hash_add_item(&lp->sl_map_hash, hi, b, hash);\n        } else {\n          // This should have been checked when generating the .spl\n          // file.\n          EMSG(_(\"E783: duplicate char in MAP entry\"));\n          xfree(b);\n        }\n      } else\n        lp->sl_map_array[c] = headc;\n    }\n  }\n}\n\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 18, "file": 0, "line": 590}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 590}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "638a43060a4c00d9ce738fe820de6761", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 590}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 590}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d0df113fda4437fbaf97151b9dace0f2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 613}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 613}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a2bdc2bb416fe7c1170e849cbba7db8e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 613}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 613}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "facb54aa0fa38581cc30aca192bde19e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a0988e5b41a07b766314dc3d6ee740d6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bc9b3d0fdccc5b9ef4e3ac84baf665c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 655}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 655}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d2c696981634cc596ab6b06ac1d0f3f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 655}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 655}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "05e3dfa35bf1c74988a3d9c9093e9a3d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 662}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "137ea2b83de01d42fc6117bd732724f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 662}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "adcf3f57ba6153bcef24d05ad61e3214", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 676}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 676}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aaab89ff1cc407842286626c3e3c525c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 676}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 676}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "743a9c3b76cc557c61d45bc846be0b10", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 702}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 702}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e01cf18978b2489d5d5dff7cda4a7356", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 702}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 702}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6f447c2431bbce19e459b3980a35182f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 734}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 734}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6e4f9181389ae7e01cbcecb7c9dcc51a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 734}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 734}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "25449e29b9600d54e14154657b47a178", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 736}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f9200e000c3f74dbcabef5614b422a33", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 736}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7968827c03683f3e1135114773f7712f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 747}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 747}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "df19aa304bec47fd0d3bf3b3a0f66eba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 747}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 747}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "08ab0f1d2dff1fad64e2a7ef25f78893", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 748}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 748}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a7b2c7cd64c54cbd31bd97b2978503ef", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 748}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 748}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8c8fbcae8eda7007a435870b2eb95f8d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 762}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 762}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4b17ded7ce23f828e8e33d037a7df787", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 762}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 762}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f562368c6f34a69172fda5106ca5fbd9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 795}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fb99d1b5bdcd9ab3b43b553e59497108", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 795}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 795}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9a991b3a1a422c28c7bbe88766d3d7fa", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 798}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 798}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e85c6a0fa9d109dbde560472a03aa866", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 798}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 798}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bbfcc77a3585b29d62d9911bae686e3a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 803}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 803}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "15d497eec0009f97013be54b4a2274cf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 803}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 803}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "419a9b4f23c0dd4bd92d4e571d48ad86", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 813}, "message": "const (fixit)"}, {"location": {"col": 38, "file": 0, "line": 813}, "message": "pointer parameter 'byts' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a5a2bb7423d9224d2f461b7f0d3895a4", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 830}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 830}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb0cbc27486d7b981b4850df765f8115", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 830}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 830}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cc01d6f5eaf71970cc5f5ba01a34cb3e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 891}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 891}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e598f8a55bc8eaabf2e3c5f46ec070ce", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 898}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 898}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a41acae475cf1d01dcb3ca7a23259a97", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 898}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 898}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "33dd3d2529fc994342b66b9a809497ea", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 945}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 945}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f16462a3a79ba5d9c13d70f26c88100c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 945}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 945}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6731528bf723de69a0f5dccc2860da11", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 959}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 959}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e6208a113fb45b947e6f98ab86268dbd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 959}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 959}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5378bb3285126f37f79792271e0c88c5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 975}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 975}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "83ddc9330122d70967352b5c35d78988", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 975}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 975}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ee514543a6daae6e9a40800d80432175", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 977}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 977}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aa12eb7ce4c3f1ea1e90673660266733", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1004}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1004}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cb528ac2b43427a809b07d9b5fc8de3f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1004}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1004}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "158d5d6973f5d61d5a04a066c37d0ed7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1008}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1008}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "641fed45d63335a4df5e75d38ba0816c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1008}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1008}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2be807c723af84992cff8c29aca532da", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1032}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b442c24a305517ff62628dfa7b94a4f1", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1036}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1036}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9b58b28bd2d0ff369d31d559df87bfb2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1036}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1036}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "013bc82b7eaaf81e37c55c74867a9544", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1047}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1047}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d60175de32ab1d56870cf78051a7fcee", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1047}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1047}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0c77dff0affb5f28c46c28ddf0634cd8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1054}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1054}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "86b76902e5d8be67b542d82bce3cdfa0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1054}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1054}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fb3041c4b18fe743daaf265c061d980c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1100}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4f1d14bd5ba9ed0e1846ac4e9b9cc780", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1100}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1100}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "11b4435365a24000b2d35cb2871beae0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1110}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1110}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ec29d75f63451a837709330fb15646a0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1110}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1110}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "56b0d445ca4fa59ea9a68f0231e2a048", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1112}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1112}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9569d581d1b8751ce704328df3147dce", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1112}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1112}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9a02725da21bf54a60eac6206e833e30", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1117}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1117}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "33ddb49e142c26fc6587228d27555d4f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1117}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1117}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "13a5090948458087ca65f4aa27940e7b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1129}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1129}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "78f2f2385b55851da7ba414b977628cd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1129}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1129}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fd7e707f98de4324af07bec82b060b22", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1159}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4f1d14bd5ba9ed0e1846ac4e9b9cc780", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1159}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "11b4435365a24000b2d35cb2871beae0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1172}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "742f56aa4b2b7eda2731294920cb5ced", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1172}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1172}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "23c96b2547484fec6389a28f7395b290", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 1181}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 1181}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f957ee4675b922ecee2b0ca431c525e6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 1181}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 1181}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "304d6cd1ec61fe0e4854005674997ba1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 1193}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 1193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f10452fff588b8d6c5d2935283d81197", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 1193}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 1193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2185f61f7ae15c5b8b8e7023e9d56a5b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 1198}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 1198}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a12f776ca41b667f76b991c97263dee8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 1198}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 1198}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7704cc7bd9fbaaf7957bbcdcff1072d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1200}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1200}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37fec548152f831e5b770e8dde6cc8df", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1200}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1200}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea59593289d697448af6d0c7a55001c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1275}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1275}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5e8611e6715c80b8b64fd8e01b80bf3d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1275}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1275}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8bbf50ce9495c919bd7df4aee4e1bb9b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1278}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1278}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1cdd788e6f8463ce2feadc6a381b8cda", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1278}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1278}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "85842cc2c1c766c6670d145aac007fb7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1280}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1280}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d97c41118a7e380023a7a29646cf6c78", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1280}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1280}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "99936660aca94db0ec6d0c1b958d29ca", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1296}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a76a943a81a1fbeaedf3ea25a8d078cb", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1303}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1303}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4f1d14bd5ba9ed0e1846ac4e9b9cc780", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1303}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1303}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "11b4435365a24000b2d35cb2871beae0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1314}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e5eedbc96675158bf5a1a7d7bbc02d2b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1314}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "083ab03336f0d752f976622cfc7781d7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 1316}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 1316}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fac6aac72a0d1faec32af298be7c81f0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 1316}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 1316}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7a2f74b0ab14603e8bff8ff3e14e17e7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1318}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1318}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a2e7f5f9ca63e147c82130aab1a4cf17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1318}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1318}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8c858762c8f308bdf81f16e6effe63be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1342}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1342}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3e7f29ccf2516bef726ff33ec7aee252", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1342}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1342}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ddaa7c7ec999fdc9ef22a3c30634ad2a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1347}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1347}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1fa3235c67fa7089bf75cdce106a4255", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1347}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1347}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "664a0ef33a1daff05cda375f5417bbd1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1353}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1353}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c8a215b20454a90ddfcb5b72286c6c22", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1353}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1353}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d86ab3e71519e6f7fa6f1f2fd465619", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1359}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1359}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c8a215b20454a90ddfcb5b72286c6c22", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1359}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1359}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d86ab3e71519e6f7fa6f1f2fd465619", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 1364}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 1364}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "174c5786b053617ce00b551e1e58094d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 1364}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 1364}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f8f1fd773fb72c04c12f2420709d5794", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1384}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1384}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "237707f790b996cef25c6173fa6e4dea", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1384}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1384}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "08a641b6a8e72f62a187f50f65dd9910", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1389}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "967cb540d27e48e04129d3f0480d7487", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1389}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "83c2e7e596c9c3ce65cd1c46f3ef4eaf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1439}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a683ee512cf7635725e5424da17fd4b0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1439}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2b0b3ad5e49385cec38daf3af5e006af", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1441}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ca2e3028c93de26acbe2faa7ef2fc3f9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1441}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2533f2751163f2db3eed3173c5f6d80a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1448}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b003163510897c121edd7f3810b8577f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1448}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7d9c4a38a593097a252b08e5d12376b8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1458}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1458}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a5bd87b10a03d16fc0916cb48da19766", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1458}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1458}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d52b86e822b7a1c2f5ef995877a258f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1479}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1479}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2deadd5c3f60e12e9a11b27098dd3f18", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1479}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1479}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4c501b8d629013b58703d61e63396806", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1484}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1484}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6c7a5ff25d832a6f6388ff9b8fc73a1c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1484}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1484}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b9c683bc40e7c6c4d74f7fd013676973", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1659}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1659}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "88266abec817436f383bf1e6b9f6257f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1659}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1659}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6e451dec570a87ff72f087baec0ce474", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1674}, "message": "example recursive call chain, starting from function 'read_tree_node'"}, {"location": {"col": 15, "file": 0, "line": 1763}, "message": "Frame #1: function 'read_tree_node' calls function 'read_tree_node' here:"}, {"location": {"col": 15, "file": 0, "line": 1763}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 1, "file": 0, "line": 1674}, "message": "function 'read_tree_node' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "96f92e4654dee2f314dc3eeba45ca0f8", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1693}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1693}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5955a1e54e797163ce047096b1bc90b6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1693}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 1693}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "90c05e7480e0b5f06303c599d21b5853", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 1696}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 1696}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "50f741be57284959780f26baa0f421c0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 1696}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 1696}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6a3086a6265b20c1ed63474bbd6ec214", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1703}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1703}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ec29d75f63451a837709330fb15646a0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1703}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1703}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "56b0d445ca4fa59ea9a68f0231e2a048", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1715}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1715}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "49475d43c71cad16cf0d426955867410", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1715}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1715}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9f71c0d21b6de21b7f67a87da6562644", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1717}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1717}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3d439dd2eb96d86bfb3216930420ae7d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1717}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 1717}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "48893eec48a8745935dd562fab5c35dd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1723}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1723}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0d020c3b1e348e644fec8f61055c055a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1723}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1723}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ba1524b92a82366ff9806abec45ed415", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 1732}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 1732}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9a88983923cf879e1aa4989dfd9b3353", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 1732}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 1732}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "feadcfd9657bce7c6b7ac7917c31892c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1734}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1734}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d937140d5284ee18ec0daa994835a6a1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1734}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1734}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7396660e56d138dcf6bf81a3a175df91", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1736}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d78f024c31804f817d18b2870282d0ee", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1736}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1736}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a7ac91cc7405a70147da4dc56f30449c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1745}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1745}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7bf32c9d3dfdee1cf21a6e1bf519e5f0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1745}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1745}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7ec81892946f6608ed33a30e411502ff", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1757}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1757}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "dc22529422a3b04791e01107f0d150da", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1757}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1757}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0ddd95930b7ab10d0f1e5e5c0aaeb33c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 1759}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 1759}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "41f79893cc38905ca2d98bfeb1e9bc9b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 1759}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 1759}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8564555440a08fadc3b4aab769c5d0d8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1eac9e765366f213943146d980082564", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ae74342a75f0bc2fc501ff846bbe4895", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 1786}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 1786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "92c1fbdea77fec625ab467caa0899273", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 1786}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 1786}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5ef671b849e994f824379bb974c99e42", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1796}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1796}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5911fb8e34805c892f1df3f3fd2f95db", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1796}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1796}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a87aff979cb473b3c58f529c74f55b11", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1805}, "message": "(   ) (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1805}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a1edfd6b7862e9269ad86c7adc4e0126", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1828}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1828}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "dc8d0e93764fac0e2dbd6f29619470d1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1828}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1828}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4cee2f9425eeced7cffa58a94256d1c9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2022}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2022}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9efa57cac88688ac4102a12416079784", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2022}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2022}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b75d7716ae89c4df057953663c6cedf1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2044}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2044}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a805c07823bdbd217d4105b629e4b33b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2044}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2044}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "001247e721a6107f8c6915ae31134874", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2046}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2046}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a060f352ec6f46894894f5fc675fb966", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2046}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2046}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d777cb7a3a610606b7c3b90b6b3f95c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2048}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2048}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8f3c8bc13588f3b91fe075d167642434", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2048}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2048}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6a30c6bb93ad7db14c9b399629b583a2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 2052}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 2052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a46dec92743360743e211301ea6ead12", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 2052}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 2052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "923047c38c4f0d8419a28e95bb123d7f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 2053}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 2053}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "44cf8f1066c51cfc409d74925e9299eb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 2053}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 2053}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "316edf63d525055a6f3ca27ee4d04e43", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 2055}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 2055}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4d3c60491570cf7a1df2fda8bbe115bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 2055}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 2055}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8ea5ebe6016607197574a1ab857ad440", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2056}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2056}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f0c8f6cc3b54b4e43d31ec6571b0654d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2056}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2056}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6c91ce828bb81d503742fc1ff27f12c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2058}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2058}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a060f352ec6f46894894f5fc675fb966", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2058}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2058}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d777cb7a3a610606b7c3b90b6b3f95c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2070}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2070}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "32e14ce3ae828e6ea42f304d7a40f804", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2070}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2070}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2fdfdd67d51c8704ca94c27d3fe473d7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2076}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fc1b27a0e7fc049decf60bd62c043050", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2076}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d9a2eeb72af77283934cf0407454e6a5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2078}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2078}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "112749428fa486fd1ff7c32e514fea70", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2078}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2078}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "11cd716f266e82f224e85bcd142a6d2c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 2080}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 2080}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "db36185de2e60adcf798eefd6592fba3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 2080}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 2080}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b9048c1176a5b95ac674973933cc7a92", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2082}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2082}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "21e708ad44e36518458f4fec3b20430d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2082}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2082}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ce2073de7c6d1007f4af1271e457fff4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2095}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2095}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5fc9b62d008c35d26403e7c4d17a8541", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2095}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2095}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8d76b9ce2a8d9236397db0e5bfe7c565", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2104}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2104}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f2cfae3748e7d9c5ef57bf9283ea78e1", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 2105}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 2105}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1b96dbe0daa3ae80239f7f1527d31ebd", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2107}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2107}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1108a8a1f8426706c35ed0fe334b64f2", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2108}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2108}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0ec91275a30067f53a023b920ee79d82", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2109}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2109}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2b42980874225164616269c217f56c01", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2117}, "message": "// TODO(khgh): remove \"RAR\" later (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2117}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9f1855b822c41d9cb1b587ee8c55ce30", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2124}, "message": "// TODO(khgh): remove \"KEP\" later (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2124}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "23e3b23267a99bc7f46ea22459aa6379", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2160}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2160}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "170c03053ac01ff256df77faeb3b746d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2160}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2160}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ffee14980b580682279b065232382971", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2167}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2167}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "170c03053ac01ff256df77faeb3b746d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2167}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2167}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ffee14980b580682279b065232382971", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 2175}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 2175}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b163fb6c69a861315a3ad991c474476e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2176}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 9, "file": 0, "line": 2176}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e63574dd84350c4a2e234778ac67546c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2181}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2181}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "672b4bae29e162753e98ae19555816fd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2181}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2181}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a4d7f2038a8bd27a909e4364d03ab56c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2190}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "03be0b55857757f046e874af0f507e29", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2190}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aabbe0c60f309299a43706ac49335ad6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2194}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 2194}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f3cde37eec2a4bf3f243ea3a949970f1", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 13, "file": 0, "line": 2195}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 13, "file": 0, "line": 2195}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37cd8080e9a4e4e65758e3282173880a", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 2197}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 11, "file": 0, "line": 2197}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6e3bb238c501b050c730dbb14aecb2cc", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2203}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2203}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0d125a3abfb08206b7e3a8a261f042fc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 2203}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 2203}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "153ac9e129970c4d4db8b9ab0c574555", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2209}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e09c825fbfce6a26b745f230a723fd4e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2209}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "dd951675c249fb9d7a33e39f78d6faf1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2215}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2215}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a52245cc91b12255a50effc83691c292", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2215}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2215}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "078074f3be5ec78d48e53c7c511ef1fc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2227}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "672b4bae29e162753e98ae19555816fd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2227}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a4d7f2038a8bd27a909e4364d03ab56c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2235}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2235}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "df068e2f3a29c227037443537d5c02f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2235}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2235}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a843b44371c83eea7c9efbc435a69b30", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2238}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2238}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3ae39b60aaf6d663433fe6f6d71316c4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2238}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2238}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "945cf52ee18fedd94684e6cfc4c5836b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2269}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2269}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e5a87df1e3b73e645443a9ccb294f1fc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2269}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2269}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "53d0e68859f49a5562051420babff192", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2271}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2271}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "21e708ad44e36518458f4fec3b20430d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2271}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2271}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ce2073de7c6d1007f4af1271e457fff4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 2282}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 0, "line": 2282}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4c0283051e4d67fe6d152f2c251733fe", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 2282}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 0, "line": 2282}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e6ff0450ed49e85f90f78ac90d562404", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2285}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2285}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2faac61aa0b64f413002f665d1f869e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2285}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2285}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "74e5fdb239de0700ca4c9c288de5f23d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2309}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2309}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1e673e511bc033e4ca04dfc78bfccfe0", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2320}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2320}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "86ac96d0449d2871ea986c10647d7f53", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2320}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2320}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8b37c4fd307d56a08a3510cc62e772be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2328}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2328}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9ebea91a1bc94dddd1bfdbf094282644", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2328}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2328}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0dca7be7991465b822ac74ebb4061e47", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 0, "line": 2331}, "message": "{ (fixit)"}, {"location": {"col": 70, "file": 0, "line": 2331}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d1d7a5e43c7f4662e6d20057228a4ae5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 0, "line": 2331}, "message": "{ (fixit)"}, {"location": {"col": 70, "file": 0, "line": 2331}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b4064493f5ffeaaaca97627ac5f936e5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2346}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2346}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b6193a5a13641326dd28ec24ebe0652c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2346}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2346}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8d8eb14f0e17c27efa322e98fba4e03d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2366}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2366}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5951e10e07672b0e918db5a0b927172b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2366}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2366}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "22276aec47b4d8311129ab3f17373502", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2373}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2373}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "20f917036fe016a4191421d6881e9c99", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2373}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2373}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5332b56c64399a5076c1ecb915b7a1de", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2397}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2397}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fddd0ddd97b77206e29db76f45cf1309", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2397}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2397}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ffc9b0f1393e3243c19ec87e4feb7b56", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2399}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2399}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3d15afcb49e2249c605edd65a5a909bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2399}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 2399}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b0ec7f30341bbabe2a357dc2c5633295", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2403}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "207b571dd1c04dc8511049898bd0e50b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2403}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8b7fb31f823b9146012d2f14e69d4716", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 2424}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3b4a2dba0c98fbf19e79b3cf149e5c70", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 2467}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 2467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c7095334211042d3b813eec21429317e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 2467}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 2467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f10da70e10ef7241fa3fd0c570ac3438", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 2479}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 2479}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "04972f692350a35508714ca6405b1fd6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 2479}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 2479}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b2f5a8488816b88204e68dfda22301b0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2481}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2481}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb0de601b114efc2227bdcba59129dc6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2481}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2481}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7d7c910791b7aabb5b38ed8c32b4a531", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2487}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "49a153b07fdb0a00478d9e8bfd1a4187", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2487}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7157a60bbcb8d5d0ff03cafb9408e841", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2489}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2489}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3ab28ca81ba5d70b7310752632b2c5f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2489}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2489}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5a8dc5a224b58fcccab2663c9ef92ad4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2491}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2491}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "335140f7673150aa08edd2eb0e5e0bf4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2491}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2491}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ae55ba8148f953532ffc73825c1abede", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2493}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2493}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2e24c7b99c4a6472d6e759793664deb8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2493}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2493}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f6b69b6cb72270ed79862e5056c8ba98", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2516}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "036225812ebd2eb6cee18af0978ea5e9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2516}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "637b40ef9f117458235e286473a447ef", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2525}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2525}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "efc5ba519e3746faf109d4b939bae95e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 2525}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 2525}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "df59a46b549e48c86ce3ea39bd87aa49", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 2549}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 2549}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f331d25db63e008a28dc2fe1dfdc93de", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 2549}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 2549}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ab4360bdfdf5692a176e638b39e2737e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2578}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2578}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5a44a70f90efbd7672377cf87d4f035d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2578}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 2578}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d94c8fdedef5041a03839c13f12b1b0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 2580}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 2580}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9c4d5fe5a4577db95f65316f1ecee6d2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 2580}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 2580}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7d23989c2f2d4e9eecd28bda4e1b472d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 2582}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 2582}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d9df66052d68001371613e97c251a0d5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 2582}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 2582}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "77f12817ed59ee11b5dbd79a610a2a64", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2584}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2584}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3d439dd2eb96d86bfb3216930420ae7d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2584}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2584}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "48893eec48a8745935dd562fab5c35dd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2606}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2606}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a5bd87b10a03d16fc0916cb48da19766", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2606}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2606}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d52b86e822b7a1c2f5ef995877a258f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2649}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2649}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d073b77b0dcd76381758b13fb85072f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2649}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2649}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "502da0fffb856c9f5e08532d9c9d4500", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 2654}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 2654}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ddd078b6dbc23fc83f7f80bb5b627b6d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 2654}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 2654}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "505ce44b2ccd3980ca728afafbec8998", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 2656}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 2656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fde7a3ed9270ee1ab2ffc315c1b52203", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 2656}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 2656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6c6162f977cf29e4f1bab738276812fc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2658}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2658}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "81071747db3ba08988143a2703f392ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2658}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2658}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "28c6a32f7e0cbe34f210e6495ad5a170", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2668}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2668}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "46db375d618933f2ffcccb84bbb9c2af", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2668}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2668}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9bc8da3908ae8a01332db4995e57b18a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 2671}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 2671}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "04194e1a3b2f6d052196cfbdbd3109ef", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 2671}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 2671}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6619d0ce31669b476c47f759d80b254c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2716}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2716}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "80db7a29cd89a85b1a90600155f3331b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2716}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2716}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "85c4f5958435c65d2f32ec4405ef521b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2718}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2718}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "21e708ad44e36518458f4fec3b20430d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2718}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 2718}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ce2073de7c6d1007f4af1271e457fff4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2721}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2721}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7cf6f904ea2c09340859fee460669303", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2721}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2721}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6c333d81be203d5d75cce0eb72d33111", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2724}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2724}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "78498b78bdfedc6d133612d10f930851", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2724}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2724}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5c3cd1ad7e617a260cf716e6bb606316", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2749}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2749}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "979d1efd3076447c9fddf51c1484ffaf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2749}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2749}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b12cf0d36ccb90c05bbdadfeb7a69699", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2752}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2752}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "81071747db3ba08988143a2703f392ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2752}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 2752}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "28c6a32f7e0cbe34f210e6495ad5a170", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2784}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2784}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4a431c228a7d61fb0e208335591f3d2b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2784}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2784}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aec4624a128110b1f6ed6c2a8a0589b3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2812}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "023634d8a8bcba5cc596de3f4bcdc21e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 2812}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 2812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7617e0f6bce2cabf1e5ba1c015af7b95", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2816}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 2816}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d74f3abb1c6454554fc72a7de9c169db", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 2817}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 2817}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ebf15ef40bcb538d81e50a8e1b985cf2", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 0, "line": 2823}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 2823}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8d245ec36a4f38a3e342022e2070f33d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 2823}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 2823}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "25da1a4c6d636f4e526ed28a5a7d47fa", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2839}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 2839}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e24ec1689931653f48f7891da470bb7e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 53, "file": 0, "line": 2852}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 2852}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "62a5166885d7e778c4d219238a106ff6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 2852}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 2852}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3eb6f71fe45bf2e2069823882ed0e329", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2919}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2919}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0c24e41f3d4c30b07bb36071e94eac69", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2919}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2919}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ee05b304d66cfbd2590e6a9ed2edcd9b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2927}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2927}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9311ee38eb965dc8068b0c38037334ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 2927}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 2927}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9ee59e66cb5d58194780ba8aca28f22a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2936}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2936}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5442894e2d0cbffad25184228e6820f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2936}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2936}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aff97366538ba14ce8be4458003e7089", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 2978}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 2978}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "867d316085eddd5b92cebc7cd382863a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 2978}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 2978}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1ea363f160f4948044d064789c2e1e65", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2982}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2982}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9616a3124f6ce21e9b13339c4e5084fc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2982}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2982}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a7620a86efefe8b54c6788ed43e5af24", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 3045}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 3045}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "212a2ffcd1704ef5832368b4cd90132a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 3045}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 3045}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7eac14ff1da30b388db0069ea9a040b8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3051}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 3051}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f2454ab1a94aff74b6a32722996314bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3051}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 3051}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "dfac91d0860285e91cc5b28bbcbc2d16", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3053}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 3053}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c5ade9a93cf7ff416ceda54b1e6ae6f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3053}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 3053}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e4e9d9c07e8391bad4075e03569bddc3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 3120}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 3120}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c8faf1677c6f25b988a4edfb4255aa66", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 3120}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 3120}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1f88a25dd612e35860662286af9a00b3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3123}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3123}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7e4d8f70ba994e1582d1022513ca1358", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3123}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3123}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1fd9b5082d82107065fb8ede54dbe078", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3127}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 3127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37fec548152f831e5b770e8dde6cc8df", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3127}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 3127}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea59593289d697448af6d0c7a55001c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 3139}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 3139}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "00503bf3f93523f050530fc8719d5911", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 3139}, "message": "{ (fixit)"}, {"location": {"col": 67, "file": 0, "line": 3139}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7ee4a078177c3a3f66699b73b18ee716", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3142}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3142}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f5b996586e5b4c8031439817a578d4db", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3142}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3142}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "48823161c3c78fd892f00898f5cba07f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 3146}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 3146}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c027be93fcc29a6001ca27ed4865602f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 3146}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 3146}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2b02e485d0d41ad1489a34cdf1cba3ad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 3154}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 3154}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "375382d4634c774a9379ffa0a3b37337", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 3154}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 3154}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6cc4e712b1f08fe8c1381fca534a644f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 3162}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 3162}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9c61f9641674d520ae7f73886227358f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 3162}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 3162}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9737bcb2184f7d8c2bcc999842c7ffc3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 3168}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 3168}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9c61f9641674d520ae7f73886227358f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 66, "file": 0, "line": 3168}, "message": "{ (fixit)"}, {"location": {"col": 65, "file": 0, "line": 3168}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9737bcb2184f7d8c2bcc999842c7ffc3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3175}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3175}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "380f9794451ff75b8319d13a087bb60e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3175}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3175}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "61d4370aabf22b797b464142e408e55e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 3177}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 3177}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0bf2011c6cdb6b96842596d481e908cd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 3177}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 3177}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8d06fbbb48b95b69543ed3bb7df5e480", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3193}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2ea6da25ff9dd377cd611560093ef901", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3193}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3193}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "60e407480483fb60d5ea24b03e6b9f2a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 3196}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 3196}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c51843f1b4ad2a9f3e703a297b9bd6c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 3196}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 3196}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e57e66182f4ba631235aa9a5f4ccf8ad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 3199}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 0, "line": 3199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "45aebf11d57796b48b4816ed2d9b7afc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 3199}, "message": "{ (fixit)"}, {"location": {"col": 57, "file": 0, "line": 3199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4abc3a1f732e8b764c298ddd0b202d4d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3202}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3202}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ba74182107ed95fcc79d23d73ff7d1f5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3202}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3202}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "df38cf2715bf59d70f29d8d5b74ca2d7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3205}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3205}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3cdb73b5b200885e11089fff88423bc2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 3205}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 3205}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1a3afd1c2044f3dd85f3726f5c46d888", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3208}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bebe2225eb59da62e0823a907c05e4ae", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3208}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1897be3897bb6ef6ab7c4d002dfdfc6d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3235}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3235}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c0bcde729e7a53f4523f0abba77bb710", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3235}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3235}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b55a1592d3439fc0b2dfaa49990da9ee", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 3239}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 3239}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aaca6559dace9d078d9147bab6baf605", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 3239}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 3239}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d62a16f2daeb473923be62eb576ef79", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3264}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3264}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "52355ade01d6dcc263111c8fbe41912d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3264}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3264}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3260928599d307c60d786cd613671b34", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 3267}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 3267}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aaca6559dace9d078d9147bab6baf605", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 3267}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 3267}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d62a16f2daeb473923be62eb576ef79", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 3282}, "message": "example recursive call chain, starting from function 'store_aff_word'"}, {"location": {"col": 19, "file": 0, "line": 3488}, "message": "Frame #1: function 'store_aff_word' calls function 'store_aff_word' here:"}, {"location": {"col": 19, "file": 0, "line": 3488}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 1, "file": 0, "line": 3282}, "message": "function 'store_aff_word' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "46785560dd56eef781ccd6ca6969bb81", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3302}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0499212c0c05071b4c20e2a68ff0ef9c", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 15, "file": 0, "line": 3364}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 15, "file": 0, "line": 3364}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8439ea7b5fafb2cfd94ef464f85300e8", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 0, "line": 3371}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ee4b28176444e934151b7e19ca26bcd4", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 39, "file": 0, "line": 3377}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 3377}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "39eb1074121aafcbc335bca4da374d55", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 3377}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 3377}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ba3ab4559c322f71bc883c832bbe8f8b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 17, "file": 0, "line": 3378}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 17, "file": 0, "line": 3378}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f750b13c5269895d597efb1e7f7ad3df", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3392}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b2be042ad740a8b84d58989d077a555d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3392}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "395ccdc8c17e7da069ab53b7826a66d6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 3402}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 3402}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4a65ef8ca3f70dff8fd9a34cdc4f9c0f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 3402}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 3402}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4514e543f8e90b232d141ac20f54b66a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 3408}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 3408}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d139fd7554d2ea644402c84cf0ab024f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 3408}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 3408}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fa400450f2eb70703ae0ad38e318aa5c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3412}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3412}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a92bae13d3e1786cf843e22d060f3850", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3412}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3412}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "272fdfff9b37343aca62dc2874f4de72", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 3419}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 3419}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "52945e385e3eb9ddfd6b78fcb7dc27d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 3419}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 3419}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0509aab5d1d14744d737bcbf7cf20716", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 3420}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 3420}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb5dbc8394ad5a6361fa202825eef497", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 3420}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 3420}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "adb94fdae592de7df1d12148e9ac719b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 3422}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 3422}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "81e0739e9ef6a14272bfccca7c33ee92", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 3422}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 3422}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b0e2ee317cd1440e5775219b8360cd71", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 3426}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 3426}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c2104e42d44e2a0d3ee67706985305bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 3426}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 3426}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9c1328698e97126e3ccd053be3cadd8f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3430}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3430}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a92bae13d3e1786cf843e22d060f3850", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 3430}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 3430}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "272fdfff9b37343aca62dc2874f4de72", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 3438}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 3438}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "93dfd2434f2269a71fa90298d69a9a3d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 3438}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 3438}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6f36c007831b28728f2be72421d3e609", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 3439}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 3439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb5dbc8394ad5a6361fa202825eef497", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 3439}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 3439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "adb94fdae592de7df1d12148e9ac719b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 3465}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 3465}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "297dd7a3e257caac7a08013fcce2791e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 59, "file": 0, "line": 3465}, "message": "{ (fixit)"}, {"location": {"col": 58, "file": 0, "line": 3465}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0e4ce17c0a90d1f4edc4402a85f17493", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3473}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3473}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3f466b7538ab8e94410f8562dc9a8f08", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 3473}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 3473}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f7994490f38d5830b3380cf3d6ecefec", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 3475}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 3475}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb0de601b114efc2227bdcba59129dc6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 3475}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 3475}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7d7c910791b7aabb5b38ed8c32b4a531", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 3482}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 3482}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "129c6975d0db17c84ac4b4c51e72b793", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 3482}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 3482}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ff56d9d6a7bf0d4cbc936b478c0da1be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3487}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2f030e363c3771609648ac9c827350fb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3487}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3487}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5ea7527b94667c93da33fcf41c1a7b06", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3492}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3492}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6c4d84a3fbc29eb144d24d3eaf7535f8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 3492}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 3492}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0f3abf84d6138b475fc8880bd673a5a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 3509}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 3509}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "18037a54d6382e4143455eab4f2efac1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 3509}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 3509}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1f382230e3bb3c5a0493229e8d81e888", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 3553}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 3553}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9efa57cac88688ac4102a12416079784", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 3553}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 3553}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b75d7716ae89c4df057953663c6cedf1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 3558}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 3558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "524c3ff822cb1330956ee7a8ef9c4bcd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 3558}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 3558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0ea005330f790b1f9f1504051389910c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3560}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 3560}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c5ade9a93cf7ff416ceda54b1e6ae6f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3560}, "message": "{ (fixit)"}, {"location": {"col": 16, "file": 0, "line": 3560}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e4e9d9c07e8391bad4075e03569bddc3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3596}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "059e908a6e78a5f4f376db3c07dc574c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3596}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a70edd7cd19e57952dcfe108d45935dc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 3616}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 3616}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "35321db810f2a9cfa38573e73f3977ca", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 0, "line": 3638}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 3638}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "263364b65f95a74b946c53c315606f8f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 3638}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 3638}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d108f53f56a08edba18294a17c13b89", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3640}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3640}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4ed9a83cf220164ddad3d11a9fe12998", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3640}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3640}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6f23986d5c12b24a962be588b79c05b4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3642}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3642}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b3eb59bf8b038a3c82d8a73206278f77", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3642}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3642}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8ef679ebf0b3570e92c82c050e66e1b4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3645}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 3645}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c9c3cb49640035153191083330c7c3f4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3645}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 3645}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "744d6461650e3cfb4066897de45a1af5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3707}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3707}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fb945b51a6e51a9d3e5550d66f95fcf2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3707}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3707}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c423e184b6e780872b7965120bb8b989", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 3810}, "message": "const (fixit)"}, {"location": {"col": 53, "file": 0, "line": 3810}, "message": "pointer parameter 'word' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a31ef7b5f381c56c53988c98421ce4f8", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3814}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "952d039d0c3805497a8724278e7f48f0", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3829}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3829}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "000cf3957a5dacac9d28329aefa2234e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3829}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3829}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "63e5744faa210af4aa7b0fdfb4944db4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3832}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3832}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fd11ffd30e431f091108ffe149720711", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3832}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3832}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3e2f9cee4042a5b660d4bfec865b0542", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 3843}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 3843}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "796237c1f4313516e21c41252dca4c76", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 3843}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 3843}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "027ee8cab40065e34bc279cccce3bcb2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3848}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3848}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "13cece5875bf003ba7fbdfe3c6b7fe94", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 3848}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 3848}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2aa6b5ef90296f314d3ed977831150a4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 3880}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 3880}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a56d807d75fa94ef4aa94b746930162a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 3880}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 3880}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1cb0628812795bfa59bcc131333a13dd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3888}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3888}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5f873d4d50cc43743bbd56b534a1584e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3888}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3888}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "152345013e652322a30ff5528e09536f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3894}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3894}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8d6301b5ada40254d6af817d85727bfe", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3894}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3894}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37e51a94b5f817903b082495103b5ba5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 3976}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 3976}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b9e5d8e9e0f4faaf870a50265f03e2d1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 3976}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 3976}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d22c13bd4b0f11959c1f1e9ed3abb265", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3995}, "message": "example recursive call chain, starting from function 'deref_wordnode'"}, {"location": {"col": 16, "file": 0, "line": 4004}, "message": "Frame #1: function 'deref_wordnode' calls function 'deref_wordnode' here:"}, {"location": {"col": 16, "file": 0, "line": 4004}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 12, "file": 0, "line": 3995}, "message": "function 'deref_wordnode' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cfdd64cfa5c2025df70ed64c51759bf1", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4003}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4003}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "565517e742c2ac0b60152cb9af62ad42", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4003}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4003}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1e884a9eb0a44fdb6111ba1b3d88d5e4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4042}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4042}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "021e47414972ccdb65dcb6a4de551685", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4042}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4042}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "41c1df6f77b1f830539e55da0fc309bb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4044}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4044}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5725857d46189049df619904e7ed1a26", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4044}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4044}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "36d4f8d23c30c61d4a9cb00b69c648a1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4046}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 4046}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4d3c60491570cf7a1df2fda8bbe115bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4046}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 4046}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8ea5ebe6016607197574a1ab857ad440", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 4062}, "message": "example recursive call chain, starting from function 'node_compress'"}, {"location": {"col": 21, "file": 0, "line": 4088}, "message": "Frame #1: function 'node_compress' calls function 'node_compress' here:"}, {"location": {"col": 21, "file": 0, "line": 4088}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 13, "file": 0, "line": 4062}, "message": "function 'node_compress' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "653dc029a85f9f5f4e4f5bceef96357d", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 4077}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3cd07c01f99692b8a09676ffa0d9af66", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4098}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4098}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "97594a2a583b5a119cc8365fcf6e0394", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4098}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4098}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "06445671cf5d114876c9703d0b5b46f3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 4116}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 4116}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a5bd87b10a03d16fc0916cb48da19766", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 4116}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 4116}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d52b86e822b7a1c2f5ef995877a258f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4130}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4130}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2f77b2543006ca1084df7991d69739b0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4130}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4130}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ed39d8816f66b6e4a76a14d8e0afc6eb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4133}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4133}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "81071747db3ba08988143a2703f392ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4133}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4133}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "28c6a32f7e0cbe34f210e6495ad5a170", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 4163}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 4163}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8087c7bb959cd6204ba7e04863952be9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 4163}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 4163}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cea6b211a72d1204e56a5603ae0d8ed3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 4169}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 4169}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9042783e5d163fcf53cc2cf6d919277c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 4169}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 4169}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8b9d9dbfe84f31fec6caf49400cfd7bb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4201}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d99f9f2743d7ab10471d2e6a1207d9c8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4201}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d282a07de78c357192fa539a3eaf43a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4228}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a2bdc2bb416fe7c1170e849cbba7db8e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4228}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4228}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "facb54aa0fa38581cc30aca192bde19e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4257}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4257}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "421c4bf6d1a21617c5b27c6531df5269", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4257}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4257}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7d901513df335643baeb98e9d1326742", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4259}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4259}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bd65c47d5f5884508da937a9560f7df2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4259}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4259}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "14d9b96d80bf63ed2fb781e377721013", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4299}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4299}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0f606a9fe29261f91bfcfdd7c0e8b0d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4299}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4299}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "676eeeaa17b3f05290a4c19b911c872d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4303}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4303}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e452ec5a71429626f0827d24337976f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4303}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4303}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "077642aaf183a1d33ee54dd48a9e0485", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4306}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 4306}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37fec548152f831e5b770e8dde6cc8df", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4306}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 4306}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea59593289d697448af6d0c7a55001c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 4310}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 4310}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "02fb873419a888347c8b602cc6c8ef9f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 4310}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 4310}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6d0b167ba1f731605341fdc32cf9b887", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4314}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6588f5113de4ec6fc00af5cd0d40b9b4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4314}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f4264ecb20995f2b8d0ec36e88b2bacd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4332}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4332}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b9389c57f59030dda9bee7187e6928a4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4332}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4332}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5a9f0496485e9c1b6817ed4f329fcb7f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4338}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4338}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2aba618a0ac9d8e1e2e71e827077d721", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4338}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4338}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5db234f6657cede7d2a0330e9fa6611a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4340}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4340}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "65240f195973e2ec5f36e11a58d9c701", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4340}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4340}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aa8d772bfd7fb51d1f184a4aeaca1cbc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4342}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4342}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7553b91bfd30876c0cdbbf85ff9f738e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4342}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4342}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fbab31d7276b2d0e76f020acbeb05ef8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 4357}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 4357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b4bf0a74e5b9edafee60eab345639044", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 4357}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 4357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c9b8ab8f5bbaaa5c2c6a2bc47afa562a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4395}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4395}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fc9e678303083648c1ebc5754094f474", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4395}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4395}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f91473a782e9946c8255288fe3c8d331", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4399}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4399}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "497bfd52c9a39ce38db1f20c2c67bf48", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4399}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4399}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea2b6af9803c77d344b7152d09c8c5b3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4403}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "772aa72cdefe6f6868e68bfbf7ce4f77", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4403}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4403}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4ea476c5a42604784e333fc738dbabd6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4512}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4512}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0f606a9fe29261f91bfcfdd7c0e8b0d9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4512}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4512}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "676eeeaa17b3f05290a4c19b911c872d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4514}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4514}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c95ff9ac47151c8377c700ff420ec06f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4514}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4514}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "123be886e8e586d0c0fa19b5e6db8429", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4516}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "81071747db3ba08988143a2703f392ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 4516}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 4516}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "28c6a32f7e0cbe34f210e6495ad5a170", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4537}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4537}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "491a857e995d6075f88228e5e6e0fd5d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4537}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4537}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9105d3041ba75e84b11816d059853545", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4540}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4540}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b139104c3dd5ee72d04aa1e2786a44da", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 4540}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 4540}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9a2db9b57ca6b90ac4a46bf3a6c30d82", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4543}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4543}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d99f9f2743d7ab10471d2e6a1207d9c8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4543}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4543}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d282a07de78c357192fa539a3eaf43a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4545}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4545}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "92c5225f8902f845084683677c65187d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4545}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4545}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d05b91e701540fd2a8c95a7fd2ed3ffe", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 4554}, "message": "example recursive call chain, starting from function 'clear_node'"}, {"location": {"col": 9, "file": 0, "line": 4564}, "message": "Frame #1: function 'clear_node' calls function 'clear_node' here:"}, {"location": {"col": 9, "file": 0, "line": 4564}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 13, "file": 0, "line": 4554}, "message": "function 'clear_node' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e1261ddcac629d2c234ac805c87ccd59", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4558}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cce509ed88b71572e4afd172720b5872", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4558}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7f7eb5dfc278e07db8239d8dadcfbbe0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4563}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4563}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "900b60c562b8a215499faebce7b5949b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4563}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4563}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea6debe91f8a92b901e38f5d4328ca64", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 4580}, "message": "example recursive call chain, starting from function 'put_node'"}, {"location": {"col": 18, "file": 0, "line": 4675}, "message": "Frame #1: function 'put_node' calls function 'put_node' here:"}, {"location": {"col": 18, "file": 0, "line": 4675}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 1, "file": 0, "line": 4580}, "message": "function 'put_node' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c0f133b9aabaceadcb90b072ec127502", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4589}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4589}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9ee8486c5843ab38db1c8a2075158f64", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 4589}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 4589}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "07fa897b50fdeef70e9adaf6eb494697", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4597}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4597}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1f7c45b6781e6df78555b88785465ea3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4597}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4597}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "060b9b954bcfc0dfe7c5d0218bbbb809", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 4601}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 4601}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "15d497eec0009f97013be54b4a2274cf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 4601}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 4601}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "419a9b4f23c0dd4bd92d4e571d48ad86", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 4614}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 4614}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e73b82b2abad9e1a02c7f15e4c233131", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 4614}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 4614}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "75a9c15f5f9ffd04492e409d74a9cb6e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4625}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4625}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1e21a328ffef459781b48a4e8694428e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 4625}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 4625}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0500ba910e93964fa2eed518da57e930", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4627}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4627}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b2e3b1cb317d5232683c68baadd83bed", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4627}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4627}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9c05117c81c359a275de0e6fcfb200c2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4641}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4641}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "7221bd8b4b9e4936e9795a411cdd98b5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4641}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4641}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "727e34e673571ab83669a4c77a3c4a4a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4643}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4643}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e4393304197dbcdba6a9a70817e083b3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4643}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4643}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c74e44fc7463f9a06e4107ddf56e02ce", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 4656}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 4656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "84a512622adc8c59902966dc020aaf64", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 4656}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 4656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6172bb4af30ce9114f800e005e688f3f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4660}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4660}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "83ddc9330122d70967352b5c35d78988", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4660}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4660}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ee514543a6daae6e9a40800d80432175", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4673}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4673}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1f7c45b6781e6df78555b88785465ea3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4673}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4673}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "060b9b954bcfc0dfe7c5d0218bbbb809", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4674}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4674}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1c7ea666baf62227dfd996fad8112972", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 4674}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 4674}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "f01067ef9f7088829190e2862e64caa2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 4727}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 4727}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "79b9e54c6e1e35faeb2c92134e3a2c36", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 4727}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 4727}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fd8247effb40ad352e9cb3a9b27a15d2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 4743}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 4743}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "309dc01766b5ff70d887b47c904a314c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 4743}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 4743}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "dbe966cc698f5d498509fc709b4beb69", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4750}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4750}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "5d6955bf2e7c9fa7a4c0a9c186db8443", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4750}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4750}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6e6b00391b6299659ef07964c9ee731b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 4771}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 4771}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3c1bc7269fe301ebf05b83a585c90a74", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 4771}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 4771}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bf825c405b144784029911af6ae4a2fd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 4812}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 4812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "eb0cbc27486d7b981b4850df765f8115", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 4812}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 4812}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cc01d6f5eaf71970cc5f5ba01a34cb3e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4833}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4833}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9b544f0cc716aa301160ed6cd8fb4265", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4833}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4833}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "187cbb4b1871bc588a6466b1572cc5ff", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 73, "file": 0, "line": 4883}, "message": "{ (fixit)"}, {"location": {"col": 72, "file": 0, "line": 4883}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3de61a43ff43f3c4cfff9c667691e88e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 73, "file": 0, "line": 4883}, "message": "{ (fixit)"}, {"location": {"col": 72, "file": 0, "line": 4883}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "3bd98a5accb106fe3420c92822ec1b96", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 4894}, "message": "example recursive call chain, starting from function 'sug_filltable'"}, {"location": {"col": 16, "file": 0, "line": 4943}, "message": "Frame #1: function 'sug_filltable' calls function 'sug_filltable' here:"}, {"location": {"col": 16, "file": 0, "line": 4943}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 1, "file": 0, "line": 4894}, "message": "function 'sug_filltable' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d41a563e47fe5ecb69f6201cc2a0bc93", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 4901}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fdf0af7cdbe663d352f1f77fc44b93db", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 0, "line": 4935}, "message": "{ (fixit)"}, {"location": {"col": 69, "file": 0, "line": 4935}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a811f08574914d216c7510012c604cf7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 70, "file": 0, "line": 4935}, "message": "{ (fixit)"}, {"location": {"col": 69, "file": 0, "line": 4935}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8124bd0895618a2cdf8f9baf3bbe82d8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4944}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4944}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ce1c6b731b73e959711701c058faab3a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4944}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4944}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "465cc10eada80fb75a7d4dc125988d91", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 4957}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "668984b7361128613380e7255d500253", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 5052}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 5052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "491a857e995d6075f88228e5e6e0fd5d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 5052}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 5052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9105d3041ba75e84b11816d059853545", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5125}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 5125}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "37fec548152f831e5b770e8dde6cc8df", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5125}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 5125}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ea59593289d697448af6d0c7a55001c0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 0, "line": 5131}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 5131}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ad929b6b9b475a7dcd013df57009d768", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 0, "line": 5131}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 5131}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d5eafdf754ddc4e36139ee22f0cd8984", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 5135}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 5135}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "694e66d4f307f7dc1bd790aa19f9e970", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 5135}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 5135}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0fc460e8e72199ba90089bbbad573c9e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 5187}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 5187}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "54dea7be9779fbd5c05afb80362d1d3f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 5187}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 5187}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a61001ce8fd52b9f2acdc3cbdd8a398b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 5202}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 5202}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6863c17e7d3b985cc0d65c420b12762a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 5202}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 5202}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "38eb7111ee64fb1b3387f9d11305efc9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 5208}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 5208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "20059a5fc770db6c3f477e467af4246e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 63, "file": 0, "line": 5208}, "message": "{ (fixit)"}, {"location": {"col": 62, "file": 0, "line": 5208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "18b7152aaea0eb0939eeb39d0ade1df6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 5214}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 5214}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "bd1b39ce642de351ffdc1cca619ce72b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 5214}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 5214}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "124dc5b55063cf8419418653ce74e0af", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 5222}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 5222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "59df4e10ab87c4f707c99adc892916c0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 5222}, "message": "{ (fixit)"}, {"location": {"col": 54, "file": 0, "line": 5222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "cbb48edf53af100e3cb3abdb071023a7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5247}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5247}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "14f71e1dfc9382a3f35368b45f336373", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5247}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5247}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a189b31fcdab18f91078ee61da2b7d06", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 5261}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 5261}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fc92ac9fe5ebf516de2d23650897af67", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 5261}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 5261}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "1766f1e0b0b15279d28c2190b51ceb1b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 5262}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 5262}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "efb3df349d039c302908f5f192114c7f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 5262}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 5262}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "0c940b910ad1633bda3d1bebcaa08ad6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 5270}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 5270}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8f276d251dc42eb54fccc7a0ea742963", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 5270}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 5270}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "306c3fc944aa4264b8c6e6e96f11bd5d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5286}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5286}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2f6c92d869ee6ee081816c34402367d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5286}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5286}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "65600b4b9c4eea1908a209d682370383", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5290}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5290}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "2f6c92d869ee6ee081816c34402367d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5290}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5290}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "65600b4b9c4eea1908a209d682370383", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5325}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "397420ff14240616a867458886bb3dca", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5332}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5332}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c6b2169b0895f65bf593d9577256452f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5332}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5332}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "746c508e6adbe1a9f28e0b532327111f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5351}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5351}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9e7630773519d98205c3cbd59a6f936f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5351}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5351}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a7b0ed6120bbf6086db5f7ac3523d1f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 5362}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 5362}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "aa6600fe616bce971503d2ee7f5b5d80", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 5362}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 5362}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6e2ebcbca0b21f6957b894db463d4d84", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 5405}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 5405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "83ddc9330122d70967352b5c35d78988", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 5405}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 5405}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "ee514543a6daae6e9a40800d80432175", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5453}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 5453}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9709bd4fbcb22db8605dc712aa1bbe18", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5453}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 5453}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "6dbd67e906c93aae5dce21fa06f9a783", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 5478}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 5478}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "54f5bbabf276dd3574e9ed8f849f7b9c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 5478}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 5478}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "306fbd3014c0a5a65a89673da8d91bb2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5488}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5488}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "9b9b6ae13821c5fa173bbde29b4f462c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5488}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5488}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "fd26b441c601cf6353b05ba89c3264df", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5493}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 5493}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4d3c60491570cf7a1df2fda8bbe115bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5493}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 5493}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "8ea5ebe6016607197574a1ab857ad440", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5499}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "c4fa9bd5a1f37b771671d021a3eb469f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5499}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "e33b1cb71a853518566b33e86b764a1d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5535}, "message": "const (fixit)"}, {"location": {"col": 13, "file": 0, "line": 5535}, "message": "pointer parameter 'flags' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "20e42a1bdd7f6e716516ec5396e3c4e6", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 5558}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 5558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "058e7557725f124f221f0d42732f5afa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 5558}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 5558}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "68dd1ada8e366a15b4ac21c7643725d6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5596}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "15d497eec0009f97013be54b4a2274cf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 5596}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 5596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "419a9b4f23c0dd4bd92d4e571d48ad86", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5612}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5612}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "36ff22ece05146033a8ba9394a0835f4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5612}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5612}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "44d4656596c1aeea8ee1319c1e5bf1a9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 5635}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 5635}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "b30106e7286823210ec8caaf1b07dd3f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 5635}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 5635}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "4b6327ea4520aad2c750e16ddb9d81a5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 5676}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 5676}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "a5bd87b10a03d16fc0916cb48da19766", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 5676}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 5676}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/spellfile.c", "reportHash": "d52b86e822b7a1c2f5ef995877a258f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
