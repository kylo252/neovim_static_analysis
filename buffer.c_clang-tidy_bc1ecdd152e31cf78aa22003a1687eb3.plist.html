<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "src/nvim/buffer.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n//\n// buffer.c: functions for dealing with the buffer structure\n//\n\n//\n// The buffer list is a double linked list of all buffers.\n// Each buffer can be in one of these states:\n// never loaded: BF_NEVERLOADED is set, only the file name is valid\n//   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n//       hidden: b_nwindows == 0, loaded but not displayed in a window\n//       normal: loaded and displayed in a window\n//\n// Instead of storing file names all over the place, each file name is\n// stored in the buffer list. It can be referenced by a number.\n//\n// The current implementation remembers all file names ever used.\n//\n\n#include <stdbool.h>\n#include <string.h>\n#include <inttypes.h>\n#include <assert.h>\n\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/api/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/assert.h\"\n#include \"nvim/channel.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/file_search.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/highlight.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/extmark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/move.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/sign.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/version.h\"\n#include \"nvim/window.h\"\n#include \"nvim/shada.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/buffer_updates.h\"\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"buffer.c.generated.h\"\n#endif\n\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n#define MAX_STL_EVAL_DEPTH 100\n\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\nstatic char *e_auabort = N_(\"E855: Autocommands caused command to abort\");\n\n// Number of times free_buffer() was called.\nstatic int buf_free_count = 0;\n\ntypedef enum {\n  kBffClearWinInfo = 1,\n  kBffInitChangedtick = 2,\n} BufFreeFlags;\n\n// Read data from buffer for retrying.\nstatic int\nread_buffer(\n    int     read_stdin,     // read file from stdin, otherwise fifo\n    exarg_T *eap,           // for forced 'ff' and 'fenc' or NULL\n    int     flags)          // extra flags for readfile()\n{\n  int       retval = OK;\n  linenr_T  line_count;\n\n  //\n  // Read from the buffer which the text is already filled in and append at\n  // the end.  This makes it possible to retry when 'fileformat' or\n  // 'fileencoding' was guessed wrong.\n  //\n  line_count = curbuf->b_ml.ml_line_count;\n  retval = readfile(\n      read_stdin ? NULL : curbuf->b_ffname,\n      read_stdin ? NULL : curbuf->b_fname,\n      (linenr_T)line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n      flags | READ_BUFFER);\n  if (retval == OK) {\n    // Delete the binary lines.\n    while (--line_count >= 0) {\n      ml_delete((linenr_T)1, false);\n    }\n  } else {\n    // Delete the converted lines.\n    while (curbuf->b_ml.ml_line_count > line_count) {\n      ml_delete(line_count, false);\n    }\n  }\n  // Put the cursor on the first line.\n  curwin->w_cursor.lnum = 1;\n  curwin->w_cursor.col = 0;\n\n  if (read_stdin) {\n    // Set or reset 'modified' before executing autocommands, so that\n    // it can be changed there.\n    if (!readonlymode && !buf_is_empty(curbuf)) {\n      changed();\n    } else if (retval != FAIL) {\n      unchanged(curbuf, false, true);\n    }\n\n    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, false,\n                          curbuf, &retval);\n  }\n  return retval;\n}\n\n// Open current buffer, that is: open the memfile and read the file into\n// memory.\n// Return FAIL for failure, OK otherwise.\nint open_buffer(\n    int read_stdin,   // read file from stdin\n    exarg_T *eap,     // for forced 'ff' and 'fenc' or NULL\n    int flags         // extra flags for readfile()\n)\n{\n  int retval = OK;\n  bufref_T       old_curbuf;\n  long old_tw = curbuf->b_p_tw;\n  int read_fifo = false;\n\n  /*\n   * The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n   * When re-entering the same buffer, it should not change, because the\n   * user may have reset the flag by hand.\n   */\n  if (readonlymode && curbuf->b_ffname != NULL\n      && (curbuf->b_flags & BF_NEVERLOADED))\n    curbuf->b_p_ro = true;\n\n  if (ml_open(curbuf) == FAIL) {\n    /*\n     * There MUST be a memfile, otherwise we can't do anything\n     * If we can't create one for the current buffer, take another buffer\n     */\n    close_buffer(NULL, curbuf, 0, false);\n\n    curbuf = NULL;\n    FOR_ALL_BUFFERS(buf) {\n      if (buf->b_ml.ml_mfp != NULL) {\n        curbuf = buf;\n        break;\n      }\n    }\n\n    // If there is no memfile at all, exit.\n    // This is OK, since there are no changes to lose.\n    if (curbuf == NULL) {\n      EMSG(_(\"E82: Cannot allocate any buffer, exiting...\"));\n\n      // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n      // will work.\n      v_dying = 2;\n      getout(2);\n    }\n\n    EMSG(_(\"E83: Cannot allocate buffer, using other one...\"));\n    enter_buffer(curbuf);\n    if (old_tw != curbuf->b_p_tw) {\n      check_colorcolumn(curwin);\n    }\n    return FAIL;\n  }\n\n  // The autocommands in readfile() may change the buffer, but only AFTER\n  // reading the file.\n  set_bufref(&old_curbuf, curbuf);\n  modified_was_set = false;\n\n  // mark cursor position as being invalid\n  curwin->w_valid = 0;\n\n  if (curbuf->b_ffname != NULL) {\n    int old_msg_silent = msg_silent;\n#ifdef UNIX\n    int save_bin = curbuf->b_p_bin;\n    int perm;\n\n    perm = os_getperm((const char *)curbuf->b_ffname);\n    if (perm >= 0 && (0 || S_ISFIFO(perm)\n                      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n                      || (S_ISCHR(perm)\n                          && is_dev_fd_file(curbuf->b_ffname))\n# endif\n                      )\n        ) {\n      read_fifo = true;\n    }\n    if (read_fifo) {\n      curbuf->b_p_bin = true;\n    }\n#endif\n    if (shortmess(SHM_FILEINFO)) {\n      msg_silent = 1;\n    }\n\n    retval = readfile(curbuf->b_ffname, curbuf->b_fname,\n                      (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n                      flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n    if (read_fifo) {\n      curbuf->b_p_bin = save_bin;\n      if (retval == OK) {\n        retval = read_buffer(false, eap, flags);\n      }\n    }\n#endif\n    msg_silent = old_msg_silent;\n\n    // Help buffer is filtered.\n    if (bt_help(curbuf)) {\n      fix_help_buffer();\n    }\n  } else if (read_stdin) {\n    int save_bin = curbuf->b_p_bin;\n\n    /*\n     * First read the text in binary mode into the buffer.\n     * Then read from that same buffer and append at the end.  This makes\n     * it possible to retry when 'fileformat' or 'fileencoding' was\n     * guessed wrong.\n     */\n    curbuf->b_p_bin = true;\n    retval = readfile(NULL, NULL, (linenr_T)0,\n        (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n        flags | (READ_NEW + READ_STDIN));\n    curbuf->b_p_bin = save_bin;\n    if (retval == OK) {\n      retval = read_buffer(true, eap, flags);\n    }\n  }\n\n  // if first time loading this buffer, init b_chartab[]\n  if (curbuf->b_flags & BF_NEVERLOADED) {\n    (void)buf_init_chartab(curbuf, false);\n    parse_cino(curbuf);\n  }\n\n  // Set/reset the Changed flag first, autocmds may change the buffer.\n  // Apply the automatic commands, before processing the modelines.\n  // So the modelines have priority over autocommands.\n\n  // When reading stdin, the buffer contents always needs writing, so set\n  // the changed flag.  Unless in readonly mode: \"ls | nvim -R -\".\n  // When interrupted and 'cpoptions' contains 'i' set changed flag.\n  if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n      || modified_was_set               // \":set modified\" used in autocmd\n      || (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)) {\n    changed();\n  } else if (retval != FAIL && !read_stdin && !read_fifo) {\n    unchanged(curbuf, false, true);\n  }\n  save_file_ff(curbuf);                 // keep this fileformat\n\n  // Set last_changedtick to avoid triggering a TextChanged autocommand right\n  // after it was added.\n  curbuf->b_last_changedtick = buf_get_changedtick(curbuf);\n  curbuf->b_last_changedtick_pum = buf_get_changedtick(curbuf);\n\n  // require \"!\" to overwrite the file, because it wasn't read completely\n  if (aborting()) {\n    curbuf->b_flags |= BF_READERR;\n  }\n\n  /* Need to update automatic folding.  Do this before the autocommands,\n   * they may use the fold info. */\n  foldUpdateAll(curwin);\n\n  // need to set w_topline, unless some autocommand already did that.\n  if (!(curwin->w_valid & VALID_TOPLINE)) {\n    curwin->w_topline = 1;\n    curwin->w_topfill = 0;\n  }\n  apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, false, curbuf, &retval);\n\n  if (retval == FAIL) {\n    return FAIL;\n  }\n\n  /*\n   * The autocommands may have changed the current buffer.  Apply the\n   * modelines to the correct buffer, if it still exists and is loaded.\n   */\n  if (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL) {\n    aco_save_T aco;\n\n    // Go to the buffer that was opened.\n    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n    do_modelines(0);\n    curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, false, curbuf,\n                          &retval);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n  }\n\n  return retval;\n}\n\n/// Store \"buf\" in \"bufref\" and set the free count.\n///\n/// @param bufref Reference to be used for the buffer.\n/// @param buf    The buffer to reference.\nvoid set_bufref(bufref_T *bufref, buf_T *buf)\n{\n  bufref->br_buf = buf;\n  bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n  bufref->br_buf_free_count = buf_free_count;\n}\n\n/// Return true if \"bufref->br_buf\" points to the same buffer as when\n/// set_bufref() was called and it is a valid buffer.\n/// Only goes through the buffer list if buf_free_count changed.\n/// Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n/// the same allocated memory, but it's a different buffer.\n///\n/// @param bufref Buffer reference to check for.\nbool bufref_valid(bufref_T *bufref)\n{\n  return bufref->br_buf_free_count == buf_free_count\n    ? true\n    : buf_valid(bufref->br_buf) && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/// Check that \"buf\" points to a valid buffer in the buffer list.\n///\n/// Can be slow if there are many buffers, prefer using bufref_valid().\n///\n/// @param buf The buffer to check for.\nbool buf_valid(buf_T *buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (buf == NULL) {\n    return false;\n  }\n  // Assume that we more often have a recent buffer,\n  // start with the last one.\n  for (buf_T *bp = lastbuf; bp != NULL; bp = bp->b_prev) {\n    if (bp == buf) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Close the link to a buffer.\n///\n/// @param win    If not NULL, set b_last_cursor.\n/// @param buf\n/// @param action Used when there is no longer a window for the buffer.\n///               Possible values:\n///                 0            buffer becomes hidden\n///                 DOBUF_UNLOAD buffer is unloaded\n///                 DOBUF_DELETE buffer is unloaded and removed from buffer list\n///                 DOBUF_WIPE   buffer is unloaded and really deleted\n///               When doing all but the first one on the current buffer, the\n///               caller should get a new buffer very soon!\n///               The 'bufhidden' option can force freeing and deleting.\n/// @param abort_if_last\n///               If true, do not close the buffer if autocommands cause\n///               there to be only one window with this buffer. e.g. when\n///               \":quit\" is supposed to close the window but autocommands\n///               close all other windows.\n/// @returns true when we got to the end and b_nwindows was decremented.\nbool close_buffer(win_T *win, buf_T *buf, int action, bool abort_if_last)\n{\n  bool unload_buf = (action != 0);\n  bool del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);\n  bool wipe_buf = (action == DOBUF_WIPE);\n\n  bool is_curwin = (curwin != NULL && curwin->w_buffer == buf);\n  win_T *the_curwin = curwin;\n  tabpage_T *the_curtab = curtab;\n\n  // Force unloading or deleting when 'bufhidden' says so, but not for terminal\n  // buffers.\n  // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n  // \"hide\" (otherwise we could never free or delete a buffer).\n  if (!buf->terminal) {\n    if (buf->b_p_bh[0] == 'd') {         // 'bufhidden' == \"delete\"\n      del_buf = true;\n      unload_buf = true;\n    } else if (buf->b_p_bh[0] == 'w') {  // 'bufhidden' == \"wipe\"\n      del_buf = true;\n      unload_buf = true;\n      wipe_buf = true;\n    } else if (buf->b_p_bh[0] == 'u')    // 'bufhidden' == \"unload\"\n      unload_buf = true;\n  }\n\n  if (buf->terminal && (unload_buf || del_buf || wipe_buf)) {\n    // terminal buffers can only be wiped\n    unload_buf = true;\n    del_buf = true;\n    wipe_buf = true;\n  }\n\n  // Disallow deleting the buffer when it is locked (already being closed or\n  // halfway a command that relies on it). Unloading is allowed.\n  if (buf->b_locked > 0 && (del_buf || wipe_buf)) {\n    EMSG(_(\"E937: Attempt to delete a buffer that is in use\"));\n    return false;\n  }\n\n  if (win != NULL  // Avoid bogus clang warning.\n      && win_valid_any_tab(win)) {\n    // Set b_last_cursor when closing the last window for the buffer.\n    // Remember the last cursor position and window options of the buffer.\n    // This used to be only for the current window, but then options like\n    // 'foldmethod' may be lost with a \":only\" command.\n    if (buf->b_nwindows == 1) {\n      set_last_cursor(win);\n    }\n    buflist_setfpos(buf, win,\n                    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n                    win->w_cursor.col, true);\n  }\n\n  bufref_T bufref;\n  set_bufref(&bufref, buf);\n\n  // When the buffer is no longer in a window, trigger BufWinLeave\n  if (buf->b_nwindows == 1) {\n    buf->b_locked++;\n    if (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname, false,\n                       buf) && !bufref_valid(&bufref)) {\n      // Autocommands deleted the buffer.\n      EMSG(_(e_auabort));\n      return false;\n    }\n    buf->b_locked--;\n    if (abort_if_last && last_nonfloat(win)) {\n      // Autocommands made this the only window.\n      EMSG(_(e_auabort));\n      return false;\n    }\n\n    // When the buffer becomes hidden, but is not unloaded, trigger\n    // BufHidden\n    if (!unload_buf) {\n      buf->b_locked++;\n      if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname, false,\n                         buf) && !bufref_valid(&bufref)) {\n        // Autocommands deleted the buffer.\n        EMSG(_(e_auabort));\n        return false;\n      }\n      buf->b_locked--;\n      if (abort_if_last && last_nonfloat(win)) {\n        // Autocommands made this the only window.\n        EMSG(_(e_auabort));\n        return false;\n      }\n    }\n    if (aborting()) {       // autocmds may abort script processing\n      return false;\n    }\n  }\n\n  // If the buffer was in curwin and the window has changed, go back to that\n  // window, if it still exists.  This avoids that \":edit x\" triggering a\n  // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n  if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin)) {\n    block_autocmds();\n    goto_tabpage_win(the_curtab, the_curwin);\n    unblock_autocmds();\n  }\n\n  int nwindows = buf->b_nwindows;\n\n  // decrease the link count from windows (unless not in any window)\n  if (buf->b_nwindows > 0) {\n    buf->b_nwindows--;\n  }\n\n  if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0) {\n    diff_buf_delete(buf);   // Clear 'diff' for hidden buffer.\n  }\n\n  /* Return when a window is displaying the buffer or when it's not\n   * unloaded. */\n  if (buf->b_nwindows > 0 || !unload_buf) {\n    return false;\n  }\n\n  if (buf->terminal) {\n    terminal_close(buf->terminal, -1);\n  }\n\n  // Always remove the buffer when there is no file name.\n  if (buf->b_ffname == NULL) {\n    del_buf = true;\n  }\n\n  // Free all things allocated for this buffer.\n  // Also calls the \"BufDelete\" autocommands when del_buf is true.\n  // Remember if we are closing the current buffer.  Restore the number of\n  // windows, so that autocommands in buf_freeall() don't get confused.\n  bool is_curbuf = (buf == curbuf);\n\n  // When closing the current buffer stop Visual mode before freeing\n  // anything.\n  if (is_curbuf && VIsual_active\n#if defined(EXITFREE)\n      && !entered_free_all_mem\n#endif\n      ) {\n    end_visual_mode();\n  }\n\n  buf->b_nwindows = nwindows;\n\n  buf_freeall(buf, (del_buf ? BFA_DEL : 0) + (wipe_buf ? BFA_WIPE : 0));\n\n  if (!bufref_valid(&bufref)) {\n    // Autocommands may have deleted the buffer.\n    return false;\n  }\n  if (aborting()) {\n    // Autocmds may abort script processing.\n    return false;\n  }\n\n  /*\n   * It's possible that autocommands change curbuf to the one being deleted.\n   * This might cause the previous curbuf to be deleted unexpectedly.  But\n   * in some cases it's OK to delete the curbuf, because a new one is\n   * obtained anyway.  Therefore only return if curbuf changed to the\n   * deleted buffer.\n   */\n  if (buf == curbuf && !is_curbuf) {\n    return false;\n  }\n\n  if (win != NULL  // Avoid bogus clang warning.\n      && win_valid_any_tab(win)\n      && win->w_buffer == buf) {\n    win->w_buffer = NULL;  // make sure we don't use the buffer now\n  }\n\n  // Autocommands may have opened or closed windows for this buffer.\n  // Decrement the count for the close we do here.\n  if (buf->b_nwindows > 0) {\n    buf->b_nwindows--;\n  }\n\n  // Change directories when the 'acd' option is set.\n  do_autochdir();\n\n  // Disable buffer-updates for the current buffer.\n  // No need to check `unload_buf`: in that case the function returned above.\n  buf_updates_unload(buf, false);\n\n  /*\n   * Remove the buffer from the list.\n   */\n  if (wipe_buf) {\n    if (buf->b_sfname != buf->b_ffname) {\n      XFREE_CLEAR(buf->b_sfname);\n    } else {\n      buf->b_sfname = NULL;\n    }\n    XFREE_CLEAR(buf->b_ffname);\n    if (buf->b_prev == NULL) {\n      firstbuf = buf->b_next;\n    } else {\n      buf->b_prev->b_next = buf->b_next;\n    }\n    if (buf->b_next == NULL) {\n      lastbuf = buf->b_prev;\n    } else {\n      buf->b_next->b_prev = buf->b_prev;\n    }\n    free_buffer(buf);\n  } else {\n    if (del_buf) {\n      // Free all internal variables and reset option values, to make\n      // \":bdel\" compatible with Vim 5.7.\n      free_buffer_stuff(buf, kBffClearWinInfo | kBffInitChangedtick);\n\n      // Make it look like a new buffer.\n      buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n      // Init the options when loaded again.\n      buf->b_p_initialized = false;\n    }\n    buf_clear_file(buf);\n    if (del_buf) {\n      buf->b_p_bl = false;\n    }\n  }\n  // NOTE: at this point \"curbuf\" may be invalid!\n  return true;\n}\n\n/// Make buffer not contain a file.\nvoid buf_clear_file(buf_T *buf)\n{\n  buf->b_ml.ml_line_count = 1;\n  unchanged(buf, true, true);\n  buf->b_p_eol = true;\n  buf->b_start_eol = true;\n  buf->b_p_bomb = false;\n  buf->b_start_bomb = false;\n  buf->b_ml.ml_mfp = NULL;\n  buf->b_ml.ml_flags = ML_EMPTY;                // empty buffer\n}\n\n/// Clears the current buffer contents.\nvoid buf_clear(void)\n{\n  linenr_T line_count = curbuf->b_ml.ml_line_count;\n  while (!(curbuf->b_ml.ml_flags & ML_EMPTY)) {\n    ml_delete((linenr_T)1, false);\n  }\n  deleted_lines_mark(1, line_count);  // prepare for display\n  ml_close(curbuf, true);             // free memline_T\n  buf_clear_file(curbuf);\n}\n\n/// buf_freeall() - free all things allocated for a buffer that are related to\n/// the file.  Careful: get here with \"curwin\" NULL when exiting.\n///\n/// @param flags BFA_DEL buffer is going to be deleted\n///              BFA_WIPE buffer is going to be wiped out\n///              BFA_KEEP_UNDO  do not free undo information\nvoid buf_freeall(buf_T *buf, int flags)\n{\n  bool is_curbuf = (buf == curbuf);\n  int is_curwin = (curwin != NULL && curwin->w_buffer == buf);\n  win_T *the_curwin = curwin;\n  tabpage_T *the_curtab = curtab;\n\n  // Make sure the buffer isn't closed by autocommands.\n  buf->b_locked++;\n\n  bufref_T bufref;\n  set_bufref(&bufref, buf);\n\n  if ((buf->b_ml.ml_mfp != NULL)\n      && apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname, false, buf)\n      && !bufref_valid(&bufref)) {\n    // Autocommands deleted the buffer.\n    return;\n  }\n  if ((flags & BFA_DEL)\n      && buf->b_p_bl\n      && apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname, false, buf)\n      && !bufref_valid(&bufref)) {\n    // Autocommands may delete the buffer.\n    return;\n  }\n  if ((flags & BFA_WIPE)\n      && apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname, false,\n                        buf)\n      && !bufref_valid(&bufref)) {\n    // Autocommands may delete the buffer.\n    return;\n  }\n  buf->b_locked--;\n\n  // If the buffer was in curwin and the window has changed, go back to that\n  // window, if it still exists.  This avoids that \":edit x\" triggering a\n  // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n  if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin)) {\n    block_autocmds();\n    goto_tabpage_win(the_curtab, the_curwin);\n    unblock_autocmds();\n  }\n  if (aborting()) {  // autocmds may abort script processing\n    return;\n  }\n\n  /*\n   * It's possible that autocommands change curbuf to the one being deleted.\n   * This might cause curbuf to be deleted unexpectedly.  But in some cases\n   * it's OK to delete the curbuf, because a new one is obtained anyway.\n   * Therefore only return if curbuf changed to the deleted buffer.\n   */\n  if (buf == curbuf && !is_curbuf) {\n    return;\n  }\n  diff_buf_delete(buf);             // Can't use 'diff' for unloaded buffer.\n  // Remove any ownsyntax, unless exiting.\n  if (curwin != NULL && curwin->w_buffer == buf) {\n    reset_synblock(curwin);\n  }\n\n  // No folds in an empty buffer.\n  FOR_ALL_TAB_WINDOWS(tp, win) {\n    if (win->w_buffer == buf) {\n      clearFolding(win);\n    }\n  }\n\n  ml_close(buf, true);              // close and delete the memline/memfile\n  buf->b_ml.ml_line_count = 0;      // no lines in buffer\n  if ((flags & BFA_KEEP_UNDO) == 0) {\n    u_blockfree(buf);               // free the memory allocated for undo\n    u_clearall(buf);                // reset all undo information\n  }\n  syntax_clear(&buf->b_s);          // reset syntax info\n  buf->b_flags &= ~BF_READERR;      // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\nstatic void free_buffer(buf_T *buf)\n{\n  pmap_del(handle_T)(&buffer_handles, buf->b_fnum);\n  buf_free_count++;\n  // b:changedtick uses an item in buf_T.\n  free_buffer_stuff(buf, kBffClearWinInfo);\n  if (buf->b_vars->dv_refcount > DO_NOT_FREE_CNT) {\n    tv_dict_add(buf->b_vars,\n                tv_dict_item_copy((dictitem_T *)(&buf->changedtick_di)));\n  }\n  unref_var_dict(buf->b_vars);\n  aubuflocal_remove(buf);\n  tv_dict_unref(buf->additional_data);\n  xfree(buf->b_prompt_text);\n  callback_free(&buf->b_prompt_callback);\n  callback_free(&buf->b_prompt_interrupt);\n  clear_fmark(&buf->b_last_cursor);\n  clear_fmark(&buf->b_last_insert);\n  clear_fmark(&buf->b_last_change);\n  for (size_t i = 0; i < NMARKS; i++) {\n    free_fmark(buf->b_namedm[i]);\n  }\n  for (int i = 0; i < buf->b_changelistlen; i++) {\n    free_fmark(buf->b_changelist[i]);\n  }\n  if (autocmd_busy) {\n    // Do not free the buffer structure while autocommands are executing,\n    // it's still needed. Free it when autocmd_busy is reset.\n    memset(&buf->b_namedm[0], 0, sizeof(buf->b_namedm));\n    memset(&buf->b_changelist[0], 0, sizeof(buf->b_changelist));\n    buf->b_next = au_pending_free_buf;\n    au_pending_free_buf = buf;\n  } else {\n    xfree(buf);\n  }\n}\n\n/// Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n///\n/// @param buf  Buffer pointer\n/// @param free_flags  BufFreeFlags\nstatic void free_buffer_stuff(buf_T *buf, int free_flags)\n{\n  if (free_flags & kBffClearWinInfo) {\n    clear_wininfo(buf);                 // including window-local options\n    free_buf_options(buf, true);\n    ga_clear(&buf->b_s.b_langp);\n  }\n  {\n    // Avoid losing b:changedtick when deleting buffer: clearing variables\n    // implies using clear_tv() on b:changedtick and that sets changedtick to\n    // zero.\n    hashitem_T *const changedtick_hi = hash_find(\n        &buf->b_vars->dv_hashtab, (const char_u *)\"changedtick\");\n    assert(changedtick_hi != NULL);\n    hash_remove(&buf->b_vars->dv_hashtab, changedtick_hi);\n  }\n  vars_clear(&buf->b_vars->dv_hashtab);   // free all internal variables\n  hash_init(&buf->b_vars->dv_hashtab);\n  if (free_flags & kBffInitChangedtick) {\n    buf_init_changedtick(buf);\n  }\n  uc_clear(&buf->b_ucmds);               // clear local user commands\n  buf_delete_signs(buf, (char_u *)\"*\");  // delete any signs\n  extmark_free_all(buf);                 // delete any extmarks\n  map_clear_int(buf, MAP_ALL_MODES, true, false);    // clear local mappings\n  map_clear_int(buf, MAP_ALL_MODES, true, true);     // clear local abbrevs\n  XFREE_CLEAR(buf->b_start_fenc);\n\n  buf_updates_unload(buf, false);\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\nstatic void clear_wininfo(buf_T *buf)\n{\n  wininfo_T   *wip;\n\n  while (buf->b_wininfo != NULL) {\n    wip = buf->b_wininfo;\n    buf->b_wininfo = wip->wi_next;\n    free_wininfo(wip, buf);\n  }\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\nvoid goto_buffer(exarg_T *eap, int start, int dir, int count)\n{\n  bufref_T old_curbuf;\n  set_bufref(&old_curbuf, curbuf);\n  swap_exists_action = SEA_DIALOG;\n\n  (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n                  start, dir, count, eap->forceit);\n\n  if (swap_exists_action == SEA_QUIT && *eap->cmd == 's') {\n    cleanup_T cs;\n\n    // Reset the error/interrupt/exception state here so that\n    // aborting() returns false when closing a window.\n    enter_cleanup(&cs);\n\n    // Quitting means closing the split window, nothing else.\n    win_close(curwin, true);\n    swap_exists_action = SEA_NONE;\n    swap_exists_did_quit = true;\n\n    /* Restore the error/interrupt/exception state if not discarded by a\n     * new aborting error, interrupt, or uncaught exception. */\n    leave_cleanup(&cs);\n  } else {\n    handle_swap_exists(&old_curbuf);\n  }\n}\n\n/// Handle the situation of swap_exists_action being set.\n///\n/// It is allowed for \"old_curbuf\" to be NULL or invalid.\n///\n/// @param old_curbuf The buffer to check for.\nvoid handle_swap_exists(bufref_T *old_curbuf)\n{\n  cleanup_T cs;\n  long old_tw = curbuf->b_p_tw;\n  buf_T *buf;\n\n  if (swap_exists_action == SEA_QUIT) {\n    // Reset the error/interrupt/exception state here so that\n    // aborting() returns false when closing a buffer.\n    enter_cleanup(&cs);\n\n    // User selected Quit at ATTENTION prompt.  Go back to previous\n    // buffer.  If that buffer is gone or the same as the current one,\n    // open a new, empty buffer.\n    swap_exists_action = SEA_NONE;      // don't want it again\n    swap_exists_did_quit = true;\n    close_buffer(curwin, curbuf, DOBUF_UNLOAD, false);\n    if (old_curbuf == NULL\n        || !bufref_valid(old_curbuf)\n        || old_curbuf->br_buf == curbuf) {\n      // Block autocommands here because curwin->w_buffer is NULL.\n      block_autocmds();\n      buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n      unblock_autocmds();\n    } else {\n      buf = old_curbuf->br_buf;\n    }\n    if (buf != NULL) {\n      int old_msg_silent = msg_silent;\n\n      if (shortmess(SHM_FILEINFO)) {\n        msg_silent = 1;  // prevent fileinfo message\n      }\n      enter_buffer(buf);\n      // restore msg_silent, so that the command line will be shown\n      msg_silent = old_msg_silent;\n\n      if (old_tw != curbuf->b_p_tw) {\n        check_colorcolumn(curwin);\n      }\n    }\n    // If \"old_curbuf\" is NULL we are in big trouble here...\n\n    /* Restore the error/interrupt/exception state if not discarded by a\n     * new aborting error, interrupt, or uncaught exception. */\n    leave_cleanup(&cs);\n  } else if (swap_exists_action == SEA_RECOVER) {\n    // Reset the error/interrupt/exception state here so that\n    // aborting() returns false when closing a buffer.\n    enter_cleanup(&cs);\n\n    // User selected Recover at ATTENTION prompt.\n    msg_scroll = true;\n    ml_recover(false);\n    MSG_PUTS(\"\\n\");     // don't overwrite the last message\n    cmdline_row = msg_row;\n    do_modelines(0);\n\n    /* Restore the error/interrupt/exception state if not discarded by a\n     * new aborting error, interrupt, or uncaught exception. */\n    leave_cleanup(&cs);\n  }\n  swap_exists_action = SEA_NONE;  // -V519\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\nchar_u *\ndo_bufdel(\n    int command,\n    char_u *arg,               // pointer to extra arguments\n    int addr_count,\n    int start_bnr,             // first buffer number in a range\n    int end_bnr,               // buffer nr or last buffer nr in a range\n    int forceit\n)\n{\n  int do_current = 0;             // delete current buffer?\n  int deleted = 0;                // number of buffers deleted\n  char_u      *errormsg = NULL;   // return value\n  int bnr;                        // buffer number\n  char_u      *p;\n\n  if (addr_count == 0) {\n    (void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n  } else {\n    if (addr_count == 2) {\n      if (*arg) {               // both range and argument is not allowed\n        return (char_u *)_(e_trailing);\n      }\n      bnr = start_bnr;\n    } else {    // addr_count == 1\n      bnr = end_bnr;\n    }\n\n    for (; !got_int; os_breakcheck()) {\n      /*\n       * delete the current buffer last, otherwise when the\n       * current buffer is deleted, the next buffer becomes\n       * the current one and will be loaded, which may then\n       * also be deleted, etc.\n       */\n      if (bnr == curbuf->b_fnum) {\n        do_current = bnr;\n      } else if (do_buffer(command, DOBUF_FIRST, FORWARD, bnr,\n                           forceit) == OK) {\n        deleted++;\n      }\n\n      /*\n       * find next buffer number to delete/unload\n       */\n      if (addr_count == 2) {\n        if (++bnr > end_bnr) {\n          break;\n        }\n      } else {    // addr_count == 1\n        arg = skipwhite(arg);\n        if (*arg == NUL) {\n          break;\n        }\n        if (!ascii_isdigit(*arg)) {\n          p = skiptowhite_esc(arg);\n          bnr = buflist_findpat(arg, p, command == DOBUF_WIPE,\n                                false, false);\n          if (bnr < 0) {                    // failed\n            break;\n          }\n          arg = p;\n        } else {\n          bnr = getdigits_int(&arg, false, 0);\n        }\n      }\n    }\n    if (!got_int && do_current\n        && do_buffer(command, DOBUF_FIRST,\n                     FORWARD, do_current, forceit) == OK) {\n      deleted++;\n    }\n\n    if (deleted == 0) {\n      if (command == DOBUF_UNLOAD) {\n        STRCPY(IObuff, _(\"E515: No buffers were unloaded\"));\n      } else if (command == DOBUF_DEL) {\n        STRCPY(IObuff, _(\"E516: No buffers were deleted\"));\n      } else {\n        STRCPY(IObuff, _(\"E517: No buffers were wiped out\"));\n      }\n      errormsg = IObuff;\n    } else if (deleted >= p_report) {\n      if (command == DOBUF_UNLOAD) {\n        if (deleted == 1) {\n          MSG(_(\"1 buffer unloaded\"));\n        } else {\n          smsg(_(\"%d buffers unloaded\"), deleted);\n        }\n      } else if (command == DOBUF_DEL) {\n        if (deleted == 1) {\n          MSG(_(\"1 buffer deleted\"));\n        } else {\n          smsg(_(\"%d buffers deleted\"), deleted);\n        }\n      } else {\n        if (deleted == 1) {\n          MSG(_(\"1 buffer wiped out\"));\n        } else {\n          smsg(_(\"%d buffers wiped out\"), deleted);\n        }\n      }\n    }\n  }\n\n\n  return errormsg;\n}\n\n\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\nstatic int empty_curbuf(int close_others, int forceit, int action)\n{\n  int retval;\n  buf_T   *buf = curbuf;\n\n  if (action == DOBUF_UNLOAD) {\n    EMSG(_(\"E90: Cannot unload last buffer\"));\n    return FAIL;\n  }\n\n  bufref_T bufref;\n  set_bufref(&bufref, buf);\n\n  if (close_others) {\n    // Close any other windows on this buffer, then make it empty.\n    close_windows(buf, true);\n  }\n\n  setpcmark();\n  retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n      forceit ? ECMD_FORCEIT : 0, curwin);\n\n  // do_ecmd() may create a new buffer, then we have to delete\n  // the old one.  But do_ecmd() may have done that already, check\n  // if the buffer still exists.\n  if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0) {\n    close_buffer(NULL, buf, action, false);\n  }\n\n  if (!close_others) {\n    need_fileinfo = false;\n  }\n\n  return retval;\n}\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\nint\ndo_buffer(\n    int action,\n    int start,\n    int dir,                        // FORWARD or BACKWARD\n    int count,                      // buffer number or number of buffers\n    int forceit                     // true for :...!\n)\n{\n  buf_T       *buf;\n  buf_T       *bp;\n  int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n                || action == DOBUF_WIPE);\n\n  switch (start) {\n  case DOBUF_FIRST:   buf = firstbuf; break;\n  case DOBUF_LAST:    buf = lastbuf;  break;\n  default:            buf = curbuf;   break;\n  }\n  if (start == DOBUF_MOD) {         // find next modified buffer\n    while (count-- > 0) {\n      do {\n        buf = buf->b_next;\n        if (buf == NULL) {\n          buf = firstbuf;\n        }\n      } while (buf != curbuf && !bufIsChanged(buf));\n    }\n    if (!bufIsChanged(buf)) {\n      EMSG(_(\"E84: No modified buffer found\"));\n      return FAIL;\n    }\n  } else if (start == DOBUF_FIRST && count) {  // find specified buffer number\n    while (buf != NULL && buf->b_fnum != count) {\n      buf = buf->b_next;\n    }\n  } else {\n    bp = NULL;\n    while (count > 0 || (!unload && !buf->b_p_bl && bp != buf)) {\n      /* remember the buffer where we start, we come back there when all\n       * buffers are unlisted. */\n      if (bp == NULL) {\n        bp = buf;\n      }\n      if (dir == FORWARD) {\n        buf = buf->b_next;\n        if (buf == NULL) {\n          buf = firstbuf;\n        }\n      } else {\n        buf = buf->b_prev;\n        if (buf == NULL) {\n          buf = lastbuf;\n        }\n      }\n      // don't count unlisted buffers\n      if (unload || buf->b_p_bl) {\n        count--;\n        bp = NULL;              // use this buffer as new starting point\n      }\n      if (bp == buf) {\n        // back where we started, didn't find anything.\n        EMSG(_(\"E85: There is no listed buffer\"));\n        return FAIL;\n      }\n    }\n  }\n\n  if (buf == NULL) {        // could not find it\n    if (start == DOBUF_FIRST) {\n      // don't warn when deleting\n      if (!unload) {\n        EMSGN(_(e_nobufnr), count);\n      }\n    } else if (dir == FORWARD) {\n      EMSG(_(\"E87: Cannot go beyond last buffer\"));\n    } else {\n      EMSG(_(\"E88: Cannot go before first buffer\"));\n    }\n    return FAIL;\n  }\n\n\n  /*\n   * delete buffer buf from memory and/or the list\n   */\n  if (unload) {\n    int forward;\n    bufref_T bufref;\n    set_bufref(&bufref, buf);\n\n    /* When unloading or deleting a buffer that's already unloaded and\n     * unlisted: fail silently. */\n    if (action != DOBUF_WIPE && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl) {\n      return FAIL;\n    }\n\n    if (!forceit && bufIsChanged(buf)) {\n      if ((p_confirm || cmdmod.confirm) && p_write) {\n        dialog_changed(buf, false);\n        if (!bufref_valid(&bufref)) {\n          // Autocommand deleted buffer, oops! It's not changed now.\n          return FAIL;\n        }\n        // If it's still changed fail silently, the dialog already\n        // mentioned why it fails.\n        if (bufIsChanged(buf)) {\n          return FAIL;\n        }\n      } else {\n        EMSGN(_(\"E89: No write since last change for buffer %\" PRId64\n                \" (add ! to override)\"),\n              buf->b_fnum);\n        return FAIL;\n      }\n    }\n\n    if (!forceit && buf->terminal && terminal_running(buf->terminal)) {\n      if (p_confirm || cmdmod.confirm) {\n        if (!dialog_close_terminal(buf)) {\n          return FAIL;\n        }\n      } else {\n        EMSG2(_(\"E89: %s will be killed (add ! to override)\"),\n              (char *)buf->b_fname);\n        return FAIL;\n      }\n    }\n\n    // When closing the current buffer stop Visual mode.\n    if (buf == curbuf && VIsual_active) {\n      end_visual_mode();\n    }\n\n    /*\n     * If deleting the last (listed) buffer, make it empty.\n     * The last (listed) buffer cannot be unloaded.\n     */\n    bp = NULL;\n    FOR_ALL_BUFFERS(bp2) {\n      if (bp2->b_p_bl && bp2 != buf) {\n        bp = bp2;\n        break;\n      }\n    }\n    if (bp == NULL && buf == curbuf) {\n      return empty_curbuf(true, forceit, action);\n    }\n\n    /*\n     * If the deleted buffer is the current one, close the current window\n     * (unless it's the only window).  Repeat this so long as we end up in\n     * a window with this buffer.\n     */\n    while (buf == curbuf\n           && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n           && (!ONE_WINDOW || first_tabpage->tp_next != NULL)) {\n      if (win_close(curwin, false) == FAIL) {\n        break;\n      }\n    }\n\n    /*\n     * If the buffer to be deleted is not the current one, delete it here.\n     */\n    if (buf != curbuf) {\n      close_windows(buf, false);\n      if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0) {\n        close_buffer(NULL, buf, action, false);\n      }\n      return OK;\n    }\n\n    // Deleting the current buffer: Need to find another buffer to go to.\n    // There should be another, otherwise it would have been handled\n    // above.  However, autocommands may have deleted all buffers.\n    // First use au_new_curbuf.br_buf, if it is valid.\n    // Then prefer the buffer we most recently visited.\n    // Else try to find one that is loaded, after the current buffer,\n    // then before the current buffer.\n    // Finally use any buffer.\n    buf = NULL;  // Selected buffer.\n    bp = NULL;   // Used when no loaded buffer found.\n    if (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf)) {\n      buf = au_new_curbuf.br_buf;\n    } else if (curwin->w_jumplistlen > 0) {\n      int jumpidx;\n\n      jumpidx = curwin->w_jumplistidx - 1;\n      if (jumpidx < 0) {\n        jumpidx = curwin->w_jumplistlen - 1;\n      }\n\n      forward = jumpidx;\n      while (jumpidx != curwin->w_jumplistidx) {\n        buf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n        if (buf != NULL) {\n          if (buf == curbuf || !buf->b_p_bl) {\n            buf = NULL;                 // skip current and unlisted bufs\n          } else if (buf->b_ml.ml_mfp == NULL) {\n            // skip unloaded buf, but may keep it for later\n            if (bp == NULL) {\n              bp = buf;\n            }\n            buf = NULL;\n          }\n        }\n        if (buf != NULL) {         // found a valid buffer: stop searching\n          break;\n        }\n        // advance to older entry in jump list\n        if (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen) {\n          break;\n        }\n        if (--jumpidx < 0) {\n          jumpidx = curwin->w_jumplistlen - 1;\n        }\n        if (jumpidx == forward) {               // List exhausted for sure\n          break;\n        }\n      }\n    }\n\n    if (buf == NULL) {          // No previous buffer, Try 2'nd approach\n      forward = true;\n      buf = curbuf->b_next;\n      for (;; ) {\n        if (buf == NULL) {\n          if (!forward) {               // tried both directions\n            break;\n          }\n          buf = curbuf->b_prev;\n          forward = false;\n          continue;\n        }\n        // in non-help buffer, try to skip help buffers, and vv\n        if (buf->b_help == curbuf->b_help && buf->b_p_bl) {\n          if (buf->b_ml.ml_mfp != NULL) {           // found loaded buffer\n            break;\n          }\n          if (bp == NULL) {             // remember unloaded buf for later\n            bp = buf;\n          }\n        }\n        if (forward) {\n          buf = buf->b_next;\n        } else {\n          buf = buf->b_prev;\n        }\n      }\n    }\n    if (buf == NULL) {          // No loaded buffer, use unloaded one\n      buf = bp;\n    }\n    if (buf == NULL) {          // No loaded buffer, find listed one\n      FOR_ALL_BUFFERS(buf2) {\n        if (buf2->b_p_bl && buf2 != curbuf) {\n          buf = buf2;\n          break;\n        }\n      }\n    }\n    if (buf == NULL) {          // Still no buffer, just take one\n      if (curbuf->b_next != NULL) {\n        buf = curbuf->b_next;\n      } else {\n        buf = curbuf->b_prev;\n      }\n    }\n  }\n\n  if (buf == NULL) {\n    /* Autocommands must have wiped out all other buffers.  Only option\n     * now is to make the current buffer empty. */\n    return empty_curbuf(false, forceit, action);\n  }\n\n  /*\n   * make buf current buffer\n   */\n  if (action == DOBUF_SPLIT) {      // split window first\n    // If 'switchbuf' contains \"useopen\": jump to first window containing\n    // \"buf\" if one exists\n    if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf)) {\n      return OK;\n    }\n    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n    // page containing \"buf\" if one exists\n    if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf)) {\n      return OK;\n    }\n    if (win_split(0, 0) == FAIL) {\n      return FAIL;\n    }\n  }\n\n  // go to current buffer - nothing to do\n  if (buf == curbuf) {\n    return OK;\n  }\n\n  /*\n   * Check if the current buffer may be abandoned.\n   */\n  if (action == DOBUF_GOTO && !can_abandon(curbuf, forceit)) {\n    if ((p_confirm || cmdmod.confirm) && p_write) {\n      bufref_T bufref;\n      set_bufref(&bufref, buf);\n      dialog_changed(curbuf, false);\n      if (!bufref_valid(&bufref)) {\n        // Autocommand deleted buffer, oops!\n        return FAIL;\n      }\n    }\n    if (bufIsChanged(curbuf)) {\n      no_write_message();\n      return FAIL;\n    }\n  }\n\n  // Go to the other buffer.\n  set_curbuf(buf, action);\n\n  if (action == DOBUF_SPLIT) {\n    RESET_BINDING(curwin);      // reset 'scrollbind' and 'cursorbind'\n  }\n\n  if (aborting()) {         // autocmds may abort script processing\n    return FAIL;\n  }\n\n  return OK;\n}\n\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n */\nvoid set_curbuf(buf_T *buf, int action)\n{\n  buf_T       *prevbuf;\n  int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n                || action == DOBUF_WIPE);\n  long old_tw = curbuf->b_p_tw;\n\n  setpcmark();\n  if (!cmdmod.keepalt) {\n    curwin->w_alt_fnum = curbuf->b_fnum;     // remember alternate file\n  }\n  buflist_altfpos(curwin);                       // remember curpos\n\n  // Don't restart Select mode after switching to another buffer.\n  VIsual_reselect = false;\n\n  // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n  prevbuf = curbuf;\n  bufref_T newbufref;\n  bufref_T prevbufref;\n  set_bufref(&prevbufref, prevbuf);\n  set_bufref(&newbufref, buf);\n\n  // Autocommands may delete the curren buffer and/or the buffer we want to go\n  // to.  In those cases don't close the buffer.\n  if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf)\n      || (bufref_valid(&prevbufref) && bufref_valid(&newbufref)\n          && !aborting())) {\n    if (prevbuf == curwin->w_buffer) {\n      reset_synblock(curwin);\n    }\n    if (unload) {\n      close_windows(prevbuf, false);\n    }\n    if (bufref_valid(&prevbufref) && !aborting()) {\n      win_T  *previouswin = curwin;\n      if (prevbuf == curbuf) {\n        u_sync(false);\n      }\n      close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL,\n                   prevbuf,\n                   unload\n                   ? action\n                   : (action == DOBUF_GOTO && !buf_hide(prevbuf)\n                      && !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n                   false);\n      if (curwin != previouswin && win_valid(previouswin)) {\n        // autocommands changed curwin, Grr!\n        curwin = previouswin;\n      }\n    }\n  }\n  /* An autocommand may have deleted \"buf\", already entered it (e.g., when\n   * it did \":bunload\") or aborted the script processing!\n   * If curwin->w_buffer is null, enter_buffer() will make it valid again */\n  if ((buf_valid(buf) && buf != curbuf\n       && !aborting()\n       ) || curwin->w_buffer == NULL\n      ) {\n    enter_buffer(buf);\n    if (old_tw != curbuf->b_p_tw) {\n      check_colorcolumn(curwin);\n    }\n  }\n\n  if (bufref_valid(&prevbufref) && prevbuf->terminal != NULL) {\n    terminal_check_size(prevbuf->terminal);\n  }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\nvoid enter_buffer(buf_T *buf)\n{\n  // Copy buffer and window local option values.  Not for a help buffer.\n  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n  if (!buf->b_help) {\n    get_winopts(buf);\n  } else {\n    // Remove all folds in the window.\n    clearFolding(curwin);\n  }\n  foldUpdateAll(curwin);        // update folds (later).\n\n  // Get the buffer in the current window.\n  curwin->w_buffer = buf;\n  curbuf = buf;\n  curbuf->b_nwindows++;\n\n  if (curwin->w_p_diff) {\n    diff_buf_add(curbuf);\n  }\n\n  curwin->w_s = &(curbuf->b_s);\n\n  // Cursor on first line by default.\n  curwin->w_cursor.lnum = 1;\n  curwin->w_cursor.col = 0;\n  curwin->w_cursor.coladd = 0;\n  curwin->w_set_curswant = true;\n  curwin->w_topline_was_set = false;\n\n  // mark cursor position as being invalid\n  curwin->w_valid = 0;\n\n  // Make sure the buffer is loaded.\n  if (curbuf->b_ml.ml_mfp == NULL) {    // need to load the file\n    // If there is no filetype, allow for detecting one.  Esp. useful for\n    // \":ball\" used in an autocommand.  If there already is a filetype we\n    // might prefer to keep it.\n    if (*curbuf->b_p_ft == NUL) {\n      did_filetype = false;\n    }\n\n    open_buffer(false, NULL, 0);\n  } else {\n    if (!msg_silent && !shortmess(SHM_FILEINFO)) {\n      need_fileinfo = true;             // display file info after redraw\n    }\n    // check if file changed\n    (void)buf_check_timestamp(curbuf);\n\n    curwin->w_topline = 1;\n    curwin->w_topfill = 0;\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);\n    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL, false, curbuf);\n  }\n\n  /* If autocommands did not change the cursor position, restore cursor lnum\n   * and possibly cursor col. */\n  if (curwin->w_cursor.lnum == 1 && inindent(0)) {\n    buflist_getfpos();\n  }\n\n  check_arg_idx(curwin);                // check for valid arg_idx\n  maketitle();\n  // when autocmds didn't change it\n  if (curwin->w_topline == 1 && !curwin->w_topline_was_set) {\n    scroll_cursor_halfway(false);       // redisplay at correct position\n  }\n\n\n  // Change directories when the 'acd' option is set.\n  do_autochdir();\n\n  if (curbuf->b_kmap_state & KEYMAP_INIT) {\n    (void)keymap_init();\n  }\n  // May need to set the spell language.  Can only do this after the buffer\n  // has been properly setup.\n  if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL) {\n    (void)did_set_spelllang(curwin);\n  }\n  curbuf->b_last_used = time(NULL);\n\n  redraw_later(curwin, NOT_VALID);\n}\n\n// Change to the directory of the current buffer.\n// Don't do this while still starting up.\nvoid do_autochdir(void)\n{\n  if (p_acd) {\n    if (starting == 0\n        && curbuf->b_ffname != NULL\n        && vim_chdirfile(curbuf->b_ffname) == OK) {\n      post_chdir(kCdScopeGlobal, false);\n      shorten_fnames(true);\n    }\n  }\n}\n\nvoid no_write_message(void)\n{\n  if (curbuf->terminal\n      && channel_job_running((uint64_t)curbuf->b_p_channel)) {\n    EMSG(_(\"E948: Job still running (add ! to end the job)\"));\n  } else {\n    EMSG(_(\"E37: No write since last change (add ! to override)\"));\n  }\n}\n\nvoid no_write_message_nobang(const buf_T *const buf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (buf->terminal\n      && channel_job_running((uint64_t)buf->b_p_channel)) {\n    EMSG(_(\"E948: Job still running\"));\n  } else {\n    EMSG(_(\"E37: No write since last change\"));\n  }\n}\n\n//\n// functions for dealing with the buffer list\n//\n\nstatic int top_file_num = 1;            ///< highest file number\n\n/// Initialize b:changedtick and changedtick_val attribute\n///\n/// @param[out]  buf  Buffer to initialize for.\nstatic inline void buf_init_changedtick(buf_T *const buf)\n  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL\n{\n  STATIC_ASSERT(sizeof(\"changedtick\") <= sizeof(buf->changedtick_di.di_key),\n                \"buf->changedtick_di cannot hold large enough keys\");\n  buf->changedtick_di = (ChangedtickDictItem) {\n    .di_flags = DI_FLAGS_RO|DI_FLAGS_FIX,  // Must not include DI_FLAGS_ALLOC.\n    .di_tv = (typval_T) {\n      .v_type = VAR_NUMBER,\n      .v_lock = VAR_FIXED,\n      .vval.v_number = buf_get_changedtick(buf),\n    },\n    .di_key = \"changedtick\",\n  };\n  tv_dict_add(buf->b_vars, (dictitem_T *)&buf->changedtick_di);\n}\n\n/// Add a file name to the buffer list.\n/// If the same file name already exists return a pointer to that buffer.\n/// If it does not exist, or if fname == NULL, a new entry is created.\n/// If (flags & BLN_CURBUF) is true, may use current buffer.\n/// If (flags & BLN_LISTED) is true, add new buffer to buffer list.\n/// If (flags & BLN_DUMMY) is true, don't count it as a real buffer.\n/// If (flags & BLN_NEW) is true, don't use an existing buffer.\n/// If (flags & BLN_NOOPT) is true, don't copy options from the current buffer\n///                                 if the buffer already exists.\n/// This is the ONLY way to create a new buffer.\n///\n/// @param ffname_arg  full path of fname or relative\n/// @param sfname_arg  short fname or NULL\n/// @param lnum   preferred cursor line\n/// @param flags  BLN_ defines\n/// @param bufnr\n///\n/// @return pointer to the buffer\nbuf_T *buflist_new(char_u *ffname_arg, char_u *sfname_arg, linenr_T lnum,\n                   int flags)\n{\n  char_u *ffname = ffname_arg;\n  char_u *sfname = sfname_arg;\n  buf_T       *buf;\n\n  fname_expand(curbuf, &ffname, &sfname);       // will allocate ffname\n\n  /*\n   * If file name already exists in the list, update the entry.\n   */\n  /* We can use inode numbers when the file exists.  Works better\n   * for hard links. */\n  FileID file_id;\n  bool file_id_valid = (sfname != NULL\n                        && os_fileid((char *)sfname, &file_id));\n  if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW))\n      && (buf = buflist_findname_file_id(ffname, &file_id,\n                                         file_id_valid)) != NULL) {\n    xfree(ffname);\n    if (lnum != 0) {\n      buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n                      lnum, (colnr_T)0, false);\n    }\n    if ((flags & BLN_NOOPT) == 0) {\n      // Copy the options now, if 'cpo' doesn't have 's' and not done already.\n      buf_copy_options(buf, 0);\n    }\n    if ((flags & BLN_LISTED) && !buf->b_p_bl) {\n      buf->b_p_bl = true;\n      bufref_T bufref;\n      set_bufref(&bufref, buf);\n      if (!(flags & BLN_DUMMY)) {\n        if (apply_autocmds(EVENT_BUFADD, NULL, NULL, false, buf)\n            && !bufref_valid(&bufref)) {\n          return NULL;\n        }\n      }\n    }\n    return buf;\n  }\n\n  /*\n   * If the current buffer has no name and no contents, use the current\n   * buffer.\tOtherwise: Need to allocate a new buffer structure.\n   *\n   * This is the ONLY place where a new buffer structure is allocated!\n   * (A spell file buffer is allocated in spell.c, but that's not a normal\n   * buffer.)\n   */\n  buf = NULL;\n  if ((flags & BLN_CURBUF) && curbuf_reusable()) {\n    assert(curbuf != NULL);\n    buf = curbuf;\n    /* It's like this buffer is deleted.  Watch out for autocommands that\n     * change curbuf!  If that happens, allocate a new buffer anyway. */\n    if (curbuf->b_p_bl) {\n      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);\n    }\n    if (buf == curbuf) {\n      apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);\n    }\n    if (aborting()) {           // autocmds may abort script processing\n      xfree(ffname);\n      return NULL;\n    }\n    if (buf == curbuf) {\n      // Make sure 'bufhidden' and 'buftype' are empty\n      clear_string_option(&buf->b_p_bh);\n      clear_string_option(&buf->b_p_bt);\n    }\n  }\n  if (buf != curbuf || curbuf == NULL) {\n    buf = xcalloc(1, sizeof(buf_T));\n    // init b: variables\n    buf->b_vars = tv_dict_alloc();\n    buf->b_signcols_valid = false;\n    init_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n    buf_init_changedtick(buf);\n  }\n\n  if (ffname != NULL) {\n    buf->b_ffname = ffname;\n    buf->b_sfname = vim_strsave(sfname);\n  }\n\n  clear_wininfo(buf);\n  buf->b_wininfo = xcalloc(1, sizeof(wininfo_T));\n\n  if (ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL)) {\n    if (buf->b_sfname != buf->b_ffname) {\n      XFREE_CLEAR(buf->b_sfname);\n    } else {\n      buf->b_sfname = NULL;\n    }\n    XFREE_CLEAR(buf->b_ffname);\n    if (buf != curbuf) {\n      free_buffer(buf);\n    }\n    return NULL;\n  }\n\n  if (buf == curbuf) {\n    // free all things allocated for this buffer\n    buf_freeall(buf, 0);\n    if (buf != curbuf) {         // autocommands deleted the buffer!\n      return NULL;\n    }\n    if (aborting()) {           // autocmds may abort script processing\n      return NULL;\n    }\n    free_buffer_stuff(buf, kBffInitChangedtick);  // delete local vars et al.\n\n    // Init the options.\n    buf->b_p_initialized = false;\n    buf_copy_options(buf, BCO_ENTER);\n\n    // need to reload lmaps and set b:keymap_name\n    curbuf->b_kmap_state |= KEYMAP_INIT;\n  } else {\n    /*\n     * put new buffer at the end of the buffer list\n     */\n    buf->b_next = NULL;\n    if (firstbuf == NULL) {             // buffer list is empty\n      buf->b_prev = NULL;\n      firstbuf = buf;\n    } else {                            // append new buffer at end of list\n      lastbuf->b_next = buf;\n      buf->b_prev = lastbuf;\n    }\n    lastbuf = buf;\n\n    buf->b_fnum = top_file_num++;\n    pmap_put(handle_T)(&buffer_handles, buf->b_fnum, buf);\n    if (top_file_num < 0) {  // wrap around (may cause duplicates)\n      EMSG(_(\"W14: Warning: List of file names overflow\"));\n      if (emsg_silent == 0) {\n        ui_flush();\n        os_delay(3001L, true);  // make sure it is noticed\n      }\n      top_file_num = 1;\n    }\n\n    /*\n     * Always copy the options from the current buffer.\n     */\n    buf_copy_options(buf, BCO_ALWAYS);\n  }\n\n  buf->b_wininfo->wi_fpos.lnum = lnum;\n  buf->b_wininfo->wi_win = curwin;\n\n  hash_init(&buf->b_s.b_keywtab);\n  hash_init(&buf->b_s.b_keywtab_ic);\n\n  buf->b_fname = buf->b_sfname;\n  if (!file_id_valid) {\n    buf->file_id_valid = false;\n  } else {\n    buf->file_id_valid = true;\n    buf->file_id = file_id;\n  }\n  buf->b_u_synced = true;\n  buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n  if (flags & BLN_DUMMY) {\n    buf->b_flags |= BF_DUMMY;\n  }\n  buf_clear_file(buf);\n  clrallmarks(buf);                     // clear marks\n  fmarks_check_names(buf);              // check file marks for this file\n  buf->b_p_bl = (flags & BLN_LISTED) ? true : false;    // init 'buflisted'\n  kv_destroy(buf->update_channels);\n  kv_init(buf->update_channels);\n  kv_destroy(buf->update_callbacks);\n  kv_init(buf->update_callbacks);\n  if (!(flags & BLN_DUMMY)) {\n    // Tricky: these autocommands may change the buffer list.  They could also\n    // split the window with re-using the one empty buffer. This may result in\n    // unexpectedly losing the empty buffer.\n    bufref_T bufref;\n    set_bufref(&bufref, buf);\n    if (apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, buf)\n        && !bufref_valid(&bufref)) {\n      return NULL;\n    }\n    if ((flags & BLN_LISTED)\n        && apply_autocmds(EVENT_BUFADD, NULL, NULL, false, buf)\n        && !bufref_valid(&bufref)) {\n      return NULL;\n    }\n    if (aborting()) {\n      // Autocmds may abort script processing.\n      return NULL;\n    }\n  }\n\n  buf->b_prompt_callback.type = kCallbackNone;\n  buf->b_prompt_interrupt.type = kCallbackNone;\n  buf->b_prompt_text = NULL;\n\n  return buf;\n}\n\n/// Return true if the current buffer is empty, unnamed, unmodified and used in\n/// only one window. That means it can be reused.\nbool curbuf_reusable(void)\n{\n  return (curbuf != NULL\n          && curbuf->b_ffname == NULL\n          && curbuf->b_nwindows <= 1\n          && (curbuf->b_ml.ml_mfp == NULL || buf_is_empty(curbuf))\n          && !bt_quickfix(curbuf)\n          && !curbufIsChanged());\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is true also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\nvoid free_buf_options(buf_T *buf, int free_p_ff)\n{\n  if (free_p_ff) {\n    clear_string_option(&buf->b_p_fenc);\n    clear_string_option(&buf->b_p_ff);\n    clear_string_option(&buf->b_p_bh);\n    clear_string_option(&buf->b_p_bt);\n  }\n  clear_string_option(&buf->b_p_def);\n  clear_string_option(&buf->b_p_inc);\n  clear_string_option(&buf->b_p_inex);\n  clear_string_option(&buf->b_p_inde);\n  clear_string_option(&buf->b_p_indk);\n  clear_string_option(&buf->b_p_fp);\n  clear_string_option(&buf->b_p_fex);\n  clear_string_option(&buf->b_p_kp);\n  clear_string_option(&buf->b_p_mps);\n  clear_string_option(&buf->b_p_fo);\n  clear_string_option(&buf->b_p_flp);\n  clear_string_option(&buf->b_p_isk);\n  clear_string_option(&buf->b_p_vsts);\n  xfree(buf->b_p_vsts_nopaste);\n  buf->b_p_vsts_nopaste = NULL;\n  xfree(buf->b_p_vsts_array);\n  buf->b_p_vsts_array = NULL;\n  clear_string_option(&buf->b_p_vts);\n  XFREE_CLEAR(buf->b_p_vts_array);\n  clear_string_option(&buf->b_p_keymap);\n  keymap_ga_clear(&buf->b_kmap_ga);\n  ga_clear(&buf->b_kmap_ga);\n  clear_string_option(&buf->b_p_com);\n  clear_string_option(&buf->b_p_cms);\n  clear_string_option(&buf->b_p_nf);\n  clear_string_option(&buf->b_p_syn);\n  clear_string_option(&buf->b_s.b_syn_isk);\n  clear_string_option(&buf->b_s.b_p_spc);\n  clear_string_option(&buf->b_s.b_p_spf);\n  vim_regfree(buf->b_s.b_cap_prog);\n  buf->b_s.b_cap_prog = NULL;\n  clear_string_option(&buf->b_s.b_p_spl);\n  clear_string_option(&buf->b_s.b_p_spo);\n  clear_string_option(&buf->b_p_sua);\n  clear_string_option(&buf->b_p_ft);\n  clear_string_option(&buf->b_p_cink);\n  clear_string_option(&buf->b_p_cino);\n  clear_string_option(&buf->b_p_cinw);\n  clear_string_option(&buf->b_p_cpt);\n  clear_string_option(&buf->b_p_cfu);\n  clear_string_option(&buf->b_p_ofu);\n  clear_string_option(&buf->b_p_gp);\n  clear_string_option(&buf->b_p_mp);\n  clear_string_option(&buf->b_p_efm);\n  clear_string_option(&buf->b_p_ep);\n  clear_string_option(&buf->b_p_path);\n  clear_string_option(&buf->b_p_tags);\n  clear_string_option(&buf->b_p_tc);\n  clear_string_option(&buf->b_p_tfu);\n  clear_string_option(&buf->b_p_dict);\n  clear_string_option(&buf->b_p_tsr);\n  clear_string_option(&buf->b_p_qe);\n  buf->b_p_ar = -1;\n  buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n  clear_string_option(&buf->b_p_lw);\n  clear_string_option(&buf->b_p_bkc);\n  clear_string_option(&buf->b_p_menc);\n}\n\n\n/// Get alternate file \"n\".\n/// Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n/// Also set cursor column to altfpos.col if 'startofline' is not set.\n/// if (options & GETF_SETMARK) call setpcmark()\n/// if (options & GETF_ALT) we are jumping to an alternate file.\n/// if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n///\n/// Return FAIL for failure, OK for success.\nint buflist_getfile(int n, linenr_T lnum, int options, int forceit)\n{\n  buf_T       *buf;\n  win_T       *wp = NULL;\n  pos_T       *fpos;\n  colnr_T col;\n\n  buf = buflist_findnr(n);\n  if (buf == NULL) {\n    if ((options & GETF_ALT) && n == 0) {\n      EMSG(_(e_noalt));\n    } else {\n      EMSGN(_(\"E92: Buffer %\" PRId64 \" not found\"), n);\n    }\n    return FAIL;\n  }\n\n  // if alternate file is the current buffer, nothing to do\n  if (buf == curbuf) {\n    return OK;\n  }\n\n  if (text_locked()) {\n    text_locked_msg();\n    return FAIL;\n  }\n  if (curbuf_locked()) {\n    return FAIL;\n  }\n\n  // altfpos may be changed by getfile(), get it now\n  if (lnum == 0) {\n    fpos = buflist_findfpos(buf);\n    lnum = fpos->lnum;\n    col = fpos->col;\n  } else\n    col = 0;\n\n  if (options & GETF_SWITCH) {\n    // If 'switchbuf' contains \"useopen\": jump to first window containing\n    // \"buf\" if one exists\n    if (swb_flags & SWB_USEOPEN) {\n      wp = buf_jump_open_win(buf);\n    }\n\n    // If 'switchbuf' contains \"usetab\": jump to first window in any tab\n    // page containing \"buf\" if one exists\n    if (wp == NULL && (swb_flags & SWB_USETAB)) {\n      wp = buf_jump_open_tab(buf);\n    }\n\n    // If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n    // current buffer isn't empty: open new tab or window\n    if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n        && !buf_is_empty(curbuf)) {\n      if (swb_flags & SWB_NEWTAB) {\n        tabpage_new();\n      } else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n                 == FAIL) {\n        return FAIL;\n      }\n      RESET_BINDING(curwin);\n    }\n  }\n\n  RedrawingDisabled++;\n  if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n                              (options & GETF_SETMARK), lnum, forceit))) {\n    RedrawingDisabled--;\n\n    // cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n    if (!p_sol && col != 0) {\n      curwin->w_cursor.col = col;\n      check_cursor_col();\n      curwin->w_cursor.coladd = 0;\n      curwin->w_set_curswant = true;\n    }\n    return OK;\n  }\n  RedrawingDisabled--;\n  return FAIL;\n}\n\n// Go to the last known line number for the current buffer.\nvoid buflist_getfpos(void)\n{\n  pos_T       *fpos;\n\n  fpos = buflist_findfpos(curbuf);\n\n  curwin->w_cursor.lnum = fpos->lnum;\n  check_cursor_lnum();\n\n  if (p_sol) {\n    curwin->w_cursor.col = 0;\n  } else {\n    curwin->w_cursor.col = fpos->col;\n    check_cursor_col();\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = true;\n  }\n}\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\nbuf_T *buflist_findname_exp(char_u *fname)\n{\n  char_u      *ffname;\n  buf_T       *buf = NULL;\n\n  // First make the name into a full path name\n  ffname = (char_u *)FullName_save((char *)fname,\n#ifdef UNIX\n                                   // force expansion, get rid of symbolic links\n                                   true\n#else\n                                   false\n#endif\n      );\n  if (ffname != NULL) {\n    buf = buflist_findname(ffname);\n    xfree(ffname);\n  }\n  return buf;\n}\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\nbuf_T *buflist_findname(char_u *ffname)\n{\n  FileID file_id;\n  bool file_id_valid = os_fileid((char *)ffname, &file_id);\n  return buflist_findname_file_id(ffname, &file_id, file_id_valid);\n}\n\n/*\n * Same as buflist_findname(), but pass the FileID structure to avoid\n * getting it twice for the same file.\n * Returns NULL if not found.\n */\nstatic buf_T *buflist_findname_file_id(char_u *ffname, FileID *file_id,\n                                       bool file_id_valid)\n{\n  // Start at the last buffer, expect to find a match sooner.\n  FOR_ALL_BUFFERS_BACKWARDS(buf) {\n    if ((buf->b_flags & BF_DUMMY) == 0\n        && !otherfile_buf(buf, ffname, file_id, file_id_valid)) {\n      return buf;\n    }\n  }\n  return NULL;\n}\n\n/// Find file in buffer list by a regexp pattern.\n/// Return fnum of the found buffer.\n/// Return < 0 for error.\nint buflist_findpat(\n    const char_u *pattern,\n    const char_u *pattern_end,  // pointer to first char after pattern\n    bool unlisted,              // find unlisted buffers\n    bool diffmode,              // find diff-mode buffers only\n    bool curtab_only            // find buffers in current tab only\n)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  int match = -1;\n  int find_listed;\n  char_u      *pat;\n  char_u      *patend;\n  int attempt;\n  char_u      *p;\n  int toggledollar;\n\n  if (pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#')) {\n    if (*pattern == '%') {\n      match = curbuf->b_fnum;\n    } else {\n      match = curwin->w_alt_fnum;\n    }\n    buf_T *found_buf = buflist_findnr(match);\n    if (diffmode && !(found_buf && diff_mode_buf(found_buf))) {\n      match = -1;\n    }\n  } else {\n    //\n    // Try four ways of matching a listed buffer:\n    // attempt == 0: without '^' or '$' (at any position)\n    // attempt == 1: with '^' at start (only at position 0)\n    // attempt == 2: with '$' at end (only match at end)\n    // attempt == 3: with '^' at start and '$' at end (only full match)\n    // Repeat this for finding an unlisted buffer if there was no matching\n    // listed buffer.\n    //\n\n    pat = file_pat_to_reg_pat(pattern, pattern_end, NULL, false);\n    if (pat == NULL) {\n      return -1;\n    }\n    patend = pat + STRLEN(pat) - 1;\n    toggledollar = (patend > pat && *patend == '$');\n\n    // First try finding a listed buffer.  If not found and \"unlisted\"\n    // is true, try finding an unlisted buffer.\n    find_listed = true;\n    for (;; ) {\n      for (attempt = 0; attempt <= 3; attempt++) {\n        // may add '^' and '$'\n        if (toggledollar) {\n          *patend = (attempt < 2) ? NUL : '$';           // add/remove '$'\n        }\n        p = pat;\n        if (*p == '^' && !(attempt & 1)) {               // add/remove '^'\n          p++;\n        }\n\n        regmatch_T regmatch;\n        regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);\n        if (regmatch.regprog == NULL) {\n          xfree(pat);\n          return -1;\n        }\n\n        FOR_ALL_BUFFERS_BACKWARDS(buf) {\n          if (buf->b_p_bl == find_listed\n              && (!diffmode || diff_mode_buf(buf))\n              && buflist_match(&regmatch, buf, false) != NULL) {\n            if (curtab_only) {\n              /* Ignore the match if the buffer is not open in\n               * the current tab. */\n              bool found_window = false;\n              FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n                if (wp->w_buffer == buf) {\n                  found_window = true;\n                  break;\n                }\n              }\n              if (!found_window) {\n                continue;\n              }\n            }\n            if (match >= 0) {                   // already found a match\n              match = -2;\n              break;\n            }\n            match = buf->b_fnum;                // remember first match\n          }\n        }\n\n        vim_regfree(regmatch.regprog);\n        if (match >= 0) {                       // found one match\n          break;\n        }\n      }\n\n      /* Only search for unlisted buffers if there was no match with\n       * a listed buffer. */\n      if (!unlisted || !find_listed || match != -1) {\n        break;\n      }\n      find_listed = false;\n    }\n\n    xfree(pat);\n  }\n\n  if (match == -2) {\n    EMSG2(_(\"E93: More than one match for %s\"), pattern);\n  } else if (match < 0) {\n    EMSG2(_(\"E94: No matching buffer for %s\"), pattern);\n  }\n  return match;\n}\n\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n\n/// Compare functions for qsort() below, that compares b_last_used.\nstatic int\nbuf_time_compare(const void *s1, const void *s2)\n{\n  buf_T *buf1 = *(buf_T **)s1;\n  buf_T *buf2 = *(buf_T **)s2;\n\n  if (buf1->b_last_used == buf2->b_last_used) {\n    return 0;\n  }\n  return buf1->b_last_used > buf2->b_last_used ? -1 : 1;\n}\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\nint ExpandBufnames(char_u *pat, int *num_file, char_u ***file, int options)\n{\n  int count = 0;\n  int round;\n  char_u      *p;\n  int attempt;\n  char_u      *patc;\n  bufmatch_T  *matches = NULL;\n\n  *num_file = 0;                    // return values in case of FAIL\n  *file = NULL;\n\n  if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff) {\n    return FAIL;\n  }\n\n  // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\".\n  if (*pat == '^') {\n    patc = xmalloc(STRLEN(pat) + 11);\n    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n    STRCPY(patc + 11, pat + 1);\n  } else\n    patc = pat;\n\n  /*\n   * attempt == 0: try match with    '\\<', match at start of word\n   * attempt == 1: try match without '\\<', match anywhere\n   */\n  for (attempt = 0; attempt <= 1; attempt++) {\n    if (attempt > 0 && patc == pat) {\n      break;            // there was no anchor, no need to try again\n    }\n\n    regmatch_T regmatch;\n    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n    if (regmatch.regprog == NULL) {\n      if (patc != pat) {\n        xfree(patc);\n      }\n      return FAIL;\n    }\n\n    /*\n     * round == 1: Count the matches.\n     * round == 2: Build the array to keep the matches.\n     */\n    for (round = 1; round <= 2; round++) {\n      count = 0;\n      FOR_ALL_BUFFERS(buf) {\n        if (!buf->b_p_bl) {             // skip unlisted buffers\n          continue;\n        }\n        if (options & BUF_DIFF_FILTER) {\n          // Skip buffers not suitable for\n          // :diffget or :diffput completion.\n          if (buf == curbuf || !diff_mode_buf(buf)) {\n            continue;\n          }\n        }\n        p = buflist_match(&regmatch, buf, p_wic);\n        if (p != NULL) {\n          if (round == 1) {\n            count++;\n          } else {\n            if (options & WILD_HOME_REPLACE) {\n              p = home_replace_save(buf, p);\n            } else {\n              p = vim_strsave(p);\n            }\n            if (matches != NULL) {\n              matches[count].buf = buf;\n              matches[count].match = p;\n              count++;\n            } else {\n              (*file)[count++] = p;\n            }\n          }\n        }\n      }\n      if (count == 0) {         // no match found, break here\n        break;\n      }\n      if (round == 1) {\n        *file = xmalloc((size_t)count * sizeof(**file));\n\n        if (options & WILD_BUFLASTUSED) {\n          matches = xmalloc((size_t)count * sizeof(*matches));\n        }\n      }\n    }\n    vim_regfree(regmatch.regprog);\n    if (count) {                // match(es) found, break here\n      break;\n    }\n  }\n\n  if (patc != pat) {\n    xfree(patc);\n  }\n\n  if (matches != NULL) {\n    if (count > 1) {\n      qsort(matches, (size_t)count, sizeof(bufmatch_T), buf_time_compare);\n    }\n\n    // if the current buffer is first in the list, place it at the end\n    if (matches[0].buf == curbuf) {\n      for (int i = 1; i < count; i++) {\n        (*file)[i-1] = matches[i].match;\n      }\n      (*file)[count-1] = matches[0].match;\n    } else {\n      for (int i = 0; i < count; i++) {\n        (*file)[i] = matches[i].match;\n      }\n    }\n    xfree(matches);\n  }\n\n  *num_file = count;\n  return count == 0 ? FAIL : OK;\n}\n\n\n/// Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n///\n/// @param ignore_case When true, ignore case. Use 'fic' otherwise.\nstatic char_u *buflist_match(regmatch_T *rmp, buf_T *buf, bool ignore_case)\n{\n  // First try the short file name, then the long file name.\n  char_u *match = fname_match(rmp, buf->b_sfname, ignore_case);\n  if (match == NULL) {\n    match = fname_match(rmp, buf->b_ffname, ignore_case);\n  }\n  return match;\n}\n\n/// Try matching the regexp in \"prog\" with file name \"name\".\n///\n/// @param ignore_case When true, ignore case. Use 'fileignorecase' otherwise.\n/// @return \"name\" when there is a match, NULL when not.\nstatic char_u *fname_match(regmatch_T *rmp, char_u *name, bool ignore_case)\n{\n  char_u      *match = NULL;\n  char_u      *p;\n\n  if (name != NULL) {\n    // Ignore case when 'fileignorecase' or the argument is set.\n    rmp->rm_ic = p_fic || ignore_case;\n    if (vim_regexec(rmp, name, (colnr_T)0)) {\n      match = name;\n    } else {\n      // Replace $(HOME) with '~' and try matching again.\n      p = home_replace_save(NULL, name);\n      if (vim_regexec(rmp, p, (colnr_T)0)) {\n        match = name;\n      }\n      xfree(p);\n    }\n  }\n\n  return match;\n}\n\n/// Find a file in the buffer list by buffer number.\nbuf_T *buflist_findnr(int nr)\n{\n  if (nr == 0) {\n    nr = curwin->w_alt_fnum;\n  }\n\n  return handle_get_buffer((handle_T)nr);\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\nchar_u *\nbuflist_nr2name(\n    int n,\n    int fullname,\n    int helptail                   // for help buffers return tail only\n)\n{\n  buf_T       *buf;\n\n  buf = buflist_findnr(n);\n  if (buf == NULL) {\n    return NULL;\n  }\n  return home_replace_save(helptail ? buf : NULL,\n      fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/// Set the line and column numbers for the given buffer and window\n///\n/// @param[in,out]  buf           Buffer for which line and column are set.\n/// @param[in,out]  win           Window for which line and column are set.\n///                               May be NULL when using :badd.\n/// @param[in]      lnum          Line number to be set. If it is zero then only\n///                               options are touched.\n/// @param[in]      col           Column number to be set.\n/// @param[in]      copy_options  If true save the local window option values.\nvoid buflist_setfpos(buf_T *const buf, win_T *const win,\n                     linenr_T lnum, colnr_T col,\n                     bool copy_options)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  wininfo_T   *wip;\n\n  for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {\n    if (wip->wi_win == win) {\n      break;\n    }\n  }\n  if (wip == NULL) {\n    // allocate a new entry\n    wip = xcalloc(1, sizeof(wininfo_T));\n    wip->wi_win = win;\n    if (lnum == 0) {            // set lnum even when it's 0\n      lnum = 1;\n    }\n  } else {\n    // remove the entry from the list\n    if (wip->wi_prev) {\n      wip->wi_prev->wi_next = wip->wi_next;\n    } else {\n      buf->b_wininfo = wip->wi_next;\n    }\n    if (wip->wi_next) {\n      wip->wi_next->wi_prev = wip->wi_prev;\n    }\n    if (copy_options && wip->wi_optset) {\n      clear_winopt(&wip->wi_opt);\n      deleteFoldRecurse(buf, &wip->wi_folds);\n    }\n  }\n  if (lnum != 0) {\n    wip->wi_fpos.lnum = lnum;\n    wip->wi_fpos.col = col;\n  }\n  if (copy_options && win != NULL) {\n    // Save the window-specific option values.\n    copy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n    wip->wi_fold_manual = win->w_fold_manual;\n    cloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n    wip->wi_optset = true;\n  }\n\n  // insert the entry in front of the list\n  wip->wi_next = buf->b_wininfo;\n  buf->b_wininfo = wip;\n  wip->wi_prev = NULL;\n  if (wip->wi_next) {\n    wip->wi_next->wi_prev = wip;\n  }\n\n  return;\n}\n\n\n/// Check that \"wip\" has 'diff' set and the diff is only for another tab page.\n/// That's because a diff is local to a tab page.\nstatic bool wininfo_other_tab_diff(wininfo_T *wip)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (wip->wi_opt.wo_diff) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      // return false when it's a window in the current tab page, thus\n      // the buffer was in diff mode here\n      if (wip->wi_win == wp) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n// Find info for the current window in buffer \"buf\".\n// If not found, return the info for the most recently used window.\n// When \"need_options\" is true skip entries where wi_optset is false.\n// When \"skip_diff_buffer\" is true avoid windows with 'diff' set that is in\n// another tab page.\n// Returns NULL when there isn't any info.\nstatic wininfo_T *find_wininfo(buf_T *buf, bool need_options,\n                               bool skip_diff_buffer)\n  FUNC_ATTR_NONNULL_ALL\n{\n  wininfo_T   *wip;\n\n  for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {\n    if (wip->wi_win == curwin\n        && (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n        && (!need_options || wip->wi_optset)) {\n      break;\n    }\n  }\n\n  // If no wininfo for curwin, use the first in the list (that doesn't have\n  // 'diff' set and is in another tab page).\n  // If \"need_options\" is true skip entries that don't have options set,\n  // unless the window is editing \"buf\", so we can copy from the window\n  // itself.\n  if (wip == NULL) {\n    if (skip_diff_buffer) {\n      for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {\n        if (!wininfo_other_tab_diff(wip)\n            && (!need_options\n                || wip->wi_optset\n                || (wip->wi_win != NULL\n                    && wip->wi_win->w_buffer == buf))) {\n          break;\n        }\n      }\n    } else {\n      wip = buf->b_wininfo;\n    }\n  }\n  return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\nvoid get_winopts(buf_T *buf)\n{\n  clear_winopt(&curwin->w_onebuf_opt);\n  clearFolding(curwin);\n\n  wininfo_T *const wip = find_wininfo(buf, true, true);\n  if (wip != NULL && wip->wi_win != curwin && wip->wi_win != NULL\n      && wip->wi_win->w_buffer == buf) {\n    win_T *wp = wip->wi_win;\n    copy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n    curwin->w_fold_manual = wp->w_fold_manual;\n    curwin->w_foldinvalid = true;\n    cloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n  } else if (wip != NULL && wip->wi_optset) {\n    copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n    curwin->w_fold_manual = wip->wi_fold_manual;\n    curwin->w_foldinvalid = true;\n    cloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n  } else\n    copy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n\n  if (curwin->w_float_config.style == kWinStyleMinimal) {\n    didset_window_options(curwin);\n    win_set_minimal_style(curwin);\n  }\n\n  // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n  if (p_fdls >= 0) {\n    curwin->w_p_fdl = p_fdls;\n  }\n  didset_window_options(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\npos_T *buflist_findfpos(buf_T *buf)\n{\n  static pos_T no_position = { 1, 0, 0 };\n\n  wininfo_T *const wip = find_wininfo(buf, false, false);\n  return (wip == NULL) ? &no_position : &(wip->wi_fpos);\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\nlinenr_T buflist_findlnum(buf_T *buf)\n{\n  return buflist_findfpos(buf)->lnum;\n}\n\n// List all known file names (for :files and :buffers command).\nvoid buflist_list(exarg_T *eap)\n{\n  buf_T       *buf = firstbuf;\n  int len;\n  int i;\n\n  garray_T buflist;\n  buf_T **buflist_data = NULL;\n\n  if (vim_strchr(eap->arg, 't')) {\n    ga_init(&buflist, sizeof(buf_T *), 50);\n    for (buf = firstbuf; buf != NULL; buf = buf->b_next) {\n      ga_grow(&buflist, 1);\n      ((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n    }\n\n    qsort(buflist.ga_data, (size_t)buflist.ga_len,\n          sizeof(buf_T *), buf_time_compare);\n\n    buflist_data = (buf_T **)buflist.ga_data;\n    buf = *buflist_data;\n  }\n  buf_T **p = buflist_data;\n\n  for (;\n       buf != NULL && !got_int;\n       buf = buflist_data != NULL\n       ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n       : buf->b_next) {\n    const bool is_terminal = buf->terminal;\n    const bool job_running = buf->terminal && terminal_running(buf->terminal);\n\n    // skip unspecified buffers\n    if ((!buf->b_p_bl && !eap->forceit && !strchr((char *)eap->arg, 'u'))\n        || (strchr((char *)eap->arg, 'u') && buf->b_p_bl)\n        || (strchr((char *)eap->arg, '+')\n            && ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n        || (strchr((char *)eap->arg, 'a')\n            && (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n        || (strchr((char *)eap->arg, 'h')\n            && (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n        || (strchr((char *)eap->arg, 'R') && (!is_terminal || !job_running))\n        || (strchr((char *)eap->arg, 'F') && (!is_terminal || job_running))\n        || (strchr((char *)eap->arg, '-') && buf->b_p_ma)\n        || (strchr((char *)eap->arg, '=') && !buf->b_p_ro)\n        || (strchr((char *)eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n        || (strchr((char *)eap->arg, '%') && buf != curbuf)\n        || (strchr((char *)eap->arg, '#')\n            && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum))) {\n      continue;\n    }\n    if (buf_spname(buf) != NULL) {\n      STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);\n    } else {\n      home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, true);\n    }\n\n    if (message_filtered(NameBuff)) {\n      continue;\n    }\n\n    const int changed_char = (buf->b_flags & BF_READERR)\n      ? 'x'\n      : (bufIsChanged(buf) ? '+' : ' ');\n    int ro_char = !MODIFIABLE(buf) ? '-' : (buf->b_p_ro ? '=' : ' ');\n    if (buf->terminal) {\n      ro_char = channel_job_running((uint64_t)buf->b_p_channel) ? 'R' : 'F';\n    }\n\n    msg_putchar('\\n');\n    len = vim_snprintf(\n        (char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n        buf->b_fnum,\n        buf->b_p_bl ? ' ' : 'u',\n        buf == curbuf ? '%' : (curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n        buf->b_ml.ml_mfp == NULL ? ' ' : (buf->b_nwindows == 0 ? 'h' : 'a'),\n        ro_char,\n        changed_char,\n        NameBuff);\n\n    if (len > IOSIZE - 20) {\n        len = IOSIZE - 20;\n    }\n\n    // put \"line 999\" in column 40 or after the file name\n    i = 40 - vim_strsize(IObuff);\n    do {\n      IObuff[len++] = ' ';\n    } while (--i > 0 && len < IOSIZE - 18);\n    if (vim_strchr(eap->arg, 't') && buf->b_last_used) {\n      add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n    } else {\n      vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n                   _(\"line %\" PRId64),\n                   buf == curbuf ? (int64_t)curwin->w_cursor.lnum\n                   : (int64_t)buflist_findlnum(buf));\n    }\n\n    msg_outtrans(IObuff);\n    line_breakcheck();\n  }\n\n  if (buflist_data) {\n    ga_clear(&buflist);\n  }\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\nint buflist_name_nr(int fnum, char_u **fname, linenr_T *lnum)\n{\n  buf_T       *buf;\n\n  buf = buflist_findnr(fnum);\n  if (buf == NULL || buf->b_fname == NULL) {\n    return FAIL;\n  }\n\n  *fname = buf->b_fname;\n  *lnum = buflist_findlnum(buf);\n\n  return OK;\n}\n\n// Set the file name for \"buf\" to \"ffname_arg\", short file name to\n// \"sfname_arg\".\n// The file name with the full path is also remembered, for when :cd is used.\n// Returns FAIL for failure (file name already in use by other buffer)\n//      OK otherwise.\nint setfname(\n    buf_T *buf,\n    char_u *ffname_arg,\n    char_u *sfname_arg,\n    bool message                  // give message when buffer already exists\n)\n{\n  char_u *ffname = ffname_arg;\n  char_u *sfname = sfname_arg;\n  buf_T       *obuf = NULL;\n  FileID file_id;\n  bool file_id_valid = false;\n\n  if (ffname == NULL || *ffname == NUL) {\n    // Removing the name.\n    if (buf->b_sfname != buf->b_ffname) {\n      XFREE_CLEAR(buf->b_sfname);\n    } else {\n      buf->b_sfname = NULL;\n    }\n    XFREE_CLEAR(buf->b_ffname);\n  } else {\n    fname_expand(buf, &ffname, &sfname);    // will allocate ffname\n    if (ffname == NULL) {                   // out of memory\n      return FAIL;\n    }\n\n    /*\n     * if the file name is already used in another buffer:\n     * - if the buffer is loaded, fail\n     * - if the buffer is not loaded, delete it from the list\n     */\n    file_id_valid = os_fileid((char *)ffname, &file_id);\n    if (!(buf->b_flags & BF_DUMMY)) {\n      obuf = buflist_findname_file_id(ffname, &file_id, file_id_valid);\n    }\n    if (obuf != NULL && obuf != buf) {\n      if (obuf->b_ml.ml_mfp != NULL) {          // it's loaded, fail\n        if (message) {\n          EMSG(_(\"E95: Buffer with this name already exists\"));\n        }\n        xfree(ffname);\n        return FAIL;\n      }\n      // delete from the list\n      close_buffer(NULL, obuf, DOBUF_WIPE, false);\n    }\n    sfname = vim_strsave(sfname);\n#ifdef USE_FNAME_CASE\n    path_fix_case(sfname);            // set correct case for short file name\n#endif\n    if (buf->b_sfname != buf->b_ffname) {\n      xfree(buf->b_sfname);\n    }\n    xfree(buf->b_ffname);\n    buf->b_ffname = ffname;\n    buf->b_sfname = sfname;\n  }\n  buf->b_fname = buf->b_sfname;\n  if (!file_id_valid) {\n    buf->file_id_valid = false;\n  } else {\n    buf->file_id_valid = true;\n    buf->file_id = file_id;\n  }\n\n  buf_name_changed(buf);\n  return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\nvoid buf_set_name(int fnum, char_u *name)\n{\n  buf_T       *buf;\n\n  buf = buflist_findnr(fnum);\n  if (buf != NULL) {\n    if (buf->b_sfname != buf->b_ffname) {\n      xfree(buf->b_sfname);\n    }\n    xfree(buf->b_ffname);\n    buf->b_ffname = vim_strsave(name);\n    buf->b_sfname = NULL;\n    /* Allocate ffname and expand into full path.  Also resolves .lnk\n     * files on Win32. */\n    fname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n    buf->b_fname = buf->b_sfname;\n  }\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\nvoid buf_name_changed(buf_T *buf)\n{\n  /*\n   * If the file name changed, also change the name of the swapfile\n   */\n  if (buf->b_ml.ml_mfp != NULL) {\n    ml_setname(buf);\n  }\n\n  if (curwin->w_buffer == buf) {\n    check_arg_idx(curwin);      // check file name for arg list\n  }\n  maketitle();                  // set window title\n  status_redraw_all();          // status lines need to be redrawn\n  fmarks_check_names(buf);      // check named file marks\n  ml_timestamp(buf);            // reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\nbuf_T *setaltfname(char_u *ffname, char_u *sfname, linenr_T lnum)\n{\n  buf_T       *buf;\n\n  // Create a buffer.  'buflisted' is not set if it's a new buffer\n  buf = buflist_new(ffname, sfname, lnum, 0);\n  if (buf != NULL && !cmdmod.keepalt) {\n    curwin->w_alt_fnum = buf->b_fnum;\n  }\n  return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\nchar_u * getaltfname(\n    bool errmsg                   // give error message\n)\n{\n  char_u      *fname;\n  linenr_T dummy;\n\n  if (buflist_name_nr(0, &fname, &dummy) == FAIL) {\n    if (errmsg) {\n      EMSG(_(e_noalt));\n    }\n    return NULL;\n  }\n  return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\nint buflist_add(char_u *fname, int flags)\n{\n  buf_T       *buf;\n\n  buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n  if (buf != NULL) {\n    return buf->b_fnum;\n  }\n  return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\nvoid buflist_slash_adjust(void)\n{\n  FOR_ALL_BUFFERS(bp) {\n    if (bp->b_ffname != NULL) {\n      slash_adjust(bp->b_ffname);\n    }\n    if (bp->b_sfname != NULL) {\n      slash_adjust(bp->b_sfname);\n    }\n  }\n}\n\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\nvoid buflist_altfpos(win_T *win)\n{\n  buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, true);\n}\n\n/// Check that \"ffname\" is not the same file as current file.\n/// Fname must have a full path (expanded by path_to_absolute()).\n///\n/// @param  ffname  full path name to check\nbool otherfile(char_u *ffname)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  return otherfile_buf(curbuf, ffname, NULL, false);\n}\n\n/// Check that \"ffname\" is not the same file as the file loaded in \"buf\".\n/// Fname must have a full path (expanded by path_to_absolute()).\n///\n/// @param  buf            buffer to check\n/// @param  ffname         full path name to check\n/// @param  file_id_p      information about the file at \"ffname\".\n/// @param  file_id_valid  whether a valid \"file_id_p\" was passed in.\nstatic bool otherfile_buf(buf_T *buf, char_u *ffname, FileID *file_id_p,\n                          bool file_id_valid)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // no name is different\n  if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL) {\n    return true;\n  }\n  if (fnamecmp(ffname, buf->b_ffname) == 0) {\n    return false;\n  }\n  {\n    FileID file_id;\n    // If no struct stat given, get it now\n    if (file_id_p == NULL) {\n      file_id_p = &file_id;\n      file_id_valid = os_fileid((char *)ffname, file_id_p);\n    }\n    if (!file_id_valid) {\n      // file_id not valid, assume files are different.\n      return true;\n    }\n    // Use dev/ino to check if the files are the same, even when the names\n    // are different (possible with links).  Still need to compare the\n    // name above, for when the file doesn't exist yet.\n    // Problem: The dev/ino changes when a file is deleted (and created\n    // again) and remains the same when renamed/moved.  We don't want to\n    // stat() each buffer each time, that would be too slow.  Get the\n    // dev/ino again when they appear to match, but not when they appear\n    // to be different: Could skip a buffer when it's actually the same\n    // file.\n    if (buf_same_file_id(buf, file_id_p)) {\n      buf_set_file_id(buf);\n      if (buf_same_file_id(buf, file_id_p)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// Set file_id for a buffer.\n// Must always be called when b_fname is changed!\nvoid buf_set_file_id(buf_T *buf)\n{\n  FileID file_id;\n  if (buf->b_fname != NULL\n      && os_fileid((char *)buf->b_fname, &file_id)) {\n    buf->file_id_valid = true;\n    buf->file_id = file_id;\n  } else {\n    buf->file_id_valid = false;\n  }\n}\n\n/// Check that file_id in buffer \"buf\" matches with \"file_id\".\n///\n/// @param  buf      buffer\n/// @param  file_id  file id\nstatic bool buf_same_file_id(buf_T *buf, FileID *file_id)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  return buf->file_id_valid && os_fileid_equal(&(buf->file_id), file_id);\n}\n\n/*\n * Print info about the current buffer.\n */\nvoid\nfileinfo(\n    int fullname,               // when non-zero print full path\n    int shorthelp,\n    int dont_truncate\n)\n{\n  char_u      *name;\n  int n;\n  char_u      *p;\n  char_u      *buffer;\n  size_t len;\n\n  buffer = xmalloc(IOSIZE);\n\n  if (fullname > 1) {       // 2 CTRL-G: include buffer number\n    vim_snprintf((char *)buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n    p = buffer + STRLEN(buffer);\n  } else\n    p = buffer;\n\n  *p++ = '\"';\n  if (buf_spname(curbuf) != NULL) {\n    STRLCPY(p, buf_spname(curbuf), IOSIZE - (p - buffer));\n  } else {\n    if (!fullname && curbuf->b_fname != NULL) {\n      name = curbuf->b_fname;\n    } else {\n      name = curbuf->b_ffname;\n    }\n    home_replace(shorthelp ? curbuf : NULL, name, p,\n                 (size_t)(IOSIZE - (p - buffer)), true);\n  }\n\n  vim_snprintf_add((char *)buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n                   curbufIsChanged()\n                   ? (shortmess(SHM_MOD) ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n                   (curbuf->b_flags & BF_NOTEDITED) && !bt_dontwrite(curbuf)\n                   ? _(\"[Not edited]\") : \"\",\n                   (curbuf->b_flags & BF_NEW) && !bt_dontwrite(curbuf)\n                   ? new_file_message() : \"\",\n                   (curbuf->b_flags & BF_READERR)\n                   ? _(\"[Read errors]\") : \"\",\n                   curbuf->b_p_ro\n                   ? (shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\")) : \"\",\n                   (curbufIsChanged()\n                    || (curbuf->b_flags & BF_WRITE_MASK)\n                    || curbuf->b_p_ro)\n                   ? \" \" : \"\");\n  // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n  // causes an overflow, thus for large numbers divide instead.\n  if (curwin->w_cursor.lnum > 1000000L) {\n    n = (int)(((long)curwin->w_cursor.lnum) /\n              ((long)curbuf->b_ml.ml_line_count / 100L));\n  } else {\n    n = (int)(((long)curwin->w_cursor.lnum * 100L) /\n              (long)curbuf->b_ml.ml_line_count);\n  }\n  if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n    vim_snprintf_add((char *)buffer, IOSIZE, \"%s\", _(no_lines_msg));\n  } else if (p_ru) {\n    // Current line and column are already on the screen -- webb\n    if (curbuf->b_ml.ml_line_count == 1) {\n      vim_snprintf_add((char *)buffer, IOSIZE, _(\"1 line --%d%%--\"), n);\n    } else {\n      vim_snprintf_add((char *)buffer, IOSIZE, _(\"%\" PRId64 \" lines --%d%%--\"),\n                       (int64_t)curbuf->b_ml.ml_line_count, n);\n    }\n  } else {\n    vim_snprintf_add((char *)buffer, IOSIZE,\n        _(\"line %\" PRId64 \" of %\" PRId64 \" --%d%%-- col \"),\n        (int64_t)curwin->w_cursor.lnum,\n        (int64_t)curbuf->b_ml.ml_line_count,\n        n);\n    validate_virtcol();\n    len = STRLEN(buffer);\n    col_print(buffer + len, IOSIZE - len,\n        (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n  }\n\n  (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));\n\n  if (dont_truncate) {\n    /* Temporarily set msg_scroll to avoid the message being truncated.\n     * First call msg_start() to get the message in the right place. */\n    msg_start();\n    n = msg_scroll;\n    msg_scroll = true;\n    msg(buffer);\n    msg_scroll = n;\n  } else {\n    p = msg_trunc_attr(buffer, false, 0);\n    if (restart_edit != 0 || (msg_scrolled && !need_wait_return)) {\n      // Need to repeat the message after redrawing when:\n      // - When restart_edit is set (otherwise there will be a delay\n      //   before redrawing).\n      // - When the screen was scrolled but there is no wait-return\n      //   prompt.\n      set_keep_msg(p, 0);\n    }\n  }\n\n  xfree(buffer);\n}\n\nvoid col_print(char_u *buf, size_t buflen, int col, int vcol)\n{\n  if (col == vcol) {\n    vim_snprintf((char *)buf, buflen, \"%d\", col);\n  } else {\n    vim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n  }\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n\n// Put the title name in the title bar and icon of the window.\nvoid maketitle(void)\n{\n  char_u *title_str = NULL;\n  char_u *icon_str = NULL;\n  int maxlen = 0;\n  int len;\n  int mustset;\n  char buf[IOSIZE];\n\n  if (!redrawing()) {\n    // Postpone updating the title when 'lazyredraw' is set.\n    need_maketitle = true;\n    return;\n  }\n\n  need_maketitle = false;\n  if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL) {\n    return;  // nothing to do\n  }\n\n  if (p_title) {\n    if (p_titlelen > 0) {\n      maxlen = (int)(p_titlelen * Columns / 100);\n      if (maxlen < 10) {\n        maxlen = 10;\n      }\n    }\n\n    if (*p_titlestring != NUL) {\n      if (stl_syntax & STL_IN_TITLE) {\n        int use_sandbox = false;\n        int save_called_emsg = called_emsg;\n\n        use_sandbox = was_set_insecurely(curwin, (char_u *)\"titlestring\", 0);\n        called_emsg = false;\n        build_stl_str_hl(curwin, (char_u *)buf, sizeof(buf),\n                         p_titlestring, use_sandbox,\n                         0, maxlen, NULL, NULL);\n        title_str = (char_u *)buf;\n        if (called_emsg) {\n          set_string_option_direct(\"titlestring\", -1, (char_u *)\"\",\n                                   OPT_FREE, SID_ERROR);\n        }\n        called_emsg |= save_called_emsg;\n      } else {\n        title_str = p_titlestring;\n      }\n    } else {\n      // Format: \"fname + (path) (1 of 2) - VIM\".\n\n#define SPACE_FOR_FNAME (sizeof(buf) - 100)\n#define SPACE_FOR_DIR   (sizeof(buf) - 20)\n#define SPACE_FOR_ARGNR (sizeof(buf) - 10)  // At least room for \" - NVIM\".\n      char *buf_p = buf;\n      if (curbuf->b_fname == NULL) {\n        const size_t size = xstrlcpy(buf_p, _(\"[No Name]\"),\n                                     SPACE_FOR_FNAME + 1);\n        buf_p += MIN(size, SPACE_FOR_FNAME);\n      } else {\n        buf_p += transstr_buf((const char *)path_tail(curbuf->b_fname),\n                              buf_p, SPACE_FOR_FNAME + 1);\n      }\n\n      switch (bufIsChanged(curbuf)\n              | (curbuf->b_p_ro << 1)\n              | (!MODIFIABLE(curbuf) << 2)) {\n        case 0: break;\n        case 1: buf_p = strappend(buf_p, \" +\"); break;\n        case 2: buf_p = strappend(buf_p, \" =\"); break;\n        case 3: buf_p = strappend(buf_p, \" =+\"); break;\n        case 4:\n        case 6: buf_p = strappend(buf_p, \" -\"); break;\n        case 5:\n        case 7: buf_p = strappend(buf_p, \" -+\"); break;\n        default: abort();\n      }\n\n      if (curbuf->b_fname != NULL) {\n        // Get path of file, replace home dir with ~.\n        *buf_p++ = ' ';\n        *buf_p++ = '(';\n        home_replace(curbuf, curbuf->b_ffname, (char_u *)buf_p,\n                     (SPACE_FOR_DIR - (size_t)(buf_p - buf)), true);\n#ifdef BACKSLASH_IN_FILENAME\n        // Avoid \"c:/name\" to be reduced to \"c\".\n        if (isalpha((uint8_t)buf_p) && *(buf_p + 1) == ':') {\n          buf_p += 2;\n        }\n#endif\n        // Remove the file name.\n        char *p = (char *)path_tail_with_sep((char_u *)buf_p);\n        if (p == buf_p) {\n          // Must be a help buffer.\n          xstrlcpy(buf_p, _(\"help\"), SPACE_FOR_DIR - (size_t)(buf_p - buf));\n        } else {\n          *p = NUL;\n        }\n\n        // Translate unprintable chars and concatenate.  Keep some\n        // room for the server name.  When there is no room (very long\n        // file name) use (...).\n        if ((size_t)(buf_p - buf) < SPACE_FOR_DIR) {\n          char *const tbuf = transstr(buf_p);\n          const size_t free_space = SPACE_FOR_DIR - (size_t)(buf_p - buf) + 1;\n          const size_t dir_len = xstrlcpy(buf_p, tbuf, free_space);\n          buf_p += MIN(dir_len, free_space - 1);\n          xfree(tbuf);\n        } else {\n          const size_t free_space = SPACE_FOR_ARGNR - (size_t)(buf_p - buf) + 1;\n          const size_t dots_len = xstrlcpy(buf_p, \"...\", free_space);\n          buf_p += MIN(dots_len, free_space - 1);\n        }\n        *buf_p++ = ')';\n        *buf_p = NUL;\n      } else {\n        *buf_p = NUL;\n      }\n\n      append_arg_number(curwin, (char_u *)buf_p,\n                        (int)(SPACE_FOR_ARGNR - (size_t)(buf_p - buf)), false);\n\n      xstrlcat(buf_p, \" - NVIM\", (sizeof(buf) - (size_t)(buf_p - buf)));\n\n      if (maxlen > 0) {\n        // Make it shorter by removing a bit in the middle.\n        if (vim_strsize((char_u *)buf) > maxlen) {\n          trunc_string((char_u *)buf, (char_u *)buf, maxlen, sizeof(buf));\n        }\n      }\n      title_str = (char_u *)buf;\n#undef SPACE_FOR_FNAME\n#undef SPACE_FOR_DIR\n#undef SPACE_FOR_ARGNR\n    }\n  }\n  mustset = value_change(title_str, &lasttitle);\n\n  if (p_icon) {\n    icon_str = (char_u *)buf;\n    if (*p_iconstring != NUL) {\n      if (stl_syntax & STL_IN_ICON) {\n        int use_sandbox = false;\n        int save_called_emsg = called_emsg;\n\n        use_sandbox = was_set_insecurely(curwin, (char_u *)\"iconstring\", 0);\n        called_emsg = false;\n        build_stl_str_hl(curwin, icon_str, sizeof(buf),\n                         p_iconstring, use_sandbox,\n                         0, 0, NULL, NULL);\n        if (called_emsg) {\n          set_string_option_direct(\"iconstring\", -1,\n                                   (char_u *)\"\", OPT_FREE, SID_ERROR);\n        }\n        called_emsg |= save_called_emsg;\n      } else {\n        icon_str = p_iconstring;\n      }\n    } else {\n      char_u *buf_p;\n      if (buf_spname(curbuf) != NULL) {\n        buf_p = buf_spname(curbuf);\n      } else {                        // use file name only in icon\n        buf_p = path_tail(curbuf->b_ffname);\n      }\n      *icon_str = NUL;\n      // Truncate name at 100 bytes.\n      len = (int)STRLEN(buf_p);\n      if (len > 100) {\n        len -= 100;\n        len += (*mb_tail_off)(buf_p, buf_p + len) + 1;\n        buf_p += len;\n      }\n      STRCPY(icon_str, buf_p);\n      trans_characters(icon_str, IOSIZE);\n    }\n  }\n\n  mustset |= value_change(icon_str, &lasticon);\n\n  if (mustset) {\n    resettitle();\n  }\n}\n\n/// Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n/// from \"str\" if it does by freeing the old value of \"*last\" and duplicating\n/// \"str\".\n///\n/// @param          str   desired title string\n/// @param[in,out]  last  current title string\n//\n/// @return true if resettitle() is to be called.\nstatic bool value_change(char_u *str, char_u **last)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if ((str == NULL) != (*last == NULL)\n      || (str != NULL && *last != NULL && STRCMP(str, *last) != 0)) {\n    xfree(*last);\n    if (str == NULL) {\n      *last = NULL;\n      resettitle();\n    } else {\n      *last = vim_strsave(str);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/// Set current window title\nvoid resettitle(void)\n{\n  ui_call_set_icon(cstr_as_string((char *)lasticon));\n  ui_call_set_title(cstr_as_string((char *)lasttitle));\n  ui_flush();\n}\n\n# if defined(EXITFREE)\nvoid free_titles(void)\n{\n  xfree(lasttitle);\n  xfree(lasticon);\n}\n\n# endif\n\n/// Enumeration specifying the valid numeric bases that can\n/// be used when printing numbers in the status line.\ntypedef enum {\n  kNumBaseDecimal = 10,\n  kNumBaseHexadecimal = 16\n} NumberBase;\n\n\n/// Build a string from the status line items in \"fmt\".\n/// Return length of string in screen cells.\n///\n/// Normally works for window \"wp\", except when working for 'tabline' then it\n/// is \"curwin\".\n///\n/// Items are drawn interspersed with the text that surrounds it\n/// Specials: %-<wid>(xxx%) => group, %= => separation marker, %< => truncation\n/// Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n///\n/// If maxwidth is not zero, the string will be filled at any middle marker\n/// or truncated if too long, fillchar is used for all whitespace.\n///\n/// @param wp The window to build a statusline for\n/// @param out The output buffer to write the statusline to\n///            Note: This should not be NameBuff\n/// @param outlen The length of the output buffer\n/// @param fmt The statusline format string\n/// @param use_sandbox Use a sandboxed environment when evaluating fmt\n/// @param fillchar Character to use when filling empty space in the statusline\n/// @param maxwidth The maximum width to make the statusline\n/// @param hltab HL attributes (can be NULL)\n/// @param tabtab Tab clicks definition (can be NULL).\n///\n/// @return The final width of the statusline\nint build_stl_str_hl(\n    win_T *wp,\n    char_u *out,\n    size_t outlen,\n    char_u *fmt,\n    int use_sandbox,\n    char_u fillchar,\n    int maxwidth,\n    stl_hlrec_t **hltab,\n    StlClickRecord **tabtab\n)\n{\n  static size_t stl_items_len = 20;  // Initial value, grows as needed.\n  static stl_item_t *stl_items = NULL;\n  static int *stl_groupitems = NULL;\n  static stl_hlrec_t *stl_hltab = NULL;\n  static StlClickRecord *stl_tabtab = NULL;\n  static int *stl_separator_locations = NULL;\n\n#define TMPLEN 70\n  char_u buf_tmp[TMPLEN];\n  char_u win_tmp[TMPLEN];\n  char_u      *usefmt = fmt;\n  const int save_must_redraw = must_redraw;\n  const int save_redr_type = curwin->w_redr_type;\n\n  if (stl_items == NULL) {\n    stl_items = xmalloc(sizeof(stl_item_t) * stl_items_len);\n    stl_groupitems = xmalloc(sizeof(int) * stl_items_len);\n    stl_hltab  = xmalloc(sizeof(stl_hlrec_t) * stl_items_len);\n    stl_tabtab = xmalloc(sizeof(StlClickRecord) * stl_items_len);\n    stl_separator_locations = xmalloc(sizeof(int) * stl_items_len);\n  }\n\n  // When the format starts with \"%!\" then evaluate it as an expression and\n  // use the result as the actual format string.\n  if (fmt[0] == '%' && fmt[1] == '!') {\n    typval_T tv = {\n      .v_type = VAR_NUMBER,\n      .vval.v_number = wp->handle,\n    };\n    set_var(S_LEN(\"g:statusline_winid\"), &tv, false);\n\n    usefmt = eval_to_string_safe(fmt + 2, NULL, use_sandbox);\n    if (usefmt == NULL) {\n      usefmt = fmt;\n    }\n\n    do_unlet(S_LEN(\"g:statusline_winid\"), true);\n  }\n\n  if (fillchar == 0) {\n    fillchar = ' ';\n  } else if (mb_char2len(fillchar) > 1) {\n    // Can't handle a multi-byte fill character yet.\n    fillchar = '-';\n  }\n\n  // The cursor in windows other than the current one isn't always\n  // up-to-date, esp. because of autocommands and timers.\n  linenr_T lnum = wp->w_cursor.lnum;\n  if (lnum > wp->w_buffer->b_ml.ml_line_count) {\n    lnum = wp->w_buffer->b_ml.ml_line_count;\n    wp->w_cursor.lnum = lnum;\n  }\n\n  // Get line & check if empty (cursorpos will show \"0-1\").\n  const char_u *line_ptr = ml_get_buf(wp->w_buffer, lnum, false);\n  bool empty_line = (*line_ptr == NUL);\n\n  // Get the byte value now, in case we need it below. This is more\n  // efficient than making a copy of the line.\n  int byteval;\n  const size_t len = STRLEN(line_ptr);\n  if (wp->w_cursor.col > (colnr_T)len) {\n    // Line may have changed since checking the cursor column, or the lnum\n    // was adjusted above.\n    wp->w_cursor.col = (colnr_T)len;\n    wp->w_cursor.coladd = 0;\n    byteval = 0;\n  } else {\n    byteval = utf_ptr2char(line_ptr + wp->w_cursor.col);\n  }\n\n  int groupdepth = 0;\n  int evaldepth  = 0;\n\n  int curitem = 0;\n  bool prevchar_isflag = true;\n  bool prevchar_isitem = false;\n\n  // out_p is the current position in the output buffer\n  char_u *out_p = out;\n\n  // out_end_p is the last valid character in the output buffer\n  // Note: The null termination character must occur here or earlier,\n  //       so any user-visible characters must occur before here.\n  char_u *out_end_p = (out + outlen) - 1;\n\n\n  // Proceed character by character through the statusline format string\n  // fmt_p is the current position in the input buffer\n  for (char_u *fmt_p = usefmt; *fmt_p; ) {\n    if (curitem == (int)stl_items_len) {\n        size_t new_len = stl_items_len * 3 / 2;\n\n        stl_items = xrealloc(stl_items, sizeof(stl_item_t) * new_len);\n        stl_groupitems = xrealloc(stl_groupitems, sizeof(int) * new_len);\n        stl_hltab = xrealloc(stl_hltab, sizeof(stl_hlrec_t) * new_len);\n        stl_tabtab = xrealloc(stl_tabtab, sizeof(StlClickRecord) * new_len);\n        stl_separator_locations =\n          xrealloc(stl_separator_locations, sizeof(int) * new_len);\n\n        stl_items_len = new_len;\n    }\n\n    if (*fmt_p != NUL && *fmt_p != '%') {\n      prevchar_isflag = prevchar_isitem = false;\n    }\n\n    // Copy the formatting verbatim until we reach the end of the string\n    // or find a formatting item (denoted by `%`)\n    // or run out of room in our output buffer.\n    while (*fmt_p != NUL && *fmt_p != '%' && out_p < out_end_p)\n      *out_p++ = *fmt_p++;\n\n    // If we have processed the entire format string or run out of\n    // room in our output buffer, exit the loop.\n    if (*fmt_p == NUL || out_p >= out_end_p) {\n      break;\n    }\n\n    // The rest of this loop will handle a single `%` item.\n    // Note: We increment here to skip over the `%` character we are currently\n    //       on so we can process the item's contents.\n    fmt_p++;\n\n    // Ignore `%` at the end of the format string\n    if (*fmt_p == NUL) {\n      break;\n    }\n\n    // Two `%` in a row is the escape sequence to print a\n    // single `%` in the output buffer.\n    if (*fmt_p == '%') {\n      *out_p++ = *fmt_p++;\n      prevchar_isflag = prevchar_isitem = false;\n      continue;\n    }\n\n    // STL_SEPARATE: Separation place between left and right aligned items.\n    if (*fmt_p == STL_SEPARATE) {\n      fmt_p++;\n      // Ignored when we are inside of a grouping\n      if (groupdepth > 0) {\n        continue;\n      }\n      stl_items[curitem].type = Separate;\n      stl_items[curitem++].start = out_p;\n      continue;\n    }\n\n    // STL_TRUNCMARK: Where to begin truncating if the statusline is too long.\n    if (*fmt_p == STL_TRUNCMARK) {\n      fmt_p++;\n      stl_items[curitem].type = Trunc;\n      stl_items[curitem++].start = out_p;\n      continue;\n    }\n\n    // The end of a grouping\n    if (*fmt_p == ')') {\n      fmt_p++;\n      // Ignore if we are not actually inside a group currently\n      if (groupdepth < 1) {\n        continue;\n      }\n      groupdepth--;\n\n      // Determine how long the group is.\n      // Note: We set the current output position to null\n      //       so `vim_strsize` will work.\n      char_u *t = stl_items[stl_groupitems[groupdepth]].start;\n      *out_p = NUL;\n      long group_len = vim_strsize(t);\n\n      // If the group contained internal items\n      // and the group did not have a minimum width,\n      // and if there were no normal items in the group,\n      // move the output pointer back to where the group started.\n      // Note: This erases any non-item characters that were in the group.\n      //       Otherwise there would be no reason to do this step.\n      if (curitem > stl_groupitems[groupdepth] + 1\n          && stl_items[stl_groupitems[groupdepth]].minwid == 0) {\n        // remove group if all items are empty and highlight group\n        // doesn't change\n        int group_start_userhl = 0;\n        int group_end_userhl = 0;\n        int n;\n        for (n = stl_groupitems[groupdepth] - 1; n >= 0; n--) {\n          if (stl_items[n].type == Highlight) {\n            group_start_userhl = group_end_userhl = stl_items[n].minwid;\n            break;\n          }\n        }\n        for (n = stl_groupitems[groupdepth] + 1; n < curitem; n++) {\n          if (stl_items[n].type == Normal) {\n            break;\n          }\n          if (stl_items[n].type == Highlight) {\n            group_end_userhl = stl_items[n].minwid;\n          }\n        }\n        if (n == curitem && group_start_userhl == group_end_userhl) {\n          // empty group\n          out_p = t;\n          group_len = 0;\n          for (n = stl_groupitems[groupdepth] + 1; n < curitem; n++) {\n            // do not use the highlighting from the removed group\n            if (stl_items[n].type == Highlight) {\n              stl_items[n].type = Empty;\n            }\n            // adjust the start position of TabPage to the next\n            // item position\n            if (stl_items[n].type == TabPage) {\n              stl_items[n].start = out_p;\n            }\n          }\n        }\n      }\n\n      // If the group is longer than it is allowed to be\n      // truncate by removing bytes from the start of the group text.\n      if (group_len > stl_items[stl_groupitems[groupdepth]].maxwid) {\n        // { Determine the number of bytes to remove\n\n        // Find the first character that should be included.\n        long n = 0;\n        while (group_len >= stl_items[stl_groupitems[groupdepth]].maxwid) {\n          group_len -= ptr2cells(t + n);\n          n += (*mb_ptr2len)(t + n);\n        }\n        // }\n\n        // Prepend the `<` to indicate that the output was truncated.\n        *t = '<';\n\n        // { Move the truncated output\n        memmove(t + 1, t + n, (size_t)(out_p - (t + n)));\n        out_p = out_p - n + 1;\n        // Fill up space left over by half a double-wide char.\n        while (++group_len < stl_items[stl_groupitems[groupdepth]].minwid) {\n          *out_p++ = fillchar;\n        }\n        // }\n\n        // correct the start of the items for the truncation\n        for (int idx = stl_groupitems[groupdepth] + 1; idx < curitem; idx++) {\n          // Shift everything back by the number of removed bytes\n          stl_items[idx].start -= n;\n\n          // If the item was partially or completely truncated, set its\n          // start to the start of the group\n          if (stl_items[idx].start < t) {\n            stl_items[idx].start = t;\n          }\n        }\n      // If the group is shorter than the minimum width, add padding characters.\n      } else if (\n          abs(stl_items[stl_groupitems[groupdepth]].minwid) > group_len) {\n        long min_group_width = stl_items[stl_groupitems[groupdepth]].minwid;\n        // If the group is left-aligned, add characters to the right.\n        if (min_group_width < 0) {\n          min_group_width = 0 - min_group_width;\n          while (group_len++ < min_group_width && out_p < out_end_p)\n            *out_p++ = fillchar;\n        // If the group is right-aligned, shift everything to the right and\n        // prepend with filler characters.\n        } else {\n          // { Move the group to the right\n          memmove(t + min_group_width - group_len, t, (size_t)(out_p - t));\n          group_len = min_group_width - group_len;\n          if (out_p + group_len >= (out_end_p + 1)) {\n            group_len = (long)(out_end_p - out_p);\n          }\n          out_p += group_len;\n          // }\n\n          // Adjust item start positions\n          for (int n = stl_groupitems[groupdepth] + 1; n < curitem; n++) {\n            stl_items[n].start += group_len;\n          }\n\n          // Prepend the fill characters\n          for (; group_len > 0; group_len--) {\n            *t++ = fillchar;\n          }\n        }\n      }\n      continue;\n    }\n    int minwid = 0;\n    int maxwid = 9999;\n    bool left_align = false;\n\n    // Denotes that numbers should be left-padded with zeros\n    bool zeropad = (*fmt_p == '0');\n    if (zeropad) {\n      fmt_p++;\n    }\n\n    // Denotes that the item should be left-aligned.\n    // This is tracked by using a negative length.\n    if (*fmt_p == '-') {\n      fmt_p++;\n      left_align = true;\n    }\n\n    // The first digit group is the item's min width\n    if (ascii_isdigit(*fmt_p)) {\n      minwid = getdigits_int(&fmt_p, false, 0);\n    }\n\n    // User highlight groups override the min width field\n    // to denote the styling to use.\n    if (*fmt_p == STL_USER_HL) {\n      stl_items[curitem].type = Highlight;\n      stl_items[curitem].start = out_p;\n      stl_items[curitem].minwid = minwid > 9 ? 1 : minwid;\n      fmt_p++;\n      curitem++;\n      continue;\n    }\n\n    // TABPAGE pairs are used to denote a region that when clicked will\n    // either switch to or close a tab.\n    //\n    // Ex: tabline=%0Ttab\\ zero%X\n    //   This tabline has a TABPAGENR item with minwid `0`,\n    //   which is then closed with a TABCLOSENR item.\n    //   Clicking on this region with mouse enabled will switch to tab 0.\n    //   Setting the minwid to a different value will switch\n    //   to that tab, if it exists\n    //\n    // Ex: tabline=%1Xtab\\ one%X\n    //   This tabline has a TABCLOSENR item with minwid `1`,\n    //   which is then closed with a TABCLOSENR item.\n    //   Clicking on this region with mouse enabled will close tab 0.\n    //   This is determined by the following formula:\n    //      tab to close = (1 - minwid)\n    //   This is because for TABPAGENR we use `minwid` = `tab number`.\n    //   For TABCLOSENR we store the tab number as a negative value.\n    //   Because 0 is a valid TABPAGENR value, we have to\n    //   start our numbering at `-1`.\n    //   So, `-1` corresponds to us wanting to close tab `0`\n    //\n    // Note: These options are only valid when creating a tabline.\n    if (*fmt_p == STL_TABPAGENR || *fmt_p == STL_TABCLOSENR) {\n      if (*fmt_p == STL_TABCLOSENR) {\n        if (minwid == 0) {\n          // %X ends the close label, go back to the previous tab label nr.\n          for (long n = curitem - 1; n >= 0; n--) {\n            if (stl_items[n].type == TabPage && stl_items[n].minwid >= 0) {\n              minwid = stl_items[n].minwid;\n              break;\n            }\n          }\n        } else {\n          // close nrs are stored as negative values\n          minwid = -minwid;\n        }\n      }\n      stl_items[curitem].type = TabPage;\n      stl_items[curitem].start = out_p;\n      stl_items[curitem].minwid = minwid;\n      fmt_p++;\n      curitem++;\n      continue;\n    }\n\n    if (*fmt_p == STL_CLICK_FUNC) {\n      fmt_p++;\n      char *t = (char *) fmt_p;\n      while (*fmt_p != STL_CLICK_FUNC && *fmt_p) {\n        fmt_p++;\n      }\n      if (*fmt_p != STL_CLICK_FUNC) {\n        break;\n      }\n      stl_items[curitem].type = ClickFunc;\n      stl_items[curitem].start = out_p;\n      stl_items[curitem].cmd = xmemdupz(t, (size_t)(((char *)fmt_p - t)));\n      stl_items[curitem].minwid = minwid;\n      fmt_p++;\n      curitem++;\n      continue;\n    }\n\n    // Denotes the end of the minwid\n    // the maxwid may follow immediately after\n    if (*fmt_p == '.') {\n      fmt_p++;\n      if (ascii_isdigit(*fmt_p)) {\n        maxwid = getdigits_int(&fmt_p, false, 50);\n      }\n    }\n\n    // Bound the minimum width at 50.\n    // Make the number negative to denote left alignment of the item\n    minwid = (minwid > 50 ? 50 : minwid) * (left_align ? -1 : 1);\n\n    // Denotes the start of a new group\n    if (*fmt_p == '(') {\n      stl_groupitems[groupdepth++] = curitem;\n      stl_items[curitem].type = Group;\n      stl_items[curitem].start = out_p;\n      stl_items[curitem].minwid = minwid;\n      stl_items[curitem].maxwid = maxwid;\n      fmt_p++;\n      curitem++;\n      continue;\n    }\n\n    // Denotes end of expanded %{} block\n    if (*fmt_p == '}' && evaldepth > 0) {\n        fmt_p++;\n        evaldepth--;\n        continue;\n    }\n\n    // An invalid item was specified.\n    // Continue processing on the next character of the format string.\n    if (vim_strchr(STL_ALL, *fmt_p) == NULL) {\n      fmt_p++;\n      continue;\n    }\n\n    // The status line item type\n    char_u opt = *fmt_p++;\n\n    // OK - now for the real work\n    NumberBase base = kNumBaseDecimal;\n    bool itemisflag = false;\n    bool fillable = true;\n    long num = -1;\n    char_u *str = NULL;\n    switch (opt) {\n    case STL_FILEPATH:\n    case STL_FULLPATH:\n    case STL_FILENAME:\n    {\n      // Set fillable to false so that ' ' in the filename will not\n      // get replaced with the fillchar\n      fillable = false;\n      if (buf_spname(wp->w_buffer) != NULL) {\n        STRLCPY(NameBuff, buf_spname(wp->w_buffer), MAXPATHL);\n      } else {\n        char_u *t = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n                     : wp->w_buffer->b_fname;\n        home_replace(wp->w_buffer, t, NameBuff, MAXPATHL, true);\n      }\n      trans_characters(NameBuff, MAXPATHL);\n      if (opt != STL_FILENAME) {\n        str = NameBuff;\n      } else {\n        str = path_tail(NameBuff);\n      }\n      break;\n    }\n    case STL_VIM_EXPR:     // '{'\n    {\n      char_u *block_start = fmt_p - 1;\n      int reevaluate = (*fmt_p == '%');\n      itemisflag = true;\n\n      if (reevaluate) {\n        fmt_p++;\n      }\n\n      // Attempt to copy the expression to evaluate into\n      // the output buffer as a null-terminated string.\n      char_u *t = out_p;\n      while ((*fmt_p != '}' || (reevaluate && fmt_p[-1] != '%'))\n             && *fmt_p != NUL && out_p < out_end_p) {\n        *out_p++ = *fmt_p++;\n      }\n      if (*fmt_p != '}') {          // missing '}' or out of space\n        break;\n      }\n      fmt_p++;\n      if (reevaluate) {\n        out_p[-1] = 0;  // remove the % at the end of %{% expr %}\n      } else {\n        *out_p = 0;\n      }\n\n      // Move our position in the output buffer\n      // to the beginning of the expression\n      out_p = t;\n\n      // { Evaluate the expression\n\n      // Store the current buffer number as a string variable\n      vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"%d\", curbuf->b_fnum);\n      set_internal_string_var(\"g:actual_curbuf\", buf_tmp);\n      vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->handle);\n      set_internal_string_var(\"g:actual_curwin\", win_tmp);\n\n      buf_T *const save_curbuf = curbuf;\n      win_T *const save_curwin = curwin;\n      const int save_VIsual_active = VIsual_active;\n      curwin = wp;\n      curbuf = wp->w_buffer;\n      // Visual mode is only valid in the current window.\n      if (curwin != save_curwin) {\n        VIsual_active = false;\n      }\n\n      // Note: The result stored in `t` is unused.\n      str = eval_to_string_safe(out_p, &t, use_sandbox);\n\n      curwin = save_curwin;\n      curbuf = save_curbuf;\n      VIsual_active = save_VIsual_active;\n\n      // Remove the variable we just stored\n      do_unlet(S_LEN(\"g:actual_curbuf\"), true);\n      do_unlet(S_LEN(\"g:actual_curwin\"), true);\n\n      // }\n\n      // Check if the evaluated result is a number.\n      // If so, convert the number to an int and free the string.\n      if (str != NULL && *str != 0) {\n        if (*skipdigits(str) == NUL) {\n          num = atoi((char *)str);\n          XFREE_CLEAR(str);\n          itemisflag = false;\n        }\n      }\n\n\n      // If the output of the expression needs to be evaluated\n      // replace the %{} block with the result of evaluation\n      if (reevaluate && str != NULL && *str != 0\n          && strchr((const char *)str, '%') != NULL\n          && evaldepth < MAX_STL_EVAL_DEPTH) {\n        size_t parsed_usefmt = (size_t)(block_start - usefmt);\n        size_t str_length = strlen((const char *)str);\n        size_t fmt_length = strlen((const char *)fmt_p);\n        size_t new_fmt_len = parsed_usefmt\n          + str_length + fmt_length + 3;\n        char_u *new_fmt = (char_u *)xmalloc(new_fmt_len * sizeof(char_u));\n        char_u *new_fmt_p = new_fmt;\n\n        new_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n          + parsed_usefmt;\n        new_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n          + str_length;\n        new_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n        new_fmt_p = (char_u *)memcpy(new_fmt_p , fmt_p, fmt_length)\n          + fmt_length;\n        *new_fmt_p = 0;\n        new_fmt_p = NULL;\n\n        if (usefmt != fmt) {\n          xfree(usefmt);\n        }\n        XFREE_CLEAR(str);\n        usefmt = new_fmt;\n        fmt_p = usefmt + parsed_usefmt;\n        evaldepth++;\n        continue;\n      }\n      break;\n    }\n\n    case STL_LINE:\n      num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n            ? 0L : (long)(wp->w_cursor.lnum);\n      break;\n\n    case STL_NUMLINES:\n      num = wp->w_buffer->b_ml.ml_line_count;\n      break;\n\n    case STL_COLUMN:\n      num = !(State & INSERT) && empty_line\n            ? 0 : (int)wp->w_cursor.col + 1;\n      break;\n\n    case STL_VIRTCOL:\n    case STL_VIRTCOL_ALT:\n    {\n      // In list mode virtcol needs to be recomputed\n      colnr_T virtcol = wp->w_virtcol;\n      if (wp->w_p_list && wp->w_p_lcs_chars.tab1 == NUL) {\n        wp->w_p_list = false;\n        getvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);\n        wp->w_p_list = true;\n      }\n      virtcol++;\n      // Don't display %V if it's the same as %c.\n      if (opt == STL_VIRTCOL_ALT\n          && (virtcol == (colnr_T)(!(State & INSERT) && empty_line\n                                   ? 0 : (int)wp->w_cursor.col + 1)))\n        break;\n      num = (long)virtcol;\n      break;\n    }\n\n    case STL_PERCENTAGE:\n      num = (int)(((long)wp->w_cursor.lnum * 100L) /\n                  (long)wp->w_buffer->b_ml.ml_line_count);\n      break;\n\n    case STL_ALTPERCENT:\n      // Store the position percentage in our temporary buffer.\n      // Note: We cannot store the value in `num` because\n      //       `get_rel_pos` can return a named position. Ex: \"Top\"\n      get_rel_pos(wp, buf_tmp, TMPLEN);\n      str = buf_tmp;\n      break;\n\n    case STL_ARGLISTSTAT:\n      fillable = false;\n\n      // Note: This is important because `append_arg_number` starts appending\n      //       at the end of the null-terminated string.\n      //       Setting the first byte to null means it will place the argument\n      //       number string at the beginning of the buffer.\n      buf_tmp[0] = 0;\n\n      // Note: The call will only return true if it actually\n      //       appended data to the `buf_tmp` buffer.\n      if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), false)) {\n        str = buf_tmp;\n      }\n      break;\n\n    case STL_KEYMAP:\n      fillable = false;\n      if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN)) {\n        str = buf_tmp;\n      }\n      break;\n    case STL_PAGENUM:\n      num = printer_page_num;\n      break;\n\n    case STL_BUFNO:\n      num = wp->w_buffer->b_fnum;\n      break;\n\n    case STL_OFFSET_X:\n      base = kNumBaseHexadecimal;\n      FALLTHROUGH;\n    case STL_OFFSET:\n    {\n      long l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL,\n                                      false);\n      num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0 ?\n            0L : l + 1 + (!(State & INSERT) && empty_line ?\n                          0 : (int)wp->w_cursor.col);\n      break;\n    }\n    case STL_BYTEVAL_X:\n      base = kNumBaseHexadecimal;\n      FALLTHROUGH;\n    case STL_BYTEVAL:\n      num = byteval;\n      if (num == NL) {\n        num = 0;\n      } else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC) {\n        num = NL;\n      }\n      break;\n\n    case STL_ROFLAG:\n    case STL_ROFLAG_ALT:\n      itemisflag = true;\n      if (wp->w_buffer->b_p_ro) {\n        str = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n      }\n      break;\n\n    case STL_HELPFLAG:\n    case STL_HELPFLAG_ALT:\n      itemisflag = true;\n      if (wp->w_buffer->b_help)\n        str = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n                         : _(\"[Help]\"));\n      break;\n\n    case STL_FILETYPE:\n      // Copy the filetype if it is not null and the formatted string will fit\n      // in the temporary buffer\n      // (including the brackets and null terminating character)\n      if (*wp->w_buffer->b_p_ft != NUL\n          && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3) {\n        vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n                     wp->w_buffer->b_p_ft);\n        str = buf_tmp;\n      }\n      break;\n\n    case STL_FILETYPE_ALT:\n    {\n      itemisflag = true;\n      // Copy the filetype if it is not null and the formatted string will fit\n      // in the temporary buffer\n      // (including the comma and null terminating character)\n      if (*wp->w_buffer->b_p_ft != NUL\n          && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2) {\n        vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n                     wp->w_buffer->b_p_ft);\n        // Uppercase the file extension\n        for (char_u *t = buf_tmp; *t != 0; t++) {\n          *t = (char_u)TOUPPER_LOC(*t);\n        }\n        str = buf_tmp;\n      }\n      break;\n    }\n    case STL_PREVIEWFLAG:\n    case STL_PREVIEWFLAG_ALT:\n      itemisflag = true;\n      if (wp->w_p_pvw)\n        str = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n                         : _(\"[Preview]\"));\n      break;\n\n    case STL_QUICKFIX:\n      if (bt_quickfix(wp->w_buffer))\n        str = (char_u *)(wp->w_llist_ref\n                         ? _(msg_loclist)\n                         : _(msg_qflist));\n      break;\n\n    case STL_MODIFIED:\n    case STL_MODIFIED_ALT:\n      itemisflag = true;\n      switch ((opt == STL_MODIFIED_ALT)\n              + bufIsChanged(wp->w_buffer) * 2\n              + (!MODIFIABLE(wp->w_buffer)) * 4) {\n      case 2: str = (char_u *)\"[+]\"; break;\n      case 3: str = (char_u *)\",+\"; break;\n      case 4: str = (char_u *)\"[-]\"; break;\n      case 5: str = (char_u *)\",-\"; break;\n      case 6: str = (char_u *)\"[+-]\"; break;\n      case 7: str = (char_u *)\",+-\"; break;\n      }\n      break;\n\n    case STL_HIGHLIGHT:\n    {\n      // { The name of the highlight is surrounded by `#`\n      char_u *t = fmt_p;\n      while (*fmt_p != '#' && *fmt_p != NUL) {\n        fmt_p++;\n      }\n      // }\n\n      // Create a highlight item based on the name\n      if (*fmt_p == '#') {\n        stl_items[curitem].type = Highlight;\n        stl_items[curitem].start = out_p;\n        stl_items[curitem].minwid = -syn_name2id_len(t, (size_t)(fmt_p - t));\n        curitem++;\n        fmt_p++;\n      }\n      continue;\n    }\n    }\n\n    // If we made it this far, the item is normal and starts at\n    // our current position in the output buffer.\n    // Non-normal items would have `continued`.\n    stl_items[curitem].start = out_p;\n    stl_items[curitem].type = Normal;\n\n    // Copy the item string into the output buffer\n    if (str != NULL && *str) {\n      // { Skip the leading `,` or ` ` if the item is a flag\n      //  and the proper conditions are met\n      char_u *t = str;\n      if (itemisflag) {\n        if ((t[0] && t[1])\n            && ((!prevchar_isitem && *t == ',')\n                || (prevchar_isflag && *t == ' ')))\n          t++;\n        prevchar_isflag = true;\n      }\n      // }\n\n      long l = vim_strsize(t);\n\n      // If this item is non-empty, record that the last thing\n      // we put in the output buffer was an item\n      if (l > 0) {\n        prevchar_isitem = true;\n      }\n\n      // If the item is too wide, truncate it from the beginning\n      if (l > maxwid) {\n        while (l >= maxwid) {\n          l -= ptr2cells(t);\n          t += utfc_ptr2len(t);\n        }\n\n        // Early out if there isn't enough room for the truncation marker\n        if (out_p >= out_end_p) {\n          break;\n        }\n\n        // Add the truncation marker\n        *out_p++ = '<';\n      }\n\n      // If the item is right aligned and not wide enough,\n      // pad with fill characters.\n      if (minwid > 0) {\n        for (; l < minwid && out_p < out_end_p; l++) {\n          // Don't put a \"-\" in front of a digit.\n          if (l + 1 == minwid && fillchar == '-' && ascii_isdigit(*t)) {\n            *out_p++ = ' ';\n          } else {\n            *out_p++ = fillchar;\n          }\n        }\n        minwid = 0;\n      } else {\n        // Note: The negative value denotes a left aligned item.\n        //       Here we switch the minimum width back to a positive value.\n        minwid *= -1;\n      }\n\n      // { Copy the string text into the output buffer\n      while (*t && out_p < out_end_p) {\n        *out_p++ = *t++;\n        // Change a space by fillchar, unless fillchar is '-' and a\n        // digit follows.\n        if (fillable && out_p[-1] == ' '\n            && (!ascii_isdigit(*t) || fillchar != '-'))\n          out_p[-1] = fillchar;\n      }\n      // }\n\n      // For left-aligned items, fill any remaining space with the fillchar\n      for (; l < minwid && out_p < out_end_p; l++) {\n        *out_p++ = fillchar;\n      }\n\n    // Otherwise if the item is a number, copy that to the output buffer.\n    } else if (num >= 0) {\n      if (out_p + 20 > out_end_p) {\n        break;                  // not sufficient space\n      }\n      prevchar_isitem = true;\n\n      // { Build the formatting string\n      char_u nstr[20];\n      char_u *t = nstr;\n      if (opt == STL_VIRTCOL_ALT) {\n        *t++ = '-';\n        minwid--;\n      }\n      *t++ = '%';\n      if (zeropad) {\n        *t++ = '0';\n      }\n\n      // Note: The `*` means we take the width as one of the arguments\n      *t++ = '*';\n      *t++ = (char_u)(base == kNumBaseHexadecimal ? 'X' : 'd');\n      *t = 0;\n      // }\n\n      // { Determine how many characters the number will take up when printed\n      //  Note: We have to cast the base because the compiler uses\n      //        unsigned ints for the enum values.\n      long num_chars = 1;\n      for (long n = num; n >= (int) base; n /= (int) base) {\n        num_chars++;\n      }\n\n      // VIRTCOL_ALT takes up an extra character because\n      // of the `-` we added above.\n      if (opt == STL_VIRTCOL_ALT) {\n        num_chars++;\n      }\n      // }\n\n      assert(out_end_p >= out_p);\n      size_t remaining_buf_len = (size_t)(out_end_p - out_p) + 1;\n\n      // If the number is going to take up too much room\n      // Figure out the approximate number in \"scientific\" type notation.\n      // Ex: 14532 with maxwid of 4 -> '14>3'\n      if (num_chars > maxwid) {\n        // Add two to the width because the power piece will take\n        // two extra characters\n        num_chars += 2;\n\n        // How many extra characters there are\n        long n = num_chars - maxwid;\n\n        // { Reduce the number by base^n\n        while (num_chars-- > maxwid) {\n          num /= (long)base;\n        }\n        // }\n\n        // { Add the format string for the exponent bit\n        *t++ = '>';\n        *t++ = '%';\n        // Use the same base as the first number\n        *t = t[-3];\n        *++t = 0;\n        // }\n\n        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,\n            0, num, n);\n      } else {\n        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,\n            minwid, num);\n      }\n\n      // Advance the output buffer position to the end of the\n      // number we just printed\n      out_p += STRLEN(out_p);\n\n    // Otherwise, there was nothing to print so mark the item as empty\n    } else {\n      stl_items[curitem].type = Empty;\n    }\n\n    // Only free the string buffer if we allocated it.\n    // Note: This is not needed if `str` is pointing at `tmp`\n    if (opt == STL_VIM_EXPR) {\n      xfree(str);\n    }\n\n    if (num >= 0 || (!itemisflag && str && *str)) {\n      prevchar_isflag = false;              // Item not NULL, but not a flag\n    }\n\n    // Item processed, move to the next\n    curitem++;\n  }\n\n  *out_p = NUL;\n  int itemcnt = curitem;\n\n  // Free the format buffer if we allocated it internally\n  if (usefmt != fmt) {\n    xfree(usefmt);\n  }\n\n  // We have now processed the entire statusline format string.\n  // What follows is post-processing to handle alignment and highlighting.\n\n  int width = vim_strsize(out);\n  if (maxwidth > 0 && width > maxwidth) {\n    // Result is too long, must truncate somewhere.\n    int item_idx = 0;\n    char_u *trunc_p;\n\n    // If there are no items, truncate from beginning\n    if (itemcnt == 0) {\n      trunc_p = out;\n\n    // Otherwise, look for the truncation item\n    } else {\n      // Default to truncating at the first item\n      trunc_p = stl_items[0].start;\n      item_idx = 0;\n\n      for (int i = 0; i < itemcnt; i++) {\n        if (stl_items[i].type == Trunc) {\n          // Truncate at %< stl_items.\n          trunc_p = stl_items[i].start;\n          item_idx = i;\n          break;\n        }\n      }\n    }\n\n    // If the truncation point we found is beyond the maximum\n    // length of the string, truncate the end of the string.\n    if (width - vim_strsize(trunc_p) >= maxwidth) {\n      // Walk from the beginning of the\n      // string to find the last character that will fit.\n      trunc_p = out;\n      width = 0;\n      for (;; ) {\n        width += ptr2cells(trunc_p);\n        if (width >= maxwidth) {\n          break;\n        }\n\n        // Note: Only advance the pointer if the next\n        //       character will fit in the available output space\n        trunc_p += utfc_ptr2len(trunc_p);\n      }\n\n      // Ignore any items in the statusline that occur after\n      // the truncation point\n      for (int i = 0; i < itemcnt; i++) {\n        if (stl_items[i].start > trunc_p) {\n          itemcnt = i;\n          break;\n        }\n      }\n\n      // Truncate the output\n      *trunc_p++ = '>';\n      *trunc_p = 0;\n\n    // Truncate at the truncation point we found\n    } else {\n      // { Determine how many bytes to remove\n      long trunc_len = 0;\n      while (width >= maxwidth) {\n        width     -= ptr2cells(trunc_p + trunc_len);\n        trunc_len += utfc_ptr2len(trunc_p + trunc_len);\n      }\n      // }\n\n      // { Truncate the string\n      char_u *trunc_end_p = trunc_p + trunc_len;\n      STRMOVE(trunc_p + 1, trunc_end_p);\n\n      // Put a `<` to mark where we truncated at\n      *trunc_p = '<';\n\n      if (width + 1 < maxwidth) {\n        // Advance the pointer to the end of the string\n        trunc_p = trunc_p + STRLEN(trunc_p);\n      }\n\n      // Fill up for half a double-wide character.\n      while (++width < maxwidth) {\n        *trunc_p++ = fillchar;\n        *trunc_p = NUL;\n      }\n      // }\n\n      // { Change the start point for items based on\n      //  their position relative to our truncation point\n\n      // Note: The offset is one less than the truncation length because\n      //       the truncation marker `<` is not counted.\n      long item_offset = trunc_len - 1;\n\n      for (int i = item_idx; i < itemcnt; i++) {\n        // Items starting at or after the end of the truncated section need\n        // to be moved backwards.\n        if (stl_items[i].start >= trunc_end_p) {\n          stl_items[i].start -= item_offset;\n        // Anything inside the truncated area is set to start\n        // at the `<` truncation character.\n        } else {\n          stl_items[i].start = trunc_p;\n        }\n      }\n      // }\n    }\n    width = maxwidth;\n\n  // If there is room left in our statusline, and room left in our buffer,\n  // add characters at the separate marker (if there is one) to\n  // fill up the available space.\n  } else if (width < maxwidth\n             && STRLEN(out) + (size_t)(maxwidth - width) + 1 < outlen) {\n    // Find how many separators there are, which we will use when\n    // figuring out how many groups there are.\n    int num_separators = 0;\n    for (int i = 0; i < itemcnt; i++) {\n      if (stl_items[i].type == Separate) {\n        // Create an array of the start location for each\n        // separator mark.\n        stl_separator_locations[num_separators] = i;\n        num_separators++;\n      }\n    }\n\n    // If we have separated groups, then we deal with it now\n    if (num_separators) {\n      int standard_spaces = (maxwidth - width) / num_separators;\n      int final_spaces = (maxwidth - width) -\n        standard_spaces * (num_separators - 1);\n\n      for (int i = 0; i < num_separators; i++) {\n        int dislocation = (i == (num_separators - 1))\n                          ? final_spaces : standard_spaces;\n        char_u *start = stl_items[stl_separator_locations[i]].start;\n        char_u *seploc = start + dislocation;\n        STRMOVE(seploc, start);\n        for (char_u *s = start; s < seploc; s++) {\n          *s = fillchar;\n        }\n\n        for (int item_idx = stl_separator_locations[i] + 1;\n             item_idx < itemcnt;\n             item_idx++) {\n          stl_items[item_idx].start += dislocation;\n        }\n      }\n\n      width = maxwidth;\n    }\n  }\n\n  // Store the info about highlighting.\n  if (hltab != NULL) {\n    *hltab = stl_hltab;\n    stl_hlrec_t *sp = stl_hltab;\n    for (long l = 0; l < itemcnt; l++) {\n      if (stl_items[l].type == Highlight) {\n        sp->start = stl_items[l].start;\n        sp->userhl = stl_items[l].minwid;\n        sp++;\n      }\n    }\n    sp->start = NULL;\n    sp->userhl = 0;\n  }\n\n  // Store the info about tab pages labels.\n  if (tabtab != NULL) {\n    *tabtab = stl_tabtab;\n    StlClickRecord *cur_tab_rec = stl_tabtab;\n    for (long l = 0; l < itemcnt; l++) {\n      if (stl_items[l].type == TabPage) {\n        cur_tab_rec->start = (char *)stl_items[l].start;\n        if (stl_items[l].minwid == 0) {\n          cur_tab_rec->def.type = kStlClickDisabled;\n          cur_tab_rec->def.tabnr = 0;\n        } else {\n          int tabnr = stl_items[l].minwid;\n          if (stl_items[l].minwid > 0) {\n            cur_tab_rec->def.type = kStlClickTabSwitch;\n          } else {\n            cur_tab_rec->def.type = kStlClickTabClose;\n            tabnr = -tabnr;\n          }\n          cur_tab_rec->def.tabnr = tabnr;\n        }\n        cur_tab_rec->def.func = NULL;\n        cur_tab_rec++;\n      } else if (stl_items[l].type == ClickFunc) {\n        cur_tab_rec->start = (char *)stl_items[l].start;\n        cur_tab_rec->def.type = kStlClickFuncRun;\n        cur_tab_rec->def.tabnr = stl_items[l].minwid;\n        cur_tab_rec->def.func = stl_items[l].cmd;\n        cur_tab_rec++;\n      }\n    }\n    cur_tab_rec->start = NULL;\n    cur_tab_rec->def.type = kStlClickDisabled;\n    cur_tab_rec->def.tabnr = 0;\n    cur_tab_rec->def.func = NULL;\n  }\n\n  // When inside update_screen we do not want redrawing a stausline, ruler,\n  // title, etc. to trigger another redraw, it may cause an endless loop.\n  if (updating_screen) {\n    must_redraw = save_must_redraw;\n    curwin->w_redr_type = save_redr_type;\n  }\n\n  return width;\n}\n\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\nvoid get_rel_pos(win_T *wp, char_u *buf, int buflen)\n{\n  // Need at least 3 chars for writing.\n  if (buflen < 3) {\n    return;\n  }\n\n  long above;          // number of lines above window\n  long below;          // number of lines below window\n\n  above = wp->w_topline - 1;\n  above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n  if (wp->w_topline == 1 && wp->w_topfill >= 1) {\n    // All buffer lines are displayed and there is an indication\n    // of filler lines, that can be considered seeing all lines.\n    above = 0;\n  }\n  below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n  if (below <= 0) {\n    STRLCPY(buf, (above == 0 ? _(\"All\") : _(\"Bot\")), buflen);\n  } else if (above <= 0) {\n    STRLCPY(buf, _(\"Top\"), buflen);\n  } else {\n    vim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n                 ? (int)(above / ((above + below) / 100L))\n                 : (int)(above * 100L / (above + below)));\n  }\n}\n\n/// Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n///\n/// @param          wp        window whose buffers to check\n/// @param[in,out]  buf       string buffer to add the text to\n/// @param          buflen    length of the string buffer\n/// @param          add_file  if true, add \"file\" before the arg number\n///\n/// @return true if it was appended.\nstatic bool append_arg_number(win_T *wp, char_u *buf, int buflen, bool add_file)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Nothing to do\n  if (ARGCOUNT <= 1) {\n    return false;\n  }\n\n  char_u *p = buf + STRLEN(buf);  // go to the end of the buffer\n\n  // Early out if the string is getting too long\n  if (p - buf + 35 >= buflen) {\n    return false;\n  }\n\n  *p++ = ' ';\n  *p++ = '(';\n  if (add_file) {\n    STRCPY(p, \"file \");\n    p += 5;\n  }\n  vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n               wp->w_arg_idx_invalid\n               ? \"(%d) of %d)\"\n               : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n  return true;\n}\n\n// Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n// \"*ffname\" becomes a pointer to allocated memory (or NULL).\n// When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n// allocated memory.\n// The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n// Note that the resulting \"*ffname\" pointer should be considered not allocated.\nvoid fname_expand(buf_T *buf, char_u **ffname, char_u **sfname)\n{\n  if (*ffname == NULL) {  // no file name given, nothing to do\n    return;\n  }\n  if (*sfname == NULL) {  // no short file name given, use ffname\n    *sfname = *ffname;\n  }\n  *ffname = (char_u *)fix_fname((char *)(*ffname));     // expand to full path\n\n#ifdef WIN32\n  if (!buf->b_p_bin) {\n    // If the file name is a shortcut file, use the file it links to.\n    char *rfname = os_resolve_shortcut((const char *)(*ffname));\n    if (rfname != NULL) {\n      xfree(*ffname);\n      *ffname = (char_u *)rfname;\n      *sfname = (char_u *)rfname;\n    }\n  }\n#endif\n}\n\n/*\n * Get the file name for an argument list entry.\n */\nchar_u *alist_name(aentry_T *aep)\n{\n  buf_T       *bp;\n\n  // Use the name from the associated buffer if it exists.\n  bp = buflist_findnr(aep->ae_fnum);\n  if (bp == NULL || bp->b_fname == NULL) {\n    return aep->ae_fname;\n  }\n  return bp->b_fname;\n}\n\n/*\n * do_arg_all(): Open up to 'count' windows, one for each argument.\n */\nvoid\ndo_arg_all(\n    int count,\n    int forceit,                  // hide buffers in current windows\n    int keep_tabs                 // keep current tabs, for \":tab drop file\"\n)\n{\n  char_u      *opened;          // Array of weight for which args are open:\n                                //  0: not opened\n                                //  1: opened in other tab\n                                //  2: opened in curtab\n                                //  3: opened in curtab and curwin\n\n  int opened_len;               // length of opened[]\n  int use_firstwin = false;     // use first window for arglist\n  bool tab_drop_empty_window = false;\n  int split_ret = OK;\n  bool p_ea_save;\n  alist_T     *alist;           // argument list to be used\n  buf_T       *buf;\n  tabpage_T   *tpnext;\n  int had_tab = cmdmod.tab;\n  win_T       *old_curwin, *last_curwin;\n  tabpage_T   *old_curtab, *last_curtab;\n  win_T       *new_curwin = NULL;\n  tabpage_T   *new_curtab = NULL;\n\n  assert(firstwin != NULL);  // satisfy coverity\n\n  if (ARGCOUNT <= 0) {\n    /* Don't give an error message.  We don't want it when the \":all\"\n     * command is in the .vimrc. */\n    return;\n  }\n  setpcmark();\n\n  opened_len = ARGCOUNT;\n  opened = xcalloc((size_t)opened_len, 1);\n\n  /* Autocommands may do anything to the argument list.  Make sure it's not\n   * freed while we are working here by \"locking\" it.  We still have to\n   * watch out for its size to be changed. */\n  alist = curwin->w_alist;\n  alist->al_refcount++;\n\n  old_curwin = curwin;\n  old_curtab = curtab;\n\n\n  /*\n   * Try closing all windows that are not in the argument list.\n   * Also close windows that are not full width;\n   * When 'hidden' or \"forceit\" set the buffer becomes hidden.\n   * Windows that have a changed buffer and can't be hidden won't be closed.\n   * When the \":tab\" modifier was used do this for all tab pages.\n   */\n  if (had_tab > 0) {\n    goto_tabpage_tp(first_tabpage, true, true);\n  }\n  for (;; ) {\n    win_T *wpnext = NULL;\n    tpnext = curtab->tp_next;\n    for (win_T *wp = firstwin; wp != NULL; wp = wpnext) {\n      int i;\n      wpnext = wp->w_next;\n      buf = wp->w_buffer;\n      if (buf->b_ffname == NULL\n          || (!keep_tabs && (buf->b_nwindows > 1 || wp->w_width != Columns))) {\n        i = opened_len;\n      } else {\n        // check if the buffer in this window is in the arglist\n        for (i = 0; i < opened_len; i++) {\n          if (i < alist->al_ga.ga_len\n              && (AARGLIST(alist)[i].ae_fnum == buf->b_fnum\n                  || path_full_compare(alist_name(&AARGLIST(alist)[i]),\n                                       buf->b_ffname,\n                                       true, true) & kEqualFiles)) {\n            int weight = 1;\n\n            if (old_curtab == curtab) {\n              weight++;\n              if (old_curwin == wp) {\n                weight++;\n              }\n            }\n\n            if (weight > (int)opened[i]) {\n              opened[i] = (char_u)weight;\n              if (i == 0) {\n                if (new_curwin != NULL) {\n                  new_curwin->w_arg_idx = opened_len;\n                }\n                new_curwin = wp;\n                new_curtab = curtab;\n              }\n            } else if (keep_tabs) {\n              i = opened_len;\n            }\n\n            if (wp->w_alist != alist) {\n              /* Use the current argument list for all windows\n               * containing a file from it. */\n              alist_unlink(wp->w_alist);\n              wp->w_alist = alist;\n              wp->w_alist->al_refcount++;\n            }\n            break;\n          }\n        }\n      }\n      wp->w_arg_idx = i;\n\n      if (i == opened_len && !keep_tabs) {    // close this window\n        if (buf_hide(buf) || forceit || buf->b_nwindows > 1\n            || !bufIsChanged(buf)) {\n          /* If the buffer was changed, and we would like to hide it,\n           * try autowriting. */\n          if (!buf_hide(buf) && buf->b_nwindows <= 1 && bufIsChanged(buf)) {\n            bufref_T bufref;\n            set_bufref(&bufref, buf);\n            (void)autowrite(buf, false);\n            // Check if autocommands removed the window.\n            if (!win_valid(wp) || !bufref_valid(&bufref)) {\n              wpnext = firstwin;  // Start all over...\n              continue;\n            }\n          }\n          // don't close last window\n          if (ONE_WINDOW\n              && (first_tabpage->tp_next == NULL || !had_tab)) {\n            use_firstwin = true;\n          } else {\n            win_close(wp, !buf_hide(buf) && !bufIsChanged(buf));\n            // check if autocommands removed the next window\n            if (!win_valid(wpnext)) {\n              // start all over...\n              wpnext = firstwin;\n            }\n          }\n        }\n      }\n    }\n\n    // Without the \":tab\" modifier only do the current tab page.\n    if (had_tab == 0 || tpnext == NULL) {\n      break;\n    }\n\n    // check if autocommands removed the next tab page\n    if (!valid_tabpage(tpnext)) {\n      tpnext = first_tabpage;           // start all over...\n    }\n    goto_tabpage_tp(tpnext, true, true);\n  }\n\n  /*\n   * Open a window for files in the argument list that don't have one.\n   * ARGCOUNT may change while doing this, because of autocommands.\n   */\n  if (count > opened_len || count <= 0) {\n    count = opened_len;\n  }\n\n  // Don't execute Win/Buf Enter/Leave autocommands here.\n  autocmd_no_enter++;\n  autocmd_no_leave++;\n  last_curwin = curwin;\n  last_curtab = curtab;\n  win_enter(lastwin, false);\n  // \":tab drop file\" should re-use an empty window to avoid \"--remote-tab\"\n  // leaving an empty tab page when executed locally.\n  if (keep_tabs && buf_is_empty(curbuf) && curbuf->b_nwindows == 1\n      && curbuf->b_ffname == NULL && !curbuf->b_changed) {\n    use_firstwin = true;\n    tab_drop_empty_window = true;\n  }\n\n  for (int i = 0; i < count && !got_int; i++) {\n    if (alist == &global_alist && i == global_alist.al_ga.ga_len - 1) {\n      arg_had_last = true;\n    }\n    if (opened[i] > 0) {\n      // Move the already present window to below the current window\n      if (curwin->w_arg_idx != i) {\n        FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n          if (wp->w_arg_idx == i) {\n            if (keep_tabs) {\n              new_curwin = wp;\n              new_curtab = curtab;\n            } else {\n              win_move_after(wp, curwin);\n            }\n            break;\n          }\n        }\n      }\n    } else if (split_ret == OK) {\n      // trigger events for tab drop\n      if (tab_drop_empty_window && i == count - 1) {\n        autocmd_no_enter--;\n      }\n      if (!use_firstwin) {              // split current window\n        p_ea_save = p_ea;\n        p_ea = true;                    // use space from all windows\n        split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n        p_ea = p_ea_save;\n        if (split_ret == FAIL) {\n          continue;\n        }\n      } else {      // first window: do autocmd for leaving this buffer\n        autocmd_no_leave--;\n      }\n\n      /*\n       * edit file \"i\"\n       */\n      curwin->w_arg_idx = i;\n      if (i == 0) {\n        new_curwin = curwin;\n        new_curtab = curtab;\n      }\n      (void)do_ecmd(0, alist_name(&AARGLIST(alist)[i]), NULL, NULL, ECMD_ONE,\n                    ((buf_hide(curwin->w_buffer)\n                      || bufIsChanged(curwin->w_buffer))\n                     ? ECMD_HIDE : 0) + ECMD_OLDBUF,\n                    curwin);\n      if (tab_drop_empty_window && i == count - 1) {\n        autocmd_no_enter++;\n      }\n      if (use_firstwin) {\n        autocmd_no_leave++;\n      }\n      use_firstwin = false;\n    }\n    os_breakcheck();\n\n    // When \":tab\" was used open a new tab for a new window repeatedly.\n    if (had_tab > 0 && tabpage_index(NULL) <= p_tpm) {\n      cmdmod.tab = 9999;\n    }\n  }\n\n  // Remove the \"lock\" on the argument list.\n  alist_unlink(alist);\n\n  autocmd_no_enter--;\n  // restore last referenced tabpage's curwin\n  if (last_curtab != new_curtab) {\n    if (valid_tabpage(last_curtab)) {\n      goto_tabpage_tp(last_curtab, true, true);\n    }\n    if (win_valid(last_curwin)) {\n      win_enter(last_curwin, false);\n    }\n  }\n  // to window with first arg\n  if (valid_tabpage(new_curtab)) {\n    goto_tabpage_tp(new_curtab, true, true);\n  }\n  if (win_valid(new_curwin)) {\n    win_enter(new_curwin, false);\n  }\n\n  autocmd_no_leave--;\n  xfree(opened);\n}\n\n/// @return true if \"buf\" is a prompt buffer.\nbool bt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p';\n}\n\n/*\n * Open a window for a number of buffers.\n */\nvoid ex_buffer_all(exarg_T *eap)\n{\n  buf_T       *buf;\n  win_T       *wp, *wpnext;\n  int split_ret = OK;\n  bool p_ea_save;\n  int open_wins = 0;\n  int r;\n  long count;                   // Maximum number of windows to open.\n  int all;                      // When true also load inactive buffers.\n  int had_tab = cmdmod.tab;\n  tabpage_T   *tpnext;\n\n  if (eap->addr_count == 0) {   // make as many windows as possible\n    count = 9999;\n  } else {\n    count = eap->line2;         // make as many windows as specified\n  }\n  if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide) {\n    all = false;\n  } else {\n    all = true;\n  }\n\n  setpcmark();\n\n\n  /*\n   * Close superfluous windows (two windows for the same buffer).\n   * Also close windows that are not full-width.\n   */\n  if (had_tab > 0) {\n    goto_tabpage_tp(first_tabpage, true, true);\n  }\n  for (;; ) {\n    tpnext = curtab->tp_next;\n    for (wp = firstwin; wp != NULL; wp = wpnext) {\n      wpnext = wp->w_next;\n      if ((wp->w_buffer->b_nwindows > 1\n           || ((cmdmod.split & WSP_VERT)\n               ? wp->w_height + wp->w_status_height < Rows - p_ch\n               - tabline_height()\n               : wp->w_width != Columns)\n           || (had_tab > 0 && wp != firstwin))\n          && !ONE_WINDOW\n          && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n          ) {\n        win_close(wp, false);\n        wpnext = firstwin;              // just in case an autocommand does\n                                        // something strange with windows\n        tpnext = first_tabpage;         // start all over...\n        open_wins = 0;\n      } else {\n        open_wins++;\n      }\n    }\n\n    // Without the \":tab\" modifier only do the current tab page.\n    if (had_tab == 0 || tpnext == NULL) {\n      break;\n    }\n    goto_tabpage_tp(tpnext, true, true);\n  }\n\n  //\n  // Go through the buffer list.  When a buffer doesn't have a window yet,\n  // open one.  Otherwise move the window to the right position.\n  // Watch out for autocommands that delete buffers or windows!\n  //\n  // Don't execute Win/Buf Enter/Leave autocommands here.\n  autocmd_no_enter++;\n  win_enter(lastwin, false);\n  autocmd_no_leave++;\n  for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next) {\n    // Check if this buffer needs a window\n    if ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl) {\n      continue;\n    }\n\n    if (had_tab != 0) {\n      // With the \":tab\" modifier don't move the window.\n      if (buf->b_nwindows > 0) {\n        wp = lastwin;               // buffer has a window, skip it\n      } else {\n        wp = NULL;\n      }\n    } else {\n      // Check if this buffer already has a window\n      for (wp = firstwin; wp != NULL; wp = wp->w_next) {\n        if (wp->w_buffer == buf) {\n          break;\n        }\n      }\n      // If the buffer already has a window, move it\n      if (wp != NULL) {\n        win_move_after(wp, curwin);\n      }\n    }\n\n    if (wp == NULL && split_ret == OK) {\n      bufref_T bufref;\n      set_bufref(&bufref, buf);\n      // Split the window and put the buffer in it.\n      p_ea_save = p_ea;\n      p_ea = true;                      // use space from all windows\n      split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n      open_wins++;\n      p_ea = p_ea_save;\n      if (split_ret == FAIL) {\n        continue;\n      }\n\n      // Open the buffer in this window.\n      swap_exists_action = SEA_DIALOG;\n      set_curbuf(buf, DOBUF_GOTO);\n      if (!bufref_valid(&bufref)) {\n        // Autocommands deleted the buffer.\n        swap_exists_action = SEA_NONE;\n        break;\n      }\n      if (swap_exists_action == SEA_QUIT) {\n        cleanup_T cs;\n\n        // Reset the error/interrupt/exception state here so that\n        // aborting() returns false when closing a window.\n        enter_cleanup(&cs);\n\n        // User selected Quit at ATTENTION prompt; close this window.\n        win_close(curwin, true);\n        open_wins--;\n        swap_exists_action = SEA_NONE;\n        swap_exists_did_quit = true;\n\n        /* Restore the error/interrupt/exception state if not\n         * discarded by a new aborting error, interrupt, or uncaught\n         * exception. */\n        leave_cleanup(&cs);\n      } else\n        handle_swap_exists(NULL);\n    }\n\n    os_breakcheck();\n    if (got_int) {\n      (void)vgetc();            // only break the file loading, not the rest\n      break;\n    }\n    // Autocommands deleted the buffer or aborted script processing!!!\n    if (aborting()) {\n      break;\n    }\n    // When \":tab\" was used open a new tab for a new window repeatedly.\n    if (had_tab > 0 && tabpage_index(NULL) <= p_tpm) {\n      cmdmod.tab = 9999;\n    }\n  }\n  autocmd_no_enter--;\n  win_enter(firstwin, false);           // back to first window\n  autocmd_no_leave--;\n\n  /*\n   * Close superfluous windows.\n   */\n  for (wp = lastwin; open_wins > count; ) {\n    r = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n         || autowrite(wp->w_buffer, false) == OK);\n    if (!win_valid(wp)) {\n      // BufWrite Autocommands made the window invalid, start over\n      wp = lastwin;\n    } else if (r) {\n      win_close(wp, !buf_hide(wp->w_buffer));\n      open_wins--;\n      wp = lastwin;\n    } else {\n      wp = wp->w_prev;\n      if (wp == NULL) {\n        break;\n      }\n    }\n  }\n}\n\n\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\nvoid do_modelines(int flags)\n{\n  linenr_T lnum;\n  int nmlines;\n  static int entered = 0;\n\n  if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0) {\n    return;\n  }\n\n  /* Disallow recursive entry here.  Can happen when executing a modeline\n   * triggers an autocommand, which reloads modelines with a \":do\". */\n  if (entered) {\n    return;\n  }\n\n  entered++;\n  for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n       lnum++) {\n    if (chk_modeline(lnum, flags) == FAIL) {\n      nmlines = 0;\n    }\n  }\n\n  for (lnum = curbuf->b_ml.ml_line_count; lnum > 0 && lnum > nmlines\n       && lnum > curbuf->b_ml.ml_line_count - nmlines; lnum--) {\n    if (chk_modeline(lnum, flags) == FAIL) {\n      nmlines = 0;\n    }\n  }\n  entered--;\n}\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\nstatic int\nchk_modeline(\n    linenr_T lnum,\n    int flags                      // Same as for do_modelines().\n)\n{\n  char_u      *s;\n  char_u      *e;\n  char_u      *linecopy;                // local copy of any modeline found\n  int prev;\n  intmax_t vers;\n  int end;\n  int retval = OK;\n  char_u      *save_sourcing_name;\n  linenr_T save_sourcing_lnum;\n\n  prev = -1;\n  for (s = ml_get(lnum); *s != NUL; s++) {\n    if (prev == -1 || ascii_isspace(prev)) {\n      if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n          || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n        break;\n      // Accept both \"vim\" and \"Vim\".\n      if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm') {\n        if (s[3] == '<' || s[3] == '=' || s[3] == '>') {\n          e = s + 4;\n        } else {\n          e = s + 3;\n        }\n        if (!try_getdigits(&e, &vers)) {\n          continue;\n        }\n\n        if (*e == ':'\n            && (s[0] != 'V'\n                || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n            && (s[3] == ':'\n                || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n                || (VIM_VERSION_100 < vers && s[3] == '<')\n                || (VIM_VERSION_100 > vers && s[3] == '>')\n                || (VIM_VERSION_100 == vers && s[3] == '='))) {\n          break;\n        }\n      }\n    }\n    prev = *s;\n  }\n\n  if (!*s) {\n    return retval;\n  }\n\n  do {                                // skip over \"ex:\", \"vi:\" or \"vim:\"\n    s++;\n  } while (s[-1] != ':');\n\n  s = linecopy = vim_strsave(s);      // copy the line, it will change\n\n  save_sourcing_lnum = sourcing_lnum;\n  save_sourcing_name = sourcing_name;\n  sourcing_lnum = lnum;               // prepare for emsg()\n  sourcing_name = (char_u *)\"modelines\";\n\n  end = false;\n  while (end == false) {\n    s = skipwhite(s);\n    if (*s == NUL) {\n      break;\n    }\n\n    /*\n     * Find end of set command: ':' or end of line.\n     * Skip over \"\\:\", replacing it with \":\".\n     */\n    for (e = s; *e != ':' && *e != NUL; e++) {\n      if (e[0] == '\\\\' && e[1] == ':') {\n        STRMOVE(e, e + 1);\n      }\n    }\n    if (*e == NUL) {\n      end = true;\n    }\n\n    /*\n     * If there is a \"set\" command, require a terminating ':' and\n     * ignore the stuff after the ':'.\n     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n     * \"vi:opt opt opt: foo\" -- foo interpreted\n     * Accept \"se\" for compatibility with Elvis.\n     */\n    if (STRNCMP(s, \"set \", (size_t)4) == 0\n        || STRNCMP(s, \"se \", (size_t)3) == 0) {\n      if (*e != ':') {                // no terminating ':'?\n        break;\n      }\n      end = true;\n      s = vim_strchr(s, ' ') + 1;\n    }\n    *e = NUL;                         // truncate the set command\n\n    if (*s != NUL) {                  // skip over an empty \"::\"\n      const int secure_save = secure;\n      const sctx_T save_current_sctx = current_sctx;\n      current_sctx.sc_sid = SID_MODELINE;\n      current_sctx.sc_seq = 0;\n      current_sctx.sc_lnum = 0;\n      // Make sure no risky things are executed as a side effect.\n      secure = 1;\n\n      retval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n      secure = secure_save;\n      current_sctx = save_current_sctx;\n      if (retval == FAIL) {                   // stop if error found\n        break;\n      }\n    }\n    s = e + 1;                        // advance to next part\n  }\n\n  sourcing_lnum = save_sourcing_lnum;\n  sourcing_name = save_sourcing_name;\n\n  xfree(linecopy);\n\n  return retval;\n}\n\n// Return true if \"buf\" is a help buffer.\nbool bt_help(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && buf->b_help;\n}\n\n// Return true if \"buf\" is a normal buffer, 'buftype' is empty.\nbool bt_normal(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n// Return true if \"buf\" is the quickfix buffer.\nbool bt_quickfix(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && buf->b_p_bt[0] == 'q';\n}\n\n// Return true if \"buf\" is a terminal buffer.\nbool bt_terminal(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && buf->b_p_bt[0] == 't';\n}\n\n// Return true if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n// buffer.  This means the buffer name is not a file name.\nbool bt_nofile(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n                         || buf->b_p_bt[0] == 'a'\n                         || buf->terminal\n                         || buf->b_p_bt[0] == 'p');\n}\n\n// Return true if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\" or \"prompt\"\n// buffer.\nbool bt_dontwrite(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return buf != NULL && (buf->b_p_bt[0] == 'n'\n                         || buf->terminal\n                         || buf->b_p_bt[0] == 'p');\n}\n\nbool bt_dontwrite_msg(const buf_T *const buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (bt_dontwrite(buf)) {\n    EMSG(_(\"E382: Cannot write, 'buftype' option is set\"));\n    return true;\n  }\n  return false;\n}\n\n// Return true if the buffer should be hidden, according to 'hidden', \":hide\"\n// and 'bufhidden'.\nbool buf_hide(const buf_T *const buf)\n{\n  // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n  switch (buf->b_p_bh[0]) {\n  case 'u':                         // \"unload\"\n  case 'w':                         // \"wipe\"\n  case 'd': return false;           // \"delete\"\n  case 'h': return true;            // \"hide\"\n  }\n  return p_hid || cmdmod.hide;\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\nchar_u *buf_spname(buf_T *buf)\n{\n  if (bt_quickfix(buf)) {\n    win_T *win;\n    tabpage_T *tp;\n\n    // For location list window, w_llist_ref points to the location list.\n    // For quickfix window, w_llist_ref is NULL.\n    if (find_win_for_buf(buf, &win, &tp) && win->w_llist_ref != NULL) {\n      return (char_u *)_(msg_loclist);\n    } else {\n      return (char_u *)_(msg_qflist);\n    }\n  }\n  // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n  // contains the name as specified by the user.\n  if (bt_nofile(buf)) {\n    if (buf->b_fname != NULL) {\n      return buf->b_fname;\n    }\n    if (bt_prompt(buf)) {\n      return (char_u *)_(\"[Prompt]\");\n    }\n    return (char_u *)_(\"[Scratch]\");\n  }\n  if (buf->b_fname == NULL) {\n    return buf_get_fname(buf);\n  }\n  return NULL;\n}\n\n/// Find a window for buffer \"buf\".\n/// If found true is returned and \"wp\" and \"tp\" are set to\n/// the window and tabpage.\n/// If not found, false is returned.\n///\n/// @param       buf  buffer to find a window for\n/// @param[out]  wp   stores the found window\n/// @param[out]  tp   stores the found tabpage\n///\n/// @return true if a window was found for the buffer.\nbool find_win_for_buf(buf_T *buf, win_T **wp, tabpage_T **tp)\n{\n  *wp = NULL;\n  *tp = NULL;\n  FOR_ALL_TAB_WINDOWS(tp2, wp2) {\n    if (wp2->w_buffer == buf) {\n      *tp = tp2;\n      *wp = wp2;\n      return true;\n    }\n  }\n  return false;\n}\n\nint buf_signcols(buf_T *buf)\n{\n    if (!buf->b_signcols_valid) {\n        sign_entry_T *sign;  // a sign in the sign list\n        int signcols = 0;\n        int linesum = 0;\n        linenr_T curline = 0;\n\n        FOR_ALL_SIGNS_IN_BUF(buf, sign) {\n          if (sign->se_lnum > curline) {\n            if (linesum > signcols) {\n              signcols = linesum;\n            }\n            curline = sign->se_lnum;\n            linesum = 0;\n          }\n          if (sign->se_has_text_or_icon) {\n            linesum++;\n          }\n        }\n        if (linesum > signcols) {\n          signcols = linesum;\n        }\n\n        // Check if we need to redraw\n        if (signcols != buf->b_signcols) {\n            buf->b_signcols = signcols;\n            redraw_buf_later(buf, NOT_VALID);\n        }\n\n        buf->b_signcols_valid = true;\n    }\n\n    return buf->b_signcols;\n}\n\n// Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\nchar_u *buf_get_fname(const buf_T *buf)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (buf->b_fname == NULL) {\n    return (char_u *)_(\"[No Name]\");\n  }\n  return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\nvoid set_buflisted(int on)\n{\n  if (on != curbuf->b_p_bl) {\n    curbuf->b_p_bl = on;\n    if (on) {\n      apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);\n    } else {\n      apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);\n    }\n  }\n}\n\n/// Read the file for \"buf\" again and check if the contents changed.\n/// Return true if it changed or this could not be checked.\n///\n/// @param  buf  buffer to check\n///\n/// @return true if the buffer's contents have changed\nbool buf_contents_changed(buf_T *buf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  bool differ = true;\n\n  // Allocate a buffer without putting it in the buffer list.\n  buf_T *newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n  if (newbuf == NULL) {\n    return true;\n  }\n\n  // Force the 'fileencoding' and 'fileformat' to be equal.\n  exarg_T ea;\n  prep_exarg(&ea, buf);\n\n  // set curwin/curbuf to buf and save a few things\n  aco_save_T aco;\n  aucmd_prepbuf(&aco, newbuf);\n\n  if (ml_open(curbuf) == OK\n      && readfile(buf->b_ffname, buf->b_fname,\n                  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n                  &ea, READ_NEW | READ_DUMMY) == OK) {\n    // compare the two files line by line\n    if (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count) {\n      differ = false;\n      for (linenr_T lnum = 1; lnum <= curbuf->b_ml.ml_line_count; lnum++) {\n        if (STRCMP(ml_get_buf(buf, lnum, false), ml_get(lnum)) != 0) {\n          differ = true;\n          break;\n        }\n      }\n    }\n  }\n  xfree(ea.cmd);\n\n  // restore curwin/curbuf and a few other things\n  aucmd_restbuf(&aco);\n\n  if (curbuf != newbuf) {  // safety check\n    wipe_buffer(newbuf, false);\n  }\n\n  return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\nvoid\nwipe_buffer(\n    buf_T *buf,\n    bool aucmd                  // When true trigger autocommands.\n)\n{\n  if (!aucmd) {\n    // Don't trigger BufDelete autocommands here.\n    block_autocmds();\n  }\n  close_buffer(NULL, buf, DOBUF_WIPE, false);\n  if (!aucmd) {\n    unblock_autocmds();\n  }\n}\n\n/// Creates or switches to a scratch buffer. :h special-buffers\n/// Scratch buffer is:\n///   - buftype=nofile bufhidden=hide noswapfile\n///   - Always considered 'nomodified'\n///\n/// @param bufnr     Buffer to switch to, or 0 to create a new buffer.\n///\n/// @see curbufIsChanged()\nvoid buf_open_scratch(handle_T bufnr, char *bufname)\n{\n  (void)do_ecmd((int)bufnr, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);\n  (void)setfname(curbuf, (char_u *)bufname, NULL, true);\n  set_option_value(\"bh\", 0L, \"hide\", OPT_LOCAL);\n  set_option_value(\"bt\", 0L, \"nofile\", OPT_LOCAL);\n  set_option_value(\"swf\", 0L, NULL, OPT_LOCAL);\n  RESET_BINDING(curwin);\n}\n\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 3, "line": 4023}, "message": "'atoi' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "src/nvim/buffer.c", "reportHash": "e6adf7540f59728d082ae0a62e5b2f36", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
