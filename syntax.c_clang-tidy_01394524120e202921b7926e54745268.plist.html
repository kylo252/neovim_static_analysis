<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"26": {"id": 26, "path": "src/nvim/syntax.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * syntax.c: code for syntax highlighting\n */\n\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor_shape.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/highlight.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/macros.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/sign.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax_defs.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/buffer.h\"\n\nstatic bool did_syntax_onoff = false;\n\n/// Structure that stores information about a highlight group.\n/// The ID of a highlight group is also called group ID.  It is the index in\n/// the highlight_ga array PLUS ONE.\ntypedef struct hl_group {\n  char_u      *sg_name;         ///< highlight group name\n  char        *sg_name_u;       ///< uppercase of sg_name\n  bool sg_cleared;              ///< \"hi clear\" was used\n  int sg_attr;                  ///< Screen attr @see ATTR_ENTRY\n  int sg_link;                  ///< link to this highlight group ID\n  int sg_deflink;               ///< default link; restored in highlight_clear()\n  int sg_set;                   ///< combination of flags in \\ref SG_SET\n  sctx_T sg_deflink_sctx;       ///< script where the default link was set\n  sctx_T sg_script_ctx;         ///< script in which the group was last set\n  // for terminal UIs\n  int sg_cterm;                 ///< \"cterm=\" highlighting attr\n                                ///< (combination of \\ref HlAttrFlags)\n  int sg_cterm_fg;              ///< terminal fg color number + 1\n  int sg_cterm_bg;              ///< terminal bg color number + 1\n  bool sg_cterm_bold;           ///< bold attr was set for light color\n  // for RGB UIs\n  int sg_gui;                   ///< \"gui=\" highlighting attributes\n                                ///< (combination of \\ref HlAttrFlags)\n  RgbValue sg_rgb_fg;           ///< RGB foreground color\n  RgbValue sg_rgb_bg;           ///< RGB background color\n  RgbValue sg_rgb_sp;           ///< RGB special color\n  char *sg_rgb_fg_name;         ///< RGB foreground color name\n  char *sg_rgb_bg_name;         ///< RGB background color name\n  char *sg_rgb_sp_name;         ///< RGB special color name\n\n  int sg_blend;                 ///< blend level (0-100 inclusive), -1 if unset\n} HlGroup;\n\n/// \\addtogroup SG_SET\n/// @{\n#define SG_CTERM        2       // cterm has been set\n#define SG_GUI          4       // gui has been set\n#define SG_LINK         8       // link has been set\n/// @}\n\n// builtin |highlight-groups|\nstatic garray_T highlight_ga = GA_EMPTY_INIT_VALUE;\nMap(cstr_t, int) highlight_unames = MAP_INIT;\n\nstatic inline struct hl_group * HL_TABLE(void)\n{\n  return ((struct hl_group *)((highlight_ga.ga_data)));\n}\n\n#define MAX_HL_ID       20000   /* maximum value for a highlight ID. */\n\n/* different types of offsets that are possible */\n#define SPO_MS_OFF      0       /* match  start offset */\n#define SPO_ME_OFF      1       /* match  end\toffset */\n#define SPO_HS_OFF      2       /* highl. start offset */\n#define SPO_HE_OFF      3       /* highl. end\toffset */\n#define SPO_RS_OFF      4       /* region start offset */\n#define SPO_RE_OFF      5       /* region end\toffset */\n#define SPO_LC_OFF      6       /* leading context offset */\n#define SPO_COUNT       7\n\n/* Flags to indicate an additional string for highlight name completion. */\nstatic int include_none = 0;    /* when 1 include \"nvim/None\" */\nstatic int include_default = 0; /* when 1 include \"nvim/default\" */\nstatic int include_link = 0;    /* when 2 include \"nvim/link\" and \"clear\" */\n\n/// The \"term\", \"cterm\" and \"gui\" arguments can be any combination of the\n/// following names, separated by commas (but no spaces!).\nstatic char *(hl_name_table[]) =\n{ \"bold\", \"standout\", \"underline\", \"undercurl\",\n  \"italic\", \"reverse\", \"inverse\", \"strikethrough\", \"nocombine\", \"NONE\" };\nstatic int hl_attr_table[] =\n{ HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE,\n  HL_INVERSE, HL_STRIKETHROUGH, HL_NOCOMBINE, 0 };\n\nstatic char e_illegal_arg[] = N_(\"E390: Illegal argument: %s\");\n\n// The patterns that are being searched for are stored in a syn_pattern.\n// A match item consists of one pattern.\n// A start/end item consists of n start patterns and m end patterns.\n// A start/skip/end item consists of n start patterns, one skip pattern and m\n// end patterns.\n// For the latter two, the patterns are always consecutive: start-skip-end.\n//\n// A character offset can be given for the matched text (_m_start and _m_end)\n// and for the actually highlighted text (_h_start and _h_end).\n//\n// Note that ordering of members is optimized to reduce padding.\ntypedef struct syn_pattern {\n  char sp_type;                         // see SPTYPE_ defines below\n  bool sp_syncing;                      // this item used for syncing\n  int16_t sp_syn_match_id;              // highlight group ID of pattern\n  int16_t sp_off_flags;                 // see below\n  int sp_offsets[SPO_COUNT];            // offsets\n  int sp_flags;                         // see HL_ defines below\n  int sp_cchar;                         // conceal substitute character\n  int sp_ic;                            // ignore-case flag for sp_prog\n  int sp_sync_idx;                      // sync item index (syncing only)\n  int sp_line_id;                       // ID of last line where tried\n  int sp_startcol;                      // next match in sp_line_id line\n  int16_t *sp_cont_list;                // cont. group IDs, if non-zero\n  int16_t *sp_next_list;                // next group IDs, if non-zero\n  struct sp_syn sp_syn;                 // struct passed to in_id_list()\n  char_u *sp_pattern;                   // regexp to match, pattern\n  regprog_T *sp_prog;                   // regexp to match, program\n  syn_time_T sp_time;\n} synpat_T;\n\n\ntypedef struct syn_cluster_S {\n  char_u *scl_name;         // syntax cluster name\n  char_u *scl_name_u;       // uppercase of scl_name\n  int16_t *scl_list;        // IDs in this syntax cluster\n} syn_cluster_T;\n\n/*\n * For the current state we need to remember more than just the idx.\n * When si_m_endpos.lnum is 0, the items other than si_idx are unknown.\n * (The end positions have the column number of the next char)\n */\ntypedef struct state_item {\n  int si_idx;                           // index of syntax pattern or\n                                        // KEYWORD_IDX\n  int si_id;                            // highlight group ID for keywords\n  int si_trans_id;                      // idem, transparency removed\n  int si_m_lnum;                        // lnum of the match\n  int si_m_startcol;                    // starting column of the match\n  lpos_T si_m_endpos;                   // just after end posn of the match\n  lpos_T si_h_startpos;                 // start position of the highlighting\n  lpos_T si_h_endpos;                   // end position of the highlighting\n  lpos_T si_eoe_pos;                    // end position of end pattern\n  int si_end_idx;                       // group ID for end pattern or zero\n  int si_ends;                          // if match ends before si_m_endpos\n  int si_attr;                          // attributes in this state\n  long si_flags;                        // HL_HAS_EOL flag in this state, and\n                                        // HL_SKIP* for si_next_list\n  int si_seqnr;                         // sequence number\n  int si_cchar;                         // substitution character for conceal\n  int16_t *si_cont_list;                // list of contained groups\n  int16_t *si_next_list;                // nextgroup IDs after this item ends\n  reg_extmatch_T *si_extmatch;          // \\z(...\\) matches from start\n                                        // pattern\n} stateitem_T;\n\n/*\n * Struct to reduce the number of arguments to get_syn_options(), it's used\n * very often.\n */\ntypedef struct {\n  int flags;                   // flags for contained and transparent\n  bool keyword;                // true for \":syn keyword\"\n  int *sync_idx;               // syntax item for \"grouphere\" argument, NULL\n                               // if not allowed\n  bool has_cont_list;          // true if \"cont_list\" can be used\n  int16_t *cont_list;          // group IDs for \"contains\" argument\n  int16_t *cont_in_list;       // group IDs for \"containedin\" argument\n  int16_t *next_list;          // group IDs for \"nextgroup\" argument\n} syn_opt_arg_T;\n\ntypedef struct {\n  proftime_T total;\n  int count;\n  int match;\n  proftime_T slowest;\n  proftime_T average;\n  int id;\n  char_u      *pattern;\n} time_entry_T;\n\nstruct name_list {\n  int flag;\n  char        *name;\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"syntax.c.generated.h\"\n#endif\n\nstatic char *(spo_name_tab[SPO_COUNT]) =\n{\"ms=\", \"me=\", \"hs=\", \"he=\", \"rs=\", \"re=\", \"lc=\"};\n\n/* The sp_off_flags are computed like this:\n * offset from the start of the matched text: (1 << SPO_XX_OFF)\n * offset from the end\t of the matched text: (1 << (SPO_XX_OFF + SPO_COUNT))\n * When both are present, only one is used.\n */\n\n#define SPTYPE_MATCH    1       /* match keyword with this group ID */\n#define SPTYPE_START    2       /* match a regexp, start of item */\n#define SPTYPE_END      3       /* match a regexp, end of item */\n#define SPTYPE_SKIP     4       /* match a regexp, skip within item */\n\n\n#define SYN_ITEMS(buf)  ((synpat_T *)((buf)->b_syn_patterns.ga_data))\n\n#define NONE_IDX        -2      /* value of sp_sync_idx for \"NONE\" */\n\n/*\n * Flags for b_syn_sync_flags:\n */\n#define SF_CCOMMENT     0x01    /* sync on a C-style comment */\n#define SF_MATCH        0x02    /* sync by matching a pattern */\n\n#define SYN_STATE_P(ssp)    ((bufstate_T *)((ssp)->ga_data))\n\n#define MAXKEYWLEN      80          /* maximum length of a keyword */\n\n/*\n * The attributes of the syntax item that has been recognized.\n */\nstatic int current_attr = 0;        /* attr of current syntax word */\nstatic int current_id = 0;          /* ID of current char for syn_get_id() */\nstatic int current_trans_id = 0;    /* idem, transparency removed */\nstatic int current_flags = 0;\nstatic int current_seqnr = 0;\nstatic int current_sub_char = 0;\n\n/*\n * Methods of combining two clusters\n */\n#define CLUSTER_REPLACE     1   /* replace first list with second */\n#define CLUSTER_ADD         2   /* add second list to first */\n#define CLUSTER_SUBTRACT    3   /* subtract second list from first */\n\n#define SYN_CLSTR(buf)  ((syn_cluster_T *)((buf)->b_syn_clusters.ga_data))\n\n/*\n * Syntax group IDs have different types:\n *     0 - 19999  normal syntax groups\n * 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)\n * 21000 - 21999  TOP indicator (current_syn_inc_tag added)\n * 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)\n * 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)\n */\n#define SYNID_ALLBUT    MAX_HL_ID   /* syntax group ID for contains=ALLBUT */\n#define SYNID_TOP       21000       /* syntax group ID for contains=TOP */\n#define SYNID_CONTAINED 22000       /* syntax group ID for contains=CONTAINED */\n#define SYNID_CLUSTER   23000       /* first syntax group ID for clusters */\n\n#define MAX_SYN_INC_TAG 999         /* maximum before the above overflow */\n#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)\n\n/*\n * Annoying Hack(TM):  \":syn include\" needs this pointer to pass to\n * expand_filename().  Most of the other syntax commands don't need it, so\n * instead of passing it to them, we stow it here.\n */\nstatic char_u **syn_cmdlinep;\n\n/*\n * Another Annoying Hack(TM):  To prevent rules from other \":syn include\"'d\n * files from leaking into ALLBUT lists, we assign a unique ID to the\n * rules in each \":syn include\"'d file.\n */\nstatic int current_syn_inc_tag = 0;\nstatic int running_syn_inc_tag = 0;\n\n/*\n * In a hashtable item \"hi_key\" points to \"keyword\" in a keyentry.\n * This avoids adding a pointer to the hashtable item.\n * KE2HIKEY() converts a var pointer to a hashitem key pointer.\n * HIKEY2KE() converts a hashitem key pointer to a var pointer.\n * HI2KE() converts a hashitem pointer to a var pointer.\n */\nstatic keyentry_T dumkey;\n#define KE2HIKEY(kp)  ((kp)->keyword)\n#define HIKEY2KE(p)   ((keyentry_T *)((p) - (dumkey.keyword - (char_u *)&dumkey)))\n#define HI2KE(hi)      HIKEY2KE((hi)->hi_key)\n\n// -V:HI2KE:782\n\n/*\n * To reduce the time spent in keepend(), remember at which level in the state\n * stack the first item with \"keepend\" is present.  When \"-1\", there is no\n * \"keepend\" on the stack.\n */\nstatic int keepend_level = -1;\n\nstatic char msg_no_items[] = N_(\"No Syntax items defined for this buffer\");\n\n// value of si_idx for keywords\n#define KEYWORD_IDX     -1\n// valid of si_cont_list for containing all but contained groups\n#define ID_LIST_ALL     (int16_t *)-1\n\nstatic int next_seqnr = 1;              /* value to use for si_seqnr */\n\n/*\n * The next possible match in the current line for any pattern is remembered,\n * to avoid having to try for a match in each column.\n * If next_match_idx == -1, not tried (in this line) yet.\n * If next_match_col == MAXCOL, no match found in this line.\n * (All end positions have the column of the char after the end)\n */\nstatic int next_match_col;              /* column for start of next match */\nstatic lpos_T next_match_m_endpos;      /* position for end of next match */\nstatic lpos_T next_match_h_startpos;  /* pos. for highl. start of next match */\nstatic lpos_T next_match_h_endpos;      /* pos. for highl. end of next match */\nstatic int next_match_idx;              /* index of matched item */\nstatic long next_match_flags;           /* flags for next match */\nstatic lpos_T next_match_eos_pos;       /* end of start pattn (start region) */\nstatic lpos_T next_match_eoe_pos;       /* pos. for end of end pattern */\nstatic int next_match_end_idx;          /* ID of group for end pattn or zero */\nstatic reg_extmatch_T *next_match_extmatch = NULL;\n\n/*\n * A state stack is an array of integers or stateitem_T, stored in a\n * garray_T.  A state stack is invalid if its itemsize entry is zero.\n */\n#define INVALID_STATE(ssp)  ((ssp)->ga_itemsize == 0)\n#define VALID_STATE(ssp)    ((ssp)->ga_itemsize != 0)\n\n/*\n * The current state (within the line) of the recognition engine.\n * When current_state.ga_itemsize is 0 the current state is invalid.\n */\nstatic win_T    *syn_win;                  // current window for highlighting\nstatic buf_T    *syn_buf;                  // current buffer for highlighting\nstatic synblock_T *syn_block;              // current buffer for highlighting\nstatic proftime_T *syn_tm;                 // timeout limit\nstatic linenr_T current_lnum = 0;          // lnum of current state\nstatic colnr_T current_col = 0;            // column of current state\nstatic bool current_state_stored = false;  // true if stored current state\n                                           // after setting current_finished\nstatic bool current_finished = false;      // current line has been finished\nstatic garray_T current_state              // current stack of state_items\n  = GA_EMPTY_INIT_VALUE;\nstatic int16_t *current_next_list = NULL;  // when non-zero, nextgroup list\nstatic int current_next_flags = 0;         // flags for current_next_list\nstatic int current_line_id = 0;            // unique number for current line\n\n#define CUR_STATE(idx)  ((stateitem_T *)(current_state.ga_data))[idx]\n\nstatic bool syn_time_on = false;\n# define IF_SYN_TIME(p) (p)\n\n// Set the timeout used for syntax highlighting.\n// Use NULL to reset, no timeout.\nvoid syn_set_timeout(proftime_T *tm)\n{\n  syn_tm = tm;\n}\n\n/*\n * Start the syntax recognition for a line.  This function is normally called\n * from the screen updating, once for each displayed line.\n * The buffer is remembered in syn_buf, because get_syntax_attr() doesn't get\n * it.\tCareful: curbuf and curwin are likely to point to another buffer and\n * window.\n */\nvoid syntax_start(win_T *wp, linenr_T lnum)\n{\n  synstate_T  *p;\n  synstate_T  *last_valid = NULL;\n  synstate_T  *last_min_valid = NULL;\n  synstate_T  *sp, *prev = NULL;\n  linenr_T parsed_lnum;\n  linenr_T first_stored;\n  int dist;\n  static int changedtick = 0;           /* remember the last change ID */\n\n  current_sub_char = NUL;\n\n  /*\n   * After switching buffers, invalidate current_state.\n   * Also do this when a change was made, the current state may be invalid\n   * then.\n   */\n  if (syn_block != wp->w_s\n      || syn_buf != wp->w_buffer\n      || changedtick != buf_get_changedtick(syn_buf)) {\n    invalidate_current_state();\n    syn_buf = wp->w_buffer;\n    syn_block = wp->w_s;\n  }\n  changedtick = buf_get_changedtick(syn_buf);\n  syn_win = wp;\n\n  /*\n   * Allocate syntax stack when needed.\n   */\n  syn_stack_alloc();\n  if (syn_block->b_sst_array == NULL)\n    return;             /* out of memory */\n  syn_block->b_sst_lasttick = display_tick;\n\n  /*\n   * If the state of the end of the previous line is useful, store it.\n   */\n  if (VALID_STATE(&current_state)\n      && current_lnum < lnum\n      && current_lnum < syn_buf->b_ml.ml_line_count) {\n    (void)syn_finish_line(false);\n    if (!current_state_stored) {\n      ++current_lnum;\n      (void)store_current_state();\n    }\n\n    /*\n     * If the current_lnum is now the same as \"lnum\", keep the current\n     * state (this happens very often!).  Otherwise invalidate\n     * current_state and figure it out below.\n     */\n    if (current_lnum != lnum)\n      invalidate_current_state();\n  } else\n    invalidate_current_state();\n\n  /*\n   * Try to synchronize from a saved state in b_sst_array[].\n   * Only do this if lnum is not before and not to far beyond a saved state.\n   */\n  if (INVALID_STATE(&current_state) && syn_block->b_sst_array != NULL) {\n    /* Find last valid saved state before start_lnum. */\n    for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next) {\n      if (p->sst_lnum > lnum) {\n        break;\n      }\n      if (p->sst_change_lnum == 0) {\n        last_valid = p;\n        if (p->sst_lnum >= lnum - syn_block->b_syn_sync_minlines)\n          last_min_valid = p;\n      }\n    }\n    if (last_min_valid != NULL)\n      load_current_state(last_min_valid);\n  }\n\n  /*\n   * If \"lnum\" is before or far beyond a line with a saved state, need to\n   * re-synchronize.\n   */\n  if (INVALID_STATE(&current_state)) {\n    syn_sync(wp, lnum, last_valid);\n    if (current_lnum == 1)\n      /* First line is always valid, no matter \"minlines\". */\n      first_stored = 1;\n    else\n      /* Need to parse \"minlines\" lines before state can be considered\n       * valid to store. */\n      first_stored = current_lnum + syn_block->b_syn_sync_minlines;\n  } else\n    first_stored = current_lnum;\n\n  /*\n   * Advance from the sync point or saved state until the current line.\n   * Save some entries for syncing with later on.\n   */\n  if (syn_block->b_sst_len <= Rows)\n    dist = 999999;\n  else\n    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;\n  while (current_lnum < lnum) {\n    syn_start_line();\n    (void)syn_finish_line(false);\n    current_lnum++;\n\n    /* If we parsed at least \"minlines\" lines or started at a valid\n     * state, the current state is considered valid. */\n    if (current_lnum >= first_stored) {\n      /* Check if the saved state entry is for the current line and is\n       * equal to the current state.  If so, then validate all saved\n       * states that depended on a change before the parsed line. */\n      if (prev == NULL)\n        prev = syn_stack_find_entry(current_lnum - 1);\n      if (prev == NULL)\n        sp = syn_block->b_sst_first;\n      else\n        sp = prev;\n      while (sp != NULL && sp->sst_lnum < current_lnum)\n        sp = sp->sst_next;\n      if (sp != NULL\n          && sp->sst_lnum == current_lnum\n          && syn_stack_equal(sp)) {\n        parsed_lnum = current_lnum;\n        prev = sp;\n        while (sp != NULL && sp->sst_change_lnum <= parsed_lnum) {\n          if (sp->sst_lnum <= lnum)\n            /* valid state before desired line, use this one */\n            prev = sp;\n          else if (sp->sst_change_lnum == 0)\n            /* past saved states depending on change, break here. */\n            break;\n          sp->sst_change_lnum = 0;\n          sp = sp->sst_next;\n        }\n        load_current_state(prev);\n      }\n      /* Store the state at this line when it's the first one, the line\n       * where we start parsing, or some distance from the previously\n       * saved state.  But only when parsed at least 'minlines'. */\n      else if (prev == NULL\n               || current_lnum == lnum\n               || current_lnum >= prev->sst_lnum + dist)\n        prev = store_current_state();\n    }\n\n    /* This can take a long time: break when CTRL-C pressed.  The current\n     * state will be wrong then. */\n    line_breakcheck();\n    if (got_int) {\n      current_lnum = lnum;\n      break;\n    }\n  }\n\n  syn_start_line();\n}\n\n/*\n * We cannot simply discard growarrays full of state_items or buf_states; we\n * have to manually release their extmatch pointers first.\n */\nstatic void clear_syn_state(synstate_T *p)\n{\n  if (p->sst_stacksize > SST_FIX_STATES) {\n#   define UNREF_BUFSTATE_EXTMATCH(bs) unref_extmatch((bs)->bs_extmatch)\n    GA_DEEP_CLEAR(&(p->sst_union.sst_ga), bufstate_T, UNREF_BUFSTATE_EXTMATCH);\n  } else {\n    for (int i = 0; i < p->sst_stacksize; i++) {\n      unref_extmatch(p->sst_union.sst_stack[i].bs_extmatch);\n    }\n  }\n}\n\n/*\n * Cleanup the current_state stack.\n */\nstatic void clear_current_state(void)\n{\n# define UNREF_STATEITEM_EXTMATCH(si) unref_extmatch((si)->si_extmatch)\n  GA_DEEP_CLEAR(&current_state, stateitem_T, UNREF_STATEITEM_EXTMATCH);\n}\n\n/*\n * Try to find a synchronisation point for line \"lnum\".\n *\n * This sets current_lnum and the current state.  One of three methods is\n * used:\n * 1. Search backwards for the end of a C-comment.\n * 2. Search backwards for given sync patterns.\n * 3. Simply start on a given number of lines above \"lnum\".\n */\nstatic void syn_sync(win_T *wp, linenr_T start_lnum, synstate_T *last_valid)\n{\n  buf_T       *curbuf_save;\n  win_T       *curwin_save;\n  pos_T cursor_save;\n  int idx;\n  linenr_T lnum;\n  linenr_T end_lnum;\n  linenr_T break_lnum;\n  bool had_sync_point;\n  stateitem_T *cur_si;\n  synpat_T    *spp;\n  char_u      *line;\n  int found_flags = 0;\n  int found_match_idx = 0;\n  linenr_T found_current_lnum = 0;\n  int found_current_col= 0;\n  lpos_T found_m_endpos;\n  colnr_T prev_current_col;\n\n  /*\n   * Clear any current state that might be hanging around.\n   */\n  invalidate_current_state();\n\n  /*\n   * Start at least \"minlines\" back.  Default starting point for parsing is\n   * there.\n   * Start further back, to avoid that scrolling backwards will result in\n   * resyncing for every line.  Now it resyncs only one out of N lines,\n   * where N is minlines * 1.5, or minlines * 2 if minlines is small.\n   * Watch out for overflow when minlines is MAXLNUM.\n   */\n  if (syn_block->b_syn_sync_minlines > start_lnum)\n    start_lnum = 1;\n  else {\n    if (syn_block->b_syn_sync_minlines == 1)\n      lnum = 1;\n    else if (syn_block->b_syn_sync_minlines < 10)\n      lnum = syn_block->b_syn_sync_minlines * 2;\n    else\n      lnum = syn_block->b_syn_sync_minlines * 3 / 2;\n    if (syn_block->b_syn_sync_maxlines != 0\n        && lnum > syn_block->b_syn_sync_maxlines)\n      lnum = syn_block->b_syn_sync_maxlines;\n    if (lnum >= start_lnum)\n      start_lnum = 1;\n    else\n      start_lnum -= lnum;\n  }\n  current_lnum = start_lnum;\n\n  /*\n   * 1. Search backwards for the end of a C-style comment.\n   */\n  if (syn_block->b_syn_sync_flags & SF_CCOMMENT) {\n    /* Need to make syn_buf the current buffer for a moment, to be able to\n     * use find_start_comment(). */\n    curwin_save = curwin;\n    curwin = wp;\n    curbuf_save = curbuf;\n    curbuf = syn_buf;\n\n    /*\n     * Skip lines that end in a backslash.\n     */\n    for (; start_lnum > 1; --start_lnum) {\n      line = ml_get(start_lnum - 1);\n      if (*line == NUL || *(line + STRLEN(line) - 1) != '\\\\')\n        break;\n    }\n    current_lnum = start_lnum;\n\n    /* set cursor to start of search */\n    cursor_save = wp->w_cursor;\n    wp->w_cursor.lnum = start_lnum;\n    wp->w_cursor.col = 0;\n\n    /*\n     * If the line is inside a comment, need to find the syntax item that\n     * defines the comment.\n     * Restrict the search for the end of a comment to b_syn_sync_maxlines.\n     */\n    if (find_start_comment((int)syn_block->b_syn_sync_maxlines) != NULL) {\n      for (idx = syn_block->b_syn_patterns.ga_len; --idx >= 0; )\n        if (SYN_ITEMS(syn_block)[idx].sp_syn.id\n            == syn_block->b_syn_sync_id\n            && SYN_ITEMS(syn_block)[idx].sp_type == SPTYPE_START) {\n          validate_current_state();\n          push_current_state(idx);\n          update_si_attr(current_state.ga_len - 1);\n          break;\n        }\n    }\n\n    /* restore cursor and buffer */\n    wp->w_cursor = cursor_save;\n    curwin = curwin_save;\n    curbuf = curbuf_save;\n  }\n  /*\n   * 2. Search backwards for given sync patterns.\n   */\n  else if (syn_block->b_syn_sync_flags & SF_MATCH) {\n    if (syn_block->b_syn_sync_maxlines != 0\n        && start_lnum > syn_block->b_syn_sync_maxlines)\n      break_lnum = start_lnum - syn_block->b_syn_sync_maxlines;\n    else\n      break_lnum = 0;\n\n    found_m_endpos.lnum = 0;\n    found_m_endpos.col = 0;\n    end_lnum = start_lnum;\n    lnum = start_lnum;\n    while (--lnum > break_lnum) {\n      /* This can take a long time: break when CTRL-C pressed. */\n      line_breakcheck();\n      if (got_int) {\n        invalidate_current_state();\n        current_lnum = start_lnum;\n        break;\n      }\n\n      /* Check if we have run into a valid saved state stack now. */\n      if (last_valid != NULL && lnum == last_valid->sst_lnum) {\n        load_current_state(last_valid);\n        break;\n      }\n\n      /*\n       * Check if the previous line has the line-continuation pattern.\n       */\n      if (lnum > 1 && syn_match_linecont(lnum - 1))\n        continue;\n\n      /*\n       * Start with nothing on the state stack\n       */\n      validate_current_state();\n\n      for (current_lnum = lnum; current_lnum < end_lnum; ++current_lnum) {\n        syn_start_line();\n        for (;; ) {\n          had_sync_point = syn_finish_line(true);\n          // When a sync point has been found, remember where, and\n          // continue to look for another one, further on in the line.\n          if (had_sync_point && current_state.ga_len) {\n            cur_si = &CUR_STATE(current_state.ga_len - 1);\n            if (cur_si->si_m_endpos.lnum > start_lnum) {\n              /* ignore match that goes to after where started */\n              current_lnum = end_lnum;\n              break;\n            }\n            if (cur_si->si_idx < 0) {\n              /* Cannot happen? */\n              found_flags = 0;\n              found_match_idx = KEYWORD_IDX;\n            } else {\n              spp = &(SYN_ITEMS(syn_block)[cur_si->si_idx]);\n              found_flags = spp->sp_flags;\n              found_match_idx = spp->sp_sync_idx;\n            }\n            found_current_lnum = current_lnum;\n            found_current_col = current_col;\n            found_m_endpos = cur_si->si_m_endpos;\n            /*\n             * Continue after the match (be aware of a zero-length\n             * match).\n             */\n            if (found_m_endpos.lnum > current_lnum) {\n              current_lnum = found_m_endpos.lnum;\n              current_col = found_m_endpos.col;\n              if (current_lnum >= end_lnum)\n                break;\n            } else if (found_m_endpos.col > current_col)\n              current_col = found_m_endpos.col;\n            else\n              ++current_col;\n\n            /* syn_current_attr() will have skipped the check for\n             * an item that ends here, need to do that now.  Be\n             * careful not to go past the NUL. */\n            prev_current_col = current_col;\n            if (syn_getcurline()[current_col] != NUL)\n              ++current_col;\n            check_state_ends();\n            current_col = prev_current_col;\n          } else\n            break;\n        }\n      }\n\n      /*\n       * If a sync point was encountered, break here.\n       */\n      if (found_flags) {\n        /*\n         * Put the item that was specified by the sync point on the\n         * state stack.  If there was no item specified, make the\n         * state stack empty.\n         */\n        clear_current_state();\n        if (found_match_idx >= 0) {\n          push_current_state(found_match_idx);\n          update_si_attr(current_state.ga_len - 1);\n        }\n\n        /*\n         * When using \"grouphere\", continue from the sync point\n         * match, until the end of the line.  Parsing starts at\n         * the next line.\n         * For \"groupthere\" the parsing starts at start_lnum.\n         */\n        if (found_flags & HL_SYNC_HERE) {\n          if (!GA_EMPTY(&current_state)) {\n            cur_si = &CUR_STATE(current_state.ga_len - 1);\n            cur_si->si_h_startpos.lnum = found_current_lnum;\n            cur_si->si_h_startpos.col = found_current_col;\n            update_si_end(cur_si, (int)current_col, true);\n            check_keepend();\n          }\n          current_col = found_m_endpos.col;\n          current_lnum = found_m_endpos.lnum;\n          (void)syn_finish_line(false);\n          current_lnum++;\n        } else {\n          current_lnum = start_lnum;\n        }\n\n        break;\n      }\n\n      end_lnum = lnum;\n      invalidate_current_state();\n    }\n\n    /* Ran into start of the file or exceeded maximum number of lines */\n    if (lnum <= break_lnum) {\n      invalidate_current_state();\n      current_lnum = break_lnum + 1;\n    }\n  }\n\n  validate_current_state();\n}\n\nstatic void save_chartab(char_u *chartab)\n{\n  if (syn_block->b_syn_isk != empty_option) {\n    memmove(chartab, syn_buf->b_chartab, (size_t)32);\n    memmove(syn_buf->b_chartab, syn_win->w_s->b_syn_chartab, (size_t)32);\n  }\n}\n\nstatic void restore_chartab(char_u *chartab)\n{\n  if (syn_win->w_s->b_syn_isk != empty_option) {\n    memmove(syn_buf->b_chartab, chartab, (size_t)32);\n  }\n}\n\n/*\n * Return TRUE if the line-continuation pattern matches in line \"lnum\".\n */\nstatic int syn_match_linecont(linenr_T lnum)\n{\n  if (syn_block->b_syn_linecont_prog != NULL) {\n    regmmatch_T regmatch;\n    // chartab array for syn iskeyword\n    char_u buf_chartab[32];\n    save_chartab(buf_chartab);\n\n    regmatch.rmm_ic = syn_block->b_syn_linecont_ic;\n    regmatch.regprog = syn_block->b_syn_linecont_prog;\n    int r = syn_regexec(&regmatch, lnum, (colnr_T)0,\n                        IF_SYN_TIME(&syn_block->b_syn_linecont_time));\n    syn_block->b_syn_linecont_prog = regmatch.regprog;\n\n    restore_chartab(buf_chartab);\n    return r;\n  }\n  return FALSE;\n}\n\n/*\n * Prepare the current state for the start of a line.\n */\nstatic void syn_start_line(void)\n{\n  current_finished = false;\n  current_col = 0;\n\n  /*\n   * Need to update the end of a start/skip/end that continues from the\n   * previous line and regions that have \"keepend\".\n   */\n  if (!GA_EMPTY(&current_state)) {\n    syn_update_ends(true);\n    check_state_ends();\n  }\n\n  next_match_idx = -1;\n  current_line_id++;\n  next_seqnr = 1;\n}\n\n/// Check for items in the stack that need their end updated.\n///\n/// @param startofline  if true the last item is always updated.\n///                     if false the item with \"keepend\" is forcefully updated.\nstatic void syn_update_ends(bool startofline)\n{\n  stateitem_T *cur_si;\n\n  if (startofline) {\n    /* Check for a match carried over from a previous line with a\n     * contained region.  The match ends as soon as the region ends. */\n    for (int i = 0; i < current_state.ga_len; ++i) {\n      cur_si = &CUR_STATE(i);\n      if (cur_si->si_idx >= 0\n          && (SYN_ITEMS(syn_block)[cur_si->si_idx]).sp_type\n          == SPTYPE_MATCH\n          && cur_si->si_m_endpos.lnum < current_lnum) {\n        cur_si->si_flags |= HL_MATCHCONT;\n        cur_si->si_m_endpos.lnum = 0;\n        cur_si->si_m_endpos.col = 0;\n        cur_si->si_h_endpos = cur_si->si_m_endpos;\n        cur_si->si_ends = TRUE;\n      }\n    }\n  }\n\n  /*\n   * Need to update the end of a start/skip/end that continues from the\n   * previous line.  And regions that have \"keepend\", because they may\n   * influence contained items.  If we've just removed \"extend\"\n   * (startofline == 0) then we should update ends of normal regions\n   * contained inside \"keepend\" because \"extend\" could have extended\n   * these \"keepend\" regions as well as contained normal regions.\n   * Then check for items ending in column 0.\n   */\n  int i = current_state.ga_len - 1;\n  if (keepend_level >= 0)\n    for (; i > keepend_level; --i)\n      if (CUR_STATE(i).si_flags & HL_EXTEND)\n        break;\n\n  bool seen_keepend = false;\n  for (; i < current_state.ga_len; i++) {\n    cur_si = &CUR_STATE(i);\n    if ((cur_si->si_flags & HL_KEEPEND)\n        || (seen_keepend && !startofline)\n        || (i == current_state.ga_len - 1 && startofline)) {\n      cur_si->si_h_startpos.col = 0;            /* start highl. in col 0 */\n      cur_si->si_h_startpos.lnum = current_lnum;\n\n      if (!(cur_si->si_flags & HL_MATCHCONT))\n        update_si_end(cur_si, (int)current_col, !startofline);\n\n      if (!startofline && (cur_si->si_flags & HL_KEEPEND)) {\n        seen_keepend = true;\n      }\n    }\n  }\n  check_keepend();\n}\n\n/****************************************\n * Handling of the state stack cache.\n */\n\n/*\n * EXPLANATION OF THE SYNTAX STATE STACK CACHE\n *\n * To speed up syntax highlighting, the state stack for the start of some\n * lines is cached.  These entries can be used to start parsing at that point.\n *\n * The stack is kept in b_sst_array[] for each buffer.  There is a list of\n * valid entries.  b_sst_first points to the first one, then follow sst_next.\n * The entries are sorted on line number.  The first entry is often for line 2\n * (line 1 always starts with an empty stack).\n * There is also a list for free entries.  This construction is used to avoid\n * having to allocate and free memory blocks too often.\n *\n * When making changes to the buffer, this is logged in b_mod_*.  When calling\n * update_screen() to update the display, it will call\n * syn_stack_apply_changes() for each displayed buffer to adjust the cached\n * entries.  The entries which are inside the changed area are removed,\n * because they must be recomputed.  Entries below the changed have their line\n * number adjusted for deleted/inserted lines, and have their sst_change_lnum\n * set to indicate that a check must be made if the changed lines would change\n * the cached entry.\n *\n * When later displaying lines, an entry is stored for each line.  Displayed\n * lines are likely to be displayed again, in which case the state at the\n * start of the line is needed.\n * For not displayed lines, an entry is stored for every so many lines.  These\n * entries will be used e.g., when scrolling backwards.  The distance between\n * entries depends on the number of lines in the buffer.  For small buffers\n * the distance is fixed at SST_DIST, for large buffers there is a fixed\n * number of entries SST_MAX_ENTRIES, and the distance is computed.\n */\n\nstatic void syn_stack_free_block(synblock_T *block)\n{\n  synstate_T  *p;\n\n  if (block->b_sst_array != NULL) {\n    for (p = block->b_sst_first; p != NULL; p = p->sst_next) {\n      clear_syn_state(p);\n    }\n    XFREE_CLEAR(block->b_sst_array);\n    block->b_sst_first = NULL;\n    block->b_sst_len = 0;\n  }\n}\n/*\n * Free b_sst_array[] for buffer \"buf\".\n * Used when syntax items changed to force resyncing everywhere.\n */\nvoid syn_stack_free_all(synblock_T *block)\n{\n  syn_stack_free_block(block);\n\n  /* When using \"syntax\" fold method, must update all folds. */\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_s == block && foldmethodIsSyntax(wp)) {\n      foldUpdateAll(wp);\n    }\n  }\n}\n\n/*\n * Allocate the syntax state stack for syn_buf when needed.\n * If the number of entries in b_sst_array[] is much too big or a bit too\n * small, reallocate it.\n * Also used to allocate b_sst_array[] for the first time.\n */\nstatic void syn_stack_alloc(void)\n{\n  long len;\n  synstate_T  *to, *from;\n  synstate_T  *sstp;\n\n  len = syn_buf->b_ml.ml_line_count / SST_DIST + Rows * 2;\n  if (len < SST_MIN_ENTRIES)\n    len = SST_MIN_ENTRIES;\n  else if (len > SST_MAX_ENTRIES)\n    len = SST_MAX_ENTRIES;\n  if (syn_block->b_sst_len > len * 2 || syn_block->b_sst_len < len) {\n    /* Allocate 50% too much, to avoid reallocating too often. */\n    len = syn_buf->b_ml.ml_line_count;\n    len = (len + len / 2) / SST_DIST + Rows * 2;\n    if (len < SST_MIN_ENTRIES)\n      len = SST_MIN_ENTRIES;\n    else if (len > SST_MAX_ENTRIES)\n      len = SST_MAX_ENTRIES;\n\n    if (syn_block->b_sst_array != NULL) {\n      /* When shrinking the array, cleanup the existing stack.\n       * Make sure that all valid entries fit in the new array. */\n      while (syn_block->b_sst_len - syn_block->b_sst_freecount + 2 > len\n             && syn_stack_cleanup())\n        ;\n      if (len < syn_block->b_sst_len - syn_block->b_sst_freecount + 2)\n        len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;\n    }\n\n    assert(len >= 0);\n    sstp = xcalloc(len, sizeof(synstate_T));\n\n    to = sstp - 1;\n    if (syn_block->b_sst_array != NULL) {\n      /* Move the states from the old array to the new one. */\n      for (from = syn_block->b_sst_first; from != NULL;\n           from = from->sst_next) {\n        ++to;\n        *to = *from;\n        to->sst_next = to + 1;\n      }\n    }\n    if (to != sstp - 1) {\n      to->sst_next = NULL;\n      syn_block->b_sst_first = sstp;\n      syn_block->b_sst_freecount = len - (int)(to - sstp) - 1;\n    } else {\n      syn_block->b_sst_first = NULL;\n      syn_block->b_sst_freecount = len;\n    }\n\n    /* Create the list of free entries. */\n    syn_block->b_sst_firstfree = to + 1;\n    while (++to < sstp + len)\n      to->sst_next = to + 1;\n    (sstp + len - 1)->sst_next = NULL;\n\n    xfree(syn_block->b_sst_array);\n    syn_block->b_sst_array = sstp;\n    syn_block->b_sst_len = len;\n  }\n}\n\n/*\n * Check for changes in a buffer to affect stored syntax states.  Uses the\n * b_mod_* fields.\n * Called from update_screen(), before screen is being updated, once for each\n * displayed buffer.\n */\nvoid syn_stack_apply_changes(buf_T *buf)\n{\n  syn_stack_apply_changes_block(&buf->b_s, buf);\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if ((wp->w_buffer == buf) && (wp->w_s != &buf->b_s)) {\n      syn_stack_apply_changes_block(wp->w_s, buf);\n    }\n  }\n}\n\nstatic void syn_stack_apply_changes_block(synblock_T *block, buf_T *buf)\n{\n  synstate_T  *p, *prev, *np;\n  linenr_T n;\n\n  prev = NULL;\n  for (p = block->b_sst_first; p != NULL; ) {\n    if (p->sst_lnum + block->b_syn_sync_linebreaks > buf->b_mod_top) {\n      n = p->sst_lnum + buf->b_mod_xlines;\n      if (n <= buf->b_mod_bot) {\n        /* this state is inside the changed area, remove it */\n        np = p->sst_next;\n        if (prev == NULL)\n          block->b_sst_first = np;\n        else\n          prev->sst_next = np;\n        syn_stack_free_entry(block, p);\n        p = np;\n        continue;\n      }\n      /* This state is below the changed area.  Remember the line\n       * that needs to be parsed before this entry can be made valid\n       * again. */\n      if (p->sst_change_lnum != 0 && p->sst_change_lnum > buf->b_mod_top) {\n        if (p->sst_change_lnum + buf->b_mod_xlines > buf->b_mod_top)\n          p->sst_change_lnum += buf->b_mod_xlines;\n        else\n          p->sst_change_lnum = buf->b_mod_top;\n      }\n      if (p->sst_change_lnum == 0\n          || p->sst_change_lnum < buf->b_mod_bot)\n        p->sst_change_lnum = buf->b_mod_bot;\n\n      p->sst_lnum = n;\n    }\n    prev = p;\n    p = p->sst_next;\n  }\n}\n\n/// Reduce the number of entries in the state stack for syn_buf.\n///\n/// @return  true if at least one entry was freed.\nstatic bool syn_stack_cleanup(void)\n{\n  synstate_T  *p, *prev;\n  disptick_T tick;\n  int dist;\n  bool retval = false;\n\n  if (syn_block->b_sst_first == NULL) {\n    return retval;\n  }\n\n  /* Compute normal distance between non-displayed entries. */\n  if (syn_block->b_sst_len <= Rows)\n    dist = 999999;\n  else\n    dist = syn_buf->b_ml.ml_line_count / (syn_block->b_sst_len - Rows) + 1;\n\n  /*\n   * Go through the list to find the \"tick\" for the oldest entry that can\n   * be removed.  Set \"above\" when the \"tick\" for the oldest entry is above\n   * \"b_sst_lasttick\" (the display tick wraps around).\n   */\n  tick = syn_block->b_sst_lasttick;\n  bool above = false;\n  prev = syn_block->b_sst_first;\n  for (p = prev->sst_next; p != NULL; prev = p, p = p->sst_next) {\n    if (prev->sst_lnum + dist > p->sst_lnum) {\n      if (p->sst_tick > syn_block->b_sst_lasttick) {\n        if (!above || p->sst_tick < tick)\n          tick = p->sst_tick;\n        above = true;\n      } else if (!above && p->sst_tick < tick) {\n        tick = p->sst_tick;\n      }\n    }\n  }\n\n  /*\n   * Go through the list to make the entries for the oldest tick at an\n   * interval of several lines.\n   */\n  prev = syn_block->b_sst_first;\n  for (p = prev->sst_next; p != NULL; prev = p, p = p->sst_next) {\n    if (p->sst_tick == tick && prev->sst_lnum + dist > p->sst_lnum) {\n      /* Move this entry from used list to free list */\n      prev->sst_next = p->sst_next;\n      syn_stack_free_entry(syn_block, p);\n      p = prev;\n      retval = true;\n    }\n  }\n  return retval;\n}\n\n/*\n * Free the allocated memory for a syn_state item.\n * Move the entry into the free list.\n */\nstatic void syn_stack_free_entry(synblock_T *block, synstate_T *p)\n{\n  clear_syn_state(p);\n  p->sst_next = block->b_sst_firstfree;\n  block->b_sst_firstfree = p;\n  ++block->b_sst_freecount;\n}\n\n/*\n * Find an entry in the list of state stacks at or before \"lnum\".\n * Returns NULL when there is no entry or the first entry is after \"lnum\".\n */\nstatic synstate_T *syn_stack_find_entry(linenr_T lnum)\n{\n  synstate_T  *p, *prev;\n\n  prev = NULL;\n  for (p = syn_block->b_sst_first; p != NULL; prev = p, p = p->sst_next) {\n    if (p->sst_lnum == lnum)\n      return p;\n    if (p->sst_lnum > lnum)\n      break;\n  }\n  return prev;\n}\n\n/*\n * Try saving the current state in b_sst_array[].\n * The current state must be valid for the start of the current_lnum line!\n */\nstatic synstate_T *store_current_state(void)\n{\n  int i;\n  synstate_T  *p;\n  bufstate_T  *bp;\n  stateitem_T *cur_si;\n  synstate_T  *sp = syn_stack_find_entry(current_lnum);\n\n  /*\n   * If the current state contains a start or end pattern that continues\n   * from the previous line, we can't use it.  Don't store it then.\n   */\n  for (i = current_state.ga_len - 1; i >= 0; --i) {\n    cur_si = &CUR_STATE(i);\n    if (cur_si->si_h_startpos.lnum >= current_lnum\n        || cur_si->si_m_endpos.lnum >= current_lnum\n        || cur_si->si_h_endpos.lnum >= current_lnum\n        || (cur_si->si_end_idx\n            && cur_si->si_eoe_pos.lnum >= current_lnum))\n      break;\n  }\n  if (i >= 0) {\n    if (sp != NULL) {\n      /* find \"sp\" in the list and remove it */\n      if (syn_block->b_sst_first == sp)\n        /* it's the first entry */\n        syn_block->b_sst_first = sp->sst_next;\n      else {\n        /* find the entry just before this one to adjust sst_next */\n        for (p = syn_block->b_sst_first; p != NULL; p = p->sst_next)\n          if (p->sst_next == sp)\n            break;\n        if (p != NULL)          /* just in case */\n          p->sst_next = sp->sst_next;\n      }\n      syn_stack_free_entry(syn_block, sp);\n      sp = NULL;\n    }\n  } else if (sp == NULL || sp->sst_lnum != current_lnum)   {\n    /*\n     * Add a new entry\n     */\n    /* If no free items, cleanup the array first. */\n    if (syn_block->b_sst_freecount == 0) {\n      (void)syn_stack_cleanup();\n      /* \"sp\" may have been moved to the freelist now */\n      sp = syn_stack_find_entry(current_lnum);\n    }\n    /* Still no free items?  Must be a strange problem... */\n    if (syn_block->b_sst_freecount == 0)\n      sp = NULL;\n    else {\n      /* Take the first item from the free list and put it in the used\n       * list, after *sp */\n      p = syn_block->b_sst_firstfree;\n      syn_block->b_sst_firstfree = p->sst_next;\n      --syn_block->b_sst_freecount;\n      if (sp == NULL) {\n        /* Insert in front of the list */\n        p->sst_next = syn_block->b_sst_first;\n        syn_block->b_sst_first = p;\n      } else {\n        /* insert in list after *sp */\n        p->sst_next = sp->sst_next;\n        sp->sst_next = p;\n      }\n      sp = p;\n      sp->sst_stacksize = 0;\n      sp->sst_lnum = current_lnum;\n    }\n  }\n  if (sp != NULL) {\n    /* When overwriting an existing state stack, clear it first */\n    clear_syn_state(sp);\n    sp->sst_stacksize = current_state.ga_len;\n    if (current_state.ga_len > SST_FIX_STATES) {\n      /* Need to clear it, might be something remaining from when the\n       * length was less than SST_FIX_STATES. */\n      ga_init(&sp->sst_union.sst_ga, (int)sizeof(bufstate_T), 1);\n      ga_grow(&sp->sst_union.sst_ga, current_state.ga_len);\n      sp->sst_union.sst_ga.ga_len = current_state.ga_len;\n      bp = SYN_STATE_P(&(sp->sst_union.sst_ga));\n    } else\n      bp = sp->sst_union.sst_stack;\n    for (i = 0; i < sp->sst_stacksize; ++i) {\n      bp[i].bs_idx = CUR_STATE(i).si_idx;\n      bp[i].bs_flags = CUR_STATE(i).si_flags;\n      bp[i].bs_seqnr = CUR_STATE(i).si_seqnr;\n      bp[i].bs_cchar = CUR_STATE(i).si_cchar;\n      bp[i].bs_extmatch = ref_extmatch(CUR_STATE(i).si_extmatch);\n    }\n    sp->sst_next_flags = current_next_flags;\n    sp->sst_next_list = current_next_list;\n    sp->sst_tick = display_tick;\n    sp->sst_change_lnum = 0;\n  }\n  current_state_stored = true;\n  return sp;\n}\n\n/*\n * Copy a state stack from \"from\" in b_sst_array[] to current_state;\n */\nstatic void load_current_state(synstate_T *from)\n{\n  int i;\n  bufstate_T  *bp;\n\n  clear_current_state();\n  validate_current_state();\n  keepend_level = -1;\n  if (from->sst_stacksize) {\n    ga_grow(&current_state, from->sst_stacksize);\n    if (from->sst_stacksize > SST_FIX_STATES)\n      bp = SYN_STATE_P(&(from->sst_union.sst_ga));\n    else\n      bp = from->sst_union.sst_stack;\n    for (i = 0; i < from->sst_stacksize; ++i) {\n      CUR_STATE(i).si_idx = bp[i].bs_idx;\n      CUR_STATE(i).si_flags = bp[i].bs_flags;\n      CUR_STATE(i).si_seqnr = bp[i].bs_seqnr;\n      CUR_STATE(i).si_cchar = bp[i].bs_cchar;\n      CUR_STATE(i).si_extmatch = ref_extmatch(bp[i].bs_extmatch);\n      if (keepend_level < 0 && (CUR_STATE(i).si_flags & HL_KEEPEND))\n        keepend_level = i;\n      CUR_STATE(i).si_ends = FALSE;\n      CUR_STATE(i).si_m_lnum = 0;\n      if (CUR_STATE(i).si_idx >= 0)\n        CUR_STATE(i).si_next_list =\n          (SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_next_list;\n      else\n        CUR_STATE(i).si_next_list = NULL;\n      update_si_attr(i);\n    }\n    current_state.ga_len = from->sst_stacksize;\n  }\n  current_next_list = from->sst_next_list;\n  current_next_flags = from->sst_next_flags;\n  current_lnum = from->sst_lnum;\n}\n\n/// Compare saved state stack \"*sp\" with the current state.\n///\n/// @return  true when they are equal.\nstatic bool syn_stack_equal(synstate_T *sp)\n{\n  bufstate_T  *bp;\n  reg_extmatch_T      *six, *bsx;\n\n  /* First a quick check if the stacks have the same size end nextlist. */\n  if (sp->sst_stacksize != current_state.ga_len\n      || sp->sst_next_list != current_next_list) {\n    return false;\n  }\n\n  /* Need to compare all states on both stacks. */\n  if (sp->sst_stacksize > SST_FIX_STATES)\n    bp = SYN_STATE_P(&(sp->sst_union.sst_ga));\n  else\n    bp = sp->sst_union.sst_stack;\n\n  int i;\n  for (i = current_state.ga_len; --i >= 0; ) {\n    /* If the item has another index the state is different. */\n    if (bp[i].bs_idx != CUR_STATE(i).si_idx)\n      break;\n    if (bp[i].bs_extmatch == CUR_STATE(i).si_extmatch) {\n      continue;\n    }\n    /* When the extmatch pointers are different, the strings in\n     * them can still be the same.  Check if the extmatch\n     * references are equal. */\n    bsx = bp[i].bs_extmatch;\n    six = CUR_STATE(i).si_extmatch;\n    /* If one of the extmatch pointers is NULL the states are\n     * different. */\n    if (bsx == NULL || six == NULL)\n      break;\n    int j;\n    for (j = 0; j < NSUBEXP; ++j) {\n      /* Check each referenced match string. They must all be\n       * equal. */\n      if (bsx->matches[j] != six->matches[j]) {\n        /* If the pointer is different it can still be the\n         * same text.  Compare the strings, ignore case when\n         * the start item has the sp_ic flag set. */\n        if (bsx->matches[j] == NULL || six->matches[j] == NULL) {\n          break;\n        }\n        if (mb_strcmp_ic((SYN_ITEMS(syn_block)[CUR_STATE(i).si_idx]).sp_ic,\n                         (const char *)bsx->matches[j],\n                         (const char *)six->matches[j]) != 0) {\n          break;\n        }\n      }\n    }\n    if (j != NSUBEXP)\n      break;\n  }\n  if (i < 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/*\n * We stop parsing syntax above line \"lnum\".  If the stored state at or below\n * this line depended on a change before it, it now depends on the line below\n * the last parsed line.\n * The window looks like this:\n *\t    line which changed\n *\t    displayed line\n *\t    displayed line\n * lnum ->  line below window\n */\nvoid syntax_end_parsing(linenr_T lnum)\n{\n  synstate_T  *sp;\n\n  sp = syn_stack_find_entry(lnum);\n  if (sp != NULL && sp->sst_lnum < lnum)\n    sp = sp->sst_next;\n\n  if (sp != NULL && sp->sst_change_lnum != 0)\n    sp->sst_change_lnum = lnum;\n}\n\n/*\n * End of handling of the state stack.\n ****************************************/\n\nstatic void invalidate_current_state(void)\n{\n  clear_current_state();\n  current_state.ga_itemsize = 0;        /* mark current_state invalid */\n  current_next_list = NULL;\n  keepend_level = -1;\n}\n\nstatic void validate_current_state(void)\n{\n  current_state.ga_itemsize = sizeof(stateitem_T);\n  ga_set_growsize(&current_state, 3);\n}\n\n/// This will only be called just after get_syntax_attr() for the previous\n/// line, to check if the next line needs to be redrawn too.\n///\n/// @return  true if the syntax at start of lnum changed since last time.\nbool syntax_check_changed(linenr_T lnum)\n{\n  bool retval = true;\n  synstate_T  *sp;\n\n  /*\n   * Check the state stack when:\n   * - lnum is just below the previously syntaxed line.\n   * - lnum is not before the lines with saved states.\n   * - lnum is not past the lines with saved states.\n   * - lnum is at or before the last changed line.\n   */\n  if (VALID_STATE(&current_state) && lnum == current_lnum + 1) {\n    sp = syn_stack_find_entry(lnum);\n    if (sp != NULL && sp->sst_lnum == lnum) {\n      /*\n       * finish the previous line (needed when not all of the line was\n       * drawn)\n       */\n      (void)syn_finish_line(false);\n\n      /*\n       * Compare the current state with the previously saved state of\n       * the line.\n       */\n      if (syn_stack_equal(sp)) {\n        retval = false;\n      }\n\n      /*\n       * Store the current state in b_sst_array[] for later use.\n       */\n      ++current_lnum;\n      (void)store_current_state();\n    }\n  }\n\n  return retval;\n}\n\n/*\n * Finish the current line.\n * This doesn't return any attributes, it only gets the state at the end of\n * the line.  It can start anywhere in the line, as long as the current state\n * is valid.\n */\nstatic bool\nsyn_finish_line(\n    const bool syncing            // called for syncing\n)\n{\n  while (!current_finished) {\n    (void)syn_current_attr(syncing, false, NULL, false);\n\n    // When syncing, and found some item, need to check the item.\n    if (syncing && current_state.ga_len) {\n      // Check for match with sync item.\n      const stateitem_T *const cur_si = &CUR_STATE(current_state.ga_len - 1);\n      if (cur_si->si_idx >= 0\n          && (SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags\n              & (HL_SYNC_HERE|HL_SYNC_THERE))) {\n        return true;\n      }\n\n      // syn_current_attr() will have skipped the check for an item\n      // that ends here, need to do that now.  Be careful not to go\n      // past the NUL.\n      const colnr_T prev_current_col = current_col;\n      if (syn_getcurline()[current_col] != NUL) {\n        current_col++;\n      }\n      check_state_ends();\n      current_col = prev_current_col;\n    }\n    current_col++;\n  }\n  return false;\n}\n\n/*\n * Return highlight attributes for next character.\n * Must first call syntax_start() once for the line.\n * \"col\" is normally 0 for the first use in a line, and increments by one each\n * time.  It's allowed to skip characters and to stop before the end of the\n * line.  But only a \"col\" after a previously used column is allowed.\n * When \"can_spell\" is not NULL set it to TRUE when spell-checking should be\n * done.\n */\nint\nget_syntax_attr(\n    const colnr_T col,\n    bool *const can_spell,\n    const bool keep_state           // keep state of char at \"col\"\n)\n{\n  int attr = 0;\n\n  if (can_spell != NULL)\n    /* Default: Only do spelling when there is no @Spell cluster or when\n     * \":syn spell toplevel\" was used. */\n    *can_spell = syn_block->b_syn_spell == SYNSPL_DEFAULT\n                 ? (syn_block->b_spell_cluster_id == 0)\n                 : (syn_block->b_syn_spell == SYNSPL_TOP);\n\n  /* check for out of memory situation */\n  if (syn_block->b_sst_array == NULL)\n    return 0;\n\n  /* After 'synmaxcol' the attribute is always zero. */\n  if (syn_buf->b_p_smc > 0 && col >= (colnr_T)syn_buf->b_p_smc) {\n    clear_current_state();\n    current_id = 0;\n    current_trans_id = 0;\n    current_flags = 0;\n    current_seqnr = 0;\n    return 0;\n  }\n\n  /* Make sure current_state is valid */\n  if (INVALID_STATE(&current_state))\n    validate_current_state();\n\n  /*\n   * Skip from the current column to \"col\", get the attributes for \"col\".\n   */\n  while (current_col <= col) {\n    attr = syn_current_attr(false, true, can_spell,\n                            current_col == col ? keep_state : false);\n    current_col++;\n  }\n\n  return attr;\n}\n\n/*\n * Get syntax attributes for current_lnum, current_col.\n */\nstatic int syn_current_attr(\n    const bool syncing,                   // When true: called for syncing\n    const bool displaying,                // result will be displayed\n    bool *const can_spell,                // return: do spell checking\n    const bool keep_state                 // keep syntax stack afterwards\n)\n{\n  lpos_T endpos;                // was: char_u *endp;\n  lpos_T hl_startpos;           // was: int hl_startcol;\n  lpos_T hl_endpos;\n  lpos_T eos_pos;               // end-of-start match (start region)\n  lpos_T eoe_pos;               // end-of-end pattern\n  int end_idx;                  // group ID for end pattern\n  stateitem_T *cur_si, *sip = NULL;\n  int startcol;\n  int endcol;\n  long flags;\n  int cchar;\n  int16_t *next_list;\n  bool found_match;                         // found usable match\n  static bool try_next_column = false;      // must try in next col\n  regmmatch_T regmatch;\n  lpos_T pos;\n  reg_extmatch_T *cur_extmatch = NULL;\n  char_u      buf_chartab[32];  // chartab array for syn iskeyword\n  char_u      *line;            // current line.  NOTE: becomes invalid after\n                                // looking for a pattern match!\n\n  // variables for zero-width matches that have a \"nextgroup\" argument\n  bool keep_next_list;\n  bool zero_width_next_list = false;\n  garray_T zero_width_next_ga;\n\n  /*\n   * No character, no attributes!  Past end of line?\n   * Do try matching with an empty line (could be the start of a region).\n   */\n  line = syn_getcurline();\n  if (line[current_col] == NUL && current_col != 0) {\n    /*\n     * If we found a match after the last column, use it.\n     */\n    if (next_match_idx >= 0 && next_match_col >= (int)current_col\n        && next_match_col != MAXCOL) {\n      (void)push_next_match();\n    }\n\n    current_finished = true;\n    current_state_stored = false;\n    return 0;\n  }\n\n  /* if the current or next character is NUL, we will finish the line now */\n  if (line[current_col] == NUL || line[current_col + 1] == NUL) {\n    current_finished = true;\n    current_state_stored = false;\n  }\n\n  /*\n   * When in the previous column there was a match but it could not be used\n   * (empty match or already matched in this column) need to try again in\n   * the next column.\n   */\n  if (try_next_column) {\n    next_match_idx = -1;\n    try_next_column = false;\n  }\n\n  // Only check for keywords when not syncing and there are some.\n  const bool do_keywords = !syncing\n      && (syn_block->b_keywtab.ht_used > 0\n          || syn_block->b_keywtab_ic.ht_used > 0);\n\n  /* Init the list of zero-width matches with a nextlist.  This is used to\n   * avoid matching the same item in the same position twice. */\n  ga_init(&zero_width_next_ga, (int)sizeof(int), 10);\n\n  // use syntax iskeyword option\n  save_chartab(buf_chartab);\n\n  /*\n   * Repeat matching keywords and patterns, to find contained items at the\n   * same column.  This stops when there are no extra matches at the current\n   * column.\n   */\n  do {\n    found_match = false;\n    keep_next_list = false;\n    int syn_id = 0;\n\n    /*\n     * 1. Check for a current state.\n     *    Only when there is no current state, or if the current state may\n     *    contain other things, we need to check for keywords and patterns.\n     *    Always need to check for contained items if some item has the\n     *    \"containedin\" argument (takes extra time!).\n     */\n    if (current_state.ga_len)\n      cur_si = &CUR_STATE(current_state.ga_len - 1);\n    else\n      cur_si = NULL;\n\n    if (syn_block->b_syn_containedin || cur_si == NULL\n        || cur_si->si_cont_list != NULL) {\n      /*\n       * 2. Check for keywords, if on a keyword char after a non-keyword\n       *\t  char.  Don't do this when syncing.\n       */\n      if (do_keywords) {\n        line = syn_getcurline();\n        const char_u *cur_pos = line + current_col;\n        if (vim_iswordp_buf(cur_pos, syn_buf)\n            && (current_col == 0 || !vim_iswordp_buf(\n                cur_pos - 1 - utf_head_off(line, cur_pos - 1), syn_buf))) {\n          syn_id = check_keyword_id(line, (int)current_col, &endcol, &flags,\n                                    &next_list, cur_si, &cchar);\n          if (syn_id != 0) {\n            push_current_state(KEYWORD_IDX);\n            {\n              cur_si = &CUR_STATE(current_state.ga_len - 1);\n              cur_si->si_m_startcol = current_col;\n              cur_si->si_h_startpos.lnum = current_lnum;\n              cur_si->si_h_startpos.col = 0;            /* starts right away */\n              cur_si->si_m_endpos.lnum = current_lnum;\n              cur_si->si_m_endpos.col = endcol;\n              cur_si->si_h_endpos.lnum = current_lnum;\n              cur_si->si_h_endpos.col = endcol;\n              cur_si->si_ends = TRUE;\n              cur_si->si_end_idx = 0;\n              cur_si->si_flags = flags;\n              cur_si->si_seqnr = next_seqnr++;\n              cur_si->si_cchar = cchar;\n              if (current_state.ga_len > 1)\n                cur_si->si_flags |=\n                  CUR_STATE(current_state.ga_len - 2).si_flags\n                  & HL_CONCEAL;\n              cur_si->si_id = syn_id;\n              cur_si->si_trans_id = syn_id;\n              if (flags & HL_TRANSP) {\n                if (current_state.ga_len < 2) {\n                  cur_si->si_attr = 0;\n                  cur_si->si_trans_id = 0;\n                } else {\n                  cur_si->si_attr = CUR_STATE(\n                      current_state.ga_len - 2).si_attr;\n                  cur_si->si_trans_id = CUR_STATE(\n                      current_state.ga_len - 2).si_trans_id;\n                }\n              } else {\n                cur_si->si_attr = syn_id2attr(syn_id);\n              }\n              cur_si->si_cont_list = NULL;\n              cur_si->si_next_list = next_list;\n              check_keepend();\n            }\n          }\n        }\n      }\n\n      /*\n       * 3. Check for patterns (only if no keyword found).\n       */\n      if (syn_id == 0 && syn_block->b_syn_patterns.ga_len) {\n        /*\n         * If we didn't check for a match yet, or we are past it, check\n         * for any match with a pattern.\n         */\n        if (next_match_idx < 0 || next_match_col < (int)current_col) {\n          /*\n           * Check all relevant patterns for a match at this\n           * position.  This is complicated, because matching with a\n           * pattern takes quite a bit of time, thus we want to\n           * avoid doing it when it's not needed.\n           */\n          next_match_idx = 0;                   /* no match in this line yet */\n          next_match_col = MAXCOL;\n          for (int idx = syn_block->b_syn_patterns.ga_len; --idx >= 0; ) {\n            synpat_T *const spp = &(SYN_ITEMS(syn_block)[idx]);\n            if (       spp->sp_syncing == syncing\n                       && (displaying || !(spp->sp_flags & HL_DISPLAY))\n                       && (spp->sp_type == SPTYPE_MATCH\n                           || spp->sp_type == SPTYPE_START)\n                       && (current_next_list != NULL\n                           ? in_id_list(NULL, current_next_list,\n                               &spp->sp_syn, 0)\n                           : (cur_si == NULL\n                              ? !(spp->sp_flags & HL_CONTAINED)\n                              : in_id_list(cur_si,\n                                  cur_si->si_cont_list, &spp->sp_syn,\n                                  spp->sp_flags & HL_CONTAINED)))) {\n              /* If we already tried matching in this line, and\n               * there isn't a match before next_match_col, skip\n               * this item. */\n              if (spp->sp_line_id == current_line_id\n                  && spp->sp_startcol >= next_match_col)\n                continue;\n              spp->sp_line_id = current_line_id;\n\n              colnr_T lc_col = current_col - spp->sp_offsets[SPO_LC_OFF];\n              if (lc_col < 0) {\n                lc_col = 0;\n              }\n\n              regmatch.rmm_ic = spp->sp_ic;\n              regmatch.regprog = spp->sp_prog;\n              int r = syn_regexec(&regmatch, current_lnum, lc_col,\n                                  IF_SYN_TIME(&spp->sp_time));\n              spp->sp_prog = regmatch.regprog;\n              if (!r) {\n                /* no match in this line, try another one */\n                spp->sp_startcol = MAXCOL;\n                continue;\n              }\n\n              /*\n               * Compute the first column of the match.\n               */\n              syn_add_start_off(&pos, &regmatch,\n                  spp, SPO_MS_OFF, -1);\n              if (pos.lnum > current_lnum) {\n                /* must have used end of match in a next line,\n                 * we can't handle that */\n                spp->sp_startcol = MAXCOL;\n                continue;\n              }\n              startcol = pos.col;\n\n              /* remember the next column where this pattern\n               * matches in the current line */\n              spp->sp_startcol = startcol;\n\n              /*\n               * If a previously found match starts at a lower\n               * column number, don't use this one.\n               */\n              if (startcol >= next_match_col)\n                continue;\n\n              /*\n               * If we matched this pattern at this position\n               * before, skip it.  Must retry in the next\n               * column, because it may match from there.\n               */\n              if (did_match_already(idx, &zero_width_next_ga)) {\n                try_next_column = true;\n                continue;\n              }\n\n              endpos.lnum = regmatch.endpos[0].lnum;\n              endpos.col = regmatch.endpos[0].col;\n\n              /* Compute the highlight start. */\n              syn_add_start_off(&hl_startpos, &regmatch,\n                  spp, SPO_HS_OFF, -1);\n\n              /* Compute the region start. */\n              /* Default is to use the end of the match. */\n              syn_add_end_off(&eos_pos, &regmatch,\n                  spp, SPO_RS_OFF, 0);\n\n              /*\n               * Grab the external submatches before they get\n               * overwritten.  Reference count doesn't change.\n               */\n              unref_extmatch(cur_extmatch);\n              cur_extmatch = re_extmatch_out;\n              re_extmatch_out = NULL;\n\n              flags = 0;\n              eoe_pos.lnum = 0;                 /* avoid warning */\n              eoe_pos.col = 0;\n              end_idx = 0;\n              hl_endpos.lnum = 0;\n\n              /*\n               * For a \"oneline\" the end must be found in the\n               * same line too.  Search for it after the end of\n               * the match with the start pattern.  Set the\n               * resulting end positions at the same time.\n               */\n              if (spp->sp_type == SPTYPE_START\n                  && (spp->sp_flags & HL_ONELINE)) {\n                lpos_T startpos;\n\n                startpos = endpos;\n                find_endpos(idx, &startpos, &endpos, &hl_endpos,\n                    &flags, &eoe_pos, &end_idx, cur_extmatch);\n                if (endpos.lnum == 0)\n                  continue;                         /* not found */\n              }\n              /*\n               * For a \"match\" the size must be > 0 after the\n               * end offset needs has been added.  Except when\n               * syncing.\n               */\n              else if (spp->sp_type == SPTYPE_MATCH) {\n                syn_add_end_off(&hl_endpos, &regmatch, spp,\n                    SPO_HE_OFF, 0);\n                syn_add_end_off(&endpos, &regmatch, spp,\n                    SPO_ME_OFF, 0);\n                if (endpos.lnum == current_lnum\n                    && (int)endpos.col + syncing < startcol) {\n                  /*\n                   * If an empty string is matched, may need\n                   * to try matching again at next column.\n                   */\n                  if (regmatch.startpos[0].col == regmatch.endpos[0].col) {\n                    try_next_column = true;\n                  }\n                  continue;\n                }\n              }\n\n              /*\n               * keep the best match so far in next_match_*\n               */\n              /* Highlighting must start after startpos and end\n               * before endpos. */\n              if (hl_startpos.lnum == current_lnum\n                  && (int)hl_startpos.col < startcol)\n                hl_startpos.col = startcol;\n              limit_pos_zero(&hl_endpos, &endpos);\n\n              next_match_idx = idx;\n              next_match_col = startcol;\n              next_match_m_endpos = endpos;\n              next_match_h_endpos = hl_endpos;\n              next_match_h_startpos = hl_startpos;\n              next_match_flags = flags;\n              next_match_eos_pos = eos_pos;\n              next_match_eoe_pos = eoe_pos;\n              next_match_end_idx = end_idx;\n              unref_extmatch(next_match_extmatch);\n              next_match_extmatch = cur_extmatch;\n              cur_extmatch = NULL;\n            }\n          }\n        }\n\n        /*\n         * If we found a match at the current column, use it.\n         */\n        if (next_match_idx >= 0 && next_match_col == (int)current_col) {\n          synpat_T    *lspp;\n\n          /* When a zero-width item matched which has a nextgroup,\n           * don't push the item but set nextgroup. */\n          lspp = &(SYN_ITEMS(syn_block)[next_match_idx]);\n          if (next_match_m_endpos.lnum == current_lnum\n              && next_match_m_endpos.col == current_col\n              && lspp->sp_next_list != NULL) {\n            current_next_list = lspp->sp_next_list;\n            current_next_flags = lspp->sp_flags;\n            keep_next_list = true;\n            zero_width_next_list = true;\n\n            /* Add the index to a list, so that we can check\n             * later that we don't match it again (and cause an\n             * endless loop). */\n            GA_APPEND(int, &zero_width_next_ga, next_match_idx);\n            next_match_idx = -1;\n          } else {\n            cur_si = push_next_match();\n          }\n          found_match = true;\n        }\n      }\n    }\n\n    /*\n     * Handle searching for nextgroup match.\n     */\n    if (current_next_list != NULL && !keep_next_list) {\n      /*\n       * If a nextgroup was not found, continue looking for one if:\n       * - this is an empty line and the \"skipempty\" option was given\n       * - we are on white space and the \"skipwhite\" option was given\n       */\n      if (!found_match) {\n        line = syn_getcurline();\n        if (((current_next_flags & HL_SKIPWHITE)\n             && ascii_iswhite(line[current_col]))\n            || ((current_next_flags & HL_SKIPEMPTY)\n                && *line == NUL))\n          break;\n      }\n\n      /*\n       * If a nextgroup was found: Use it, and continue looking for\n       * contained matches.\n       * If a nextgroup was not found: Continue looking for a normal\n       * match.\n       * When did set current_next_list for a zero-width item and no\n       * match was found don't loop (would get stuck).\n       */\n      current_next_list = NULL;\n      next_match_idx = -1;\n      if (!zero_width_next_list) {\n        found_match = true;\n      }\n    }\n\n  } while (found_match);\n\n  restore_chartab(buf_chartab);\n\n  /*\n   * Use attributes from the current state, if within its highlighting.\n   * If not, use attributes from the current-but-one state, etc.\n   */\n  current_attr = 0;\n  current_id = 0;\n  current_trans_id = 0;\n  current_flags = 0;\n  current_seqnr = 0;\n  if (cur_si != NULL) {\n    for (int idx = current_state.ga_len - 1; idx >= 0; --idx) {\n      sip = &CUR_STATE(idx);\n      if ((current_lnum > sip->si_h_startpos.lnum\n           || (current_lnum == sip->si_h_startpos.lnum\n               && current_col >= sip->si_h_startpos.col))\n          && (sip->si_h_endpos.lnum == 0\n              || current_lnum < sip->si_h_endpos.lnum\n              || (current_lnum == sip->si_h_endpos.lnum\n                  && current_col < sip->si_h_endpos.col))) {\n        current_attr = sip->si_attr;\n        current_id = sip->si_id;\n        current_trans_id = sip->si_trans_id;\n        current_flags = sip->si_flags;\n        current_seqnr = sip->si_seqnr;\n        current_sub_char = sip->si_cchar;\n        break;\n      }\n    }\n\n    if (can_spell != NULL) {\n      struct sp_syn sps;\n\n      /*\n       * set \"can_spell\" to TRUE if spell checking is supposed to be\n       * done in the current item.\n       */\n      if (syn_block->b_spell_cluster_id == 0) {\n        /* There is no @Spell cluster: Do spelling for items without\n         * @NoSpell cluster. */\n        if (syn_block->b_nospell_cluster_id == 0\n            || current_trans_id == 0)\n          *can_spell = (syn_block->b_syn_spell != SYNSPL_NOTOP);\n        else {\n          sps.inc_tag = 0;\n          sps.id = syn_block->b_nospell_cluster_id;\n          sps.cont_in_list = NULL;\n          *can_spell = !in_id_list(sip, sip->si_cont_list, &sps, 0);\n        }\n      } else {\n        /* The @Spell cluster is defined: Do spelling in items with\n         * the @Spell cluster.  But not when @NoSpell is also there.\n         * At the toplevel only spell check when \":syn spell toplevel\"\n         * was used. */\n        if (current_trans_id == 0)\n          *can_spell = (syn_block->b_syn_spell == SYNSPL_TOP);\n        else {\n          sps.inc_tag = 0;\n          sps.id = syn_block->b_spell_cluster_id;\n          sps.cont_in_list = NULL;\n          *can_spell = in_id_list(sip, sip->si_cont_list, &sps, 0);\n\n          if (syn_block->b_nospell_cluster_id != 0) {\n            sps.id = syn_block->b_nospell_cluster_id;\n            if (in_id_list(sip, sip->si_cont_list, &sps, 0))\n              *can_spell = false;\n          }\n        }\n      }\n    }\n\n\n    /*\n     * Check for end of current state (and the states before it) at the\n     * next column.  Don't do this for syncing, because we would miss a\n     * single character match.\n     * First check if the current state ends at the current column.  It\n     * may be for an empty match and a containing item might end in the\n     * current column.\n     */\n    if (!syncing && !keep_state) {\n      check_state_ends();\n      if (!GA_EMPTY(&current_state)\n          && syn_getcurline()[current_col] != NUL) {\n        ++current_col;\n        check_state_ends();\n        --current_col;\n      }\n    }\n  } else if (can_spell != NULL)\n    /* Default: Only do spelling when there is no @Spell cluster or when\n     * \":syn spell toplevel\" was used. */\n    *can_spell = syn_block->b_syn_spell == SYNSPL_DEFAULT\n                 ? (syn_block->b_spell_cluster_id == 0)\n                 : (syn_block->b_syn_spell == SYNSPL_TOP);\n\n  /* nextgroup ends at end of line, unless \"skipnl\" or \"skipempty\" present */\n  if (current_next_list != NULL\n      && (line = syn_getcurline())[current_col] != NUL\n      && line[current_col + 1] == NUL\n      && !(current_next_flags & (HL_SKIPNL | HL_SKIPEMPTY))) {\n    current_next_list = NULL;\n  }\n\n  if (!GA_EMPTY(&zero_width_next_ga))\n    ga_clear(&zero_width_next_ga);\n\n  /* No longer need external matches.  But keep next_match_extmatch. */\n  unref_extmatch(re_extmatch_out);\n  re_extmatch_out = NULL;\n  unref_extmatch(cur_extmatch);\n\n  return current_attr;\n}\n\n\n/// @return  true if we already matched pattern \"idx\" at the current column.\nstatic bool did_match_already(int idx, garray_T *gap)\n{\n  for (int i = current_state.ga_len; --i >= 0; ) {\n    if (CUR_STATE(i).si_m_startcol == (int)current_col\n        && CUR_STATE(i).si_m_lnum == (int)current_lnum\n        && CUR_STATE(i).si_idx == idx) {\n      return true;\n    }\n  }\n\n  /* Zero-width matches with a nextgroup argument are not put on the syntax\n   * stack, and can only be matched once anyway. */\n  for (int i = gap->ga_len; --i >= 0; ) {\n    if (((int *)(gap->ga_data))[i] == idx) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/*\n * Push the next match onto the stack.\n */\nstatic stateitem_T *push_next_match(void)\n{\n  stateitem_T *cur_si;\n  synpat_T *spp;\n  int save_flags;\n\n  spp = &(SYN_ITEMS(syn_block)[next_match_idx]);\n\n  /*\n   * Push the item in current_state stack;\n   */\n  push_current_state(next_match_idx);\n  {\n    /*\n     * If it's a start-skip-end type that crosses lines, figure out how\n     * much it continues in this line.  Otherwise just fill in the length.\n     */\n    cur_si = &CUR_STATE(current_state.ga_len - 1);\n    cur_si->si_h_startpos = next_match_h_startpos;\n    cur_si->si_m_startcol = current_col;\n    cur_si->si_m_lnum = current_lnum;\n    cur_si->si_flags = spp->sp_flags;\n    cur_si->si_seqnr = next_seqnr++;\n    cur_si->si_cchar = spp->sp_cchar;\n    if (current_state.ga_len > 1)\n      cur_si->si_flags |=\n        CUR_STATE(current_state.ga_len - 2).si_flags & HL_CONCEAL;\n    cur_si->si_next_list = spp->sp_next_list;\n    cur_si->si_extmatch = ref_extmatch(next_match_extmatch);\n    if (spp->sp_type == SPTYPE_START && !(spp->sp_flags & HL_ONELINE)) {\n      // Try to find the end pattern in the current line\n      update_si_end(cur_si, (int)(next_match_m_endpos.col), true);\n      check_keepend();\n    } else {\n      cur_si->si_m_endpos = next_match_m_endpos;\n      cur_si->si_h_endpos = next_match_h_endpos;\n      cur_si->si_ends = TRUE;\n      cur_si->si_flags |= next_match_flags;\n      cur_si->si_eoe_pos = next_match_eoe_pos;\n      cur_si->si_end_idx = next_match_end_idx;\n    }\n    if (keepend_level < 0 && (cur_si->si_flags & HL_KEEPEND))\n      keepend_level = current_state.ga_len - 1;\n    check_keepend();\n    update_si_attr(current_state.ga_len - 1);\n\n    save_flags = cur_si->si_flags & (HL_CONCEAL | HL_CONCEALENDS);\n    /*\n     * If the start pattern has another highlight group, push another item\n     * on the stack for the start pattern.\n     */\n    if (spp->sp_type == SPTYPE_START && spp->sp_syn_match_id != 0) {\n      push_current_state(next_match_idx);\n      cur_si = &CUR_STATE(current_state.ga_len - 1);\n      cur_si->si_h_startpos = next_match_h_startpos;\n      cur_si->si_m_startcol = current_col;\n      cur_si->si_m_lnum = current_lnum;\n      cur_si->si_m_endpos = next_match_eos_pos;\n      cur_si->si_h_endpos = next_match_eos_pos;\n      cur_si->si_ends = TRUE;\n      cur_si->si_end_idx = 0;\n      cur_si->si_flags = HL_MATCH;\n      cur_si->si_seqnr = next_seqnr++;\n      cur_si->si_flags |= save_flags;\n      if (cur_si->si_flags & HL_CONCEALENDS)\n        cur_si->si_flags |= HL_CONCEAL;\n      cur_si->si_next_list = NULL;\n      check_keepend();\n      update_si_attr(current_state.ga_len - 1);\n    }\n  }\n\n  next_match_idx = -1;          /* try other match next time */\n\n  return cur_si;\n}\n\n/*\n * Check for end of current state (and the states before it).\n */\nstatic void check_state_ends(void)\n{\n  stateitem_T *cur_si;\n  int had_extend;\n\n  cur_si = &CUR_STATE(current_state.ga_len - 1);\n  for (;; ) {\n    if (cur_si->si_ends\n        && (cur_si->si_m_endpos.lnum < current_lnum\n            || (cur_si->si_m_endpos.lnum == current_lnum\n                && cur_si->si_m_endpos.col <= current_col))) {\n      /*\n       * If there is an end pattern group ID, highlight the end pattern\n       * now.  No need to pop the current item from the stack.\n       * Only do this if the end pattern continues beyond the current\n       * position.\n       */\n      if (cur_si->si_end_idx\n          && (cur_si->si_eoe_pos.lnum > current_lnum\n              || (cur_si->si_eoe_pos.lnum == current_lnum\n                  && cur_si->si_eoe_pos.col > current_col))) {\n        cur_si->si_idx = cur_si->si_end_idx;\n        cur_si->si_end_idx = 0;\n        cur_si->si_m_endpos = cur_si->si_eoe_pos;\n        cur_si->si_h_endpos = cur_si->si_eoe_pos;\n        cur_si->si_flags |= HL_MATCH;\n        cur_si->si_seqnr = next_seqnr++;\n        if (cur_si->si_flags & HL_CONCEALENDS)\n          cur_si->si_flags |= HL_CONCEAL;\n        update_si_attr(current_state.ga_len - 1);\n\n        /* nextgroup= should not match in the end pattern */\n        current_next_list = NULL;\n\n        /* what matches next may be different now, clear it */\n        next_match_idx = 0;\n        next_match_col = MAXCOL;\n        break;\n      } else {\n        /* handle next_list, unless at end of line and no \"skipnl\" or\n         * \"skipempty\" */\n        current_next_list = cur_si->si_next_list;\n        current_next_flags = cur_si->si_flags;\n        if (!(current_next_flags & (HL_SKIPNL | HL_SKIPEMPTY))\n            && syn_getcurline()[current_col] == NUL)\n          current_next_list = NULL;\n\n        /* When the ended item has \"extend\", another item with\n         * \"keepend\" now needs to check for its end. */\n        had_extend = (cur_si->si_flags & HL_EXTEND);\n\n        pop_current_state();\n\n        if (GA_EMPTY(&current_state))\n          break;\n\n        if (had_extend && keepend_level >= 0) {\n          syn_update_ends(false);\n          if (GA_EMPTY(&current_state)) {\n            break;\n          }\n        }\n\n        cur_si = &CUR_STATE(current_state.ga_len - 1);\n\n        /*\n         * Only for a region the search for the end continues after\n         * the end of the contained item.  If the contained match\n         * included the end-of-line, break here, the region continues.\n         * Don't do this when:\n         * - \"keepend\" is used for the contained item\n         * - not at the end of the line (could be end=\"x$\"me=e-1).\n         * - \"excludenl\" is used (HL_HAS_EOL won't be set)\n         */\n        if (cur_si->si_idx >= 0\n            && SYN_ITEMS(syn_block)[cur_si->si_idx].sp_type\n            == SPTYPE_START\n            && !(cur_si->si_flags & (HL_MATCH | HL_KEEPEND))) {\n          update_si_end(cur_si, (int)current_col, true);\n          check_keepend();\n          if ((current_next_flags & HL_HAS_EOL)\n              && keepend_level < 0\n              && syn_getcurline()[current_col] == NUL)\n            break;\n        }\n      }\n    } else\n      break;\n  }\n}\n\n/*\n * Update an entry in the current_state stack for a match or region.  This\n * fills in si_attr, si_next_list and si_cont_list.\n */\nstatic void update_si_attr(int idx)\n{\n  stateitem_T *sip = &CUR_STATE(idx);\n  synpat_T    *spp;\n\n  /* This should not happen... */\n  if (sip->si_idx < 0)\n    return;\n\n  spp = &(SYN_ITEMS(syn_block)[sip->si_idx]);\n  if (sip->si_flags & HL_MATCH)\n    sip->si_id = spp->sp_syn_match_id;\n  else\n    sip->si_id = spp->sp_syn.id;\n  sip->si_attr = syn_id2attr(sip->si_id);\n  sip->si_trans_id = sip->si_id;\n  if (sip->si_flags & HL_MATCH)\n    sip->si_cont_list = NULL;\n  else\n    sip->si_cont_list = spp->sp_cont_list;\n\n  /*\n   * For transparent items, take attr from outer item.\n   * Also take cont_list, if there is none.\n   * Don't do this for the matchgroup of a start or end pattern.\n   */\n  if ((spp->sp_flags & HL_TRANSP) && !(sip->si_flags & HL_MATCH)) {\n    if (idx == 0) {\n      sip->si_attr = 0;\n      sip->si_trans_id = 0;\n      if (sip->si_cont_list == NULL)\n        sip->si_cont_list = ID_LIST_ALL;\n    } else {\n      sip->si_attr = CUR_STATE(idx - 1).si_attr;\n      sip->si_trans_id = CUR_STATE(idx - 1).si_trans_id;\n      sip->si_h_startpos = CUR_STATE(idx - 1).si_h_startpos;\n      sip->si_h_endpos = CUR_STATE(idx - 1).si_h_endpos;\n      if (sip->si_cont_list == NULL) {\n        sip->si_flags |= HL_TRANS_CONT;\n        sip->si_cont_list = CUR_STATE(idx - 1).si_cont_list;\n      }\n    }\n  }\n}\n\n/*\n * Check the current stack for patterns with \"keepend\" flag.\n * Propagate the match-end to contained items, until a \"skipend\" item is found.\n */\nstatic void check_keepend(void)\n{\n  int i;\n  lpos_T maxpos;\n  lpos_T maxpos_h;\n  stateitem_T *sip;\n\n  /*\n   * This check can consume a lot of time; only do it from the level where\n   * there really is a keepend.\n   */\n  if (keepend_level < 0)\n    return;\n\n  /*\n   * Find the last index of an \"extend\" item.  \"keepend\" items before that\n   * won't do anything.  If there is no \"extend\" item \"i\" will be\n   * \"keepend_level\" and all \"keepend\" items will work normally.\n   */\n  for (i = current_state.ga_len - 1; i > keepend_level; --i)\n    if (CUR_STATE(i).si_flags & HL_EXTEND)\n      break;\n\n  maxpos.lnum = 0;\n  maxpos.col = 0;\n  maxpos_h.lnum = 0;\n  maxpos_h.col = 0;\n  for (; i < current_state.ga_len; ++i) {\n    sip = &CUR_STATE(i);\n    if (maxpos.lnum != 0) {\n      limit_pos_zero(&sip->si_m_endpos, &maxpos);\n      limit_pos_zero(&sip->si_h_endpos, &maxpos_h);\n      limit_pos_zero(&sip->si_eoe_pos, &maxpos);\n      sip->si_ends = TRUE;\n    }\n    if (sip->si_ends && (sip->si_flags & HL_KEEPEND)) {\n      if (maxpos.lnum == 0\n          || maxpos.lnum > sip->si_m_endpos.lnum\n          || (maxpos.lnum == sip->si_m_endpos.lnum\n              && maxpos.col > sip->si_m_endpos.col))\n        maxpos = sip->si_m_endpos;\n      if (maxpos_h.lnum == 0\n          || maxpos_h.lnum > sip->si_h_endpos.lnum\n          || (maxpos_h.lnum == sip->si_h_endpos.lnum\n              && maxpos_h.col > sip->si_h_endpos.col))\n        maxpos_h = sip->si_h_endpos;\n    }\n  }\n}\n\n/// Update an entry in the current_state stack for a start-skip-end pattern.\n/// This finds the end of the current item, if it's in the current line.\n///\n/// @param startcol  where to start searching for the end\n/// @param force     when true overrule a previous end\n///\n/// @return          the flags for the matched END.\nstatic void update_si_end(stateitem_T *sip, int startcol, bool force)\n{\n  lpos_T hl_endpos;\n  lpos_T end_endpos;\n\n  /* return quickly for a keyword */\n  if (sip->si_idx < 0)\n    return;\n\n  /* Don't update when it's already done.  Can be a match of an end pattern\n   * that started in a previous line.  Watch out: can also be a \"keepend\"\n   * from a containing item. */\n  if (!force && sip->si_m_endpos.lnum >= current_lnum)\n    return;\n\n  /*\n   * We need to find the end of the region.  It may continue in the next\n   * line.\n   */\n  int end_idx = 0;\n  lpos_T startpos = {\n    .lnum = current_lnum,\n    .col = startcol,\n  };\n  lpos_T endpos = { 0 };\n  find_endpos(sip->si_idx, &startpos, &endpos, &hl_endpos,\n      &(sip->si_flags), &end_endpos, &end_idx, sip->si_extmatch);\n\n  if (endpos.lnum == 0) {\n    /* No end pattern matched. */\n    if (SYN_ITEMS(syn_block)[sip->si_idx].sp_flags & HL_ONELINE) {\n      /* a \"oneline\" never continues in the next line */\n      sip->si_ends = TRUE;\n      sip->si_m_endpos.lnum = current_lnum;\n      sip->si_m_endpos.col = (colnr_T)STRLEN(syn_getcurline());\n    } else {\n      /* continues in the next line */\n      sip->si_ends = FALSE;\n      sip->si_m_endpos.lnum = 0;\n    }\n    sip->si_h_endpos = sip->si_m_endpos;\n  } else {\n    /* match within this line */\n    sip->si_m_endpos = endpos;\n    sip->si_h_endpos = hl_endpos;\n    sip->si_eoe_pos = end_endpos;\n    sip->si_ends = TRUE;\n    sip->si_end_idx = end_idx;\n  }\n}\n\n/*\n * Add a new state to the current state stack.\n * It is cleared and the index set to \"idx\".\n */\nstatic void push_current_state(int idx)\n{\n  stateitem_T *p = GA_APPEND_VIA_PTR(stateitem_T, &current_state);\n  memset(p, 0, sizeof(*p));\n  p->si_idx = idx;\n}\n\n/*\n * Remove a state from the current_state stack.\n */\nstatic void pop_current_state(void)\n{\n  if (!GA_EMPTY(&current_state)) {\n    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);\n    --current_state.ga_len;\n  }\n  /* after the end of a pattern, try matching a keyword or pattern */\n  next_match_idx = -1;\n\n  /* if first state with \"keepend\" is popped, reset keepend_level */\n  if (keepend_level >= current_state.ga_len)\n    keepend_level = -1;\n}\n\n/*\n * Find the end of a start/skip/end syntax region after \"startpos\".\n * Only checks one line.\n * Also handles a match item that continued from a previous line.\n * If not found, the syntax item continues in the next line.  m_endpos->lnum\n * will be 0.\n * If found, the end of the region and the end of the highlighting is\n * computed.\n */\nstatic void\nfind_endpos(\n    int idx,                    // index of the pattern\n    lpos_T *startpos,           // where to start looking for an END match\n    lpos_T *m_endpos,           // return: end of match\n    lpos_T *hl_endpos,          // return: end of highlighting\n    long *flagsp,               // return: flags of matching END\n    lpos_T *end_endpos,         // return: end of end pattern match\n    int *end_idx,               // return: group ID for end pat. match, or 0\n    reg_extmatch_T *start_ext   // submatches from the start pattern\n)\n{\n  colnr_T matchcol;\n  synpat_T    *spp, *spp_skip;\n  int start_idx;\n  int best_idx;\n  regmmatch_T regmatch;\n  regmmatch_T best_regmatch;        /* startpos/endpos of best match */\n  lpos_T pos;\n  char_u      *line;\n  bool had_match = false;\n  char_u buf_chartab[32];  // chartab array for syn option iskeyword\n\n  /* just in case we are invoked for a keyword */\n  if (idx < 0)\n    return;\n\n  /*\n   * Check for being called with a START pattern.\n   * Can happen with a match that continues to the next line, because it\n   * contained a region.\n   */\n  spp = &(SYN_ITEMS(syn_block)[idx]);\n  if (spp->sp_type != SPTYPE_START) {\n    *hl_endpos = *startpos;\n    return;\n  }\n\n  /*\n   * Find the SKIP or first END pattern after the last START pattern.\n   */\n  for (;; ) {\n    spp = &(SYN_ITEMS(syn_block)[idx]);\n    if (spp->sp_type != SPTYPE_START)\n      break;\n    ++idx;\n  }\n\n  /*\n   *\tLookup the SKIP pattern (if present)\n   */\n  if (spp->sp_type == SPTYPE_SKIP) {\n    spp_skip = spp;\n    ++idx;\n  } else\n    spp_skip = NULL;\n\n  /* Setup external matches for syn_regexec(). */\n  unref_extmatch(re_extmatch_in);\n  re_extmatch_in = ref_extmatch(start_ext);\n\n  matchcol = startpos->col;     // start looking for a match at sstart\n  start_idx = idx;              // remember the first END pattern.\n  best_regmatch.startpos[0].col = 0;            // avoid compiler warning\n\n  // use syntax iskeyword option\n  save_chartab(buf_chartab);\n\n  for (;; ) {\n    /*\n     * Find end pattern that matches first after \"matchcol\".\n     */\n    best_idx = -1;\n    for (idx = start_idx; idx < syn_block->b_syn_patterns.ga_len; ++idx) {\n      int lc_col = matchcol;\n\n      spp = &(SYN_ITEMS(syn_block)[idx]);\n      if (spp->sp_type != SPTYPE_END)           /* past last END pattern */\n        break;\n      lc_col -= spp->sp_offsets[SPO_LC_OFF];\n      if (lc_col < 0)\n        lc_col = 0;\n\n      regmatch.rmm_ic = spp->sp_ic;\n      regmatch.regprog = spp->sp_prog;\n      int r = syn_regexec(&regmatch, startpos->lnum, lc_col,\n                          IF_SYN_TIME(&spp->sp_time));\n      spp->sp_prog = regmatch.regprog;\n      if (r) {\n        if (best_idx == -1 || regmatch.startpos[0].col\n            < best_regmatch.startpos[0].col) {\n          best_idx = idx;\n          best_regmatch.startpos[0] = regmatch.startpos[0];\n          best_regmatch.endpos[0] = regmatch.endpos[0];\n        }\n      }\n    }\n\n    /*\n     * If all end patterns have been tried, and there is no match, the\n     * item continues until end-of-line.\n     */\n    if (best_idx == -1)\n      break;\n\n    /*\n     * If the skip pattern matches before the end pattern,\n     * continue searching after the skip pattern.\n     */\n    if (spp_skip != NULL) {\n      int lc_col = matchcol - spp_skip->sp_offsets[SPO_LC_OFF];\n\n      if (lc_col < 0)\n        lc_col = 0;\n      regmatch.rmm_ic = spp_skip->sp_ic;\n      regmatch.regprog = spp_skip->sp_prog;\n      int r = syn_regexec(&regmatch, startpos->lnum, lc_col,\n                          IF_SYN_TIME(&spp_skip->sp_time));\n      spp_skip->sp_prog = regmatch.regprog;\n      if (r && regmatch.startpos[0].col <= best_regmatch.startpos[0].col) {\n        // Add offset to skip pattern match\n        syn_add_end_off(&pos, &regmatch, spp_skip, SPO_ME_OFF, 1);\n\n        // If the skip pattern goes on to the next line, there is no\n        // match with an end pattern in this line.\n        if (pos.lnum > startpos->lnum) {\n          break;\n        }\n\n        line = ml_get_buf(syn_buf, startpos->lnum, false);\n        int line_len = (int)STRLEN(line);\n\n        // take care of an empty match or negative offset\n        if (pos.col <= matchcol) {\n          matchcol++;\n        } else if (pos.col <= regmatch.endpos[0].col) {\n          matchcol = pos.col;\n        } else {\n          // Be careful not to jump over the NUL at the end-of-line\n          for (matchcol = regmatch.endpos[0].col;\n               matchcol < line_len && matchcol < pos.col;\n               matchcol++) {\n          }\n        }\n\n        // if the skip pattern includes end-of-line, break here\n        if (matchcol >= line_len) {\n          break;\n        }\n\n        continue;  // start with first end pattern again\n      }\n    }\n\n    /*\n     * Match from start pattern to end pattern.\n     * Correct for match and highlight offset of end pattern.\n     */\n    spp = &(SYN_ITEMS(syn_block)[best_idx]);\n    syn_add_end_off(m_endpos, &best_regmatch, spp, SPO_ME_OFF, 1);\n    /* can't end before the start */\n    if (m_endpos->lnum == startpos->lnum && m_endpos->col < startpos->col)\n      m_endpos->col = startpos->col;\n\n    syn_add_end_off(end_endpos, &best_regmatch, spp, SPO_HE_OFF, 1);\n    /* can't end before the start */\n    if (end_endpos->lnum == startpos->lnum\n        && end_endpos->col < startpos->col)\n      end_endpos->col = startpos->col;\n    /* can't end after the match */\n    limit_pos(end_endpos, m_endpos);\n\n    /*\n     * If the end group is highlighted differently, adjust the pointers.\n     */\n    if (spp->sp_syn_match_id != spp->sp_syn.id && spp->sp_syn_match_id != 0) {\n      *end_idx = best_idx;\n      if (spp->sp_off_flags & (1 << (SPO_RE_OFF + SPO_COUNT))) {\n        hl_endpos->lnum = best_regmatch.endpos[0].lnum;\n        hl_endpos->col = best_regmatch.endpos[0].col;\n      } else {\n        hl_endpos->lnum = best_regmatch.startpos[0].lnum;\n        hl_endpos->col = best_regmatch.startpos[0].col;\n      }\n      hl_endpos->col += spp->sp_offsets[SPO_RE_OFF];\n\n      /* can't end before the start */\n      if (hl_endpos->lnum == startpos->lnum\n          && hl_endpos->col < startpos->col)\n        hl_endpos->col = startpos->col;\n      limit_pos(hl_endpos, m_endpos);\n\n      /* now the match ends where the highlighting ends, it is turned\n       * into the matchgroup for the end */\n      *m_endpos = *hl_endpos;\n    } else {\n      *end_idx = 0;\n      *hl_endpos = *end_endpos;\n    }\n\n    *flagsp = spp->sp_flags;\n\n    had_match = true;\n    break;\n  }\n\n  /* no match for an END pattern in this line */\n  if (!had_match)\n    m_endpos->lnum = 0;\n\n  restore_chartab(buf_chartab);\n\n  /* Remove external matches. */\n  unref_extmatch(re_extmatch_in);\n  re_extmatch_in = NULL;\n}\n\n/*\n * Limit \"pos\" not to be after \"limit\".\n */\nstatic void limit_pos(lpos_T *pos, lpos_T *limit)\n{\n  if (pos->lnum > limit->lnum)\n    *pos = *limit;\n  else if (pos->lnum == limit->lnum && pos->col > limit->col)\n    pos->col = limit->col;\n}\n\n/*\n * Limit \"pos\" not to be after \"limit\", unless pos->lnum is zero.\n */\nstatic void limit_pos_zero(lpos_T *pos, lpos_T *limit)\n{\n  if (pos->lnum == 0)\n    *pos = *limit;\n  else\n    limit_pos(pos, limit);\n}\n\n/*\n * Add offset to matched text for end of match or highlight.\n */\nstatic void\nsyn_add_end_off(\n    lpos_T *result,           // returned position\n    regmmatch_T *regmatch,    // start/end of match\n    synpat_T *spp,            // matched pattern\n    int idx,                  // index of offset\n    int extra                 // extra chars for offset to start\n)\n{\n  int col;\n  int off;\n  char_u      *base;\n  char_u      *p;\n\n  if (spp->sp_off_flags & (1 << idx)) {\n    result->lnum = regmatch->startpos[0].lnum;\n    col = regmatch->startpos[0].col;\n    off = spp->sp_offsets[idx] + extra;\n  } else {\n    result->lnum = regmatch->endpos[0].lnum;\n    col = regmatch->endpos[0].col;\n    off = spp->sp_offsets[idx];\n  }\n  // Don't go past the end of the line.  Matters for \"rs=e+2\" when there\n  // is a matchgroup. Watch out for match with last NL in the buffer.\n  if (result->lnum > syn_buf->b_ml.ml_line_count) {\n    col = 0;\n  } else if (off != 0) {\n    base = ml_get_buf(syn_buf, result->lnum, false);\n    p = base + col;\n    if (off > 0) {\n      while (off-- > 0 && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n    } else {\n      while (off++ < 0 && base < p) {\n        MB_PTR_BACK(base, p);\n      }\n    }\n    col = (int)(p - base);\n  }\n  result->col = col;\n}\n\n/*\n * Add offset to matched text for start of match or highlight.\n * Avoid resulting column to become negative.\n */\nstatic void\nsyn_add_start_off(\n    lpos_T *result,           // returned position\n    regmmatch_T *regmatch,    // start/end of match\n    synpat_T *spp,\n    int idx,\n    int extra                 // extra chars for offset to end\n)\n{\n  int col;\n  int off;\n  char_u      *base;\n  char_u      *p;\n\n  if (spp->sp_off_flags & (1 << (idx + SPO_COUNT))) {\n    result->lnum = regmatch->endpos[0].lnum;\n    col = regmatch->endpos[0].col;\n    off = spp->sp_offsets[idx] + extra;\n  } else {\n    result->lnum = regmatch->startpos[0].lnum;\n    col = regmatch->startpos[0].col;\n    off = spp->sp_offsets[idx];\n  }\n  if (result->lnum > syn_buf->b_ml.ml_line_count) {\n    /* a \"\\n\" at the end of the pattern may take us below the last line */\n    result->lnum = syn_buf->b_ml.ml_line_count;\n    col = (int)STRLEN(ml_get_buf(syn_buf, result->lnum, false));\n  }\n  if (off != 0) {\n    base = ml_get_buf(syn_buf, result->lnum, false);\n    p = base + col;\n    if (off > 0) {\n      while (off-- && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n    } else {\n      while (off++ && base < p) {\n        MB_PTR_BACK(base, p);\n      }\n    }\n    col = (int)(p - base);\n  }\n  result->col = col;\n}\n\n/*\n * Get current line in syntax buffer.\n */\nstatic char_u *syn_getcurline(void)\n{\n  return ml_get_buf(syn_buf, current_lnum, false);\n}\n\n/*\n * Call vim_regexec() to find a match with \"rmp\" in \"syn_buf\".\n * Returns TRUE when there is a match.\n */\nstatic int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T *st)\n{\n  int r;\n  int timed_out = 0;\n  proftime_T pt;\n  const bool l_syn_time_on = syn_time_on;\n\n  if (l_syn_time_on) {\n    pt = profile_start();\n  }\n\n  if (rmp->regprog == NULL) {\n    // This can happen if a previous call to vim_regexec_multi() tried to\n    // use the NFA engine, which resulted in NFA_TOO_EXPENSIVE, and\n    // compiling the pattern with the other engine fails.\n    return false;\n  }\n\n  rmp->rmm_maxcol = syn_buf->b_p_smc;\n  r = vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col,\n                        syn_tm, &timed_out);\n\n  if (l_syn_time_on) {\n    pt = profile_end(pt);\n    st->total = profile_add(st->total, pt);\n    if (profile_cmp(pt, st->slowest) < 0) {\n      st->slowest = pt;\n    }\n    ++st->count;\n    if (r > 0)\n      ++st->match;\n  }\n  if (timed_out && !syn_win->w_s->b_syn_slow) {\n    syn_win->w_s->b_syn_slow = true;\n    MSG(_(\"'redrawtime' exceeded, syntax highlighting disabled\"));\n  }\n\n  if (r > 0) {\n    rmp->startpos[0].lnum += lnum;\n    rmp->endpos[0].lnum += lnum;\n    return TRUE;\n  }\n  return FALSE;\n}\n\n/*\n * Check one position in a line for a matching keyword.\n * The caller must check if a keyword can start at startcol.\n * Return its ID if found, 0 otherwise.\n */\nstatic int check_keyword_id(\n    char_u *const line,\n    const int startcol,           // position in line to check for keyword\n    int *const endcolp,           // return: character after found keyword\n    long *const flagsp,           // return: flags of matching keyword\n    int16_t **const next_listp,   // return: next_list of matching keyword\n    stateitem_T *const cur_si,    // item at the top of the stack\n    int *const ccharp             // conceal substitution char\n)\n{\n  // Find first character after the keyword.  First character was already\n  // checked.\n  char_u *const kwp = line + startcol;\n  int kwlen = 0;\n  do {\n    kwlen += utfc_ptr2len(kwp + kwlen);\n  } while (vim_iswordp_buf(kwp + kwlen, syn_buf));\n\n  if (kwlen > MAXKEYWLEN) {\n    return 0;\n  }\n\n  // Must make a copy of the keyword, so we can add a NUL and make it\n  // lowercase.\n  char_u keyword[MAXKEYWLEN + 1];         // assume max. keyword len is 80\n  STRLCPY(keyword, kwp, kwlen + 1);\n\n  keyentry_T *kp = NULL;\n\n  // matching case\n  if (syn_block->b_keywtab.ht_used != 0) {\n    kp = match_keyword(keyword, &syn_block->b_keywtab, cur_si);\n  }\n\n  // ignoring case\n  if (kp == NULL && syn_block->b_keywtab_ic.ht_used != 0) {\n    str_foldcase(kwp, kwlen, keyword, MAXKEYWLEN + 1);\n    kp = match_keyword(keyword, &syn_block->b_keywtab_ic, cur_si);\n  }\n\n  if (kp != NULL) {\n    *endcolp = startcol + kwlen;\n    *flagsp = kp->flags;\n    *next_listp = kp->next_list;\n    *ccharp = kp->k_char;\n    return kp->k_syn.id;\n  }\n\n  return 0;\n}\n\n/// Find keywords that match.  There can be several with different\n/// attributes.\n/// When current_next_list is non-zero accept only that group, otherwise:\n///  Accept a not-contained keyword at toplevel.\n///  Accept a keyword at other levels only if it is in the contains list.\nstatic keyentry_T *match_keyword(char_u *keyword, hashtab_T *ht,\n                                 stateitem_T *cur_si)\n{\n  hashitem_T *hi = hash_find(ht, keyword);\n  if (!HASHITEM_EMPTY(hi))\n    for (keyentry_T *kp = HI2KE(hi); kp != NULL; kp = kp->ke_next) {\n      if (current_next_list != 0\n          ? in_id_list(NULL, current_next_list, &kp->k_syn, 0)\n          : (cur_si == NULL\n            ? !(kp->flags & HL_CONTAINED)\n            : in_id_list(cur_si, cur_si->si_cont_list,\n                         &kp->k_syn, kp->flags & HL_CONTAINED))) {\n        return kp;\n      }\n    }\n  return NULL;\n}\n\n/*\n * Handle \":syntax conceal\" command.\n */\nstatic void syn_cmd_conceal(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *next;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  next = skiptowhite(arg);\n  if (*arg == NUL) {\n    if (curwin->w_s->b_syn_conceal) {\n      MSG(_(\"syntax conceal on\"));\n    } else {\n      MSG(_(\"syntax conceal off\"));\n    }\n  } else if (STRNICMP(arg, \"on\", 2) == 0 && next - arg == 2) {\n    curwin->w_s->b_syn_conceal = true;\n  } else if (STRNICMP(arg, \"off\", 3) == 0 && next - arg == 3) {\n    curwin->w_s->b_syn_conceal = false;\n  } else {\n    EMSG2(_(e_illegal_arg), arg);\n  }\n}\n\n/*\n * Handle \":syntax case\" command.\n */\nstatic void syn_cmd_case(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *next;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  next = skiptowhite(arg);\n  if (*arg == NUL) {\n    if (curwin->w_s->b_syn_ic) {\n      MSG(_(\"syntax case ignore\"));\n    } else {\n      MSG(_(\"syntax case match\"));\n    }\n  } else if (STRNICMP(arg, \"match\", 5) == 0 && next - arg == 5) {\n    curwin->w_s->b_syn_ic = false;\n  } else if (STRNICMP(arg, \"ignore\", 6) == 0 && next - arg == 6) {\n    curwin->w_s->b_syn_ic = true;\n  } else {\n    EMSG2(_(e_illegal_arg), arg);\n  }\n}\n\n/// Handle \":syntax foldlevel\" command.\nstatic void syn_cmd_foldlevel(exarg_T *eap, int syncing)\n{\n  char_u *arg = eap->arg;\n  char_u *arg_end;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  if (*arg == NUL) {\n    switch (curwin->w_s->b_syn_foldlevel) {\n    case SYNFLD_START:   MSG(_(\"syntax foldlevel start\"));   break;\n    case SYNFLD_MINIMUM: MSG(_(\"syntax foldlevel minimum\")); break;\n    default: break;\n    }\n    return;\n  }\n\n  arg_end = skiptowhite(arg);\n  if (STRNICMP(arg, \"start\", 5) == 0 && arg_end - arg == 5) {\n    curwin->w_s->b_syn_foldlevel = SYNFLD_START;\n  } else if (STRNICMP(arg, \"minimum\", 7) == 0 && arg_end - arg == 7) {\n    curwin->w_s->b_syn_foldlevel = SYNFLD_MINIMUM;\n  } else {\n    EMSG2(_(e_illegal_arg), arg);\n    return;\n  }\n\n  arg = skipwhite(arg_end);\n  if (*arg != NUL) {\n    EMSG2(_(e_illegal_arg), arg);\n  }\n}\n\n/*\n * Handle \":syntax spell\" command.\n */\nstatic void syn_cmd_spell(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *next;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  next = skiptowhite(arg);\n  if (*arg == NUL) {\n    if (curwin->w_s->b_syn_spell == SYNSPL_TOP) {\n      MSG(_(\"syntax spell toplevel\"));\n    } else if (curwin->w_s->b_syn_spell == SYNSPL_NOTOP) {\n      MSG(_(\"syntax spell notoplevel\"));\n    } else {\n      MSG(_(\"syntax spell default\"));\n    }\n  } else if (STRNICMP(arg, \"toplevel\", 8) == 0 && next - arg == 8) {\n    curwin->w_s->b_syn_spell = SYNSPL_TOP;\n  } else if (STRNICMP(arg, \"notoplevel\", 10) == 0 && next - arg == 10) {\n    curwin->w_s->b_syn_spell = SYNSPL_NOTOP;\n  } else if (STRNICMP(arg, \"default\", 7) == 0 && next - arg == 7) {\n    curwin->w_s->b_syn_spell = SYNSPL_DEFAULT;\n  } else {\n    EMSG2(_(e_illegal_arg), arg);\n    return;\n  }\n\n  // assume spell checking changed, force a redraw\n  redraw_later(curwin, NOT_VALID);\n}\n\n/// Handle \":syntax iskeyword\" command.\nstatic void syn_cmd_iskeyword(exarg_T *eap, int syncing)\n{\n  char_u *arg = eap->arg;\n  char_u save_chartab[32];\n  char_u *save_isk;\n\n  if (eap->skip) {\n    return;\n  }\n\n  arg = skipwhite(arg);\n  if (*arg == NUL) {\n    MSG_PUTS(\"\\n\");\n    if (curwin->w_s->b_syn_isk != empty_option) {\n      MSG_PUTS(_(\"syntax iskeyword \"));\n      msg_outtrans(curwin->w_s->b_syn_isk);\n    } else {\n      msg_outtrans((char_u *)_(\"syntax iskeyword not set\"));\n    }\n  } else {\n    if (STRNICMP(arg, \"clear\", 5) == 0) {\n      memmove(curwin->w_s->b_syn_chartab, curbuf->b_chartab, (size_t)32);\n      clear_string_option(&curwin->w_s->b_syn_isk);\n    } else {\n      memmove(save_chartab, curbuf->b_chartab, (size_t)32);\n      save_isk = curbuf->b_p_isk;\n      curbuf->b_p_isk = vim_strsave(arg);\n\n      buf_init_chartab(curbuf, false);\n      memmove(curwin->w_s->b_syn_chartab, curbuf->b_chartab, (size_t)32);\n      memmove(curbuf->b_chartab, save_chartab, (size_t)32);\n      clear_string_option(&curwin->w_s->b_syn_isk);\n      curwin->w_s->b_syn_isk = curbuf->b_p_isk;\n      curbuf->b_p_isk = save_isk;\n    }\n  }\n  redraw_later(curwin, NOT_VALID);\n}\n\n/*\n * Clear all syntax info for one buffer.\n */\nvoid syntax_clear(synblock_T *block)\n{\n  block->b_syn_error = false;           // clear previous error\n  block->b_syn_slow = false;            // clear previous timeout\n  block->b_syn_ic = false;              // Use case, by default\n  block->b_syn_foldlevel = SYNFLD_START;\n  block->b_syn_spell = SYNSPL_DEFAULT;  // default spell checking\n  block->b_syn_containedin = false;\n  block->b_syn_conceal = false;\n\n  /* free the keywords */\n  clear_keywtab(&block->b_keywtab);\n  clear_keywtab(&block->b_keywtab_ic);\n\n  /* free the syntax patterns */\n  for (int i = block->b_syn_patterns.ga_len; --i >= 0; ) {\n    syn_clear_pattern(block, i);\n  }\n  ga_clear(&block->b_syn_patterns);\n\n  /* free the syntax clusters */\n  for (int i = block->b_syn_clusters.ga_len; --i >= 0; ) {\n    syn_clear_cluster(block, i);\n  }\n  ga_clear(&block->b_syn_clusters);\n  block->b_spell_cluster_id = 0;\n  block->b_nospell_cluster_id = 0;\n\n  block->b_syn_sync_flags = 0;\n  block->b_syn_sync_minlines = 0;\n  block->b_syn_sync_maxlines = 0;\n  block->b_syn_sync_linebreaks = 0;\n\n  vim_regfree(block->b_syn_linecont_prog);\n  block->b_syn_linecont_prog = NULL;\n  XFREE_CLEAR(block->b_syn_linecont_pat);\n  block->b_syn_folditems = 0;\n  clear_string_option(&block->b_syn_isk);\n\n  /* free the stored states */\n  syn_stack_free_all(block);\n  invalidate_current_state();\n\n  /* Reset the counter for \":syn include\" */\n  running_syn_inc_tag = 0;\n}\n\n/*\n * Get rid of ownsyntax for window \"wp\".\n */\nvoid reset_synblock(win_T *wp)\n{\n  if (wp->w_s != &wp->w_buffer->b_s) {\n    syntax_clear(wp->w_s);\n    xfree(wp->w_s);\n    wp->w_s = &wp->w_buffer->b_s;\n  }\n}\n\n/*\n * Clear syncing info for one buffer.\n */\nstatic void syntax_sync_clear(void)\n{\n  /* free the syntax patterns */\n  for (int i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; ) {\n    if (SYN_ITEMS(curwin->w_s)[i].sp_syncing) {\n      syn_remove_pattern(curwin->w_s, i);\n    }\n  }\n\n  curwin->w_s->b_syn_sync_flags = 0;\n  curwin->w_s->b_syn_sync_minlines = 0;\n  curwin->w_s->b_syn_sync_maxlines = 0;\n  curwin->w_s->b_syn_sync_linebreaks = 0;\n\n  vim_regfree(curwin->w_s->b_syn_linecont_prog);\n  curwin->w_s->b_syn_linecont_prog = NULL;\n  XFREE_CLEAR(curwin->w_s->b_syn_linecont_pat);\n  clear_string_option(&curwin->w_s->b_syn_isk);\n\n  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */\n}\n\n/*\n * Remove one pattern from the buffer's pattern list.\n */\nstatic void syn_remove_pattern(synblock_T *block, int idx)\n{\n  synpat_T    *spp;\n\n  spp = &(SYN_ITEMS(block)[idx]);\n  if (spp->sp_flags & HL_FOLD)\n    --block->b_syn_folditems;\n  syn_clear_pattern(block, idx);\n  memmove(spp, spp + 1,\n      sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));\n  --block->b_syn_patterns.ga_len;\n}\n\n/*\n * Clear and free one syntax pattern.  When clearing all, must be called from\n * last to first!\n */\nstatic void syn_clear_pattern(synblock_T *block, int i)\n{\n  xfree(SYN_ITEMS(block)[i].sp_pattern);\n  vim_regfree(SYN_ITEMS(block)[i].sp_prog);\n  /* Only free sp_cont_list and sp_next_list of first start pattern */\n  if (i == 0 || SYN_ITEMS(block)[i - 1].sp_type != SPTYPE_START) {\n    xfree(SYN_ITEMS(block)[i].sp_cont_list);\n    xfree(SYN_ITEMS(block)[i].sp_next_list);\n    xfree(SYN_ITEMS(block)[i].sp_syn.cont_in_list);\n  }\n}\n\n/*\n * Clear and free one syntax cluster.\n */\nstatic void syn_clear_cluster(synblock_T *block, int i)\n{\n  xfree(SYN_CLSTR(block)[i].scl_name);\n  xfree(SYN_CLSTR(block)[i].scl_name_u);\n  xfree(SYN_CLSTR(block)[i].scl_list);\n}\n\n/*\n * Handle \":syntax clear\" command.\n */\nstatic void syn_cmd_clear(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *arg_end;\n  int id;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  /*\n   * We have to disable this within \":syn include @group filename\",\n   * because otherwise @group would get deleted.\n   * Only required for Vim 5.x syntax files, 6.0 ones don't contain \":syn\n   * clear\".\n   */\n  if (curwin->w_s->b_syn_topgrp != 0)\n    return;\n\n  if (ends_excmd(*arg)) {\n    /*\n     * No argument: Clear all syntax items.\n     */\n    if (syncing)\n      syntax_sync_clear();\n    else {\n      syntax_clear(curwin->w_s);\n      if (curwin->w_s == &curwin->w_buffer->b_s) {\n        do_unlet(S_LEN(\"b:current_syntax\"), true);\n      }\n      do_unlet(S_LEN(\"w:current_syntax\"), true);\n    }\n  } else {\n    /*\n     * Clear the group IDs that are in the argument.\n     */\n    while (!ends_excmd(*arg)) {\n      arg_end = skiptowhite(arg);\n      if (*arg == '@') {\n        id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));\n        if (id == 0) {\n          EMSG2(_(\"E391: No such syntax cluster: %s\"), arg);\n          break;\n        } else {\n          // We can't physically delete a cluster without changing\n          // the IDs of other clusters, so we do the next best thing\n          // and make it empty.\n          int scl_id = id - SYNID_CLUSTER;\n\n          XFREE_CLEAR(SYN_CLSTR(curwin->w_s)[scl_id].scl_list);\n        }\n      } else {\n        id = syn_name2id_len(arg, (int)(arg_end - arg));\n        if (id == 0) {\n          EMSG2(_(e_nogroup), arg);\n          break;\n        } else\n          syn_clear_one(id, syncing);\n      }\n      arg = skipwhite(arg_end);\n    }\n  }\n  redraw_curbuf_later(SOME_VALID);\n  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */\n}\n\n/*\n * Clear one syntax group for the current buffer.\n */\nstatic void syn_clear_one(const int id, const bool syncing)\n{\n  synpat_T    *spp;\n\n  /* Clear keywords only when not \":syn sync clear group-name\" */\n  if (!syncing) {\n    syn_clear_keyword(id, &curwin->w_s->b_keywtab);\n    syn_clear_keyword(id, &curwin->w_s->b_keywtab_ic);\n  }\n\n  /* clear the patterns for \"id\" */\n  for (int idx = curwin->w_s->b_syn_patterns.ga_len; --idx >= 0; ) {\n    spp = &(SYN_ITEMS(curwin->w_s)[idx]);\n    if (spp->sp_syn.id != id || spp->sp_syncing != syncing)\n      continue;\n    syn_remove_pattern(curwin->w_s, idx);\n  }\n}\n\n/*\n * Handle \":syntax on\" command.\n */\nstatic void syn_cmd_on(exarg_T *eap, int syncing)\n{\n  syn_cmd_onoff(eap, \"syntax\");\n}\n\n/*\n * Handle \":syntax reset\" command.\n * It actually resets highlighting, not syntax.\n */\nstatic void syn_cmd_reset(exarg_T *eap, int syncing)\n{\n  eap->nextcmd = check_nextcmd(eap->arg);\n  if (!eap->skip) {\n    init_highlight(true, true);\n  }\n}\n\n/*\n * Handle \":syntax manual\" command.\n */\nstatic void syn_cmd_manual(exarg_T *eap, int syncing)\n{\n  syn_cmd_onoff(eap, \"manual\");\n}\n\n/*\n * Handle \":syntax off\" command.\n */\nstatic void syn_cmd_off(exarg_T *eap, int syncing)\n{\n  syn_cmd_onoff(eap, \"nosyntax\");\n}\n\nstatic void syn_cmd_onoff(exarg_T *eap, char *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  eap->nextcmd = check_nextcmd(eap->arg);\n  if (!eap->skip) {\n    did_syntax_onoff = true;\n    char buf[100];\n    memcpy(buf, \"so \", 4);\n    vim_snprintf(buf + 3, sizeof(buf) - 3, SYNTAX_FNAME, name);\n    do_cmdline_cmd(buf);\n  }\n}\n\nvoid syn_maybe_enable(void)\n{\n  if (!did_syntax_onoff) {\n    exarg_T ea;\n    ea.arg = (char_u *)\"\";\n    ea.skip = false;\n    syn_cmd_on(&ea, false);\n  }\n}\n\n/*\n * Handle \":syntax [list]\" command: list current syntax words.\n */\nstatic void\nsyn_cmd_list(\n    exarg_T *eap,\n    int syncing                        /* when TRUE: list syncing items */\n)\n{\n  char_u      *arg = eap->arg;\n  char_u      *arg_end;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  if (!syntax_present(curwin)) {\n    MSG(_(msg_no_items));\n    return;\n  }\n\n  if (syncing) {\n    if (curwin->w_s->b_syn_sync_flags & SF_CCOMMENT) {\n      MSG_PUTS(_(\"syncing on C-style comments\"));\n      syn_lines_msg();\n      syn_match_msg();\n      return;\n    } else if (!(curwin->w_s->b_syn_sync_flags & SF_MATCH))   {\n      if (curwin->w_s->b_syn_sync_minlines == 0) {\n        MSG_PUTS(_(\"no syncing\"));\n      } else {\n        if (curwin->w_s->b_syn_sync_minlines == MAXLNUM) {\n          MSG_PUTS(_(\"syncing starts at the first line\"));\n        } else {\n          MSG_PUTS(_(\"syncing starts \"));\n          msg_outnum(curwin->w_s->b_syn_sync_minlines);\n          MSG_PUTS(_(\" lines before top line\"));\n        }\n        syn_match_msg();\n      }\n      return;\n    }\n    MSG_PUTS_TITLE(_(\"\\n--- Syntax sync items ---\"));\n    if (curwin->w_s->b_syn_sync_minlines > 0\n        || curwin->w_s->b_syn_sync_maxlines > 0\n        || curwin->w_s->b_syn_sync_linebreaks > 0) {\n      MSG_PUTS(_(\"\\nsyncing on items\"));\n      syn_lines_msg();\n      syn_match_msg();\n    }\n  } else\n    MSG_PUTS_TITLE(_(\"\\n--- Syntax items ---\"));\n  if (ends_excmd(*arg)) {\n    /*\n     * No argument: List all group IDs and all syntax clusters.\n     */\n    for (int id = 1; id <= highlight_ga.ga_len && !got_int; id++) {\n      syn_list_one(id, syncing, false);\n    }\n    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {\n      syn_list_cluster(id);\n    }\n  } else {\n    /*\n     * List the group IDs and syntax clusters that are in the argument.\n     */\n    while (!ends_excmd(*arg) && !got_int) {\n      arg_end = skiptowhite(arg);\n      if (*arg == '@') {\n        int id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));\n        if (id == 0)\n          EMSG2(_(\"E392: No such syntax cluster: %s\"), arg);\n        else\n          syn_list_cluster(id - SYNID_CLUSTER);\n      } else {\n        int id = syn_name2id_len(arg, (int)(arg_end - arg));\n        if (id == 0) {\n          EMSG2(_(e_nogroup), arg);\n        } else {\n          syn_list_one(id, syncing, true);\n        }\n      }\n      arg = skipwhite(arg_end);\n    }\n  }\n  eap->nextcmd = check_nextcmd(arg);\n}\n\nstatic void syn_lines_msg(void)\n{\n  if (curwin->w_s->b_syn_sync_maxlines > 0\n      || curwin->w_s->b_syn_sync_minlines > 0) {\n    MSG_PUTS(\"; \");\n    if (curwin->w_s->b_syn_sync_minlines == MAXLNUM) {\n      MSG_PUTS(_(\"from the first line\"));\n    } else {\n      if (curwin->w_s->b_syn_sync_minlines > 0) {\n        MSG_PUTS(_(\"minimal \"));\n        msg_outnum(curwin->w_s->b_syn_sync_minlines);\n        if (curwin->w_s->b_syn_sync_maxlines) {\n          MSG_PUTS(\", \");\n        }\n      }\n      if (curwin->w_s->b_syn_sync_maxlines > 0) {\n        MSG_PUTS(_(\"maximal \"));\n        msg_outnum(curwin->w_s->b_syn_sync_maxlines);\n      }\n      MSG_PUTS(_(\" lines before top line\"));\n    }\n  }\n}\n\nstatic void syn_match_msg(void)\n{\n  if (curwin->w_s->b_syn_sync_linebreaks > 0) {\n    MSG_PUTS(_(\"; match \"));\n    msg_outnum(curwin->w_s->b_syn_sync_linebreaks);\n    MSG_PUTS(_(\" line breaks\"));\n  }\n}\n\nstatic int last_matchgroup;\n\n\n/*\n * List one syntax item, for \":syntax\" or \"syntax list syntax_name\".\n */\nstatic void\nsyn_list_one(\n    const int id,\n    const bool syncing,                 // when true: list syncing items\n    const bool link_only                // when true; list link-only too\n)\n{\n  bool did_header = false;\n  static struct name_list namelist1[] =\n  {\n    {HL_DISPLAY, \"display\"},\n    {HL_CONTAINED, \"contained\"},\n    {HL_ONELINE, \"oneline\"},\n    {HL_KEEPEND, \"keepend\"},\n    {HL_EXTEND, \"extend\"},\n    {HL_EXCLUDENL, \"excludenl\"},\n    {HL_TRANSP, \"transparent\"},\n    {HL_FOLD, \"fold\"},\n    {HL_CONCEAL, \"conceal\"},\n    {HL_CONCEALENDS, \"concealends\"},\n    {0, NULL}\n  };\n  static struct name_list namelist2[] =\n  {\n    {HL_SKIPWHITE, \"skipwhite\"},\n    {HL_SKIPNL, \"skipnl\"},\n    {HL_SKIPEMPTY, \"skipempty\"},\n    {0, NULL}\n  };\n\n  const int attr = HL_ATTR(HLF_D);      // highlight like directories\n\n  // list the keywords for \"id\"\n  if (!syncing) {\n    did_header = syn_list_keywords(id, &curwin->w_s->b_keywtab, false, attr);\n    did_header = syn_list_keywords(id, &curwin->w_s->b_keywtab_ic,\n                                   did_header, attr);\n  }\n\n  // list the patterns for \"id\"\n  for (int idx = 0;\n       idx < curwin->w_s->b_syn_patterns.ga_len && !got_int;\n       idx++) {\n    const synpat_T *const spp = &(SYN_ITEMS(curwin->w_s)[idx]);\n    if (spp->sp_syn.id != id || spp->sp_syncing != syncing) {\n      continue;\n    }\n\n    (void)syn_list_header(did_header, 0, id, true);\n    did_header = true;\n    last_matchgroup = 0;\n    if (spp->sp_type == SPTYPE_MATCH) {\n      put_pattern(\"match\", ' ', spp, attr);\n      msg_putchar(' ');\n    } else if (spp->sp_type == SPTYPE_START)   {\n      while (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_START)\n        put_pattern(\"start\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);\n      if (SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_SKIP)\n        put_pattern(\"skip\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);\n      while (idx < curwin->w_s->b_syn_patterns.ga_len\n             && SYN_ITEMS(curwin->w_s)[idx].sp_type == SPTYPE_END)\n        put_pattern(\"end\", '=', &SYN_ITEMS(curwin->w_s)[idx++], attr);\n      --idx;\n      msg_putchar(' ');\n    }\n    syn_list_flags(namelist1, spp->sp_flags, attr);\n\n    if (spp->sp_cont_list != NULL) {\n      put_id_list(\"contains\", spp->sp_cont_list, attr);\n    }\n\n    if (spp->sp_syn.cont_in_list != NULL) {\n      put_id_list(\"containedin\", spp->sp_syn.cont_in_list, attr);\n    }\n\n    if (spp->sp_next_list != NULL) {\n      put_id_list(\"nextgroup\", spp->sp_next_list, attr);\n      syn_list_flags(namelist2, spp->sp_flags, attr);\n    }\n    if (spp->sp_flags & (HL_SYNC_HERE|HL_SYNC_THERE)) {\n      if (spp->sp_flags & HL_SYNC_HERE) {\n        msg_puts_attr(\"grouphere\", attr);\n      } else {\n        msg_puts_attr(\"groupthere\", attr);\n      }\n      msg_putchar(' ');\n      if (spp->sp_sync_idx >= 0)\n        msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin->w_s)\n                                [spp->sp_sync_idx].sp_syn.id - 1].sg_name);\n      else\n        MSG_PUTS(\"NONE\");\n      msg_putchar(' ');\n    }\n  }\n\n  /* list the link, if there is one */\n  if (HL_TABLE()[id - 1].sg_link && (did_header || link_only) && !got_int) {\n    (void)syn_list_header(did_header, 0, id, true);\n    msg_puts_attr(\"links to\", attr);\n    msg_putchar(' ');\n    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);\n  }\n}\n\nstatic void syn_list_flags(struct name_list *nlist, int flags, int attr)\n{\n  int i;\n\n  for (i = 0; nlist[i].flag != 0; ++i)\n    if (flags & nlist[i].flag) {\n      msg_puts_attr(nlist[i].name, attr);\n      msg_putchar(' ');\n    }\n}\n\n/*\n * List one syntax cluster, for \":syntax\" or \"syntax list syntax_name\".\n */\nstatic void syn_list_cluster(int id)\n{\n  int endcol = 15;\n\n  /* slight hack:  roughly duplicate the guts of syn_list_header() */\n  msg_putchar('\\n');\n  msg_outtrans(SYN_CLSTR(curwin->w_s)[id].scl_name);\n\n  if (msg_col >= endcol)        /* output at least one space */\n    endcol = msg_col + 1;\n  if (Columns <= endcol)        /* avoid hang for tiny window */\n    endcol = Columns - 1;\n\n  msg_advance(endcol);\n  if (SYN_CLSTR(curwin->w_s)[id].scl_list != NULL) {\n    put_id_list(\"cluster\", SYN_CLSTR(curwin->w_s)[id].scl_list, HL_ATTR(HLF_D));\n  } else {\n    msg_puts_attr(\"cluster\", HL_ATTR(HLF_D));\n    msg_puts(\"=NONE\");\n  }\n}\n\nstatic void put_id_list(const char *const name,\n                        const int16_t *const list,\n                        const int attr)\n{\n  msg_puts_attr(name, attr);\n  msg_putchar('=');\n  for (const int16_t *p = list; *p; p++) {\n    if (*p >= SYNID_ALLBUT && *p < SYNID_TOP) {\n      if (p[1]) {\n        msg_puts(\"ALLBUT\");\n      } else {\n        msg_puts(\"ALL\");\n      }\n    } else if (*p >= SYNID_TOP && *p < SYNID_CONTAINED)   {\n      msg_puts(\"TOP\");\n    } else if (*p >= SYNID_CONTAINED && *p < SYNID_CLUSTER)   {\n      msg_puts(\"CONTAINED\");\n    } else if (*p >= SYNID_CLUSTER)   {\n      int scl_id = *p - SYNID_CLUSTER;\n\n      msg_putchar('@');\n      msg_outtrans(SYN_CLSTR(curwin->w_s)[scl_id].scl_name);\n    } else\n      msg_outtrans(HL_TABLE()[*p - 1].sg_name);\n    if (p[1])\n      msg_putchar(',');\n  }\n  msg_putchar(' ');\n}\n\nstatic void put_pattern(const char *const s, const int c,\n                        const synpat_T *const spp, const int attr)\n{\n  static const char *const sepchars = \"/+=-#@\\\"|'^&\";\n  int i;\n\n  /* May have to write \"matchgroup=group\" */\n  if (last_matchgroup != spp->sp_syn_match_id) {\n    last_matchgroup = spp->sp_syn_match_id;\n    msg_puts_attr(\"matchgroup\", attr);\n    msg_putchar('=');\n    if (last_matchgroup == 0)\n      msg_outtrans((char_u *)\"NONE\");\n    else\n      msg_outtrans(HL_TABLE()[last_matchgroup - 1].sg_name);\n    msg_putchar(' ');\n  }\n\n  // Output the name of the pattern and an '=' or ' '.\n  msg_puts_attr(s, attr);\n  msg_putchar(c);\n\n  /* output the pattern, in between a char that is not in the pattern */\n  for (i = 0; vim_strchr(spp->sp_pattern, sepchars[i]) != NULL; )\n    if (sepchars[++i] == NUL) {\n      i = 0;            /* no good char found, just use the first one */\n      break;\n    }\n  msg_putchar(sepchars[i]);\n  msg_outtrans(spp->sp_pattern);\n  msg_putchar(sepchars[i]);\n\n  // output any pattern options\n  bool first = true;\n  for (i = 0; i < SPO_COUNT; i++) {\n    const int mask = (1 << i);\n    if (!(spp->sp_off_flags & (mask + (mask << SPO_COUNT)))) {\n      continue;\n    }\n    if (!first) {\n      msg_putchar(',');  // Separate with commas.\n    }\n    msg_puts(spo_name_tab[i]);\n    const long n = spp->sp_offsets[i];\n    if (i != SPO_LC_OFF) {\n      if (spp->sp_off_flags & mask)\n        msg_putchar('s');\n      else\n        msg_putchar('e');\n      if (n > 0)\n        msg_putchar('+');\n    }\n    if (n || i == SPO_LC_OFF) {\n      msg_outnum(n);\n    }\n    first = false;\n  }\n  msg_putchar(' ');\n}\n\n// List or clear the keywords for one syntax group.\n// Return true if the header has been printed.\nstatic bool syn_list_keywords(\n    const int id,\n    const hashtab_T *const ht,\n    bool did_header,                        // header has already been printed\n    const int attr\n)\n{\n  int prev_contained = 0;\n  const int16_t *prev_next_list = NULL;\n  const int16_t *prev_cont_in_list = NULL;\n  int prev_skipnl = 0;\n  int prev_skipwhite = 0;\n  int prev_skipempty = 0;\n\n  // Unfortunately, this list of keywords is not sorted on alphabet but on\n  // hash value...\n  size_t todo = ht->ht_used;\n  for (const hashitem_T *hi = ht->ht_array; todo > 0 && !got_int; hi++) {\n    if (HASHITEM_EMPTY(hi)) {\n      continue;\n    }\n    todo--;\n    for (keyentry_T *kp = HI2KE(hi); kp != NULL && !got_int; kp = kp->ke_next) {\n      if (kp->k_syn.id == id) {\n        int outlen = 0;\n        bool force_newline = false;\n        if (prev_contained != (kp->flags & HL_CONTAINED)\n            || prev_skipnl != (kp->flags & HL_SKIPNL)\n            || prev_skipwhite != (kp->flags & HL_SKIPWHITE)\n            || prev_skipempty != (kp->flags & HL_SKIPEMPTY)\n            || prev_cont_in_list != kp->k_syn.cont_in_list\n            || prev_next_list != kp->next_list) {\n            force_newline = true;\n        } else {\n          outlen = (int)STRLEN(kp->keyword);\n        }\n        // output \"contained\" and \"nextgroup\" on each line\n        if (syn_list_header(did_header, outlen, id, force_newline)) {\n          prev_contained = 0;\n          prev_next_list = NULL;\n          prev_cont_in_list = NULL;\n          prev_skipnl = 0;\n          prev_skipwhite = 0;\n          prev_skipempty = 0;\n        }\n        did_header = true;\n        if (prev_contained != (kp->flags & HL_CONTAINED)) {\n          msg_puts_attr(\"contained\", attr);\n          msg_putchar(' ');\n          prev_contained = (kp->flags & HL_CONTAINED);\n        }\n        if (kp->k_syn.cont_in_list != prev_cont_in_list) {\n          put_id_list(\"containedin\", kp->k_syn.cont_in_list, attr);\n          msg_putchar(' ');\n          prev_cont_in_list = kp->k_syn.cont_in_list;\n        }\n        if (kp->next_list != prev_next_list) {\n          put_id_list(\"nextgroup\", kp->next_list, attr);\n          msg_putchar(' ');\n          prev_next_list = kp->next_list;\n          if (kp->flags & HL_SKIPNL) {\n            msg_puts_attr(\"skipnl\", attr);\n            msg_putchar(' ');\n            prev_skipnl = (kp->flags & HL_SKIPNL);\n          }\n          if (kp->flags & HL_SKIPWHITE) {\n            msg_puts_attr(\"skipwhite\", attr);\n            msg_putchar(' ');\n            prev_skipwhite = (kp->flags & HL_SKIPWHITE);\n          }\n          if (kp->flags & HL_SKIPEMPTY) {\n            msg_puts_attr(\"skipempty\", attr);\n            msg_putchar(' ');\n            prev_skipempty = (kp->flags & HL_SKIPEMPTY);\n          }\n        }\n        msg_outtrans(kp->keyword);\n      }\n    }\n  }\n\n  return did_header;\n}\n\nstatic void syn_clear_keyword(int id, hashtab_T *ht)\n{\n  hashitem_T  *hi;\n  keyentry_T  *kp;\n  keyentry_T  *kp_prev;\n  keyentry_T  *kp_next;\n  int todo;\n\n  hash_lock(ht);\n  todo = (int)ht->ht_used;\n  for (hi = ht->ht_array; todo > 0; ++hi) {\n    if (HASHITEM_EMPTY(hi)) {\n      continue;\n    }\n    --todo;\n    kp_prev = NULL;\n    for (kp = HI2KE(hi); kp != NULL; ) {\n      if (kp->k_syn.id == id) {\n        kp_next = kp->ke_next;\n        if (kp_prev == NULL) {\n          if (kp_next == NULL)\n            hash_remove(ht, hi);\n          else\n            hi->hi_key = KE2HIKEY(kp_next);\n        } else\n          kp_prev->ke_next = kp_next;\n        xfree(kp->next_list);\n        xfree(kp->k_syn.cont_in_list);\n        xfree(kp);\n        kp = kp_next;\n      } else {\n        kp_prev = kp;\n        kp = kp->ke_next;\n      }\n    }\n  }\n  hash_unlock(ht);\n}\n\n/*\n * Clear a whole keyword table.\n */\nstatic void clear_keywtab(hashtab_T *ht)\n{\n  hashitem_T  *hi;\n  int todo;\n  keyentry_T  *kp;\n  keyentry_T  *kp_next;\n\n  todo = (int)ht->ht_used;\n  for (hi = ht->ht_array; todo > 0; ++hi) {\n    if (!HASHITEM_EMPTY(hi)) {\n      --todo;\n      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {\n        kp_next = kp->ke_next;\n        xfree(kp->next_list);\n        xfree(kp->k_syn.cont_in_list);\n        xfree(kp);\n      }\n    }\n  }\n  hash_clear(ht);\n  hash_init(ht);\n}\n\n/// Add a keyword to the list of keywords.\n///\n/// @param name name of keyword\n/// @param id group ID for this keyword\n/// @param flags flags for this keyword\n/// @param cont_in_list containedin for this keyword\n/// @param next_list nextgroup for this keyword\nstatic void add_keyword(char_u *const name,\n                        const int id,\n                        const int flags,\n                        int16_t *const cont_in_list,\n                        int16_t *const next_list,\n                        const int conceal_char)\n{\n  char_u name_folded[MAXKEYWLEN + 1];\n  const char_u *const name_ic = (curwin->w_s->b_syn_ic)\n      ? str_foldcase(name, (int)STRLEN(name), name_folded, sizeof(name_folded))\n      : name;\n\n  keyentry_T *const kp = xmalloc(sizeof(keyentry_T) + STRLEN(name_ic));\n  STRCPY(kp->keyword, name_ic);\n  kp->k_syn.id = id;\n  kp->k_syn.inc_tag = current_syn_inc_tag;\n  kp->flags = flags;\n  kp->k_char = conceal_char;\n  kp->k_syn.cont_in_list = copy_id_list(cont_in_list);\n  if (cont_in_list != NULL) {\n    curwin->w_s->b_syn_containedin = TRUE;\n  }\n  kp->next_list = copy_id_list(next_list);\n\n  const hash_T hash = hash_hash(kp->keyword);\n  hashtab_T *const ht = (curwin->w_s->b_syn_ic)\n      ? &curwin->w_s->b_keywtab_ic\n      : &curwin->w_s->b_keywtab;\n  hashitem_T *const hi = hash_lookup(ht, (const char *)kp->keyword,\n                                     STRLEN(kp->keyword), hash);\n\n  // even though it looks like only the kp->keyword member is\n  // being used here, vim uses some pointer trickery to get the original\n  // struct again later by using knowledge of the offset of the keyword\n  // field in the struct. See the definition of the HI2KE macro.\n  if (HASHITEM_EMPTY(hi)) {\n    // new keyword, add to hashtable\n    kp->ke_next = NULL;\n    hash_add_item(ht, hi, kp->keyword, hash);\n  } else {\n    // keyword already exists, prepend to list\n    kp->ke_next = HI2KE(hi);\n    hi->hi_key = KE2HIKEY(kp);\n  }\n}\n\n/*\n * Get the start and end of the group name argument.\n * Return a pointer to the first argument.\n * Return NULL if the end of the command was found instead of further args.\n */\nstatic char_u *\nget_group_name (\n    char_u *arg,               /* start of the argument */\n    char_u **name_end         /* pointer to end of the name */\n)\n{\n  char_u      *rest;\n\n  *name_end = skiptowhite(arg);\n  rest = skipwhite(*name_end);\n\n  /*\n   * Check if there are enough arguments.  The first argument may be a\n   * pattern, where '|' is allowed, so only check for NUL.\n   */\n  if (ends_excmd(*arg) || *rest == NUL)\n    return NULL;\n  return rest;\n}\n\n/*\n * Check for syntax command option arguments.\n * This can be called at any place in the list of arguments, and just picks\n * out the arguments that are known.  Can be called several times in a row to\n * collect all options in between other arguments.\n * Return a pointer to the next argument (which isn't an option).\n * Return NULL for any error;\n */\nstatic char_u *\nget_syn_options(\n    char_u *arg,            // next argument to be checked\n    syn_opt_arg_T *opt,     // various things\n    int *conceal_char,\n    int skip                // TRUE if skipping over command\n)\n{\n  char_u      *gname_start, *gname;\n  int syn_id;\n  int len = 0;\n  char        *p;\n  int fidx;\n  static const struct flag {\n    char    *name;\n    int argtype;\n    int flags;\n  } flagtab[] = { {\"cCoOnNtTaAiInNeEdD\",      0,      HL_CONTAINED},\n                  {\"oOnNeElLiInNeE\",          0,      HL_ONELINE},\n                  {\"kKeEeEpPeEnNdD\",          0,      HL_KEEPEND},\n                  {\"eExXtTeEnNdD\",            0,      HL_EXTEND},\n                  {\"eExXcClLuUdDeEnNlL\",      0,      HL_EXCLUDENL},\n                  {\"tTrRaAnNsSpPaArReEnNtT\",  0,      HL_TRANSP},\n                  {\"sSkKiIpPnNlL\",            0,      HL_SKIPNL},\n                  {\"sSkKiIpPwWhHiItTeE\",      0,      HL_SKIPWHITE},\n                  {\"sSkKiIpPeEmMpPtTyY\",      0,      HL_SKIPEMPTY},\n                  {\"gGrRoOuUpPhHeErReE\",      0,      HL_SYNC_HERE},\n                  {\"gGrRoOuUpPtThHeErReE\",    0,      HL_SYNC_THERE},\n                  {\"dDiIsSpPlLaAyY\",          0,      HL_DISPLAY},\n                  {\"fFoOlLdD\",                0,      HL_FOLD},\n                  {\"cCoOnNcCeEaAlL\",          0,      HL_CONCEAL},\n                  {\"cCoOnNcCeEaAlLeEnNdDsS\",  0,      HL_CONCEALENDS},\n                  {\"cCcChHaArR\",              11,     0},\n                  {\"cCoOnNtTaAiInNsS\",        1,      0},\n                  {\"cCoOnNtTaAiInNeEdDiInN\",  2,      0},\n                  {\"nNeExXtTgGrRoOuUpP\",      3,      0},};\n  static const char *const first_letters = \"cCoOkKeEtTsSgGdDfFnN\";\n\n  if (arg == NULL)              /* already detected error */\n    return NULL;\n\n  if (curwin->w_s->b_syn_conceal)\n    opt->flags |= HL_CONCEAL;\n\n  for (;; ) {\n    /*\n     * This is used very often when a large number of keywords is defined.\n     * Need to skip quickly when no option name is found.\n     * Also avoid tolower(), it's slow.\n     */\n    if (strchr(first_letters, *arg) == NULL)\n      break;\n\n    for (fidx = ARRAY_SIZE(flagtab); --fidx >= 0; ) {\n      p = flagtab[fidx].name;\n      int i;\n      for (i = 0, len = 0; p[i] != NUL; i += 2, ++len) {\n        if (arg[len] != p[i] && arg[len] != p[i + 1])\n          break;\n      }\n      if (p[i] == NUL && (ascii_iswhite(arg[len])\n                          || (flagtab[fidx].argtype > 0\n                              ? arg[len] == '='\n                              : ends_excmd(arg[len])))) {\n        if (opt->keyword\n            && (flagtab[fidx].flags == HL_DISPLAY\n                || flagtab[fidx].flags == HL_FOLD\n                || flagtab[fidx].flags == HL_EXTEND))\n          /* treat \"display\", \"fold\" and \"extend\" as a keyword */\n          fidx = -1;\n        break;\n      }\n    }\n    if (fidx < 0)           /* no match found */\n      break;\n\n    if (flagtab[fidx].argtype == 1) {\n      if (!opt->has_cont_list) {\n        EMSG(_(\"E395: contains argument not accepted here\"));\n        return NULL;\n      }\n      if (get_id_list(&arg, 8, &opt->cont_list, skip) == FAIL) {\n        return NULL;\n      }\n    } else if (flagtab[fidx].argtype == 2)   {\n      if (get_id_list(&arg, 11, &opt->cont_in_list, skip) == FAIL) {\n        return NULL;\n      }\n    } else if (flagtab[fidx].argtype == 3)   {\n      if (get_id_list(&arg, 9, &opt->next_list, skip) == FAIL) {\n        return NULL;\n      }\n    } else if (flagtab[fidx].argtype == 11 && arg[5] == '=')   {\n      // cchar=?\n      *conceal_char = utf_ptr2char(arg + 6);\n      arg += mb_ptr2len(arg + 6) - 1;\n      if (!vim_isprintc_strict(*conceal_char)) {\n        EMSG(_(\"E844: invalid cchar value\"));\n        return NULL;\n      }\n      arg = skipwhite(arg + 7);\n    } else {\n      opt->flags |= flagtab[fidx].flags;\n      arg = skipwhite(arg + len);\n\n      if (flagtab[fidx].flags == HL_SYNC_HERE\n          || flagtab[fidx].flags == HL_SYNC_THERE) {\n        if (opt->sync_idx == NULL) {\n          EMSG(_(\"E393: group[t]here not accepted here\"));\n          return NULL;\n        }\n        gname_start = arg;\n        arg = skiptowhite(arg);\n        if (gname_start == arg)\n          return NULL;\n        gname = vim_strnsave(gname_start, arg - gname_start);\n        if (STRCMP(gname, \"NONE\") == 0) {\n          *opt->sync_idx = NONE_IDX;\n        } else {\n          syn_id = syn_name2id(gname);\n          int i;\n          for (i = curwin->w_s->b_syn_patterns.ga_len; --i >= 0; )\n            if (SYN_ITEMS(curwin->w_s)[i].sp_syn.id == syn_id\n                && SYN_ITEMS(curwin->w_s)[i].sp_type == SPTYPE_START) {\n              *opt->sync_idx = i;\n              break;\n            }\n          if (i < 0) {\n            EMSG2(_(\"E394: Didn't find region item for %s\"), gname);\n            xfree(gname);\n            return NULL;\n          }\n        }\n\n        xfree(gname);\n        arg = skipwhite(arg);\n      } else if (flagtab[fidx].flags == HL_FOLD\n                 && foldmethodIsSyntax(curwin))\n        /* Need to update folds later. */\n        foldUpdateAll(curwin);\n    }\n  }\n\n  return arg;\n}\n\n/*\n * Adjustments to syntax item when declared in a \":syn include\"'d file.\n * Set the contained flag, and if the item is not already contained, add it\n * to the specified top-level group, if any.\n */\nstatic void syn_incl_toplevel(int id, int *flagsp)\n{\n  if ((*flagsp & HL_CONTAINED) || curwin->w_s->b_syn_topgrp == 0)\n    return;\n  *flagsp |= HL_CONTAINED;\n  if (curwin->w_s->b_syn_topgrp >= SYNID_CLUSTER) {\n    // We have to alloc this, because syn_combine_list() will free it.\n    int16_t *grp_list = xmalloc(2 * sizeof(*grp_list));\n    int tlg_id = curwin->w_s->b_syn_topgrp - SYNID_CLUSTER;\n\n    grp_list[0] = id;\n    grp_list[1] = 0;\n    syn_combine_list(&SYN_CLSTR(curwin->w_s)[tlg_id].scl_list, &grp_list,\n        CLUSTER_ADD);\n  }\n}\n\n/*\n * Handle \":syntax include [@{group-name}] filename\" command.\n */\nstatic void syn_cmd_include(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  int sgl_id = 1;\n  char_u      *group_name_end;\n  char_u      *rest;\n  char_u      *errormsg = NULL;\n  int prev_toplvl_grp;\n  int prev_syn_inc_tag;\n  bool source = false;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  if (arg[0] == '@') {\n    ++arg;\n    rest = get_group_name(arg, &group_name_end);\n    if (rest == NULL) {\n      EMSG((char_u *)_(\"E397: Filename required\"));\n      return;\n    }\n    sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));\n    if (sgl_id == 0)\n      return;\n    /* separate_nextcmd() and expand_filename() depend on this */\n    eap->arg = rest;\n  }\n\n  /*\n   * Everything that's left, up to the next command, should be the\n   * filename to include.\n   */\n  eap->argt |= (EX_XFILE | EX_NOSPC);\n  separate_nextcmd(eap);\n  if (*eap->arg == '<' || *eap->arg == '$' || path_is_absolute(eap->arg)) {\n    // For an absolute path, \"$VIM/...\" or \"<sfile>..\" we \":source\" the\n    // file.  Need to expand the file name first.  In other cases\n    // \":runtime!\" is used.\n    source = true;\n    if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL) {\n      if (errormsg != NULL)\n        EMSG(errormsg);\n      return;\n    }\n  }\n\n  /*\n   * Save and restore the existing top-level grouplist id and \":syn\n   * include\" tag around the actual inclusion.\n   */\n  if (running_syn_inc_tag >= MAX_SYN_INC_TAG) {\n    EMSG((char_u *)_(\"E847: Too many syntax includes\"));\n    return;\n  }\n  prev_syn_inc_tag = current_syn_inc_tag;\n  current_syn_inc_tag = ++running_syn_inc_tag;\n  prev_toplvl_grp = curwin->w_s->b_syn_topgrp;\n  curwin->w_s->b_syn_topgrp = sgl_id;\n  if (source\n      ? do_source(eap->arg, false, DOSO_NONE) == FAIL\n      : source_in_path(p_rtp, eap->arg, DIP_ALL) == FAIL) {\n    EMSG2(_(e_notopen), eap->arg);\n  }\n  curwin->w_s->b_syn_topgrp = prev_toplvl_grp;\n  current_syn_inc_tag = prev_syn_inc_tag;\n}\n\n/*\n * Handle \":syntax keyword {group-name} [{option}] keyword ..\" command.\n */\nstatic void syn_cmd_keyword(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *group_name_end;\n  int syn_id;\n  char_u      *rest;\n  char_u      *keyword_copy = NULL;\n  char_u      *p;\n  char_u      *kw;\n  syn_opt_arg_T syn_opt_arg;\n  int cnt;\n  int conceal_char = NUL;\n\n  rest = get_group_name(arg, &group_name_end);\n\n  if (rest != NULL) {\n    if (eap->skip) {\n      syn_id = -1;\n    } else {\n      syn_id = syn_check_group(arg, (int)(group_name_end - arg));\n    }\n    if (syn_id != 0) {\n      // Allocate a buffer, for removing backslashes in the keyword.\n      keyword_copy = xmalloc(STRLEN(rest) + 1);\n    }\n    if (keyword_copy != NULL) {\n      syn_opt_arg.flags = 0;\n      syn_opt_arg.keyword = true;\n      syn_opt_arg.sync_idx = NULL;\n      syn_opt_arg.has_cont_list = false;\n      syn_opt_arg.cont_in_list = NULL;\n      syn_opt_arg.next_list = NULL;\n\n      // The options given apply to ALL keywords, so all options must be\n      // found before keywords can be created.\n      // 1: collect the options and copy the keywords to keyword_copy.\n      cnt = 0;\n      p = keyword_copy;\n      for (; rest != NULL && !ends_excmd(*rest); rest = skipwhite(rest)) {\n        rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);\n        if (rest == NULL || ends_excmd(*rest)) {\n          break;\n        }\n        // Copy the keyword, removing backslashes, and add a NUL.\n        while (*rest != NUL && !ascii_iswhite(*rest)) {\n          if (*rest == '\\\\' && rest[1] != NUL) {\n            rest++;\n          }\n          *p++ = *rest++;\n        }\n        *p++ = NUL;\n        cnt++;\n      }\n\n      if (!eap->skip) {\n        // Adjust flags for use of \":syn include\".\n        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);\n\n        // 2: Add an entry for each keyword.\n        for (kw = keyword_copy; --cnt >= 0; kw += STRLEN(kw) + 1) {\n          for (p = vim_strchr(kw, '[');; ) {\n            if (p != NULL) {\n              *p = NUL;\n            }\n            add_keyword(kw, syn_id, syn_opt_arg.flags,\n                        syn_opt_arg.cont_in_list,\n                        syn_opt_arg.next_list, conceal_char);\n            if (p == NULL) {\n              break;\n            }\n            if (p[1] == NUL) {\n              emsgf(_(\"E789: Missing ']': %s\"), kw);\n              goto error;\n            }\n            if (p[1] == ']') {\n              if (p[2] != NUL) {\n                emsgf(_(\"E890: trailing char after ']': %s]%s\"),\n                      kw, &p[2]);\n                goto error;\n              }\n              kw = p + 1;\n              break;   // skip over the \"]\"\n            }\n            const int l = (*mb_ptr2len)(p + 1);\n\n            memmove(p, p + 1, l);\n            p += l;\n          }\n        }\n      }\n\nerror:\n      xfree(keyword_copy);\n      xfree(syn_opt_arg.cont_in_list);\n      xfree(syn_opt_arg.next_list);\n    }\n  }\n\n  if (rest != NULL)\n    eap->nextcmd = check_nextcmd(rest);\n  else\n    EMSG2(_(e_invarg2), arg);\n\n  redraw_curbuf_later(SOME_VALID);\n  syn_stack_free_all(curwin->w_s);              /* Need to recompute all syntax. */\n}\n\n/*\n * Handle \":syntax match {name} [{options}] {pattern} [{options}]\".\n *\n * Also \":syntax sync match {name} [[grouphere | groupthere] {group-name}] ..\"\n */\nstatic void\nsyn_cmd_match(\n    exarg_T *eap,\n    int syncing                        /* TRUE for \":syntax sync match .. \" */\n)\n{\n  char_u      *arg = eap->arg;\n  char_u      *group_name_end;\n  char_u      *rest;\n  synpat_T item;                /* the item found in the line */\n  int syn_id;\n  syn_opt_arg_T syn_opt_arg;\n  int sync_idx = 0;\n  int conceal_char = NUL;\n\n  /* Isolate the group name, check for validity */\n  rest = get_group_name(arg, &group_name_end);\n\n  /* Get options before the pattern */\n  syn_opt_arg.flags = 0;\n  syn_opt_arg.keyword = false;\n  syn_opt_arg.sync_idx = syncing ? &sync_idx : NULL;\n  syn_opt_arg.has_cont_list = true;\n  syn_opt_arg.cont_list = NULL;\n  syn_opt_arg.cont_in_list = NULL;\n  syn_opt_arg.next_list = NULL;\n  rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);\n\n  /* get the pattern. */\n  init_syn_patterns();\n  memset(&item, 0, sizeof(item));\n  rest = get_syn_pattern(rest, &item);\n  if (vim_regcomp_had_eol() && !(syn_opt_arg.flags & HL_EXCLUDENL)) {\n    syn_opt_arg.flags |= HL_HAS_EOL;\n  }\n\n  // Get options after the pattern\n  rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);\n\n  if (rest != NULL) {           /* all arguments are valid */\n    /*\n     * Check for trailing command and illegal trailing arguments.\n     */\n    eap->nextcmd = check_nextcmd(rest);\n    if (!ends_excmd(*rest) || eap->skip)\n      rest = NULL;\n    else {\n      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {\n        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);\n        /*\n         * Store the pattern in the syn_items list\n         */\n        synpat_T *spp = GA_APPEND_VIA_PTR(synpat_T,\n                                          &curwin->w_s->b_syn_patterns);\n        *spp = item;\n        spp->sp_syncing = syncing;\n        spp->sp_type = SPTYPE_MATCH;\n        spp->sp_syn.id = syn_id;\n        spp->sp_syn.inc_tag = current_syn_inc_tag;\n        spp->sp_flags = syn_opt_arg.flags;\n        spp->sp_sync_idx = sync_idx;\n        spp->sp_cont_list = syn_opt_arg.cont_list;\n        spp->sp_syn.cont_in_list = syn_opt_arg.cont_in_list;\n        spp->sp_cchar = conceal_char;\n        if (syn_opt_arg.cont_in_list != NULL)\n          curwin->w_s->b_syn_containedin = TRUE;\n        spp->sp_next_list = syn_opt_arg.next_list;\n\n        /* remember that we found a match for syncing on */\n        if (syn_opt_arg.flags & (HL_SYNC_HERE|HL_SYNC_THERE))\n          curwin->w_s->b_syn_sync_flags |= SF_MATCH;\n        if (syn_opt_arg.flags & HL_FOLD)\n          ++curwin->w_s->b_syn_folditems;\n\n        redraw_curbuf_later(SOME_VALID);\n        syn_stack_free_all(curwin->w_s);          /* Need to recompute all syntax. */\n        return;           /* don't free the progs and patterns now */\n      }\n    }\n  }\n\n  /*\n   * Something failed, free the allocated memory.\n   */\n  vim_regfree(item.sp_prog);\n  xfree(item.sp_pattern);\n  xfree(syn_opt_arg.cont_list);\n  xfree(syn_opt_arg.cont_in_list);\n  xfree(syn_opt_arg.next_list);\n\n  if (rest == NULL)\n    EMSG2(_(e_invarg2), arg);\n}\n\n/*\n * Handle \":syntax region {group-name} [matchgroup={group-name}]\n *\t\tstart {start} .. [skip {skip}] end {end} .. [{options}]\".\n */\nstatic void\nsyn_cmd_region(\n    exarg_T *eap,\n    int syncing                        /* TRUE for \":syntax sync region ..\" */\n)\n{\n  char_u              *arg = eap->arg;\n  char_u              *group_name_end;\n  char_u              *rest;                    /* next arg, NULL on error */\n  char_u              *key_end;\n  char_u              *key = NULL;\n  char_u              *p;\n  int item;\n#define ITEM_START          0\n#define ITEM_SKIP           1\n#define ITEM_END            2\n#define ITEM_MATCHGROUP     3\n  struct pat_ptr {\n    synpat_T        *pp_synp;                   /* pointer to syn_pattern */\n    int pp_matchgroup_id;                       /* matchgroup ID */\n    struct pat_ptr  *pp_next;                   /* pointer to next pat_ptr */\n  }                   *(pat_ptrs[3]);\n  /* patterns found in the line */\n  struct pat_ptr      *ppp;\n  struct pat_ptr      *ppp_next;\n  int pat_count = 0;                            /* nr of syn_patterns found */\n  int syn_id;\n  int matchgroup_id = 0;\n  bool not_enough = false;                      // not enough arguments\n  bool illegal = false;                         // illegal arguments\n  bool success = false;\n  syn_opt_arg_T syn_opt_arg;\n  int conceal_char = NUL;\n\n  /* Isolate the group name, check for validity */\n  rest = get_group_name(arg, &group_name_end);\n\n  pat_ptrs[0] = NULL;\n  pat_ptrs[1] = NULL;\n  pat_ptrs[2] = NULL;\n\n  init_syn_patterns();\n\n  syn_opt_arg.flags = 0;\n  syn_opt_arg.keyword = false;\n  syn_opt_arg.sync_idx = NULL;\n  syn_opt_arg.has_cont_list = true;\n  syn_opt_arg.cont_list = NULL;\n  syn_opt_arg.cont_in_list = NULL;\n  syn_opt_arg.next_list = NULL;\n\n  // get the options, patterns and matchgroup.\n  while (rest != NULL && !ends_excmd(*rest)) {\n    // Check for option arguments\n    rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);\n    if (rest == NULL || ends_excmd(*rest)) {\n      break;\n    }\n\n    /* must be a pattern or matchgroup then */\n    key_end = rest;\n    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=')\n      ++key_end;\n    xfree(key);\n    key = vim_strnsave_up(rest, key_end - rest);\n    if (STRCMP(key, \"MATCHGROUP\") == 0) {\n      item = ITEM_MATCHGROUP;\n    } else if (STRCMP(key, \"START\") == 0) {\n      item = ITEM_START;\n    } else if (STRCMP(key, \"END\") == 0) {\n      item = ITEM_END;\n    } else if (STRCMP(key, \"SKIP\") == 0) {\n      if (pat_ptrs[ITEM_SKIP] != NULL) {  // One skip pattern allowed.\n        illegal = true;\n        break;\n      }\n      item = ITEM_SKIP;\n    } else {\n      break;\n    }\n    rest = skipwhite(key_end);\n    if (*rest != '=') {\n      rest = NULL;\n      EMSG2(_(\"E398: Missing '=': %s\"), arg);\n      break;\n    }\n    rest = skipwhite(rest + 1);\n    if (*rest == NUL) {\n      not_enough = true;\n      break;\n    }\n\n    if (item == ITEM_MATCHGROUP) {\n      p = skiptowhite(rest);\n      if ((p - rest == 4 && STRNCMP(rest, \"NONE\", 4) == 0) || eap->skip)\n        matchgroup_id = 0;\n      else {\n        matchgroup_id = syn_check_group(rest, (int)(p - rest));\n        if (matchgroup_id == 0) {\n          illegal = true;\n          break;\n        }\n      }\n      rest = skipwhite(p);\n    } else {\n      /*\n       * Allocate room for a syn_pattern, and link it in the list of\n       * syn_patterns for this item, at the start (because the list is\n       * used from end to start).\n       */\n      ppp = xmalloc(sizeof(struct pat_ptr));\n      ppp->pp_next = pat_ptrs[item];\n      pat_ptrs[item] = ppp;\n      ppp->pp_synp = xcalloc(1, sizeof(synpat_T));\n\n      // Get the syntax pattern and the following offset(s).\n\n      // Enable the appropriate \\z specials.\n      if (item == ITEM_START) {\n        reg_do_extmatch = REX_SET;\n      } else {\n        assert(item == ITEM_SKIP || item == ITEM_END);\n        reg_do_extmatch = REX_USE;\n      }\n      rest = get_syn_pattern(rest, ppp->pp_synp);\n      reg_do_extmatch = 0;\n      if (item == ITEM_END && vim_regcomp_had_eol()\n          && !(syn_opt_arg.flags & HL_EXCLUDENL)) {\n        ppp->pp_synp->sp_flags |= HL_HAS_EOL;\n      }\n      ppp->pp_matchgroup_id = matchgroup_id;\n      pat_count++;\n    }\n  }\n  xfree(key);\n  if (illegal || not_enough)\n    rest = NULL;\n\n  // Must have a \"start\" and \"end\" pattern.\n  if (rest != NULL && (pat_ptrs[ITEM_START] == NULL\n                       || pat_ptrs[ITEM_END] == NULL)) {\n    not_enough = true;\n    rest = NULL;\n  }\n\n  if (rest != NULL) {\n    /*\n     * Check for trailing garbage or command.\n     * If OK, add the item.\n     */\n    eap->nextcmd = check_nextcmd(rest);\n    if (!ends_excmd(*rest) || eap->skip)\n      rest = NULL;\n    else {\n      ga_grow(&(curwin->w_s->b_syn_patterns), pat_count);\n      if ((syn_id = syn_check_group(arg, (int)(group_name_end - arg))) != 0) {\n        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);\n        /*\n         * Store the start/skip/end in the syn_items list\n         */\n        int idx = curwin->w_s->b_syn_patterns.ga_len;\n        for (item = ITEM_START; item <= ITEM_END; ++item) {\n          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp->pp_next) {\n            SYN_ITEMS(curwin->w_s)[idx] = *(ppp->pp_synp);\n            SYN_ITEMS(curwin->w_s)[idx].sp_syncing = syncing;\n            SYN_ITEMS(curwin->w_s)[idx].sp_type =\n              (item == ITEM_START) ? SPTYPE_START :\n              (item == ITEM_SKIP) ? SPTYPE_SKIP : SPTYPE_END;\n            SYN_ITEMS(curwin->w_s)[idx].sp_flags |= syn_opt_arg.flags;\n            SYN_ITEMS(curwin->w_s)[idx].sp_syn.id = syn_id;\n            SYN_ITEMS(curwin->w_s)[idx].sp_syn.inc_tag =\n              current_syn_inc_tag;\n            SYN_ITEMS(curwin->w_s)[idx].sp_syn_match_id =\n              ppp->pp_matchgroup_id;\n            SYN_ITEMS(curwin->w_s)[idx].sp_cchar = conceal_char;\n            if (item == ITEM_START) {\n              SYN_ITEMS(curwin->w_s)[idx].sp_cont_list =\n                syn_opt_arg.cont_list;\n              SYN_ITEMS(curwin->w_s)[idx].sp_syn.cont_in_list =\n                syn_opt_arg.cont_in_list;\n              if (syn_opt_arg.cont_in_list != NULL)\n                curwin->w_s->b_syn_containedin = TRUE;\n              SYN_ITEMS(curwin->w_s)[idx].sp_next_list =\n                syn_opt_arg.next_list;\n            }\n            ++curwin->w_s->b_syn_patterns.ga_len;\n            ++idx;\n            if (syn_opt_arg.flags & HL_FOLD)\n              ++curwin->w_s->b_syn_folditems;\n          }\n        }\n\n        redraw_curbuf_later(SOME_VALID);\n        syn_stack_free_all(curwin->w_s);  // Need to recompute all syntax.\n        success = true;                   // don't free the progs and patterns now\n      }\n    }\n  }\n\n  /*\n   * Free the allocated memory.\n   */\n  for (item = ITEM_START; item <= ITEM_END; ++item)\n    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {\n      if (!success && ppp->pp_synp != NULL) {\n        vim_regfree(ppp->pp_synp->sp_prog);\n        xfree(ppp->pp_synp->sp_pattern);\n      }\n      xfree(ppp->pp_synp);\n      ppp_next = ppp->pp_next;\n      xfree(ppp);\n    }\n\n  if (!success) {\n    xfree(syn_opt_arg.cont_list);\n    xfree(syn_opt_arg.cont_in_list);\n    xfree(syn_opt_arg.next_list);\n    if (not_enough)\n      EMSG2(_(\"E399: Not enough arguments: syntax region %s\"), arg);\n    else if (illegal || rest == NULL)\n      EMSG2(_(e_invarg2), arg);\n  }\n}\n\n// A simple syntax group ID comparison function suitable for use in qsort()\nstatic int syn_compare_stub(const void *const v1, const void *const v2)\n{\n  const int16_t *const s1 = v1;\n  const int16_t *const s2 = v2;\n\n  return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0;\n}\n\n// Combines lists of syntax clusters.\n// *clstr1 and *clstr2 must both be allocated memory; they will be consumed.\nstatic void syn_combine_list(int16_t **const clstr1, int16_t **const clstr2,\n                             const int list_op)\n{\n  size_t count1 = 0;\n  size_t count2 = 0;\n  const int16_t *g1;\n  const int16_t *g2;\n  int16_t *clstr = NULL;\n\n  /*\n   * Handle degenerate cases.\n   */\n  if (*clstr2 == NULL)\n    return;\n  if (*clstr1 == NULL || list_op == CLUSTER_REPLACE) {\n    if (list_op == CLUSTER_REPLACE)\n      xfree(*clstr1);\n    if (list_op == CLUSTER_REPLACE || list_op == CLUSTER_ADD)\n      *clstr1 = *clstr2;\n    else\n      xfree(*clstr2);\n    return;\n  }\n\n  for (g1 = *clstr1; *g1; g1++) {\n    count1++;\n  }\n  for (g2 = *clstr2; *g2; g2++) {\n    count2++;\n  }\n\n  // For speed purposes, sort both lists.\n  qsort(*clstr1, count1, sizeof(**clstr1), syn_compare_stub);\n  qsort(*clstr2, count2, sizeof(**clstr2), syn_compare_stub);\n\n  // We proceed in two passes; in round 1, we count the elements to place\n  // in the new list, and in round 2, we allocate and populate the new\n  // list.  For speed, we use a mergesort-like method, adding the smaller\n  // of the current elements in each list to the new list.\n  for (int round = 1; round <= 2; round++) {\n    g1 = *clstr1;\n    g2 = *clstr2;\n    int count = 0;\n\n    /*\n     * First, loop through the lists until one of them is empty.\n     */\n    while (*g1 && *g2) {\n      /*\n       * We always want to add from the first list.\n       */\n      if (*g1 < *g2) {\n        if (round == 2)\n          clstr[count] = *g1;\n        count++;\n        g1++;\n        continue;\n      }\n      /*\n       * We only want to add from the second list if we're adding the\n       * lists.\n       */\n      if (list_op == CLUSTER_ADD) {\n        if (round == 2)\n          clstr[count] = *g2;\n        count++;\n      }\n      if (*g1 == *g2)\n        g1++;\n      g2++;\n    }\n\n    /*\n     * Now add the leftovers from whichever list didn't get finished\n     * first.  As before, we only want to add from the second list if\n     * we're adding the lists.\n     */\n    for (; *g1; g1++, count++)\n      if (round == 2)\n        clstr[count] = *g1;\n    if (list_op == CLUSTER_ADD)\n      for (; *g2; g2++, count++)\n        if (round == 2)\n          clstr[count] = *g2;\n\n    if (round == 1) {\n      /*\n       * If the group ended up empty, we don't need to allocate any\n       * space for it.\n       */\n      if (count == 0) {\n        clstr = NULL;\n        break;\n      }\n      clstr = xmalloc((count + 1) * sizeof(*clstr));\n      clstr[count] = 0;\n    }\n  }\n\n  /*\n   * Finally, put the new list in place.\n   */\n  xfree(*clstr1);\n  xfree(*clstr2);\n  *clstr1 = clstr;\n}\n\n// Lookup a syntax cluster name and return its ID.\n// If it is not found, 0 is returned.\nstatic int syn_scl_name2id(char_u *name)\n{\n  // Avoid using stricmp() too much, it's slow on some systems\n  char_u *name_u = vim_strsave_up(name);\n  int i;\n  for (i = curwin->w_s->b_syn_clusters.ga_len; --i >= 0; ) {\n    if (SYN_CLSTR(curwin->w_s)[i].scl_name_u != NULL\n        && STRCMP(name_u, SYN_CLSTR(curwin->w_s)[i].scl_name_u) == 0) {\n      break;\n    }\n  }\n  xfree(name_u);\n  return i < 0 ? 0 : i + SYNID_CLUSTER;\n}\n\n/*\n * Like syn_scl_name2id(), but take a pointer + length argument.\n */\nstatic int syn_scl_namen2id(char_u *linep, int len)\n{\n  char_u *name = vim_strnsave(linep, len);\n  int id = syn_scl_name2id(name);\n  xfree(name);\n\n  return id;\n}\n\n// Find syntax cluster name in the table and return its ID.\n// The argument is a pointer to the name and the length of the name.\n// If it doesn't exist yet, a new entry is created.\n// Return 0 for failure.\nstatic int syn_check_cluster(char_u *pp, int len)\n{\n  int id;\n  char_u      *name;\n\n  name = vim_strnsave(pp, len);\n\n  id = syn_scl_name2id(name);\n  if (id == 0)                          /* doesn't exist yet */\n    id = syn_add_cluster(name);\n  else\n    xfree(name);\n  return id;\n}\n\n// Add new syntax cluster and return its ID.\n// \"name\" must be an allocated string, it will be consumed.\n// Return 0 for failure.\nstatic int syn_add_cluster(char_u *name)\n{\n  /*\n   * First call for this growarray: init growing array.\n   */\n  if (curwin->w_s->b_syn_clusters.ga_data == NULL) {\n    curwin->w_s->b_syn_clusters.ga_itemsize = sizeof(syn_cluster_T);\n    ga_set_growsize(&curwin->w_s->b_syn_clusters, 10);\n  }\n\n  int len = curwin->w_s->b_syn_clusters.ga_len;\n  if (len >= MAX_CLUSTER_ID) {\n    EMSG((char_u *)_(\"E848: Too many syntax clusters\"));\n    xfree(name);\n    return 0;\n  }\n\n  syn_cluster_T *scp = GA_APPEND_VIA_PTR(syn_cluster_T,\n                                         &curwin->w_s->b_syn_clusters);\n  memset(scp, 0, sizeof(*scp));\n  scp->scl_name = name;\n  scp->scl_name_u = vim_strsave_up(name);\n  scp->scl_list = NULL;\n\n  if (STRICMP(name, \"Spell\") == 0)\n    curwin->w_s->b_spell_cluster_id = len + SYNID_CLUSTER;\n  if (STRICMP(name, \"NoSpell\") == 0)\n    curwin->w_s->b_nospell_cluster_id = len + SYNID_CLUSTER;\n\n  return len + SYNID_CLUSTER;\n}\n\n/*\n * Handle \":syntax cluster {cluster-name} [contains={groupname},..]\n *\t\t[add={groupname},..] [remove={groupname},..]\".\n */\nstatic void syn_cmd_cluster(exarg_T *eap, int syncing)\n{\n  char_u      *arg = eap->arg;\n  char_u      *group_name_end;\n  char_u      *rest;\n  bool got_clstr = false;\n  int opt_len;\n  int list_op;\n\n  eap->nextcmd = find_nextcmd(arg);\n  if (eap->skip)\n    return;\n\n  rest = get_group_name(arg, &group_name_end);\n\n  if (rest != NULL) {\n    int scl_id = syn_check_cluster(arg, (int)(group_name_end - arg));\n    if (scl_id == 0) {\n      return;\n    }\n    scl_id -= SYNID_CLUSTER;\n\n    for (;; ) {\n      if (STRNICMP(rest, \"add\", 3) == 0\n          && (ascii_iswhite(rest[3]) || rest[3] == '=')) {\n        opt_len = 3;\n        list_op = CLUSTER_ADD;\n      } else if (STRNICMP(rest, \"remove\", 6) == 0\n                 && (ascii_iswhite(rest[6]) || rest[6] == '=')) {\n        opt_len = 6;\n        list_op = CLUSTER_SUBTRACT;\n      } else if (STRNICMP(rest, \"contains\", 8) == 0\n                 && (ascii_iswhite(rest[8]) || rest[8] == '=')) {\n        opt_len = 8;\n        list_op = CLUSTER_REPLACE;\n      } else\n        break;\n\n      int16_t *clstr_list = NULL;\n      if (get_id_list(&rest, opt_len, &clstr_list, eap->skip) == FAIL) {\n        EMSG2(_(e_invarg2), rest);\n        break;\n      }\n      if (scl_id >= 0) {\n        syn_combine_list(&SYN_CLSTR(curwin->w_s)[scl_id].scl_list,\n                         &clstr_list, list_op);\n      } else {\n        xfree(clstr_list);\n      }\n      got_clstr = true;\n    }\n\n    if (got_clstr) {\n      redraw_curbuf_later(SOME_VALID);\n      syn_stack_free_all(curwin->w_s);          /* Need to recompute all. */\n    }\n  }\n\n  if (!got_clstr)\n    EMSG(_(\"E400: No cluster specified\"));\n  if (rest == NULL || !ends_excmd(*rest))\n    EMSG2(_(e_invarg2), arg);\n}\n\n/*\n * On first call for current buffer: Init growing array.\n */\nstatic void init_syn_patterns(void)\n{\n  curwin->w_s->b_syn_patterns.ga_itemsize = sizeof(synpat_T);\n  ga_set_growsize(&curwin->w_s->b_syn_patterns, 10);\n}\n\n/*\n * Get one pattern for a \":syntax match\" or \":syntax region\" command.\n * Stores the pattern and program in a synpat_T.\n * Returns a pointer to the next argument, or NULL in case of an error.\n */\nstatic char_u *get_syn_pattern(char_u *arg, synpat_T *ci)\n{\n  char_u      *end;\n  int         *p;\n  int idx;\n  char_u      *cpo_save;\n\n  // need at least three chars\n  if (arg == NULL || arg[0] == NUL || arg[1] == NUL || arg[2] == NUL) {\n    return NULL;\n  }\n\n  end = skip_regexp(arg + 1, *arg, TRUE, NULL);\n  if (*end != *arg) {                       /* end delimiter not found */\n    EMSG2(_(\"E401: Pattern delimiter not found: %s\"), arg);\n    return NULL;\n  }\n  // store the pattern and compiled regexp program\n  ci->sp_pattern = vim_strnsave(arg + 1, end - arg - 1);\n\n  /* Make 'cpoptions' empty, to avoid the 'l' flag */\n  cpo_save = p_cpo;\n  p_cpo = (char_u *)\"\";\n  ci->sp_prog = vim_regcomp(ci->sp_pattern, RE_MAGIC);\n  p_cpo = cpo_save;\n\n  if (ci->sp_prog == NULL)\n    return NULL;\n  ci->sp_ic = curwin->w_s->b_syn_ic;\n  syn_clear_time(&ci->sp_time);\n\n  /*\n   * Check for a match, highlight or region offset.\n   */\n  ++end;\n  do {\n    for (idx = SPO_COUNT; --idx >= 0; )\n      if (STRNCMP(end, spo_name_tab[idx], 3) == 0)\n        break;\n    if (idx >= 0) {\n      p = &(ci->sp_offsets[idx]);\n      if (idx != SPO_LC_OFF)\n        switch (end[3]) {\n        case 's':   break;\n        case 'b':   break;\n        case 'e':   idx += SPO_COUNT; break;\n        default:    idx = -1; break;\n        }\n      if (idx >= 0) {\n        ci->sp_off_flags |= (1 << idx);\n        if (idx == SPO_LC_OFF) {            /* lc=99 */\n          end += 3;\n          *p = getdigits_int(&end, true, 0);\n\n          /* \"lc=\" offset automatically sets \"ms=\" offset */\n          if (!(ci->sp_off_flags & (1 << SPO_MS_OFF))) {\n            ci->sp_off_flags |= (1 << SPO_MS_OFF);\n            ci->sp_offsets[SPO_MS_OFF] = *p;\n          }\n        } else {                          /* yy=x+99 */\n          end += 4;\n          if (*end == '+') {\n            end++;\n            *p = getdigits_int(&end, true, 0);    // positive offset\n          } else if (*end == '-')   {\n            end++;\n            *p = -getdigits_int(&end, true, 0);   // negative offset\n          }\n        }\n        if (*end != ',')\n          break;\n        ++end;\n      }\n    }\n  } while (idx >= 0);\n\n  if (!ends_excmd(*end) && !ascii_iswhite(*end)) {\n    EMSG2(_(\"E402: Garbage after pattern: %s\"), arg);\n    return NULL;\n  }\n  return skipwhite(end);\n}\n\n/*\n * Handle \":syntax sync ..\" command.\n */\nstatic void syn_cmd_sync(exarg_T *eap, int syncing)\n{\n  char_u      *arg_start = eap->arg;\n  char_u      *arg_end;\n  char_u      *key = NULL;\n  char_u      *next_arg;\n  int illegal = FALSE;\n  int finished = FALSE;\n  long n;\n  char_u      *cpo_save;\n\n  if (ends_excmd(*arg_start)) {\n    syn_cmd_list(eap, TRUE);\n    return;\n  }\n\n  while (!ends_excmd(*arg_start)) {\n    arg_end = skiptowhite(arg_start);\n    next_arg = skipwhite(arg_end);\n    xfree(key);\n    key = vim_strnsave_up(arg_start, arg_end - arg_start);\n    if (STRCMP(key, \"CCOMMENT\") == 0) {\n      if (!eap->skip)\n        curwin->w_s->b_syn_sync_flags |= SF_CCOMMENT;\n      if (!ends_excmd(*next_arg)) {\n        arg_end = skiptowhite(next_arg);\n        if (!eap->skip)\n          curwin->w_s->b_syn_sync_id = syn_check_group(next_arg,\n              (int)(arg_end - next_arg));\n        next_arg = skipwhite(arg_end);\n      } else if (!eap->skip)\n        curwin->w_s->b_syn_sync_id = syn_name2id((char_u *)\"Comment\");\n    } else if (  STRNCMP(key, \"LINES\", 5) == 0\n                 || STRNCMP(key, \"MINLINES\", 8) == 0\n                 || STRNCMP(key, \"MAXLINES\", 8) == 0\n                 || STRNCMP(key, \"LINEBREAKS\", 10) == 0) {\n      if (key[4] == 'S')\n        arg_end = key + 6;\n      else if (key[0] == 'L')\n        arg_end = key + 11;\n      else\n        arg_end = key + 9;\n      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {\n        illegal = TRUE;\n        break;\n      }\n      n = getdigits_long(&arg_end, false, 0);\n      if (!eap->skip) {\n        if (key[4] == 'B')\n          curwin->w_s->b_syn_sync_linebreaks = n;\n        else if (key[1] == 'A')\n          curwin->w_s->b_syn_sync_maxlines = n;\n        else\n          curwin->w_s->b_syn_sync_minlines = n;\n      }\n    } else if (STRCMP(key, \"FROMSTART\") == 0)   {\n      if (!eap->skip) {\n        curwin->w_s->b_syn_sync_minlines = MAXLNUM;\n        curwin->w_s->b_syn_sync_maxlines = 0;\n      }\n    } else if (STRCMP(key, \"LINECONT\") == 0)   {\n      if (*next_arg == NUL) {  // missing pattern\n        illegal = true;\n        break;\n      }\n      if (curwin->w_s->b_syn_linecont_pat != NULL) {\n        EMSG(_(\"E403: syntax sync: line continuations pattern specified twice\"));\n        finished = TRUE;\n        break;\n      }\n      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);\n      if (*arg_end != *next_arg) {          /* end delimiter not found */\n        illegal = TRUE;\n        break;\n      }\n\n      if (!eap->skip) {\n        /* store the pattern and compiled regexp program */\n        curwin->w_s->b_syn_linecont_pat =\n          vim_strnsave(next_arg + 1, arg_end - next_arg - 1);\n        curwin->w_s->b_syn_linecont_ic = curwin->w_s->b_syn_ic;\n\n        /* Make 'cpoptions' empty, to avoid the 'l' flag */\n        cpo_save = p_cpo;\n        p_cpo = (char_u *)\"\";\n        curwin->w_s->b_syn_linecont_prog =\n          vim_regcomp(curwin->w_s->b_syn_linecont_pat, RE_MAGIC);\n        p_cpo = cpo_save;\n        syn_clear_time(&curwin->w_s->b_syn_linecont_time);\n\n        if (curwin->w_s->b_syn_linecont_prog == NULL) {\n          XFREE_CLEAR(curwin->w_s->b_syn_linecont_pat);\n          finished = true;\n          break;\n        }\n      }\n      next_arg = skipwhite(arg_end + 1);\n    } else {\n      eap->arg = next_arg;\n      if (STRCMP(key, \"MATCH\") == 0)\n        syn_cmd_match(eap, TRUE);\n      else if (STRCMP(key, \"REGION\") == 0)\n        syn_cmd_region(eap, TRUE);\n      else if (STRCMP(key, \"CLEAR\") == 0)\n        syn_cmd_clear(eap, TRUE);\n      else\n        illegal = TRUE;\n      finished = TRUE;\n      break;\n    }\n    arg_start = next_arg;\n  }\n  xfree(key);\n  if (illegal)\n    EMSG2(_(\"E404: Illegal arguments: %s\"), arg_start);\n  else if (!finished) {\n    eap->nextcmd = check_nextcmd(arg_start);\n    redraw_curbuf_later(SOME_VALID);\n    syn_stack_free_all(curwin->w_s);            /* Need to recompute all syntax. */\n  }\n}\n\n/*\n * Convert a line of highlight group names into a list of group ID numbers.\n * \"arg\" should point to the \"contains\" or \"nextgroup\" keyword.\n * \"arg\" is advanced to after the last group name.\n * Careful: the argument is modified (NULs added).\n * returns FAIL for some error, OK for success.\n */\nstatic int\nget_id_list(\n    char_u **const arg,\n    const int keylen,       // length of keyword\n    int16_t **const list,   // where to store the resulting list, if not\n                            // NULL, the list is silently skipped!\n    const bool skip\n)\n{\n  char_u      *p = NULL;\n  char_u      *end;\n  int total_count = 0;\n  int16_t *retval = NULL;\n  regmatch_T regmatch;\n  int id;\n  bool failed = false;\n\n  // We parse the list twice:\n  // round == 1: count the number of items, allocate the array.\n  // round == 2: fill the array with the items.\n  // In round 1 new groups may be added, causing the number of items to\n  // grow when a regexp is used.  In that case round 1 is done once again.\n  for (int round = 1; round <= 2; round++) {\n    // skip \"contains\"\n    p = skipwhite(*arg + keylen);\n    if (*p != '=') {\n      EMSG2(_(\"E405: Missing equal sign: %s\"), *arg);\n      break;\n    }\n    p = skipwhite(p + 1);\n    if (ends_excmd(*p)) {\n      EMSG2(_(\"E406: Empty argument: %s\"), *arg);\n      break;\n    }\n\n    // parse the arguments after \"contains\"\n    int count = 0;\n    do {\n      for (end = p; *end && !ascii_iswhite(*end) && *end != ','; end++) {\n      }\n      char_u *const name = xmalloc((int)(end - p + 3));   // leave room for \"^$\"\n      STRLCPY(name + 1, p, end - p + 1);\n      if (       STRCMP(name + 1, \"ALLBUT\") == 0\n                 || STRCMP(name + 1, \"ALL\") == 0\n                 || STRCMP(name + 1, \"TOP\") == 0\n                 || STRCMP(name + 1, \"CONTAINED\") == 0) {\n        if (TOUPPER_ASC(**arg) != 'C') {\n          EMSG2(_(\"E407: %s not allowed here\"), name + 1);\n          failed = true;\n          xfree(name);\n          break;\n        }\n        if (count != 0) {\n          EMSG2(_(\"E408: %s must be first in contains list\"),\n                name + 1);\n          failed = true;\n          xfree(name);\n          break;\n        }\n        if (name[1] == 'A') {\n          id = SYNID_ALLBUT + current_syn_inc_tag;\n        } else if (name[1] == 'T') {\n          if (curwin->w_s->b_syn_topgrp >= SYNID_CLUSTER) {\n            id = curwin->w_s->b_syn_topgrp;\n          } else {\n            id = SYNID_TOP + current_syn_inc_tag;\n          }\n        } else {\n          id = SYNID_CONTAINED + current_syn_inc_tag;\n        }\n      } else if (name[1] == '@')   {\n        if (skip) {\n          id = -1;\n        } else {\n          id = syn_check_cluster(name + 2, (int)(end - p - 1));\n        }\n      } else {\n        /*\n         * Handle full group name.\n         */\n        if (vim_strpbrk(name + 1, (char_u *)\"\\\\.*^$~[\") == NULL) {\n          id = syn_check_group(name + 1, (int)(end - p));\n        } else {\n          // Handle match of regexp with group names.\n          *name = '^';\n          STRCAT(name, \"$\");\n          regmatch.regprog = vim_regcomp(name, RE_MAGIC);\n          if (regmatch.regprog == NULL) {\n            failed = true;\n            xfree(name);\n            break;\n          }\n\n          regmatch.rm_ic = TRUE;\n          id = 0;\n          for (int i = highlight_ga.ga_len; --i >= 0; ) {\n            if (vim_regexec(&regmatch, HL_TABLE()[i].sg_name, (colnr_T)0)) {\n              if (round == 2) {\n                // Got more items than expected; can happen\n                // when adding items that match:\n                // \"contains=a.*b,axb\".\n                // Go back to first round.\n                if (count >= total_count) {\n                  xfree(retval);\n                  round = 1;\n                } else {\n                  retval[count] = i + 1;  // -V522\n                }\n              }\n              count++;\n              id = -1;  // Remember that we found one.\n            }\n          }\n          vim_regfree(regmatch.regprog);\n        }\n      }\n      xfree(name);\n      if (id == 0) {\n        EMSG2(_(\"E409: Unknown group name: %s\"), p);\n        failed = true;\n        break;\n      }\n      if (id > 0) {\n        if (round == 2) {\n          // Got more items than expected, go back to first round.\n          if (count >= total_count) {\n            xfree(retval);\n            round = 1;\n          } else {\n            retval[count] = id;\n          }\n        }\n        ++count;\n      }\n      p = skipwhite(end);\n      if (*p != ',')\n        break;\n      p = skipwhite(p + 1);             /* skip comma in between arguments */\n    } while (!ends_excmd(*p));\n    if (failed)\n      break;\n    if (round == 1) {\n      retval = xmalloc((count + 1) * sizeof(*retval));\n      retval[count] = 0;            // zero means end of the list\n      total_count = count;\n    }\n  }\n\n  *arg = p;\n  if (failed || retval == NULL) {\n    xfree(retval);\n    return FAIL;\n  }\n\n  if (*list == NULL)\n    *list = retval;\n  else\n    xfree(retval);           /* list already found, don't overwrite it */\n\n  return OK;\n}\n\n/*\n * Make a copy of an ID list.\n */\nstatic int16_t *copy_id_list(const int16_t *const list)\n{\n  if (list == NULL) {\n    return NULL;\n  }\n\n  int count;\n  for (count = 0; list[count]; count++) {\n  }\n  const size_t len = (count + 1) * sizeof(int16_t);\n  int16_t *const retval = xmalloc(len);\n  memmove(retval, list, len);\n\n  return retval;\n}\n\n/*\n * Check if syntax group \"ssp\" is in the ID list \"list\" of \"cur_si\".\n * \"cur_si\" can be NULL if not checking the \"containedin\" list.\n * Used to check if a syntax item is in the \"contains\" or \"nextgroup\" list of\n * the current item.\n * This function is called very often, keep it fast!!\n */\nstatic int\nin_id_list(\n    stateitem_T *cur_si,    // current item or NULL\n    int16_t *list,          // id list\n    struct sp_syn *ssp,     // group id and \":syn include\" tag of group\n    int contained           // group id is contained\n)\n{\n  int retval;\n  int16_t *scl_list;\n  int16_t item;\n  int16_t id = ssp->id;\n  static int depth = 0;\n  int r;\n\n  /* If ssp has a \"containedin\" list and \"cur_si\" is in it, return TRUE. */\n  if (cur_si != NULL && ssp->cont_in_list != NULL\n      && !(cur_si->si_flags & HL_MATCH)) {\n    /* Ignore transparent items without a contains argument.  Double check\n     * that we don't go back past the first one. */\n    while ((cur_si->si_flags & HL_TRANS_CONT)\n           && cur_si > (stateitem_T *)(current_state.ga_data))\n      --cur_si;\n    /* cur_si->si_idx is -1 for keywords, these never contain anything. */\n    if (cur_si->si_idx >= 0 && in_id_list(NULL, ssp->cont_in_list,\n            &(SYN_ITEMS(syn_block)[cur_si->si_idx].sp_syn),\n            SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags & HL_CONTAINED))\n      return TRUE;\n  }\n\n  if (list == NULL)\n    return FALSE;\n\n  /*\n   * If list is ID_LIST_ALL, we are in a transparent item that isn't\n   * inside anything.  Only allow not-contained groups.\n   */\n  if (list == ID_LIST_ALL)\n    return !contained;\n\n  /*\n   * If the first item is \"ALLBUT\", return TRUE if \"id\" is NOT in the\n   * contains list.  We also require that \"id\" is at the same \":syn include\"\n   * level as the list.\n   */\n  item = *list;\n  if (item >= SYNID_ALLBUT && item < SYNID_CLUSTER) {\n    if (item < SYNID_TOP) {\n      /* ALL or ALLBUT: accept all groups in the same file */\n      if (item - SYNID_ALLBUT != ssp->inc_tag)\n        return FALSE;\n    } else if (item < SYNID_CONTAINED)   {\n      /* TOP: accept all not-contained groups in the same file */\n      if (item - SYNID_TOP != ssp->inc_tag || contained)\n        return FALSE;\n    } else {\n      /* CONTAINED: accept all contained groups in the same file */\n      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained)\n        return FALSE;\n    }\n    item = *++list;\n    retval = FALSE;\n  } else\n    retval = TRUE;\n\n  /*\n   * Return \"retval\" if id is in the contains list.\n   */\n  while (item != 0) {\n    if (item == id)\n      return retval;\n    if (item >= SYNID_CLUSTER) {\n      scl_list = SYN_CLSTR(syn_block)[item - SYNID_CLUSTER].scl_list;\n      /* restrict recursiveness to 30 to avoid an endless loop for a\n       * cluster that includes itself (indirectly) */\n      if (scl_list != NULL && depth < 30) {\n        ++depth;\n        r = in_id_list(NULL, scl_list, ssp, contained);\n        --depth;\n        if (r)\n          return retval;\n      }\n    }\n    item = *++list;\n  }\n  return !retval;\n}\n\nstruct subcommand {\n  char    *name;                                /* subcommand name */\n  void    (*func)(exarg_T *, int);              /* function to call */\n};\n\nstatic struct subcommand subcommands[] =\n{\n  { \"case\",      syn_cmd_case },\n  { \"clear\",     syn_cmd_clear },\n  { \"cluster\",   syn_cmd_cluster },\n  { \"conceal\",   syn_cmd_conceal },\n  { \"enable\",    syn_cmd_on },\n  { \"foldlevel\", syn_cmd_foldlevel },\n  { \"include\",   syn_cmd_include },\n  { \"iskeyword\", syn_cmd_iskeyword },\n  { \"keyword\",   syn_cmd_keyword },\n  { \"list\",      syn_cmd_list },\n  { \"manual\",    syn_cmd_manual },\n  { \"match\",     syn_cmd_match },\n  { \"on\",        syn_cmd_on },\n  { \"off\",       syn_cmd_off },\n  { \"region\",    syn_cmd_region },\n  { \"reset\",     syn_cmd_reset },\n  { \"spell\",     syn_cmd_spell },\n  { \"sync\",      syn_cmd_sync },\n  { \"\",          syn_cmd_list },\n  { NULL, NULL }\n};\n\n/*\n * \":syntax\".\n * This searches the subcommands[] table for the subcommand name, and calls a\n * syntax_subcommand() function to do the rest.\n */\nvoid ex_syntax(exarg_T *eap)\n{\n  char_u      *arg = eap->arg;\n  char_u      *subcmd_end;\n\n  syn_cmdlinep = eap->cmdlinep;\n\n  // isolate subcommand name\n  for (subcmd_end = arg; ASCII_ISALPHA(*subcmd_end); subcmd_end++) {\n  }\n  char_u *const subcmd_name = vim_strnsave(arg, subcmd_end - arg);\n  if (eap->skip) {  // skip error messages for all subcommands\n    emsg_skip++;\n  }\n  for (int i = 0;; i++) {\n    if (subcommands[i].name == NULL) {\n      EMSG2(_(\"E410: Invalid :syntax subcommand: %s\"), subcmd_name);\n      break;\n    }\n    if (STRCMP(subcmd_name, (char_u *)subcommands[i].name) == 0) {\n      eap->arg = skipwhite(subcmd_end);\n      (subcommands[i].func)(eap, FALSE);\n      break;\n    }\n  }\n  xfree(subcmd_name);\n  if (eap->skip)\n    --emsg_skip;\n}\n\nvoid ex_ownsyntax(exarg_T *eap)\n{\n  char_u      *old_value;\n  char_u      *new_value;\n\n  if (curwin->w_s == &curwin->w_buffer->b_s) {\n    curwin->w_s = xmalloc(sizeof(synblock_T));\n    memset(curwin->w_s, 0, sizeof(synblock_T));\n    hash_init(&curwin->w_s->b_keywtab);\n    hash_init(&curwin->w_s->b_keywtab_ic);\n    // TODO: Keep the spell checking as it was. NOLINT(readability/todo)\n    curwin->w_p_spell = false;  // No spell checking\n    // make sure option values are \"empty_option\" instead of NULL\n    clear_string_option(&curwin->w_s->b_p_spc);\n    clear_string_option(&curwin->w_s->b_p_spf);\n    clear_string_option(&curwin->w_s->b_p_spl);\n    clear_string_option(&curwin->w_s->b_p_spo);\n    clear_string_option(&curwin->w_s->b_syn_isk);\n  }\n\n  // Save value of b:current_syntax.\n  old_value = get_var_value(\"b:current_syntax\");\n  if (old_value != NULL) {\n    old_value = vim_strsave(old_value);\n  }\n\n  /* Apply the \"syntax\" autocommand event, this finds and loads the syntax\n   * file. */\n  apply_autocmds(EVENT_SYNTAX, eap->arg, curbuf->b_fname, TRUE, curbuf);\n\n  // Move value of b:current_syntax to w:current_syntax.\n  new_value = get_var_value(\"b:current_syntax\");\n  if (new_value != NULL) {\n    set_internal_string_var(\"w:current_syntax\", new_value);\n  }\n\n  // Restore value of b:current_syntax.\n  if (old_value == NULL) {\n    do_unlet(S_LEN(\"b:current_syntax\"), true);\n  } else {\n    set_internal_string_var(\"b:current_syntax\", old_value);\n    xfree(old_value);\n  }\n}\n\nbool syntax_present(win_T *win)\n{\n  return win->w_s->b_syn_patterns.ga_len != 0\n         || win->w_s->b_syn_clusters.ga_len != 0\n         || win->w_s->b_keywtab.ht_used > 0\n         || win->w_s->b_keywtab_ic.ht_used > 0;\n}\n\n\nstatic enum {\n  EXP_SUBCMD,       // expand \":syn\" sub-commands\n  EXP_CASE,         // expand \":syn case\" arguments\n  EXP_SPELL,        // expand \":syn spell\" arguments\n  EXP_SYNC          // expand \":syn sync\" arguments\n} expand_what;\n\n/*\n * Reset include_link, include_default, include_none to 0.\n * Called when we are done expanding.\n */\nvoid reset_expand_highlight(void)\n{\n  include_link = include_default = include_none = 0;\n}\n\n/*\n * Handle command line completion for :match and :echohl command: Add \"None\"\n * as highlight group.\n */\nvoid set_context_in_echohl_cmd(expand_T *xp, const char *arg)\n{\n  xp->xp_context = EXPAND_HIGHLIGHT;\n  xp->xp_pattern = (char_u *)arg;\n  include_none = 1;\n}\n\n/*\n * Handle command line completion for :syntax command.\n */\nvoid set_context_in_syntax_cmd(expand_T *xp, const char *arg)\n{\n  // Default: expand subcommands.\n  xp->xp_context = EXPAND_SYNTAX;\n  expand_what = EXP_SUBCMD;\n  xp->xp_pattern = (char_u *)arg;\n  include_link = 0;\n  include_default = 0;\n\n  /* (part of) subcommand already typed */\n  if (*arg != NUL) {\n    const char *p = (const char *)skiptowhite((const char_u *)arg);\n    if (*p != NUL) {  // Past first word.\n      xp->xp_pattern = skipwhite((const char_u *)p);\n      if (*skiptowhite(xp->xp_pattern) != NUL) {\n        xp->xp_context = EXPAND_NOTHING;\n      } else if (STRNICMP(arg, \"case\", p - arg) == 0) {\n        expand_what = EXP_CASE;\n      } else if (STRNICMP(arg, \"spell\", p - arg) == 0) {\n        expand_what = EXP_SPELL;\n      } else if (STRNICMP(arg, \"sync\", p - arg) == 0) {\n        expand_what = EXP_SYNC;\n      } else if (STRNICMP(arg, \"keyword\", p - arg) == 0\n                 || STRNICMP(arg, \"region\", p - arg) == 0\n                 || STRNICMP(arg, \"match\", p - arg) == 0\n                 || STRNICMP(arg, \"list\", p - arg) == 0) {\n        xp->xp_context = EXPAND_HIGHLIGHT;\n      } else {\n        xp->xp_context = EXPAND_NOTHING;\n      }\n    }\n  }\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list syntax names for\n * expansion.\n */\nchar_u *get_syntax_name(expand_T *xp, int idx)\n{\n  switch (expand_what) {\n    case EXP_SUBCMD:\n        return (char_u *)subcommands[idx].name;\n    case EXP_CASE: {\n        static char *case_args[] = { \"match\", \"ignore\", NULL };\n        return (char_u *)case_args[idx];\n    }\n    case EXP_SPELL: {\n        static char *spell_args[] =\n        { \"toplevel\", \"notoplevel\", \"default\", NULL };\n        return (char_u *)spell_args[idx];\n    }\n    case EXP_SYNC: {\n        static char *sync_args[] =\n        { \"ccomment\", \"clear\", \"fromstart\",\n         \"linebreaks=\", \"linecont\", \"lines=\", \"match\",\n         \"maxlines=\", \"minlines=\", \"region\", NULL };\n        return (char_u *)sync_args[idx];\n    }\n  }\n  return NULL;\n}\n\n\n// Function called for expression evaluation: get syntax ID at file position.\nint syn_get_id(\n    win_T *wp,\n    long lnum,\n    colnr_T col,\n    int trans,      // remove transparency\n    bool *spellp,   // return: can do spell checking\n    int keep_state  // keep state of char at \"col\"\n)\n{\n  // When the position is not after the current position and in the same\n  // line of the same buffer, need to restart parsing.\n  if (wp->w_buffer != syn_buf || lnum != current_lnum || col < current_col) {\n    syntax_start(wp, lnum);\n  } else if (col > current_col) {\n      // next_match may not be correct when moving around, e.g. with the\n      // \"skip\" expression in searchpair()\n      next_match_idx = -1;\n  }\n\n  (void)get_syntax_attr(col, spellp, keep_state);\n\n  return trans ? current_trans_id : current_id;\n}\n\n/*\n * Get extra information about the syntax item.  Must be called right after\n * get_syntax_attr().\n * Stores the current item sequence nr in \"*seqnrp\".\n * Returns the current flags.\n */\nint get_syntax_info(int *seqnrp)\n{\n  *seqnrp = current_seqnr;\n  return current_flags;\n}\n\n\n/// Get the sequence number of the concealed file position.\n///\n/// @return seqnr if the file position is concealed, 0 otherwise.\nint syn_get_concealed_id(win_T *wp, linenr_T lnum, colnr_T col)\n{\n  int seqnr;\n  int syntax_flags;\n\n  (void)syn_get_id(wp, lnum, col, false, NULL, false);\n  syntax_flags = get_syntax_info(&seqnr);\n\n  if (syntax_flags & HL_CONCEAL) {\n    return seqnr;\n  }\n  return 0;\n}\n\n/*\n * Return conceal substitution character\n */\nint syn_get_sub_char(void)\n{\n  return current_sub_char;\n}\n\n/*\n * Return the syntax ID at position \"i\" in the current stack.\n * The caller must have called syn_get_id() before to fill the stack.\n * Returns -1 when \"i\" is out of range.\n */\nint syn_get_stack_item(int i)\n{\n  if (i >= current_state.ga_len) {\n    /* Need to invalidate the state, because we didn't properly finish it\n     * for the last character, \"keep_state\" was TRUE. */\n    invalidate_current_state();\n    current_col = MAXCOL;\n    return -1;\n  }\n  return CUR_STATE(i).si_id;\n}\n\nstatic int syn_cur_foldlevel(void)\n{\n  int level = 0;\n  for (int i = 0; i < current_state.ga_len; i++) {\n    if (CUR_STATE(i).si_flags & HL_FOLD) {\n      level++;\n    }\n  }\n  return level;\n}\n\n/*\n * Function called to get folding level for line \"lnum\" in window \"wp\".\n */\nint syn_get_foldlevel(win_T *wp, long lnum)\n{\n  int level = 0;\n\n  // Return quickly when there are no fold items at all.\n  if (wp->w_s->b_syn_folditems != 0\n      && !wp->w_s->b_syn_error\n      && !wp->w_s->b_syn_slow) {\n    syntax_start(wp, lnum);\n\n    // Start with the fold level at the start of the line.\n    level = syn_cur_foldlevel();\n\n    if (wp->w_s->b_syn_foldlevel == SYNFLD_MINIMUM) {\n      // Find the lowest fold level that is followed by a higher one.\n      int cur_level = level;\n      int low_level = cur_level;\n      while (!current_finished) {\n        (void)syn_current_attr(false, false, NULL, false);\n        cur_level = syn_cur_foldlevel();\n        if (cur_level < low_level) {\n          low_level = cur_level;\n        } else if (cur_level > low_level) {\n          level = low_level;\n        }\n        current_col++;\n      }\n    }\n  }\n  if (level > wp->w_p_fdn) {\n    level = wp->w_p_fdn;\n    if (level < 0)\n      level = 0;\n  }\n  return level;\n}\n\n/*\n * \":syntime\".\n */\nvoid ex_syntime(exarg_T *eap)\n{\n  if (STRCMP(eap->arg, \"on\") == 0) {\n    syn_time_on = true;\n  } else if (STRCMP(eap->arg, \"off\") == 0) {\n    syn_time_on = false;\n  } else if (STRCMP(eap->arg, \"clear\") == 0) {\n    syntime_clear();\n  } else if (STRCMP(eap->arg, \"report\") == 0) {\n    syntime_report();\n  } else {\n    EMSG2(_(e_invarg2), eap->arg);\n  }\n}\n\nstatic void syn_clear_time(syn_time_T *st)\n{\n  st->total = profile_zero();\n  st->slowest = profile_zero();\n  st->count = 0;\n  st->match = 0;\n}\n\n/*\n * Clear the syntax timing for the current buffer.\n */\nstatic void syntime_clear(void)\n{\n  synpat_T    *spp;\n\n  if (!syntax_present(curwin)) {\n    MSG(_(msg_no_items));\n    return;\n  }\n  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {\n    spp = &(SYN_ITEMS(curwin->w_s)[idx]);\n    syn_clear_time(&spp->sp_time);\n  }\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the possible arguments of the\n * \":syntime {on,off,clear,report}\" command.\n */\nchar_u *get_syntime_arg(expand_T *xp, int idx)\n{\n  switch (idx) {\n  case 0: return (char_u *)\"on\";\n  case 1: return (char_u *)\"off\";\n  case 2: return (char_u *)\"clear\";\n  case 3: return (char_u *)\"report\";\n  }\n  return NULL;\n}\n\nstatic int syn_compare_syntime(const void *v1, const void *v2)\n{\n  const time_entry_T  *s1 = v1;\n  const time_entry_T  *s2 = v2;\n\n  return profile_cmp(s1->total, s2->total);\n}\n\n/*\n * Clear the syntax timing for the current buffer.\n */\nstatic void syntime_report(void)\n{\n  if (!syntax_present(curwin)) {\n    MSG(_(msg_no_items));\n    return;\n  }\n\n  garray_T ga;\n  ga_init(&ga, sizeof(time_entry_T), 50);\n\n  proftime_T total_total = profile_zero();\n  int total_count = 0;\n  time_entry_T *p;\n  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {\n    synpat_T *spp = &(SYN_ITEMS(curwin->w_s)[idx]);\n    if (spp->sp_time.count > 0) {\n      p = GA_APPEND_VIA_PTR(time_entry_T, &ga);\n      p->total = spp->sp_time.total;\n      total_total = profile_add(total_total, spp->sp_time.total);\n      p->count = spp->sp_time.count;\n      p->match = spp->sp_time.match;\n      total_count += spp->sp_time.count;\n      p->slowest = spp->sp_time.slowest;\n      proftime_T tm = profile_divide(spp->sp_time.total, spp->sp_time.count);\n      p->average = tm;\n      p->id = spp->sp_syn.id;\n      p->pattern = spp->sp_pattern;\n    }\n  }\n\n  // Sort on total time. Skip if there are no items to avoid passing NULL\n  // pointer to qsort().\n  if (ga.ga_len > 1) {\n    qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),\n          syn_compare_syntime);\n  }\n\n  MSG_PUTS_TITLE(_(\n          \"  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN\"));\n  MSG_PUTS(\"\\n\");\n  for (int idx = 0; idx < ga.ga_len && !got_int; ++idx) {\n    p = ((time_entry_T *)ga.ga_data) + idx;\n\n    MSG_PUTS(profile_msg(p->total));\n    MSG_PUTS(\" \");     /* make sure there is always a separating space */\n    msg_advance(13);\n    msg_outnum(p->count);\n    MSG_PUTS(\" \");\n    msg_advance(20);\n    msg_outnum(p->match);\n    MSG_PUTS(\" \");\n    msg_advance(26);\n    MSG_PUTS(profile_msg(p->slowest));\n    MSG_PUTS(\" \");\n    msg_advance(38);\n    MSG_PUTS(profile_msg(p->average));\n    MSG_PUTS(\" \");\n    msg_advance(50);\n    msg_outtrans(HL_TABLE()[p->id - 1].sg_name);\n    MSG_PUTS(\" \");\n\n    msg_advance(69);\n    int len;\n    if (Columns < 80)\n      len = 20;       /* will wrap anyway */\n    else\n      len = Columns - 70;\n    if (len > (int)STRLEN(p->pattern))\n      len = (int)STRLEN(p->pattern);\n    msg_outtrans_len(p->pattern, len);\n    MSG_PUTS(\"\\n\");\n  }\n  ga_clear(&ga);\n  if (!got_int) {\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(profile_msg(total_total));\n    msg_advance(13);\n    msg_outnum(total_count);\n    MSG_PUTS(\"\\n\");\n  }\n}\n\n/**************************************\n*  Highlighting stuff\t\t      *\n**************************************/\n\n// The default highlight groups.  These are compiled-in for fast startup and\n// they still work when the runtime files can't be found.\n//\n// When making changes here, also change runtime/colors/default.vim!\n\nstatic const char *highlight_init_both[] = {\n  \"Conceal \"\n      \"ctermbg=DarkGrey ctermfg=LightGrey guibg=DarkGrey guifg=LightGrey\",\n  \"Cursor       guibg=fg guifg=bg\",\n  \"lCursor      guibg=fg guifg=bg\",\n  \"DiffText     cterm=bold ctermbg=Red gui=bold guibg=Red\",\n  \"ErrorMsg     ctermbg=DarkRed ctermfg=White guibg=Red guifg=White\",\n  \"IncSearch    cterm=reverse gui=reverse\",\n  \"ModeMsg      cterm=bold gui=bold\",\n  \"NonText      ctermfg=Blue gui=bold guifg=Blue\",\n  \"Normal       cterm=NONE gui=NONE\",\n  \"PmenuSbar    ctermbg=Grey guibg=Grey\",\n  \"StatusLine   cterm=reverse,bold gui=reverse,bold\",\n  \"StatusLineNC cterm=reverse gui=reverse\",\n  \"TabLineFill  cterm=reverse gui=reverse\",\n  \"TabLineSel   cterm=bold gui=bold\",\n  \"TermCursor   cterm=reverse gui=reverse\",\n  \"VertSplit    cterm=reverse gui=reverse\",\n  \"WildMenu     ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black\",\n  \"default link EndOfBuffer NonText\",\n  \"default link LineNrAbove LineNr\",\n  \"default link LineNrBelow LineNr\",\n  \"default link QuickFixLine Search\",\n  \"default link Substitute Search\",\n  \"default link Whitespace NonText\",\n  \"default link MsgSeparator StatusLine\",\n  \"default link NormalFloat Pmenu\",\n  \"default link FloatBorder VertSplit\",\n  \"default FloatShadow blend=80 guibg=Black\",\n  \"default FloatShadowThrough blend=100 guibg=Black\",\n  \"RedrawDebugNormal cterm=reverse gui=reverse\",\n  \"RedrawDebugClear ctermbg=Yellow guibg=Yellow\",\n  \"RedrawDebugComposed ctermbg=Green guibg=Green\",\n  \"RedrawDebugRecompose ctermbg=Red guibg=Red\",\n  \"Error term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE \"\n    \"guifg=White guibg=Red\",\n  \"Todo term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE \"\n    \"guifg=Blue guibg=Yellow\",\n  \"default link String Constant\",\n  \"default link Character Constant\",\n  \"default link Number Constant\",\n  \"default link Boolean Constant\",\n  \"default link Float Number\",\n  \"default link Function Identifier\",\n  \"default link Conditional Statement\",\n  \"default link Repeat Statement\",\n  \"default link Label Statement\",\n  \"default link Operator Statement\",\n  \"default link Keyword Statement\",\n  \"default link Exception Statement\",\n  \"default link Include PreProc\",\n  \"default link Define PreProc\",\n  \"default link Macro PreProc\",\n  \"default link PreCondit PreProc\",\n  \"default link StorageClass Type\",\n  \"default link Structure Type\",\n  \"default link Typedef Type\",\n  \"default link Tag Special\",\n  \"default link SpecialChar Special\",\n  \"default link Delimiter Special\",\n  \"default link SpecialComment Special\",\n  \"default link Debug Special\",\n  NULL\n};\n\n// Default colors only used with a light background.\nstatic const char *highlight_init_light[] = {\n  \"ColorColumn  ctermbg=LightRed guibg=LightRed\",\n  \"CursorColumn ctermbg=LightGrey guibg=Grey90\",\n  \"CursorLine   cterm=underline guibg=Grey90\",\n  \"CursorLineNr cterm=underline ctermfg=Brown gui=bold guifg=Brown\",\n  \"DiffAdd      ctermbg=LightBlue guibg=LightBlue\",\n  \"DiffChange   ctermbg=LightMagenta guibg=LightMagenta\",\n  \"DiffDelete   ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan\",\n  \"Directory    ctermfg=DarkBlue guifg=Blue\",\n  \"FoldColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue\",\n  \"Folded       ctermbg=Grey ctermfg=DarkBlue guibg=LightGrey guifg=DarkBlue\",\n  \"LineNr       ctermfg=Brown guifg=Brown\",\n  \"MatchParen   ctermbg=Cyan guibg=Cyan\",\n  \"MoreMsg      ctermfg=DarkGreen gui=bold guifg=SeaGreen\",\n  \"Pmenu        ctermbg=LightMagenta ctermfg=Black guibg=LightMagenta\",\n  \"PmenuSel     ctermbg=LightGrey ctermfg=Black guibg=Grey\",\n  \"PmenuThumb   ctermbg=Black guibg=Black\",\n  \"Question     ctermfg=DarkGreen gui=bold guifg=SeaGreen\",\n  \"Search       ctermbg=Yellow ctermfg=NONE guibg=Yellow guifg=NONE\",\n  \"SignColumn   ctermbg=Grey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue\",\n  \"SpecialKey   ctermfg=DarkBlue guifg=Blue\",\n  \"SpellBad     ctermbg=LightRed guisp=Red gui=undercurl\",\n  \"SpellCap     ctermbg=LightBlue guisp=Blue gui=undercurl\",\n  \"SpellLocal   ctermbg=Cyan guisp=DarkCyan gui=undercurl\",\n  \"SpellRare    ctermbg=LightMagenta guisp=Magenta gui=undercurl\",\n  \"TabLine      cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey\",\n  \"Title        ctermfg=DarkMagenta gui=bold guifg=Magenta\",\n  \"Visual       guibg=LightGrey\",\n  \"WarningMsg   ctermfg=DarkRed guifg=Red\",\n  \"Comment      term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE \"\n    \"gui=NONE guifg=Blue guibg=NONE\",\n  \"Constant     term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE \"\n    \"gui=NONE guifg=Magenta guibg=NONE\",\n  \"Special      term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE \"\n    \"gui=NONE guifg=#6a5acd guibg=NONE\",\n  \"Identifier   term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE \"\n    \"gui=NONE guifg=DarkCyan guibg=NONE\",\n  \"Statement    term=bold cterm=NONE ctermfg=Brown ctermbg=NONE \"\n    \"gui=bold guifg=Brown guibg=NONE\",\n  \"PreProc      term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE \"\n    \"gui=NONE guifg=#6a0dad guibg=NONE\",\n  \"Type         term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE \"\n    \"gui=bold guifg=SeaGreen guibg=NONE\",\n  \"Underlined   term=underline cterm=underline ctermfg=DarkMagenta \"\n    \"gui=underline guifg=SlateBlue\",\n  \"Ignore       term=NONE cterm=NONE ctermfg=white ctermbg=NONE \"\n    \"gui=NONE guifg=bg guibg=NONE\",\n  NULL\n};\n\n// Default colors only used with a dark background.\nstatic const char *highlight_init_dark[] = {\n  \"ColorColumn  ctermbg=DarkRed guibg=DarkRed\",\n  \"CursorColumn ctermbg=DarkGrey guibg=Grey40\",\n  \"CursorLine   cterm=underline guibg=Grey40\",\n  \"CursorLineNr cterm=underline ctermfg=Yellow gui=bold guifg=Yellow\",\n  \"DiffAdd      ctermbg=DarkBlue guibg=DarkBlue\",\n  \"DiffChange   ctermbg=DarkMagenta guibg=DarkMagenta\",\n  \"DiffDelete   ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan\",\n  \"Directory    ctermfg=LightCyan guifg=Cyan\",\n  \"FoldColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan\",\n  \"Folded       ctermbg=DarkGrey ctermfg=Cyan guibg=DarkGrey guifg=Cyan\",\n  \"LineNr       ctermfg=Yellow guifg=Yellow\",\n  \"MatchParen   ctermbg=DarkCyan guibg=DarkCyan\",\n  \"MoreMsg      ctermfg=LightGreen gui=bold guifg=SeaGreen\",\n  \"Pmenu        ctermbg=Magenta ctermfg=Black guibg=Magenta\",\n  \"PmenuSel     ctermbg=Black ctermfg=DarkGrey guibg=DarkGrey\",\n  \"PmenuThumb   ctermbg=White guibg=White\",\n  \"Question     ctermfg=LightGreen gui=bold guifg=Green\",\n  \"Search       ctermbg=Yellow ctermfg=Black guibg=Yellow guifg=Black\",\n  \"SignColumn   ctermbg=DarkGrey ctermfg=Cyan guibg=Grey guifg=Cyan\",\n  \"SpecialKey   ctermfg=LightBlue guifg=Cyan\",\n  \"SpellBad     ctermbg=Red guisp=Red gui=undercurl\",\n  \"SpellCap     ctermbg=Blue guisp=Blue gui=undercurl\",\n  \"SpellLocal   ctermbg=Cyan guisp=Cyan gui=undercurl\",\n  \"SpellRare    ctermbg=Magenta guisp=Magenta gui=undercurl\",\n  \"TabLine      cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey\",\n  \"Title        ctermfg=LightMagenta gui=bold guifg=Magenta\",\n  \"Visual       guibg=DarkGrey\",\n  \"WarningMsg   ctermfg=LightRed guifg=Red\",\n  \"Comment      term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE \"\n    \"gui=NONE guifg=#80a0ff guibg=NONE\",\n  \"Constant     term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE \"\n    \"gui=NONE guifg=#ffa0a0 guibg=NONE\",\n  \"Special      term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE \"\n    \"gui=NONE guifg=Orange guibg=NONE\",\n  \"Identifier   term=underline cterm=bold ctermfg=Cyan ctermbg=NONE \"\n    \"gui=NONE guifg=#40ffff guibg=NONE\",\n  \"Statement    term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE \"\n    \"gui=bold guifg=#ffff60 guibg=NONE\",\n  \"PreProc      term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE \"\n    \"gui=NONE guifg=#ff80ff guibg=NONE\",\n  \"Type         term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE \"\n    \"gui=bold guifg=#60ff60 guibg=NONE\",\n  \"Underlined   term=underline cterm=underline ctermfg=LightBlue \"\n    \"gui=underline guifg=#80a0ff\",\n  \"Ignore       term=NONE cterm=NONE ctermfg=black ctermbg=NONE \"\n    \"gui=NONE guifg=bg guibg=NONE\",\n  NULL\n};\n\nconst char *const highlight_init_cmdline[] = {\n  // XXX When modifying a list modify it in both valid and invalid halves.\n  // TODO(ZyX-I): merge valid and invalid groups via a macros.\n\n  // NvimInternalError should appear only when highlighter has a bug.\n  \"NvimInternalError ctermfg=Red ctermbg=Red guifg=Red guibg=Red\",\n\n  // Highlight groups (links) used by parser:\n\n  \"default link NvimAssignment Operator\",\n  \"default link NvimPlainAssignment NvimAssignment\",\n  \"default link NvimAugmentedAssignment NvimAssignment\",\n  \"default link NvimAssignmentWithAddition NvimAugmentedAssignment\",\n  \"default link NvimAssignmentWithSubtraction NvimAugmentedAssignment\",\n  \"default link NvimAssignmentWithConcatenation NvimAugmentedAssignment\",\n\n  \"default link NvimOperator Operator\",\n\n  \"default link NvimUnaryOperator NvimOperator\",\n  \"default link NvimUnaryPlus NvimUnaryOperator\",\n  \"default link NvimUnaryMinus NvimUnaryOperator\",\n  \"default link NvimNot NvimUnaryOperator\",\n\n  \"default link NvimBinaryOperator NvimOperator\",\n  \"default link NvimComparison NvimBinaryOperator\",\n  \"default link NvimComparisonModifier NvimComparison\",\n  \"default link NvimBinaryPlus NvimBinaryOperator\",\n  \"default link NvimBinaryMinus NvimBinaryOperator\",\n  \"default link NvimConcat NvimBinaryOperator\",\n  \"default link NvimConcatOrSubscript NvimConcat\",\n  \"default link NvimOr NvimBinaryOperator\",\n  \"default link NvimAnd NvimBinaryOperator\",\n  \"default link NvimMultiplication NvimBinaryOperator\",\n  \"default link NvimDivision NvimBinaryOperator\",\n  \"default link NvimMod NvimBinaryOperator\",\n\n  \"default link NvimTernary NvimOperator\",\n  \"default link NvimTernaryColon NvimTernary\",\n\n  \"default link NvimParenthesis Delimiter\",\n  \"default link NvimLambda NvimParenthesis\",\n  \"default link NvimNestingParenthesis NvimParenthesis\",\n  \"default link NvimCallingParenthesis NvimParenthesis\",\n\n  \"default link NvimSubscript NvimParenthesis\",\n  \"default link NvimSubscriptBracket NvimSubscript\",\n  \"default link NvimSubscriptColon NvimSubscript\",\n  \"default link NvimCurly NvimSubscript\",\n\n  \"default link NvimContainer NvimParenthesis\",\n  \"default link NvimDict NvimContainer\",\n  \"default link NvimList NvimContainer\",\n\n  \"default link NvimIdentifier Identifier\",\n  \"default link NvimIdentifierScope NvimIdentifier\",\n  \"default link NvimIdentifierScopeDelimiter NvimIdentifier\",\n  \"default link NvimIdentifierName NvimIdentifier\",\n  \"default link NvimIdentifierKey NvimIdentifier\",\n\n  \"default link NvimColon Delimiter\",\n  \"default link NvimComma Delimiter\",\n  \"default link NvimArrow Delimiter\",\n\n  \"default link NvimRegister SpecialChar\",\n  \"default link NvimNumber Number\",\n  \"default link NvimFloat NvimNumber\",\n  \"default link NvimNumberPrefix Type\",\n\n  \"default link NvimOptionSigil Type\",\n  \"default link NvimOptionName NvimIdentifier\",\n  \"default link NvimOptionScope NvimIdentifierScope\",\n  \"default link NvimOptionScopeDelimiter NvimIdentifierScopeDelimiter\",\n\n  \"default link NvimEnvironmentSigil NvimOptionSigil\",\n  \"default link NvimEnvironmentName NvimIdentifier\",\n\n  \"default link NvimString String\",\n  \"default link NvimStringBody NvimString\",\n  \"default link NvimStringQuote NvimString\",\n  \"default link NvimStringSpecial SpecialChar\",\n\n  \"default link NvimSingleQuote NvimStringQuote\",\n  \"default link NvimSingleQuotedBody NvimStringBody\",\n  \"default link NvimSingleQuotedQuote NvimStringSpecial\",\n\n  \"default link NvimDoubleQuote NvimStringQuote\",\n  \"default link NvimDoubleQuotedBody NvimStringBody\",\n  \"default link NvimDoubleQuotedEscape NvimStringSpecial\",\n\n  \"default link NvimFigureBrace NvimInternalError\",\n  \"default link NvimSingleQuotedUnknownEscape NvimInternalError\",\n\n  \"default link NvimSpacing Normal\",\n\n  // NvimInvalid groups:\n\n  \"default link NvimInvalidSingleQuotedUnknownEscape NvimInternalError\",\n\n  \"default link NvimInvalid Error\",\n\n  \"default link NvimInvalidAssignment NvimInvalid\",\n  \"default link NvimInvalidPlainAssignment NvimInvalidAssignment\",\n  \"default link NvimInvalidAugmentedAssignment NvimInvalidAssignment\",\n  \"default link NvimInvalidAssignmentWithAddition \"\n      \"NvimInvalidAugmentedAssignment\",\n  \"default link NvimInvalidAssignmentWithSubtraction \"\n      \"NvimInvalidAugmentedAssignment\",\n  \"default link NvimInvalidAssignmentWithConcatenation \"\n      \"NvimInvalidAugmentedAssignment\",\n\n  \"default link NvimInvalidOperator NvimInvalid\",\n\n  \"default link NvimInvalidUnaryOperator NvimInvalidOperator\",\n  \"default link NvimInvalidUnaryPlus NvimInvalidUnaryOperator\",\n  \"default link NvimInvalidUnaryMinus NvimInvalidUnaryOperator\",\n  \"default link NvimInvalidNot NvimInvalidUnaryOperator\",\n\n  \"default link NvimInvalidBinaryOperator NvimInvalidOperator\",\n  \"default link NvimInvalidComparison NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidComparisonModifier NvimInvalidComparison\",\n  \"default link NvimInvalidBinaryPlus NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidBinaryMinus NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidConcat NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidConcatOrSubscript NvimInvalidConcat\",\n  \"default link NvimInvalidOr NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidAnd NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidMultiplication NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidDivision NvimInvalidBinaryOperator\",\n  \"default link NvimInvalidMod NvimInvalidBinaryOperator\",\n\n  \"default link NvimInvalidTernary NvimInvalidOperator\",\n  \"default link NvimInvalidTernaryColon NvimInvalidTernary\",\n\n  \"default link NvimInvalidDelimiter NvimInvalid\",\n\n  \"default link NvimInvalidParenthesis NvimInvalidDelimiter\",\n  \"default link NvimInvalidLambda NvimInvalidParenthesis\",\n  \"default link NvimInvalidNestingParenthesis NvimInvalidParenthesis\",\n  \"default link NvimInvalidCallingParenthesis NvimInvalidParenthesis\",\n\n  \"default link NvimInvalidSubscript NvimInvalidParenthesis\",\n  \"default link NvimInvalidSubscriptBracket NvimInvalidSubscript\",\n  \"default link NvimInvalidSubscriptColon NvimInvalidSubscript\",\n  \"default link NvimInvalidCurly NvimInvalidSubscript\",\n\n  \"default link NvimInvalidContainer NvimInvalidParenthesis\",\n  \"default link NvimInvalidDict NvimInvalidContainer\",\n  \"default link NvimInvalidList NvimInvalidContainer\",\n\n  \"default link NvimInvalidValue NvimInvalid\",\n\n  \"default link NvimInvalidIdentifier NvimInvalidValue\",\n  \"default link NvimInvalidIdentifierScope NvimInvalidIdentifier\",\n  \"default link NvimInvalidIdentifierScopeDelimiter NvimInvalidIdentifier\",\n  \"default link NvimInvalidIdentifierName NvimInvalidIdentifier\",\n  \"default link NvimInvalidIdentifierKey NvimInvalidIdentifier\",\n\n  \"default link NvimInvalidColon NvimInvalidDelimiter\",\n  \"default link NvimInvalidComma NvimInvalidDelimiter\",\n  \"default link NvimInvalidArrow NvimInvalidDelimiter\",\n\n  \"default link NvimInvalidRegister NvimInvalidValue\",\n  \"default link NvimInvalidNumber NvimInvalidValue\",\n  \"default link NvimInvalidFloat NvimInvalidNumber\",\n  \"default link NvimInvalidNumberPrefix NvimInvalidNumber\",\n\n  \"default link NvimInvalidOptionSigil NvimInvalidIdentifier\",\n  \"default link NvimInvalidOptionName NvimInvalidIdentifier\",\n  \"default link NvimInvalidOptionScope NvimInvalidIdentifierScope\",\n  \"default link NvimInvalidOptionScopeDelimiter \"\n      \"NvimInvalidIdentifierScopeDelimiter\",\n\n  \"default link NvimInvalidEnvironmentSigil NvimInvalidOptionSigil\",\n  \"default link NvimInvalidEnvironmentName NvimInvalidIdentifier\",\n\n  // Invalid string bodies and specials are still highlighted as valid ones to\n  // minimize the red area.\n  \"default link NvimInvalidString NvimInvalidValue\",\n  \"default link NvimInvalidStringBody NvimStringBody\",\n  \"default link NvimInvalidStringQuote NvimInvalidString\",\n  \"default link NvimInvalidStringSpecial NvimStringSpecial\",\n\n  \"default link NvimInvalidSingleQuote NvimInvalidStringQuote\",\n  \"default link NvimInvalidSingleQuotedBody NvimInvalidStringBody\",\n  \"default link NvimInvalidSingleQuotedQuote NvimInvalidStringSpecial\",\n\n  \"default link NvimInvalidDoubleQuote NvimInvalidStringQuote\",\n  \"default link NvimInvalidDoubleQuotedBody NvimInvalidStringBody\",\n  \"default link NvimInvalidDoubleQuotedEscape NvimInvalidStringSpecial\",\n  \"default link NvimInvalidDoubleQuotedUnknownEscape NvimInvalidValue\",\n\n  \"default link NvimInvalidFigureBrace NvimInvalidDelimiter\",\n\n  \"default link NvimInvalidSpacing ErrorMsg\",\n\n  // Not actually invalid, but we highlight user that he is doing something\n  // wrong.\n  \"default link NvimDoubleQuotedUnknownEscape NvimInvalidValue\",\n  NULL,\n};\n\n/// Create default links for Nvim* highlight groups used for cmdline coloring\nvoid syn_init_cmdline_highlight(bool reset, bool init)\n{\n  for (size_t i = 0 ; highlight_init_cmdline[i] != NULL ; i++) {\n    do_highlight(highlight_init_cmdline[i], reset, init);\n  }\n}\n\n/// Load colors from a file if \"g:colors_name\" is set, otherwise load builtin\n/// colors\n///\n/// @param both include groups where 'bg' doesn't matter\n/// @param reset clear groups first\nvoid init_highlight(bool both, bool reset)\n{\n  static int had_both = false;\n\n  // Try finding the color scheme file.  Used when a color file was loaded\n  // and 'background' or 't_Co' is changed.\n  char_u *p = get_var_value(\"g:colors_name\");\n  if (p != NULL) {\n    // Value of g:colors_name could be freed in load_colors() and make\n    // p invalid, so copy it.\n    char_u *copy_p = vim_strsave(p);\n    bool okay = load_colors(copy_p);\n    xfree(copy_p);\n    if (okay) {\n        return;\n    }\n  }\n\n  /*\n   * Didn't use a color file, use the compiled-in colors.\n   */\n  if (both) {\n    had_both = true;\n    const char *const *const pp = highlight_init_both;\n    for (size_t i = 0; pp[i] != NULL; i++) {\n      do_highlight(pp[i], reset, true);\n    }\n  } else if (!had_both) {\n    // Don't do anything before the call with both == true from main().\n    // Not everything has been setup then, and that call will overrule\n    // everything anyway.\n    return;\n  }\n\n  const char *const *const pp = ((*p_bg == 'l')\n                                 ? highlight_init_light\n                                 : highlight_init_dark);\n  for (size_t i = 0; pp[i] != NULL; i++) {\n    do_highlight(pp[i], reset, true);\n  }\n\n  /* Reverse looks ugly, but grey may not work for 8 colors.  Thus let it\n   * depend on the number of colors available.\n   * With 8 colors brown is equal to yellow, need to use black for Search fg\n   * to avoid Statement highlighted text disappears.\n   * Clear the attributes, needed when changing the t_Co value. */\n  if (t_colors > 8) {\n    do_highlight(\n        (*p_bg == 'l'\n         ? \"Visual cterm=NONE ctermbg=LightGrey\"\n         : \"Visual cterm=NONE ctermbg=DarkGrey\"), false, true);\n  } else {\n    do_highlight(\"Visual cterm=reverse ctermbg=NONE\", false, true);\n    if (*p_bg == 'l') {\n      do_highlight(\"Search ctermfg=black\", false, true);\n    }\n  }\n\n  syn_init_cmdline_highlight(false, false);\n}\n\n/*\n * Load color file \"name\".\n * Return OK for success, FAIL for failure.\n */\nint load_colors(char_u *name)\n{\n  char_u      *buf;\n  int retval = FAIL;\n  static bool recursive = false;\n\n  // When being called recursively, this is probably because setting\n  // 'background' caused the highlighting to be reloaded.  This means it is\n  // working, thus we should return OK.\n  if (recursive) {\n    return OK;\n  }\n\n  recursive = true;\n  size_t buflen = STRLEN(name) + 12;\n  buf = xmalloc(buflen);\n  apply_autocmds(EVENT_COLORSCHEMEPRE, name, curbuf->b_fname, false, curbuf);\n  snprintf((char *)buf, buflen, \"colors/%s.vim\", name);\n  retval = source_runtime(buf, DIP_START + DIP_OPT);\n  if (retval == FAIL) {\n    snprintf((char *)buf, buflen, \"colors/%s.lua\", name);\n    retval = source_runtime(buf, DIP_START + DIP_OPT);\n  }\n  xfree(buf);\n  apply_autocmds(EVENT_COLORSCHEME, name, curbuf->b_fname, FALSE, curbuf);\n\n  recursive = false;\n\n  return retval;\n}\n\nstatic char *(color_names[28]) = {\n  \"Black\", \"DarkBlue\", \"DarkGreen\", \"DarkCyan\",\n  \"DarkRed\", \"DarkMagenta\", \"Brown\", \"DarkYellow\",\n  \"Gray\", \"Grey\", \"LightGray\", \"LightGrey\",\n  \"DarkGray\", \"DarkGrey\",\n  \"Blue\", \"LightBlue\", \"Green\", \"LightGreen\",\n  \"Cyan\", \"LightCyan\", \"Red\", \"LightRed\", \"Magenta\",\n  \"LightMagenta\", \"Yellow\", \"LightYellow\", \"White\", \"NONE\" };\n  // indices:\n  // 0, 1, 2, 3,\n  // 4, 5, 6, 7,\n  // 8, 9, 10, 11,\n  // 12, 13,\n  // 14, 15, 16, 17,\n  // 18, 19, 20, 21, 22,\n  // 23, 24, 25, 26, 27\nstatic int color_numbers_16[28] = { 0, 1, 2, 3,\n  4, 5, 6, 6,\n  7, 7, 7, 7,\n  8, 8,\n  9, 9, 10, 10,\n  11, 11, 12, 12, 13,\n  13, 14, 14, 15, -1 };\n// for xterm with 88 colors...\nstatic int color_numbers_88[28] = { 0, 4, 2, 6,\n  1, 5, 32, 72,\n  84, 84, 7, 7,\n  82, 82,\n  12, 43, 10, 61,\n  14, 63, 9, 74, 13,\n  75, 11, 78, 15, -1 };\n// for xterm with 256 colors...\nstatic int color_numbers_256[28] = { 0, 4, 2, 6,\n  1, 5, 130, 3,\n  248, 248, 7, 7,\n  242, 242,\n  12, 81, 10, 121,\n  14, 159, 9, 224, 13,\n  225, 11, 229, 15, -1 };\n// for terminals with less than 16 colors...\nstatic int color_numbers_8[28] = { 0, 4, 2, 6,\n  1, 5, 3, 3,\n  7, 7, 7, 7,\n  0+8, 0+8,\n  4+8, 4+8, 2+8, 2+8,\n  6+8, 6+8, 1+8, 1+8, 5+8,\n  5+8, 3+8, 3+8, 7+8, -1 };\n\n// Lookup the \"cterm\" value to be used for color with index \"idx\" in\n// color_names[].\n// \"boldp\" will be set to TRUE or FALSE for a foreground color when using 8\n// colors, otherwise it will be unchanged.\nint lookup_color(const int idx, const bool foreground, TriState *const boldp)\n{\n  int color = color_numbers_16[idx];\n\n  // Use the _16 table to check if it's a valid color name.\n  if (color < 0) {\n    return -1;\n  }\n\n  if (t_colors == 8) {\n    // t_Co is 8: use the 8 colors table\n    color = color_numbers_8[idx];\n    if (foreground) {\n      // set/reset bold attribute to get light foreground\n      // colors (on some terminals, e.g. \"linux\")\n      if (color & 8) {\n        *boldp = kTrue;\n      } else {\n        *boldp = kFalse;\n      }\n    }\n    color &= 7;   // truncate to 8 colors\n  } else if (t_colors == 16) {\n    color = color_numbers_8[idx];\n  } else if (t_colors == 88) {\n    color = color_numbers_88[idx];\n  } else if (t_colors >= 256) {\n    color = color_numbers_256[idx];\n  }\n  return color;\n}\n\n\n/// Handle \":highlight\" command\n///\n/// When using \":highlight clear\" this is called recursively for each group with\n/// forceit and init being both true.\n///\n/// @param[in]  line  Command arguments.\n/// @param[in]  forceit  True when bang is given, allows to link group even if\n///                      it has its own settings.\n/// @param[in]  init  True when initializing.\nvoid do_highlight(const char *line, const bool forceit, const bool init)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char *name_end;\n  const char *linep;\n  const char *key_start;\n  const char *arg_start;\n  long i;\n  int off;\n  int len;\n  int attr;\n  int id;\n  int idx;\n  struct hl_group item_before;\n  bool did_change = false;\n  bool dodefault = false;\n  bool doclear = false;\n  bool dolink = false;\n  bool error = false;\n  int color;\n  bool is_normal_group = false;   // \"Normal\" group\n  bool did_highlight_changed = false;\n\n  // If no argument, list current highlighting.\n  if (ends_excmd((uint8_t)(*line))) {\n    for (i = 1; i <= highlight_ga.ga_len && !got_int; i++) {\n      // TODO(brammool): only call when the group has attributes set\n      highlight_list_one(i);\n    }\n    return;\n  }\n\n  // Isolate the name.\n  name_end = (const char *)skiptowhite((const char_u *)line);\n  linep = (const char *)skipwhite((const char_u *)name_end);\n\n  // Check for \"default\" argument.\n  if (strncmp(line, \"default\", name_end - line) == 0) {\n    dodefault = true;\n    line = linep;\n    name_end = (const char *)skiptowhite((const char_u *)line);\n    linep = (const char *)skipwhite((const char_u *)name_end);\n  }\n\n  // Check for \"clear\" or \"link\" argument.\n  if (strncmp(line, \"clear\", name_end - line) == 0) {\n    doclear = true;\n  } else if (strncmp(line, \"link\", name_end - line) == 0) {\n    dolink = true;\n  }\n\n  // \":highlight {group-name}\": list highlighting for one group.\n  if (!doclear && !dolink && ends_excmd((uint8_t)(*linep))) {\n    id = syn_name2id_len((const char_u *)line, (int)(name_end - line));\n    if (id == 0) {\n      emsgf(_(\"E411: highlight group not found: %s\"), line);\n    } else {\n      highlight_list_one(id);\n    }\n    return;\n  }\n\n  // Handle \":highlight link {from} {to}\" command.\n  if (dolink) {\n    const char *from_start = linep;\n    const char *from_end;\n    const char *to_start;\n    const char *to_end;\n    int from_id;\n    int to_id;\n    struct hl_group *hlgroup = NULL;\n\n    from_end = (const char *)skiptowhite((const char_u *)from_start);\n    to_start = (const char *)skipwhite((const char_u *)from_end);\n    to_end   = (const char *)skiptowhite((const char_u *)to_start);\n\n    if (ends_excmd((uint8_t)(*from_start))\n        || ends_excmd((uint8_t)(*to_start))) {\n      emsgf(_(\"E412: Not enough arguments: \\\":highlight link %s\\\"\"),\n            from_start);\n      return;\n    }\n\n    if (!ends_excmd(*skipwhite((const char_u *)to_end))) {\n      emsgf(_(\"E413: Too many arguments: \\\":highlight link %s\\\"\"), from_start);\n      return;\n    }\n\n    from_id = syn_check_group((const char_u *)from_start,\n                              (int)(from_end - from_start));\n    if (strncmp(to_start, \"NONE\", 4) == 0) {\n      to_id = 0;\n    } else {\n      to_id = syn_check_group((const char_u *)to_start,\n                              (int)(to_end - to_start));\n    }\n\n    if (from_id > 0) {\n      hlgroup = &HL_TABLE()[from_id - 1];\n      if (dodefault && (forceit || hlgroup->sg_deflink == 0)) {\n        hlgroup->sg_deflink = to_id;\n        hlgroup->sg_deflink_sctx = current_sctx;\n        hlgroup->sg_deflink_sctx.sc_lnum += sourcing_lnum;\n      }\n    }\n\n    if (from_id > 0 && (!init || hlgroup->sg_set == 0)) {\n      // Don't allow a link when there already is some highlighting\n      // for the group, unless '!' is used\n      if (to_id > 0 && !forceit && !init\n          && hl_has_settings(from_id - 1, dodefault)) {\n        if (sourcing_name == NULL && !dodefault) {\n          EMSG(_(\"E414: group has settings, highlight link ignored\"));\n        }\n      } else if (hlgroup->sg_link != to_id\n                 || hlgroup->sg_script_ctx.sc_sid != current_sctx.sc_sid\n                 || hlgroup->sg_cleared) {\n        if (!init) {\n          hlgroup->sg_set |= SG_LINK;\n        }\n        hlgroup->sg_link = to_id;\n        hlgroup->sg_script_ctx = current_sctx;\n        hlgroup->sg_script_ctx.sc_lnum += sourcing_lnum;\n        hlgroup->sg_cleared = false;\n        redraw_all_later(SOME_VALID);\n\n        // Only call highlight changed() once after multiple changes\n        need_highlight_changed = true;\n      }\n    }\n\n    return;\n  }\n\n  if (doclear) {\n    // \":highlight clear [group]\" command.\n    line = linep;\n    if (ends_excmd((uint8_t)(*line))) {\n      do_unlet(S_LEN(\"colors_name\"), true);\n      restore_cterm_colors();\n\n      // Clear all default highlight groups and load the defaults.\n      for (int j = 0; j < highlight_ga.ga_len; j++) {\n        highlight_clear(j);\n      }\n      init_highlight(true, true);\n      highlight_changed();\n      redraw_all_later(NOT_VALID);\n      return;\n    }\n    name_end = (const char *)skiptowhite((const char_u *)line);\n    linep = (const char *)skipwhite((const char_u *)name_end);\n  }\n\n  // Find the group name in the table.  If it does not exist yet, add it.\n  id = syn_check_group((const char_u *)line, (int)(name_end - line));\n  if (id == 0) {  // Failed (out of memory).\n    return;\n  }\n  idx = id - 1;  // Index is ID minus one.\n\n  // Return if \"default\" was used and the group already has settings\n  if (dodefault && hl_has_settings(idx, true)) {\n    return;\n  }\n\n  // Make a copy so we can check if any attribute actually changed\n  item_before = HL_TABLE()[idx];\n  is_normal_group = (STRCMP(HL_TABLE()[idx].sg_name_u, \"NORMAL\") == 0);\n\n  // Clear the highlighting for \":hi clear {group}\" and \":hi clear\".\n  if (doclear || (forceit && init)) {\n    highlight_clear(idx);\n    if (!doclear) {\n      HL_TABLE()[idx].sg_set = 0;\n    }\n  }\n\n  char *key = NULL;\n  char *arg = NULL;\n  if (!doclear) {\n    while (!ends_excmd((uint8_t)(*linep))) {\n      key_start = linep;\n      if (*linep == '=') {\n        emsgf(_(\"E415: unexpected equal sign: %s\"), key_start);\n        error = true;\n        break;\n      }\n\n      // Isolate the key (\"term\", \"ctermfg\", \"ctermbg\", \"font\", \"guifg\",\n      // \"guibg\" or \"guisp\").\n      while (*linep && !ascii_iswhite(*linep) && *linep != '=') {\n        linep++;\n      }\n      xfree(key);\n      key = (char *)vim_strnsave_up((const char_u *)key_start,\n                                    linep - key_start);\n      linep = (const char *)skipwhite((const char_u *)linep);\n\n      if (strcmp(key, \"NONE\") == 0) {\n        if (!init || HL_TABLE()[idx].sg_set == 0) {\n          if (!init) {\n            HL_TABLE()[idx].sg_set |= SG_CTERM+SG_GUI;\n          }\n          highlight_clear(idx);\n        }\n        continue;\n      }\n\n      // Check for the equal sign.\n      if (*linep != '=') {\n        emsgf(_(\"E416: missing equal sign: %s\"), key_start);\n        error = true;\n        break;\n      }\n      linep++;\n\n      // Isolate the argument.\n      linep = (const char *)skipwhite((const char_u *)linep);\n      if (*linep == '\\'') {  // guifg='color name'\n        arg_start = ++linep;\n        linep = strchr(linep, '\\'');\n        if (linep == NULL) {\n          emsgf(_(e_invarg2), key_start);\n          error = true;\n          break;\n        }\n      } else {\n        arg_start = linep;\n        linep = (const char *)skiptowhite((const char_u *)linep);\n      }\n      if (linep == arg_start) {\n        emsgf(_(\"E417: missing argument: %s\"), key_start);\n        error = true;\n        break;\n      }\n      xfree(arg);\n      arg = xstrndup(arg_start, (size_t)(linep - arg_start));\n\n      if (*linep == '\\'') {\n        linep++;\n      }\n\n      // Store the argument.\n      if (strcmp(key, \"TERM\") == 0\n          || strcmp(key, \"CTERM\") == 0\n          || strcmp(key, \"GUI\") == 0) {\n        attr = 0;\n        off = 0;\n        while (arg[off] != NUL) {\n          for (i = ARRAY_SIZE(hl_attr_table); --i >= 0; ) {\n            len = (int)STRLEN(hl_name_table[i]);\n            if (STRNICMP(arg + off, hl_name_table[i], len) == 0) {\n              attr |= hl_attr_table[i];\n              off += len;\n              break;\n            }\n          }\n          if (i < 0) {\n            emsgf(_(\"E418: Illegal value: %s\"), arg);\n            error = true;\n            break;\n          }\n          if (arg[off] == ',') {  // Another one follows.\n            off++;\n          }\n        }\n        if (error) {\n          break;\n        }\n        if (*key == 'C')   {\n          if (!init || !(HL_TABLE()[idx].sg_set & SG_CTERM)) {\n            if (!init) {\n              HL_TABLE()[idx].sg_set |= SG_CTERM;\n            }\n            HL_TABLE()[idx].sg_cterm = attr;\n            HL_TABLE()[idx].sg_cterm_bold = false;\n          }\n        } else if (*key == 'G') {\n          if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI)) {\n            if (!init) {\n              HL_TABLE()[idx].sg_set |= SG_GUI;\n            }\n            HL_TABLE()[idx].sg_gui = attr;\n          }\n        }\n      } else if (STRCMP(key, \"FONT\") == 0)   {\n        // in non-GUI fonts are simply ignored\n      } else if (STRCMP(key, \"CTERMFG\") == 0 || STRCMP(key, \"CTERMBG\") == 0) {\n        if (!init || !(HL_TABLE()[idx].sg_set & SG_CTERM)) {\n          if (!init) {\n            HL_TABLE()[idx].sg_set |= SG_CTERM;\n          }\n\n          /* When setting the foreground color, and previously the \"bold\"\n           * flag was set for a light color, reset it now */\n          if (key[5] == 'F' && HL_TABLE()[idx].sg_cterm_bold) {\n            HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;\n            HL_TABLE()[idx].sg_cterm_bold = false;\n          }\n\n          if (ascii_isdigit(*arg)) {\n            color = atoi((char *)arg);\n          } else if (STRICMP(arg, \"fg\") == 0) {\n            if (cterm_normal_fg_color) {\n              color = cterm_normal_fg_color - 1;\n            } else {\n              EMSG(_(\"E419: FG color unknown\"));\n              error = true;\n              break;\n            }\n          } else if (STRICMP(arg, \"bg\") == 0)   {\n            if (cterm_normal_bg_color > 0)\n              color = cterm_normal_bg_color - 1;\n            else {\n              EMSG(_(\"E420: BG color unknown\"));\n              error = true;\n              break;\n            }\n          } else {\n            // Reduce calls to STRICMP a bit, it can be slow.\n            off = TOUPPER_ASC(*arg);\n            for (i = ARRAY_SIZE(color_names); --i >= 0; ) {\n              if (off == color_names[i][0]\n                  && STRICMP(arg + 1, color_names[i] + 1) == 0) {\n                break;\n              }\n            }\n            if (i < 0) {\n              emsgf(_(\"E421: Color name or number not recognized: %s\"),\n                    key_start);\n              error = true;\n              break;\n            }\n\n            TriState bold = kNone;\n            color = lookup_color(i, key[5] == 'F', &bold);\n\n            // set/reset bold attribute to get light foreground\n            // colors (on some terminals, e.g. \"linux\")\n            if (bold == kTrue) {\n              HL_TABLE()[idx].sg_cterm |= HL_BOLD;\n              HL_TABLE()[idx].sg_cterm_bold = true;\n            } else if (bold == kFalse) {\n              HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;\n            }\n          }\n          // Add one to the argument, to avoid zero.  Zero is used for\n          // \"NONE\", then \"color\" is -1.\n          if (key[5] == 'F') {\n            HL_TABLE()[idx].sg_cterm_fg = color + 1;\n            if (is_normal_group) {\n              cterm_normal_fg_color = color + 1;\n            }\n          } else {\n            HL_TABLE()[idx].sg_cterm_bg = color + 1;\n            if (is_normal_group) {\n              cterm_normal_bg_color = color + 1;\n              if (!ui_rgb_attached()) {\n                if (color >= 0) {\n                  int dark = -1;\n\n                  if (t_colors < 16) {\n                    dark = (color == 0 || color == 4);\n                  } else if (color < 16) {\n                    // Limit the heuristic to the standard 16 colors\n                    dark = (color < 7 || color == 8);\n                  }\n                  // Set the 'background' option if the value is\n                  // wrong.\n                  if (dark != -1\n                      && dark != (*p_bg == 'd')\n                      && !option_was_set(\"bg\")) {\n                    set_option_value(\"bg\", 0L, (dark ? \"dark\" : \"light\"), 0);\n                    reset_option_was_set(\"bg\");\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else if (strcmp(key, \"GUIFG\") == 0)   {\n        char **namep = &HL_TABLE()[idx].sg_rgb_fg_name;\n\n        if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI)) {\n          if (!init) {\n            HL_TABLE()[idx].sg_set |= SG_GUI;\n          }\n\n          if (*namep == NULL || STRCMP(*namep, arg) != 0) {\n            xfree(*namep);\n            if (strcmp(arg, \"NONE\") != 0) {\n              *namep = xstrdup(arg);\n              HL_TABLE()[idx].sg_rgb_fg = name_to_color(arg);\n            } else {\n              *namep = NULL;\n              HL_TABLE()[idx].sg_rgb_fg = -1;\n            }\n            did_change = true;\n          }\n        }\n\n        if (is_normal_group) {\n          normal_fg = HL_TABLE()[idx].sg_rgb_fg;\n        }\n      } else if (STRCMP(key, \"GUIBG\") == 0)   {\n        char **const namep = &HL_TABLE()[idx].sg_rgb_bg_name;\n\n        if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI)) {\n          if (!init) {\n            HL_TABLE()[idx].sg_set |= SG_GUI;\n          }\n\n          if (*namep == NULL || STRCMP(*namep, arg) != 0) {\n            xfree(*namep);\n            if (STRCMP(arg, \"NONE\") != 0) {\n              *namep = xstrdup(arg);\n              HL_TABLE()[idx].sg_rgb_bg = name_to_color(arg);\n            } else {\n              *namep = NULL;\n              HL_TABLE()[idx].sg_rgb_bg = -1;\n            }\n            did_change = true;\n          }\n        }\n\n        if (is_normal_group) {\n          normal_bg = HL_TABLE()[idx].sg_rgb_bg;\n        }\n      } else if (strcmp(key, \"GUISP\") == 0)   {\n        char **const namep = &HL_TABLE()[idx].sg_rgb_sp_name;\n\n        if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI)) {\n          if (!init) {\n            HL_TABLE()[idx].sg_set |= SG_GUI;\n          }\n\n          if (*namep == NULL || STRCMP(*namep, arg) != 0) {\n            xfree(*namep);\n            if (strcmp(arg, \"NONE\") != 0) {\n              *namep = xstrdup(arg);\n              HL_TABLE()[idx].sg_rgb_sp = name_to_color(arg);\n            } else {\n              *namep = NULL;\n              HL_TABLE()[idx].sg_rgb_sp = -1;\n            }\n            did_change = true;\n          }\n        }\n\n        if (is_normal_group) {\n          normal_sp = HL_TABLE()[idx].sg_rgb_sp;\n        }\n      } else if (strcmp(key, \"START\") == 0 || strcmp(key, \"STOP\") == 0)   {\n        // Ignored for now\n      } else if (strcmp(key, \"BLEND\") == 0)   {\n        if (strcmp(arg, \"NONE\") != 0) {\n          HL_TABLE()[idx].sg_blend = strtol(arg, NULL, 10);\n        } else {\n          HL_TABLE()[idx].sg_blend = -1;\n        }\n      } else {\n        emsgf(_(\"E423: Illegal argument: %s\"), key_start);\n        error = true;\n        break;\n      }\n      HL_TABLE()[idx].sg_cleared = false;\n\n      // When highlighting has been given for a group, don't link it.\n      if (!init || !(HL_TABLE()[idx].sg_set & SG_LINK)) {\n        HL_TABLE()[idx].sg_link = 0;\n      }\n\n      // Continue with next argument.\n      linep = (const char *)skipwhite((const char_u *)linep);\n    }\n  }\n\n  // If there is an error, and it's a new entry, remove it from the table.\n  if (error && idx == highlight_ga.ga_len) {\n    syn_unadd_group();\n  } else {\n    if (!error && is_normal_group) {\n      // Need to update all groups, because they might be using \"bg\" and/or\n      // \"fg\", which have been changed now.\n      highlight_attr_set_all();\n\n      if (!ui_has(kUILinegrid) && starting == 0) {\n        // Older UIs assume that we clear the screen after normal group is\n        // changed\n        ui_refresh();\n      } else {\n        // TUI and newer UIs will repaint the screen themselves. NOT_VALID\n        // redraw below will still handle usages of guibg=fg etc.\n        ui_default_colors_set();\n      }\n      did_highlight_changed = true;\n      redraw_all_later(NOT_VALID);\n    } else {\n      set_hl_attr(idx);\n    }\n    HL_TABLE()[idx].sg_script_ctx = current_sctx;\n    HL_TABLE()[idx].sg_script_ctx.sc_lnum += sourcing_lnum;\n  }\n  xfree(key);\n  xfree(arg);\n\n  // Only call highlight_changed() once, after a sequence of highlight\n  // commands, and only if an attribute actually changed\n  if ((did_change\n       || memcmp(&HL_TABLE()[idx], &item_before, sizeof(item_before)) != 0)\n      && !did_highlight_changed) {\n    // Do not trigger a redraw when highlighting is changed while\n    // redrawing.  This may happen when evaluating 'statusline' changes the\n    // StatusLine group.\n    if (!updating_screen) {\n      redraw_all_later(NOT_VALID);\n    }\n    need_highlight_changed = true;\n  }\n}\n\n#if defined(EXITFREE)\nvoid free_highlight(void)\n{\n  for (int i = 0; i < highlight_ga.ga_len; ++i) {\n    highlight_clear(i);\n    xfree(HL_TABLE()[i].sg_name);\n    xfree(HL_TABLE()[i].sg_name_u);\n  }\n  ga_clear(&highlight_ga);\n  map_destroy(cstr_t, int)(&highlight_unames);\n}\n\n#endif\n\n/*\n * Reset the cterm colors to what they were before Vim was started, if\n * possible.  Otherwise reset them to zero.\n */\nvoid restore_cterm_colors(void)\n{\n  normal_fg = -1;\n  normal_bg = -1;\n  normal_sp = -1;\n  cterm_normal_fg_color = 0;\n  cterm_normal_bg_color = 0;\n}\n\n/// @param check_link  if true also check for an existing link.\n///\n/// @return TRUE if highlight group \"idx\" has any settings.\nstatic int hl_has_settings(int idx, bool check_link)\n{\n  return HL_TABLE()[idx].sg_cleared == 0\n    && (HL_TABLE()[idx].sg_attr != 0\n        || HL_TABLE()[idx].sg_cterm_fg != 0\n        || HL_TABLE()[idx].sg_cterm_bg != 0\n        || HL_TABLE()[idx].sg_rgb_fg_name != NULL\n        || HL_TABLE()[idx].sg_rgb_bg_name != NULL\n        || HL_TABLE()[idx].sg_rgb_sp_name != NULL\n        || (check_link && (HL_TABLE()[idx].sg_set & SG_LINK)));\n}\n\n/*\n * Clear highlighting for one group.\n */\nstatic void highlight_clear(int idx)\n{\n  HL_TABLE()[idx].sg_cleared = true;\n\n  HL_TABLE()[idx].sg_attr = 0;\n  HL_TABLE()[idx].sg_cterm = 0;\n  HL_TABLE()[idx].sg_cterm_bold = false;\n  HL_TABLE()[idx].sg_cterm_fg = 0;\n  HL_TABLE()[idx].sg_cterm_bg = 0;\n  HL_TABLE()[idx].sg_gui = 0;\n  HL_TABLE()[idx].sg_rgb_fg = -1;\n  HL_TABLE()[idx].sg_rgb_bg = -1;\n  HL_TABLE()[idx].sg_rgb_sp = -1;\n  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_fg_name);\n  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_bg_name);\n  XFREE_CLEAR(HL_TABLE()[idx].sg_rgb_sp_name);\n  HL_TABLE()[idx].sg_blend = -1;\n  // Restore default link and context if they exist. Otherwise clears.\n  HL_TABLE()[idx].sg_link = HL_TABLE()[idx].sg_deflink;\n  // Since we set the default link, set the location to where the default\n  // link was set.\n  HL_TABLE()[idx].sg_script_ctx = HL_TABLE()[idx].sg_deflink_sctx;\n}\n\n\n/// \\addtogroup LIST_XXX\n/// @{\n#define LIST_ATTR   1\n#define LIST_STRING 2\n#define LIST_INT    3\n/// @}\n\nstatic void highlight_list_one(const int id)\n{\n  struct hl_group *const sgp = &HL_TABLE()[id - 1];  // index is ID minus one\n  bool didh = false;\n\n  if (message_filtered(sgp->sg_name)) {\n    return;\n  }\n\n  didh = highlight_list_arg(id, didh, LIST_ATTR,\n      sgp->sg_cterm, NULL, \"cterm\");\n  didh = highlight_list_arg(id, didh, LIST_INT,\n      sgp->sg_cterm_fg, NULL, \"ctermfg\");\n  didh = highlight_list_arg(id, didh, LIST_INT,\n      sgp->sg_cterm_bg, NULL, \"ctermbg\");\n\n  didh = highlight_list_arg(id, didh, LIST_ATTR,\n      sgp->sg_gui, NULL, \"gui\");\n  didh = highlight_list_arg(id, didh, LIST_STRING,\n      0, sgp->sg_rgb_fg_name, \"guifg\");\n  didh = highlight_list_arg(id, didh, LIST_STRING,\n      0, sgp->sg_rgb_bg_name, \"guibg\");\n  didh = highlight_list_arg(id, didh, LIST_STRING,\n                            0, sgp->sg_rgb_sp_name, \"guisp\");\n\n  didh = highlight_list_arg(id, didh, LIST_INT,\n                            sgp->sg_blend+1, NULL, \"blend\");\n\n  if (sgp->sg_link && !got_int) {\n    (void)syn_list_header(didh, 0, id, true);\n    didh = true;\n    msg_puts_attr(\"links to\", HL_ATTR(HLF_D));\n    msg_putchar(' ');\n    msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);\n  }\n\n  if (!didh) {\n    highlight_list_arg(id, didh, LIST_STRING, 0, \"cleared\", \"\");\n  }\n  if (p_verbose > 0) {\n    last_set_msg(sgp->sg_script_ctx);\n  }\n}\n\nDictionary get_global_hl_defs(void)\n{\n  Dictionary rv = ARRAY_DICT_INIT;\n  for (int i = 1; i <= highlight_ga.ga_len && !got_int; i++) {\n    Dictionary attrs = ARRAY_DICT_INIT;\n    struct hl_group *h = &HL_TABLE()[i - 1];\n    if (h->sg_attr > 0) {\n      attrs = hlattrs2dict(syn_attr2entry(h->sg_attr), true);\n    } else if (h->sg_link > 0) {\n      const char *link = (const char *)HL_TABLE()[h->sg_link - 1].sg_name;\n      PUT(attrs, \"link\", STRING_OBJ(cstr_to_string(link)));\n    }\n    PUT(rv, (const char *)h->sg_name, DICTIONARY_OBJ(attrs));\n  }\n\n  return rv;\n}\n\n/// Outputs a highlight when doing \":hi MyHighlight\"\n///\n/// @param type one of \\ref LIST_XXX\n/// @param iarg integer argument used if \\p type == LIST_INT\n/// @param sarg string used if \\p type == LIST_STRING\nstatic bool highlight_list_arg(\n    const int id, bool didh, const int type, int iarg,\n    char *const sarg, const char *const name)\n{\n  char buf[100];\n\n  if (got_int) {\n    return false;\n  }\n  if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0)) {\n    char *ts = buf;\n    if (type == LIST_INT) {\n      snprintf((char *)buf, sizeof(buf), \"%d\", iarg - 1);\n    } else if (type == LIST_STRING) {\n      ts = sarg;\n    } else {    // type == LIST_ATTR\n      buf[0] = NUL;\n      for (int i = 0; hl_attr_table[i] != 0; i++) {\n        if (iarg & hl_attr_table[i]) {\n          if (buf[0] != NUL)\n            xstrlcat((char *)buf, \",\", 100);\n          xstrlcat((char *)buf, hl_name_table[i], 100);\n          iarg &= ~hl_attr_table[i];                /* don't want \"inverse\" */\n        }\n      }\n    }\n\n    (void)syn_list_header(didh, (int)(vim_strsize((char_u *)ts) + STRLEN(name)\n                                      + 1), id, false);\n    didh = true;\n    if (!got_int) {\n      if (*name != NUL) {\n        MSG_PUTS_ATTR(name, HL_ATTR(HLF_D));\n        MSG_PUTS_ATTR(\"=\", HL_ATTR(HLF_D));\n      }\n      msg_outtrans((char_u *)ts);\n    }\n  }\n  return didh;\n}\n\n/// Check whether highlight group has attribute\n///\n/// @param[in]  id  Highlight group to check.\n/// @param[in]  flag  Attribute to check.\n/// @param[in]  modec  'g' for GUI, 'c' for term.\n///\n/// @return \"1\" if highlight group has attribute, NULL otherwise.\nconst char *highlight_has_attr(const int id, const int flag, const int modec)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE\n{\n  int attr;\n\n  if (id <= 0 || id > highlight_ga.ga_len) {\n    return NULL;\n  }\n\n  if (modec == 'g') {\n    attr = HL_TABLE()[id - 1].sg_gui;\n  } else {\n    attr = HL_TABLE()[id - 1].sg_cterm;\n  }\n\n  return (attr & flag) ? \"1\" : NULL;\n}\n\n/// Return color name of the given highlight group\n///\n/// @param[in]  id  Highlight group to work with.\n/// @param[in]  what  What to return: one of \"font\", \"fg\", \"bg\", \"sp\", \"fg#\",\n///                   \"bg#\" or \"sp#\".\n/// @param[in]  modec  'g' for GUI, 'c' for cterm and 't' for term.\n///\n/// @return color name, possibly in a static buffer. Buffer will be overwritten\n///         on next highlight_color() call. May return NULL.\nconst char *highlight_color(const int id, const char *const what,\n                            const int modec)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  static char name[20];\n  int n;\n  bool fg = false;\n  bool sp = false;\n  bool font = false;\n\n  if (id <= 0 || id > highlight_ga.ga_len) {\n    return NULL;\n  }\n\n  if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'g') {\n    fg = true;\n  } else if (TOLOWER_ASC(what[0]) == 'f' && TOLOWER_ASC(what[1]) == 'o'\n             && TOLOWER_ASC(what[2]) == 'n' && TOLOWER_ASC(what[3]) == 't') {\n    font = true;\n  } else if (TOLOWER_ASC(what[0]) == 's' && TOLOWER_ASC(what[1]) == 'p') {\n    sp = true;\n  } else if (!(TOLOWER_ASC(what[0]) == 'b' && TOLOWER_ASC(what[1]) == 'g')) {\n    return NULL;\n  }\n  if (modec == 'g') {\n    if (what[2] == '#' && ui_rgb_attached()) {\n      if (fg) {\n          n = HL_TABLE()[id - 1].sg_rgb_fg;\n      } else if (sp) {\n          n = HL_TABLE()[id - 1].sg_rgb_sp;\n      } else {\n          n = HL_TABLE()[id - 1].sg_rgb_bg;\n      }\n      if (n < 0 || n > 0xffffff) {\n        return NULL;\n      }\n      snprintf(name, sizeof(name), \"#%06x\", n);\n      return name;\n    }\n    if (fg) {\n      return (const char *)HL_TABLE()[id - 1].sg_rgb_fg_name;\n    }\n    if (sp) {\n      return (const char *)HL_TABLE()[id - 1].sg_rgb_sp_name;\n    }\n    return (const char *)HL_TABLE()[id - 1].sg_rgb_bg_name;\n  }\n  if (font || sp) {\n    return NULL;\n  }\n  if (modec == 'c') {\n    if (fg) {\n      n = HL_TABLE()[id - 1].sg_cterm_fg - 1;\n    } else {\n      n = HL_TABLE()[id - 1].sg_cterm_bg - 1;\n    }\n    if (n < 0) {\n      return NULL;\n    }\n    snprintf(name, sizeof(name), \"%d\", n);\n    return name;\n  }\n  // term doesn't have color.\n  return NULL;\n}\n\n/// Output the syntax list header.\n///\n/// @param did_header did header already\n/// @param outlen length of string that comes\n/// @param id highlight group id\n/// @param force_newline always start a new line\n/// @return true when started a new line.\nstatic bool syn_list_header(const bool did_header, const int outlen,\n                            const int id, bool force_newline)\n{\n  int endcol = 19;\n  bool newline = true;\n  bool adjust = true;\n\n  if (!did_header) {\n    msg_putchar('\\n');\n    if (got_int) {\n      return true;\n    }\n    msg_outtrans(HL_TABLE()[id - 1].sg_name);\n    endcol = 15;\n  } else if ((ui_has(kUIMessages) || msg_silent) && !force_newline) {\n    msg_putchar(' ');\n    adjust = false;\n  } else if (msg_col + outlen + 1 >= Columns || force_newline)   {\n    msg_putchar('\\n');\n    if (got_int) {\n      return true;\n    }\n  } else {\n    if (msg_col >= endcol) {    // wrap around is like starting a new line\n      newline = false;\n    }\n  }\n\n  if (adjust) {\n    if (msg_col >= endcol) {\n      // output at least one space\n      endcol = msg_col + 1;\n    }\n\n    msg_advance(endcol);\n  }\n\n  /* Show \"xxx\" with the attributes. */\n  if (!did_header) {\n    msg_puts_attr(\"xxx\", syn_id2attr(id));\n    msg_putchar(' ');\n  }\n\n  return newline;\n}\n\n/// Set the attribute numbers for a highlight group.\n/// Called after one of the attributes has changed.\n/// @param idx corrected highlight index\nstatic void set_hl_attr(int idx)\n{\n  HlAttrs at_en = HLATTRS_INIT;\n  struct hl_group     *sgp = HL_TABLE() + idx;\n\n  at_en.cterm_ae_attr = sgp->sg_cterm;\n  at_en.cterm_fg_color = sgp->sg_cterm_fg;\n  at_en.cterm_bg_color = sgp->sg_cterm_bg;\n  at_en.rgb_ae_attr = sgp->sg_gui;\n  // FIXME(tarruda): The \"unset value\" for rgb is -1, but since hlgroup is\n  // initialized with 0(by garray functions), check for sg_rgb_{f,b}g_name\n  // before setting attr_entry->{f,g}g_color to a other than -1\n  at_en.rgb_fg_color = sgp->sg_rgb_fg_name ? sgp->sg_rgb_fg : -1;\n  at_en.rgb_bg_color = sgp->sg_rgb_bg_name ? sgp->sg_rgb_bg : -1;\n  at_en.rgb_sp_color = sgp->sg_rgb_sp_name ? sgp->sg_rgb_sp : -1;\n  at_en.hl_blend = sgp->sg_blend;\n\n  sgp->sg_attr = hl_get_syn_attr(0, idx+1, at_en);\n\n  // a cursor style uses this syn_id, make sure its attribute is updated.\n  if (cursor_mode_uses_syn_id(idx+1)) {\n    ui_mode_info_set();\n  }\n}\n\nint syn_name2id(const char_u *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return syn_name2id_len(name, STRLEN(name));\n}\n\n/// Lookup a highlight group name and return its ID.\n///\n/// @param highlight name e.g. 'Cursor', 'Normal'\n/// @return the highlight id, else 0 if \\p name does not exist\nint syn_name2id_len(const char_u *name, size_t len)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char name_u[201];\n\n  if (len == 0 || len > 200) {\n    // ID names over 200 chars don't deserve to be found!\n    return 0;\n  }\n\n  // Avoid using stricmp() too much, it's slow on some systems */\n  // Avoid alloc()/free(), these are slow too.\n  memcpy(name_u, name, len);\n  name_u[len] = '\\0';\n  vim_strup((char_u *)name_u);\n\n  // map_get(..., int) returns 0 when no key is present, which is\n  // the expected value for missing highlight group.\n  return map_get(cstr_t, int)(&highlight_unames, name_u);\n}\n\n/// Lookup a highlight group name and return its attributes.\n/// Return zero if not found.\nint syn_name2attr(const char_u *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int id = syn_name2id(name);\n\n  if (id != 0) {\n    return syn_id2attr(id);\n  }\n  return 0;\n}\n\n/*\n * Return TRUE if highlight group \"name\" exists.\n */\nint highlight_exists(const char_u *name)\n{\n  return syn_name2id(name) > 0;\n}\n\n/*\n * Return the name of highlight group \"id\".\n * When not a valid ID return an empty string.\n */\nchar_u *syn_id2name(int id)\n{\n  if (id <= 0 || id > highlight_ga.ga_len)\n    return (char_u *)\"\";\n  return HL_TABLE()[id - 1].sg_name;\n}\n\n\n/// Find highlight group name in the table and return its ID.\n/// If it doesn't exist yet, a new entry is created.\n///\n/// @param pp Highlight group name\n/// @param len length of \\p pp\n///\n/// @return 0 for failure else the id of the group\nint syn_check_group(const char_u *name, int len)\n{\n  int id = syn_name2id_len(name, len);\n  if (id == 0) {  // doesn't exist yet\n    return syn_add_group(vim_strnsave(name, len));\n  }\n  return id;\n}\n\n/// Add new highlight group and return its ID.\n///\n/// @param name must be an allocated string, it will be consumed.\n/// @return 0 for failure, else the allocated group id\n/// @see syn_check_group syn_unadd_group\nstatic int syn_add_group(char_u *name)\n{\n  char_u      *p;\n\n  /* Check that the name is ASCII letters, digits and underscore. */\n  for (p = name; *p != NUL; ++p) {\n    if (!vim_isprintc(*p)) {\n      EMSG(_(\"E669: Unprintable character in group name\"));\n      xfree(name);\n      return 0;\n    } else if (!ASCII_ISALNUM(*p) && *p != '_')   {\n      /* This is an error, but since there previously was no check only\n       * give a warning. */\n      msg_source(HL_ATTR(HLF_W));\n      MSG(_(\"W18: Invalid character in group name\"));\n      break;\n    }\n  }\n\n  /*\n   * First call for this growarray: init growing array.\n   */\n  if (highlight_ga.ga_data == NULL) {\n    highlight_ga.ga_itemsize = sizeof(struct hl_group);\n    ga_set_growsize(&highlight_ga, 10);\n  }\n\n  if (highlight_ga.ga_len >= MAX_HL_ID) {\n    EMSG(_(\"E849: Too many highlight and syntax groups\"));\n    xfree(name);\n    return 0;\n  }\n\n  char *const name_up = (char *)vim_strsave_up(name);\n\n  // Append another syntax_highlight entry.\n  struct hl_group* hlgp = GA_APPEND_VIA_PTR(struct hl_group, &highlight_ga);\n  memset(hlgp, 0, sizeof(*hlgp));\n  hlgp->sg_name = name;\n  hlgp->sg_rgb_bg = -1;\n  hlgp->sg_rgb_fg = -1;\n  hlgp->sg_rgb_sp = -1;\n  hlgp->sg_blend = -1;\n  hlgp->sg_name_u = name_up;\n\n  int id = highlight_ga.ga_len;  // ID is index plus one\n\n  map_put(cstr_t, int)(&highlight_unames, name_up, id);\n\n  return id;\n}\n\n/// When, just after calling syn_add_group(), an error is discovered, this\n/// function deletes the new name.\nstatic void syn_unadd_group(void)\n{\n  highlight_ga.ga_len--;\n  HlGroup *item = &HL_TABLE()[highlight_ga.ga_len];\n  map_del(cstr_t, int)(&highlight_unames, item->sg_name_u);\n  xfree(item->sg_name);\n  xfree(item->sg_name_u);\n}\n\n\n/// Translate a group ID to highlight attributes.\n/// @see syn_attr2entry\nint syn_id2attr(int hl_id)\n{\n  hl_id = syn_get_final_id(hl_id);\n  struct hl_group *sgp = &HL_TABLE()[hl_id - 1];  // index is ID minus one\n\n  int attr = ns_get_hl(-1, hl_id, false, sgp->sg_set);\n  if (attr >= 0) {\n    return attr;\n  }\n  return sgp->sg_attr;\n}\n\n\n\n\n/*\n * Translate a group ID to the final group ID (following links).\n */\nint syn_get_final_id(int hl_id)\n{\n  int count;\n\n  if (hl_id > highlight_ga.ga_len || hl_id < 1)\n    return 0;                           /* Can be called from eval!! */\n\n  /*\n   * Follow links until there is no more.\n   * Look out for loops!  Break after 100 links.\n   */\n  for (count = 100; --count >= 0; ) {\n    struct hl_group *sgp = &HL_TABLE()[hl_id - 1];  // index is ID minus one\n\n    // ACHTUNG: when using \"tmp\" attribute (no link) the function might be\n    // called twice. it needs be smart enough to remember attr only to\n    // syn_id2attr time\n    int check = ns_get_hl(-1, hl_id, true, sgp->sg_set);\n    if (check == 0) {\n      return hl_id;  // how dare! it broke the link!\n    } else if (check > 0) {\n      hl_id = check;\n      continue;\n    }\n\n\n    if (sgp->sg_link == 0 || sgp->sg_link > highlight_ga.ga_len) {\n      break;\n    }\n    hl_id = sgp->sg_link;\n  }\n\n  return hl_id;\n}\n\n/// Refresh the color attributes of all highlight groups.\nvoid highlight_attr_set_all(void)\n{\n  for (int idx = 0; idx < highlight_ga.ga_len; idx++) {\n    struct hl_group *sgp = &HL_TABLE()[idx];\n    if (sgp->sg_rgb_bg_name != NULL) {\n      sgp->sg_rgb_bg = name_to_color(sgp->sg_rgb_bg_name);\n    }\n    if (sgp->sg_rgb_fg_name != NULL) {\n      sgp->sg_rgb_fg = name_to_color(sgp->sg_rgb_fg_name);\n    }\n    if (sgp->sg_rgb_sp_name != NULL) {\n      sgp->sg_rgb_sp = name_to_color(sgp->sg_rgb_sp_name);\n    }\n    set_hl_attr(idx);\n  }\n}\n\n// Apply difference between User[1-9] and HLF_S to HLF_SNC.\nstatic void combine_stl_hlt(int id, int id_S, int id_alt, int hlcnt, int i,\n                            int hlf, int *table)\n  FUNC_ATTR_NONNULL_ALL\n{\n  struct hl_group *const hlt = HL_TABLE();\n\n  if (id_alt == 0) {\n    memset(&hlt[hlcnt + i], 0, sizeof(struct hl_group));\n    hlt[hlcnt + i].sg_cterm = highlight_attr[hlf];\n    hlt[hlcnt + i].sg_gui = highlight_attr[hlf];\n  } else {\n    memmove(&hlt[hlcnt + i], &hlt[id_alt - 1], sizeof(struct hl_group));\n  }\n  hlt[hlcnt + i].sg_link = 0;\n\n  hlt[hlcnt + i].sg_cterm ^= hlt[id - 1].sg_cterm ^ hlt[id_S - 1].sg_cterm;\n  if (hlt[id - 1].sg_cterm_fg != hlt[id_S - 1].sg_cterm_fg) {\n    hlt[hlcnt + i].sg_cterm_fg = hlt[id - 1].sg_cterm_fg;\n  }\n  if (hlt[id - 1].sg_cterm_bg != hlt[id_S - 1].sg_cterm_bg) {\n    hlt[hlcnt + i].sg_cterm_bg = hlt[id - 1].sg_cterm_bg;\n  }\n  hlt[hlcnt + i].sg_gui ^= hlt[id - 1].sg_gui ^ hlt[id_S - 1].sg_gui;\n  if (hlt[id - 1].sg_rgb_fg != hlt[id_S - 1].sg_rgb_fg) {\n    hlt[hlcnt + i].sg_rgb_fg = hlt[id - 1].sg_rgb_fg;\n  }\n  if (hlt[id - 1].sg_rgb_bg != hlt[id_S - 1].sg_rgb_bg) {\n    hlt[hlcnt + i].sg_rgb_bg = hlt[id - 1].sg_rgb_bg;\n  }\n  if (hlt[id - 1].sg_rgb_sp != hlt[id_S - 1].sg_rgb_sp) {\n    hlt[hlcnt + i].sg_rgb_sp = hlt[id - 1].sg_rgb_sp;\n  }\n  highlight_ga.ga_len = hlcnt + i + 1;\n  set_hl_attr(hlcnt + i);  // At long last we can apply\n  table[i] = syn_id2attr(hlcnt + i + 1);\n}\n\n/// Translate highlight groups into attributes in highlight_attr[] and set up\n/// the user highlights User1..9. A set of corresponding highlights to use on\n/// top of HLF_SNC is computed.  Called only when nvim starts and upon first\n/// screen redraw after any :highlight command.\nvoid highlight_changed(void)\n{\n  int id;\n  char_u userhl[30];  // use 30 to avoid compiler warning\n  int id_S = -1;\n  int id_SNC = 0;\n  int hlcnt;\n\n  need_highlight_changed = false;\n\n  /// Translate builtin highlight groups into attributes for quick lookup.\n  for (int hlf = 0; hlf < (int)HLF_COUNT; hlf++) {\n    id = syn_check_group((char_u *)hlf_names[hlf], STRLEN(hlf_names[hlf]));\n    if (id == 0) {\n      abort();\n    }\n    int final_id = syn_get_final_id(id);\n    if (hlf == (int)HLF_SNC) {\n      id_SNC = final_id;\n    } else if (hlf == (int)HLF_S) {\n      id_S = final_id;\n    }\n\n    highlight_attr[hlf] = hl_get_ui_attr(hlf, final_id,\n                                         hlf == (int)HLF_INACTIVE);\n\n    if (highlight_attr[hlf] != highlight_attr_last[hlf]) {\n      if (hlf == HLF_MSG) {\n        clear_cmdline = true;\n      }\n      ui_call_hl_group_set(cstr_as_string((char *)hlf_names[hlf]),\n                           highlight_attr[hlf]);\n      highlight_attr_last[hlf] = highlight_attr[hlf];\n    }\n  }\n\n  //\n  // Setup the user highlights\n  //\n  // Temporarily utilize 10 more hl entries:\n  // 9 for User1-User9 combined with StatusLineNC\n  // 1 for StatusLine default\n  // Must to be in there simultaneously in case of table overflows in\n  // get_attr_entry()\n  ga_grow(&highlight_ga, 10);\n  hlcnt = highlight_ga.ga_len;\n  if (id_S == -1) {\n    // Make sure id_S is always valid to simplify code below. Use the last entry\n    memset(&HL_TABLE()[hlcnt + 9], 0, sizeof(struct hl_group));\n    id_S = hlcnt + 10;\n  }\n  for (int i = 0; i < 9; i++) {\n    sprintf((char *)userhl, \"User%d\", i + 1);\n    id = syn_name2id(userhl);\n    if (id == 0) {\n      highlight_user[i] = 0;\n      highlight_stlnc[i] = 0;\n    } else {\n      highlight_user[i] = syn_id2attr(id);\n      combine_stl_hlt(id, id_S, id_SNC, hlcnt, i, HLF_SNC, highlight_stlnc);\n    }\n  }\n  highlight_ga.ga_len = hlcnt;\n}\n\n\n/*\n * Handle command line completion for :highlight command.\n */\nvoid set_context_in_highlight_cmd(expand_T *xp, const char *arg)\n{\n  // Default: expand group names.\n  xp->xp_context = EXPAND_HIGHLIGHT;\n  xp->xp_pattern = (char_u *)arg;\n  include_link = 2;\n  include_default = 1;\n\n  /* (part of) subcommand already typed */\n  if (*arg != NUL) {\n    const char *p = (const char *)skiptowhite((const char_u *)arg);\n    if (*p != NUL) {  // Past \"default\" or group name.\n      include_default = 0;\n      if (strncmp(\"default\", arg, p - arg) == 0) {\n        arg = (const char *)skipwhite((const char_u *)p);\n        xp->xp_pattern = (char_u *)arg;\n        p = (const char *)skiptowhite((const char_u *)arg);\n      }\n      if (*p != NUL) {                          /* past group name */\n        include_link = 0;\n        if (arg[1] == 'i' && arg[0] == 'N') {\n          highlight_list();\n        }\n        if (strncmp(\"link\", arg, p - arg) == 0\n            || strncmp(\"clear\", arg, p - arg) == 0) {\n          xp->xp_pattern = skipwhite((const char_u *)p);\n          p = (const char *)skiptowhite(xp->xp_pattern);\n          if (*p != NUL) {  // Past first group name.\n            xp->xp_pattern = skipwhite((const char_u *)p);\n            p = (const char *)skiptowhite(xp->xp_pattern);\n          }\n        }\n        if (*p != NUL) {  // Past group name(s).\n          xp->xp_context = EXPAND_NOTHING;\n        }\n      }\n    }\n  }\n}\n\n/*\n * List highlighting matches in a nice way.\n */\nstatic void highlight_list(void)\n{\n  int i;\n\n  for (i = 10; --i >= 0; ) {\n    highlight_list_two(i, HL_ATTR(HLF_D));\n  }\n  for (i = 40; --i >= 0; ) {\n    highlight_list_two(99, 0);\n  }\n}\n\nstatic void highlight_list_two(int cnt, int attr)\n{\n  msg_puts_attr(&(\"N \\bI \\b!  \\b\"[cnt / 11]), attr);\n  msg_clr_eos();\n  ui_flush();\n  os_delay(cnt == 99 ? 40L : (long)cnt * 50L, false);\n}\n\n\n/// Function given to ExpandGeneric() to obtain the list of group names.\nconst char *get_highlight_name(expand_T *const xp, int idx)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return get_highlight_name_ext(xp, idx, true);\n}\n\n\n/// Obtain a highlight group name.\n///\n/// @param skip_cleared  if true don't return a cleared entry.\nconst char *get_highlight_name_ext(expand_T *xp, int idx, bool skip_cleared)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (idx < 0) {\n    return NULL;\n  }\n\n  // Items are never removed from the table, skip the ones that were cleared.\n  if (skip_cleared && idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared) {\n    return \"\";\n  }\n\n  if (idx == highlight_ga.ga_len && include_none != 0) {\n    return \"none\";\n  } else if (idx == highlight_ga.ga_len + include_none\n             && include_default != 0) {\n    return \"default\";\n  } else if (idx == highlight_ga.ga_len + include_none + include_default\n             && include_link != 0) {\n    return \"link\";\n  } else if (idx == highlight_ga.ga_len + include_none + include_default + 1\n             && include_link != 0) {\n    return \"clear\";\n  } else if (idx >= highlight_ga.ga_len) {\n    return NULL;\n  }\n  return (const char *)HL_TABLE()[idx].sg_name;\n}\n\ncolor_name_table_T color_name_table[] = {\n  // Colors from rgb.txt\n  { \"AliceBlue\", RGB_(0xf0, 0xf8, 0xff) },\n  { \"AntiqueWhite\", RGB_(0xfa, 0xeb, 0xd7) },\n  { \"AntiqueWhite1\", RGB_(0xff, 0xef, 0xdb) },\n  { \"AntiqueWhite2\", RGB_(0xee, 0xdf, 0xcc) },\n  { \"AntiqueWhite3\", RGB_(0xcd, 0xc0, 0xb0) },\n  { \"AntiqueWhite4\", RGB_(0x8b, 0x83, 0x78) },\n  { \"Aqua\", RGB_(0x00, 0xff, 0xff) },\n  { \"Aquamarine\", RGB_(0x7f, 0xff, 0xd4) },\n  { \"Aquamarine1\", RGB_(0x7f, 0xff, 0xd4) },\n  { \"Aquamarine2\", RGB_(0x76, 0xee, 0xc6) },\n  { \"Aquamarine3\", RGB_(0x66, 0xcd, 0xaa) },\n  { \"Aquamarine4\", RGB_(0x45, 0x8b, 0x74) },\n  { \"Azure\", RGB_(0xf0, 0xff, 0xff) },\n  { \"Azure1\", RGB_(0xf0, 0xff, 0xff) },\n  { \"Azure2\", RGB_(0xe0, 0xee, 0xee) },\n  { \"Azure3\", RGB_(0xc1, 0xcd, 0xcd) },\n  { \"Azure4\", RGB_(0x83, 0x8b, 0x8b) },\n  { \"Beige\", RGB_(0xf5, 0xf5, 0xdc) },\n  { \"Bisque\", RGB_(0xff, 0xe4, 0xc4) },\n  { \"Bisque1\", RGB_(0xff, 0xe4, 0xc4) },\n  { \"Bisque2\", RGB_(0xee, 0xd5, 0xb7) },\n  { \"Bisque3\", RGB_(0xcd, 0xb7, 0x9e) },\n  { \"Bisque4\", RGB_(0x8b, 0x7d, 0x6b) },\n  { \"Black\", RGB_(0x00, 0x00, 0x00) },\n  { \"BlanchedAlmond\", RGB_(0xff, 0xeb, 0xcd) },\n  { \"Blue\", RGB_(0x00, 0x00, 0xff) },\n  { \"Blue1\", RGB_(0x0, 0x0, 0xff) },\n  { \"Blue2\", RGB_(0x0, 0x0, 0xee) },\n  { \"Blue3\", RGB_(0x0, 0x0, 0xcd) },\n  { \"Blue4\", RGB_(0x0, 0x0, 0x8b) },\n  { \"BlueViolet\", RGB_(0x8a, 0x2b, 0xe2) },\n  { \"Brown\", RGB_(0xa5, 0x2a, 0x2a) },\n  { \"Brown1\", RGB_(0xff, 0x40, 0x40) },\n  { \"Brown2\", RGB_(0xee, 0x3b, 0x3b) },\n  { \"Brown3\", RGB_(0xcd, 0x33, 0x33) },\n  { \"Brown4\", RGB_(0x8b, 0x23, 0x23) },\n  { \"BurlyWood\", RGB_(0xde, 0xb8, 0x87) },\n  { \"Burlywood1\", RGB_(0xff, 0xd3, 0x9b) },\n  { \"Burlywood2\", RGB_(0xee, 0xc5, 0x91) },\n  { \"Burlywood3\", RGB_(0xcd, 0xaa, 0x7d) },\n  { \"Burlywood4\", RGB_(0x8b, 0x73, 0x55) },\n  { \"CadetBlue\", RGB_(0x5f, 0x9e, 0xa0) },\n  { \"CadetBlue1\", RGB_(0x98, 0xf5, 0xff) },\n  { \"CadetBlue2\", RGB_(0x8e, 0xe5, 0xee) },\n  { \"CadetBlue3\", RGB_(0x7a, 0xc5, 0xcd) },\n  { \"CadetBlue4\", RGB_(0x53, 0x86, 0x8b) },\n  { \"ChartReuse\", RGB_(0x7f, 0xff, 0x00) },\n  { \"Chartreuse1\", RGB_(0x7f, 0xff, 0x0) },\n  { \"Chartreuse2\", RGB_(0x76, 0xee, 0x0) },\n  { \"Chartreuse3\", RGB_(0x66, 0xcd, 0x0) },\n  { \"Chartreuse4\", RGB_(0x45, 0x8b, 0x0) },\n  { \"Chocolate\", RGB_(0xd2, 0x69, 0x1e) },\n  { \"Chocolate1\", RGB_(0xff, 0x7f, 0x24) },\n  { \"Chocolate2\", RGB_(0xee, 0x76, 0x21) },\n  { \"Chocolate3\", RGB_(0xcd, 0x66, 0x1d) },\n  { \"Chocolate4\", RGB_(0x8b, 0x45, 0x13) },\n  { \"Coral\", RGB_(0xff, 0x7f, 0x50) },\n  { \"Coral1\", RGB_(0xff, 0x72, 0x56) },\n  { \"Coral2\", RGB_(0xee, 0x6a, 0x50) },\n  { \"Coral3\", RGB_(0xcd, 0x5b, 0x45) },\n  { \"Coral4\", RGB_(0x8b, 0x3e, 0x2f) },\n  { \"CornFlowerBlue\", RGB_(0x64, 0x95, 0xed) },\n  { \"Cornsilk\", RGB_(0xff, 0xf8, 0xdc) },\n  { \"Cornsilk1\", RGB_(0xff, 0xf8, 0xdc) },\n  { \"Cornsilk2\", RGB_(0xee, 0xe8, 0xcd) },\n  { \"Cornsilk3\", RGB_(0xcd, 0xc8, 0xb1) },\n  { \"Cornsilk4\", RGB_(0x8b, 0x88, 0x78) },\n  { \"Crimson\", RGB_(0xdc, 0x14, 0x3c) },\n  { \"Cyan\", RGB_(0x00, 0xff, 0xff) },\n  { \"Cyan1\", RGB_(0x0, 0xff, 0xff) },\n  { \"Cyan2\", RGB_(0x0, 0xee, 0xee) },\n  { \"Cyan3\", RGB_(0x0, 0xcd, 0xcd) },\n  { \"Cyan4\", RGB_(0x0, 0x8b, 0x8b) },\n  { \"DarkBlue\", RGB_(0x00, 0x00, 0x8b) },\n  { \"DarkCyan\", RGB_(0x00, 0x8b, 0x8b) },\n  { \"DarkGoldenRod\", RGB_(0xb8, 0x86, 0x0b) },\n  { \"DarkGoldenrod1\", RGB_(0xff, 0xb9, 0xf) },\n  { \"DarkGoldenrod2\", RGB_(0xee, 0xad, 0xe) },\n  { \"DarkGoldenrod3\", RGB_(0xcd, 0x95, 0xc) },\n  { \"DarkGoldenrod4\", RGB_(0x8b, 0x65, 0x8) },\n  { \"DarkGray\", RGB_(0xa9, 0xa9, 0xa9) },\n  { \"DarkGreen\", RGB_(0x00, 0x64, 0x00) },\n  { \"DarkGrey\", RGB_(0xa9, 0xa9, 0xa9) },\n  { \"DarkKhaki\", RGB_(0xbd, 0xb7, 0x6b) },\n  { \"DarkMagenta\", RGB_(0x8b, 0x00, 0x8b) },\n  { \"DarkOliveGreen\", RGB_(0x55, 0x6b, 0x2f) },\n  { \"DarkOliveGreen1\", RGB_(0xca, 0xff, 0x70) },\n  { \"DarkOliveGreen2\", RGB_(0xbc, 0xee, 0x68) },\n  { \"DarkOliveGreen3\", RGB_(0xa2, 0xcd, 0x5a) },\n  { \"DarkOliveGreen4\", RGB_(0x6e, 0x8b, 0x3d) },\n  { \"DarkOrange\", RGB_(0xff, 0x8c, 0x00) },\n  { \"DarkOrange1\", RGB_(0xff, 0x7f, 0x0) },\n  { \"DarkOrange2\", RGB_(0xee, 0x76, 0x0) },\n  { \"DarkOrange3\", RGB_(0xcd, 0x66, 0x0) },\n  { \"DarkOrange4\", RGB_(0x8b, 0x45, 0x0) },\n  { \"DarkOrchid\", RGB_(0x99, 0x32, 0xcc) },\n  { \"DarkOrchid1\", RGB_(0xbf, 0x3e, 0xff) },\n  { \"DarkOrchid2\", RGB_(0xb2, 0x3a, 0xee) },\n  { \"DarkOrchid3\", RGB_(0x9a, 0x32, 0xcd) },\n  { \"DarkOrchid4\", RGB_(0x68, 0x22, 0x8b) },\n  { \"DarkRed\", RGB_(0x8b, 0x00, 0x00) },\n  { \"DarkSalmon\", RGB_(0xe9, 0x96, 0x7a) },\n  { \"DarkSeaGreen\", RGB_(0x8f, 0xbc, 0x8f) },\n  { \"DarkSeaGreen1\", RGB_(0xc1, 0xff, 0xc1) },\n  { \"DarkSeaGreen2\", RGB_(0xb4, 0xee, 0xb4) },\n  { \"DarkSeaGreen3\", RGB_(0x9b, 0xcd, 0x9b) },\n  { \"DarkSeaGreen4\", RGB_(0x69, 0x8b, 0x69) },\n  { \"DarkSlateBlue\", RGB_(0x48, 0x3d, 0x8b) },\n  { \"DarkSlateGray\", RGB_(0x2f, 0x4f, 0x4f) },\n  { \"DarkSlateGray1\", RGB_(0x97, 0xff, 0xff) },\n  { \"DarkSlateGray2\", RGB_(0x8d, 0xee, 0xee) },\n  { \"DarkSlateGray3\", RGB_(0x79, 0xcd, 0xcd) },\n  { \"DarkSlateGray4\", RGB_(0x52, 0x8b, 0x8b) },\n  { \"DarkSlateGrey\", RGB_(0x2f, 0x4f, 0x4f) },\n  { \"DarkTurquoise\", RGB_(0x00, 0xce, 0xd1) },\n  { \"DarkViolet\", RGB_(0x94, 0x00, 0xd3) },\n  { \"DarkYellow\", RGB_(0xbb, 0xbb, 0x00) },\n  { \"DeepPink\", RGB_(0xff, 0x14, 0x93) },\n  { \"DeepPink1\", RGB_(0xff, 0x14, 0x93) },\n  { \"DeepPink2\", RGB_(0xee, 0x12, 0x89) },\n  { \"DeepPink3\", RGB_(0xcd, 0x10, 0x76) },\n  { \"DeepPink4\", RGB_(0x8b, 0xa, 0x50) },\n  { \"DeepSkyBlue\", RGB_(0x00, 0xbf, 0xff) },\n  { \"DeepSkyBlue1\", RGB_(0x0, 0xbf, 0xff) },\n  { \"DeepSkyBlue2\", RGB_(0x0, 0xb2, 0xee) },\n  { \"DeepSkyBlue3\", RGB_(0x0, 0x9a, 0xcd) },\n  { \"DeepSkyBlue4\", RGB_(0x0, 0x68, 0x8b) },\n  { \"DimGray\", RGB_(0x69, 0x69, 0x69) },\n  { \"DimGrey\", RGB_(0x69, 0x69, 0x69) },\n  { \"DodgerBlue\", RGB_(0x1e, 0x90, 0xff) },\n  { \"DodgerBlue1\", RGB_(0x1e, 0x90, 0xff) },\n  { \"DodgerBlue2\", RGB_(0x1c, 0x86, 0xee) },\n  { \"DodgerBlue3\", RGB_(0x18, 0x74, 0xcd) },\n  { \"DodgerBlue4\", RGB_(0x10, 0x4e, 0x8b) },\n  { \"Firebrick\", RGB_(0xb2, 0x22, 0x22) },\n  { \"Firebrick1\", RGB_(0xff, 0x30, 0x30) },\n  { \"Firebrick2\", RGB_(0xee, 0x2c, 0x2c) },\n  { \"Firebrick3\", RGB_(0xcd, 0x26, 0x26) },\n  { \"Firebrick4\", RGB_(0x8b, 0x1a, 0x1a) },\n  { \"FloralWhite\", RGB_(0xff, 0xfa, 0xf0) },\n  { \"ForestGreen\", RGB_(0x22, 0x8b, 0x22) },\n  { \"Fuchsia\", RGB_(0xff, 0x00, 0xff) },\n  { \"Gainsboro\", RGB_(0xdc, 0xdc, 0xdc) },\n  { \"GhostWhite\", RGB_(0xf8, 0xf8, 0xff) },\n  { \"Gold\", RGB_(0xff, 0xd7, 0x00) },\n  { \"Gold1\", RGB_(0xff, 0xd7, 0x0) },\n  { \"Gold2\", RGB_(0xee, 0xc9, 0x0) },\n  { \"Gold3\", RGB_(0xcd, 0xad, 0x0) },\n  { \"Gold4\", RGB_(0x8b, 0x75, 0x0) },\n  { \"GoldenRod\", RGB_(0xda, 0xa5, 0x20) },\n  { \"Goldenrod1\", RGB_(0xff, 0xc1, 0x25) },\n  { \"Goldenrod2\", RGB_(0xee, 0xb4, 0x22) },\n  { \"Goldenrod3\", RGB_(0xcd, 0x9b, 0x1d) },\n  { \"Goldenrod4\", RGB_(0x8b, 0x69, 0x14) },\n  { \"Gray\", RGB_(0x80, 0x80, 0x80) },\n  { \"Gray0\", RGB_(0x0, 0x0, 0x0) },\n  { \"Gray1\", RGB_(0x3, 0x3, 0x3) },\n  { \"Gray10\", RGB_(0x1a, 0x1a, 0x1a) },\n  { \"Gray100\", RGB_(0xff, 0xff, 0xff) },\n  { \"Gray11\", RGB_(0x1c, 0x1c, 0x1c) },\n  { \"Gray12\", RGB_(0x1f, 0x1f, 0x1f) },\n  { \"Gray13\", RGB_(0x21, 0x21, 0x21) },\n  { \"Gray14\", RGB_(0x24, 0x24, 0x24) },\n  { \"Gray15\", RGB_(0x26, 0x26, 0x26) },\n  { \"Gray16\", RGB_(0x29, 0x29, 0x29) },\n  { \"Gray17\", RGB_(0x2b, 0x2b, 0x2b) },\n  { \"Gray18\", RGB_(0x2e, 0x2e, 0x2e) },\n  { \"Gray19\", RGB_(0x30, 0x30, 0x30) },\n  { \"Gray2\", RGB_(0x5, 0x5, 0x5) },\n  { \"Gray20\", RGB_(0x33, 0x33, 0x33) },\n  { \"Gray21\", RGB_(0x36, 0x36, 0x36) },\n  { \"Gray22\", RGB_(0x38, 0x38, 0x38) },\n  { \"Gray23\", RGB_(0x3b, 0x3b, 0x3b) },\n  { \"Gray24\", RGB_(0x3d, 0x3d, 0x3d) },\n  { \"Gray25\", RGB_(0x40, 0x40, 0x40) },\n  { \"Gray26\", RGB_(0x42, 0x42, 0x42) },\n  { \"Gray27\", RGB_(0x45, 0x45, 0x45) },\n  { \"Gray28\", RGB_(0x47, 0x47, 0x47) },\n  { \"Gray29\", RGB_(0x4a, 0x4a, 0x4a) },\n  { \"Gray3\", RGB_(0x8, 0x8, 0x8) },\n  { \"Gray30\", RGB_(0x4d, 0x4d, 0x4d) },\n  { \"Gray31\", RGB_(0x4f, 0x4f, 0x4f) },\n  { \"Gray32\", RGB_(0x52, 0x52, 0x52) },\n  { \"Gray33\", RGB_(0x54, 0x54, 0x54) },\n  { \"Gray34\", RGB_(0x57, 0x57, 0x57) },\n  { \"Gray35\", RGB_(0x59, 0x59, 0x59) },\n  { \"Gray36\", RGB_(0x5c, 0x5c, 0x5c) },\n  { \"Gray37\", RGB_(0x5e, 0x5e, 0x5e) },\n  { \"Gray38\", RGB_(0x61, 0x61, 0x61) },\n  { \"Gray39\", RGB_(0x63, 0x63, 0x63) },\n  { \"Gray4\", RGB_(0xa, 0xa, 0xa) },\n  { \"Gray40\", RGB_(0x66, 0x66, 0x66) },\n  { \"Gray41\", RGB_(0x69, 0x69, 0x69) },\n  { \"Gray42\", RGB_(0x6b, 0x6b, 0x6b) },\n  { \"Gray43\", RGB_(0x6e, 0x6e, 0x6e) },\n  { \"Gray44\", RGB_(0x70, 0x70, 0x70) },\n  { \"Gray45\", RGB_(0x73, 0x73, 0x73) },\n  { \"Gray46\", RGB_(0x75, 0x75, 0x75) },\n  { \"Gray47\", RGB_(0x78, 0x78, 0x78) },\n  { \"Gray48\", RGB_(0x7a, 0x7a, 0x7a) },\n  { \"Gray49\", RGB_(0x7d, 0x7d, 0x7d) },\n  { \"Gray5\", RGB_(0xd, 0xd, 0xd) },\n  { \"Gray50\", RGB_(0x7f, 0x7f, 0x7f) },\n  { \"Gray51\", RGB_(0x82, 0x82, 0x82) },\n  { \"Gray52\", RGB_(0x85, 0x85, 0x85) },\n  { \"Gray53\", RGB_(0x87, 0x87, 0x87) },\n  { \"Gray54\", RGB_(0x8a, 0x8a, 0x8a) },\n  { \"Gray55\", RGB_(0x8c, 0x8c, 0x8c) },\n  { \"Gray56\", RGB_(0x8f, 0x8f, 0x8f) },\n  { \"Gray57\", RGB_(0x91, 0x91, 0x91) },\n  { \"Gray58\", RGB_(0x94, 0x94, 0x94) },\n  { \"Gray59\", RGB_(0x96, 0x96, 0x96) },\n  { \"Gray6\", RGB_(0xf, 0xf, 0xf) },\n  { \"Gray60\", RGB_(0x99, 0x99, 0x99) },\n  { \"Gray61\", RGB_(0x9c, 0x9c, 0x9c) },\n  { \"Gray62\", RGB_(0x9e, 0x9e, 0x9e) },\n  { \"Gray63\", RGB_(0xa1, 0xa1, 0xa1) },\n  { \"Gray64\", RGB_(0xa3, 0xa3, 0xa3) },\n  { \"Gray65\", RGB_(0xa6, 0xa6, 0xa6) },\n  { \"Gray66\", RGB_(0xa8, 0xa8, 0xa8) },\n  { \"Gray67\", RGB_(0xab, 0xab, 0xab) },\n  { \"Gray68\", RGB_(0xad, 0xad, 0xad) },\n  { \"Gray69\", RGB_(0xb0, 0xb0, 0xb0) },\n  { \"Gray7\", RGB_(0x12, 0x12, 0x12) },\n  { \"Gray70\", RGB_(0xb3, 0xb3, 0xb3) },\n  { \"Gray71\", RGB_(0xb5, 0xb5, 0xb5) },\n  { \"Gray72\", RGB_(0xb8, 0xb8, 0xb8) },\n  { \"Gray73\", RGB_(0xba, 0xba, 0xba) },\n  { \"Gray74\", RGB_(0xbd, 0xbd, 0xbd) },\n  { \"Gray75\", RGB_(0xbf, 0xbf, 0xbf) },\n  { \"Gray76\", RGB_(0xc2, 0xc2, 0xc2) },\n  { \"Gray77\", RGB_(0xc4, 0xc4, 0xc4) },\n  { \"Gray78\", RGB_(0xc7, 0xc7, 0xc7) },\n  { \"Gray79\", RGB_(0xc9, 0xc9, 0xc9) },\n  { \"Gray8\", RGB_(0x14, 0x14, 0x14) },\n  { \"Gray80\", RGB_(0xcc, 0xcc, 0xcc) },\n  { \"Gray81\", RGB_(0xcf, 0xcf, 0xcf) },\n  { \"Gray82\", RGB_(0xd1, 0xd1, 0xd1) },\n  { \"Gray83\", RGB_(0xd4, 0xd4, 0xd4) },\n  { \"Gray84\", RGB_(0xd6, 0xd6, 0xd6) },\n  { \"Gray85\", RGB_(0xd9, 0xd9, 0xd9) },\n  { \"Gray86\", RGB_(0xdb, 0xdb, 0xdb) },\n  { \"Gray87\", RGB_(0xde, 0xde, 0xde) },\n  { \"Gray88\", RGB_(0xe0, 0xe0, 0xe0) },\n  { \"Gray89\", RGB_(0xe3, 0xe3, 0xe3) },\n  { \"Gray9\", RGB_(0x17, 0x17, 0x17) },\n  { \"Gray90\", RGB_(0xe5, 0xe5, 0xe5) },\n  { \"Gray91\", RGB_(0xe8, 0xe8, 0xe8) },\n  { \"Gray92\", RGB_(0xeb, 0xeb, 0xeb) },\n  { \"Gray93\", RGB_(0xed, 0xed, 0xed) },\n  { \"Gray94\", RGB_(0xf0, 0xf0, 0xf0) },\n  { \"Gray95\", RGB_(0xf2, 0xf2, 0xf2) },\n  { \"Gray96\", RGB_(0xf5, 0xf5, 0xf5) },\n  { \"Gray97\", RGB_(0xf7, 0xf7, 0xf7) },\n  { \"Gray98\", RGB_(0xfa, 0xfa, 0xfa) },\n  { \"Gray99\", RGB_(0xfc, 0xfc, 0xfc) },\n  { \"Green\", RGB_(0x00, 0x80, 0x00) },\n  { \"Green1\", RGB_(0x0, 0xff, 0x0) },\n  { \"Green2\", RGB_(0x0, 0xee, 0x0) },\n  { \"Green3\", RGB_(0x0, 0xcd, 0x0) },\n  { \"Green4\", RGB_(0x0, 0x8b, 0x0) },\n  { \"GreenYellow\", RGB_(0xad, 0xff, 0x2f) },\n  { \"Grey\", RGB_(0x80, 0x80, 0x80) },\n  { \"Grey0\", RGB_(0x0, 0x0, 0x0) },\n  { \"Grey1\", RGB_(0x3, 0x3, 0x3) },\n  { \"Grey10\", RGB_(0x1a, 0x1a, 0x1a) },\n  { \"Grey100\", RGB_(0xff, 0xff, 0xff) },\n  { \"Grey11\", RGB_(0x1c, 0x1c, 0x1c) },\n  { \"Grey12\", RGB_(0x1f, 0x1f, 0x1f) },\n  { \"Grey13\", RGB_(0x21, 0x21, 0x21) },\n  { \"Grey14\", RGB_(0x24, 0x24, 0x24) },\n  { \"Grey15\", RGB_(0x26, 0x26, 0x26) },\n  { \"Grey16\", RGB_(0x29, 0x29, 0x29) },\n  { \"Grey17\", RGB_(0x2b, 0x2b, 0x2b) },\n  { \"Grey18\", RGB_(0x2e, 0x2e, 0x2e) },\n  { \"Grey19\", RGB_(0x30, 0x30, 0x30) },\n  { \"Grey2\", RGB_(0x5, 0x5, 0x5) },\n  { \"Grey20\", RGB_(0x33, 0x33, 0x33) },\n  { \"Grey21\", RGB_(0x36, 0x36, 0x36) },\n  { \"Grey22\", RGB_(0x38, 0x38, 0x38) },\n  { \"Grey23\", RGB_(0x3b, 0x3b, 0x3b) },\n  { \"Grey24\", RGB_(0x3d, 0x3d, 0x3d) },\n  { \"Grey25\", RGB_(0x40, 0x40, 0x40) },\n  { \"Grey26\", RGB_(0x42, 0x42, 0x42) },\n  { \"Grey27\", RGB_(0x45, 0x45, 0x45) },\n  { \"Grey28\", RGB_(0x47, 0x47, 0x47) },\n  { \"Grey29\", RGB_(0x4a, 0x4a, 0x4a) },\n  { \"Grey3\", RGB_(0x8, 0x8, 0x8) },\n  { \"Grey30\", RGB_(0x4d, 0x4d, 0x4d) },\n  { \"Grey31\", RGB_(0x4f, 0x4f, 0x4f) },\n  { \"Grey32\", RGB_(0x52, 0x52, 0x52) },\n  { \"Grey33\", RGB_(0x54, 0x54, 0x54) },\n  { \"Grey34\", RGB_(0x57, 0x57, 0x57) },\n  { \"Grey35\", RGB_(0x59, 0x59, 0x59) },\n  { \"Grey36\", RGB_(0x5c, 0x5c, 0x5c) },\n  { \"Grey37\", RGB_(0x5e, 0x5e, 0x5e) },\n  { \"Grey38\", RGB_(0x61, 0x61, 0x61) },\n  { \"Grey39\", RGB_(0x63, 0x63, 0x63) },\n  { \"Grey4\", RGB_(0xa, 0xa, 0xa) },\n  { \"Grey40\", RGB_(0x66, 0x66, 0x66) },\n  { \"Grey41\", RGB_(0x69, 0x69, 0x69) },\n  { \"Grey42\", RGB_(0x6b, 0x6b, 0x6b) },\n  { \"Grey43\", RGB_(0x6e, 0x6e, 0x6e) },\n  { \"Grey44\", RGB_(0x70, 0x70, 0x70) },\n  { \"Grey45\", RGB_(0x73, 0x73, 0x73) },\n  { \"Grey46\", RGB_(0x75, 0x75, 0x75) },\n  { \"Grey47\", RGB_(0x78, 0x78, 0x78) },\n  { \"Grey48\", RGB_(0x7a, 0x7a, 0x7a) },\n  { \"Grey49\", RGB_(0x7d, 0x7d, 0x7d) },\n  { \"Grey5\", RGB_(0xd, 0xd, 0xd) },\n  { \"Grey50\", RGB_(0x7f, 0x7f, 0x7f) },\n  { \"Grey51\", RGB_(0x82, 0x82, 0x82) },\n  { \"Grey52\", RGB_(0x85, 0x85, 0x85) },\n  { \"Grey53\", RGB_(0x87, 0x87, 0x87) },\n  { \"Grey54\", RGB_(0x8a, 0x8a, 0x8a) },\n  { \"Grey55\", RGB_(0x8c, 0x8c, 0x8c) },\n  { \"Grey56\", RGB_(0x8f, 0x8f, 0x8f) },\n  { \"Grey57\", RGB_(0x91, 0x91, 0x91) },\n  { \"Grey58\", RGB_(0x94, 0x94, 0x94) },\n  { \"Grey59\", RGB_(0x96, 0x96, 0x96) },\n  { \"Grey6\", RGB_(0xf, 0xf, 0xf) },\n  { \"Grey60\", RGB_(0x99, 0x99, 0x99) },\n  { \"Grey61\", RGB_(0x9c, 0x9c, 0x9c) },\n  { \"Grey62\", RGB_(0x9e, 0x9e, 0x9e) },\n  { \"Grey63\", RGB_(0xa1, 0xa1, 0xa1) },\n  { \"Grey64\", RGB_(0xa3, 0xa3, 0xa3) },\n  { \"Grey65\", RGB_(0xa6, 0xa6, 0xa6) },\n  { \"Grey66\", RGB_(0xa8, 0xa8, 0xa8) },\n  { \"Grey67\", RGB_(0xab, 0xab, 0xab) },\n  { \"Grey68\", RGB_(0xad, 0xad, 0xad) },\n  { \"Grey69\", RGB_(0xb0, 0xb0, 0xb0) },\n  { \"Grey7\", RGB_(0x12, 0x12, 0x12) },\n  { \"Grey70\", RGB_(0xb3, 0xb3, 0xb3) },\n  { \"Grey71\", RGB_(0xb5, 0xb5, 0xb5) },\n  { \"Grey72\", RGB_(0xb8, 0xb8, 0xb8) },\n  { \"Grey73\", RGB_(0xba, 0xba, 0xba) },\n  { \"Grey74\", RGB_(0xbd, 0xbd, 0xbd) },\n  { \"Grey75\", RGB_(0xbf, 0xbf, 0xbf) },\n  { \"Grey76\", RGB_(0xc2, 0xc2, 0xc2) },\n  { \"Grey77\", RGB_(0xc4, 0xc4, 0xc4) },\n  { \"Grey78\", RGB_(0xc7, 0xc7, 0xc7) },\n  { \"Grey79\", RGB_(0xc9, 0xc9, 0xc9) },\n  { \"Grey8\", RGB_(0x14, 0x14, 0x14) },\n  { \"Grey80\", RGB_(0xcc, 0xcc, 0xcc) },\n  { \"Grey81\", RGB_(0xcf, 0xcf, 0xcf) },\n  { \"Grey82\", RGB_(0xd1, 0xd1, 0xd1) },\n  { \"Grey83\", RGB_(0xd4, 0xd4, 0xd4) },\n  { \"Grey84\", RGB_(0xd6, 0xd6, 0xd6) },\n  { \"Grey85\", RGB_(0xd9, 0xd9, 0xd9) },\n  { \"Grey86\", RGB_(0xdb, 0xdb, 0xdb) },\n  { \"Grey87\", RGB_(0xde, 0xde, 0xde) },\n  { \"Grey88\", RGB_(0xe0, 0xe0, 0xe0) },\n  { \"Grey89\", RGB_(0xe3, 0xe3, 0xe3) },\n  { \"Grey9\", RGB_(0x17, 0x17, 0x17) },\n  { \"Grey90\", RGB_(0xe5, 0xe5, 0xe5) },\n  { \"Grey91\", RGB_(0xe8, 0xe8, 0xe8) },\n  { \"Grey92\", RGB_(0xeb, 0xeb, 0xeb) },\n  { \"Grey93\", RGB_(0xed, 0xed, 0xed) },\n  { \"Grey94\", RGB_(0xf0, 0xf0, 0xf0) },\n  { \"Grey95\", RGB_(0xf2, 0xf2, 0xf2) },\n  { \"Grey96\", RGB_(0xf5, 0xf5, 0xf5) },\n  { \"Grey97\", RGB_(0xf7, 0xf7, 0xf7) },\n  { \"Grey98\", RGB_(0xfa, 0xfa, 0xfa) },\n  { \"Grey99\", RGB_(0xfc, 0xfc, 0xfc) },\n  { \"Honeydew\", RGB_(0xf0, 0xff, 0xf0) },\n  { \"Honeydew1\", RGB_(0xf0, 0xff, 0xf0) },\n  { \"Honeydew2\", RGB_(0xe0, 0xee, 0xe0) },\n  { \"Honeydew3\", RGB_(0xc1, 0xcd, 0xc1) },\n  { \"Honeydew4\", RGB_(0x83, 0x8b, 0x83) },\n  { \"HotPink\", RGB_(0xff, 0x69, 0xb4) },\n  { \"HotPink1\", RGB_(0xff, 0x6e, 0xb4) },\n  { \"HotPink2\", RGB_(0xee, 0x6a, 0xa7) },\n  { \"HotPink3\", RGB_(0xcd, 0x60, 0x90) },\n  { \"HotPink4\", RGB_(0x8b, 0x3a, 0x62) },\n  { \"IndianRed\", RGB_(0xcd, 0x5c, 0x5c) },\n  { \"IndianRed1\", RGB_(0xff, 0x6a, 0x6a) },\n  { \"IndianRed2\", RGB_(0xee, 0x63, 0x63) },\n  { \"IndianRed3\", RGB_(0xcd, 0x55, 0x55) },\n  { \"IndianRed4\", RGB_(0x8b, 0x3a, 0x3a) },\n  { \"Indigo\", RGB_(0x4b, 0x00, 0x82) },\n  { \"Ivory\", RGB_(0xff, 0xff, 0xf0) },\n  { \"Ivory1\", RGB_(0xff, 0xff, 0xf0) },\n  { \"Ivory2\", RGB_(0xee, 0xee, 0xe0) },\n  { \"Ivory3\", RGB_(0xcd, 0xcd, 0xc1) },\n  { \"Ivory4\", RGB_(0x8b, 0x8b, 0x83) },\n  { \"Khaki\", RGB_(0xf0, 0xe6, 0x8c) },\n  { \"Khaki1\", RGB_(0xff, 0xf6, 0x8f) },\n  { \"Khaki2\", RGB_(0xee, 0xe6, 0x85) },\n  { \"Khaki3\", RGB_(0xcd, 0xc6, 0x73) },\n  { \"Khaki4\", RGB_(0x8b, 0x86, 0x4e) },\n  { \"Lavender\", RGB_(0xe6, 0xe6, 0xfa) },\n  { \"LavenderBlush\", RGB_(0xff, 0xf0, 0xf5) },\n  { \"LavenderBlush1\", RGB_(0xff, 0xf0, 0xf5) },\n  { \"LavenderBlush2\", RGB_(0xee, 0xe0, 0xe5) },\n  { \"LavenderBlush3\", RGB_(0xcd, 0xc1, 0xc5) },\n  { \"LavenderBlush4\", RGB_(0x8b, 0x83, 0x86) },\n  { \"LawnGreen\", RGB_(0x7c, 0xfc, 0x00) },\n  { \"LemonChiffon\", RGB_(0xff, 0xfa, 0xcd) },\n  { \"LemonChiffon1\", RGB_(0xff, 0xfa, 0xcd) },\n  { \"LemonChiffon2\", RGB_(0xee, 0xe9, 0xbf) },\n  { \"LemonChiffon3\", RGB_(0xcd, 0xc9, 0xa5) },\n  { \"LemonChiffon4\", RGB_(0x8b, 0x89, 0x70) },\n  { \"LightBlue\", RGB_(0xad, 0xd8, 0xe6) },\n  { \"LightBlue1\", RGB_(0xbf, 0xef, 0xff) },\n  { \"LightBlue2\", RGB_(0xb2, 0xdf, 0xee) },\n  { \"LightBlue3\", RGB_(0x9a, 0xc0, 0xcd) },\n  { \"LightBlue4\", RGB_(0x68, 0x83, 0x8b) },\n  { \"LightCoral\", RGB_(0xf0, 0x80, 0x80) },\n  { \"LightCyan\", RGB_(0xe0, 0xff, 0xff) },\n  { \"LightCyan1\", RGB_(0xe0, 0xff, 0xff) },\n  { \"LightCyan2\", RGB_(0xd1, 0xee, 0xee) },\n  { \"LightCyan3\", RGB_(0xb4, 0xcd, 0xcd) },\n  { \"LightCyan4\", RGB_(0x7a, 0x8b, 0x8b) },\n  { \"LightGoldenrod\", RGB_(0xee, 0xdd, 0x82) },\n  { \"LightGoldenrod1\", RGB_(0xff, 0xec, 0x8b) },\n  { \"LightGoldenrod2\", RGB_(0xee, 0xdc, 0x82) },\n  { \"LightGoldenrod3\", RGB_(0xcd, 0xbe, 0x70) },\n  { \"LightGoldenrod4\", RGB_(0x8b, 0x81, 0x4c) },\n  { \"LightGoldenRodYellow\", RGB_(0xfa, 0xfa, 0xd2) },\n  { \"LightGray\", RGB_(0xd3, 0xd3, 0xd3) },\n  { \"LightGreen\", RGB_(0x90, 0xee, 0x90) },\n  { \"LightGrey\", RGB_(0xd3, 0xd3, 0xd3) },\n  { \"LightMagenta\", RGB_(0xff, 0xbb, 0xff) },\n  { \"LightPink\", RGB_(0xff, 0xb6, 0xc1) },\n  { \"LightPink1\", RGB_(0xff, 0xae, 0xb9) },\n  { \"LightPink2\", RGB_(0xee, 0xa2, 0xad) },\n  { \"LightPink3\", RGB_(0xcd, 0x8c, 0x95) },\n  { \"LightPink4\", RGB_(0x8b, 0x5f, 0x65) },\n  { \"LightRed\", RGB_(0xff, 0xbb, 0xbb) },\n  { \"LightSalmon\", RGB_(0xff, 0xa0, 0x7a) },\n  { \"LightSalmon1\", RGB_(0xff, 0xa0, 0x7a) },\n  { \"LightSalmon2\", RGB_(0xee, 0x95, 0x72) },\n  { \"LightSalmon3\", RGB_(0xcd, 0x81, 0x62) },\n  { \"LightSalmon4\", RGB_(0x8b, 0x57, 0x42) },\n  { \"LightSeaGreen\", RGB_(0x20, 0xb2, 0xaa) },\n  { \"LightSkyBlue\", RGB_(0x87, 0xce, 0xfa) },\n  { \"LightSkyBlue1\", RGB_(0xb0, 0xe2, 0xff) },\n  { \"LightSkyBlue2\", RGB_(0xa4, 0xd3, 0xee) },\n  { \"LightSkyBlue3\", RGB_(0x8d, 0xb6, 0xcd) },\n  { \"LightSkyBlue4\", RGB_(0x60, 0x7b, 0x8b) },\n  { \"LightSlateBlue\", RGB_(0x84, 0x70, 0xff) },\n  { \"LightSlateGray\", RGB_(0x77, 0x88, 0x99) },\n  { \"LightSlateGrey\", RGB_(0x77, 0x88, 0x99) },\n  { \"LightSteelBlue\", RGB_(0xb0, 0xc4, 0xde) },\n  { \"LightSteelBlue1\", RGB_(0xca, 0xe1, 0xff) },\n  { \"LightSteelBlue2\", RGB_(0xbc, 0xd2, 0xee) },\n  { \"LightSteelBlue3\", RGB_(0xa2, 0xb5, 0xcd) },\n  { \"LightSteelBlue4\", RGB_(0x6e, 0x7b, 0x8b) },\n  { \"LightYellow\", RGB_(0xff, 0xff, 0xe0) },\n  { \"LightYellow1\", RGB_(0xff, 0xff, 0xe0) },\n  { \"LightYellow2\", RGB_(0xee, 0xee, 0xd1) },\n  { \"LightYellow3\", RGB_(0xcd, 0xcd, 0xb4) },\n  { \"LightYellow4\", RGB_(0x8b, 0x8b, 0x7a) },\n  { \"Lime\", RGB_(0x00, 0xff, 0x00) },\n  { \"LimeGreen\", RGB_(0x32, 0xcd, 0x32) },\n  { \"Linen\", RGB_(0xfa, 0xf0, 0xe6) },\n  { \"Magenta\", RGB_(0xff, 0x00, 0xff) },\n  { \"Magenta1\", RGB_(0xff, 0x0, 0xff) },\n  { \"Magenta2\", RGB_(0xee, 0x0, 0xee) },\n  { \"Magenta3\", RGB_(0xcd, 0x0, 0xcd) },\n  { \"Magenta4\", RGB_(0x8b, 0x0, 0x8b) },\n  { \"Maroon\", RGB_(0x80, 0x00, 0x00) },\n  { \"Maroon1\", RGB_(0xff, 0x34, 0xb3) },\n  { \"Maroon2\", RGB_(0xee, 0x30, 0xa7) },\n  { \"Maroon3\", RGB_(0xcd, 0x29, 0x90) },\n  { \"Maroon4\", RGB_(0x8b, 0x1c, 0x62) },\n  { \"MediumAquamarine\", RGB_(0x66, 0xcd, 0xaa) },\n  { \"MediumBlue\", RGB_(0x00, 0x00, 0xcd) },\n  { \"MediumOrchid\", RGB_(0xba, 0x55, 0xd3) },\n  { \"MediumOrchid1\", RGB_(0xe0, 0x66, 0xff) },\n  { \"MediumOrchid2\", RGB_(0xd1, 0x5f, 0xee) },\n  { \"MediumOrchid3\", RGB_(0xb4, 0x52, 0xcd) },\n  { \"MediumOrchid4\", RGB_(0x7a, 0x37, 0x8b) },\n  { \"MediumPurple\", RGB_(0x93, 0x70, 0xdb) },\n  { \"MediumPurple1\", RGB_(0xab, 0x82, 0xff) },\n  { \"MediumPurple2\", RGB_(0x9f, 0x79, 0xee) },\n  { \"MediumPurple3\", RGB_(0x89, 0x68, 0xcd) },\n  { \"MediumPurple4\", RGB_(0x5d, 0x47, 0x8b) },\n  { \"MediumSeaGreen\", RGB_(0x3c, 0xb3, 0x71) },\n  { \"MediumSlateBlue\", RGB_(0x7b, 0x68, 0xee) },\n  { \"MediumSpringGreen\", RGB_(0x00, 0xfa, 0x9a) },\n  { \"MediumTurquoise\", RGB_(0x48, 0xd1, 0xcc) },\n  { \"MediumVioletRed\", RGB_(0xc7, 0x15, 0x85) },\n  { \"MidnightBlue\", RGB_(0x19, 0x19, 0x70) },\n  { \"MintCream\", RGB_(0xf5, 0xff, 0xfa) },\n  { \"MistyRose\", RGB_(0xff, 0xe4, 0xe1) },\n  { \"MistyRose1\", RGB_(0xff, 0xe4, 0xe1) },\n  { \"MistyRose2\", RGB_(0xee, 0xd5, 0xd2) },\n  { \"MistyRose3\", RGB_(0xcd, 0xb7, 0xb5) },\n  { \"MistyRose4\", RGB_(0x8b, 0x7d, 0x7b) },\n  { \"Moccasin\", RGB_(0xff, 0xe4, 0xb5) },\n  { \"NavajoWhite\", RGB_(0xff, 0xde, 0xad) },\n  { \"NavajoWhite1\", RGB_(0xff, 0xde, 0xad) },\n  { \"NavajoWhite2\", RGB_(0xee, 0xcf, 0xa1) },\n  { \"NavajoWhite3\", RGB_(0xcd, 0xb3, 0x8b) },\n  { \"NavajoWhite4\", RGB_(0x8b, 0x79, 0x5e) },\n  { \"Navy\", RGB_(0x00, 0x00, 0x80) },\n  { \"NavyBlue\", RGB_(0x0, 0x0, 0x80) },\n  { \"OldLace\", RGB_(0xfd, 0xf5, 0xe6) },\n  { \"Olive\", RGB_(0x80, 0x80, 0x00) },\n  { \"OliveDrab\", RGB_(0x6b, 0x8e, 0x23) },\n  { \"OliveDrab1\", RGB_(0xc0, 0xff, 0x3e) },\n  { \"OliveDrab2\", RGB_(0xb3, 0xee, 0x3a) },\n  { \"OliveDrab3\", RGB_(0x9a, 0xcd, 0x32) },\n  { \"OliveDrab4\", RGB_(0x69, 0x8b, 0x22) },\n  { \"Orange\", RGB_(0xff, 0xa5, 0x00) },\n  { \"Orange1\", RGB_(0xff, 0xa5, 0x0) },\n  { \"Orange2\", RGB_(0xee, 0x9a, 0x0) },\n  { \"Orange3\", RGB_(0xcd, 0x85, 0x0) },\n  { \"Orange4\", RGB_(0x8b, 0x5a, 0x0) },\n  { \"OrangeRed\", RGB_(0xff, 0x45, 0x00) },\n  { \"OrangeRed1\", RGB_(0xff, 0x45, 0x0) },\n  { \"OrangeRed2\", RGB_(0xee, 0x40, 0x0) },\n  { \"OrangeRed3\", RGB_(0xcd, 0x37, 0x0) },\n  { \"OrangeRed4\", RGB_(0x8b, 0x25, 0x0) },\n  { \"Orchid\", RGB_(0xda, 0x70, 0xd6) },\n  { \"Orchid1\", RGB_(0xff, 0x83, 0xfa) },\n  { \"Orchid2\", RGB_(0xee, 0x7a, 0xe9) },\n  { \"Orchid3\", RGB_(0xcd, 0x69, 0xc9) },\n  { \"Orchid4\", RGB_(0x8b, 0x47, 0x89) },\n  { \"PaleGoldenRod\", RGB_(0xee, 0xe8, 0xaa) },\n  { \"PaleGreen\", RGB_(0x98, 0xfb, 0x98) },\n  { \"PaleGreen1\", RGB_(0x9a, 0xff, 0x9a) },\n  { \"PaleGreen2\", RGB_(0x90, 0xee, 0x90) },\n  { \"PaleGreen3\", RGB_(0x7c, 0xcd, 0x7c) },\n  { \"PaleGreen4\", RGB_(0x54, 0x8b, 0x54) },\n  { \"PaleTurquoise\", RGB_(0xaf, 0xee, 0xee) },\n  { \"PaleTurquoise1\", RGB_(0xbb, 0xff, 0xff) },\n  { \"PaleTurquoise2\", RGB_(0xae, 0xee, 0xee) },\n  { \"PaleTurquoise3\", RGB_(0x96, 0xcd, 0xcd) },\n  { \"PaleTurquoise4\", RGB_(0x66, 0x8b, 0x8b) },\n  { \"PaleVioletRed\", RGB_(0xdb, 0x70, 0x93) },\n  { \"PaleVioletRed1\", RGB_(0xff, 0x82, 0xab) },\n  { \"PaleVioletRed2\", RGB_(0xee, 0x79, 0x9f) },\n  { \"PaleVioletRed3\", RGB_(0xcd, 0x68, 0x89) },\n  { \"PaleVioletRed4\", RGB_(0x8b, 0x47, 0x5d) },\n  { \"PapayaWhip\", RGB_(0xff, 0xef, 0xd5) },\n  { \"PeachPuff\", RGB_(0xff, 0xda, 0xb9) },\n  { \"PeachPuff1\", RGB_(0xff, 0xda, 0xb9) },\n  { \"PeachPuff2\", RGB_(0xee, 0xcb, 0xad) },\n  { \"PeachPuff3\", RGB_(0xcd, 0xaf, 0x95) },\n  { \"PeachPuff4\", RGB_(0x8b, 0x77, 0x65) },\n  { \"Peru\", RGB_(0xcd, 0x85, 0x3f) },\n  { \"Pink\", RGB_(0xff, 0xc0, 0xcb) },\n  { \"Pink1\", RGB_(0xff, 0xb5, 0xc5) },\n  { \"Pink2\", RGB_(0xee, 0xa9, 0xb8) },\n  { \"Pink3\", RGB_(0xcd, 0x91, 0x9e) },\n  { \"Pink4\", RGB_(0x8b, 0x63, 0x6c) },\n  { \"Plum\", RGB_(0xdd, 0xa0, 0xdd) },\n  { \"Plum1\", RGB_(0xff, 0xbb, 0xff) },\n  { \"Plum2\", RGB_(0xee, 0xae, 0xee) },\n  { \"Plum3\", RGB_(0xcd, 0x96, 0xcd) },\n  { \"Plum4\", RGB_(0x8b, 0x66, 0x8b) },\n  { \"PowderBlue\", RGB_(0xb0, 0xe0, 0xe6) },\n  { \"Purple\", RGB_(0x80, 0x00, 0x80) },\n  { \"Purple1\", RGB_(0x9b, 0x30, 0xff) },\n  { \"Purple2\", RGB_(0x91, 0x2c, 0xee) },\n  { \"Purple3\", RGB_(0x7d, 0x26, 0xcd) },\n  { \"Purple4\", RGB_(0x55, 0x1a, 0x8b) },\n  { \"RebeccaPurple\", RGB_(0x66, 0x33, 0x99) },\n  { \"Red\", RGB_(0xff, 0x00, 0x00) },\n  { \"Red1\", RGB_(0xff, 0x0, 0x0) },\n  { \"Red2\", RGB_(0xee, 0x0, 0x0) },\n  { \"Red3\", RGB_(0xcd, 0x0, 0x0) },\n  { \"Red4\", RGB_(0x8b, 0x0, 0x0) },\n  { \"RosyBrown\", RGB_(0xbc, 0x8f, 0x8f) },\n  { \"RosyBrown1\", RGB_(0xff, 0xc1, 0xc1) },\n  { \"RosyBrown2\", RGB_(0xee, 0xb4, 0xb4) },\n  { \"RosyBrown3\", RGB_(0xcd, 0x9b, 0x9b) },\n  { \"RosyBrown4\", RGB_(0x8b, 0x69, 0x69) },\n  { \"RoyalBlue\", RGB_(0x41, 0x69, 0xe1) },\n  { \"RoyalBlue1\", RGB_(0x48, 0x76, 0xff) },\n  { \"RoyalBlue2\", RGB_(0x43, 0x6e, 0xee) },\n  { \"RoyalBlue3\", RGB_(0x3a, 0x5f, 0xcd) },\n  { \"RoyalBlue4\", RGB_(0x27, 0x40, 0x8b) },\n  { \"SaddleBrown\", RGB_(0x8b, 0x45, 0x13) },\n  { \"Salmon\", RGB_(0xfa, 0x80, 0x72) },\n  { \"Salmon1\", RGB_(0xff, 0x8c, 0x69) },\n  { \"Salmon2\", RGB_(0xee, 0x82, 0x62) },\n  { \"Salmon3\", RGB_(0xcd, 0x70, 0x54) },\n  { \"Salmon4\", RGB_(0x8b, 0x4c, 0x39) },\n  { \"SandyBrown\", RGB_(0xf4, 0xa4, 0x60) },\n  { \"SeaGreen\", RGB_(0x2e, 0x8b, 0x57) },\n  { \"SeaGreen1\", RGB_(0x54, 0xff, 0x9f) },\n  { \"SeaGreen2\", RGB_(0x4e, 0xee, 0x94) },\n  { \"SeaGreen3\", RGB_(0x43, 0xcd, 0x80) },\n  { \"SeaGreen4\", RGB_(0x2e, 0x8b, 0x57) },\n  { \"SeaShell\", RGB_(0xff, 0xf5, 0xee) },\n  { \"Seashell1\", RGB_(0xff, 0xf5, 0xee) },\n  { \"Seashell2\", RGB_(0xee, 0xe5, 0xde) },\n  { \"Seashell3\", RGB_(0xcd, 0xc5, 0xbf) },\n  { \"Seashell4\", RGB_(0x8b, 0x86, 0x82) },\n  { \"Sienna\", RGB_(0xa0, 0x52, 0x2d) },\n  { \"Sienna1\", RGB_(0xff, 0x82, 0x47) },\n  { \"Sienna2\", RGB_(0xee, 0x79, 0x42) },\n  { \"Sienna3\", RGB_(0xcd, 0x68, 0x39) },\n  { \"Sienna4\", RGB_(0x8b, 0x47, 0x26) },\n  { \"Silver\", RGB_(0xc0, 0xc0, 0xc0) },\n  { \"SkyBlue\", RGB_(0x87, 0xce, 0xeb) },\n  { \"SkyBlue1\", RGB_(0x87, 0xce, 0xff) },\n  { \"SkyBlue2\", RGB_(0x7e, 0xc0, 0xee) },\n  { \"SkyBlue3\", RGB_(0x6c, 0xa6, 0xcd) },\n  { \"SkyBlue4\", RGB_(0x4a, 0x70, 0x8b) },\n  { \"SlateBlue\", RGB_(0x6a, 0x5a, 0xcd) },\n  { \"SlateBlue1\", RGB_(0x83, 0x6f, 0xff) },\n  { \"SlateBlue2\", RGB_(0x7a, 0x67, 0xee) },\n  { \"SlateBlue3\", RGB_(0x69, 0x59, 0xcd) },\n  { \"SlateBlue4\", RGB_(0x47, 0x3c, 0x8b) },\n  { \"SlateGray\", RGB_(0x70, 0x80, 0x90) },\n  { \"SlateGray1\", RGB_(0xc6, 0xe2, 0xff) },\n  { \"SlateGray2\", RGB_(0xb9, 0xd3, 0xee) },\n  { \"SlateGray3\", RGB_(0x9f, 0xb6, 0xcd) },\n  { \"SlateGray4\", RGB_(0x6c, 0x7b, 0x8b) },\n  { \"SlateGrey\", RGB_(0x70, 0x80, 0x90) },\n  { \"Snow\", RGB_(0xff, 0xfa, 0xfa) },\n  { \"Snow1\", RGB_(0xff, 0xfa, 0xfa) },\n  { \"Snow2\", RGB_(0xee, 0xe9, 0xe9) },\n  { \"Snow3\", RGB_(0xcd, 0xc9, 0xc9) },\n  { \"Snow4\", RGB_(0x8b, 0x89, 0x89) },\n  { \"SpringGreen\", RGB_(0x00, 0xff, 0x7f) },\n  { \"SpringGreen1\", RGB_(0x0, 0xff, 0x7f) },\n  { \"SpringGreen2\", RGB_(0x0, 0xee, 0x76) },\n  { \"SpringGreen3\", RGB_(0x0, 0xcd, 0x66) },\n  { \"SpringGreen4\", RGB_(0x0, 0x8b, 0x45) },\n  { \"SteelBlue\", RGB_(0x46, 0x82, 0xb4) },\n  { \"SteelBlue1\", RGB_(0x63, 0xb8, 0xff) },\n  { \"SteelBlue2\", RGB_(0x5c, 0xac, 0xee) },\n  { \"SteelBlue3\", RGB_(0x4f, 0x94, 0xcd) },\n  { \"SteelBlue4\", RGB_(0x36, 0x64, 0x8b) },\n  { \"Tan\", RGB_(0xd2, 0xb4, 0x8c) },\n  { \"Tan1\", RGB_(0xff, 0xa5, 0x4f) },\n  { \"Tan2\", RGB_(0xee, 0x9a, 0x49) },\n  { \"Tan3\", RGB_(0xcd, 0x85, 0x3f) },\n  { \"Tan4\", RGB_(0x8b, 0x5a, 0x2b) },\n  { \"Teal\", RGB_(0x00, 0x80, 0x80) },\n  { \"Thistle\", RGB_(0xd8, 0xbf, 0xd8) },\n  { \"Thistle1\", RGB_(0xff, 0xe1, 0xff) },\n  { \"Thistle2\", RGB_(0xee, 0xd2, 0xee) },\n  { \"Thistle3\", RGB_(0xcd, 0xb5, 0xcd) },\n  { \"Thistle4\", RGB_(0x8b, 0x7b, 0x8b) },\n  { \"Tomato\", RGB_(0xff, 0x63, 0x47) },\n  { \"Tomato1\", RGB_(0xff, 0x63, 0x47) },\n  { \"Tomato2\", RGB_(0xee, 0x5c, 0x42) },\n  { \"Tomato3\", RGB_(0xcd, 0x4f, 0x39) },\n  { \"Tomato4\", RGB_(0x8b, 0x36, 0x26) },\n  { \"Turquoise\", RGB_(0x40, 0xe0, 0xd0) },\n  { \"Turquoise1\", RGB_(0x0, 0xf5, 0xff) },\n  { \"Turquoise2\", RGB_(0x0, 0xe5, 0xee) },\n  { \"Turquoise3\", RGB_(0x0, 0xc5, 0xcd) },\n  { \"Turquoise4\", RGB_(0x0, 0x86, 0x8b) },\n  { \"Violet\", RGB_(0xee, 0x82, 0xee) },\n  { \"VioletRed\", RGB_(0xd0, 0x20, 0x90) },\n  { \"VioletRed1\", RGB_(0xff, 0x3e, 0x96) },\n  { \"VioletRed2\", RGB_(0xee, 0x3a, 0x8c) },\n  { \"VioletRed3\", RGB_(0xcd, 0x32, 0x78) },\n  { \"VioletRed4\", RGB_(0x8b, 0x22, 0x52) },\n  { \"WebGray\", RGB_(0x80, 0x80, 0x80) },\n  { \"WebGreen\", RGB_(0x0, 0x80, 0x0) },\n  { \"WebGrey\", RGB_(0x80, 0x80, 0x80) },\n  { \"WebMaroon\", RGB_(0x80, 0x0, 0x0) },\n  { \"WebPurple\", RGB_(0x80, 0x0, 0x80) },\n  { \"Wheat\", RGB_(0xf5, 0xde, 0xb3) },\n  { \"Wheat1\", RGB_(0xff, 0xe7, 0xba) },\n  { \"Wheat2\", RGB_(0xee, 0xd8, 0xae) },\n  { \"Wheat3\", RGB_(0xcd, 0xba, 0x96) },\n  { \"Wheat4\", RGB_(0x8b, 0x7e, 0x66) },\n  { \"White\", RGB_(0xff, 0xff, 0xff) },\n  { \"WhiteSmoke\", RGB_(0xf5, 0xf5, 0xf5) },\n  { \"X11Gray\", RGB_(0xbe, 0xbe, 0xbe) },\n  { \"X11Green\", RGB_(0x0, 0xff, 0x0) },\n  { \"X11Grey\", RGB_(0xbe, 0xbe, 0xbe) },\n  { \"X11Maroon\", RGB_(0xb0, 0x30, 0x60) },\n  { \"X11Purple\", RGB_(0xa0, 0x20, 0xf0) },\n  { \"Yellow\", RGB_(0xff, 0xff, 0x00) },\n  { \"Yellow1\", RGB_(0xff, 0xff, 0x0) },\n  { \"Yellow2\", RGB_(0xee, 0xee, 0x0) },\n  { \"Yellow3\", RGB_(0xcd, 0xcd, 0x0) },\n  { \"Yellow4\", RGB_(0x8b, 0x8b, 0x0) },\n  { \"YellowGreen\", RGB_(0x9a, 0xcd, 0x32) },\n  { NULL, 0 },\n};\n\n\n/// Translate to RgbValue if \\p name is an hex value (e.g. #XXXXXX),\n/// else look into color_name_table to translate a color name to  its\n/// hex value\n///\n/// @param[in] name string value to convert to RGB\n/// return the hex value or -1 if could not find a correct value\nRgbValue name_to_color(const char *name)\n{\n\n  if (name[0] == '#' && isxdigit(name[1]) && isxdigit(name[2])\n      && isxdigit(name[3]) && isxdigit(name[4]) && isxdigit(name[5])\n      && isxdigit(name[6]) && name[7] == NUL) {\n    // rgb hex string\n    return strtol((char *)(name + 1), NULL, 16);\n  } else if (!STRICMP(name, \"bg\") || !STRICMP(name, \"background\")) {\n    return normal_bg;\n  } else if (!STRICMP(name, \"fg\") || !STRICMP(name, \"foreground\")) {\n    return normal_fg;\n  }\n\n  for (int i = 0; color_name_table[i].name != NULL; i++) {\n    if (!STRICMP(name, color_name_table[i].name)) {\n      return color_name_table[i].color;\n    }\n  }\n\n  return -1;\n}\n\n\n/**************************************\n*  End of Highlighting stuff\t      *\n**************************************/\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 26, "line": 247}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 26, "line": 247}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "9e7e41cdede591f688fc3d4f778a8bd4", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 333}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 26, "line": 333}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "82f5161ec7eadf764e9270d63bc5a079", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 335}, "message": "(            ) (fixit)"}, {"location": {"col": 36, "file": 26, "line": 335}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "26305daf92739c646fe602f33663ee85", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 26, "line": 427}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "2f77b9b9764e6fd2f6d994e3b7231bfa", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 26, "line": 503}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "1a41cc199d48deecd7e37c681d76f695", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 26, "line": 1079}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "6600b03f45f0bf7cbac35b9ce5426ae8", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 26, "line": 1082}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "83fb25b494edaa2e4b5eece853830d0d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 26, "line": 1093}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "b98b79ea1e3f438db95712c86fc17f9f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 26, "line": 1172}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "1a41cc199d48deecd7e37c681d76f695", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 2060}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "a1ea001801715469d5c337347118870b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 26, "line": 2082}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "42ca7d53b627ae7232e6ce4d56e438e2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 26, "line": 2095}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "f7c28070aab6e110ff47a333ab118a43", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 26, "line": 2100}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "c098eb31414931c214e20d95d8c0b466", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 2198}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "abfbeeefb7bbf150a3ae5af9a3bacd2e", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 26, "line": 2224}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "7b08ca556cdc5a790eb3847ac73acf63", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 26, "line": 2234}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "7d95f286248883f2303d7538a85ca621", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 26, "line": 2300}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "2df465fc2ba8f17cf0fb9a212c07eee6", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 26, "line": 2307}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "3bbbbac36ff7213b7c66b719b1a6432a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 335}, "message": "expanded from macro 'ID_LIST_ALL'"}, {"location": {"col": 29, "file": 26, "line": 2384}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "7ee90c5f4a93a88091f2f89471ce9615", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 26, "line": 2912}, "message": "narrowing conversion from 'long' to signed type 'colnr_T' (aka 'int') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "cb13a3c4103e67f6418c729cbfb846d5", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 7, "file": 26, "line": 2913}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "66d559bc75ef3bdb46953fe7f98effc0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 26, "line": 3993}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "e91d9ce711b0c46a7024d1b4b8e100d6", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 26, "line": 4115}, "message": "comparison between 'signed char' and 'unsigned char'"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "bbbfe54506e8669e182cf77ddc9a91f7", "checkerName": "bugprone-signed-char-misuse", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 33, "file": 26, "line": 4115}, "message": "comparison between 'signed char' and 'unsigned char'"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "57a8a9d7ac8d34b561ba40518bdea69f", "checkerName": "bugprone-signed-char-misuse", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 26, "line": 4219}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "93e302602c98bd8ce785b3bf28dba432", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 26, "line": 4469}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "190c9da16a950c57c50699c8ff313542", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 26, "line": 4677}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "da755e14122358734862f7dcc7d71d4f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 53, "file": 26, "line": 4679}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "31635174d4e8ed3ad537decb6846ee94", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 26, "line": 4683}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "463d8e5ed21d25fa895922c908a9843d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 26, "line": 5061}, "message": "last of these clones ends here"}, {"location": {"col": 9, "file": 26, "line": 5060}, "message": "switch has 2 consecutive identical branches"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "f388fead8b6c513ffb01e2faace0ad3e", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 26, "line": 5066}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "522797be99a0223813ddee5912462cf2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 40, "file": 26, "line": 5130}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "06ffda62fe37bc21562f64748d669543", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 26, "line": 5134}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "64f2e39cd9ed0e70e0c99b8b2eb5722b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 26, "line": 5338}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "663237c556753008502026b06c5feb3b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 26, "line": 5361}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "a057b923380870665387fffa77d158e7", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 335}, "message": "expanded from macro 'ID_LIST_ALL'"}, {"location": {"col": 15, "file": 26, "line": 5457}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "4f19a112ca30fb95b793e879863852a2", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 8, "file": 26, "line": 5672}, "message": "end of the original"}, {"location": {"col": 14, "file": 26, "line": 5683}, "message": "clone 1 starts here"}, {"location": {"col": 48, "file": 26, "line": 5670}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "5b176d6350eadb44e946638fa91396ce", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 26, "line": 5844}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "05fe757fcb77a062e7e648e26e90bde0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 26, "line": 5939}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "bb5c978372e2bbce60ac5764ec2626fe", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 26, "line": 5940}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "173cc447002d2929e68f8f800aa7422e", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 26, "line": 5941}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "4fbf693c4f7e5724d59394f1c589a6cf", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 58, "file": 26, "line": 5943}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "d6daf8a45942b4f99f6f71673993f833", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 26, "line": 6609}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "357edb9a0ce2254da14ac9d4345bee14", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 26, "line": 6870}, "message": "end of the original"}, {"location": {"col": 75, "file": 26, "line": 7035}, "message": "clone 1 starts here"}, {"location": {"col": 46, "file": 26, "line": 6868}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "071d748081e09292a0bedb57856cccf6", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 26, "line": 6884}, "message": "'atoi' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "329129770157761ee00713e935a41fa5", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 26, "line": 6918}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "be7f642ddfd0a3a7e5dbc8f0fcb0363d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 26, "line": 7039}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "b712bd4a4e6846f520755fb172e7426c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 26, "line": 7450}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "2049440b0fc2c6f4f79c47bd6db1ed4b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 26, "line": 7453}, "message": "narrowing conversion from 'int' to signed type 'int16_t' (aka 'short') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "a50640133912010c8ffcfd8708ff1e61", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 26, "line": 8605}, "message": "narrowing conversion from 'long' to signed type 'RgbValue' (aka 'int') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/syntax.c", "reportHash": "bf8ce7a6112d4f5e38866d23a502734c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
