<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/shada.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <string.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <assert.h>\n\n#include <msgpack.h>\n#include <uv.h>\n\n#include \"nvim/os/os.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/pos.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/shada.h\"\n#include \"nvim/message.h\"\n#include \"nvim/globals.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/macros.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/option.h\"\n#include \"nvim/msgpack_rpc/helpers.h\"\n#include \"nvim/api/private/defs.h\"\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/buffer_defs.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/search.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/eval/typval.h\"\n#include \"nvim/version.h\"\n#include \"nvim/path.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/os/fileio.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/eval/encode.h\"\n#include \"nvim/eval/decode.h\"\n#include \"nvim/lib/khash.h\"\n#include \"nvim/lib/kvec.h\"\n\n#ifdef HAVE_BE64TOH\n# define _BSD_SOURCE 1\n# define _DEFAULT_SOURCE 1\n# include ENDIAN_INCLUDE_FILE\n#endif\n\n// Note: when using bufset hash pointers are intentionally casted to uintptr_t\n// and not to khint32_t or khint64_t: this way compiler must give a warning\n// (-Wconversion) when types change.\n#ifdef ARCH_32\nKHASH_SET_INIT_INT(bufset)\n#elif defined(ARCH_64)\nKHASH_SET_INIT_INT64(bufset)\n#else\n# error Not a 64- or 32-bit architecture\n#endif\nKHASH_MAP_INIT_STR(fnamebufs, buf_T *)\nKHASH_SET_INIT_STR(strset)\n\n#define copy_option_part(src, dest, ...) \\\n    ((char *) copy_option_part((char_u **) src, (char_u *) dest, __VA_ARGS__))\n#define find_shada_parameter(...) \\\n    ((const char *) find_shada_parameter(__VA_ARGS__))\n#define home_replace_save(a, b) \\\n    ((char *)home_replace_save(a, (char_u *)b))\n#define home_replace(a, b, c, d, e) \\\n    home_replace(a, (char_u *)b, (char_u *)c, d, e)\n#define vim_rename(a, b) \\\n    (vim_rename((char_u *)a, (char_u *)b))\n#define mb_strnicmp(a, b, c) \\\n    (mb_strnicmp((char_u *)a, (char_u *)b, c))\n#define path_try_shorten_fname(b) \\\n    ((char *)path_try_shorten_fname((char_u *)b))\n#define buflist_new(ffname, sfname, ...) \\\n    (buflist_new((char_u *)ffname, (char_u *)sfname, __VA_ARGS__))\n#define os_isdir(f) (os_isdir((char_u *) f))\n#define regtilde(s, m) ((char *) regtilde((char_u *) s, m))\n#define path_tail_with_sep(f) ((char *) path_tail_with_sep((char_u *)f))\n\n#define SEARCH_KEY_MAGIC \"sm\"\n#define SEARCH_KEY_SMARTCASE \"sc\"\n#define SEARCH_KEY_HAS_LINE_OFFSET \"sl\"\n#define SEARCH_KEY_PLACE_CURSOR_AT_END \"se\"\n#define SEARCH_KEY_IS_LAST_USED \"su\"\n#define SEARCH_KEY_IS_SUBSTITUTE_PATTERN \"ss\"\n#define SEARCH_KEY_HIGHLIGHTED \"sh\"\n#define SEARCH_KEY_OFFSET \"so\"\n#define SEARCH_KEY_PAT \"sp\"\n#define SEARCH_KEY_BACKWARD \"sb\"\n\n#define REG_KEY_TYPE \"rt\"\n#define REG_KEY_WIDTH \"rw\"\n#define REG_KEY_CONTENTS \"rc\"\n#define REG_KEY_UNNAMED \"ru\"\n\n#define KEY_LNUM \"l\"\n#define KEY_COL \"c\"\n#define KEY_FILE \"f\"\n#define KEY_NAME_CHAR \"n\"\n\n// Error messages formerly used by viminfo code:\n//   E136: viminfo: Too many errors, skipping rest of file\n//   E137: Viminfo file is not writable: %s\n//   E138: Can't write viminfo file %s!\n//   E195: Cannot open ShaDa file for reading\n//   E574: Unknown register type %d\n//   E575: Illegal starting char\n//   E576: Missing '>'\n//   E577: Illegal register name\n//   E886: Can't rename viminfo file to %s!\n//   E929: Too many viminfo temp files, like %s!\n// Now only six of them are used:\n//   E137: ShaDa file is not writeable (for pre-open checks)\n//   E929: All %s.tmp.X files exist, cannot write ShaDa file!\n//   RCERR (E576) for critical read errors.\n//   RNERR (E136) for various errors when renaming.\n//   RERR (E575) for various errors inside read ShaDa file.\n//   SERR (E886) for various \u201csystem\u201d errors (always contains output of\n//   strerror)\n//   WERR (E574) for various ignorable write errors\n\n/// Common prefix for all errors inside ShaDa file\n///\n/// I.e. errors occurred while parsing, but not system errors occurred while\n/// reading.\n#define RERR \"E575: \"\n\n/// Common prefix for critical read errors\n///\n/// I.e. errors that make shada_read_next_item return kSDReadStatusNotShaDa.\n#define RCERR \"E576: \"\n\n/// Common prefix for all \u201csystem\u201d errors\n#define SERR \"E886: \"\n\n/// Common prefix for all \u201crename\u201d errors\n#define RNERR \"E136: \"\n\n/// Common prefix for all ignorable \u201cwrite\u201d errors\n#define WERR \"E574: \"\n\n/// Callback function for add_search_pattern\ntypedef void (*SearchPatternGetter)(SearchPattern *);\n\n/// Possible ShaDa entry types\n///\n/// @warning Enum values are part of the API and must not be altered.\n///\n/// All values that are not in enum are ignored.\ntypedef enum {\n  kSDItemUnknown = -1,       ///< Unknown item.\n  kSDItemMissing = 0,        ///< Missing value. Should never appear in a file.\n  kSDItemHeader = 1,         ///< Header. Present for debugging purposes.\n  kSDItemSearchPattern = 2,  ///< Last search pattern (*not* history item).\n                             ///< Comes from user searches (e.g. when typing\n                             ///< \"/pat\") or :substitute command calls.\n  kSDItemSubString = 3,      ///< Last substitute replacement string.\n  kSDItemHistoryEntry = 4,   ///< History item.\n  kSDItemRegister = 5,       ///< Register.\n  kSDItemVariable = 6,       ///< Global variable.\n  kSDItemGlobalMark = 7,     ///< Global mark definition.\n  kSDItemJump = 8,           ///< Item from jump list.\n  kSDItemBufferList = 9,     ///< Buffer list.\n  kSDItemLocalMark = 10,     ///< Buffer-local mark.\n  kSDItemChange = 11,        ///< Item from buffer change list.\n#define SHADA_LAST_ENTRY ((uint64_t) kSDItemChange)\n} ShadaEntryType;\n\n/// Possible results when reading ShaDa file\ntypedef enum {\n  kSDReadStatusSuccess,    ///< Reading was successful.\n  kSDReadStatusFinished,   ///< Nothing more to read.\n  kSDReadStatusReadError,  ///< Failed to read from file.\n  kSDReadStatusNotShaDa,   ///< Input is most likely not a ShaDa file.\n  kSDReadStatusMalformed,  ///< Error in the currently read item.\n} ShaDaReadResult;\n\n/// Possible results of shada_write function.\ntypedef enum {\n  kSDWriteSuccessfull,   ///< Writing was successful.\n  kSDWriteReadNotShada,  ///< Writing was successful, but when reading it\n                         ///< attempted to read file that did not look like\n                         ///< a ShaDa file.\n  kSDWriteFailed,        ///< Writing was not successful (e.g. because there\n                         ///< was no space left on device).\n  kSDWriteIgnError,      ///< Writing resulted in a error which can be ignored\n                         ///< (e.g. when trying to dump a function reference or\n                         ///< self-referencing container in a variable).\n} ShaDaWriteResult;\n\n/// Flags for shada_read_next_item\nenum SRNIFlags {\n  kSDReadHeader = (1 << kSDItemHeader),  ///< Determines whether header should\n                                         ///< be read (it is usually ignored).\n  kSDReadUndisableableData = (\n      (1 << kSDItemSearchPattern)\n      | (1 << kSDItemSubString)\n      | (1 << kSDItemJump)),  ///< Data reading which cannot be disabled by\n                              ///< &shada or other options except for disabling\n                              ///< reading ShaDa as a whole.\n  kSDReadRegisters = (1 << kSDItemRegister),  ///< Determines whether registers\n                                              ///< should be read (may only be\n                                              ///< disabled when writing, but\n                                              ///< not when reading).\n  kSDReadHistory = (1 << kSDItemHistoryEntry),  ///< Determines whether history\n                                                ///< should be read (can only be\n                                                ///< disabled by &history).\n  kSDReadVariables = (1 << kSDItemVariable),  ///< Determines whether variables\n                                              ///< should be read (disabled by\n                                              ///< removing ! from &shada).\n  kSDReadBufferList = (1 << kSDItemBufferList),  ///< Determines whether buffer\n                                                 ///< list should be read\n                                                 ///< (disabled by removing\n                                                 ///< % entry from &shada).\n  kSDReadUnknown = (1 << (SHADA_LAST_ENTRY + 1)),  ///< Determines whether\n                                                   ///< unknown items should be\n                                                   ///< read (usually disabled).\n  kSDReadGlobalMarks = (1 << kSDItemGlobalMark),  ///< Determines whether global\n                                                  ///< marks should be read. Can\n                                                  ///< only be disabled by\n                                                  ///< having f0 in &shada when\n                                                  ///< writing.\n  kSDReadLocalMarks = (1 << kSDItemLocalMark),  ///< Determines whether local\n                                                ///< marks should be read. Can\n                                                ///< only be disabled by\n                                                ///< disabling &shada or putting\n                                                ///< '0 there. Is also used for\n                                                ///< v:oldfiles.\n  kSDReadChanges = (1 << kSDItemChange),  ///< Determines whether change list\n                                          ///< should be read. Can only be\n                                          ///< disabled by disabling &shada or\n                                          ///< putting '0 there.\n};\n// Note: SRNIFlags enum name was created only to make it possible to reference\n// it. This name is not actually used anywhere outside of the documentation.\n\n/// Structure defining a single ShaDa file entry\ntypedef struct {\n  ShadaEntryType type;\n  Timestamp timestamp;\n  union {\n    Dictionary header;\n    struct shada_filemark {\n      char name;\n      pos_T mark;\n      char *fname;\n      dict_T *additional_data;\n    } filemark;\n    struct search_pattern {\n      bool magic;\n      bool smartcase;\n      bool has_line_offset;\n      bool place_cursor_at_end;\n      int64_t offset;\n      bool is_last_used;\n      bool is_substitute_pattern;\n      bool highlighted;\n      bool search_backward;\n      char *pat;\n      dict_T *additional_data;\n    } search_pattern;\n    struct history_item {\n      uint8_t histtype;\n      char *string;\n      char sep;\n      list_T *additional_elements;\n    } history_item;\n    struct reg {  // yankreg_T\n      char name;\n      MotionType type;\n      char **contents;\n      bool is_unnamed;\n      size_t contents_size;\n      size_t width;\n      dict_T *additional_data;\n    } reg;\n    struct global_var {\n      char *name;\n      typval_T value;\n      list_T *additional_elements;\n    } global_var;\n    struct {\n      uint64_t type;\n      char *contents;\n      size_t size;\n    } unknown_item;\n    struct sub_string {\n      char *sub;\n      list_T *additional_elements;\n    } sub_string;\n    struct buffer_list {\n      size_t size;\n      struct buffer_list_buffer {\n        pos_T pos;\n        char *fname;\n        dict_T *additional_data;\n      } *buffers;\n    } buffer_list;\n  } data;\n} ShadaEntry;\n\nstruct hm_llist_entry;\n\n/// One entry in sized linked list\ntypedef struct hm_llist_entry {\n  ShadaEntry data;              ///< Entry data.\n  bool can_free_entry;          ///< True if data can be freed.\n  struct hm_llist_entry *next;  ///< Pointer to next entry or NULL.\n  struct hm_llist_entry *prev;  ///< Pointer to previous entry or NULL.\n} HMLListEntry;\n\nKHASH_MAP_INIT_STR(hmll_entries, HMLListEntry *)\n\n/// Sized linked list structure for history merger\ntypedef struct {\n  HMLListEntry *entries;  ///< Pointer to the start of the allocated array of\n                          ///< entries.\n  HMLListEntry *first;    ///< First entry in the list (is not necessary start\n                          ///< of the array) or NULL.\n  HMLListEntry *last;     ///< Last entry in the list or NULL.\n  HMLListEntry *free_entry;  ///< Last free entry removed by hmll_remove.\n  HMLListEntry *last_free_entry;  ///< Last unused element in entries array.\n  size_t size;            ///< Number of allocated entries.\n  size_t num_entries;     ///< Number of entries already used.\n  khash_t(hmll_entries) contained_entries;  ///< Hash mapping all history entry\n                                            ///< strings to corresponding entry\n                                            ///< pointers.\n} HMLList;\n\ntypedef struct {\n  HMLList hmll;\n  bool do_merge;\n  bool reading;\n  const void *iter;\n  ShadaEntry last_hist_entry;\n  uint8_t history_type;\n} HistoryMergerState;\n\n/// ShadaEntry structure that knows whether it should be freed\ntypedef struct {\n  ShadaEntry data;      ///< ShadaEntry data.\n  bool can_free_entry;  ///< True if entry can be freed.\n} PossiblyFreedShadaEntry;\n\n/// Structure that holds one file marks.\ntypedef struct {\n  PossiblyFreedShadaEntry marks[NLOCALMARKS];  ///< All file marks.\n  PossiblyFreedShadaEntry changes[JUMPLISTSIZE];  ///< All file changes.\n  size_t changes_size;  ///< Number of changes occupied.\n  ShadaEntry *additional_marks;  ///< All marks with unknown names.\n  size_t additional_marks_size;  ///< Size of the additional_marks array.\n  Timestamp greatest_timestamp;  ///< Greatest timestamp among marks.\n} FileMarks;\n\nKHASH_MAP_INIT_STR(file_marks, FileMarks)\n\n/// State structure used by shada_write\n///\n/// Before actually writing most of the data is read to this structure.\ntypedef struct {\n  HistoryMergerState hms[HIST_COUNT];  ///< Structures for history merging.\n  PossiblyFreedShadaEntry global_marks[NMARKS];  ///< Named global marks.\n  PossiblyFreedShadaEntry numbered_marks[EXTRA_MARKS];  ///< Numbered marks.\n  PossiblyFreedShadaEntry registers[NUM_SAVED_REGISTERS];  ///< All registers.\n  PossiblyFreedShadaEntry jumps[JUMPLISTSIZE];  ///< All dumped jumps.\n  size_t jumps_size;  ///< Number of jumps occupied.\n  PossiblyFreedShadaEntry search_pattern;  ///< Last search pattern.\n  PossiblyFreedShadaEntry sub_search_pattern;  ///< Last s/ search pattern.\n  PossiblyFreedShadaEntry replacement;  ///< Last s// replacement string.\n  khash_t(strset) dumped_variables;  ///< Names of already dumped variables.\n  khash_t(file_marks) file_marks;  ///< All file marks.\n} WriteMergerState;\n\nstruct sd_read_def;\n\n/// Function used to close files defined by ShaDaReadDef\ntypedef void (*ShaDaReadCloser)(struct sd_read_def *const sd_reader)\n  REAL_FATTR_NONNULL_ALL;\n\n/// Function used to read ShaDa files\ntypedef ptrdiff_t (*ShaDaFileReader)(struct sd_read_def *const sd_reader,\n                                     void *const dest,\n                                     const size_t size)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Function used to skip in ShaDa files\ntypedef int (*ShaDaFileSkipper)(struct sd_read_def *const sd_reader,\n                                const size_t offset)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Structure containing necessary pointers for reading ShaDa files\ntypedef struct sd_read_def {\n  ShaDaFileReader read;   ///< Reader function.\n  ShaDaReadCloser close;  ///< Close function.\n  ShaDaFileSkipper skip;  ///< Function used to skip some bytes.\n  void *cookie;           ///< Data describing object read from.\n  bool eof;               ///< True if reader reached end of file.\n  const char *error;      ///< Error message in case of error.\n  uintmax_t fpos;         ///< Current position (amount of bytes read since\n                          ///< reader structure initialization). May overflow.\n} ShaDaReadDef;\n\nstruct sd_write_def;\n\n/// Function used to close files defined by ShaDaWriteDef\ntypedef void (*ShaDaWriteCloser)(struct sd_write_def *const sd_writer)\n  REAL_FATTR_NONNULL_ALL;\n\n/// Function used to write ShaDa files\ntypedef ptrdiff_t (*ShaDaFileWriter)(struct sd_write_def *const sd_writer,\n                                     const void *const src,\n                                     const size_t size)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Structure containing necessary pointers for writing ShaDa files\ntypedef struct sd_write_def {\n  ShaDaFileWriter write;   ///< Writer function.\n  ShaDaWriteCloser close;  ///< Close function.\n  void *cookie;            ///< Data describing object written to.\n  const char *error;       ///< Error message in case of error.\n} ShaDaWriteDef;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"shada.c.generated.h\"\n#endif\n\n#define DEF_SDE(name, attr, ...) \\\n    [kSDItem##name] = { \\\n      .timestamp = 0, \\\n      .type = kSDItem##name, \\\n      .data = { \\\n        .attr = { __VA_ARGS__ } \\\n      } \\\n    }\n#define DEFAULT_POS { 1, 0, 0 }\nstatic const pos_T default_pos = DEFAULT_POS;\nstatic const ShadaEntry sd_default_values[] = {\n  [kSDItemMissing] = { .type = kSDItemMissing, .timestamp = 0 },\n  DEF_SDE(Header, header, .size = 0),\n  DEF_SDE(SearchPattern, search_pattern,\n          .magic = true,\n          .smartcase = false,\n          .has_line_offset = false,\n          .place_cursor_at_end = false,\n          .offset = 0,\n          .is_last_used = true,\n          .is_substitute_pattern = false,\n          .highlighted = false,\n          .search_backward = false,\n          .pat = NULL,\n          .additional_data = NULL),\n  DEF_SDE(SubString, sub_string, .sub = NULL, .additional_elements = NULL),\n  DEF_SDE(HistoryEntry, history_item,\n          .histtype = HIST_CMD,\n          .string = NULL,\n          .sep = NUL,\n          .additional_elements = NULL),\n  DEF_SDE(Register, reg,\n          .name = NUL,\n          .type = kMTCharWise,\n          .contents = NULL,\n          .contents_size = 0,\n          .is_unnamed = false,\n          .width = 0,\n          .additional_data = NULL),\n  DEF_SDE(Variable, global_var,\n          .name = NULL,\n          .value = {\n            .v_type = VAR_UNKNOWN,\n            .vval = { .v_string = NULL }\n          },\n          .additional_elements = NULL),\n  DEF_SDE(GlobalMark, filemark,\n          .name = '\"',\n          .mark = DEFAULT_POS,\n          .fname = NULL,\n          .additional_data = NULL),\n  DEF_SDE(Jump, filemark,\n          .name = NUL,\n          .mark = DEFAULT_POS,\n          .fname = NULL,\n          .additional_data = NULL),\n  DEF_SDE(BufferList, buffer_list,\n          .size = 0,\n          .buffers = NULL),\n  DEF_SDE(LocalMark, filemark,\n          .name = '\"',\n          .mark = DEFAULT_POS,\n          .fname = NULL,\n          .additional_data = NULL),\n  DEF_SDE(Change, filemark,\n          .name = NUL,\n          .mark = DEFAULT_POS,\n          .fname = NULL,\n          .additional_data = NULL),\n};\n#undef DEFAULT_POS\n#undef DEF_SDE\n\n/// Initialize new linked list\n///\n/// @param[out]  hmll       List to initialize.\n/// @param[in]   size       Maximum size of the list.\nstatic inline void hmll_init(HMLList *const hmll, const size_t size)\n  FUNC_ATTR_NONNULL_ALL\n{\n  *hmll = (HMLList) {\n    .entries = xcalloc(size, sizeof(hmll->entries[0])),\n    .first = NULL,\n    .last = NULL,\n    .free_entry = NULL,\n    .size = size,\n    .num_entries = 0,\n    .contained_entries = KHASH_EMPTY_TABLE(hmll_entries),\n  };\n  hmll->last_free_entry = hmll->entries;\n}\n\n/// Iterate over HMLList in forward direction\n///\n/// @param  hmll       Pointer to the list.\n/// @param  cur_entry  Name of the variable to iterate over.\n/// @param  code       Code to execute on each iteration.\n///\n/// @return `for` cycle header (use `HMLL_FORALL(hmll, cur_entry) {body}`).\n#define HMLL_FORALL(hmll, cur_entry, code) \\\n    for (HMLListEntry *cur_entry = (hmll)->first; cur_entry != NULL; \\\n         cur_entry = cur_entry->next) { \\\n      code \\\n    } \\\n\n/// Remove entry from the linked list\n///\n/// @param  hmll        List to remove from.\n/// @param  hmll_entry  Entry to remove.\nstatic inline void hmll_remove(HMLList *const hmll,\n                               HMLListEntry *const hmll_entry)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (hmll_entry == hmll->last_free_entry - 1) {\n    hmll->last_free_entry--;\n  } else {\n    assert(hmll->free_entry == NULL);\n    hmll->free_entry = hmll_entry;\n  }\n  const khiter_t k = kh_get(hmll_entries, &hmll->contained_entries,\n                            hmll_entry->data.data.history_item.string);\n  assert(k != kh_end(&hmll->contained_entries));\n  kh_del(hmll_entries, &hmll->contained_entries, k);\n  if (hmll_entry->next == NULL) {\n    hmll->last = hmll_entry->prev;\n  } else {\n    hmll_entry->next->prev = hmll_entry->prev;\n  }\n  if (hmll_entry->prev == NULL) {\n    hmll->first = hmll_entry->next;\n  } else {\n    hmll_entry->prev->next = hmll_entry->next;\n  }\n  hmll->num_entries--;\n  if (hmll_entry->can_free_entry) {\n    shada_free_shada_entry(&hmll_entry->data);\n  }\n}\n\n\n/// Insert entry to the linked list\n///\n/// @param[out]  hmll            List to insert to.\n/// @param[in]   hmll_entry      Entry to insert after or NULL if it is needed\n///                              to insert at the first entry.\n/// @param[in]   data            Data to insert.\n/// @param[in]   can_free_entry  True if data can be freed.\nstatic inline void hmll_insert(HMLList *const hmll,\n                               HMLListEntry *hmll_entry,\n                               const ShadaEntry data,\n                               const bool can_free_entry)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (hmll->num_entries == hmll->size) {\n    if (hmll_entry == hmll->first) {\n      hmll_entry = NULL;\n    }\n    assert(hmll->first != NULL);\n    hmll_remove(hmll, hmll->first);\n  }\n  HMLListEntry *target_entry;\n  if (hmll->free_entry == NULL) {\n    assert((size_t) (hmll->last_free_entry - hmll->entries)\n           == hmll->num_entries);\n    target_entry = hmll->last_free_entry++;\n  } else {\n    assert((size_t) (hmll->last_free_entry - hmll->entries) - 1\n           == hmll->num_entries);\n    target_entry = hmll->free_entry;\n    hmll->free_entry = NULL;\n  }\n  target_entry->data = data;\n  target_entry->can_free_entry = can_free_entry;\n  int kh_ret;\n  const khiter_t k = kh_put(hmll_entries, &hmll->contained_entries,\n                            data.data.history_item.string, &kh_ret);\n  if (kh_ret > 0) {\n    kh_val(&hmll->contained_entries, k) = target_entry;\n  }\n  hmll->num_entries++;\n  target_entry->prev = hmll_entry;\n  if (hmll_entry == NULL) {\n    target_entry->next = hmll->first;\n    hmll->first = target_entry;\n  } else {\n    target_entry->next = hmll_entry->next;\n    hmll_entry->next = target_entry;\n  }\n  if (target_entry->next == NULL) {\n    hmll->last = target_entry;\n  } else {\n    target_entry->next->prev = target_entry;\n  }\n}\n\n/// Iterate over HMLList in backward direction\n///\n/// @param  hmll       Pointer to the list.\n/// @param  cur_entry  Name of the variable to iterate over, must be already\n///                    defined.\n/// @param  code       Code to execute on each iteration.\n///\n/// @return `for` cycle header (use `HMLL_FORALL(hmll, cur_entry) {body}`).\n#define HMLL_ITER_BACK(hmll, cur_entry, code) \\\n    for (cur_entry = (hmll)->last; cur_entry != NULL; \\\n         cur_entry = cur_entry->prev) { \\\n      code \\\n    }\n\n/// Free linked list\n///\n/// @param[in]  hmll  List to free.\nstatic inline void hmll_dealloc(HMLList *const hmll)\n  FUNC_ATTR_NONNULL_ALL\n{\n  kh_dealloc(hmll_entries, &hmll->contained_entries);\n  xfree(hmll->entries);\n}\n\n/// Wrapper for reading from file descriptors\n///\n/// @return -1 or number of bytes read.\nstatic ptrdiff_t read_file(ShaDaReadDef *const sd_reader, void *const dest,\n                           const size_t size)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const ptrdiff_t ret = file_read(sd_reader->cookie, dest, size);\n  sd_reader->eof = file_eof(sd_reader->cookie);\n  if (ret < 0) {\n    sd_reader->error = os_strerror((int)ret);\n    return -1;\n  }\n  sd_reader->fpos += (size_t)ret;\n  return ret;\n}\n\n/// Read one character\nstatic int read_char(ShaDaReadDef *const sd_reader)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  uint8_t ret;\n  ptrdiff_t read_bytes = sd_reader->read(sd_reader, &ret, 1);\n  if (read_bytes != 1) {\n    return EOF;\n  }\n  return (int) ret;\n}\n\n/// Wrapper for writing to file descriptors\n///\n/// @return -1 or number of bytes written.\nstatic ptrdiff_t write_file(ShaDaWriteDef *const sd_writer,\n                            const void *const dest,\n                            const size_t size)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const ptrdiff_t ret = file_write(sd_writer->cookie, dest, size);\n  if (ret < 0) {\n    sd_writer->error = os_strerror((int)ret);\n    return -1;\n  }\n  return ret;\n}\n\n/// Wrapper for closing file descriptors opened for reading\nstatic void close_sd_reader(ShaDaReadDef *const sd_reader)\n  FUNC_ATTR_NONNULL_ALL\n{\n  close_file(sd_reader->cookie);\n}\n\n/// Wrapper for closing file descriptors opened for writing\nstatic void close_sd_writer(ShaDaWriteDef *const sd_writer)\n  FUNC_ATTR_NONNULL_ALL\n{\n  close_file(sd_writer->cookie);\n}\n\n/// Wrapper for read that reads to IObuff and ignores bytes read\n///\n/// Used for skipping.\n///\n/// @param[in,out]  sd_reader  File read.\n/// @param[in]      offset     Amount of bytes to skip.\n///\n/// @return FAIL in case of failure, OK in case of success. May set\n///         sd_reader->eof or sd_reader->error.\nstatic int sd_reader_skip_read(ShaDaReadDef *const sd_reader,\n                               const size_t offset)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const ptrdiff_t skip_bytes = file_skip(sd_reader->cookie, offset);\n  if (skip_bytes < 0) {\n    sd_reader->error = os_strerror((int)skip_bytes);\n    return FAIL;\n  } else if (skip_bytes != (ptrdiff_t)offset) {\n    assert(skip_bytes < (ptrdiff_t)offset);\n    sd_reader->eof = file_eof(sd_reader->cookie);\n    if (!sd_reader->eof) {\n      sd_reader->error = _(\"too few bytes read\");\n    }\n    return FAIL;\n  }\n  sd_reader->fpos += (size_t)skip_bytes;\n  return OK;\n}\n\n/// Wrapper for read that can be used when lseek cannot be used\n///\n/// E.g. when trying to read from a pipe.\n///\n/// @param[in,out]  sd_reader  File read.\n/// @param[in]      offset     Amount of bytes to skip.\n///\n/// @return kSDReadStatusReadError, kSDReadStatusNotShaDa or\n///         kSDReadStatusSuccess.\nstatic ShaDaReadResult sd_reader_skip(ShaDaReadDef *const sd_reader,\n                                      const size_t offset)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (sd_reader->skip(sd_reader, offset) != OK) {\n    if (sd_reader->error != NULL) {\n      emsgf(_(SERR \"System error while skipping in ShaDa file: %s\"),\n            sd_reader->error);\n      return kSDReadStatusReadError;\n    } else if (sd_reader->eof) {\n      emsgf(_(RCERR \"Error while reading ShaDa file: \"\n              \"last entry specified that it occupies %\" PRIu64 \" bytes, \"\n              \"but file ended earlier\"),\n            (uint64_t) offset);\n      return kSDReadStatusNotShaDa;\n    }\n    abort();\n  }\n  return kSDReadStatusSuccess;\n}\n\n/// Open ShaDa file for reading\n///\n/// @param[in]   fname      File name to open.\n/// @param[out]  sd_reader  Location where reader structure will be saved.\n///\n/// @return libuv error in case of error, 0 otherwise.\nstatic int open_shada_file_for_reading(const char *const fname,\n                                       ShaDaReadDef *sd_reader)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  int error;\n\n  *sd_reader = (ShaDaReadDef) {\n    .read = &read_file,\n    .close = &close_sd_reader,\n    .skip = &sd_reader_skip_read,\n    .error = NULL,\n    .eof = false,\n    .fpos = 0,\n    .cookie = file_open_new(&error, fname, kFileReadOnly, 0),\n  };\n  if (sd_reader->cookie == NULL) {\n    return error;\n  }\n\n  assert(STRCMP(p_enc, \"utf-8\") == 0);\n\n  return 0;\n}\n\n/// Wrapper for closing file descriptors\nstatic void close_file(void *cookie)\n{\n  const int error = file_free(cookie, !!p_fs);\n  if (error != 0) {\n    emsgf(_(SERR \"System error while closing ShaDa file: %s\"),\n          os_strerror(error));\n  }\n}\n\n/// Check whether buffer is in the given set\n///\n/// @param[in]  set  Set to check within.\n/// @param[in]  buf  Buffer to find.\n///\n/// @return true or false.\nstatic inline bool in_bufset(const khash_t(bufset) *const set, const buf_T *buf)\n  FUNC_ATTR_PURE\n{\n  return kh_get(bufset, set, (uintptr_t) buf) != kh_end(set);\n}\n\n/// Check whether string is in the given set\n///\n/// @param[in]  set  Set to check within.\n/// @param[in]  buf  Buffer to find.\n///\n/// @return true or false.\nstatic inline bool in_strset(const khash_t(strset) *const set, char *str)\n  FUNC_ATTR_PURE\n{\n  return kh_get(strset, set, str) != kh_end(set);\n}\n\n/// Msgpack callback for writing to ShaDaWriteDef*\nstatic int msgpack_sd_writer_write(void *data, const char *buf, size_t len)\n{\n  ShaDaWriteDef *const sd_writer = (ShaDaWriteDef *) data;\n  ptrdiff_t written_bytes = sd_writer->write(sd_writer, buf, len);\n  if (written_bytes == -1) {\n    emsgf(_(SERR \"System error while writing ShaDa file: %s\"),\n          sd_writer->error);\n    return -1;\n  }\n  return 0;\n}\n\n/// Check whether writing to shada file was disabled (\"-i NONE\" or \"--clean\").\n///\n/// @return true if it was disabled, false otherwise.\nstatic bool shada_disabled(void)\n  FUNC_ATTR_PURE\n{\n  return strequal(p_shadafile, \"NONE\");\n}\n\n/// Read ShaDa file\n///\n/// @param[in]  file   File to read or NULL to use default name.\n/// @param[in]  flags  Flags, see ShaDaReadFileFlags enum.\n///\n/// @return FAIL if reading failed for some reason and OK otherwise.\nstatic int shada_read_file(const char *const file, const int flags)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (shada_disabled()) {\n    return FAIL;\n  }\n\n  char *const fname = shada_filename(file);\n\n  ShaDaReadDef sd_reader;\n  const int of_ret = open_shada_file_for_reading(fname, &sd_reader);\n\n  if (p_verbose > 0) {\n    verbose_enter();\n    smsg(_(\"Reading ShaDa file \\\"%s\\\"%s%s%s%s\"),\n         fname,\n         (flags & kShaDaWantInfo) ? _(\" info\") : \"\",\n         (flags & kShaDaWantMarks) ? _(\" marks\") : \"\",\n         (flags & kShaDaGetOldfiles) ? _(\" oldfiles\") : \"\",\n         of_ret != 0 ? _(\" FAILED\") : \"\");\n    verbose_leave();\n  }\n\n  if (of_ret != 0) {\n    if (of_ret != UV_ENOENT || (flags & kShaDaMissingError)) {\n      emsgf(_(SERR \"System error while opening ShaDa file %s for reading: %s\"),\n            fname, os_strerror(of_ret));\n    }\n    xfree(fname);\n    return FAIL;\n  }\n  xfree(fname);\n\n  shada_read(&sd_reader, flags);\n  sd_reader.close(&sd_reader);\n\n  return OK;\n}\n\n/// Wrapper for hist_iter() function which produces ShadaEntry values\n///\n/// @param[in]   iter          Current iteration state.\n/// @param[in]   history_type  Type of the history (HIST_*).\n/// @param[in]   zero          If true, then item is removed from instance\n///                            memory upon reading.\n/// @param[out]  hist          Location where iteration results should be saved.\n///\n/// @return Next iteration state.\nstatic const void *shada_hist_iter(const void *const iter,\n                                   const uint8_t history_type,\n                                   const bool zero,\n                                   ShadaEntry *const hist)\n  FUNC_ATTR_NONNULL_ARG(4) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  histentry_T hist_he;\n  const void *const ret = hist_iter(iter, history_type, zero, &hist_he);\n  if (hist_he.hisstr == NULL) {\n    *hist = (ShadaEntry) { .type = kSDItemMissing };\n  } else {\n    *hist = (ShadaEntry) {\n      .type = kSDItemHistoryEntry,\n      .timestamp = hist_he.timestamp,\n      .data = {\n        .history_item = {\n          .histtype = history_type,\n          .string = (char *) hist_he.hisstr,\n          .sep = (char) (history_type == HIST_SEARCH\n                         ? (char) hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]\n                         : 0),\n          .additional_elements = hist_he.additional_elements,\n        }\n      }\n    };\n  }\n  return ret;\n}\n\n/// Insert history entry\n///\n/// Inserts history entry at the end of the ring buffer (may insert earlier\n/// according to the timestamp). If entry was already in the ring buffer\n/// existing entry will be removed unless it has greater timestamp.\n///\n/// Before the new entry entries from the current Neovim history will be\n/// inserted unless `do_iter` argument is false.\n///\n/// @param[in,out]  hms_p           Ring buffer and associated structures.\n/// @param[in]      entry           Inserted entry.\n/// @param[in]      do_iter         Determines whether Neovim own history should\n///                                 be used. Must be true only if inserting\n///                                 entry from current Neovim history.\n/// @param[in]      can_free_entry  True if entry can be freed.\nstatic void hms_insert(HistoryMergerState *const hms_p, const ShadaEntry entry,\n                       const bool do_iter, const bool can_free_entry)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (do_iter) {\n    while (hms_p->last_hist_entry.type != kSDItemMissing\n           && hms_p->last_hist_entry.timestamp < entry.timestamp) {\n      hms_insert(hms_p, hms_p->last_hist_entry, false, hms_p->reading);\n      if (hms_p->iter == NULL) {\n        hms_p->last_hist_entry.type = kSDItemMissing;\n        break;\n      }\n      hms_p->iter = shada_hist_iter(hms_p->iter, hms_p->history_type,\n                                    hms_p->reading, &hms_p->last_hist_entry);\n    }\n  }\n  HMLList *const hmll = &hms_p->hmll;\n  const khiter_t k = kh_get(hmll_entries, &hms_p->hmll.contained_entries,\n                            entry.data.history_item.string);\n  if (k != kh_end(&hmll->contained_entries)) {\n    HMLListEntry *const existing_entry = kh_val(&hmll->contained_entries, k);\n    if (entry.timestamp > existing_entry->data.timestamp) {\n      hmll_remove(hmll, existing_entry);\n    } else if (!do_iter && entry.timestamp == existing_entry->data.timestamp) {\n      // Prefer entry from the current Neovim instance.\n      if (existing_entry->can_free_entry) {\n        shada_free_shada_entry(&existing_entry->data);\n      }\n      existing_entry->data = entry;\n      existing_entry->can_free_entry = can_free_entry;\n      // Previous key was freed above, as part of freeing the ShaDa entry.\n      kh_key(&hmll->contained_entries, k) = entry.data.history_item.string;\n      return;\n    } else {\n      return;\n    }\n  }\n  HMLListEntry *insert_after;\n  HMLL_ITER_BACK(hmll, insert_after, {\n    if (insert_after->data.timestamp <= entry.timestamp) {\n      break;\n    }\n  })\n  hmll_insert(hmll, insert_after, entry, can_free_entry);\n}\n\n/// Initialize the history merger\n///\n/// @param[out]  hms_p         Structure to be initialized.\n/// @param[in]   history_type  History type (one of HIST_\\* values).\n/// @param[in]   num_elements  Number of elements in the result.\n/// @param[in]   do_merge      Prepare structure for merging elements.\n/// @param[in]   reading       If true, then merger is reading history for use\n///                            in Neovim.\nstatic inline void hms_init(HistoryMergerState *const hms_p,\n                            const uint8_t history_type,\n                            const size_t num_elements,\n                            const bool do_merge,\n                            const bool reading)\n  FUNC_ATTR_NONNULL_ALL\n{\n  hmll_init(&hms_p->hmll, num_elements);\n  hms_p->do_merge = do_merge;\n  hms_p->reading = reading;\n  hms_p->iter = shada_hist_iter(NULL, history_type, hms_p->reading,\n                                &hms_p->last_hist_entry);\n  hms_p->history_type = history_type;\n}\n\n/// Merge in all remaining Neovim own history entries\n///\n/// @param[in,out]  hms_p  Merger structure into which history should be\n///                        inserted.\nstatic inline void hms_insert_whole_neovim_history(\n    HistoryMergerState *const hms_p)\n  FUNC_ATTR_NONNULL_ALL\n{\n  while (hms_p->last_hist_entry.type != kSDItemMissing) {\n    hms_insert(hms_p, hms_p->last_hist_entry, false, hms_p->reading);\n    if (hms_p->iter == NULL) {\n      break;\n    }\n    hms_p->iter = shada_hist_iter(hms_p->iter, hms_p->history_type,\n                                  hms_p->reading, &hms_p->last_hist_entry);\n  }\n}\n\n/// Convert merger structure to Neovim internal structure for history\n///\n/// @param[in]   hms_p       Converted merger structure.\n/// @param[out]  hist_array  Array with the results.\n/// @param[out]  new_hisidx  New last history entry index.\n/// @param[out]  new_hisnum  Amount of history items in merger structure.\nstatic inline void hms_to_he_array(const HistoryMergerState *const hms_p,\n                                   histentry_T *const hist_array,\n                                   int *const new_hisidx,\n                                   int *const new_hisnum)\n  FUNC_ATTR_NONNULL_ALL\n{\n  histentry_T *hist = hist_array;\n  HMLL_FORALL(&hms_p->hmll, cur_entry,  {\n    hist->timestamp = cur_entry->data.timestamp;\n    hist->hisnum = (int) (hist - hist_array) + 1;\n    hist->hisstr = (char_u *) cur_entry->data.data.history_item.string;\n    hist->additional_elements =\n        cur_entry->data.data.history_item.additional_elements;\n    hist++;\n  })\n  *new_hisnum = (int) (hist - hist_array);\n  *new_hisidx = *new_hisnum - 1;\n}\n\n/// Free history merger structure\n///\n/// @param[in]  hms_p  Structure to be freed.\nstatic inline void hms_dealloc(HistoryMergerState *const hms_p)\n  FUNC_ATTR_NONNULL_ALL\n{\n  hmll_dealloc(&hms_p->hmll);\n}\n\n/// Iterate over all history entries in history merger, in order\n///\n/// @param[in]   hms_p      Merger structure to iterate over.\n/// @param[out]  cur_entry  Name of the iterator variable.\n/// @param       code       Code to execute on each iteration.\n///\n/// @return for cycle header. Use `HMS_ITER(hms_p, cur_entry) {body}`.\n#define HMS_ITER(hms_p, cur_entry, code) \\\n    HMLL_FORALL(&((hms_p)->hmll), cur_entry, code)\n\n/// Find buffer for given buffer name (cached)\n///\n/// @param[in,out]  fname_bufs  Cache containing fname to buffer mapping.\n/// @param[in]      fname       File name to find.\n///\n/// @return Pointer to the buffer or NULL.\nstatic buf_T *find_buffer(khash_t(fnamebufs) *const fname_bufs,\n                          const char *const fname)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  int kh_ret;\n  khint_t k = kh_put(fnamebufs, fname_bufs, fname, &kh_ret);\n  if (!kh_ret) {\n    return kh_val(fname_bufs, k);\n  }\n  kh_key(fname_bufs, k) = xstrdup(fname);\n  FOR_ALL_BUFFERS(buf) {\n    if (buf->b_ffname != NULL) {\n      if (fnamecmp(fname, buf->b_ffname) == 0) {\n        kh_val(fname_bufs, k) = buf;\n        return buf;\n      }\n    }\n  }\n  kh_val(fname_bufs, k) = NULL;\n  return NULL;\n}\n\n/// Compare two marks\nstatic inline bool marks_equal(const pos_T a, const pos_T b)\n{\n  return (a.lnum == b.lnum) && (a.col == b.col);\n}\n\n#define MERGE_JUMPS(jumps_size, jumps, jumps_type, timestamp_attr, mark_attr, \\\n                    entry, fname_cond, free_func, fin_func, \\\n                    idxadj_func, afterfree_func) \\\n  do { \\\n    const int jl_len = (int) jumps_size; \\\n    int i; \\\n    for (i = jl_len; i > 0; i--) { \\\n      const jumps_type jl_entry = jumps[i - 1]; \\\n      if (jl_entry.timestamp_attr <= entry.timestamp) { \\\n        if (marks_equal(jl_entry.mark_attr, entry.data.filemark.mark) \\\n            && fname_cond) { \\\n          i = -1; \\\n        } \\\n        break; \\\n      } \\\n    } \\\n    if (i > 0) { \\\n      if (jl_len == JUMPLISTSIZE) { \\\n        free_func(jumps[0]); \\\n        i--; \\\n        if (i > 0) { \\\n          memmove(&jumps[0], &jumps[1], sizeof(jumps[1]) * (size_t) i); \\\n        } \\\n      } else if (i != jl_len) { \\\n        memmove(&jumps[i + 1], &jumps[i], \\\n                sizeof(jumps[0]) * (size_t) (jl_len - i)); \\\n      } \\\n    } else if (i == 0) { \\\n      if (jl_len == JUMPLISTSIZE) { \\\n        i = -1; \\\n      } else if (jl_len > 0) { \\\n        memmove(&jumps[1], &jumps[0], sizeof(jumps[0]) * (size_t) jl_len); \\\n      } \\\n    } \\\n    if (i != -1) { \\\n      jumps[i] = fin_func(entry); \\\n      if (jl_len < JUMPLISTSIZE) { \\\n        jumps_size++; \\\n      } \\\n      idxadj_func(i); \\\n    } else { \\\n      shada_free_shada_entry(&entry); \\\n      afterfree_func(entry); \\\n    } \\\n  } while (0)\n\n/// Read data from ShaDa file\n///\n/// @param[in]  sd_reader  Structure containing file reader definition.\n/// @param[in]  flags      What to read, see ShaDaReadFileFlags enum.\nstatic void shada_read(ShaDaReadDef *const sd_reader, const int flags)\n  FUNC_ATTR_NONNULL_ALL\n{\n  list_T *oldfiles_list = get_vim_var_list(VV_OLDFILES);\n  const bool force = flags & kShaDaForceit;\n  const bool get_old_files = (flags & (kShaDaGetOldfiles | kShaDaForceit)\n                              && (force || tv_list_len(oldfiles_list) == 0));\n  const bool want_marks = flags & kShaDaWantMarks;\n  const unsigned srni_flags = (unsigned) (\n      (flags & kShaDaWantInfo\n       ? (kSDReadUndisableableData\n          | kSDReadRegisters\n          | kSDReadGlobalMarks\n          | (p_hi ? kSDReadHistory : 0)\n          | (find_shada_parameter('!') != NULL\n             ? kSDReadVariables\n             : 0)\n          | (find_shada_parameter('%') != NULL\n             && ARGCOUNT == 0\n             ? kSDReadBufferList\n             : 0))\n       : 0)\n      | (want_marks && get_shada_parameter('\\'') > 0\n         ? kSDReadLocalMarks | kSDReadChanges\n         : 0)\n      | (get_old_files\n         ? kSDReadLocalMarks\n         : 0));\n  if (srni_flags == 0) {\n    // Nothing to do.\n    return;\n  }\n  HistoryMergerState hms[HIST_COUNT];\n  if (srni_flags & kSDReadHistory) {\n    for (uint8_t i = 0; i < HIST_COUNT; i++) {\n      hms_init(&hms[i], i, (size_t) p_hi, true, true);\n    }\n  }\n  ShadaEntry cur_entry;\n  khash_t(bufset) cl_bufs = KHASH_EMPTY_TABLE(bufset);\n  khash_t(fnamebufs) fname_bufs = KHASH_EMPTY_TABLE(fnamebufs);\n  khash_t(strset) oldfiles_set = KHASH_EMPTY_TABLE(strset);\n  if (get_old_files && (oldfiles_list == NULL || force)) {\n    oldfiles_list = tv_list_alloc(kListLenUnknown);\n    set_vim_var_list(VV_OLDFILES, oldfiles_list);\n  }\n  ShaDaReadResult srni_ret;\n  while ((srni_ret = shada_read_next_item(sd_reader, &cur_entry, srni_flags, 0))\n         != kSDReadStatusFinished) {\n    switch (srni_ret) {\n      case kSDReadStatusSuccess: {\n        break;\n      }\n      case kSDReadStatusFinished: {\n        // Should be handled by the while condition.\n        abort();\n      }\n      case kSDReadStatusNotShaDa:\n      case kSDReadStatusReadError: {\n        goto shada_read_main_cycle_end;\n      }\n      case kSDReadStatusMalformed: {\n        continue;\n      }\n    }\n    switch (cur_entry.type) {\n      case kSDItemMissing: {\n        abort();\n      }\n      case kSDItemUnknown: {\n        break;\n      }\n      case kSDItemHeader: {\n        shada_free_shada_entry(&cur_entry);\n        break;\n      }\n      case kSDItemSearchPattern: {\n        if (!force) {\n          SearchPattern pat;\n          (cur_entry.data.search_pattern.is_substitute_pattern\n           ? &get_substitute_pattern\n           : &get_search_pattern)(&pat);\n          if (pat.pat != NULL && pat.timestamp >= cur_entry.timestamp) {\n            shada_free_shada_entry(&cur_entry);\n            break;\n          }\n        }\n        (cur_entry.data.search_pattern.is_substitute_pattern\n         ? &set_substitute_pattern\n         : &set_search_pattern)((SearchPattern) {\n           .magic = cur_entry.data.search_pattern.magic,\n           .no_scs = !cur_entry.data.search_pattern.smartcase,\n           .off = {\n             .dir = cur_entry.data.search_pattern.search_backward ? '?' : '/',\n             .line = cur_entry.data.search_pattern.has_line_offset,\n             .end = cur_entry.data.search_pattern.place_cursor_at_end,\n             .off = cur_entry.data.search_pattern.offset,\n           },\n           .pat = (char_u *) cur_entry.data.search_pattern.pat,\n           .additional_data = cur_entry.data.search_pattern.additional_data,\n           .timestamp = cur_entry.timestamp,\n         });\n        if (cur_entry.data.search_pattern.is_last_used) {\n          set_last_used_pattern(\n              cur_entry.data.search_pattern.is_substitute_pattern);\n          set_no_hlsearch(!cur_entry.data.search_pattern.highlighted);\n        }\n        // Do not free shada entry: its allocated memory was saved above.\n        break;\n      }\n      case kSDItemSubString: {\n        if (!force) {\n          SubReplacementString sub;\n          sub_get_replacement(&sub);\n          if (sub.sub != NULL && sub.timestamp >= cur_entry.timestamp) {\n            shada_free_shada_entry(&cur_entry);\n            break;\n          }\n        }\n        sub_set_replacement((SubReplacementString) {\n          .sub = cur_entry.data.sub_string.sub,\n          .timestamp = cur_entry.timestamp,\n          .additional_elements = cur_entry.data.sub_string.additional_elements,\n        });\n        // Without using regtilde and without / &cpo flag previous substitute\n        // string is close to useless: you can only use it with :& or :~ and\n        // that\u2019s all because s//~ is not available until the first call to\n        // regtilde. Vim was not calling this for some reason.\n        (void) regtilde(cur_entry.data.sub_string.sub, p_magic);\n        // Do not free shada entry: its allocated memory was saved above.\n        break;\n      }\n      case kSDItemHistoryEntry: {\n        if (cur_entry.data.history_item.histtype >= HIST_COUNT) {\n          shada_free_shada_entry(&cur_entry);\n          break;\n        }\n        hms_insert(hms + cur_entry.data.history_item.histtype, cur_entry, true,\n                   true);\n        // Do not free shada entry: its allocated memory was saved above.\n        break;\n      }\n      case kSDItemRegister: {\n        if (cur_entry.data.reg.type != kMTCharWise\n            && cur_entry.data.reg.type != kMTLineWise\n            && cur_entry.data.reg.type != kMTBlockWise) {\n          shada_free_shada_entry(&cur_entry);\n          break;\n        }\n        if (!force) {\n          const yankreg_T *const reg = op_reg_get(cur_entry.data.reg.name);\n          if (reg == NULL || reg->timestamp >= cur_entry.timestamp) {\n            shada_free_shada_entry(&cur_entry);\n            break;\n          }\n        }\n        if (!op_reg_set(cur_entry.data.reg.name, (yankreg_T) {\n          .y_array = (char_u **)cur_entry.data.reg.contents,\n          .y_size = cur_entry.data.reg.contents_size,\n          .y_type = cur_entry.data.reg.type,\n          .y_width = (colnr_T) cur_entry.data.reg.width,\n          .timestamp = cur_entry.timestamp,\n          .additional_data = cur_entry.data.reg.additional_data,\n        }, cur_entry.data.reg.is_unnamed)) {\n          shada_free_shada_entry(&cur_entry);\n        }\n        // Do not free shada entry: its allocated memory was saved above.\n        break;\n      }\n      case kSDItemVariable: {\n        var_set_global(cur_entry.data.global_var.name,\n                       cur_entry.data.global_var.value);\n        cur_entry.data.global_var.value.v_type = VAR_UNKNOWN;\n        shada_free_shada_entry(&cur_entry);\n        break;\n      }\n      case kSDItemJump:\n      case kSDItemGlobalMark: {\n        buf_T *buf = find_buffer(&fname_bufs, cur_entry.data.filemark.fname);\n        if (buf != NULL) {\n          XFREE_CLEAR(cur_entry.data.filemark.fname);\n        }\n        xfmark_T fm = (xfmark_T) {\n          .fname = (char_u *) (buf == NULL\n                               ? cur_entry.data.filemark.fname\n                               : NULL),\n          .fmark = {\n            .mark = cur_entry.data.filemark.mark,\n            .fnum = (buf == NULL ? 0 : buf->b_fnum),\n            .timestamp = cur_entry.timestamp,\n            .additional_data = cur_entry.data.filemark.additional_data,\n          },\n        };\n        if (cur_entry.type == kSDItemGlobalMark) {\n          if (!mark_set_global(cur_entry.data.filemark.name, fm, !force)) {\n            shada_free_shada_entry(&cur_entry);\n            break;\n          }\n        } else {\n#define SDE_TO_XFMARK(entry) fm\n#define ADJUST_IDX(i) \\\n          if (curwin->w_jumplistidx >= i \\\n              && curwin->w_jumplistidx + 1 <= curwin->w_jumplistlen) { \\\n            curwin->w_jumplistidx++; \\\n          }\n#define DUMMY_AFTERFREE(entry)\n          MERGE_JUMPS(curwin->w_jumplistlen, curwin->w_jumplist, xfmark_T,\n                      fmark.timestamp, fmark.mark, cur_entry,\n                      (buf == NULL\n                       ? (jl_entry.fname != NULL\n                          && STRCMP(fm.fname, jl_entry.fname) == 0)\n                       : fm.fmark.fnum == jl_entry.fmark.fnum),\n                      free_xfmark, SDE_TO_XFMARK, ADJUST_IDX, DUMMY_AFTERFREE);\n#undef SDE_TO_XFMARK\n#undef ADJUST_IDX\n#undef DUMMY_AFTERFREE\n        }\n        // Do not free shada entry: its allocated memory was saved above.\n        break;\n      }\n      case kSDItemBufferList: {\n        for (size_t i = 0; i < cur_entry.data.buffer_list.size; i++) {\n          char *const sfname = path_try_shorten_fname(\n              cur_entry.data.buffer_list.buffers[i].fname);\n          buf_T *const buf = buflist_new(\n              cur_entry.data.buffer_list.buffers[i].fname, sfname, 0,\n              BLN_LISTED);\n          if (buf != NULL) {\n            RESET_FMARK(&buf->b_last_cursor,\n                        cur_entry.data.buffer_list.buffers[i].pos, 0);\n            buflist_setfpos(buf, curwin, buf->b_last_cursor.mark.lnum,\n                            buf->b_last_cursor.mark.col, false);\n            buf->additional_data =\n                cur_entry.data.buffer_list.buffers[i].additional_data;\n            cur_entry.data.buffer_list.buffers[i].additional_data = NULL;\n          }\n        }\n        shada_free_shada_entry(&cur_entry);\n        break;\n      }\n      case kSDItemChange:\n      case kSDItemLocalMark: {\n        if (get_old_files && !in_strset(&oldfiles_set,\n                                        cur_entry.data.filemark.fname)) {\n          char *fname = cur_entry.data.filemark.fname;\n          if (want_marks) {\n            // Do not bother with allocating memory for the string if already\n            // allocated string from cur_entry can be used. It cannot be used if\n            // want_marks is set because this way it may be used for a mark.\n            fname = xstrdup(fname);\n          }\n          int kh_ret;\n          (void)kh_put(strset, &oldfiles_set, fname, &kh_ret);\n          tv_list_append_allocated_string(oldfiles_list, fname);\n          if (!want_marks) {\n            // Avoid free because this string was already used.\n            cur_entry.data.filemark.fname = NULL;\n          }\n        }\n        if (!want_marks) {\n          shada_free_shada_entry(&cur_entry);\n          break;\n        }\n        buf_T *buf = find_buffer(&fname_bufs, cur_entry.data.filemark.fname);\n        if (buf == NULL) {\n          shada_free_shada_entry(&cur_entry);\n          break;\n        }\n        const fmark_T fm = (fmark_T) {\n          .mark = cur_entry.data.filemark.mark,\n          .fnum = 0,\n          .timestamp = cur_entry.timestamp,\n          .additional_data = cur_entry.data.filemark.additional_data,\n        };\n        if (cur_entry.type == kSDItemLocalMark) {\n          if (!mark_set_local(cur_entry.data.filemark.name, buf, fm, !force)) {\n            shada_free_shada_entry(&cur_entry);\n            break;\n          }\n        } else {\n          int kh_ret;\n          (void) kh_put(bufset, &cl_bufs, (uintptr_t) buf, &kh_ret);\n#define SDE_TO_FMARK(entry) fm\n#define AFTERFREE(entry) (entry).data.filemark.fname = NULL\n#define DUMMY_IDX_ADJ(i)\n          MERGE_JUMPS(buf->b_changelistlen, buf->b_changelist, fmark_T,\n                      timestamp, mark, cur_entry, true,\n                      free_fmark, SDE_TO_FMARK, DUMMY_IDX_ADJ, AFTERFREE);\n#undef SDE_TO_FMARK\n#undef AFTERFREE\n#undef DUMMY_IDX_ADJ\n        }\n        // Do not free shada entry: except for fname, its allocated memory (i.e.\n        // additional_data attribute contents if non-NULL) was saved above.\n        xfree(cur_entry.data.filemark.fname);\n        break;\n      }\n    }\n  }\nshada_read_main_cycle_end:\n  // Warning: shada_hist_iter returns ShadaEntry elements which use strings from\n  //          original history list. This means that once such entry is removed\n  //          from the history Neovim array will no longer be valid. To reduce\n  //          amount of memory allocations ShaDa file reader allocates enough\n  //          memory for the history string itself and separator character which\n  //          may be assigned right away.\n  if (srni_flags & kSDReadHistory) {\n    for (uint8_t i = 0; i < HIST_COUNT; i++) {\n      hms_insert_whole_neovim_history(&hms[i]);\n      clr_history(i);\n      int *new_hisidx;\n      int *new_hisnum;\n      histentry_T *hist = hist_get_array(i, &new_hisidx, &new_hisnum);\n      if (hist != NULL) {\n        hms_to_he_array(&hms[i], hist, new_hisidx, new_hisnum);\n      }\n      hms_dealloc(&hms[i]);\n    }\n  }\n  if (cl_bufs.n_occupied) {\n    FOR_ALL_TAB_WINDOWS(tp, wp) {\n      (void) tp;\n      if (in_bufset(&cl_bufs, wp->w_buffer)) {\n        wp->w_changelistidx = wp->w_buffer->b_changelistlen;\n      }\n    }\n  }\n  kh_dealloc(bufset, &cl_bufs);\n  const char *key;\n  kh_foreach_key(&fname_bufs, key, {\n    xfree((void *) key);\n  })\n  kh_dealloc(fnamebufs, &fname_bufs);\n  kh_dealloc(strset, &oldfiles_set);\n}\n\n/// Default shada file location: cached path\nstatic char *default_shada_file = NULL;\n\n/// Get the default ShaDa file\nstatic const char *shada_get_default_file(void)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (default_shada_file == NULL) {\n    char *shada_dir = stdpaths_user_data_subpath(\"shada\", 0, false);\n    default_shada_file = concat_fnames_realloc(shada_dir, \"main.shada\", true);\n  }\n  return default_shada_file;\n}\n\n/// Get the ShaDa file name to use\n///\n/// If \"file\" is given and not empty, use it (has already been expanded by\n/// cmdline functions). Otherwise use \"-i file_name\", value from 'shada' or the\n/// default, and expand environment variables.\n///\n/// @param[in]  file  Forced file name or NULL.\n///\n/// @return An allocated string containing shada file name.\nstatic char *shada_filename(const char *file)\n  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (file == NULL || *file == NUL) {\n    if (p_shadafile != NULL && *p_shadafile != NUL) {\n      file = p_shadafile;\n    } else {\n      if ((file = find_shada_parameter('n')) == NULL || *file == NUL) {\n        file =  shada_get_default_file();\n      }\n      // XXX It used to be one level lower, so that whatever is in\n      //     `p_shadafile` was expanded. I intentionally moved it here\n      //     because various expansions must have already be done by the shell.\n      //     If shell is not performing them then they should be done in main.c\n      //     where arguments are parsed, *not here*.\n      expand_env((char_u *)file, &(NameBuff[0]), MAXPATHL);\n      file = (const char *) &(NameBuff[0]);\n    }\n  }\n  return xstrdup(file);\n}\n\n#define PACK_STATIC_STR(s) \\\n    do { \\\n      msgpack_pack_str(spacker, sizeof(s) - 1); \\\n      msgpack_pack_str_body(spacker, s, sizeof(s) - 1); \\\n    } while (0)\n#define PACK_STRING(s) \\\n    do { \\\n      const String s_ = (s); \\\n      msgpack_pack_str(spacker, s_.size); \\\n      if (s_.size) { \\\n        msgpack_pack_str_body(spacker, s_.data, s_.size); \\\n      } \\\n    } while (0)\n#define PACK_BIN(s) \\\n    do { \\\n      const String s_ = (s); \\\n      msgpack_pack_bin(spacker, s_.size); \\\n      if (s_.size > 0) { \\\n        msgpack_pack_bin_body(spacker, s_.data, s_.size); \\\n      } \\\n    } while (0)\n\n/// Write single ShaDa entry\n///\n/// @param[in]  packer     Packer used to write entry.\n/// @param[in]  entry      Entry written.\n/// @param[in]  max_kbyte  Maximum size of an item in KiB. Zero means no\n///                        restrictions.\n///\n/// @return kSDWriteSuccessfull, kSDWriteFailed or kSDWriteIgnError.\nstatic ShaDaWriteResult shada_pack_entry(msgpack_packer *const packer,\n                                         ShadaEntry entry,\n                                         const size_t max_kbyte)\n  FUNC_ATTR_NONNULL_ALL\n{\n  ShaDaWriteResult ret = kSDWriteFailed;\n  msgpack_sbuffer sbuf;\n  msgpack_sbuffer_init(&sbuf);\n  msgpack_packer *spacker = msgpack_packer_new(&sbuf, &msgpack_sbuffer_write);\n#define DUMP_ADDITIONAL_ELEMENTS(src, what) \\\n  do { \\\n    if ((src) != NULL) { \\\n      TV_LIST_ITER((src), li, { \\\n        if (encode_vim_to_msgpack(spacker, TV_LIST_ITEM_TV(li), \\\n                                  _(\"additional elements of ShaDa \" what)) \\\n            == FAIL) { \\\n          goto shada_pack_entry_error; \\\n        } \\\n      }); \\\n    } \\\n  } while (0)\n#define DUMP_ADDITIONAL_DATA(src, what) \\\n  do { \\\n    dict_T *const d = (src); \\\n    if (d != NULL) { \\\n      size_t todo = d->dv_hashtab.ht_used; \\\n      for (const hashitem_T *hi= d->dv_hashtab.ht_array; todo; hi++) { \\\n        if (!HASHITEM_EMPTY(hi)) { \\\n          todo--; \\\n          dictitem_T *const di = TV_DICT_HI2DI(hi); \\\n          const size_t key_len = strlen((const char *)hi->hi_key); \\\n          msgpack_pack_str(spacker, key_len); \\\n          msgpack_pack_str_body(spacker, (const char *)hi->hi_key, key_len); \\\n          if (encode_vim_to_msgpack(spacker, &di->di_tv, \\\n                                    _(\"additional data of ShaDa \" what)) \\\n              == FAIL) { \\\n            goto shada_pack_entry_error; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  } while (0)\n#define CHECK_DEFAULT(entry, attr) \\\n  (sd_default_values[entry.type].data.attr == entry.data.attr)\n#define ONE_IF_NOT_DEFAULT(entry, attr) \\\n  ((size_t) (!CHECK_DEFAULT(entry, attr)))\n  switch (entry.type) {\n    case kSDItemMissing: {\n      abort();\n    }\n    case kSDItemUnknown: {\n      if (spacker->callback(spacker->data, entry.data.unknown_item.contents,\n                            (unsigned) entry.data.unknown_item.size) == -1) {\n        goto shada_pack_entry_error;\n      }\n      break;\n    }\n    case kSDItemHistoryEntry: {\n      const bool is_hist_search =\n          entry.data.history_item.histtype == HIST_SEARCH;\n      const size_t arr_size = 2 + (size_t)is_hist_search + (size_t)(\n          tv_list_len(entry.data.history_item.additional_elements));\n      msgpack_pack_array(spacker, arr_size);\n      msgpack_pack_uint8(spacker, entry.data.history_item.histtype);\n      PACK_BIN(cstr_as_string(entry.data.history_item.string));\n      if (is_hist_search) {\n        msgpack_pack_uint8(spacker, (uint8_t)entry.data.history_item.sep);\n      }\n      DUMP_ADDITIONAL_ELEMENTS(entry.data.history_item.additional_elements,\n                               \"history entry item\");\n      break;\n    }\n    case kSDItemVariable: {\n      const size_t arr_size = 2 + (size_t)(\n          tv_list_len(entry.data.global_var.additional_elements));\n      msgpack_pack_array(spacker, arr_size);\n      const String varname = cstr_as_string(entry.data.global_var.name);\n      PACK_BIN(varname);\n      char vardesc[256] = \"variable g:\";\n      memcpy(&vardesc[sizeof(\"variable g:\") - 1], varname.data,\n             varname.size + 1);\n      if (encode_vim_to_msgpack(spacker, &entry.data.global_var.value, vardesc)\n          == FAIL) {\n        ret = kSDWriteIgnError;\n        EMSG2(_(WERR \"Failed to write variable %s\"),\n              entry.data.global_var.name);\n        goto shada_pack_entry_error;\n      }\n      DUMP_ADDITIONAL_ELEMENTS(entry.data.global_var.additional_elements,\n                               \"variable item\");\n      break;\n    }\n    case kSDItemSubString: {\n      const size_t arr_size = 1 + (size_t)(\n          tv_list_len(entry.data.sub_string.additional_elements));\n      msgpack_pack_array(spacker, arr_size);\n      PACK_BIN(cstr_as_string(entry.data.sub_string.sub));\n      DUMP_ADDITIONAL_ELEMENTS(entry.data.sub_string.additional_elements,\n                               \"sub string item\");\n      break;\n    }\n    case kSDItemSearchPattern: {\n      const size_t map_size = (size_t) (\n          1  // Search pattern is always present\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.magic)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_last_used)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.smartcase)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.has_line_offset)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.place_cursor_at_end)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_substitute_pattern)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.highlighted)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.offset)\n          + ONE_IF_NOT_DEFAULT(entry, search_pattern.search_backward)\n          // finally, additional data:\n          + (size_t) (\n              entry.data.search_pattern.additional_data\n              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used\n              : 0));\n      msgpack_pack_map(spacker, map_size);\n      PACK_STATIC_STR(SEARCH_KEY_PAT);\n      PACK_BIN(cstr_as_string(entry.data.search_pattern.pat));\n#define PACK_BOOL(entry, name, attr) \\\n      do { \\\n        if (!CHECK_DEFAULT(entry, search_pattern.attr)) { \\\n          PACK_STATIC_STR(name); \\\n          if (sd_default_values[entry.type].data.search_pattern.attr) { \\\n            msgpack_pack_false(spacker); \\\n          } else { \\\n            msgpack_pack_true(spacker); \\\n          } \\\n        } \\\n      } while (0)\n      PACK_BOOL(entry, SEARCH_KEY_MAGIC, magic);\n      PACK_BOOL(entry, SEARCH_KEY_IS_LAST_USED, is_last_used);\n      PACK_BOOL(entry, SEARCH_KEY_SMARTCASE, smartcase);\n      PACK_BOOL(entry, SEARCH_KEY_HAS_LINE_OFFSET, has_line_offset);\n      PACK_BOOL(entry, SEARCH_KEY_PLACE_CURSOR_AT_END, place_cursor_at_end);\n      PACK_BOOL(entry, SEARCH_KEY_IS_SUBSTITUTE_PATTERN, is_substitute_pattern);\n      PACK_BOOL(entry, SEARCH_KEY_HIGHLIGHTED, highlighted);\n      PACK_BOOL(entry, SEARCH_KEY_BACKWARD, search_backward);\n      if (!CHECK_DEFAULT(entry, search_pattern.offset)) {\n        PACK_STATIC_STR(SEARCH_KEY_OFFSET);\n        msgpack_pack_int64(spacker, entry.data.search_pattern.offset);\n      }\n#undef PACK_BOOL\n      DUMP_ADDITIONAL_DATA(entry.data.search_pattern.additional_data,\n                           \"search pattern item\");\n      break;\n    }\n    case kSDItemChange:\n    case kSDItemGlobalMark:\n    case kSDItemLocalMark:\n    case kSDItemJump: {\n      const size_t map_size = (size_t) (\n          1  // File name\n          + ONE_IF_NOT_DEFAULT(entry, filemark.mark.lnum)\n          + ONE_IF_NOT_DEFAULT(entry, filemark.mark.col)\n          + ONE_IF_NOT_DEFAULT(entry, filemark.name)\n          // Additional entries, if any:\n          + (size_t) (\n              entry.data.filemark.additional_data == NULL\n              ? 0\n              : entry.data.filemark.additional_data->dv_hashtab.ht_used));\n      msgpack_pack_map(spacker, map_size);\n      PACK_STATIC_STR(KEY_FILE);\n      PACK_BIN(cstr_as_string(entry.data.filemark.fname));\n      if (!CHECK_DEFAULT(entry, filemark.mark.lnum)) {\n        PACK_STATIC_STR(KEY_LNUM);\n        msgpack_pack_long(spacker, entry.data.filemark.mark.lnum);\n      }\n      if (!CHECK_DEFAULT(entry, filemark.mark.col)) {\n        PACK_STATIC_STR(KEY_COL);\n        msgpack_pack_long(spacker, entry.data.filemark.mark.col);\n      }\n      assert(entry.type == kSDItemJump || entry.type == kSDItemChange\n             ? CHECK_DEFAULT(entry, filemark.name)\n             : true);\n      if (!CHECK_DEFAULT(entry, filemark.name)) {\n        PACK_STATIC_STR(KEY_NAME_CHAR);\n        msgpack_pack_uint8(spacker, (uint8_t) entry.data.filemark.name);\n      }\n      DUMP_ADDITIONAL_DATA(entry.data.filemark.additional_data,\n                           \"mark (change, jump, global or local) item\");\n      break;\n    }\n    case kSDItemRegister: {\n      const size_t map_size = (size_t) (\n          2  // Register contents and name\n          + ONE_IF_NOT_DEFAULT(entry, reg.type)\n          + ONE_IF_NOT_DEFAULT(entry, reg.width)\n          + ONE_IF_NOT_DEFAULT(entry, reg.is_unnamed)\n          // Additional entries, if any:\n          + (size_t) (entry.data.reg.additional_data == NULL\n                      ? 0\n                      : entry.data.reg.additional_data->dv_hashtab.ht_used));\n      msgpack_pack_map(spacker, map_size);\n      PACK_STATIC_STR(REG_KEY_CONTENTS);\n      msgpack_pack_array(spacker, entry.data.reg.contents_size);\n      for (size_t i = 0; i < entry.data.reg.contents_size; i++) {\n        PACK_BIN(cstr_as_string(entry.data.reg.contents[i]));\n      }\n      PACK_STATIC_STR(KEY_NAME_CHAR);\n      msgpack_pack_char(spacker, entry.data.reg.name);\n      if (!CHECK_DEFAULT(entry, reg.type)) {\n        PACK_STATIC_STR(REG_KEY_TYPE);\n        msgpack_pack_uint8(spacker, (uint8_t)entry.data.reg.type);\n      }\n      if (!CHECK_DEFAULT(entry, reg.width)) {\n        PACK_STATIC_STR(REG_KEY_WIDTH);\n        msgpack_pack_uint64(spacker, (uint64_t) entry.data.reg.width);\n      }\n      if (!CHECK_DEFAULT(entry, reg.is_unnamed)) {\n        PACK_STATIC_STR(REG_KEY_UNNAMED);\n        if (entry.data.reg.is_unnamed) {\n          msgpack_pack_true(spacker);\n        } else {\n          msgpack_pack_false(spacker);\n        }\n      }\n      DUMP_ADDITIONAL_DATA(entry.data.reg.additional_data, \"register item\");\n      break;\n    }\n    case kSDItemBufferList: {\n      msgpack_pack_array(spacker, entry.data.buffer_list.size);\n      for (size_t i = 0; i < entry.data.buffer_list.size; i++) {\n        const size_t map_size = (size_t) (\n            1  // Buffer name\n            + (size_t) (entry.data.buffer_list.buffers[i].pos.lnum\n                        != default_pos.lnum)\n            + (size_t) (entry.data.buffer_list.buffers[i].pos.col\n                        != default_pos.col)\n            // Additional entries, if any:\n            + (size_t) (\n                entry.data.buffer_list.buffers[i].additional_data == NULL\n                ? 0\n                : (entry.data.buffer_list.buffers[i].additional_data\n                   ->dv_hashtab.ht_used)));\n        msgpack_pack_map(spacker, map_size);\n        PACK_STATIC_STR(KEY_FILE);\n        PACK_BIN(cstr_as_string(entry.data.buffer_list.buffers[i].fname));\n        if (entry.data.buffer_list.buffers[i].pos.lnum != 1) {\n          PACK_STATIC_STR(KEY_LNUM);\n          msgpack_pack_uint64(\n              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.lnum);\n        }\n        if (entry.data.buffer_list.buffers[i].pos.col != 0) {\n          PACK_STATIC_STR(KEY_COL);\n          msgpack_pack_uint64(\n              spacker, (uint64_t) entry.data.buffer_list.buffers[i].pos.col);\n        }\n        DUMP_ADDITIONAL_DATA(entry.data.buffer_list.buffers[i].additional_data,\n                             \"buffer list subitem\");\n      }\n      break;\n    }\n    case kSDItemHeader: {\n      msgpack_pack_map(spacker, entry.data.header.size);\n      for (size_t i = 0; i < entry.data.header.size; i++) {\n        PACK_STRING(entry.data.header.items[i].key);\n        const Object obj = entry.data.header.items[i].value;\n        switch (obj.type) {\n          case kObjectTypeString: {\n            PACK_BIN(obj.data.string);\n            break;\n          }\n          case kObjectTypeInteger: {\n            msgpack_pack_int64(spacker, (int64_t) obj.data.integer);\n            break;\n          }\n          default: {\n            abort();\n          }\n        }\n      }\n      break;\n    }\n  }\n#undef CHECK_DEFAULT\n#undef ONE_IF_NOT_DEFAULT\n  if (!max_kbyte || sbuf.size <= max_kbyte * 1024) {\n    if (entry.type == kSDItemUnknown) {\n      if (msgpack_pack_uint64(packer, entry.data.unknown_item.type) == -1) {\n        goto shada_pack_entry_error;\n      }\n    } else {\n      if (msgpack_pack_uint64(packer, (uint64_t) entry.type) == -1) {\n        goto shada_pack_entry_error;\n      }\n    }\n    if (msgpack_pack_uint64(packer, (uint64_t) entry.timestamp) == -1) {\n      goto shada_pack_entry_error;\n    }\n    if (sbuf.size > 0) {\n      if ((msgpack_pack_uint64(packer, (uint64_t) sbuf.size) == -1)\n          || (packer->callback(packer->data, sbuf.data,\n                               (unsigned) sbuf.size) == -1)) {\n        goto shada_pack_entry_error;\n      }\n    }\n  }\n  msgpack_packer_free(spacker);\n  msgpack_sbuffer_destroy(&sbuf);\n  return kSDWriteSuccessfull;\nshada_pack_entry_error:\n  msgpack_packer_free(spacker);\n  msgpack_sbuffer_destroy(&sbuf);\n  return ret;\n}\n#undef PACK_STRING\n\n/// Write single ShaDa entry and free it afterwards\n///\n/// Will not free if entry could not be freed.\n///\n/// @param[in]  packer     Packer used to write entry.\n/// @param[in]  entry      Entry written.\n/// @param[in]  max_kbyte  Maximum size of an item in KiB. Zero means no\n///                        restrictions.\nstatic inline ShaDaWriteResult shada_pack_pfreed_entry(\n    msgpack_packer *const packer, PossiblyFreedShadaEntry entry,\n    const size_t max_kbyte)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE\n{\n  ShaDaWriteResult ret = kSDWriteSuccessfull;\n  ret = shada_pack_entry(packer, entry.data, max_kbyte);\n  if (entry.can_free_entry) {\n    shada_free_shada_entry(&entry.data);\n  }\n  return ret;\n}\n\n/// Compare two FileMarks structure to order them by greatest_timestamp\n///\n/// Order is reversed: structure with greatest greatest_timestamp comes first.\n/// Function signature is compatible with qsort.\nstatic int compare_file_marks(const void *a, const void *b)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE\n{\n  const FileMarks *const *const a_fms = a;\n  const FileMarks *const *const b_fms = b;\n  return ((*a_fms)->greatest_timestamp == (*b_fms)->greatest_timestamp\n          ? 0\n          : ((*a_fms)->greatest_timestamp > (*b_fms)->greatest_timestamp\n             ? -1\n             : 1));\n}\n\n/// Parse msgpack object that has given length\n///\n/// @param[in]   sd_reader     Structure containing file reader definition.\n/// @param[in]   length        Object length.\n/// @param[out]  ret_unpacked  Location where read result should be saved. If\n///                            NULL then unpacked data will be freed. Must be\n///                            NULL if `ret_buf` is NULL.\n/// @param[out]  ret_buf       Buffer containing parsed string.\n///\n/// @return kSDReadStatusNotShaDa, kSDReadStatusReadError or\n///         kSDReadStatusSuccess.\nstatic inline ShaDaReadResult shada_parse_msgpack(\n    ShaDaReadDef *const sd_reader, const size_t length,\n    msgpack_unpacked *ret_unpacked, char **const ret_buf)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)\n{\n  const uintmax_t initial_fpos = sd_reader->fpos;\n  char *const buf = xmalloc(length);\n\n  const ShaDaReadResult fl_ret = fread_len(sd_reader, buf, length);\n  if (fl_ret != kSDReadStatusSuccess) {\n    xfree(buf);\n    return fl_ret;\n  }\n  bool did_try_to_free = false;\nshada_parse_msgpack_read_next: {}\n  size_t off = 0;\n  msgpack_unpacked unpacked;\n  msgpack_unpacked_init(&unpacked);\n  const msgpack_unpack_return result =\n      msgpack_unpack_next(&unpacked, buf, length, &off);\n  ShaDaReadResult ret = kSDReadStatusSuccess;\n  switch (result) {\n    case MSGPACK_UNPACK_SUCCESS: {\n      if (off < length) {\n        goto shada_parse_msgpack_extra_bytes;\n      }\n      break;\n    }\n    case MSGPACK_UNPACK_PARSE_ERROR: {\n      emsgf(_(RCERR \"Failed to parse ShaDa file due to a msgpack parser error \"\n              \"at position %\" PRIu64),\n            (uint64_t) initial_fpos);\n      ret = kSDReadStatusNotShaDa;\n      break;\n    }\n    case MSGPACK_UNPACK_NOMEM_ERROR: {\n      if (!did_try_to_free) {\n        did_try_to_free = true;\n        try_to_free_memory();\n        goto shada_parse_msgpack_read_next;\n      }\n      EMSG(_(e_outofmem));\n      ret = kSDReadStatusReadError;\n      break;\n    }\n    case MSGPACK_UNPACK_CONTINUE: {\n      emsgf(_(RCERR \"Failed to parse ShaDa file: incomplete msgpack string \"\n              \"at position %\" PRIu64),\n            (uint64_t) initial_fpos);\n      ret = kSDReadStatusNotShaDa;\n      break;\n    }\n    case MSGPACK_UNPACK_EXTRA_BYTES: {\nshada_parse_msgpack_extra_bytes:\n      emsgf(_(RCERR \"Failed to parse ShaDa file: extra bytes in msgpack string \"\n              \"at position %\" PRIu64),\n            (uint64_t) initial_fpos);\n      ret = kSDReadStatusNotShaDa;\n      break;\n    }\n  }\n  if (ret_buf != NULL && ret == kSDReadStatusSuccess) {\n    if (ret_unpacked == NULL) {\n      msgpack_unpacked_destroy(&unpacked);\n    } else {\n      *ret_unpacked = unpacked;\n    }\n    *ret_buf = buf;\n  } else {\n    assert(ret_buf == NULL || ret != kSDReadStatusSuccess);\n    msgpack_unpacked_destroy(&unpacked);\n    xfree(buf);\n  }\n  return ret;\n}\n\n/// Format shada entry for debugging purposes\n///\n/// @param[in]  entry  ShaDa entry to format.\n///\n/// @return string representing ShaDa entry in a static buffer.\nstatic const char *shada_format_entry(const ShadaEntry entry)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET\n{\n  static char ret[1024];\n  ret[0] = 0;\n  vim_snprintf(S_LEN(ret), \"%s\", \"[ ] ts=%\" PRIu64 \" \");\n  //                         ^ Space for `can_free_entry`\n  switch (entry.type) {\n    case kSDItemMissing: {\n      vim_snprintf_add(S_LEN(ret), \"Missing\");\n      break;\n    }\n    case kSDItemHeader: {\n      vim_snprintf_add(S_LEN(ret), \"Header { TODO }\");\n      break;\n    }\n    case kSDItemBufferList: {\n      vim_snprintf_add(S_LEN(ret), \"BufferList { TODO }\");\n      break;\n    }\n    case kSDItemUnknown: {\n      vim_snprintf_add(S_LEN(ret), \"Unknown { TODO }\");\n      break;\n    }\n    case kSDItemSearchPattern: {\n      vim_snprintf_add(S_LEN(ret), \"SearchPattern { TODO }\");\n      break;\n    }\n    case kSDItemSubString: {\n      vim_snprintf_add(S_LEN(ret), \"SubString { TODO }\");\n      break;\n    }\n    case kSDItemHistoryEntry: {\n      vim_snprintf_add(S_LEN(ret), \"HistoryEntry { TODO }\");\n      break;\n    }\n    case kSDItemRegister: {\n      vim_snprintf_add(S_LEN(ret), \"Register { TODO }\");\n      break;\n    }\n    case kSDItemVariable: {\n      vim_snprintf_add(S_LEN(ret), \"Variable { TODO }\");\n      break;\n    }\n#define FORMAT_MARK_ENTRY(entry_name, name_fmt, name_fmt_arg) \\\n    do { \\\n      typval_T ad_tv = { \\\n        .v_type = VAR_DICT, \\\n        .vval.v_dict = entry.data.filemark.additional_data \\\n      }; \\\n      size_t ad_len; \\\n      char *const ad = encode_tv2string(&ad_tv, &ad_len); \\\n      vim_snprintf_add( \\\n          S_LEN(ret), \\\n          entry_name \" {\" name_fmt \" file=[%zu]\\\"%.512s\\\", \" \\\n          \"pos={l=%\" PRIdLINENR \",c=%\" PRIdCOLNR \",a=%\" PRIdCOLNR \"}, \" \\\n          \"ad={%p:[%zu]%.64s} }\", \\\n          name_fmt_arg, \\\n          strlen(entry.data.filemark.fname), \\\n          entry.data.filemark.fname, \\\n          entry.data.filemark.mark.lnum, \\\n          entry.data.filemark.mark.col, \\\n          entry.data.filemark.mark.coladd, \\\n          (void *)entry.data.filemark.additional_data, \\\n          ad_len, \\\n          ad); \\\n    } while (0)\n    case kSDItemGlobalMark: {\n      FORMAT_MARK_ENTRY(\"GlobalMark\", \" name='%c',\", entry.data.filemark.name);\n      break;\n    }\n    case kSDItemChange: {\n      FORMAT_MARK_ENTRY(\"Change\", \"%s\", \"\");\n      break;\n    }\n    case kSDItemLocalMark: {\n      FORMAT_MARK_ENTRY(\"LocalMark\", \" name='%c',\", entry.data.filemark.name);\n      break;\n    }\n    case kSDItemJump: {\n      FORMAT_MARK_ENTRY(\"Jump\", \"%s\", \"\");\n      break;\n    }\n#undef FORMAT_MARK_ENTRY\n  }\n  return ret;\n}\n\n/// Format possibly freed shada entry for debugging purposes\n///\n/// @param[in]  entry  ShaDa entry to format.\n///\n/// @return string representing ShaDa entry in a static buffer.\nstatic const char *shada_format_pfreed_entry(\n    const PossiblyFreedShadaEntry pfs_entry)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_UNUSED FUNC_ATTR_NONNULL_RET\n{\n  char *ret = (char *)shada_format_entry(pfs_entry.data);\n  ret[1] = (pfs_entry.can_free_entry ? 'T' : 'F');\n  return ret;\n}\n\n/// Read and merge in ShaDa file, used when writing\n///\n/// @param[in]      sd_reader   Structure containing file reader definition.\n/// @param[in]      srni_flags  Flags determining what to read.\n/// @param[in]      max_kbyte   Maximum size of one element.\n/// @param[in,out]  ret_wms     Location where results are saved.\n/// @param[out]     packer      MessagePack packer for entries which are not\n///                             merged.\nstatic inline ShaDaWriteResult shada_read_when_writing(\n    ShaDaReadDef *const sd_reader, const unsigned srni_flags,\n    const size_t max_kbyte, WriteMergerState *const wms,\n    msgpack_packer *const packer)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  ShaDaWriteResult ret = kSDWriteSuccessfull;\n  ShadaEntry entry;\n  ShaDaReadResult srni_ret;\n  while ((srni_ret = shada_read_next_item(sd_reader, &entry, srni_flags,\n                                          max_kbyte))\n         != kSDReadStatusFinished) {\n    switch (srni_ret) {\n      case kSDReadStatusSuccess: {\n        break;\n      }\n      case kSDReadStatusFinished: {\n        // Should be handled by the while condition.\n        abort();\n      }\n      case kSDReadStatusNotShaDa: {\n        ret = kSDWriteReadNotShada;\n        FALLTHROUGH;\n      }\n      case kSDReadStatusReadError: {\n        return ret;\n      }\n      case kSDReadStatusMalformed: {\n        continue;\n      }\n    }\n#define COMPARE_WITH_ENTRY(wms_entry_, entry) \\\n    do { \\\n      PossiblyFreedShadaEntry *const wms_entry = (wms_entry_); \\\n      if (wms_entry->data.type != kSDItemMissing) { \\\n        if (wms_entry->data.timestamp >= (entry).timestamp) { \\\n          shada_free_shada_entry(&(entry)); \\\n          break; \\\n        } \\\n        if (wms_entry->can_free_entry) { \\\n          shada_free_shada_entry(&wms_entry->data); \\\n        } \\\n      } \\\n      *wms_entry = pfs_entry; \\\n    } while (0)\n    const PossiblyFreedShadaEntry pfs_entry = {\n      .can_free_entry = true,\n      .data = entry,\n    };\n    switch (entry.type) {\n      case kSDItemMissing: {\n        break;\n      }\n      case kSDItemHeader:\n      case kSDItemBufferList: {\n        abort();\n      }\n      case kSDItemUnknown: {\n        ret = shada_pack_entry(packer, entry, 0);\n        shada_free_shada_entry(&entry);\n        break;\n      }\n      case kSDItemSearchPattern: {\n        COMPARE_WITH_ENTRY((entry.data.search_pattern.is_substitute_pattern\n                            ? &wms->sub_search_pattern\n                            : &wms->search_pattern), entry);\n        break;\n      }\n      case kSDItemSubString: {\n        COMPARE_WITH_ENTRY(&wms->replacement, entry);\n        break;\n      }\n      case kSDItemHistoryEntry: {\n        if (entry.data.history_item.histtype >= HIST_COUNT) {\n          ret = shada_pack_entry(packer, entry, 0);\n          shada_free_shada_entry(&entry);\n          break;\n        }\n        if (wms->hms[entry.data.history_item.histtype].hmll.size != 0) {\n          hms_insert(&wms->hms[entry.data.history_item.histtype], entry, true,\n                     true);\n        } else {\n          shada_free_shada_entry(&entry);\n        }\n        break;\n      }\n      case kSDItemRegister: {\n        const int idx = op_reg_index(entry.data.reg.name);\n        if (idx < 0) {\n          ret = shada_pack_entry(packer, entry, 0);\n          shada_free_shada_entry(&entry);\n          break;\n        }\n        COMPARE_WITH_ENTRY(&wms->registers[idx], entry);\n        break;\n      }\n      case kSDItemVariable: {\n        if (!in_strset(&wms->dumped_variables, entry.data.global_var.name)) {\n          ret = shada_pack_entry(packer, entry, 0);\n        }\n        shada_free_shada_entry(&entry);\n        break;\n      }\n      case kSDItemGlobalMark: {\n        if (ascii_isdigit(entry.data.filemark.name)) {\n          bool processed_mark = false;\n          // Completely ignore numbered mark names, make a list sorted by\n          // timestamp.\n          for (size_t i = ARRAY_SIZE(wms->numbered_marks); i > 0; i--) {\n            ShadaEntry wms_entry = wms->numbered_marks[i - 1].data;\n            if (wms_entry.type != kSDItemGlobalMark) {\n              continue;\n            }\n            // Ignore duplicates.\n            if (wms_entry.timestamp == entry.timestamp\n                && (wms_entry.data.filemark.additional_data == NULL\n                    && entry.data.filemark.additional_data == NULL)\n                && marks_equal(wms_entry.data.filemark.mark,\n                               entry.data.filemark.mark)\n                && strcmp(wms_entry.data.filemark.fname,\n                          entry.data.filemark.fname) == 0) {\n              shada_free_shada_entry(&entry);\n              processed_mark = true;\n              break;\n            }\n            if (wms_entry.timestamp >= entry.timestamp) {\n              processed_mark = true;\n              if (i < ARRAY_SIZE(wms->numbered_marks)) {\n                replace_numbered_mark(wms, i, pfs_entry);\n              } else {\n                shada_free_shada_entry(&entry);\n              }\n              break;\n            }\n          }\n          if (!processed_mark) {\n            replace_numbered_mark(wms, 0, pfs_entry);\n          }\n        } else {\n          const int idx = mark_global_index(entry.data.filemark.name);\n          if (idx < 0) {\n            ret = shada_pack_entry(packer, entry, 0);\n            shada_free_shada_entry(&entry);\n            break;\n          }\n          COMPARE_WITH_ENTRY(&wms->global_marks[idx], entry);\n        }\n        break;\n      }\n      case kSDItemChange:\n      case kSDItemLocalMark: {\n        if (shada_removable(entry.data.filemark.fname)) {\n          shada_free_shada_entry(&entry);\n          break;\n        }\n        const char *const fname = (const char *) entry.data.filemark.fname;\n        khiter_t k;\n        int kh_ret;\n        k = kh_put(file_marks, &wms->file_marks, fname, &kh_ret);\n        FileMarks *const filemarks = &kh_val(&wms->file_marks, k);\n        if (kh_ret > 0) {\n          memset(filemarks, 0, sizeof(*filemarks));\n        }\n        if (entry.timestamp > filemarks->greatest_timestamp) {\n          filemarks->greatest_timestamp = entry.timestamp;\n        }\n        if (entry.type == kSDItemLocalMark) {\n          const int idx = mark_local_index(entry.data.filemark.name);\n          if (idx < 0) {\n            filemarks->additional_marks = xrealloc(\n                filemarks->additional_marks,\n                (++filemarks->additional_marks_size\n                 * sizeof(filemarks->additional_marks[0])));\n            filemarks->additional_marks[filemarks->additional_marks_size - 1] =\n                entry;\n          } else {\n            PossiblyFreedShadaEntry *const wms_entry = &filemarks->marks[idx];\n            if (wms_entry->data.type != kSDItemMissing) {\n              if (wms_entry->data.timestamp >= entry.timestamp) {\n                shada_free_shada_entry(&entry);\n                break;\n              }\n              if (wms_entry->can_free_entry) {\n                if (kh_key(&wms->file_marks, k)\n                    == wms_entry->data.data.filemark.fname) {\n                  kh_key(&wms->file_marks, k) = entry.data.filemark.fname;\n                }\n                shada_free_shada_entry(&wms_entry->data);\n              }\n            }\n            *wms_entry = pfs_entry;\n          }\n        } else {\n#define FREE_POSSIBLY_FREED_SHADA_ENTRY(entry) \\\n        do { \\\n          if (entry.can_free_entry) { \\\n            shada_free_shada_entry(&entry.data); \\\n          } \\\n        } while (0)\n#define SDE_TO_PFSDE(entry) \\\n        ((PossiblyFreedShadaEntry) { .can_free_entry = true, .data = entry })\n#define AFTERFREE_DUMMY(entry)\n#define DUMMY_IDX_ADJ(i)\n          MERGE_JUMPS(filemarks->changes_size, filemarks->changes,\n                      PossiblyFreedShadaEntry, data.timestamp,\n                      data.data.filemark.mark, entry, true,\n                      FREE_POSSIBLY_FREED_SHADA_ENTRY, SDE_TO_PFSDE,\n                      DUMMY_IDX_ADJ, AFTERFREE_DUMMY);\n        }\n        break;\n      }\n      case kSDItemJump: {\n        MERGE_JUMPS(wms->jumps_size, wms->jumps, PossiblyFreedShadaEntry,\n                    data.timestamp, data.data.filemark.mark, entry,\n                    strcmp(jl_entry.data.data.filemark.fname,\n                           entry.data.filemark.fname) == 0,\n                    FREE_POSSIBLY_FREED_SHADA_ENTRY, SDE_TO_PFSDE,\n                    DUMMY_IDX_ADJ, AFTERFREE_DUMMY);\n#undef FREE_POSSIBLY_FREED_SHADA_ENTRY\n#undef SDE_TO_PFSDE\n#undef DUMMY_IDX_ADJ\n#undef AFTERFREE_DUMMY\n        break;\n      }\n    }\n  }\n#undef COMPARE_WITH_ENTRY\n  return ret;\n}\n\n/// Check whether buffer should be ignored\n///\n/// @param[in]  buf  buf_T* to check.\n/// @param[in]  removable_bufs  Cache of buffers ignored due to their location.\n///\n/// @return true or false.\nstatic inline bool ignore_buf(const buf_T *const buf,\n                              khash_t(bufset) *const removable_bufs)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE\n{\n  return (buf->b_ffname == NULL || !buf->b_p_bl || bt_quickfix(buf) \\\n          || bt_terminal(buf) || in_bufset(removable_bufs, buf));\n}\n\n/// Get list of buffers to write to the shada file\n///\n/// @param[in]  removable_bufs  Buffers which are ignored\n///\n/// @return  ShadaEntry  List of buffers to save, kSDItemBufferList entry.\nstatic inline ShadaEntry shada_get_buflist(\n    khash_t(bufset) *const removable_bufs)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE\n{\n  int max_bufs = get_shada_parameter('%');\n  size_t buf_count = 0;\n  FOR_ALL_BUFFERS(buf) {\n    if (!ignore_buf(buf, removable_bufs)\n        && (max_bufs < 0 || buf_count < (size_t)max_bufs)) {\n      buf_count++;\n    }\n  }\n\n  ShadaEntry buflist_entry = (ShadaEntry) {\n    .type = kSDItemBufferList,\n      .timestamp = os_time(),\n      .data = {\n        .buffer_list = {\n          .size = buf_count,\n          .buffers = xmalloc(buf_count\n                             * sizeof(*buflist_entry.data.buffer_list.buffers)),\n        },\n      },\n  };\n  size_t i = 0;\n  FOR_ALL_BUFFERS(buf) {\n    if (ignore_buf(buf, removable_bufs)) {\n      continue;\n    }\n    if (i >= buf_count) {\n      break;\n    }\n    buflist_entry.data.buffer_list.buffers[i] = (struct buffer_list_buffer) {\n      .pos = buf->b_last_cursor.mark,\n        .fname = (char *)buf->b_ffname,\n        .additional_data = buf->additional_data,\n    };\n    i++;\n  }\n\n  return buflist_entry;\n}\n\n/// Save search pattern to PossiblyFreedShadaEntry\n///\n/// @param[out]  ret_pse  Location where result will be saved.\n/// @param[in]  get_pattern  Function used to get pattern.\n/// @param[in]  is_substitute_pattern  True if pattern in question is substitute\n///                                    pattern. Also controls whether some\n///                                    fields should be initialized to default\n///                                    or values from get_pattern.\n/// @param[in]  search_last_used  Result of search_was_last_used().\n/// @param[in]  search_highlighted  True if search pattern was highlighted by\n///                                 &hlsearch and this information should be\n///                                 saved.\nstatic inline void add_search_pattern(PossiblyFreedShadaEntry *const ret_pse,\n                                      const SearchPatternGetter get_pattern,\n                                      const bool is_substitute_pattern,\n                                      const bool search_last_used,\n                                      const bool search_highlighted)\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  const ShadaEntry defaults = sd_default_values[kSDItemSearchPattern];\n  SearchPattern pat;\n  get_pattern(&pat);\n  if (pat.pat != NULL) {\n    *ret_pse = (PossiblyFreedShadaEntry) {\n      .can_free_entry = false,\n      .data = {\n        .type = kSDItemSearchPattern,\n        .timestamp = pat.timestamp,\n        .data = {\n          .search_pattern = {\n            .magic = pat.magic,\n            .smartcase = !pat.no_scs,\n            .has_line_offset = (is_substitute_pattern\n                                ? defaults.data.search_pattern.has_line_offset\n                                : pat.off.line),\n            .place_cursor_at_end = (\n                is_substitute_pattern\n                ? defaults.data.search_pattern.place_cursor_at_end\n                : pat.off.end),\n            .offset = (is_substitute_pattern\n                       ? defaults.data.search_pattern.offset\n                       : pat.off.off),\n            .is_last_used = (is_substitute_pattern ^ search_last_used),\n            .is_substitute_pattern = is_substitute_pattern,\n            .highlighted = ((is_substitute_pattern ^ search_last_used)\n                            && search_highlighted),\n            .pat = (char *)pat.pat,\n            .additional_data = pat.additional_data,\n            .search_backward = (!is_substitute_pattern && pat.off.dir == '?'),\n          }\n        }\n      }\n    };\n  }\n}\n\n/// Initialize registers for writing to the ShaDa file\n///\n/// @param[in]  wms  The WriteMergerState used when writing.\n/// @param[in]  max_reg_lines  The maximum number of register lines.\nstatic inline void shada_initialize_registers(WriteMergerState *const wms,\n                                              int max_reg_lines)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE\n{\n  const void *reg_iter = NULL;\n  const bool limit_reg_lines = max_reg_lines >= 0;\n  do {\n    yankreg_T reg;\n    char name = NUL;\n    bool is_unnamed = false;\n    reg_iter = op_global_reg_iter(reg_iter, &name, &reg, &is_unnamed);\n    if (name == NUL) {\n      break;\n    }\n    if (limit_reg_lines && reg.y_size > (size_t)max_reg_lines) {\n      continue;\n    }\n    wms->registers[op_reg_index(name)] = (PossiblyFreedShadaEntry) {\n      .can_free_entry = false,\n      .data = {\n        .type = kSDItemRegister,\n        .timestamp = reg.timestamp,\n        .data = {\n          .reg = {\n            .contents = (char **)reg.y_array,\n            .contents_size = (size_t)reg.y_size,\n            .type = reg.y_type,\n            .width = (size_t)(reg.y_type == kMTBlockWise ? reg.y_width : 0),\n            .additional_data = reg.additional_data,\n            .name = name,\n            .is_unnamed = is_unnamed,\n          }\n        }\n      }\n    };\n  } while (reg_iter != NULL);\n}\n\n/// Replace numbered mark in WriteMergerState\n///\n/// Frees the last mark, moves (including adjusting mark names) marks from idx\n/// to the last-but-one one and saves the new mark at given index.\n///\n/// @param[out]  wms  Merger state to adjust.\n/// @param[in]  idx  Index at which new mark should be placed.\n/// @param[in]  entry  New mark.\nstatic inline void replace_numbered_mark(WriteMergerState *const wms,\n                                         const size_t idx,\n                                         const PossiblyFreedShadaEntry entry)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE\n{\n  if (ARRAY_LAST_ENTRY(wms->numbered_marks).can_free_entry) {\n    shada_free_shada_entry(&ARRAY_LAST_ENTRY(wms->numbered_marks).data);\n  }\n  for (size_t i = idx; i < ARRAY_SIZE(wms->numbered_marks) - 1; i++) {\n    if (wms->numbered_marks[i].data.type == kSDItemGlobalMark) {\n      wms->numbered_marks[i].data.data.filemark.name = (char)('0' + (int)i + 1);\n    }\n  }\n  memmove(wms->numbered_marks + idx + 1, wms->numbered_marks + idx,\n          sizeof(wms->numbered_marks[0])\n          * (ARRAY_SIZE(wms->numbered_marks) - 1 - idx));\n  wms->numbered_marks[idx] = entry;\n  wms->numbered_marks[idx].data.data.filemark.name = (char)('0' + (int)idx);\n}\n\n/// Find buffers ignored due to their location.\n///\n/// @param[out]  removable_bufs  Cache of buffers ignored due to their location.\nstatic inline void find_removable_bufs(khash_t(bufset) *removable_bufs)\n{\n  FOR_ALL_BUFFERS(buf) {\n    if (buf->b_ffname != NULL && shada_removable((char *)buf->b_ffname)) {\n      int kh_ret;\n      (void)kh_put(bufset, removable_bufs, (uintptr_t)buf, &kh_ret);\n    }\n  }\n}\n\n/// Write ShaDa file\n///\n/// @param[in]  sd_writer  Structure containing file writer definition.\n/// @param[in]  sd_reader  Structure containing file reader definition. If it is\n///                        not NULL then contents of this file will be merged\n///                        with current Neovim runtime.\nstatic ShaDaWriteResult shada_write(ShaDaWriteDef *const sd_writer,\n                                    ShaDaReadDef *const sd_reader)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  ShaDaWriteResult ret = kSDWriteSuccessfull;\n  int max_kbyte_i = get_shada_parameter('s');\n  if (max_kbyte_i < 0) {\n    max_kbyte_i = 10;\n  }\n  if (max_kbyte_i == 0) {\n    return ret;\n  }\n\n  WriteMergerState *const wms = xcalloc(1, sizeof(*wms));\n  bool dump_one_history[HIST_COUNT];\n  const bool dump_global_vars = (find_shada_parameter('!') != NULL);\n  int max_reg_lines = get_shada_parameter('<');\n  if (max_reg_lines < 0) {\n    max_reg_lines = get_shada_parameter('\"');\n  }\n  const bool dump_registers = (max_reg_lines != 0);\n  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);\n  const size_t max_kbyte = (size_t) max_kbyte_i;\n  const size_t num_marked_files = (size_t) get_shada_parameter('\\'');\n  const bool dump_global_marks = get_shada_parameter('f') != 0;\n  bool dump_history = false;\n\n  // Initialize history merger\n  for (uint8_t i = 0; i < HIST_COUNT; i++) {\n    long num_saved = get_shada_parameter(hist_type2char(i));\n    if (num_saved == -1) {\n      num_saved = p_hi;\n    }\n    if (num_saved > 0) {\n      dump_history = true;\n      dump_one_history[i] = true;\n      hms_init(&wms->hms[i], i, (size_t) num_saved, sd_reader != NULL, false);\n    } else {\n      dump_one_history[i] = false;\n    }\n  }\n\n  const unsigned srni_flags = (unsigned) (\n      kSDReadUndisableableData\n      | kSDReadUnknown\n      | (dump_history ? kSDReadHistory : 0)\n      | (dump_registers ? kSDReadRegisters : 0)\n      | (dump_global_vars ? kSDReadVariables : 0)\n      | (dump_global_marks ? kSDReadGlobalMarks : 0)\n      | (num_marked_files ? kSDReadLocalMarks | kSDReadChanges : 0));\n\n  msgpack_packer *const packer = msgpack_packer_new(sd_writer,\n                                                    &msgpack_sd_writer_write);\n\n  // Set b_last_cursor for all the buffers that have a window.\n  //\n  // It is needed to correctly save '\"' mark on exit. Has a side effect of\n  // setting '\"' mark in all windows on :wshada to the current cursor\n  // position (basically what :wviminfo used to do).\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    set_last_cursor(wp);\n  }\n\n  find_removable_bufs(&removable_bufs);\n\n  // Write header\n  if (shada_pack_entry(packer, (ShadaEntry) {\n    .type = kSDItemHeader,\n    .timestamp = os_time(),\n    .data = {\n      .header = {\n        .size = 5,\n        .capacity = 5,\n        .items = ((KeyValuePair[]) {\n          { STATIC_CSTR_AS_STRING(\"generator\"),\n            STRING_OBJ(STATIC_CSTR_AS_STRING(\"nvim\")) },\n          { STATIC_CSTR_AS_STRING(\"version\"),\n            STRING_OBJ(cstr_as_string(longVersion)) },\n          { STATIC_CSTR_AS_STRING(\"max_kbyte\"),\n            INTEGER_OBJ((Integer) max_kbyte) },\n          { STATIC_CSTR_AS_STRING(\"pid\"),\n            INTEGER_OBJ((Integer) os_get_pid()) },\n          { STATIC_CSTR_AS_STRING(\"encoding\"),\n            STRING_OBJ(cstr_as_string((char *) p_enc)) },\n        }),\n      }\n    }\n  }, 0) == kSDWriteFailed) {\n    ret = kSDWriteFailed;\n    goto shada_write_exit;\n  }\n\n  // Write buffer list\n  if (find_shada_parameter('%') != NULL) {\n    ShadaEntry buflist_entry = shada_get_buflist(&removable_bufs);\n    if (shada_pack_entry(packer, buflist_entry, 0) == kSDWriteFailed) {\n      xfree(buflist_entry.data.buffer_list.buffers);\n      ret = kSDWriteFailed;\n      goto shada_write_exit;\n    }\n    xfree(buflist_entry.data.buffer_list.buffers);\n  }\n\n  // Write some of the variables\n  if (dump_global_vars) {\n    const void *var_iter = NULL;\n    const Timestamp cur_timestamp = os_time();\n    do {\n      typval_T vartv;\n      const char *name = NULL;\n      var_iter = var_shada_iter(var_iter, &name, &vartv, VAR_FLAVOUR_SHADA);\n      if (name == NULL) {\n        break;\n      }\n      switch (vartv.v_type) {\n        case VAR_FUNC:\n        case VAR_PARTIAL:\n          tv_clear(&vartv);\n          continue;\n        case VAR_DICT:\n          {\n            dict_T *di = vartv.vval.v_dict;\n            int copyID = get_copyID();\n            if (!set_ref_in_ht(&di->dv_hashtab, copyID, NULL)\n                && copyID == di->dv_copyID) {\n              tv_clear(&vartv);\n              continue;\n            }\n            break;\n          }\n        case VAR_LIST:\n          {\n            list_T *l = vartv.vval.v_list;\n            int copyID = get_copyID();\n            if (!set_ref_in_list(l, copyID, NULL)\n                && copyID == l->lv_copyID) {\n              tv_clear(&vartv);\n              continue;\n            }\n            break;\n          }\n        default:\n          break;\n      }\n      typval_T tgttv;\n      tv_copy(&vartv, &tgttv);\n      ShaDaWriteResult spe_ret;\n      if ((spe_ret = shada_pack_entry(packer, (ShadaEntry) {\n        .type = kSDItemVariable,\n        .timestamp = cur_timestamp,\n        .data = {\n          .global_var = {\n            .name = (char *) name,\n            .value = tgttv,\n            .additional_elements = NULL,\n          }\n        }\n      }, max_kbyte)) == kSDWriteFailed) {\n        tv_clear(&vartv);\n        tv_clear(&tgttv);\n        ret = kSDWriteFailed;\n        goto shada_write_exit;\n      }\n      tv_clear(&vartv);\n      tv_clear(&tgttv);\n      if (spe_ret == kSDWriteSuccessfull) {\n        int kh_ret;\n        (void) kh_put(strset, &wms->dumped_variables, name, &kh_ret);\n      }\n    } while (var_iter != NULL);\n  }\n\n  // Initialize jump list\n  setpcmark();\n  cleanup_jumplist(curwin, false);\n  wms->jumps_size = shada_init_jumps(wms->jumps, &removable_bufs);\n\n  const bool search_highlighted = !(no_hlsearch\n                                    || find_shada_parameter('h') != NULL);\n  const bool search_last_used = search_was_last_used();\n\n  // Initialize search pattern\n  add_search_pattern(&wms->search_pattern, &get_search_pattern, false,\n                     search_last_used, search_highlighted);\n\n  // Initialize substitute search pattern\n  add_search_pattern(&wms->sub_search_pattern, &get_substitute_pattern, true,\n                     search_last_used, search_highlighted);\n\n  // Initialize substitute replacement string\n  {\n    SubReplacementString sub;\n    sub_get_replacement(&sub);\n    wms->replacement = (PossiblyFreedShadaEntry) {\n      .can_free_entry = false,\n      .data = {\n        .type = kSDItemSubString,\n        .timestamp = sub.timestamp,\n        .data = {\n          .sub_string = {\n            .sub = (char *) sub.sub,\n            .additional_elements = sub.additional_elements,\n          }\n        }\n      }\n    };\n  }\n\n  // Initialize global marks\n  if (dump_global_marks) {\n    const void *global_mark_iter = NULL;\n    size_t digit_mark_idx = 0;\n    do {\n      char name = NUL;\n      xfmark_T fm;\n      global_mark_iter = mark_global_iter(global_mark_iter, &name, &fm);\n      if (name == NUL) {\n        break;\n      }\n      const char *fname;\n      if (fm.fmark.fnum == 0) {\n        assert(fm.fname != NULL);\n        if (shada_removable((const char *) fm.fname)) {\n          continue;\n        }\n        fname = (const char *) fm.fname;\n      } else {\n        const buf_T *const buf = buflist_findnr(fm.fmark.fnum);\n        if (buf == NULL || buf->b_ffname == NULL\n            || in_bufset(&removable_bufs, buf)) {\n          continue;\n        }\n        fname = (const char *) buf->b_ffname;\n      }\n      const PossiblyFreedShadaEntry pf_entry = {\n        .can_free_entry = false,\n        .data = {\n          .type = kSDItemGlobalMark,\n          .timestamp = fm.fmark.timestamp,\n          .data = {\n            .filemark = {\n              .mark = fm.fmark.mark,\n              .name = name,\n              .additional_data = fm.fmark.additional_data,\n              .fname = (char *)fname,\n            }\n          }\n        },\n      };\n      if (ascii_isdigit(name)) {\n        replace_numbered_mark(wms, digit_mark_idx++, pf_entry);\n      } else {\n        wms->global_marks[mark_global_index(name)] = pf_entry;\n      }\n    } while (global_mark_iter != NULL);\n  }\n\n  // Initialize registers\n  if (dump_registers) {\n    shada_initialize_registers(wms, max_reg_lines);\n  }\n\n  // Initialize buffers\n  if (num_marked_files > 0) {\n    FOR_ALL_BUFFERS(buf) {\n      if (buf->b_ffname == NULL || in_bufset(&removable_bufs, buf)) {\n        continue;\n      }\n      const void *local_marks_iter = NULL;\n      const char *const fname = (const char *) buf->b_ffname;\n      khiter_t k;\n      int kh_ret;\n      k = kh_put(file_marks, &wms->file_marks, fname, &kh_ret);\n      FileMarks *const filemarks = &kh_val(&wms->file_marks, k);\n      if (kh_ret > 0) {\n        memset(filemarks, 0, sizeof(*filemarks));\n      }\n      do {\n        fmark_T fm;\n        char name = NUL;\n        local_marks_iter = mark_buffer_iter(local_marks_iter, buf, &name, &fm);\n        if (name == NUL) {\n          break;\n        }\n        filemarks->marks[mark_local_index(name)] = (PossiblyFreedShadaEntry) {\n          .can_free_entry = false,\n          .data = {\n            .type = kSDItemLocalMark,\n            .timestamp = fm.timestamp,\n            .data = {\n              .filemark = {\n                .mark = fm.mark,\n                .name = name,\n                .fname = (char *) fname,\n                .additional_data = fm.additional_data,\n              }\n            }\n          }\n        };\n        if (fm.timestamp > filemarks->greatest_timestamp) {\n          filemarks->greatest_timestamp = fm.timestamp;\n        }\n      } while (local_marks_iter != NULL);\n      for (int i = 0; i < buf->b_changelistlen; i++) {\n        const fmark_T fm = buf->b_changelist[i];\n        filemarks->changes[i] = (PossiblyFreedShadaEntry) {\n          .can_free_entry = false,\n          .data = {\n            .type = kSDItemChange,\n            .timestamp = fm.timestamp,\n            .data = {\n              .filemark = {\n                .mark = fm.mark,\n                .fname = (char *) fname,\n                .additional_data = fm.additional_data,\n              }\n            }\n          }\n        };\n        if (fm.timestamp > filemarks->greatest_timestamp) {\n          filemarks->greatest_timestamp = fm.timestamp;\n        }\n      }\n      filemarks->changes_size = (size_t) buf->b_changelistlen;\n    }\n  }\n\n  if (sd_reader != NULL) {\n    const ShaDaWriteResult srww_ret = shada_read_when_writing(\n        sd_reader, srni_flags, max_kbyte, wms, packer);\n    if (srww_ret != kSDWriteSuccessfull) {\n      ret = srww_ret;\n    }\n  }\n\n  // Update numbered marks: '0' should be replaced with the current position,\n  // '9' should be removed and all other marks shifted.\n  if (!ignore_buf(curbuf, &removable_bufs) && curwin->w_cursor.lnum != 0) {\n    replace_numbered_mark(wms, 0, (PossiblyFreedShadaEntry) {\n      .can_free_entry = false,\n      .data = {\n        .type = kSDItemGlobalMark,\n        .timestamp = os_time(),\n        .data = {\n          .filemark = {\n            .mark = curwin->w_cursor,\n            .name = '0',\n            .additional_data = NULL,\n            .fname = (char *)curbuf->b_ffname,\n          }\n        }\n      },\n    });\n  }\n\n  // Write the rest\n#define PACK_WMS_ARRAY(wms_array) \\\n  do { \\\n    for (size_t i_ = 0; i_ < ARRAY_SIZE(wms_array); i_++) { \\\n      if (wms_array[i_].data.type != kSDItemMissing) { \\\n        if (shada_pack_pfreed_entry(packer, wms_array[i_], max_kbyte) \\\n            == kSDWriteFailed) { \\\n          ret = kSDWriteFailed; \\\n          goto shada_write_exit; \\\n        } \\\n      } \\\n    } \\\n  } while (0)\n  PACK_WMS_ARRAY(wms->global_marks);\n  PACK_WMS_ARRAY(wms->numbered_marks);\n  PACK_WMS_ARRAY(wms->registers);\n  for (size_t i = 0; i < wms->jumps_size; i++) {\n    if (shada_pack_pfreed_entry(packer, wms->jumps[i], max_kbyte)\n        == kSDWriteFailed) {\n      ret = kSDWriteFailed;\n      goto shada_write_exit;\n    }\n  }\n#define PACK_WMS_ENTRY(wms_entry) \\\n  do { \\\n    if (wms_entry.data.type != kSDItemMissing) { \\\n      if (shada_pack_pfreed_entry(packer, wms_entry, max_kbyte) \\\n          == kSDWriteFailed) { \\\n        ret = kSDWriteFailed; \\\n        goto shada_write_exit; \\\n      } \\\n    } \\\n  } while (0)\n  PACK_WMS_ENTRY(wms->search_pattern);\n  PACK_WMS_ENTRY(wms->sub_search_pattern);\n  PACK_WMS_ENTRY(wms->replacement);\n#undef PACK_WMS_ENTRY\n\n  const size_t file_markss_size = kh_size(&wms->file_marks);\n  FileMarks **const all_file_markss =\n      xmalloc(file_markss_size * sizeof(*all_file_markss));\n  FileMarks **cur_file_marks = all_file_markss;\n  for (khint_t i = kh_begin(&wms->file_marks); i != kh_end(&wms->file_marks);\n       i++) {\n    if (kh_exist(&wms->file_marks, i)) {\n      *cur_file_marks++ = &kh_val(&wms->file_marks, i);\n    }\n  }\n  qsort((void *) all_file_markss, file_markss_size, sizeof(*all_file_markss),\n        &compare_file_marks);\n  const size_t file_markss_to_dump = MIN(num_marked_files, file_markss_size);\n  for (size_t i = 0; i < file_markss_to_dump; i++) {\n    PACK_WMS_ARRAY(all_file_markss[i]->marks);\n    for (size_t j = 0; j < all_file_markss[i]->changes_size; j++) {\n      if (shada_pack_pfreed_entry(packer, all_file_markss[i]->changes[j],\n                                  max_kbyte) == kSDWriteFailed) {\n        ret = kSDWriteFailed;\n        goto shada_write_exit;\n      }\n    }\n    for (size_t j = 0; j < all_file_markss[i]->additional_marks_size; j++) {\n      if (shada_pack_entry(packer, all_file_markss[i]->additional_marks[j],\n                           0) == kSDWriteFailed) {\n        shada_free_shada_entry(&all_file_markss[i]->additional_marks[j]);\n        ret = kSDWriteFailed;\n        goto shada_write_exit;\n      }\n      shada_free_shada_entry(&all_file_markss[i]->additional_marks[j]);\n    }\n    xfree(all_file_markss[i]->additional_marks);\n  }\n  xfree(all_file_markss);\n#undef PACK_WMS_ARRAY\n\n  if (dump_history) {\n    for (size_t i = 0; i < HIST_COUNT; i++) {\n      if (dump_one_history[i]) {\n        hms_insert_whole_neovim_history(&wms->hms[i]);\n        HMS_ITER(&wms->hms[i], cur_entry, {\n          if (shada_pack_pfreed_entry(\n              packer, (PossiblyFreedShadaEntry) {\n                .data = cur_entry->data,\n                .can_free_entry = cur_entry->can_free_entry,\n              }, max_kbyte) == kSDWriteFailed) {\n            ret = kSDWriteFailed;\n            break;\n          }\n        })\n        if (ret == kSDWriteFailed) {\n          goto shada_write_exit;\n        }\n      }\n    }\n  }\n\nshada_write_exit:\n  for (size_t i = 0; i < HIST_COUNT; i++) {\n    if (dump_one_history[i]) {\n      hms_dealloc(&wms->hms[i]);\n    }\n  }\n  kh_dealloc(file_marks, &wms->file_marks);\n  kh_dealloc(bufset, &removable_bufs);\n  msgpack_packer_free(packer);\n  kh_dealloc(strset, &wms->dumped_variables);\n  xfree(wms);\n  return ret;\n}\n\n#undef IGNORE_BUF\n#undef PACK_STATIC_STR\n\n/// Write ShaDa file to a given location\n///\n/// @param[in]  fname    File to write to. If it is NULL or empty then default\n///                      location is used.\n/// @param[in]  nomerge  If true then old file is ignored.\n///\n/// @return OK if writing was successful, FAIL otherwise.\nint shada_write_file(const char *const file, bool nomerge)\n{\n  if (shada_disabled()) {\n    return FAIL;\n  }\n\n  char *const fname = shada_filename(file);\n  char *tempname = NULL;\n  ShaDaWriteDef sd_writer = {\n    .write = &write_file,\n    .close = &close_sd_writer,\n    .error = NULL,\n  };\n  ShaDaReadDef sd_reader = { .close = NULL };\n\n  if (!nomerge) {\n    int error;\n    if ((error = open_shada_file_for_reading(fname, &sd_reader)) != 0) {\n      if (error != UV_ENOENT) {\n        emsgf(_(SERR \"System error while opening ShaDa file %s for reading \"\n                \"to merge before writing it: %s\"),\n              fname, os_strerror(error));\n        // Try writing the file even if opening it emerged any issues besides\n        // file not existing: maybe writing will succeed nevertheless.\n      }\n      nomerge = true;\n      goto shada_write_file_nomerge;\n    }\n    tempname = modname(fname, \".tmp.a\", false);\n    if (tempname == NULL) {\n      nomerge = true;\n      goto shada_write_file_nomerge;\n    }\n\n    // Save permissions from the original file, with modifications:\n    int perm = (int) os_getperm(fname);\n    perm = (perm >= 0) ? ((perm & 0777) | 0600) : 0600;\n    //                 ^3         ^1       ^2      ^2,3\n    // 1: Strip SUID bit if any.\n    // 2: Make sure that user can always read and write the result.\n    // 3: If somebody happened to delete the file after it was opened for\n    //    reading use u=rw permissions.\nshada_write_file_open: {}\n    sd_writer.cookie = file_open_new(\n        &error, tempname, kFileCreateOnly|kFileNoSymlink, perm);\n    if (sd_writer.cookie == NULL) {\n      if (error == UV_EEXIST || error == UV_ELOOP) {\n        // File already exists, try another name\n        char *const wp = tempname + strlen(tempname) - 1;\n        if (*wp == 'z') {\n          // Tried names from .tmp.a to .tmp.z, all failed. Something must be\n          // wrong then.\n          EMSG2(_(\"E138: All %s.tmp.X files exist, cannot write ShaDa file!\"),\n                fname);\n          xfree(fname);\n          xfree(tempname);\n          assert(sd_reader.close != NULL);\n          sd_reader.close(&sd_reader);\n          return FAIL;\n        } else {\n          (*wp)++;\n          goto shada_write_file_open;\n        }\n      } else {\n        emsgf(_(SERR \"System error while opening temporary ShaDa file %s \"\n                \"for writing: %s\"), tempname, os_strerror(error));\n      }\n    }\n  }\n  if (nomerge) {\nshada_write_file_nomerge: {}\n    char *const tail = path_tail_with_sep(fname);\n    if (tail != fname) {\n      const char tail_save = *tail;\n      *tail = NUL;\n      if (!os_isdir(fname)) {\n        int ret;\n        char *failed_dir;\n        if ((ret = os_mkdir_recurse(fname, 0700, &failed_dir)) != 0) {\n          EMSG3(_(SERR \"Failed to create directory %s \"\n                  \"for writing ShaDa file: %s\"),\n                failed_dir, os_strerror(ret));\n          xfree(fname);\n          xfree(failed_dir);\n          return FAIL;\n        }\n      }\n      *tail = tail_save;\n    }\n    int error;\n    sd_writer.cookie = file_open_new(&error, fname, kFileCreate|kFileTruncate,\n                                     0600);\n    if (sd_writer.cookie == NULL) {\n      emsgf(_(SERR \"System error while opening ShaDa file %s for writing: %s\"),\n            fname, os_strerror(error));\n    }\n  }\n\n  if (sd_writer.cookie == NULL) {\n    xfree(fname);\n    xfree(tempname);\n    if (sd_reader.cookie != NULL) {\n      sd_reader.close(&sd_reader);\n    }\n    return FAIL;\n  }\n\n  if (p_verbose > 0) {\n    verbose_enter();\n    smsg(_(\"Writing ShaDa file \\\"%s\\\"\"), fname);\n    verbose_leave();\n  }\n\n  const ShaDaWriteResult sw_ret = shada_write(&sd_writer, (nomerge\n                                                           ? NULL\n                                                           : &sd_reader));\n  assert(sw_ret != kSDWriteIgnError);\n  if (!nomerge) {\n    sd_reader.close(&sd_reader);\n    bool did_remove = false;\n    if (sw_ret == kSDWriteSuccessfull) {\n#ifdef UNIX\n      // For Unix we check the owner of the file.  It's not very nice to\n      // overwrite a user\u2019s viminfo file after a \"su root\", with a\n      // viminfo file that the user can't read.\n      FileInfo old_info;\n      if (os_fileinfo((char *)fname, &old_info)) {\n        if (getuid() == ROOT_UID) {\n          if (old_info.stat.st_uid != ROOT_UID\n              || old_info.stat.st_gid != getgid()) {\n            const uv_uid_t old_uid = (uv_uid_t)old_info.stat.st_uid;\n            const uv_gid_t old_gid = (uv_gid_t)old_info.stat.st_gid;\n            const int fchown_ret = os_fchown(file_fd(sd_writer.cookie),\n                                             old_uid, old_gid);\n            if (fchown_ret != 0) {\n              EMSG3(_(RNERR \"Failed setting uid and gid for file %s: %s\"),\n                    tempname, os_strerror(fchown_ret));\n              goto shada_write_file_did_not_remove;\n            }\n          }\n        } else if (!(old_info.stat.st_uid == getuid()\n                     ? (old_info.stat.st_mode & 0200)\n                     : (old_info.stat.st_gid == getgid()\n                        ? (old_info.stat.st_mode & 0020)\n                        : (old_info.stat.st_mode & 0002)))) {\n          EMSG2(_(\"E137: ShaDa file is not writable: %s\"), fname);\n          goto shada_write_file_did_not_remove;\n        }\n      }\n#endif\n      if (vim_rename(tempname, fname) == -1) {\n        EMSG3(_(RNERR \"Can't rename ShaDa file from %s to %s!\"),\n              tempname, fname);\n      } else {\n        did_remove = true;\n        os_remove(tempname);\n      }\n    } else {\n      if (sw_ret == kSDWriteReadNotShada) {\n        EMSG3(_(RNERR \"Did not rename %s because %s \"\n                \"does not look like a ShaDa file\"), tempname, fname);\n      } else {\n        EMSG3(_(RNERR \"Did not rename %s to %s because there were errors \"\n                \"during writing it\"), tempname, fname);\n      }\n    }\n    if (!did_remove) {\n#ifdef UNIX\nshada_write_file_did_not_remove:\n#endif\n      EMSG3(_(RNERR \"Do not forget to remove %s or rename it manually to %s.\"),\n            tempname, fname);\n    }\n    xfree(tempname);\n  }\n  sd_writer.close(&sd_writer);\n\n  xfree(fname);\n  return OK;\n}\n\n/// Read marks information from ShaDa file\n///\n/// @return OK in case of success, FAIL otherwise.\nint shada_read_marks(void)\n{\n  return shada_read_file(NULL, kShaDaWantMarks);\n}\n\n/// Read all information from ShaDa file\n///\n/// @param[in]  fname    File to write to. If it is NULL or empty then default\n/// @param[in]  forceit  If true, use forced reading (prioritize file contents\n///                      over current Neovim state).\n/// @param[in]  missing_ok  If true, do not error out when file is missing.\n///\n/// @return OK in case of success, FAIL otherwise.\nint shada_read_everything(const char *const fname, const bool forceit,\n                          const bool missing_ok)\n{\n  return shada_read_file(fname,\n                         kShaDaWantInfo|kShaDaWantMarks|kShaDaGetOldfiles\n                         |(forceit?kShaDaForceit:0)\n                         |(missing_ok?0:kShaDaMissingError));\n}\n\nstatic void shada_free_shada_entry(ShadaEntry *const entry)\n{\n  if (entry == NULL) {\n    return;\n  }\n  switch (entry->type) {\n    case kSDItemMissing: {\n      break;\n    }\n    case kSDItemUnknown: {\n      xfree(entry->data.unknown_item.contents);\n      break;\n    }\n    case kSDItemHeader: {\n      api_free_dictionary(entry->data.header);\n      break;\n    }\n    case kSDItemChange:\n    case kSDItemJump:\n    case kSDItemGlobalMark:\n    case kSDItemLocalMark: {\n      tv_dict_unref(entry->data.filemark.additional_data);\n      xfree(entry->data.filemark.fname);\n      break;\n    }\n    case kSDItemSearchPattern: {\n      tv_dict_unref(entry->data.search_pattern.additional_data);\n      xfree(entry->data.search_pattern.pat);\n      break;\n    }\n    case kSDItemRegister: {\n      tv_dict_unref(entry->data.reg.additional_data);\n      for (size_t i = 0; i < entry->data.reg.contents_size; i++) {\n        xfree(entry->data.reg.contents[i]);\n      }\n      xfree(entry->data.reg.contents);\n      break;\n    }\n    case kSDItemHistoryEntry: {\n      tv_list_unref(entry->data.history_item.additional_elements);\n      xfree(entry->data.history_item.string);\n      break;\n    }\n    case kSDItemVariable: {\n      tv_list_unref(entry->data.global_var.additional_elements);\n      xfree(entry->data.global_var.name);\n      tv_clear(&entry->data.global_var.value);\n      break;\n    }\n    case kSDItemSubString: {\n      tv_list_unref(entry->data.sub_string.additional_elements);\n      xfree(entry->data.sub_string.sub);\n      break;\n    }\n    case kSDItemBufferList: {\n      for (size_t i = 0; i < entry->data.buffer_list.size; i++) {\n        xfree(entry->data.buffer_list.buffers[i].fname);\n        tv_dict_unref(entry->data.buffer_list.buffers[i].additional_data);\n      }\n      xfree(entry->data.buffer_list.buffers);\n      break;\n    }\n  }\n}\n\n#ifndef HAVE_BE64TOH\nstatic inline uint64_t be64toh(uint64_t big_endian_64_bits)\n{\n#ifdef ORDER_BIG_ENDIAN\n  return big_endian_64_bits;\n#else\n  // It may appear that when !defined(ORDER_BIG_ENDIAN) actual order is big\n  // endian. This variant is suboptimal, but it works regardless of actual\n  // order.\n  uint8_t *buf = (uint8_t *) &big_endian_64_bits;\n  uint64_t ret = 0;\n  for (size_t i = 8; i; i--) {\n    ret |= ((uint64_t) buf[i - 1]) << ((8 - i) * 8);\n  }\n  return ret;\n#endif\n}\n#endif\n\n/// Read given number of bytes into given buffer, display error if needed\n///\n/// @param[in]   sd_reader  Structure containing file reader definition.\n/// @param[out]  buffer     Where to save the results.\n/// @param[in]   length     How many bytes should be read.\n///\n/// @return kSDReadStatusSuccess if everything was OK, kSDReadStatusNotShaDa if\n///         there were not enough bytes to read or kSDReadStatusReadError if\n///         there was some error while reading.\nstatic ShaDaReadResult fread_len(ShaDaReadDef *const sd_reader,\n                                 char *const buffer,\n                                 const size_t length)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const ptrdiff_t read_bytes = sd_reader->read(sd_reader, buffer, length);\n\n  if (read_bytes != (ptrdiff_t)length) {\n    if (sd_reader->error != NULL) {\n      emsgf(_(SERR \"System error while reading ShaDa file: %s\"),\n            sd_reader->error);\n      return kSDReadStatusReadError;\n    } else {\n      emsgf(_(RCERR \"Error while reading ShaDa file: \"\n              \"last entry specified that it occupies %\" PRIu64 \" bytes, \"\n              \"but file ended earlier\"),\n            (uint64_t)length);\n      return kSDReadStatusNotShaDa;\n    }\n  }\n  return kSDReadStatusSuccess;\n}\n\n/// Read next unsigned integer from file\n///\n/// Errors out if the result is not an unsigned integer.\n///\n/// Unlike msgpack own function this one works with `FILE *` and reads *exactly*\n/// as much bytes as needed, making it possible to avoid both maintaining own\n/// buffer and calling `fseek`.\n///\n/// One byte from file stream is always consumed, even if it is not correct.\n///\n/// @param[in]   sd_reader  Structure containing file reader definition.\n/// @param[out]  result     Location where result is saved.\n///\n/// @return kSDReadStatusSuccess if reading was successful,\n///         kSDReadStatusNotShaDa if there were not enough bytes to read or\n///         kSDReadStatusReadError if reading failed for whatever reason.\nstatic ShaDaReadResult msgpack_read_uint64(ShaDaReadDef *const sd_reader,\n                                           const int first_char,\n                                           uint64_t *const result)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const uintmax_t fpos = sd_reader->fpos - 1;\n\n  if (first_char == EOF) {\n    if (sd_reader->error) {\n      emsgf(_(SERR \"System error while reading integer from ShaDa file: %s\"),\n            sd_reader->error);\n      return kSDReadStatusReadError;\n    } else if (sd_reader->eof) {\n      emsgf(_(RCERR \"Error while reading ShaDa file: \"\n              \"expected positive integer at position %\" PRIu64\n              \", but got nothing\"),\n            (uint64_t) fpos);\n      return kSDReadStatusNotShaDa;\n    }\n  }\n\n  if (~first_char & 0x80) {\n    // Positive fixnum\n    *result = (uint64_t) ((uint8_t) first_char);\n  } else {\n    size_t length = 0;\n    switch (first_char) {\n      case 0xCC: {  // uint8\n        length = 1;\n        break;\n      }\n      case 0xCD: {  // uint16\n        length = 2;\n        break;\n      }\n      case 0xCE: {  // uint32\n        length = 4;\n        break;\n      }\n      case 0xCF: {  // uint64\n        length = 8;\n        break;\n      }\n      default: {\n        emsgf(_(RCERR \"Error while reading ShaDa file: \"\n                \"expected positive integer at position %\" PRIu64),\n              (uint64_t) fpos);\n        return kSDReadStatusNotShaDa;\n      }\n    }\n    uint64_t buf = 0;\n    char *buf_u8 = (char *) &buf;\n    ShaDaReadResult fl_ret;\n    if ((fl_ret = fread_len(sd_reader, &(buf_u8[sizeof(buf)-length]), length))\n        != kSDReadStatusSuccess) {\n      return fl_ret;\n    }\n    *result = be64toh(buf);\n  }\n  return kSDReadStatusSuccess;\n}\n\n#define READERR(entry_name, error_desc) \\\n    RERR \"Error while reading ShaDa file: \" \\\n    entry_name \" entry at position %\" PRIu64 \" \" \\\n    error_desc\n#define CHECK_KEY(key, expected) ( \\\n    key.via.str.size == sizeof(expected) - 1 \\\n    && STRNCMP(key.via.str.ptr, expected, sizeof(expected) - 1) == 0)\n#define CLEAR_GA_AND_ERROR_OUT(ga) \\\n    do { \\\n      ga_clear(&ga); \\\n      goto shada_read_next_item_error; \\\n    } while (0)\n#define ID(s) s\n#define BINDUP(b) xmemdupz(b.ptr, b.size)\n#define TOINT(s) ((int) (s))\n#define TOLONG(s) ((long) (s))\n#define TOCHAR(s) ((char) (s))\n#define TOU8(s) ((uint8_t) (s))\n#define TOSIZE(s) ((size_t) (s))\n#define CHECKED_ENTRY(condition, error_desc, entry_name, obj, tgt, attr, \\\n                      proc) \\\n  do { \\\n    if (!(condition)) { \\\n      emsgf(_(READERR(entry_name, error_desc)), initial_fpos); \\\n      CLEAR_GA_AND_ERROR_OUT(ad_ga); \\\n    } \\\n    tgt = proc(obj.via.attr); \\\n  } while (0)\n#define CHECK_KEY_IS_STR(un, entry_name) \\\n  if (un.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) { \\\n    emsgf(_(READERR(entry_name, \"has key which is not a string\")), \\\n          initial_fpos); \\\n    CLEAR_GA_AND_ERROR_OUT(ad_ga); \\\n  } else if (un.data.via.map.ptr[i].key.via.str.size == 0) { \\\n    emsgf(_(READERR(entry_name, \"has empty key\")), initial_fpos); \\\n    CLEAR_GA_AND_ERROR_OUT(ad_ga); \\\n  }\n#define CHECKED_KEY(un, entry_name, name, error_desc, tgt, condition, attr, \\\n                    proc) \\\n  else if (CHECK_KEY( /* NOLINT(readability/braces) */ \\\n      un.data.via.map.ptr[i].key, name)) { \\\n    CHECKED_ENTRY( \\\n        condition, \"has \" name \" key value \" error_desc, \\\n        entry_name, un.data.via.map.ptr[i].val, \\\n        tgt, attr, proc); \\\n  }\n#define TYPED_KEY(un, entry_name, name, type_name, tgt, objtype, attr, proc) \\\n  CHECKED_KEY( \\\n      un, entry_name, name, \"which is not \" type_name, tgt, \\\n      un.data.via.map.ptr[i].val.type == MSGPACK_OBJECT_##objtype, \\\n      attr, proc)\n#define BOOLEAN_KEY(un, entry_name, name, tgt) \\\n  TYPED_KEY(un, entry_name, name, \"a boolean\", tgt, BOOLEAN, boolean, ID)\n#define STRING_KEY(un, entry_name, name, tgt) \\\n  TYPED_KEY(un, entry_name, name, \"a binary\", tgt, BIN, bin, BINDUP)\n#define CONVERTED_STRING_KEY(un, entry_name, name, tgt) \\\n  TYPED_KEY(un, entry_name, name, \"a binary\", tgt, BIN, bin, \\\n            BIN_CONVERTED)\n#define INT_KEY(un, entry_name, name, tgt, proc) \\\n  CHECKED_KEY( \\\n      un, entry_name, name, \"which is not an integer\", tgt, \\\n      ((un.data.via.map.ptr[i].val.type \\\n        == MSGPACK_OBJECT_POSITIVE_INTEGER) \\\n       || (un.data.via.map.ptr[i].val.type \\\n           == MSGPACK_OBJECT_NEGATIVE_INTEGER)), \\\n      i64, proc)\n#define INTEGER_KEY(un, entry_name, name, tgt) \\\n  INT_KEY(un, entry_name, name, tgt, TOINT)\n#define LONG_KEY(un, entry_name, name, tgt) \\\n  INT_KEY(un, entry_name, name, tgt, TOLONG)\n#define ADDITIONAL_KEY(un) \\\n  else { /* NOLINT(readability/braces) */ \\\n    ga_grow(&ad_ga, 1); \\\n    memcpy(((char *)ad_ga.ga_data) + ((size_t)ad_ga.ga_len \\\n                                      * sizeof(*un.data.via.map.ptr)), \\\n           un.data.via.map.ptr + i, \\\n           sizeof(*un.data.via.map.ptr)); \\\n    ad_ga.ga_len++; \\\n  }\n#define CONVERTED(str, len) (xmemdupz((str), (len)))\n#define BIN_CONVERTED(b) CONVERTED(b.ptr, b.size)\n#define SET_ADDITIONAL_DATA(tgt, name) \\\n      do { \\\n        if (ad_ga.ga_len) { \\\n          msgpack_object obj = { \\\n            .type = MSGPACK_OBJECT_MAP, \\\n            .via = { \\\n              .map = { \\\n                .size = (uint32_t) ad_ga.ga_len, \\\n                .ptr = ad_ga.ga_data, \\\n              } \\\n            } \\\n          }; \\\n          typval_T adtv; \\\n          if (msgpack_to_vim(obj, &adtv) == FAIL \\\n              || adtv.v_type != VAR_DICT) { \\\n            emsgf(_(READERR(name, \\\n                            \"cannot be converted to a VimL dictionary\")), \\\n                  initial_fpos); \\\n            ga_clear(&ad_ga); \\\n            tv_clear(&adtv); \\\n            goto shada_read_next_item_error; \\\n          } \\\n          tgt = adtv.vval.v_dict; \\\n        } \\\n        ga_clear(&ad_ga); \\\n      } while (0)\n#define SET_ADDITIONAL_ELEMENTS(src, src_maxsize, tgt, name) \\\n      do { \\\n        if ((src).size > (size_t) (src_maxsize)) { \\\n          msgpack_object obj = { \\\n            .type = MSGPACK_OBJECT_ARRAY, \\\n            .via = { \\\n              .array = { \\\n                .size = ((src).size - (uint32_t) (src_maxsize)), \\\n                .ptr = (src).ptr + (src_maxsize), \\\n              } \\\n            } \\\n          }; \\\n          typval_T aetv; \\\n          if (msgpack_to_vim(obj, &aetv) == FAIL) { \\\n            emsgf(_(READERR(name, \"cannot be converted to a VimL list\")), \\\n                  initial_fpos); \\\n            tv_clear(&aetv); \\\n            goto shada_read_next_item_error; \\\n          } \\\n          assert(aetv.v_type == VAR_LIST); \\\n          (tgt) = aetv.vval.v_list; \\\n        } \\\n      } while (0)\n\n/// Iterate over shada file contents\n///\n/// @param[in]   sd_reader  Structure containing file reader definition.\n/// @param[out]  entry      Address where next entry contents will be saved.\n/// @param[in]   flags      Flags, determining whether and which items should be\n///                         skipped (see SRNIFlags enum).\n/// @param[in]   max_kbyte  If non-zero, skip reading entries which have length\n///                         greater then given.\n///\n/// @return Any value from ShaDaReadResult enum.\nstatic ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,\n                                            ShadaEntry *const entry,\n                                            const unsigned flags,\n                                            const size_t max_kbyte)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  ShaDaReadResult ret = kSDReadStatusMalformed;\nshada_read_next_item_start:\n  // Set entry type to kSDItemMissing and also make sure that all pointers in\n  // data union are NULL so they are safe to xfree(). This is needed in case\n  // somebody calls goto shada_read_next_item_error before anything is set in\n  // the switch.\n  memset(entry, 0, sizeof(*entry));\n  if (sd_reader->eof) {\n    return kSDReadStatusFinished;\n  }\n\n  // First: manually unpack type, timestamp and length.\n  // This is needed to avoid both seeking and having to maintain a buffer.\n  uint64_t type_u64 = (uint64_t) kSDItemMissing;\n  uint64_t timestamp_u64;\n  uint64_t length_u64;\n\n  const uint64_t initial_fpos = (uint64_t) sd_reader->fpos;\n  const int first_char = read_char(sd_reader);\n  if (first_char == EOF && sd_reader->eof) {\n    return kSDReadStatusFinished;\n  }\n\n  ShaDaReadResult mru_ret;\n  if (((mru_ret = msgpack_read_uint64(sd_reader, first_char, &type_u64))\n       != kSDReadStatusSuccess)\n      || ((mru_ret = msgpack_read_uint64(sd_reader, read_char(sd_reader),\n                                         &timestamp_u64))\n          != kSDReadStatusSuccess)\n      || ((mru_ret = msgpack_read_uint64(sd_reader, read_char(sd_reader),\n                                         &length_u64))\n          != kSDReadStatusSuccess)) {\n    return mru_ret;\n  }\n\n  if (length_u64 > PTRDIFF_MAX) {\n    emsgf(_(RCERR \"Error while reading ShaDa file: \"\n            \"there is an item at position %\" PRIu64 \" \"\n            \"that is stated to be too long\"),\n          initial_fpos);\n    return kSDReadStatusNotShaDa;\n  }\n\n  const size_t length = (size_t)length_u64;\n  entry->timestamp = (Timestamp)timestamp_u64;\n\n  if (type_u64 == 0) {\n    // kSDItemUnknown cannot possibly pass that far because it is -1 and that\n    // will fail in msgpack_read_uint64. But kSDItemMissing may and it will\n    // otherwise be skipped because (1 << 0) will never appear in flags.\n    emsgf(_(RCERR \"Error while reading ShaDa file: \"\n            \"there is an item at position %\" PRIu64 \" \"\n            \"that must not be there: Missing items are \"\n            \"for internal uses only\"),\n          initial_fpos);\n    return kSDReadStatusNotShaDa;\n  }\n\n  if ((type_u64 > SHADA_LAST_ENTRY\n       ? !(flags & kSDReadUnknown)\n       : !((unsigned) (1 << type_u64) & flags))\n      || (max_kbyte && length > max_kbyte * 1024)) {\n    // First entry is unknown or equal to \"\\n\" (10)? Most likely this means that\n    // current file is not a ShaDa file because first item should normally be\n    // a header (excluding tests where first item is tested item). Check this by\n    // parsing entry contents: in non-ShaDa files this will most likely result\n    // in incomplete MessagePack string.\n    if (initial_fpos == 0\n        && (type_u64 == '\\n' || type_u64 > SHADA_LAST_ENTRY)) {\n      const ShaDaReadResult spm_ret = shada_parse_msgpack(sd_reader, length,\n                                                          NULL, NULL);\n      if (spm_ret != kSDReadStatusSuccess) {\n        return spm_ret;\n      }\n    } else {\n      const ShaDaReadResult srs_ret = sd_reader_skip(sd_reader, length);\n      if (srs_ret != kSDReadStatusSuccess) {\n        return srs_ret;\n      }\n    }\n    goto shada_read_next_item_start;\n  }\n\n  if (type_u64 > SHADA_LAST_ENTRY) {\n    entry->type = kSDItemUnknown;\n    entry->data.unknown_item.size = length;\n    entry->data.unknown_item.type = type_u64;\n    if (initial_fpos == 0) {\n      const ShaDaReadResult spm_ret = shada_parse_msgpack(\n          sd_reader, length, NULL, &entry->data.unknown_item.contents);\n      if (spm_ret != kSDReadStatusSuccess) {\n        entry->type = kSDItemMissing;\n      }\n      return spm_ret;\n    } else {\n      entry->data.unknown_item.contents = xmalloc(length);\n      const ShaDaReadResult fl_ret = fread_len(\n          sd_reader, entry->data.unknown_item.contents, length);\n      if (fl_ret != kSDReadStatusSuccess) {\n        shada_free_shada_entry(entry);\n        entry->type = kSDItemMissing;\n      }\n      return fl_ret;\n    }\n  }\n\n  msgpack_unpacked unpacked;\n  char *buf = NULL;\n\n  const ShaDaReadResult spm_ret = shada_parse_msgpack(sd_reader, length,\n                                                      &unpacked, &buf);\n  if (spm_ret != kSDReadStatusSuccess) {\n    ret = spm_ret;\n    goto shada_read_next_item_error;\n  }\n  ret = kSDReadStatusMalformed;\n  entry->data = sd_default_values[type_u64].data;\n  switch ((ShadaEntryType) type_u64) {\n    case kSDItemHeader: {\n      if (!msgpack_rpc_to_dictionary(&(unpacked.data), &(entry->data.header))) {\n        emsgf(_(READERR(\"header\", \"is not a dictionary\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      break;\n    }\n    case kSDItemSearchPattern: {\n      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {\n        emsgf(_(READERR(\"search pattern\", \"is not a dictionary\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      garray_T ad_ga;\n      ga_init(&ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);\n      for (size_t i = 0; i < unpacked.data.via.map.size; i++) {\n        CHECK_KEY_IS_STR(unpacked, \"search pattern\")\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_MAGIC,\n                    entry->data.search_pattern.magic)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_SMARTCASE,\n                    entry->data.search_pattern.smartcase)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_HAS_LINE_OFFSET,\n                    entry->data.search_pattern.has_line_offset)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_PLACE_CURSOR_AT_END,\n                    entry->data.search_pattern.place_cursor_at_end)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_IS_LAST_USED,\n                    entry->data.search_pattern.is_last_used)\n        BOOLEAN_KEY(unpacked, \"search pattern\",\n                    SEARCH_KEY_IS_SUBSTITUTE_PATTERN,\n                    entry->data.search_pattern.is_substitute_pattern)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_HIGHLIGHTED,\n                    entry->data.search_pattern.highlighted)\n        BOOLEAN_KEY(unpacked, \"search pattern\", SEARCH_KEY_BACKWARD,\n                    entry->data.search_pattern.search_backward)\n        INTEGER_KEY(unpacked, \"search pattern\", SEARCH_KEY_OFFSET,\n                    entry->data.search_pattern.offset)\n        CONVERTED_STRING_KEY(unpacked, \"search pattern\", SEARCH_KEY_PAT,\n                             entry->data.search_pattern.pat)\n        ADDITIONAL_KEY(unpacked)\n      }\n      if (entry->data.search_pattern.pat == NULL) {\n        emsgf(_(READERR(\"search pattern\", \"has no pattern\")), initial_fpos);\n        CLEAR_GA_AND_ERROR_OUT(ad_ga);\n      }\n      SET_ADDITIONAL_DATA(entry->data.search_pattern.additional_data,\n                          \"search pattern\");\n      break;\n    }\n    case kSDItemChange:\n    case kSDItemJump:\n    case kSDItemGlobalMark:\n    case kSDItemLocalMark: {\n      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {\n        emsgf(_(READERR(\"mark\", \"is not a dictionary\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      garray_T ad_ga;\n      ga_init(&ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);\n      for (size_t i = 0; i < unpacked.data.via.map.size; i++) {\n        CHECK_KEY_IS_STR(unpacked, \"mark\")\n        if (CHECK_KEY(unpacked.data.via.map.ptr[i].key, KEY_NAME_CHAR)) {\n          if (type_u64 == kSDItemJump || type_u64 == kSDItemChange) {\n            emsgf(_(READERR(\"mark\", \"has n key which is only valid for \"\n                            \"local and global mark entries\")), initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          CHECKED_ENTRY(\n              (unpacked.data.via.map.ptr[i].val.type\n               == MSGPACK_OBJECT_POSITIVE_INTEGER),\n              \"has n key value which is not an unsigned integer\",\n              \"mark\", unpacked.data.via.map.ptr[i].val,\n              entry->data.filemark.name, u64, TOCHAR);\n        }\n        LONG_KEY(unpacked, \"mark\", KEY_LNUM, entry->data.filemark.mark.lnum)\n        INTEGER_KEY(unpacked, \"mark\", KEY_COL, entry->data.filemark.mark.col)\n        STRING_KEY(unpacked, \"mark\", KEY_FILE, entry->data.filemark.fname)\n        ADDITIONAL_KEY(unpacked)\n      }\n      if (entry->data.filemark.fname == NULL) {\n        emsgf(_(READERR(\"mark\", \"is missing file name\")), initial_fpos);\n        CLEAR_GA_AND_ERROR_OUT(ad_ga);\n      }\n      if (entry->data.filemark.mark.lnum <= 0) {\n        emsgf(_(READERR(\"mark\", \"has invalid line number\")), initial_fpos);\n        CLEAR_GA_AND_ERROR_OUT(ad_ga);\n      }\n      if (entry->data.filemark.mark.col < 0) {\n        emsgf(_(READERR(\"mark\", \"has invalid column number\")), initial_fpos);\n        CLEAR_GA_AND_ERROR_OUT(ad_ga);\n      }\n      SET_ADDITIONAL_DATA(entry->data.filemark.additional_data, \"mark\");\n      break;\n    }\n    case kSDItemRegister: {\n      if (unpacked.data.type != MSGPACK_OBJECT_MAP) {\n        emsgf(_(READERR(\"register\", \"is not a dictionary\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      garray_T ad_ga;\n      ga_init(&ad_ga, sizeof(*(unpacked.data.via.map.ptr)), 1);\n      for (size_t i = 0; i < unpacked.data.via.map.size; i++) {\n        CHECK_KEY_IS_STR(unpacked, \"register\")\n        if (CHECK_KEY(unpacked.data.via.map.ptr[i].key,\n                      REG_KEY_CONTENTS)) {\n          if (unpacked.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            emsgf(_(READERR(\"register\",\n                            \"has \" REG_KEY_CONTENTS\n                            \" key with non-array value\")),\n                  initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          if (unpacked.data.via.map.ptr[i].val.via.array.size == 0) {\n            emsgf(_(READERR(\"register\",\n                            \"has \" REG_KEY_CONTENTS \" key with empty array\")),\n                  initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          const msgpack_object_array arr =\n              unpacked.data.via.map.ptr[i].val.via.array;\n          for (size_t j = 0; j < arr.size; j++) {\n            if (arr.ptr[j].type != MSGPACK_OBJECT_BIN) {\n              emsgf(_(READERR(\"register\", \"has \" REG_KEY_CONTENTS \" array \"\n                              \"with non-binary value\")), initial_fpos);\n              CLEAR_GA_AND_ERROR_OUT(ad_ga);\n            }\n          }\n          entry->data.reg.contents_size = arr.size;\n          entry->data.reg.contents = xmalloc(arr.size * sizeof(char *));\n          for (size_t j = 0; j < arr.size; j++) {\n            entry->data.reg.contents[j] = BIN_CONVERTED(arr.ptr[j].via.bin);\n          }\n        }\n        BOOLEAN_KEY(unpacked, \"register\", REG_KEY_UNNAMED,\n                    entry->data.reg.is_unnamed)\n        TYPED_KEY(unpacked, \"register\", REG_KEY_TYPE, \"an unsigned integer\",\n                  entry->data.reg.type, POSITIVE_INTEGER, u64, TOU8)\n        TYPED_KEY(unpacked, \"register\", KEY_NAME_CHAR, \"an unsigned integer\",\n                  entry->data.reg.name, POSITIVE_INTEGER, u64, TOCHAR)\n        TYPED_KEY(unpacked, \"register\", REG_KEY_WIDTH, \"an unsigned integer\",\n                  entry->data.reg.width, POSITIVE_INTEGER, u64, TOSIZE)\n        ADDITIONAL_KEY(unpacked)\n      }\n      if (entry->data.reg.contents == NULL) {\n        emsgf(_(READERR(\"register\", \"has missing \" REG_KEY_CONTENTS \" array\")),\n              initial_fpos);\n        CLEAR_GA_AND_ERROR_OUT(ad_ga);\n      }\n      SET_ADDITIONAL_DATA(entry->data.reg.additional_data, \"register\");\n      break;\n    }\n    case kSDItemHistoryEntry: {\n      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {\n        emsgf(_(READERR(\"history\", \"is not an array\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.size < 2) {\n        emsgf(_(READERR(\"history\", \"does not have enough elements\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.ptr[0].type\n          != MSGPACK_OBJECT_POSITIVE_INTEGER) {\n        emsgf(_(READERR(\"history\", \"has wrong history type type\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.ptr[1].type\n          != MSGPACK_OBJECT_BIN) {\n        emsgf(_(READERR(\"history\", \"has wrong history string type\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (memchr(unpacked.data.via.array.ptr[1].via.bin.ptr, 0,\n                 unpacked.data.via.array.ptr[1].via.bin.size) != NULL) {\n        emsgf(_(READERR(\"history\", \"contains string with zero byte inside\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      entry->data.history_item.histtype =\n          (uint8_t) unpacked.data.via.array.ptr[0].via.u64;\n      const bool is_hist_search =\n          entry->data.history_item.histtype == HIST_SEARCH;\n      if (is_hist_search) {\n        if (unpacked.data.via.array.size < 3) {\n          emsgf(_(READERR(\"search history\",\n                          \"does not have separator character\")), initial_fpos);\n          goto shada_read_next_item_error;\n        }\n        if (unpacked.data.via.array.ptr[2].type\n            != MSGPACK_OBJECT_POSITIVE_INTEGER) {\n          emsgf(_(READERR(\"search history\",\n                          \"has wrong history separator type\")), initial_fpos);\n          goto shada_read_next_item_error;\n        }\n        entry->data.history_item.sep =\n            (char) unpacked.data.via.array.ptr[2].via.u64;\n      }\n      size_t strsize;\n      strsize = (\n          unpacked.data.via.array.ptr[1].via.bin.size\n          + 1  // Zero byte\n          + 1);  // Separator character\n      entry->data.history_item.string = xmalloc(strsize);\n      memcpy(entry->data.history_item.string,\n             unpacked.data.via.array.ptr[1].via.bin.ptr,\n             unpacked.data.via.array.ptr[1].via.bin.size);\n      entry->data.history_item.string[strsize - 2] = 0;\n      entry->data.history_item.string[strsize - 1] =\n          entry->data.history_item.sep;\n      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, (2 + is_hist_search),\n                              entry->data.history_item.additional_elements,\n                              \"history\");\n      break;\n    }\n    case kSDItemVariable: {\n      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {\n        emsgf(_(READERR(\"variable\", \"is not an array\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.size < 2) {\n        emsgf(_(READERR(\"variable\", \"does not have enough elements\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.ptr[0].type != MSGPACK_OBJECT_BIN) {\n        emsgf(_(READERR(\"variable\", \"has wrong variable name type\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      entry->data.global_var.name =\n          xmemdupz(unpacked.data.via.array.ptr[0].via.bin.ptr,\n                   unpacked.data.via.array.ptr[0].via.bin.size);\n      if (msgpack_to_vim(unpacked.data.via.array.ptr[1],\n                         &(entry->data.global_var.value)) == FAIL) {\n        emsgf(_(READERR(\"variable\", \"has value that cannot \"\n                        \"be converted to the VimL value\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 2,\n                              entry->data.global_var.additional_elements,\n                              \"variable\");\n      break;\n    }\n    case kSDItemSubString: {\n      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {\n        emsgf(_(READERR(\"sub string\", \"is not an array\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.size < 1) {\n        emsgf(_(READERR(\"sub string\", \"does not have enough elements\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.ptr[0].type != MSGPACK_OBJECT_BIN) {\n        emsgf(_(READERR(\"sub string\", \"has wrong sub string type\")),\n              initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      entry->data.sub_string.sub =\n          BIN_CONVERTED(unpacked.data.via.array.ptr[0].via.bin);\n      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 1,\n                              entry->data.sub_string.additional_elements,\n                              \"sub string\");\n      break;\n    }\n    case kSDItemBufferList: {\n      if (unpacked.data.type != MSGPACK_OBJECT_ARRAY) {\n        emsgf(_(READERR(\"buffer list\", \"is not an array\")), initial_fpos);\n        goto shada_read_next_item_error;\n      }\n      if (unpacked.data.via.array.size == 0) {\n        break;\n      }\n      entry->data.buffer_list.buffers =\n          xcalloc(unpacked.data.via.array.size,\n                  sizeof(*entry->data.buffer_list.buffers));\n      for (size_t i = 0; i < unpacked.data.via.array.size; i++) {\n        entry->data.buffer_list.size++;\n        msgpack_unpacked unpacked_2 = (msgpack_unpacked) {\n          .data = unpacked.data.via.array.ptr[i],\n        };\n        {\n          if (unpacked_2.data.type != MSGPACK_OBJECT_MAP) {\n            emsgf(_(RERR \"Error while reading ShaDa file: \"\n                    \"buffer list at position %\" PRIu64 \" \"\n                    \"contains entry that is not a dictionary\"),\n                  initial_fpos);\n            goto shada_read_next_item_error;\n          }\n          entry->data.buffer_list.buffers[i].pos = default_pos;\n          garray_T ad_ga;\n          ga_init(&ad_ga, sizeof(*(unpacked_2.data.via.map.ptr)), 1);\n          {\n            // XXX: Temporarily reassign `i` because the macros depend on it.\n            const size_t j = i;\n            {\n              for (i = 0; i < unpacked_2.data.via.map.size; i++) {  // -V535\n                CHECK_KEY_IS_STR(unpacked_2, \"buffer list entry\")\n                LONG_KEY(unpacked_2, \"buffer list entry\", KEY_LNUM,\n                         entry->data.buffer_list.buffers[j].pos.lnum)\n                INTEGER_KEY(unpacked_2, \"buffer list entry\", KEY_COL,\n                            entry->data.buffer_list.buffers[j].pos.col)\n                STRING_KEY(unpacked_2, \"buffer list entry\", KEY_FILE,\n                           entry->data.buffer_list.buffers[j].fname)\n                ADDITIONAL_KEY(unpacked_2)\n              }\n            }\n            i = j;  // XXX: Restore `i`.\n          }\n          if (entry->data.buffer_list.buffers[i].pos.lnum <= 0) {\n            emsgf(_(RERR \"Error while reading ShaDa file: \"\n                    \"buffer list at position %\" PRIu64 \" \"\n                    \"contains entry with invalid line number\"),\n                  initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          if (entry->data.buffer_list.buffers[i].pos.col < 0) {\n            emsgf(_(RERR \"Error while reading ShaDa file: \"\n                    \"buffer list at position %\" PRIu64 \" \"\n                    \"contains entry with invalid column number\"),\n                  initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          if (entry->data.buffer_list.buffers[i].fname == NULL) {\n            emsgf(_(RERR \"Error while reading ShaDa file: \"\n                    \"buffer list at position %\" PRIu64 \" \"\n                    \"contains entry that does not have a file name\"),\n                  initial_fpos);\n            CLEAR_GA_AND_ERROR_OUT(ad_ga);\n          }\n          SET_ADDITIONAL_DATA(\n              entry->data.buffer_list.buffers[i].additional_data,\n              \"buffer list entry\");\n        }\n      }\n      break;\n    }\n    case kSDItemMissing:\n    case kSDItemUnknown: {\n      abort();\n    }\n  }\n  entry->type = (ShadaEntryType) type_u64;\n  ret = kSDReadStatusSuccess;\nshada_read_next_item_end:\n  if (buf != NULL) {\n    msgpack_unpacked_destroy(&unpacked);\n    xfree(buf);\n  }\n  return ret;\nshada_read_next_item_error:\n  entry->type = (ShadaEntryType) type_u64;\n  shada_free_shada_entry(entry);\n  entry->type = kSDItemMissing;\n  goto shada_read_next_item_end;\n}\n#undef BIN_CONVERTED\n#undef CONVERTED\n#undef CHECK_KEY\n#undef BOOLEAN_KEY\n#undef CONVERTED_STRING_KEY\n#undef STRING_KEY\n#undef ADDITIONAL_KEY\n#undef ID\n#undef BINDUP\n#undef TOCHAR\n#undef TOINT\n#undef TOLONG\n#undef TYPED_KEY\n#undef INT_KEY\n#undef INTEGER_KEY\n#undef LONG_KEY\n#undef TOU8\n#undef TOSIZE\n#undef SET_ADDITIONAL_DATA\n#undef SET_ADDITIONAL_ELEMENTS\n#undef CLEAR_GA_AND_ERROR_OUT\n\n/// Check whether \"name\" is on removable media (according to 'shada')\n///\n/// @param[in]  name  Checked name.\n///\n/// @return True if it is, false otherwise.\nstatic bool shada_removable(const char *name)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  char  *p;\n  char part[MAXPATHL + 1];\n  bool retval = false;\n\n  char *new_name = home_replace_save(NULL, name);\n  for (p = (char *) p_shada; *p; ) {\n    (void) copy_option_part(&p, part, ARRAY_SIZE(part), \", \");\n    if (part[0] == 'r') {\n      home_replace(NULL, part + 1, NameBuff, MAXPATHL, true);\n      size_t n = STRLEN(NameBuff);\n      if (mb_strnicmp(NameBuff, new_name, n) == 0) {\n        retval = true;\n        break;\n      }\n    }\n  }\n  xfree(new_name);\n  return retval;\n}\n\n/// Initialize ShaDa jumplist entries.\n///\n/// @param[in,out]  jumps           Array of ShaDa entries to set.\n/// @param[in]      removable_bufs  Cache of buffers ignored due to their\n///                                 location.\n///\n/// @return number of jumplist entries\nstatic inline size_t shada_init_jumps(\n    PossiblyFreedShadaEntry *jumps, khash_t(bufset) *const removable_bufs)\n{\n  if (!curwin->w_jumplistlen) {\n    return 0;\n  }\n\n  size_t jumps_size = 0;\n  const void *jump_iter = NULL;\n\n  do {\n    xfmark_T fm;\n    jump_iter = mark_jumplist_iter(jump_iter, curwin, &fm);\n\n    if (fm.fmark.mark.lnum == 0) {\n      iemsgf(\"ShaDa: mark lnum zero (ji:%p, js:%p, len:%i)\",\n             (void *)jump_iter, (void *)&curwin->w_jumplist[0],\n             curwin->w_jumplistlen);\n      continue;\n    }\n    const buf_T *const buf = (fm.fmark.fnum == 0\n                              ? NULL\n                              : buflist_findnr(fm.fmark.fnum));\n    if (buf != NULL\n        ? in_bufset(removable_bufs, buf)\n        : fm.fmark.fnum != 0) {\n      continue;\n    }\n    const char *const fname = (char *) (fm.fmark.fnum == 0\n                                        ? (fm.fname == NULL ? NULL : fm.fname)\n                                        : buf ? buf->b_ffname : NULL);\n    if (fname == NULL) {\n      continue;\n    }\n    jumps[jumps_size++] = (PossiblyFreedShadaEntry) {\n      .can_free_entry = false,\n      .data = {\n        .type = kSDItemJump,\n        .timestamp = fm.fmark.timestamp,\n        .data = {\n          .filemark = {\n            .name = NUL,\n            .mark = fm.fmark.mark,\n            .fname = (char *) fname,\n            .additional_data = fm.fmark.additional_data,\n          }\n        }\n      }\n    };\n  } while (jump_iter != NULL);\n  return jumps_size;\n}\n\n/// Write registers ShaDa entries in given msgpack_sbuffer.\n///\n/// @param[in]  sbuf  target msgpack_sbuffer to write to.\nvoid shada_encode_regs(msgpack_sbuffer *const sbuf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  WriteMergerState *const wms = xcalloc(1, sizeof(*wms));\n  shada_initialize_registers(wms, -1);\n  msgpack_packer packer;\n  msgpack_packer_init(&packer, sbuf, msgpack_sbuffer_write);\n  for (size_t i = 0; i < ARRAY_SIZE(wms->registers); i++) {\n    if (wms->registers[i].data.type == kSDItemRegister) {\n      if (kSDWriteFailed\n          == shada_pack_pfreed_entry(&packer, wms->registers[i], 0)) {\n        abort();\n      }\n    }\n  }\n  xfree(wms);\n}\n\n/// Write jumplist ShaDa entries in given msgpack_sbuffer.\n///\n/// @param[in]  sbuf            target msgpack_sbuffer to write to.\nvoid shada_encode_jumps(msgpack_sbuffer *const sbuf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);\n  find_removable_bufs(&removable_bufs);\n  PossiblyFreedShadaEntry jumps[JUMPLISTSIZE];\n  cleanup_jumplist(curwin, true);\n  size_t jumps_size = shada_init_jumps(jumps, &removable_bufs);\n  msgpack_packer packer;\n  msgpack_packer_init(&packer, sbuf, msgpack_sbuffer_write);\n  for (size_t i = 0; i < jumps_size; i++) {\n    if (kSDWriteFailed == shada_pack_pfreed_entry(&packer, jumps[i], 0)) {\n      abort();\n    }\n  }\n}\n\n/// Write buffer list ShaDa entry in given msgpack_sbuffer.\n///\n/// @param[in]  sbuf            target msgpack_sbuffer to write to.\nvoid shada_encode_buflist(msgpack_sbuffer *const sbuf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  khash_t(bufset) removable_bufs = KHASH_EMPTY_TABLE(bufset);\n  find_removable_bufs(&removable_bufs);\n  ShadaEntry buflist_entry = shada_get_buflist(&removable_bufs);\n  msgpack_packer packer;\n  msgpack_packer_init(&packer, sbuf, msgpack_sbuffer_write);\n  if (kSDWriteFailed == shada_pack_entry(&packer, buflist_entry, 0)) {\n    abort();\n  }\n  xfree(buflist_entry.data.buffer_list.buffers);\n}\n\n/// Write global variables ShaDa entries in given msgpack_sbuffer.\n///\n/// @param[in]  sbuf            target msgpack_sbuffer to write to.\nvoid shada_encode_gvars(msgpack_sbuffer *const sbuf)\n  FUNC_ATTR_NONNULL_ALL\n{\n  msgpack_packer packer;\n  msgpack_packer_init(&packer, sbuf, msgpack_sbuffer_write);\n  const void *var_iter = NULL;\n  const Timestamp cur_timestamp = os_time();\n  do {\n    typval_T vartv;\n    const char *name = NULL;\n    var_iter = var_shada_iter(\n        var_iter, &name, &vartv,\n        VAR_FLAVOUR_DEFAULT | VAR_FLAVOUR_SESSION | VAR_FLAVOUR_SHADA);\n    if (name == NULL) {\n      break;\n    }\n    if (vartv.v_type != VAR_FUNC && vartv.v_type != VAR_PARTIAL) {\n      typval_T tgttv;\n      tv_copy(&vartv, &tgttv);\n      ShaDaWriteResult r = shada_pack_entry(&packer, (ShadaEntry) {\n        .type = kSDItemVariable,\n        .timestamp = cur_timestamp,\n        .data = {\n          .global_var = {\n            .name = (char *)name,\n            .value = tgttv,\n            .additional_elements = NULL,\n          }\n        }\n      }, 0);\n      if (kSDWriteFailed == r) {\n        abort();\n      }\n      tv_clear(&tgttv);\n    }\n    tv_clear(&vartv);\n  } while (var_iter != NULL);\n}\n\n/// Wrapper for reading from msgpack_sbuffer.\n///\n/// @return number of bytes read.\nstatic ptrdiff_t read_sbuf(ShaDaReadDef *const sd_reader, void *const dest,\n                           const size_t size)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  msgpack_sbuffer *sbuf = (msgpack_sbuffer *)sd_reader->cookie;\n  const uintmax_t bytes_read = MIN(size, sbuf->size - sd_reader->fpos);\n  if (bytes_read < size) {\n    sd_reader->eof = true;\n  }\n  memcpy(dest, sbuf->data + sd_reader->fpos, (size_t)bytes_read);\n  sd_reader->fpos += bytes_read;\n  return (ptrdiff_t)bytes_read;\n}\n\n/// Wrapper for read that ignores bytes read from msgpack_sbuffer.\n///\n/// Used for skipping.\n///\n/// @param[in,out]  sd_reader  ShaDaReadDef with msgpack_sbuffer.\n/// @param[in]      offset     Amount of bytes to skip.\n///\n/// @return FAIL in case of failure, OK in case of success. May set\n///         sd_reader->eof.\nstatic int sd_sbuf_reader_skip_read(ShaDaReadDef *const sd_reader,\n                                    const size_t offset)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  msgpack_sbuffer *sbuf = (msgpack_sbuffer *)sd_reader->cookie;\n  assert(sbuf->size >= sd_reader->fpos);\n  const uintmax_t skip_bytes = MIN(offset, sbuf->size - sd_reader->fpos);\n  if (skip_bytes < offset) {\n    sd_reader->eof = true;\n    return FAIL;\n  }\n  sd_reader->fpos += offset;\n  return OK;\n}\n\n/// Prepare ShaDaReadDef with msgpack_sbuffer for reading.\n///\n/// @param[in]   sbuf       msgpack_sbuffer to read from.\n/// @param[out]  sd_reader  Location where reader structure will be saved.\nstatic void open_shada_sbuf_for_reading(const msgpack_sbuffer *const sbuf,\n                                        ShaDaReadDef *sd_reader)\n  FUNC_ATTR_NONNULL_ALL\n{\n  *sd_reader = (ShaDaReadDef) {\n    .read = &read_sbuf,\n    .close = NULL,\n    .skip = &sd_sbuf_reader_skip_read,\n    .error = NULL,\n    .eof = false,\n    .fpos = 0,\n    .cookie = (void *)sbuf,\n  };\n}\n\n/// Read ShaDa from msgpack_sbuffer.\n///\n/// @param[in]  file   msgpack_sbuffer to read from.\n/// @param[in]  flags  Flags, see ShaDaReadFileFlags enum.\nvoid shada_read_sbuf(msgpack_sbuffer *const sbuf, const int flags)\n  FUNC_ATTR_NONNULL_ALL\n{\n  assert(sbuf != NULL);\n  if (sbuf->data == NULL) {\n    return;\n  }\n  ShaDaReadDef sd_reader;\n  open_shada_sbuf_for_reading(sbuf, &sd_reader);\n  shada_read(&sd_reader, flags);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 1662}, "message": "Memory copy function overflows the destination buffer"}], "macros": [{"location": {"col": 7, "file": 0, "line": 1660}, "expansion": "do { const String s_ = (varname); msgpack_pack_bin(spacker, s_.size); if (s_.size > 0) { msgpack_pack_bin_body(spacker, s_.data, s_.size); } } while (0)", "name": "PACK_BIN"}], "notes": [], "path": "src/nvim/shada.c", "reportHash": "2d08c32389c13ec8f6e784884b712f17", "checkerName": "alpha.unix.cstring.OutOfBounds", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 9, "file": 0, "line": 4247}, "message": "The value provided to the cast expression is not in the valid range of values for the enum"}], "macros": [], "notes": [], "path": "src/nvim/shada.c", "reportHash": "3105f4b8cdeef0180e27a2060d46c930", "checkerName": "alpha.cplusplus.EnumCastOutOfRange", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
