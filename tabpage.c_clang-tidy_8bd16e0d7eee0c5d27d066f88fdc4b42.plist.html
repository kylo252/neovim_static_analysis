<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "build/include/hashtab.h.generated.h", "content": "#define DEFINE_FUNC_ATTRIBUTES\n#include \"nvim/func_attr.h\"\n#undef DEFINE_FUNC_ATTRIBUTES\nvoid hash_init(hashtab_T *ht);\nvoid hash_clear(hashtab_T *ht);\nvoid hash_clear_all(hashtab_T *ht, unsigned int off);\nhashitem_T *hash_find(const hashtab_T *const ht, const char_u *const key);\nhashitem_T *hash_find_len(const hashtab_T *const ht, const char *const key, const size_t len);\nhashitem_T *hash_lookup(const hashtab_T *const ht, const char *const key, const size_t key_len, const hash_T hash);\nvoid hash_debug_results(void);\nint hash_add(hashtab_T *ht, char_u *key);\nvoid hash_add_item(hashtab_T *ht, hashitem_T *hi, char_u *key, hash_T hash);\nvoid hash_remove(hashtab_T *ht, hashitem_T *hi);\nvoid hash_lock(hashtab_T *ht);\nvoid hash_unlock(hashtab_T *ht);\nhash_T hash_hash(const char_u *key);\nhash_T hash_hash_len(const char *key, const size_t len) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;\nconst char_u *_hash_key_removed(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;\n#include \"nvim/func_attr.h\"\n"}, "1": {"id": 1, "path": "src/nvim/api/private/helpers.h", "content": "#ifndef NVIM_API_PRIVATE_HELPERS_H\n#define NVIM_API_PRIVATE_HELPERS_H\n\n#include <stdbool.h>\n\n#include \"nvim/api/private/defs.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/decoration.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/lib/kvec.h\"\n\n#define OBJECT_OBJ(o) o\n\n#define BOOLEAN_OBJ(b) ((Object) { \\\n    .type = kObjectTypeBoolean, \\\n    .data.boolean = b })\n#define BOOL(b) BOOLEAN_OBJ(b)\n\n#define INTEGER_OBJ(i) ((Object) { \\\n    .type = kObjectTypeInteger, \\\n    .data.integer = i })\n\n#define FLOAT_OBJ(f) ((Object) { \\\n    .type = kObjectTypeFloat, \\\n    .data.floating = f })\n\n#define STRING_OBJ(s) ((Object) { \\\n    .type = kObjectTypeString, \\\n    .data.string = s })\n\n#define CSTR_TO_OBJ(s) STRING_OBJ(cstr_to_string(s))\n\n#define BUFFER_OBJ(s) ((Object) { \\\n    .type = kObjectTypeBuffer, \\\n    .data.integer = s })\n\n#define WINDOW_OBJ(s) ((Object) { \\\n    .type = kObjectTypeWindow, \\\n    .data.integer = s })\n\n#define TABPAGE_OBJ(s) ((Object) { \\\n    .type = kObjectTypeTabpage, \\\n    .data.integer = s })\n\n#define ARRAY_OBJ(a) ((Object) { \\\n    .type = kObjectTypeArray, \\\n    .data.array = a })\n\n#define DICTIONARY_OBJ(d) ((Object) { \\\n    .type = kObjectTypeDictionary, \\\n    .data.dictionary = d })\n\n#define LUAREF_OBJ(r) ((Object) { \\\n    .type = kObjectTypeLuaRef, \\\n    .data.luaref = r })\n\n#define NIL ((Object)OBJECT_INIT)\n#define NULL_STRING ((String)STRING_INIT)\n\n#define PUT(dict, k, v) \\\n  kv_push(dict, ((KeyValuePair) { .key = cstr_to_string(k), .value = v }))\n\n#define PUT_BOOL(dict, name, condition) PUT(dict, name, BOOLEAN_OBJ(condition));\n\n#define ADD(array, item) \\\n  kv_push(array, item)\n\n#define FIXED_TEMP_ARRAY(name, fixsize) \\\n  Array name = ARRAY_DICT_INIT; \\\n  Object name##__items[fixsize]; \\\n  name.size = fixsize; \\\n  name.items = name##__items; \\\n\n#define STATIC_CSTR_AS_STRING(s) ((String) {.data = s, .size = sizeof(s) - 1})\n\n/// Create a new String instance, putting data in allocated memory\n///\n/// @param[in]  s  String to work with. Must be a string literal.\n#define STATIC_CSTR_TO_STRING(s) ((String){ \\\n    .data = xmemdupz(s, sizeof(s) - 1), \\\n    .size = sizeof(s) - 1 })\n\n// Helpers used by the generated msgpack-rpc api wrappers\n#define api_init_boolean\n#define api_init_integer\n#define api_init_float\n#define api_init_string = STRING_INIT\n#define api_init_buffer\n#define api_init_window\n#define api_init_tabpage\n#define api_init_object = NIL\n#define api_init_array = ARRAY_DICT_INIT\n#define api_init_dictionary = ARRAY_DICT_INIT\n\n#define api_free_boolean(value)\n#define api_free_integer(value)\n#define api_free_float(value)\n#define api_free_buffer(value)\n#define api_free_window(value)\n#define api_free_tabpage(value)\n\nEXTERN PMap(handle_T) buffer_handles INIT(= MAP_INIT);\nEXTERN PMap(handle_T) window_handles INIT(= MAP_INIT);\nEXTERN PMap(handle_T) tabpage_handles INIT(= MAP_INIT);\n\n#define handle_get_buffer(h) pmap_get(handle_T)(&buffer_handles, (h))\n#define handle_get_window(h) pmap_get(handle_T)(&window_handles, (h))\n#define handle_get_tabpage(h) pmap_get(handle_T)(&tabpage_handles, (h))\n\n/// Structure used for saving state for :try\n///\n/// Used when caller is supposed to be operating when other VimL code is being\n/// processed and that \u201cother VimL code\u201d must not be affected.\ntypedef struct {\n  except_T *current_exception;\n  struct msglist *private_msg_list;\n  const struct msglist *const *msg_list;\n  int trylevel;\n  int got_int;\n  int need_rethrow;\n  int did_emsg;\n} TryState;\n\n// `msg_list` controls the collection of abort-causing non-exception errors,\n// which would otherwise be ignored.  This pattern is from do_cmdline().\n//\n// TODO(bfredl): prepare error-handling at \"top level\" (nv_event).\n#define TRY_WRAP(code) \\\n  do { \\\n    struct msglist **saved_msg_list = msg_list; \\\n    struct msglist *private_msg_list; \\\n    msg_list = &private_msg_list; \\\n    private_msg_list = NULL; \\\n    code \\\n    msg_list = saved_msg_list;  /* Restore the exception context. */ \\\n  } while (0)\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"api/private/helpers.h.generated.h\"\n#endif\n#endif  // NVIM_API_PRIVATE_HELPERS_H\n"}, "2": {"id": 2, "path": "src/nvim/buffer_defs.h", "content": "#ifndef NVIM_BUFFER_DEFS_H\n#define NVIM_BUFFER_DEFS_H\n\n#include <stdbool.h>\n#include <stdint.h>\n// for FILE\n#include <stdio.h>\n\ntypedef struct file_buffer buf_T; // Forward declaration\n\n// Reference to a buffer that stores the value of buf_free_count.\n// bufref_valid() only needs to check \"buf\" when the count differs.\ntypedef struct {\n  buf_T *br_buf;\n  int    br_fnum;\n  int    br_buf_free_count;\n} bufref_T;\n\n// for garray_T\n#include \"nvim/garray.h\"\n// for ScreenGrid\n#include \"nvim/grid_defs.h\"\n// for HLF_COUNT\n#include \"nvim/highlight_defs.h\"\n// for pos_T, lpos_T and linenr_T\n#include \"nvim/pos.h\"\n// for the number window-local and buffer-local options\n#include \"nvim/option_defs.h\"\n// for jump list and tag stack sizes in a buffer and mark types\n#include \"nvim/mark_defs.h\"\n// for u_header_T; needs buf_T.\n#include \"nvim/undo_defs.h\"\n// for hashtab_T\n#include \"nvim/hashtab.h\"\n// for dict_T\n#include \"nvim/eval/typval.h\"\n// for proftime_T\n#include \"nvim/profile.h\"\n// for String\n#include \"nvim/api/private/defs.h\"\n// for Map(K, V)\n#include \"nvim/map.h\"\n// for kvec\n#include \"nvim/lib/kvec.h\"\n// for marktree\n#include \"nvim/marktree.h\"\n\n#define GETFILE_SUCCESS(x)    ((x) <= 0)\n#define MODIFIABLE(buf) (buf->b_p_ma)\n\n/*\n * Flags for w_valid.\n * These are set when something in a window structure becomes invalid, except\n * when the cursor is moved.  Call check_cursor_moved() before testing one of\n * the flags.\n * These are reset when that thing has been updated and is valid again.\n *\n * Every function that invalidates one of these must call one of the\n * invalidate_* functions.\n *\n * w_valid is supposed to be used only in screen.c.  From other files, use the\n * functions that set or reset the flags.\n *\n * VALID_BOTLINE    VALID_BOTLINE_AP\n *     on       on      w_botline valid\n *     off      on      w_botline approximated\n *     off      off     w_botline not valid\n *     on       off     not possible\n */\n#define VALID_WROW      0x01    // w_wrow (window row) is valid\n#define VALID_WCOL      0x02    // w_wcol (window col) is valid\n#define VALID_VIRTCOL   0x04    // w_virtcol (file col) is valid\n#define VALID_CHEIGHT   0x08    // w_cline_height and w_cline_folded valid\n#define VALID_CROW      0x10    // w_cline_row is valid\n#define VALID_BOTLINE   0x20    // w_botine and w_empty_rows are valid\n#define VALID_BOTLINE_AP 0x40   // w_botine is approximated\n#define VALID_TOPLINE   0x80    // w_topline is valid (for cursor position)\n\n// flags for b_flags\n#define BF_RECOVERED    0x01    // buffer has been recovered\n#define BF_CHECK_RO     0x02    // need to check readonly when loading file\n                                // into buffer (set by \":e\", may be reset by\n                                // \":buf\")\n#define BF_NEVERLOADED  0x04    // file has never been loaded into buffer,\n                                // many variables still need to be set\n#define BF_NOTEDITED    0x08    // Set when file name is changed after\n                                // starting to edit, reset when file is\n                                // written out.\n#define BF_NEW          0x10    // file didn't exist when editing started\n#define BF_NEW_W        0x20    // Warned for BF_NEW and file created\n#define BF_READERR      0x40    // got errors while reading the file\n#define BF_DUMMY        0x80    // dummy buffer, only used internally\n#define BF_PRESERVED    0x100   // \":preserve\" was used\n#define BF_SYN_SET      0x200   // 'syntax' option was set\n\n// Mask to check for flags that prevent normal writing\n#define BF_WRITE_MASK   (BF_NOTEDITED + BF_NEW + BF_READERR)\n\ntypedef struct window_S win_T;\ntypedef struct wininfo_S wininfo_T;\ntypedef struct frame_S frame_T;\ntypedef uint16_t disptick_T;  // display tick type\n\n// for struct memline (it needs memfile_T)\n#include \"nvim/memline_defs.h\"\n// for struct memfile, bhdr_T, blocknr_T... (it needs buf_T)\n#include \"nvim/memfile_defs.h\"\n\n// for regprog_T. Needs win_T and buf_T.\n#include \"nvim/regexp_defs.h\"\n// for synstate_T (needs reg_extmatch_T, win_T, buf_T)\n#include \"nvim/syntax_defs.h\"\n// for sign_entry_T\n#include \"nvim/sign_defs.h\"\n\n#include \"nvim/os/fs_defs.h\"    // for FileID\n#include \"nvim/terminal.h\"      // for Terminal\n\n/*\n * The taggy struct is used to store the information about a :tag command.\n */\ntypedef struct taggy {\n  char_u      *tagname;         // tag name\n  fmark_T fmark;                // cursor position BEFORE \":tag\"\n  int cur_match;                // match number\n  int cur_fnum;                 // buffer number used for cur_match\n  char_u *user_data;            // used with tagfunc\n} taggy_T;\n\ntypedef struct buffblock buffblock_T;\ntypedef struct buffheader buffheader_T;\n\n/*\n * structure used to store one block of the stuff/redo/recording buffers\n */\nstruct buffblock {\n  buffblock_T *b_next;  // pointer to next buffblock\n  char_u b_str[1];      // contents (actually longer)\n};\n\n/*\n * header used for the stuff buffer and the redo buffer\n */\nstruct buffheader {\n  buffblock_T bh_first;  // first (dummy) block of list\n  buffblock_T *bh_curr;  // buffblock for appending\n  size_t bh_index;          // index for reading\n  size_t bh_space;          // space in bh_curr for appending\n};\n\ntypedef struct\n{\n  buffheader_T sr_redobuff;\n  buffheader_T sr_old_redobuff;\n} save_redo_T;\n\n/*\n * Structure that contains all options that are local to a window.\n * Used twice in a window: for the current buffer and for all buffers.\n * Also used in wininfo_T.\n */\ntypedef struct {\n  int wo_arab;\n# define w_p_arab w_onebuf_opt.wo_arab  // 'arabic'\n  int wo_bri;\n# define w_p_bri w_onebuf_opt.wo_bri    // 'breakindent'\n  char_u *wo_briopt;\n# define w_p_briopt w_onebuf_opt.wo_briopt  // 'breakindentopt'\n  int wo_diff;\n# define w_p_diff w_onebuf_opt.wo_diff  // 'diff'\n  char_u *wo_fdc;\n# define w_p_fdc w_onebuf_opt.wo_fdc    // 'foldcolumn'\n  char_u *wo_fdc_save;\n# define w_p_fdc_save w_onebuf_opt.wo_fdc_save  // 'fdc' saved for diff mode\n  int wo_fen;\n# define w_p_fen w_onebuf_opt.wo_fen    // 'foldenable'\n  int wo_fen_save;\n  // 'foldenable' saved for diff mode\n# define w_p_fen_save w_onebuf_opt.wo_fen_save\n  char_u      *wo_fdi;\n# define w_p_fdi w_onebuf_opt.wo_fdi    // 'foldignore'\n  long wo_fdl;\n# define w_p_fdl w_onebuf_opt.wo_fdl    // 'foldlevel'\n  int wo_fdl_save;\n  // 'foldlevel' state saved for diff mode\n# define w_p_fdl_save w_onebuf_opt.wo_fdl_save\n  char_u      *wo_fdm;\n# define w_p_fdm w_onebuf_opt.wo_fdm    // 'foldmethod'\n  char_u      *wo_fdm_save;\n# define w_p_fdm_save w_onebuf_opt.wo_fdm_save  // 'fdm' saved for diff mode\n  long wo_fml;\n# define w_p_fml w_onebuf_opt.wo_fml    // 'foldminlines'\n  long wo_fdn;\n# define w_p_fdn w_onebuf_opt.wo_fdn    // 'foldnestmax'\n  char_u      *wo_fde;\n# define w_p_fde w_onebuf_opt.wo_fde    // 'foldexpr'\n  char_u      *wo_fdt;\n#  define w_p_fdt w_onebuf_opt.wo_fdt   // 'foldtext'\n  char_u      *wo_fmr;\n# define w_p_fmr w_onebuf_opt.wo_fmr    // 'foldmarker'\n  int wo_lbr;\n# define w_p_lbr w_onebuf_opt.wo_lbr    // 'linebreak'\n  int wo_list;\n#define w_p_list w_onebuf_opt.wo_list   // 'list'\n  int wo_nu;\n#define w_p_nu w_onebuf_opt.wo_nu       // 'number'\n  int wo_rnu;\n#define w_p_rnu w_onebuf_opt.wo_rnu     // 'relativenumber'\n  long wo_nuw;\n# define w_p_nuw w_onebuf_opt.wo_nuw    // 'numberwidth'\n  int wo_wfh;\n# define w_p_wfh w_onebuf_opt.wo_wfh    // 'winfixheight'\n  int wo_wfw;\n# define w_p_wfw w_onebuf_opt.wo_wfw    // 'winfixwidth'\n  int wo_pvw;\n# define w_p_pvw w_onebuf_opt.wo_pvw    // 'previewwindow'\n  int wo_rl;\n# define w_p_rl w_onebuf_opt.wo_rl      // 'rightleft'\n  char_u      *wo_rlc;\n# define w_p_rlc w_onebuf_opt.wo_rlc    // 'rightleftcmd'\n  long wo_scr;\n#define w_p_scr w_onebuf_opt.wo_scr     // 'scroll'\n  int wo_spell;\n# define w_p_spell w_onebuf_opt.wo_spell  // 'spell'\n  int wo_cuc;\n# define w_p_cuc w_onebuf_opt.wo_cuc    // 'cursorcolumn'\n  int wo_cul;\n# define w_p_cul w_onebuf_opt.wo_cul    // 'cursorline'\n  char_u      *wo_culopt;\n# define w_p_culopt w_onebuf_opt.wo_culopt  // 'cursorlineopt'\n  char_u      *wo_cc;\n# define w_p_cc w_onebuf_opt.wo_cc      // 'colorcolumn'\n  char_u      *wo_stl;\n#define w_p_stl w_onebuf_opt.wo_stl     // 'statusline'\n  int wo_scb;\n# define w_p_scb w_onebuf_opt.wo_scb    // 'scrollbind'\n  int wo_diff_saved;           // options were saved for starting diff mode\n# define w_p_diff_saved w_onebuf_opt.wo_diff_saved\n  int wo_scb_save;              // 'scrollbind' saved for diff mode\n# define w_p_scb_save w_onebuf_opt.wo_scb_save\n  int wo_wrap;\n#define w_p_wrap w_onebuf_opt.wo_wrap   // 'wrap'\n  int wo_wrap_save;             // 'wrap' state saved for diff mode\n# define w_p_wrap_save w_onebuf_opt.wo_wrap_save\n  char_u      *wo_cocu;                 // 'concealcursor'\n# define w_p_cocu w_onebuf_opt.wo_cocu\n  long wo_cole;                         // 'conceallevel'\n# define w_p_cole w_onebuf_opt.wo_cole\n  int wo_crb;\n# define w_p_crb w_onebuf_opt.wo_crb    // 'cursorbind'\n  int wo_crb_save;              // 'cursorbind' state saved for diff mode\n# define w_p_crb_save w_onebuf_opt.wo_crb_save\n  char_u *wo_scl;\n# define w_p_scl w_onebuf_opt.wo_scl    // 'signcolumn'\n  char_u *wo_winhl;\n# define w_p_winhl w_onebuf_opt.wo_winhl    // 'winhighlight'\n  char_u *wo_fcs;\n# define w_p_fcs w_onebuf_opt.wo_fcs    // 'fillchars'\n  char_u *wo_lcs;\n# define w_p_lcs w_onebuf_opt.wo_lcs    // 'listchars'\n  long wo_winbl;\n# define w_p_winbl w_onebuf_opt.wo_winbl  // 'winblend'\n\n  LastSet wo_script_ctx[WV_COUNT];        // SCTXs for window-local options\n# define w_p_script_ctx w_onebuf_opt.wo_script_ctx\n} winopt_T;\n\n/*\n * Window info stored with a buffer.\n *\n * Two types of info are kept for a buffer which are associated with a\n * specific window:\n * 1. Each window can have a different line number associated with a buffer.\n * 2. The window-local options for a buffer work in a similar way.\n * The window-info is kept in a list at b_wininfo.  It is kept in\n * most-recently-used order.\n */\nstruct wininfo_S {\n  wininfo_T   *wi_next;         // next entry or NULL for last entry\n  wininfo_T   *wi_prev;         // previous entry or NULL for first entry\n  win_T       *wi_win;          // pointer to window that did set wi_fpos\n  pos_T wi_fpos;                // last cursor position in the file\n  bool wi_optset;               // true when wi_opt has useful values\n  winopt_T wi_opt;              // local window options\n  bool wi_fold_manual;          // copy of w_fold_manual\n  garray_T wi_folds;            // clone of w_folds\n};\n\n/*\n * Argument list: Array of file names.\n * Used for the global argument list and the argument lists local to a window.\n *\n * TODO: move struct arglist to another header\n */\ntypedef struct arglist {\n  garray_T al_ga;               // growarray with the array of file names\n  int al_refcount;              // number of windows using this arglist\n  int id;                       ///< id of this arglist\n} alist_T;\n\n// For each argument remember the file name as it was given, and the buffer\n// number that contains the expanded file name (required for when \":cd\" is\n// used).\n//\n// TODO(Felipe): move aentry_T to another header\ntypedef struct argentry {\n  char_u      *ae_fname;        // file name as specified\n  int ae_fnum;                  // buffer number with expanded file name\n} aentry_T;\n\n# define ALIST(win) (win)->w_alist\n#define GARGLIST        ((aentry_T *)global_alist.al_ga.ga_data)\n#define ARGLIST         ((aentry_T *)ALIST(curwin)->al_ga.ga_data)\n#define WARGLIST(wp)    ((aentry_T *)ALIST(wp)->al_ga.ga_data)\n#define AARGLIST(al)    ((aentry_T *)((al)->al_ga.ga_data))\n#define GARGCOUNT       (global_alist.al_ga.ga_len)\n#define ARGCOUNT        (ALIST(curwin)->al_ga.ga_len)\n#define WARGCOUNT(wp)   (ALIST(wp)->al_ga.ga_len)\n\n/*\n * Used for the typeahead buffer: typebuf.\n */\ntypedef struct {\n  char_u      *tb_buf;          // buffer for typed characters\n  char_u      *tb_noremap;      // mapping flags for characters in tb_buf[]\n  int tb_buflen;                // size of tb_buf[]\n  int tb_off;                   // current position in tb_buf[]\n  int tb_len;                   // number of valid bytes in tb_buf[]\n  int tb_maplen;                // nr of mapped bytes in tb_buf[]\n  int tb_silent;                // nr of silently mapped bytes in tb_buf[]\n  int tb_no_abbr_cnt;           // nr of bytes without abbrev. in tb_buf[]\n  int tb_change_cnt;            // nr of time tb_buf was changed; never zero\n} typebuf_T;\n\n// Struct to hold the saved typeahead for save_typeahead().\ntypedef struct {\n  typebuf_T save_typebuf;\n  bool typebuf_valid;                       // true when save_typebuf valid\n  int old_char;\n  int old_mod_mask;\n  buffheader_T save_readbuf1;\n  buffheader_T save_readbuf2;\n  String save_inputbuf;\n} tasave_T;\n\n/*\n * Structure used for mappings and abbreviations.\n */\ntypedef struct mapblock mapblock_T;\nstruct mapblock {\n  mapblock_T  *m_next;          // next mapblock in list\n  char_u      *m_keys;          // mapped from, lhs\n  char_u      *m_str;           // mapped to, rhs\n  char_u      *m_orig_str;      // rhs as entered by the user\n  int m_keylen;                 // strlen(m_keys)\n  int m_mode;                   // valid mode\n  int m_noremap;                // if non-zero no re-mapping for m_str\n  char m_silent;                // <silent> used, don't echo commands\n  char m_nowait;                // <nowait> used\n  char m_expr;                  // <expr> used, m_str is an expression\n  sctx_T m_script_ctx;          // SCTX where map was defined\n};\n\n/// Used for highlighting in the status line.\ntypedef struct stl_hlrec stl_hlrec_t;\nstruct stl_hlrec {\n  char_u      *start;\n  int userhl;                   // 0: no HL, 1-9: User HL, < 0 for syn ID\n};\n\n/// Used for building the status line.\ntypedef struct stl_item stl_item_t;\nstruct stl_item {\n  // Where the item starts in the status line output buffer\n  char_u *start;\n  // Function to run for ClickFunc items.\n  char *cmd;\n  // The minimum width of the item\n  int minwid;\n  // The maximum width of the item\n  int maxwid;\n  enum {\n    Normal,\n    Empty,\n    Group,\n    Separate,\n    Highlight,\n    TabPage,\n    ClickFunc,\n    Trunc\n  } type;\n};\n\n// values for b_syn_spell: what to do with toplevel text\n#define SYNSPL_DEFAULT  0       // spell check if @Spell not defined\n#define SYNSPL_TOP      1       // spell check toplevel text\n#define SYNSPL_NOTOP    2       // don't spell check toplevel text\n\n// values for b_syn_foldlevel: how to compute foldlevel on a line\n#define SYNFLD_START    0       // use level of item at start of line\n#define SYNFLD_MINIMUM  1       // use lowest local minimum level on line\n\n// avoid #ifdefs for when b_spell is not available\n# define B_SPELL(buf)  ((buf)->b_spell)\n\ntypedef struct qf_info_S qf_info_T;\n\n/*\n * Used for :syntime: timing of executing a syntax pattern.\n */\ntypedef struct {\n  proftime_T total;             // total time used\n  proftime_T slowest;           // time of slowest call\n  long count;                   // nr of times used\n  long match;                   // nr of times matched\n} syn_time_T;\n\n/*\n * These are items normally related to a buffer.  But when using \":ownsyntax\"\n * a window may have its own instance.\n */\ntypedef struct {\n  hashtab_T b_keywtab;                  // syntax keywords hash table\n  hashtab_T b_keywtab_ic;               // idem, ignore case\n  int b_syn_error;                      // TRUE when error occurred in HL\n  bool b_syn_slow;                      // true when 'redrawtime' reached\n  int b_syn_ic;                         // ignore case for :syn cmds\n  int b_syn_foldlevel;                  // how to compute foldlevel on a line\n  int b_syn_spell;                      // SYNSPL_ values\n  garray_T b_syn_patterns;              // table for syntax patterns\n  garray_T b_syn_clusters;              // table for syntax clusters\n  int b_spell_cluster_id;               // @Spell cluster ID or 0\n  int b_nospell_cluster_id;             // @NoSpell cluster ID or 0\n  int b_syn_containedin;                // TRUE when there is an item with a\n                                        // \"containedin\" argument\n  int b_syn_sync_flags;                 // flags about how to sync\n  int16_t b_syn_sync_id;                // group to sync on\n  long b_syn_sync_minlines;             // minimal sync lines offset\n  long b_syn_sync_maxlines;             // maximal sync lines offset\n  long b_syn_sync_linebreaks;           // offset for multi-line pattern\n  char_u      *b_syn_linecont_pat;      // line continuation pattern\n  regprog_T   *b_syn_linecont_prog;     // line continuation program\n  syn_time_T b_syn_linecont_time;\n  int b_syn_linecont_ic;                // ignore-case flag for above\n  int b_syn_topgrp;                     // for \":syntax include\"\n  int b_syn_conceal;                    // auto-conceal for :syn cmds\n  int b_syn_folditems;                  // number of patterns with the HL_FOLD\n                                        // flag set\n  // b_sst_array[] contains the state stack for a number of lines, for the\n  // start of that line (col == 0).  This avoids having to recompute the\n  // syntax state too often.\n  // b_sst_array[] is allocated to hold the state for all displayed lines,\n  // and states for 1 out of about 20 other lines.\n  // b_sst_array        pointer to an array of synstate_T\n  // b_sst_len          number of entries in b_sst_array[]\n  // b_sst_first        pointer to first used entry in b_sst_array[] or NULL\n  // b_sst_firstfree    pointer to first free entry in b_sst_array[] or NULL\n  // b_sst_freecount    number of free entries in b_sst_array[]\n  // b_sst_check_lnum   entries after this lnum need to be checked for\n  //                    validity (MAXLNUM means no check needed)\n  synstate_T  *b_sst_array;\n  int b_sst_len;\n  synstate_T  *b_sst_first;\n  synstate_T  *b_sst_firstfree;\n  int b_sst_freecount;\n  linenr_T b_sst_check_lnum;\n  disptick_T b_sst_lasttick;    // last display tick\n\n  // for spell checking\n  garray_T b_langp;             // list of pointers to slang_T, see spell.c\n  bool b_spell_ismw[256];       // flags: is midword char\n  char_u      *b_spell_ismw_mb;  // multi-byte midword chars\n  char_u      *b_p_spc;         // 'spellcapcheck'\n  regprog_T   *b_cap_prog;      // program for 'spellcapcheck'\n  char_u      *b_p_spf;         // 'spellfile'\n  char_u      *b_p_spl;         // 'spelllang'\n  char_u      *b_p_spo;         // 'spelloptions'\n  int b_cjk;                    // all CJK letters as OK\n  char_u b_syn_chartab[32];     // syntax iskeyword option\n  char_u *b_syn_isk;            // iskeyword option\n} synblock_T;\n\n/// Type used for changedtick_di member in buf_T\n///\n/// Primary exists so that literals of relevant type can be made.\ntypedef TV_DICTITEM_STRUCT(sizeof(\"changedtick\")) ChangedtickDictItem;\n\ntypedef struct {\n  LuaRef on_lines;\n  LuaRef on_bytes;\n  LuaRef on_changedtick;\n  LuaRef on_detach;\n  LuaRef on_reload;\n  bool utf_sizes;\n  bool preview;\n} BufUpdateCallbacks;\n#define BUF_UPDATE_CALLBACKS_INIT { LUA_NOREF, LUA_NOREF, LUA_NOREF, \\\n                                    LUA_NOREF, LUA_NOREF, false, false }\n\nEXTERN int curbuf_splice_pending INIT(= 0);\n\n#define BUF_HAS_QF_ENTRY 1\n#define BUF_HAS_LL_ENTRY 2\n\n// Maximum number of maphash blocks we will have\n#define MAX_MAPHASH 256\n\n/*\n * buffer: structure that holds information about one file\n *\n * Several windows can share a single Buffer\n * A buffer is unallocated if there is no memfile for it.\n * A buffer is new if the associated file has never been loaded yet.\n */\n\nstruct file_buffer {\n  handle_T handle;              // unique id for the buffer (buffer number)\n#define b_fnum handle\n\n  memline_T b_ml;               // associated memline (also contains line count\n\n  buf_T       *b_next;          // links in list of buffers\n  buf_T       *b_prev;\n\n  int b_nwindows;               // nr of windows open on this buffer\n\n  int b_flags;                  // various BF_ flags\n  int b_locked;                 // Buffer is being closed or referenced, don't\n                                // let autocommands wipe it out.\n  int b_ro_locked;              // Non-zero when the buffer can't be changed.\n                                // Used for FileChangedRO\n\n  //\n  // b_ffname   has the full path of the file (NULL for no name).\n  // b_sfname   is the name as the user typed it (or NULL).\n  // b_fname    is the same as b_sfname, unless \":cd\" has been done,\n  //            then it is the same as b_ffname (NULL for no name).\n  //\n  char_u      *b_ffname;        // full path file name, allocated\n  char_u      *b_sfname;        // short file name, allocated, may be equal to\n                                // b_ffname\n  char_u      *b_fname;         // current file name, points to b_ffname or\n                                // b_sfname\n\n  bool file_id_valid;\n  FileID file_id;\n\n  int b_changed;                // 'modified': Set to true if something in the\n                                // file has been changed and not written out.\n  bool b_changed_invalid;       // Set if BufModified autocmd has not been\n                                // triggered since the last time b_changed was\n                                // modified.\n\n  /// Change-identifier incremented for each change, including undo.\n  ///\n  /// This is a dictionary item used to store b:changedtick.\n  ChangedtickDictItem changedtick_di;\n\n  varnumber_T b_last_changedtick;       // b:changedtick when TextChanged or\n                                        // TextChangedI was last triggered.\n  varnumber_T b_last_changedtick_pum;   // b:changedtick when TextChangedP was\n                                        // last triggered.\n\n  bool b_saving;                /* Set to true if we are in the middle of\n                                   saving the buffer. */\n\n  /*\n   * Changes to a buffer require updating of the display.  To minimize the\n   * work, remember changes made and update everything at once.\n   */\n  bool b_mod_set;               /* true when there are changes since the last\n                                   time the display was updated */\n  linenr_T b_mod_top;           // topmost lnum that was changed\n  linenr_T b_mod_bot;           // lnum below last changed line, AFTER the\n                                // change\n  long b_mod_xlines;            // number of extra buffer lines inserted;\n                                // negative when lines were deleted\n  wininfo_T   *b_wininfo;       // list of last used info for each window\n  int b_mod_tick_syn;           // last display tick syntax was updated\n  int b_mod_tick_decor;         // last display tick decoration providers\n                                // where invoked\n\n  long b_mtime;                 // last change time of original file\n  long b_mtime_read;            // last change time when reading\n  uint64_t b_orig_size;         // size of original file in bytes\n  int b_orig_mode;              // mode of original file\n  time_t b_last_used;           // time when the buffer was last used; used\n                                // for viminfo\n\n  fmark_T b_namedm[NMARKS];     // current named marks (mark.c)\n\n  // These variables are set when VIsual_active becomes FALSE\n  visualinfo_T b_visual;\n  int b_visual_mode_eval;            // b_visual.vi_mode for visualmode()\n\n  fmark_T b_last_cursor;        // cursor position when last unloading this\n                                // buffer\n  fmark_T b_last_insert;        // where Insert mode was left\n  fmark_T b_last_change;        // position of last change: '. mark\n\n  /*\n   * the changelist contains old change positions\n   */\n  fmark_T b_changelist[JUMPLISTSIZE];\n  int b_changelistlen;                  // number of active entries\n  bool b_new_change;                    // set by u_savecommon()\n\n  /*\n   * Character table, only used in charset.c for 'iskeyword'\n   * bitset with 4*64=256 bits: 1 bit per character 0-255.\n   */\n  uint64_t b_chartab[4];\n\n  // Table used for mappings local to a buffer.\n  mapblock_T  *(b_maphash[MAX_MAPHASH]);\n\n  // First abbreviation local to a buffer.\n  mapblock_T  *b_first_abbr;\n  // User commands local to the buffer.\n  garray_T b_ucmds;\n  /*\n   * start and end of an operator, also used for '[ and ']\n   */\n  pos_T b_op_start;\n  pos_T b_op_start_orig;  // used for Insstart_orig\n  pos_T b_op_end;\n\n  bool b_marks_read;            // Have we read ShaDa marks yet?\n\n  /*\n   * The following only used in undo.c.\n   */\n  u_header_T  *b_u_oldhead;     // pointer to oldest header\n  u_header_T  *b_u_newhead;     // pointer to newest header; may not be valid\n                                // if b_u_curhead is not NULL\n  u_header_T  *b_u_curhead;     // pointer to current header\n  int b_u_numhead;              // current number of headers\n  bool b_u_synced;              // entry lists are synced\n  long b_u_seq_last;            // last used undo sequence number\n  long b_u_save_nr_last;        // counter for last file write\n  long b_u_seq_cur;             // hu_seq of header below which we are now\n  time_t b_u_time_cur;          // uh_time of header below which we are now\n  long b_u_save_nr_cur;         // file write nr after which we are now\n\n  /*\n   * variables for \"U\" command in undo.c\n   */\n  char_u      *b_u_line_ptr;    // saved line for \"U\" command\n  linenr_T b_u_line_lnum;       // line number of line in u_line\n  colnr_T b_u_line_colnr;       // optional column number\n\n  bool b_scanned;               // ^N/^P have scanned this buffer\n\n  // flags for use of \":lmap\" and IM control\n  long b_p_iminsert;            // input mode for insert\n  long b_p_imsearch;            // input mode for search\n#define B_IMODE_USE_INSERT -1   //  Use b_p_iminsert value for search\n#define B_IMODE_NONE 0          //  Input via none\n#define B_IMODE_LMAP 1          //  Input via langmap\n# define B_IMODE_LAST 1\n\n  int16_t b_kmap_state;         // using \"lmap\" mappings\n# define KEYMAP_INIT    1       // 'keymap' was set, call keymap_init()\n# define KEYMAP_LOADED  2       // 'keymap' mappings have been loaded\n  garray_T b_kmap_ga;           // the keymap table\n\n  /*\n   * Options local to a buffer.\n   * They are here because their value depends on the type of file\n   * or contents of the file being edited.\n   */\n  bool b_p_initialized;                 // set when options initialized\n\n  LastSet b_p_script_ctx[BV_COUNT];     // SCTXs for buffer-local options\n\n  int b_p_ai;                   ///< 'autoindent'\n  int b_p_ai_nopaste;           ///< b_p_ai saved for paste mode\n  char_u *b_p_bkc;              ///< 'backupco\n  unsigned int b_bkc_flags;     ///< flags for 'backupco\n  int b_p_ci;                   ///< 'copyindent'\n  int b_p_bin;                  ///< 'binary'\n  int b_p_bomb;                 ///< 'bomb'\n  char_u *b_p_bh;               ///< 'bufhidden'\n  char_u *b_p_bt;               ///< 'buftype'\n  int b_has_qf_entry;           ///< quickfix exists for buffer\n  int b_p_bl;                   ///< 'buflisted'\n  long b_p_channel;             ///< 'channel'\n  int b_p_cin;                  ///< 'cindent'\n  char_u *b_p_cino;             ///< 'cinoptions'\n  char_u *b_p_cink;             ///< 'cinkeys'\n  char_u *b_p_cinw;             ///< 'cinwords'\n  char_u *b_p_com;              ///< 'comments'\n  char_u *b_p_cms;              ///< 'commentstring'\n  char_u *b_p_cpt;              ///< 'complete'\n#ifdef BACKSLASH_IN_FILENAME\n  char_u *b_p_csl;              ///< 'completeslash'\n#endif\n  char_u *b_p_cfu;              ///< 'completefunc'\n  char_u *b_p_ofu;              ///< 'omnifunc'\n  char_u *b_p_tfu;              ///< 'tagfunc'\n  int b_p_eol;                  ///< 'endofline'\n  int b_p_fixeol;               ///< 'fixendofline'\n  int b_p_et;                   ///< 'expandtab'\n  int b_p_et_nobin;             ///< b_p_et saved for binary mode\n  int b_p_et_nopaste;           ///< b_p_et saved for paste mode\n  char_u *b_p_fenc;             ///< 'fileencoding'\n  char_u *b_p_ff;               ///< 'fileformat'\n  char_u *b_p_ft;               ///< 'filetype'\n  char_u *b_p_fo;               ///< 'formatoptions'\n  char_u *b_p_flp;              ///< 'formatlistpat'\n  int b_p_inf;                  ///< 'infercase'\n  char_u *b_p_isk;              ///< 'iskeyword'\n  char_u *b_p_def;              ///< 'define' local value\n  char_u *b_p_inc;              ///< 'include'\n  char_u *b_p_inex;             ///< 'includeexpr'\n  uint32_t b_p_inex_flags;      ///< flags for 'includeexpr'\n  char_u *b_p_inde;             ///< 'indentexpr'\n  uint32_t b_p_inde_flags;      ///< flags for 'indentexpr'\n  char_u *b_p_indk;             ///< 'indentkeys'\n  char_u *b_p_fp;               ///< 'formatprg'\n  char_u *b_p_fex;              ///< 'formatexpr'\n  uint32_t b_p_fex_flags;       ///< flags for 'formatexpr'\n  char_u *b_p_kp;               ///< 'keywordprg'\n  int b_p_lisp;                 ///< 'lisp'\n  char_u *b_p_menc;             ///< 'makeencoding'\n  char_u *b_p_mps;              ///< 'matchpairs'\n  int b_p_ml;                   ///< 'modeline'\n  int b_p_ml_nobin;             ///< b_p_ml saved for binary mode\n  int b_p_ma;                   ///< 'modifiable'\n  char_u *b_p_nf;               ///< 'nrformats'\n  int b_p_pi;                   ///< 'preserveindent'\n  char_u *b_p_qe;               ///< 'quoteescape'\n  int b_p_ro;                   ///< 'readonly'\n  long b_p_sw;                  ///< 'shiftwidth'\n  long b_p_scbk;                ///< 'scrollback'\n  int b_p_si;                   ///< 'smartindent'\n  long b_p_sts;                 ///< 'softtabstop'\n  long b_p_sts_nopaste;         ///< b_p_sts saved for paste mode\n  char_u *b_p_sua;              ///< 'suffixesadd'\n  int b_p_swf;                  ///< 'swapfile'\n  long b_p_smc;                 ///< 'synmaxcol'\n  char_u *b_p_syn;              ///< 'syntax'\n  long b_p_ts;                  ///< 'tabstop'\n  long b_p_tw;                  ///< 'textwidth'\n  long b_p_tw_nobin;            ///< b_p_tw saved for binary mode\n  long b_p_tw_nopaste;          ///< b_p_tw saved for paste mode\n  long b_p_wm;                  ///< 'wrapmargin'\n  long b_p_wm_nobin;            ///< b_p_wm saved for binary mode\n  long b_p_wm_nopaste;          ///< b_p_wm saved for paste mode\n  char_u *b_p_vsts;             ///< 'varsofttabstop'\n  long *b_p_vsts_array;          ///< 'varsofttabstop' in internal format\n  char_u *b_p_vsts_nopaste;     ///< b_p_vsts saved for paste mode\n  char_u *b_p_vts;              ///< 'vartabstop'\n  long *b_p_vts_array;           ///< 'vartabstop' in internal format\n  char_u *b_p_keymap;           ///< 'keymap'\n\n  // local values for options which are normally global\n  char_u *b_p_gp;               ///< 'grepprg' local value\n  char_u *b_p_mp;               ///< 'makeprg' local value\n  char_u *b_p_efm;              ///< 'errorformat' local value\n  char_u *b_p_ep;               ///< 'equalprg' local value\n  char_u *b_p_path;             ///< 'path' local value\n  int b_p_ar;                   ///< 'autoread' local value\n  char_u *b_p_tags;             ///< 'tags' local value\n  char_u *b_p_tc;               ///< 'tagcase' local value\n  unsigned b_tc_flags;          ///< flags for 'tagcase'\n  char_u *b_p_dict;             ///< 'dictionary' local value\n  char_u *b_p_tsr;              ///< 'thesaurus' local value\n  long b_p_ul;                  ///< 'undolevels' local value\n  int b_p_udf;                  ///< 'undofile'\n  char_u *b_p_lw;               ///< 'lispwords' local value\n\n  // end of buffer options\n\n  // values set from b_p_cino\n  int b_ind_level;\n  int b_ind_open_imag;\n  int b_ind_no_brace;\n  int b_ind_first_open;\n  int b_ind_open_extra;\n  int b_ind_close_extra;\n  int b_ind_open_left_imag;\n  int b_ind_jump_label;\n  int b_ind_case;\n  int b_ind_case_code;\n  int b_ind_case_break;\n  int b_ind_param;\n  int b_ind_func_type;\n  int b_ind_comment;\n  int b_ind_in_comment;\n  int b_ind_in_comment2;\n  int b_ind_cpp_baseclass;\n  int b_ind_continuation;\n  int b_ind_unclosed;\n  int b_ind_unclosed2;\n  int b_ind_unclosed_noignore;\n  int b_ind_unclosed_wrapped;\n  int b_ind_unclosed_whiteok;\n  int b_ind_matching_paren;\n  int b_ind_paren_prev;\n  int b_ind_maxparen;\n  int b_ind_maxcomment;\n  int b_ind_scopedecl;\n  int b_ind_scopedecl_code;\n  int b_ind_java;\n  int b_ind_js;\n  int b_ind_keep_case_label;\n  int b_ind_hash_comment;\n  int b_ind_cpp_namespace;\n  int b_ind_if_for_while;\n  int b_ind_cpp_extern_c;\n  int b_ind_pragma;\n\n  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary\n                                 * write should not have an end-of-line */\n\n  int b_start_eol;              // last line had eol when it was read\n  int b_start_ffc;              // first char of 'ff' when edit started\n  char_u      *b_start_fenc;    // 'fileencoding' when edit started or NULL\n  int b_bad_char;               // \"++bad=\" argument when edit started or 0\n  int b_start_bomb;             // 'bomb' when it was read\n\n  ScopeDictDictItem b_bufvar;  ///< Variable for \"b:\" Dictionary.\n  dict_T *b_vars;  ///< b: scope dictionary.\n\n  /* When a buffer is created, it starts without a swap file.  b_may_swap is\n   * then set to indicate that a swap file may be opened later.  It is reset\n   * if a swap file could not be opened.\n   */\n  bool b_may_swap;\n  bool b_did_warn;              /* Set to true if user has been warned on first\n                                   change of a read-only file */\n\n  /* Two special kinds of buffers:\n   * help buffer  - used for help files, won't use a swap file.\n   * spell buffer - used for spell info, never displayed and doesn't have a\n   *                file name.\n   */\n  bool b_help;                  // TRUE for help file buffer (when set b_p_bt\n                                // is \"help\")\n  bool b_spell;                 // True for a spell file buffer, most fields\n                                // are not used!  Use the B_SPELL macro to\n                                // access b_spell without #ifdef.\n\n  char_u *b_prompt_text;        // set by prompt_setprompt()\n  Callback b_prompt_callback;   // set by prompt_setcallback()\n  Callback b_prompt_interrupt;  // set by prompt_setinterrupt()\n  int b_prompt_insert;          // value for restart_edit when entering\n                                // a prompt buffer window.\n\n  synblock_T b_s;               // Info related to syntax highlighting.  w_s\n                                // normally points to this, but some windows\n                                // may use a different synblock_T.\n\n  sign_entry_T *b_signlist;     // list of placed signs\n  int b_signcols;               // last calculated number of sign columns\n  bool b_signcols_valid;        // calculated sign columns is valid\n\n  Terminal *terminal;           // Terminal instance associated with the buffer\n\n  dict_T *additional_data;      // Additional data from shada file if any.\n\n  int b_mapped_ctrl_c;          // modes where CTRL-C is mapped\n\n  MarkTree b_marktree[1];\n  Map(uint64_t, ExtmarkItem) b_extmark_index[1];\n  Map(uint64_t, ExtmarkNs) b_extmark_ns[1];         // extmark namespaces\n\n  // array of channel_id:s which have asked to receive updates for this\n  // buffer.\n  kvec_t(uint64_t) update_channels;\n  // array of lua callbacks for buffer updates.\n  kvec_t(BufUpdateCallbacks) update_callbacks;\n\n  // whether an update callback has requested codepoint size of deleted regions.\n  bool update_need_codepoints;\n\n  // Measurements of the deleted or replaced region since the last update\n  // event. Some consumers of buffer changes need to know the byte size (like\n  // tree-sitter) or the corresponding UTF-32/UTF-16 size (like LSP) of the\n  // deleted text.\n  size_t deleted_bytes;\n  size_t deleted_bytes2;\n  size_t deleted_codepoints;\n  size_t deleted_codeunits;\n\n  // The number for times the current line has been flushed in the memline.\n  int flush_count;\n\n  int b_diff_failed;    // internal diff failed for this buffer\n};\n\n/*\n * Stuff for diff mode.\n */\n# define DB_COUNT 8     // up to four buffers can be diff'ed\n\n/*\n * Each diffblock defines where a block of lines starts in each of the buffers\n * and how many lines it occupies in that buffer.  When the lines are missing\n * in the buffer the df_count[] is zero.  This is all counted in\n * buffer lines.\n * There is always at least one unchanged line in between the diffs.\n * Otherwise it would have been included in the diff above or below it.\n * df_lnum[] + df_count[] is the lnum below the change.  When in one buffer\n * lines have been inserted, in the other buffer df_lnum[] is the line below\n * the insertion and df_count[] is zero.  When appending lines at the end of\n * the buffer, df_lnum[] is one beyond the end!\n * This is using a linked list, because the number of differences is expected\n * to be reasonable small.  The list is sorted on lnum.\n */\ntypedef struct diffblock_S diff_T;\nstruct diffblock_S {\n  diff_T      *df_next;\n  linenr_T df_lnum[DB_COUNT];           // line number in buffer\n  linenr_T df_count[DB_COUNT];          // nr of inserted/changed lines\n};\n\n#define SNAP_HELP_IDX   0\n# define SNAP_AUCMD_IDX 1\n# define SNAP_COUNT     2\n\n/// Tab pages point to the top frame of each tab page.\n/// Note: Most values are NOT valid for the current tab page!  Use \"curwin\",\n/// \"firstwin\", etc. for that.  \"tp_topframe\" is always valid and can be\n/// compared against \"topframe\" to find the current tab page.\ntypedef struct tabpage_S tabpage_T;\nstruct tabpage_S {\n  handle_T handle;\n  tabpage_T       *tp_next;         ///< next tabpage or NULL\n  frame_T         *tp_topframe;     ///< topframe for the windows\n  win_T           *tp_curwin;       ///< current window in this Tab page\n  win_T           *tp_prevwin;      ///< previous window in this Tab page\n  win_T           *tp_firstwin;     ///< first window in this Tab page\n  win_T           *tp_lastwin;      ///< last window in this Tab page\n  long tp_old_Rows;                 ///< Rows when Tab page was left\n  long tp_old_Columns;              ///< Columns when Tab page was left\n  long tp_ch_used;                  ///< value of 'cmdheight' when frame size\n                                    ///< was set\n\n  diff_T          *tp_first_diff;\n  buf_T           *(tp_diffbuf[DB_COUNT]);\n  int tp_diff_invalid;              ///< list of diffs is outdated\n  int tp_diff_update;               ///< update diffs before redrawing\n  frame_T         *(tp_snapshot[SNAP_COUNT]);    ///< window layout snapshots\n  ScopeDictDictItem tp_winvar;      ///< Variable for \"t:\" Dictionary.\n  dict_T          *tp_vars;         ///< Internal variables, local to tab page.\n  char_u          *tp_localdir;     ///< Absolute path of local cwd or NULL.\n};\n\n/*\n * Structure to cache info for displayed lines in w_lines[].\n * Each logical line has one entry.\n * The entry tells how the logical line is currently displayed in the window.\n * This is updated when displaying the window.\n * When the display is changed (e.g., when clearing the screen) w_lines_valid\n * is changed to exclude invalid entries.\n * When making changes to the buffer, wl_valid is reset to indicate wl_size\n * may not reflect what is actually in the buffer.  When wl_valid is FALSE,\n * the entries can only be used to count the number of displayed lines used.\n * wl_lnum and wl_lastlnum are invalid too.\n */\ntypedef struct w_line {\n  linenr_T wl_lnum;             // buffer line number for logical line\n  uint16_t wl_size;             // height in screen lines\n  char wl_valid;                // TRUE values are valid for text in buffer\n  char wl_folded;               // TRUE when this is a range of folded lines\n  linenr_T wl_lastlnum;         // last buffer line number for logical line\n} wline_T;\n\n/*\n * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)\n * or row (FR_ROW) layout or is a leaf, which has a window.\n */\nstruct frame_S {\n  char fr_layout;               // FR_LEAF, FR_COL or FR_ROW\n  int fr_width;\n  int fr_newwidth;              // new width used in win_equal_rec()\n  int fr_height;\n  int fr_newheight;             // new height used in win_equal_rec()\n  frame_T     *fr_parent;       // containing frame or NULL\n  frame_T     *fr_next;         // frame right or below in same parent, NULL\n                                // for last\n  frame_T     *fr_prev;         // frame left or above in same parent, NULL\n                                // for first\n  // fr_child and fr_win are mutually exclusive\n  frame_T     *fr_child;        // first contained frame\n  win_T       *fr_win;          // window that fills this frame\n};\n\n#define FR_LEAF 0       // frame is a leaf\n#define FR_ROW  1       // frame with a row of windows\n#define FR_COL  2       // frame with a column of windows\n\n/*\n * Struct used for highlighting 'hlsearch' matches, matches defined by\n * \":match\" and matches defined by match functions.\n * For 'hlsearch' there is one pattern for all windows.  For \":match\" and the\n * match functions there is a different pattern for each window.\n */\ntypedef struct {\n  regmmatch_T rm;       // points to the regexp program; contains last found\n                        // match (may continue in next line)\n  buf_T       *buf;     // the buffer to search for a match\n  linenr_T lnum;        // the line to search for a match\n  int attr;             // attributes to be used for a match\n  int attr_cur;         // attributes currently active in win_line()\n  linenr_T first_lnum;  // first lnum to search for multi-line pat\n  colnr_T startcol;     // in win_line() points to char where HL starts\n  colnr_T endcol;       // in win_line() points to char where HL ends\n  bool is_addpos;       // position specified directly by matchaddpos()\n  proftime_T tm;        // for a time limit\n} match_T;\n\n/// number of positions supported by matchaddpos()\n#define MAXPOSMATCH 8\n\n/// Same as lpos_T, but with additional field len.\ntypedef struct\n{\n    linenr_T    lnum;   ///< line number\n    colnr_T     col;    ///< column number\n    int         len;    ///< length: 0 - to the end of line\n} llpos_T;\n\n/// posmatch_T provides an array for storing match items for matchaddpos()\n/// function.\ntypedef struct posmatch posmatch_T;\nstruct posmatch\n{\n    llpos_T     pos[MAXPOSMATCH];   ///< array of positions\n    int         cur;                ///< internal position counter\n    linenr_T    toplnum;            ///< top buffer line\n    linenr_T    botlnum;            ///< bottom buffer line\n};\n\n/*\n * matchitem_T provides a linked list for storing match items for \":match\" and\n * the match functions.\n */\ntypedef struct matchitem matchitem_T;\nstruct matchitem {\n  matchitem_T *next;\n  int id;                   ///< match ID\n  int priority;             ///< match priority\n  char_u *pattern;          ///< pattern to highlight\n  regmmatch_T match;        ///< regexp program for pattern\n  posmatch_T pos;           ///< position matches\n  match_T hl;               ///< struct for doing the actual highlighting\n  int hlg_id;               ///< highlight group ID\n  int conceal_char;         ///< cchar for Conceal highlighting\n};\n\ntypedef int FloatAnchor;\n\nenum {\n  kFloatAnchorEast  = 1,\n  kFloatAnchorSouth = 2,\n};\n\n// NW -> 0\n// NE -> kFloatAnchorEast\n// SW -> kFloatAnchorSouth\n// SE -> kFloatAnchorSouth | kFloatAnchorEast\nEXTERN const char *const float_anchor_str[] INIT(= { \"NW\", \"NE\", \"SW\", \"SE\" });\n\ntypedef enum {\n  kFloatRelativeEditor = 0,\n  kFloatRelativeWindow = 1,\n  kFloatRelativeCursor = 2,\n} FloatRelative;\n\nEXTERN const char *const float_relative_str[] INIT(= { \"editor\", \"win\",\n                                                       \"cursor\" });\n\ntypedef enum {\n  kWinStyleUnused = 0,\n  kWinStyleMinimal,  /// Minimal UI: no number column, eob markers, etc\n} WinStyle;\n\ntypedef struct {\n  Window window;\n  lpos_T bufpos;\n  int height, width;\n  double row, col;\n  FloatAnchor anchor;\n  FloatRelative relative;\n  bool external;\n  bool focusable;\n  int zindex;\n  WinStyle style;\n  bool border;\n  bool shadow;\n  schar_T border_chars[8];\n  int border_hl_ids[8];\n  int border_attr[8];\n  bool noautocmd;\n} FloatConfig;\n\n#define FLOAT_CONFIG_INIT ((FloatConfig){ .height = 0, .width = 0, \\\n                                          .bufpos = { -1, 0 }, \\\n                                          .row = 0, .col = 0, .anchor = 0, \\\n                                          .relative = 0, .external = false, \\\n                                          .focusable = true, \\\n                                          .zindex = kZIndexFloatDefault, \\\n                                          .style = kWinStyleUnused, \\\n                                          .noautocmd = false })\n\n// Structure to store last cursor position and topline.  Used by check_lnums()\n// and reset_lnums().\ntypedef struct\n{\n  int w_topline_save;   // original topline value\n  int w_topline_corr;   // corrected topline value\n  pos_T w_cursor_save;  // original cursor position\n  pos_T w_cursor_corr;  // corrected cursor position\n} pos_save_T;\n\n/// Indices into vimmenu_T->strings[] and vimmenu_T->noremap[] for each mode\n/// \\addtogroup MENU_INDEX\n/// @{\nenum {\n  MENU_INDEX_INVALID      = -1,\n  MENU_INDEX_NORMAL       =  0,\n  MENU_INDEX_VISUAL       =  1,\n  MENU_INDEX_SELECT       =  2,\n  MENU_INDEX_OP_PENDING   =  3,\n  MENU_INDEX_INSERT       =  4,\n  MENU_INDEX_CMDLINE      =  5,\n  MENU_INDEX_TIP          =  6,\n  MENU_MODES              =  7,\n};\n\ntypedef struct VimMenu vimmenu_T;\n\nstruct VimMenu {\n  int modes;                         ///< Which modes is this menu visible for\n  int enabled;                       ///< for which modes the menu is enabled\n  char_u      *name;                 ///< Name of menu, possibly translated\n  char_u      *dname;                ///< Displayed Name (\"name\" without '&')\n  char_u      *en_name;              ///< \"name\" untranslated, NULL when\n                                     ///< was not translated\n  char_u      *en_dname;             ///< NULL when \"dname\" untranslated\n  int mnemonic;                      ///< mnemonic key (after '&')\n  char_u      *actext;               ///< accelerator text (after TAB)\n  long priority;                     ///< Menu order priority\n  char_u      *strings[MENU_MODES];  ///< Mapped string for each mode\n  int noremap[MENU_MODES];           ///< A \\ref REMAP_VALUES flag for each mode\n  bool silent[MENU_MODES];           ///< A silent flag for each mode\n  vimmenu_T   *children;             ///< Children of sub-menu\n  vimmenu_T   *parent;               ///< Parent of menu\n  vimmenu_T   *next;                 ///< Next item in menu\n};\n\n/// Structure which contains all information that belongs to a window.\n///\n/// All row numbers are relative to the start of the window, except w_winrow.\nstruct window_S {\n  handle_T handle;                  ///< unique identifier for the window\n\n  buf_T       *w_buffer;            ///< buffer we are a window into (used\n                                    ///< often, keep it the first item!)\n\n  synblock_T  *w_s;                 ///< for :ownsyntax\n\n  int w_hl_id_normal;               ///< 'winhighlight' normal id\n  int w_hl_attr_normal;             ///< 'winhighlight' normal final attrs\n\n  int w_hl_ids[HLF_COUNT];          ///< 'winhighlight' id\n  int w_hl_attrs[HLF_COUNT];        ///< 'winhighlight' final attrs\n\n  int w_hl_needs_update;            ///< attrs need to be recalculated\n\n  win_T       *w_prev;              ///< link to previous window\n  win_T       *w_next;              ///< link to next window\n  bool w_closing;                   ///< window is being closed, don't let\n                                    ///  autocommands close it too.\n\n  frame_T     *w_frame;             ///< frame containing this window\n\n  pos_T w_cursor;                   ///< cursor position in buffer\n\n  colnr_T w_curswant;               ///< Column we want to be at.  This is\n                                    ///  used to try to stay in the same column\n                                    ///  for up/down cursor motions.\n\n  int w_set_curswant;               // If set, then update w_curswant the next\n                                    // time through cursupdate() to the\n                                    // current virtual column\n\n  linenr_T w_last_cursorline;       ///< where last 'cursorline' was drawn\n  pos_T w_last_cursormoved;         ///< for CursorMoved event\n\n  // the next seven are used to update the visual part\n  char w_old_visual_mode;           ///< last known VIsual_mode\n  linenr_T w_old_cursor_lnum;       ///< last known end of visual part\n  colnr_T w_old_cursor_fcol;        ///< first column for block visual part\n  colnr_T w_old_cursor_lcol;        ///< last column for block visual part\n  linenr_T w_old_visual_lnum;       ///< last known start of visual part\n  colnr_T w_old_visual_col;         ///< last known start of visual part\n  colnr_T w_old_curswant;           ///< last known value of Curswant\n\n  // 'listchars' characters. Defaults set in set_chars_option().\n  struct {\n    int eol;\n    int ext;\n    int prec;\n    int nbsp;\n    int space;\n    int tab1;                       ///< first tab character\n    int tab2;                       ///< second tab character\n    int tab3;                       ///< third tab character\n    int lead;\n    int trail;\n    int conceal;\n  } w_p_lcs_chars;\n\n  // 'fillchars' characters. Defaults set in set_chars_option().\n  struct {\n    int stl;\n    int stlnc;\n    int vert;\n    int fold;\n    int foldopen;                    ///< when fold is open\n    int foldclosed;                  ///< when fold is closed\n    int foldsep;                     ///< continuous fold marker\n    int diff;\n    int msgsep;\n    int eob;\n  } w_p_fcs_chars;\n\n  /*\n   * \"w_topline\", \"w_leftcol\" and \"w_skipcol\" specify the offsets for\n   * displaying the buffer.\n   */\n  linenr_T w_topline;               /* buffer line number of the line at the\n                                       top of the window */\n  char w_topline_was_set;           /* flag set to TRUE when topline is set,\n                                       e.g. by winrestview() */\n  int w_topfill;                    // number of filler lines above w_topline\n  int w_old_topfill;                // w_topfill at last redraw\n  bool w_botfill;                   // true when filler lines are actually\n                                    // below w_topline (at end of file)\n  bool w_old_botfill;               // w_botfill at last redraw\n  colnr_T w_leftcol;                // window column number of the left most\n                                    // character in the window; used when\n                                    // 'wrap' is off\n  colnr_T w_skipcol;                // starting column when a single line\n                                    // doesn't fit in the window\n\n  // \"w_last_topline\" and \"w_last_leftcol\" are used to determine if\n  // a Scroll autocommand should be emitted.\n  linenr_T w_last_topline;          ///< last known value for topline\n  colnr_T w_last_leftcol;          ///< last known value for leftcol\n  int w_last_width;                 ///< last known value for width\n  int w_last_height;                ///< last known value for height\n\n  //\n  // Layout of the window in the screen.\n  // May need to add \"msg_scrolled\" to \"w_winrow\" in rare situations.\n  //\n  int w_winrow;                     // first row of window in screen\n  int w_height;                     // number of rows in window, excluding\n                                    // status/command/winbar line(s)\n  int w_status_height;              // number of status lines (0 or 1)\n  int w_wincol;                     // Leftmost column of window in screen.\n  int w_width;                      // Width of window, excluding separation.\n  int w_vsep_width;                 // Number of separator columns (0 or 1).\n  pos_save_T w_save_cursor;         // backup of cursor pos and topline\n\n  // inner size of window, which can be overridden by external UI\n  int w_height_inner;\n  int w_width_inner;\n  // external UI request. If non-zero, the inner size will use this.\n  int w_height_request;\n  int w_width_request;\n\n  int w_border_adj[4];  // top, right, bottom, left\n  // outer size of window grid, including border\n  int w_height_outer;\n  int w_width_outer;\n\n  /*\n   * === start of cached values ====\n   */\n  /*\n   * Recomputing is minimized by storing the result of computations.\n   * Use functions in screen.c to check if they are valid and to update.\n   * w_valid is a bitfield of flags, which indicate if specific values are\n   * valid or need to be recomputed.\n   */\n  int w_valid;\n  pos_T w_valid_cursor;             /* last known position of w_cursor, used\n                                       to adjust w_valid */\n  colnr_T w_valid_leftcol;          // last known w_leftcol\n\n  bool w_viewport_invalid;\n\n  /*\n   * w_cline_height is the number of physical lines taken by the buffer line\n   * that the cursor is on.  We use this to avoid extra calls to plines_win().\n   */\n  int w_cline_height;               // current size of cursor line\n  bool w_cline_folded;              // cursor line is folded\n\n  int w_cline_row;                  // starting row of the cursor line\n\n  colnr_T w_virtcol;                // column number of the cursor in the\n                                    // buffer line, as opposed to the column\n                                    // number we're at on the screen.  This\n                                    // makes a difference on lines which span\n                                    // more than one screen line or when\n                                    // w_leftcol is non-zero\n\n  /*\n   * w_wrow and w_wcol specify the cursor position in the window.\n   * This is related to positions in the window, not in the display or\n   * buffer, thus w_wrow is relative to w_winrow.\n   */\n  int w_wrow, w_wcol;               // cursor position in window\n\n  linenr_T w_botline;               // number of the line below the bottom of\n                                    // the window\n  int w_empty_rows;                 // number of ~ rows in window\n  int w_filler_rows;                // number of filler rows at the end of the\n                                    // window\n\n  /*\n   * Info about the lines currently in the window is remembered to avoid\n   * recomputing it every time.  The allocated size of w_lines[] is Rows.\n   * Only the w_lines_valid entries are actually valid.\n   * When the display is up-to-date w_lines[0].wl_lnum is equal to w_topline\n   * and w_lines[w_lines_valid - 1].wl_lnum is equal to w_botline.\n   * Between changing text and updating the display w_lines[] represents\n   * what is currently displayed.  wl_valid is reset to indicated this.\n   * This is used for efficient redrawing.\n   */\n  int w_lines_valid;                // number of valid entries\n  wline_T     *w_lines;\n\n  garray_T w_folds;                 // array of nested folds\n  bool w_fold_manual;               // when true: some folds are opened/closed\n                                    // manually\n  bool w_foldinvalid;               // when true: folding needs to be\n                                    // recomputed\n  int w_nrwidth;                    // width of 'number' and 'relativenumber'\n                                    // column being used\n\n  /*\n   * === end of cached values ===\n   */\n\n  int w_redr_type;                  // type of redraw to be performed on win\n  int w_upd_rows;                   // number of window lines to update when\n                                    // w_redr_type is REDRAW_TOP\n  linenr_T w_redraw_top;            // when != 0: first line needing redraw\n  linenr_T w_redraw_bot;            // when != 0: last line needing redraw\n  bool w_redr_status;               // if true status line must be redrawn\n  bool w_redr_border;               // if true border must be redrawn\n\n  // remember what is shown in the ruler for this window (if 'ruler' set)\n  pos_T w_ru_cursor;                // cursor position shown in ruler\n  colnr_T w_ru_virtcol;             // virtcol shown in ruler\n  linenr_T w_ru_topline;            // topline shown in ruler\n  linenr_T w_ru_line_count;         // line count used for ruler\n  int w_ru_topfill;                 // topfill shown in ruler\n  char w_ru_empty;                  // TRUE if ruler shows 0-1 (empty line)\n\n  int w_alt_fnum;                   // alternate file (for # and CTRL-^)\n\n  alist_T     *w_alist;             // pointer to arglist for this window\n  int w_arg_idx;                    // current index in argument list (can be\n                                    // out of range!)\n  int w_arg_idx_invalid;            // editing another file than w_arg_idx\n\n  char_u      *w_localdir;          /* absolute path of local directory or\n                                       NULL */\n  // Options local to a window.\n  // They are local because they influence the layout of the window or\n  // depend on the window layout.\n  // There are two values: w_onebuf_opt is local to the buffer currently in\n  // this window, w_allbuf_opt is for all buffers in this window.\n  winopt_T w_onebuf_opt;\n  winopt_T w_allbuf_opt;\n\n  // A few options have local flags for P_INSECURE.\n  uint32_t w_p_stl_flags;           // flags for 'statusline'\n  uint32_t w_p_fde_flags;           // flags for 'foldexpr'\n  uint32_t w_p_fdt_flags;           // flags for 'foldtext'\n  int         *w_p_cc_cols;         // array of columns to highlight or NULL\n  char_u      w_p_culopt_flags;     // flags for cursorline highlighting\n  long        w_p_siso;             // 'sidescrolloff' local value\n  long        w_p_so;               // 'scrolloff' local value\n\n  int w_briopt_min;                 // minimum width for breakindent\n  int w_briopt_shift;               // additional shift for breakindent\n  bool w_briopt_sbr;                // sbr in 'briopt'\n  int w_briopt_list;                // additional indent for lists\n\n  // transform a pointer to a \"onebuf\" option into a \"allbuf\" option\n#define GLOBAL_WO(p)    ((char *)p + sizeof(winopt_T))\n\n  long w_scbind_pos;\n\n  ScopeDictDictItem w_winvar;  ///< Variable for \"w:\" dictionary.\n  dict_T *w_vars;  ///< Dictionary with w: variables.\n\n  /*\n   * The w_prev_pcmark field is used to check whether we really did jump to\n   * a new line after setting the w_pcmark.  If not, then we revert to\n   * using the previous w_pcmark.\n   */\n  pos_T w_pcmark;               // previous context mark\n  pos_T w_prev_pcmark;          // previous w_pcmark\n\n  /*\n   * the jumplist contains old cursor positions\n   */\n  xfmark_T w_jumplist[JUMPLISTSIZE];\n  int w_jumplistlen;                    // number of active entries\n  int w_jumplistidx;                    // current position\n\n  int w_changelistidx;                  // current position in b_changelist\n\n  matchitem_T *w_match_head;            // head of match list\n  int w_next_match_id;                  // next match ID\n\n  /*\n   * the tagstack grows from 0 upwards:\n   * entry 0: older\n   * entry 1: newer\n   * entry 2: newest\n   */\n  taggy_T w_tagstack[TAGSTACKSIZE];     // the tag stack\n  int w_tagstackidx;                    // idx just below active entry\n  int w_tagstacklen;                    // number of tags on stack\n\n  ScreenGrid w_grid;                    // the grid specific to the window\n  ScreenGrid w_grid_alloc;              // the grid specific to the window\n  bool w_pos_changed;                   // true if window position changed\n  bool w_floating;                       ///< whether the window is floating\n  FloatConfig w_float_config;\n\n  /*\n   * w_fraction is the fractional row of the cursor within the window, from\n   * 0 at the top row to FRACTION_MULT at the last row.\n   * w_prev_fraction_row was the actual cursor row when w_fraction was last\n   * calculated.\n   */\n  int w_fraction;\n  int w_prev_fraction_row;\n\n  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width\n                                         * was computed. */\n  int w_nrwidth_width;                  // nr of chars to print line count.\n\n  qf_info_T   *w_llist;                 // Location list for this window\n  // Location list reference used in the location list window.\n  // In a non-location list window, w_llist_ref is NULL.\n  qf_info_T   *w_llist_ref;\n};\n\nstatic inline int win_hl_attr(win_T *wp, int hlf)\n{\n  return wp->w_hl_attrs[hlf];\n}\n\n/// Macros defined in Vim, but not in Neovim\n#define CHANGEDTICK(buf) \\\n    (=== Include buffer.h & use buf_(get|set|inc)_changedtick ===)\n\n#endif // NVIM_BUFFER_DEFS_H\n"}, "3": {"id": 3, "path": "src/nvim/eval/typval.h", "content": "#ifndef NVIM_EVAL_TYPVAL_H\n#define NVIM_EVAL_TYPVAL_H\n\n#include <inttypes.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"nvim/types.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/lib/queue.h\"\n#include \"nvim/profile.h\"  // for proftime_T\n#include \"nvim/pos.h\"      // for linenr_T\n#include \"nvim/gettext.h\"\n#include \"nvim/message.h\"\n#include \"nvim/macros.h\"\n#ifdef LOG_LIST_ACTIONS\n# include \"nvim/memory.h\"\n#endif\n\n/// Type used for VimL VAR_NUMBER values\ntypedef int64_t varnumber_T;\ntypedef uint64_t uvarnumber_T;\n\n/// Type used for VimL VAR_FLOAT values\ntypedef double float_T;\n\n/// Refcount for dict or list that should not be freed\nenum { DO_NOT_FREE_CNT = (INT_MAX / 2) };\n\n/// Additional values for tv_list_alloc() len argument\nenum ListLenSpecials {\n  /// List length is not known in advance\n  ///\n  /// To be used when there is neither a way to know how many elements will be\n  /// needed nor are any educated guesses.\n  kListLenUnknown = -1,\n  /// List length *should* be known, but is actually not\n  ///\n  /// All occurrences of this value should be eventually removed. This is for\n  /// the case when the only reason why list length is not known is that it\n  /// would be hard to code without refactoring, but refactoring is needed.\n  kListLenShouldKnow = -2,\n  /// List length may be known in advance, but it requires too much effort\n  ///\n  /// To be used when it looks impractical to determine list length.\n  kListLenMayKnow = -3,\n};\n\n/// Maximal possible value of varnumber_T variable\n#define VARNUMBER_MAX INT64_MAX\n#define UVARNUMBER_MAX UINT64_MAX\n\n/// Minimal possible value of varnumber_T variable\n#define VARNUMBER_MIN INT64_MIN\n\n/// %d printf format specifier for varnumber_T\n#define PRIdVARNUMBER PRId64\n\ntypedef struct listvar_S list_T;\ntypedef struct dictvar_S dict_T;\ntypedef struct partial_S partial_T;\n\ntypedef struct ufunc ufunc_T;\n\ntypedef enum {\n  kCallbackNone = 0,\n  kCallbackFuncref,\n  kCallbackPartial,\n} CallbackType;\n\ntypedef struct {\n  union {\n    char_u *funcref;\n    partial_T *partial;\n  } data;\n  CallbackType type;\n} Callback;\n#define CALLBACK_NONE ((Callback){ .type = kCallbackNone })\n\n/// Structure holding dictionary watcher\ntypedef struct dict_watcher {\n  Callback callback;\n  char *key_pattern;\n  size_t key_pattern_len;\n  QUEUE node;\n  bool busy;  // prevent recursion if the dict is changed in the callback\n  bool needs_free;\n} DictWatcher;\n\n/// Bool variable values\ntypedef enum {\n  kBoolVarFalse,         ///< v:false\n  kBoolVarTrue,          ///< v:true\n} BoolVarValue;\n\n/// Special variable values\ntypedef enum {\n  kSpecialVarNull,   ///< v:null\n} SpecialVarValue;\n\n/// Variable lock status for typval_T.v_lock\ntypedef enum {\n  VAR_UNLOCKED = 0,  ///< Not locked.\n  VAR_LOCKED = 1,    ///< User lock, can be unlocked.\n  VAR_FIXED = 2,     ///< Locked forever.\n} VarLockStatus;\n\n/// VimL variable types, for use in typval_T.v_type\ntypedef enum {\n  VAR_UNKNOWN = 0,  ///< Unknown (unspecified) value.\n  VAR_NUMBER,       ///< Number, .v_number is used.\n  VAR_STRING,       ///< String, .v_string is used.\n  VAR_FUNC,         ///< Function reference, .v_string is used as function name.\n  VAR_LIST,         ///< List, .v_list is used.\n  VAR_DICT,         ///< Dictionary, .v_dict is used.\n  VAR_FLOAT,        ///< Floating-point value, .v_float is used.\n  VAR_BOOL,         ///< true, false\n  VAR_SPECIAL,      ///< Special value (null), .v_special\n                    ///< is used.\n  VAR_PARTIAL,      ///< Partial, .v_partial is used.\n} VarType;\n\n/// Structure that holds an internal variable value\ntypedef struct {\n  VarType v_type;  ///< Variable type.\n  VarLockStatus v_lock;  ///< Variable lock status.\n  union typval_vval_union {\n    varnumber_T v_number;  ///< Number, for VAR_NUMBER.\n    BoolVarValue v_bool;        ///< Bool value, for VAR_BOOL\n    SpecialVarValue v_special;  ///< Special value, for VAR_SPECIAL.\n    float_T v_float;  ///< Floating-point number, for VAR_FLOAT.\n    char_u *v_string;  ///< String, for VAR_STRING and VAR_FUNC, can be NULL.\n    list_T *v_list;  ///< List for VAR_LIST, can be NULL.\n    dict_T *v_dict;  ///< Dictionary for VAR_DICT, can be NULL.\n    partial_T *v_partial;  ///< Closure: function with args.\n  }           vval;  ///< Actual value.\n} typval_T;\n\n/// Values for (struct dictvar_S).dv_scope\ntypedef enum {\n  VAR_NO_SCOPE = 0,  ///< Not a scope dictionary.\n  VAR_SCOPE = 1,  ///< Scope dictionary which requires prefix (a:, v:, \u2026).\n  VAR_DEF_SCOPE = 2,  ///< Scope dictionary which may be accessed without prefix\n                      ///< (l:, g:).\n} ScopeType;\n\n/// Structure to hold an item of a list\ntypedef struct listitem_S listitem_T;\n\nstruct listitem_S {\n  listitem_T  *li_next;  ///< Next item in list.\n  listitem_T  *li_prev;  ///< Previous item in list.\n  typval_T li_tv;  ///< Item value.\n};\n\n/// Structure used by those that are using an item in a list\ntypedef struct listwatch_S listwatch_T;\n\nstruct listwatch_S {\n  listitem_T *lw_item;  ///< Item being watched.\n  listwatch_T *lw_next;  ///< Next watcher.\n};\n\n/// Structure to hold info about a list\n/// Order of members is optimized to reduce padding.\nstruct listvar_S {\n  listitem_T *lv_first;  ///< First item, NULL if none.\n  listitem_T *lv_last;  ///< Last item, NULL if none.\n  listwatch_T *lv_watch;  ///< First watcher, NULL if none.\n  listitem_T *lv_idx_item;  ///< When not NULL item at index \"lv_idx\".\n  list_T *lv_copylist;  ///< Copied list used by deepcopy().\n  list_T *lv_used_next;  ///< next list in used lists list.\n  list_T *lv_used_prev;  ///< Previous list in used lists list.\n  int lv_refcount;  ///< Reference count.\n  int lv_len;  ///< Number of items.\n  int lv_idx;  ///< Index of a cached item, used for optimising repeated l[idx].\n  int lv_copyID;  ///< ID used by deepcopy().\n  VarLockStatus lv_lock;  ///< Zero, VAR_LOCKED, VAR_FIXED.\n\n  LuaRef lua_table_ref;\n};\n\n// Static list with 10 items. Use tv_list_init_static10() to initialize.\ntypedef struct {\n  list_T sl_list;  // must be first\n  listitem_T sl_items[10];\n} staticList10_T;\n\n#define TV_LIST_STATIC10_INIT { \\\n    .sl_list = { \\\n      .lv_first = NULL, \\\n      .lv_last = NULL, \\\n      .lv_refcount = 0, \\\n      .lv_len = 0, \\\n      .lv_watch = NULL, \\\n      .lv_idx_item = NULL, \\\n      .lv_lock = VAR_FIXED, \\\n      .lv_used_next = NULL, \\\n      .lv_used_prev = NULL, \\\n    }, \\\n  }\n\n#define TV_DICTITEM_STRUCT(...) \\\n    struct { \\\n      typval_T di_tv;  /* Structure that holds scope dictionary itself. */ \\\n      uint8_t di_flags;  /* Flags. */ \\\n      char_u di_key[__VA_ARGS__];  /* Key value. */ \\\n    }\n\n/// Structure to hold a scope dictionary\n///\n/// @warning Must be compatible with dictitem_T.\n///\n/// For use in find_var_in_ht to pretend that it found dictionary item when it\n/// finds scope dictionary.\ntypedef TV_DICTITEM_STRUCT(1) ScopeDictDictItem;\n\n/// Structure to hold an item of a Dictionary\n///\n/// @warning Must be compatible with ScopeDictDictItem.\n///\n/// Also used for a variable.\ntypedef TV_DICTITEM_STRUCT() dictitem_T;\n\n/// Flags for dictitem_T.di_flags\ntypedef enum {\n  DI_FLAGS_RO = 1,  ///< Read-only value\n  DI_FLAGS_RO_SBX = 2,  ///< Value, read-only in the sandbox\n  DI_FLAGS_FIX = 4,  ///< Fixed value: cannot be :unlet or remove()d.\n  DI_FLAGS_LOCK = 8,  ///< Locked value.\n  DI_FLAGS_ALLOC = 16,  ///< Separately allocated.\n} DictItemFlags;\n\n/// Structure representing a Dictionary\nstruct dictvar_S {\n  VarLockStatus dv_lock;  ///< Whole dictionary lock status.\n  ScopeType dv_scope;     ///< Non-zero (#VAR_SCOPE, #VAR_DEF_SCOPE) if\n                          ///< dictionary represents a scope (i.e. g:, l: \u2026).\n  int dv_refcount;        ///< Reference count.\n  int dv_copyID;          ///< ID used when recursivery traversing a value.\n  hashtab_T dv_hashtab;   ///< Hashtab containing all items.\n  dict_T *dv_copydict;    ///< Copied dict used by deepcopy().\n  dict_T *dv_used_next;   ///< Next dictionary in used dictionaries list.\n  dict_T *dv_used_prev;   ///< Previous dictionary in used dictionaries list.\n  QUEUE watchers;         ///< Dictionary key watchers set by user code.\n\n  LuaRef lua_table_ref;\n};\n\n/// Type used for script ID\ntypedef int scid_T;\n/// Format argument for scid_T\n#define PRIdSCID \"d\"\n\n// SCript ConteXt (SCTX): identifies a script line.\n// When sourcing a script \"sc_lnum\" is zero, \"sourcing_lnum\" is the current\n// line number. When executing a user function \"sc_lnum\" is the line where the\n// function was defined, \"sourcing_lnum\" is the line number inside the\n// function.  When stored with a function, mapping, option, etc. \"sc_lnum\" is\n// the line number in the script \"sc_sid\".\ntypedef struct {\n  scid_T sc_sid;     // script ID\n  int sc_seq;        // sourcing sequence number\n  linenr_T sc_lnum;  // line number\n} sctx_T;\n\n/// Maximum number of function arguments\n#define MAX_FUNC_ARGS   20\n/// Short variable name length\n#define VAR_SHORT_LEN 20\n/// Number of fixed variables used for arguments\n#define FIXVAR_CNT 12\n\n/// Callback interface for C function reference>\n///     Used for managing functions that were registered with |register_cfunc|\ntypedef int (*cfunc_T)(int argcount, typval_T *argvars, typval_T *rettv, void *state);  // NOLINT\n/// Callback to clear cfunc_T and any associated state.\ntypedef void (*cfunc_free_T)(void *state);\n\n// Structure to hold info for a function that is currently being executed.\ntypedef struct funccall_S funccall_T;\n\nstruct funccall_S {\n  ufunc_T *func;  ///< Function being called.\n  int linenr;  ///< Next line to be executed.\n  int returned;  ///< \":return\" used.\n  /// Fixed variables for arguments.\n  TV_DICTITEM_STRUCT(VAR_SHORT_LEN + 1) fixvar[FIXVAR_CNT];\n  dict_T l_vars;  ///< l: local function variables.\n  ScopeDictDictItem l_vars_var;  ///< Variable for l: scope.\n  dict_T l_avars;  ///< a: argument variables.\n  ScopeDictDictItem l_avars_var;  ///< Variable for a: scope.\n  list_T l_varlist;  ///< List for a:000.\n  listitem_T l_listitems[MAX_FUNC_ARGS];  ///< List items for a:000.\n  typval_T *rettv;  ///< Return value.\n  linenr_T breakpoint;  ///< Next line with breakpoint or zero.\n  int dbg_tick;  ///< Debug_tick when breakpoint was set.\n  int level;  ///< Top nesting level of executed function.\n  proftime_T prof_child;  ///< Time spent in a child.\n  funccall_T *caller;  ///< Calling function or NULL; or next funccal in\n                       ///< list pointed to by previous_funccal.\n  int fc_refcount;  ///< Number of user functions that reference this funccall.\n  int fc_copyID;  ///< CopyID used for garbage collection.\n  garray_T fc_funcs;  ///< List of ufunc_T* which keep a reference to \"func\".\n};\n\n/// Structure to hold info for a user function.\nstruct ufunc {\n  int          uf_varargs;       ///< variable nr of arguments\n  int          uf_flags;\n  int          uf_calls;         ///< nr of active calls\n  bool         uf_cleared;       ///< func_clear() was already called\n  garray_T     uf_args;          ///< arguments\n  garray_T     uf_def_args;      ///< default argument expressions\n  garray_T     uf_lines;         ///< function lines\n  int          uf_profiling;     ///< true when func is being profiled\n  int          uf_prof_initialized;\n  // Managing cfuncs\n  cfunc_T      uf_cb;            ///< C function extension callback\n  cfunc_free_T uf_cb_free;       ///< C function extension free callback\n  void        *uf_cb_state;      ///< State of C function extension.\n  // Profiling the function as a whole.\n  int          uf_tm_count;      ///< nr of calls\n  proftime_T   uf_tm_total;      ///< time spent in function + children\n  proftime_T   uf_tm_self;       ///< time spent in function itself\n  proftime_T   uf_tm_children;   ///< time spent in children this call\n  // Profiling the function per line.\n  int         *uf_tml_count;     ///< nr of times line was executed\n  proftime_T  *uf_tml_total;     ///< time spent in a line + children\n  proftime_T  *uf_tml_self;      ///< time spent in a line itself\n  proftime_T   uf_tml_start;     ///< start time for current line\n  proftime_T   uf_tml_children;  ///< time spent in children for this line\n  proftime_T   uf_tml_wait;      ///< start wait time for current line\n  int          uf_tml_idx;       ///< index of line being timed; -1 if none\n  int          uf_tml_execed;    ///< line being timed was executed\n  sctx_T       uf_script_ctx;    ///< SCTX where function was defined,\n                                 ///< used for s: variables\n  int          uf_refcount;      ///< reference count, see func_name_refcount()\n  funccall_T   *uf_scoped;       ///< l: local variables for closure\n  char_u       uf_name[];  ///< Name of function (actual size equals name);\n                           ///< can start with <SNR>123_\n                           ///< (<SNR> is K_SPECIAL KS_EXTRA KE_SNR)\n};\n\nstruct partial_S {\n  int pt_refcount;  ///< Reference count.\n  char_u *pt_name;  ///< Function name; when NULL use pt_func->name.\n  ufunc_T *pt_func;  ///< Function pointer; when NULL lookup function with\n                     ///< pt_name.\n  bool pt_auto;  ///< When true the partial was created by using dict.member\n                 ///< in handle_subscript().\n  int pt_argc;  ///< Number of arguments.\n  typval_T *pt_argv;  ///< Arguments in allocated array.\n  dict_T *pt_dict;  ///< Dict for \"self\".\n};\n\n/// Structure used for explicit stack while garbage collecting hash tables\ntypedef struct ht_stack_S {\n  hashtab_T *ht;\n  struct ht_stack_S *prev;\n} ht_stack_T;\n\n/// Structure used for explicit stack while garbage collecting lists\ntypedef struct list_stack_S {\n  list_T *list;\n  struct list_stack_S *prev;\n} list_stack_T;\n\n/// Structure representing one list item, used for sort array.\ntypedef struct {\n  listitem_T *item;  ///< Sorted list item.\n  int idx;  ///< Sorted list item index.\n} ListSortItem;\n\ntypedef int (*ListSorter)(const void *, const void *);\n\n#ifdef LOG_LIST_ACTIONS\n\n/// List actions log entry\ntypedef struct {\n  uintptr_t l;  ///< List log entry belongs to.\n  uintptr_t li1;  ///< First list item log entry belongs to, if applicable.\n  uintptr_t li2;  ///< Second list item log entry belongs to, if applicable.\n  int len;  ///< List length when log entry was created.\n  const char *action;  ///< Logged action.\n} ListLogEntry;\n\ntypedef struct list_log ListLog;\n\n/// List actions log\nstruct list_log {\n  ListLog *next;  ///< Next chunk or NULL.\n  size_t capacity;  ///< Number of entries in current chunk.\n  size_t size;  ///< Current chunk size.\n  ListLogEntry entries[];  ///< Actual log entries.\n};\n\nextern ListLog *list_log_first;  ///< First list log chunk, NULL if missing\nextern ListLog *list_log_last;  ///< Last list log chunk\n\nstatic inline ListLog *list_log_alloc(const size_t size)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Allocate a new log chunk and update globals\n///\n/// @param[in]  size  Number of entries in a new chunk.\n///\n/// @return [allocated] Newly allocated chunk.\nstatic inline ListLog *list_log_new(const size_t size)\n{\n  ListLog *ret = xmalloc(offsetof(ListLog, entries)\n                         + size * sizeof(ret->entries[0]));\n  ret->size = 0;\n  ret->capacity = size;\n  ret->next = NULL;\n  if (list_log_first == NULL) {\n    list_log_first = ret;\n  } else {\n    list_log_last->next = ret;\n  }\n  list_log_last = ret;\n  return ret;\n}\n\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Add new entry to log\n///\n/// If last chunk was filled it uses twice as much memory to allocate the next\n/// chunk.\n///\n/// @param[in]  l  List to which entry belongs.\n/// @param[in]  li1  List item 1.\n/// @param[in]  li2  List item 2, often used for integers and not list items.\n/// @param[in]  action  Logged action.\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n{\n  ListLog *tgt;\n  if (list_log_first == NULL) {\n    tgt = list_log_new(128);\n  } else if (list_log_last->size == list_log_last->capacity) {\n    tgt = list_log_new(list_log_last->capacity * 2);\n  } else {\n    tgt = list_log_last;\n  }\n  tgt->entries[tgt->size++] = (ListLogEntry) {\n    .l = (uintptr_t)l,\n    .li1 = (uintptr_t)li1,\n    .li2 = (uintptr_t)li2,\n    .len = (l == NULL ? 0 : l->lv_len),\n    .action = action,\n  };\n}\n#else\n# define list_log(...)\n# define list_write_log(...)\n# define list_free_log()\n#endif\n\n// In a hashtab item \"hi_key\" points to \"di_key\" in a dictitem.\n// This avoids adding a pointer to the hashtab item.\n\n/// Convert a hashitem pointer to a dictitem pointer\n#define TV_DICT_HI2DI(hi) \\\n    ((dictitem_T *)((hi)->hi_key - offsetof(dictitem_T, di_key)))\n\nstatic inline void tv_list_ref(list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Increase reference count for a given list\n///\n/// Does nothing for NULL lists.\n///\n/// @param[in,out]  l  List to modify.\nstatic inline void tv_list_ref(list_T *const l)\n{\n  if (l == NULL) {\n    return;\n  }\n  l->lv_refcount++;\n}\n\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a list as the return value.  Increments the reference count.\n///\n/// @param[out]  tv  Object to receive the list\n/// @param[in,out]  l  List to pass to the object\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n{\n  tv->v_type = VAR_LIST;\n  tv->vval.v_list = l;\n  tv_list_ref(l);\n}\n\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get list lock status\n///\n/// Returns VAR_FIXED for NULL lists.\n///\n/// @param[in]  l  List to check.\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n{\n  if (l == NULL) {\n    return VAR_FIXED;\n  }\n  return l->lv_lock;\n}\n\n/// Set list lock status\n///\n/// May only \u201cset\u201d VAR_FIXED for NULL lists.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  lock  New lock status.\nstatic inline void tv_list_set_lock(list_T *const l,\n                                    const VarLockStatus lock)\n{\n  if (l == NULL) {\n    assert(lock == VAR_FIXED);\n    return;\n  }\n  l->lv_lock = lock;\n}\n\n/// Set list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  copyid  New copyID.\nstatic inline void tv_list_set_copyid(list_T *const l,\n                                      const int copyid)\n  FUNC_ATTR_NONNULL_ALL\n{\n  l->lv_copyID = copyid;\n}\n\nstatic inline int tv_list_len(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a list\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_len(const list_T *const l)\n{\n  list_log(l, NULL, NULL, \"len\");\n  if (l == NULL) {\n    return 0;\n  }\n  return l->lv_len;\n}\n\nstatic inline int tv_list_copyid(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_copyid(const list_T *const l)\n{\n  return l->lv_copyID;\n}\n\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get latest list copy\n///\n/// Gets lv_copylist field assigned by tv_list_copy() earlier.\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n{\n  return l->lv_copylist;\n}\n\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Normalize index: that is, return either -1 or non-negative index\n///\n/// @param[in]  l  List to index. Used to get length.\n/// @param[in]  n  List index, possibly negative.\n///\n/// @return -1 or list index in range [0, tv_list_len(l)).\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n{\n  // Negative index is relative to the end.\n  if (n < 0) {\n    n += tv_list_len(l);\n  }\n\n  // Check for index out of range.\n  if (n < 0 || n >= tv_list_len(l)) {\n    return -1;\n  }\n  return n;\n}\n\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check whether list has watchers\n///\n/// E.g. is referenced by a :for loop.\n///\n/// @param[in]  l  List to check.\n///\n/// @return true if there are watchers, false otherwise.\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n{\n  return l && l->lv_watch;\n}\n\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get first list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"first\");\n    return NULL;\n  }\n  list_log(l, l->lv_first, NULL, \"first\");\n  return l->lv_first;\n}\n\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get last list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"last\");\n    return NULL;\n  }\n  list_log(l, l->lv_last, NULL, \"last\");\n  return l->lv_last;\n}\n\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a dictionary as the return value\n///\n/// @param[out]  tv  Object to receive the dictionary\n/// @param[in,out]  d  Dictionary to pass to the object\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n{\n  tv->v_type = VAR_DICT;\n  tv->vval.v_dict = d;\n  if (d != NULL) {\n    d->dv_refcount++;\n  }\n}\n\nstatic inline long tv_dict_len(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a Dictionary\n///\n/// @param[in]  d  Dictionary to check.\nstatic inline long tv_dict_len(const dict_T *const d)\n{\n  if (d == NULL) {\n    return 0L;\n  }\n  return (long)d->dv_hashtab.ht_used;\n}\n\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check if dictionary is watched\n///\n/// @param[in]  d  Dictionary to check.\n///\n/// @return true if there is at least one watcher.\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n{\n  return d && !QUEUE_EMPTY(&d->watchers);\n}\n\n/// Initialize VimL object\n///\n/// Initializes to unlocked VAR_UNKNOWN object.\n///\n/// @param[out]  tv  Object to initialize.\nstatic inline void tv_init(typval_T *const tv)\n{\n  if (tv != NULL) {\n    memset(tv, 0, sizeof(*tv));\n  }\n}\n\n#define TV_INITIAL_VALUE \\\n    ((typval_T) { \\\n      .v_type = VAR_UNKNOWN, \\\n      .v_lock = VAR_UNLOCKED, \\\n    })\n\n/// Empty string\n///\n/// Needed for hack which allows not allocating empty string and still not\n/// crashing when freeing it.\nextern const char *const tv_empty_string;\n\n/// Specifies that free_unref_items() function has (not) been entered\nextern bool tv_in_free_unref_items;\n\n/// Iterate over a list\n///\n/// @param  modifier  Modifier: expected to be const or nothing, volatile should\n///                   also work if you have any uses for the volatile list.\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define _TV_LIST_ITER_MOD(modifier, l, li, code) \\\n    do { \\\n      modifier list_T *const l_ = (l); \\\n      list_log(l_, NULL, NULL, \"iter\" #modifier); \\\n      if (l_ != NULL) { \\\n        for (modifier listitem_T *li = l_->lv_first; \\\n             li != NULL; li = li->li_next) { \\\n          code \\\n        } \\\n      } \\\n    } while (0)\n\n/// Iterate over a list\n///\n/// To be used when you need to modify list or values you iterate over, use\n/// #TV_LIST_ITER_CONST if you don\u2019t.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER(l, li, code) \\\n    _TV_LIST_ITER_MOD(, l, li, code)\n\n/// Iterate over a list\n///\n/// To be used when you don\u2019t need to modify list or values you iterate over,\n/// use #TV_LIST_ITER if you do.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER_CONST(l, li, code) \\\n    _TV_LIST_ITER_MOD(const, l, li, code)\n\n// Below macros are macros to avoid duplicating code for functionally identical\n// const and non-const function variants.\n\n/// Get typval_T out of list item\n///\n/// @param[in]  li  List item to get typval_T from, must not be NULL.\n///\n/// @return Pointer to typval_T.\n#define TV_LIST_ITEM_TV(li) (&(li)->li_tv)\n\n/// Get next list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the next item or NULL.\n#define TV_LIST_ITEM_NEXT(l, li) ((li)->li_next)\n\n/// Get previous list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the previous item or NULL.\n#define TV_LIST_ITEM_PREV(l, li) ((li)->li_prev)\n// List argument is not used currently, but it is a must for lists implemented\n// as a pair (size(in list), array) without terminator - basically for lists on\n// top of kvec.\n\n/// Iterate over a dictionary\n///\n/// @param[in]  d  Dictionary to iterate over.\n/// @param  di  Name of the variable with current dictitem_T entry.\n/// @param  code  Cycle body.\n#define TV_DICT_ITER(d, di, code) \\\n    HASHTAB_ITER(&(d)->dv_hashtab, di##hi_, { \\\n      { \\\n        dictitem_T *const di = TV_DICT_HI2DI(di##hi_); \\\n        { \\\n          code \\\n        } \\\n      } \\\n    })\n\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n// FIXME circular dependency, cannot import message.h.\nbool emsgf(const char *const fmt, ...);\n\n/// Get the float value\n///\n/// Raises an error if object is not number or floating-point.\n///\n/// @param[in]  tv  VimL object to get value from.\n/// @param[out]  ret_f  Location where resulting float is stored.\n///\n/// @return true in case of success, false if tv is not a number or float.\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n{\n  if (tv->v_type == VAR_FLOAT) {\n    *ret_f = tv->vval.v_float;\n    return true;\n  }\n  if (tv->v_type == VAR_NUMBER) {\n    *ret_f = (float_T)tv->vval.v_number;\n    return true;\n  }\n  emsgf(\"%s\", _(\"E808: Number or Float required\"));\n  return false;\n}\n\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_NONNULL_RET REAL_FATTR_PURE\n  REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_ALWAYS_INLINE;\n\n/// Compute the `DictWatcher` address from a QUEUE node.\n///\n/// This only exists for .asan-blacklist (ASAN doesn't handle QUEUE_DATA pointer\n/// arithmetic).\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n{\n  return QUEUE_DATA(q, DictWatcher, node);\n}\n\nstatic inline bool tv_is_func(const typval_T tv)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;\n\n/// Check whether given typval_T contains a function\n///\n/// That is, whether it contains VAR_FUNC or VAR_PARTIAL.\n///\n/// @param[in]  tv  Typval to check.\n///\n/// @return True if it is a function or a partial, false otherwise.\nstatic inline bool tv_is_func(const typval_T tv)\n{\n  return tv.v_type == VAR_FUNC || tv.v_type == VAR_PARTIAL;\n}\n\n/// Specify that argument needs to be translated\n///\n/// Used for size_t length arguments to avoid calling gettext() and strlen()\n/// unless needed.\n#define TV_TRANSLATE (SIZE_MAX)\n\n/// Specify that argument is a NUL-terminated C string\n///\n/// Used for size_t length arguments to avoid calling strlen() unless needed.\n#define TV_CSTRING (SIZE_MAX - 1)\n\n#ifdef UNIT_TESTING\n// Do not use enum constants, see commit message.\nEXTERN const size_t kTVCstring INIT(= TV_CSTRING);\nEXTERN const size_t kTVTranslate INIT(= TV_TRANSLATE);\n#endif\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"eval/typval.h.generated.h\"\n#endif\n#endif  // NVIM_EVAL_TYPVAL_H\n"}, "4": {"id": 4, "path": "src/nvim/event/defs.h", "content": "#ifndef NVIM_EVENT_DEFS_H\n#define NVIM_EVENT_DEFS_H\n\n#include <assert.h>\n#include <stdarg.h>\n\n#define EVENT_HANDLER_MAX_ARGC 10\n\ntypedef void (*argv_callback)(void **argv);\ntypedef struct message {\n  argv_callback handler;\n  void *argv[EVENT_HANDLER_MAX_ARGC];\n} Event;\ntypedef void(*event_scheduler)(Event event, void *data);\n\n#define VA_EVENT_INIT(event, h, a) \\\n  do { \\\n    assert(a <= EVENT_HANDLER_MAX_ARGC); \\\n    (event)->handler = h; \\\n    if (a) { \\\n      va_list args; \\\n      va_start(args, a); \\\n      for (int i = 0; i < a; i++) { \\\n        (event)->argv[i] = va_arg(args, void *); \\\n      } \\\n      va_end(args); \\\n    } \\\n  } while (0)\n\nstatic inline Event event_create(argv_callback cb, int argc, ...)\n{\n  assert(argc <= EVENT_HANDLER_MAX_ARGC);\n  Event event;\n  VA_EVENT_INIT(&event, cb, argc);\n  return event;\n}\n\n#endif  // NVIM_EVENT_DEFS_H\n"}, "5": {"id": 5, "path": "src/nvim/event/loop.h", "content": "#ifndef NVIM_EVENT_LOOP_H\n#define NVIM_EVENT_LOOP_H\n\n#include <stdint.h>\n\n#include <uv.h>\n\n#include \"nvim/lib/klist.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/event/multiqueue.h\"\n\ntypedef void * WatcherPtr;\n\n#define _noop(x)\nKLIST_INIT(WatcherPtr, WatcherPtr, _noop)\n\ntypedef struct loop {\n  uv_loop_t uv;\n  MultiQueue *events;\n  MultiQueue *thread_events;\n  // Immediate events:\n  //    \"Processed after exiting uv_run() (to avoid recursion), but before\n  //    returning from loop_poll_events().\" 502aee690c98\n  // Practical consequence (for main_loop): these events are processed by\n  //    state_enter()..os_inchar()\n  // whereas \"regular\" events (main_loop.events) are processed by\n  //    state_enter()..VimState.execute()\n  // But state_enter()..os_inchar() can be \"too early\" if you want the event\n  // to trigger UI updates and other user-activity-related side-effects.\n  MultiQueue *fast_events;\n\n  // used by process/job-control subsystem\n  klist_t(WatcherPtr) *children;\n  uv_signal_t children_watcher;\n  uv_timer_t children_kill_timer;\n\n  // generic timer, used by loop_poll_events()\n  uv_timer_t poll_timer;\n\n  uv_async_t async;\n  uv_mutex_t mutex;\n  int recursive;\n} Loop;\n\n#define CREATE_EVENT(multiqueue, handler, argc, ...) \\\n  do { \\\n    if (multiqueue) { \\\n      multiqueue_put((multiqueue), (handler), argc, __VA_ARGS__); \\\n    } else { \\\n      void *argv[argc] = { __VA_ARGS__ }; \\\n      (handler)(argv); \\\n    } \\\n  } while (0)\n\n// -V:LOOP_PROCESS_EVENTS_UNTIL:547\n\n// Poll for events until a condition or timeout\n#define LOOP_PROCESS_EVENTS_UNTIL(loop, multiqueue, timeout, condition) \\\n  do { \\\n    int remaining = timeout; \\\n    uint64_t before = (remaining > 0) ? os_hrtime() : 0; \\\n    while (!(condition)) { \\\n      LOOP_PROCESS_EVENTS(loop, multiqueue, remaining); \\\n      if (remaining == 0) { \\\n        break; \\\n      } else if (remaining > 0) { \\\n        uint64_t now = os_hrtime(); \\\n        remaining -= (int) ((now - before) / 1000000); \\\n        before = now; \\\n        if (remaining <= 0) { \\\n          break; \\\n        } \\\n      } \\\n    } \\\n  } while (0)\n\n#define LOOP_PROCESS_EVENTS(loop, multiqueue, timeout) \\\n  do { \\\n    if (multiqueue && !multiqueue_empty(multiqueue)) { \\\n      multiqueue_process_events(multiqueue); \\\n    } else { \\\n      loop_poll_events(loop, timeout); \\\n    } \\\n  } while (0)\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"event/loop.h.generated.h\"\n#endif\n\n#endif  // NVIM_EVENT_LOOP_H\n"}, "6": {"id": 6, "path": "src/nvim/ex_cmds_defs.h", "content": "#ifndef NVIM_EX_CMDS_DEFS_H\n#define NVIM_EX_CMDS_DEFS_H\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"nvim/pos.h\"      // for linenr_T\n#include \"nvim/normal.h\"\n#include \"nvim/regexp_defs.h\"\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"ex_cmds_enum.generated.h\"\n#endif\n\n// When adding an Ex command:\n// 1. Add an entry to the table in src/nvim/ex_cmds.lua.  Keep it sorted on the\n//    shortest version of the command name that works.  If it doesn't start with\n//    a lower case letter, add it at the end.\n//\n//    Each table entry is a table with the following keys:\n//\n//      Key     | Description\n//      ------- | -------------------------------------------------------------\n//      command | Name of the command. Required.\n//      enum    | Name of the enum entry. If not set defaults to CMD_{command}.\n//      flags   | A set of the flags from below list joined by bitwise or.\n//      func    | Name of the function containing the implementation.\n//\n//    Referenced function should be either non-static one or defined in\n//    ex_docmd.c and be coercible to ex_func_T type from below.\n//\n//    All keys not described in the above table are reserved for future use.\n//\n// 2. Add a \"case: CMD_xxx\" in the big switch in ex_docmd.c.\n// 3. Add an entry in the index for Ex commands at \":help ex-cmd-index\".\n// 4. Add documentation in ../doc/xxx.txt.  Add a tag for both the short and\n//    long name of the command.\n\n#define EX_RANGE           0x001  // allow a linespecs\n#define EX_BANG            0x002  // allow a ! after the command name\n#define EX_EXTRA           0x004  // allow extra args after command name\n#define EX_XFILE           0x008  // expand wildcards in extra part\n#define EX_NOSPC           0x010  // no spaces allowed in the extra part\n#define EX_DFLALL          0x020  // default file range is 1,$\n#define EX_WHOLEFOLD       0x040  // extend range to include whole fold also\n                                  // when less than two numbers given\n#define EX_NEEDARG         0x080  // argument required\n#define EX_TRLBAR          0x100  // check for trailing vertical bar\n#define EX_REGSTR          0x200  // allow \"x for register designation\n#define EX_COUNT           0x400  // allow count in argument, after command\n#define EX_NOTRLCOM        0x800  // no trailing comment allowed\n#define EX_ZEROR          0x1000  // zero line number allowed\n#define EX_CTRLV          0x2000  // do not remove CTRL-V from argument\n#define EX_CMDARG         0x4000  // allow \"+command\" argument\n#define EX_BUFNAME        0x8000  // accepts buffer name\n#define EX_BUFUNL        0x10000  // accepts unlisted buffer too\n#define EX_ARGOPT        0x20000  // allow \"++opt=val\" argument\n#define EX_SBOXOK        0x40000  // allowed in the sandbox\n#define EX_CMDWIN        0x80000  // allowed in cmdline window; when missing\n                                  // disallows editing another buffer when\n                                  // current buffer is locked\n#define EX_MODIFY       0x100000  // forbidden in non-'modifiable' buffer\n#define EX_FLAGS        0x200000  // allow flags after count in argument\n#define EX_FILES (EX_XFILE | EX_EXTRA)  // multiple extra files allowed\n#define EX_FILE1 (EX_FILES | EX_NOSPC)  // 1 file, defaults to current file\n#define EX_WORD1 (EX_EXTRA | EX_NOSPC)  // one extra word allowed\n\n// values for cmd_addr_type\ntypedef enum {\n  ADDR_LINES,           // buffer line numbers\n  ADDR_WINDOWS,         // window number\n  ADDR_ARGUMENTS,       // argument number\n  ADDR_LOADED_BUFFERS,  // buffer number of loaded buffer\n  ADDR_BUFFERS,         // buffer number\n  ADDR_TABS,            // tab page number\n  ADDR_TABS_RELATIVE,   // Tab page that only relative\n  ADDR_QUICKFIX_VALID,  // quickfix list valid entry number\n  ADDR_QUICKFIX,        // quickfix list entry number\n  ADDR_UNSIGNED,        // positive count or zero, defaults to 1\n  ADDR_OTHER,           // something else, use line number for '$', '%', etc.\n  ADDR_NONE             // no range used\n} cmd_addr_T;\n\ntypedef struct exarg exarg_T;\n\n/* behavior for bad character, \"++bad=\" argument */\n#define BAD_REPLACE     '?'     /* replace it with '?' (default) */\n#define BAD_KEEP        -1      /* leave it */\n#define BAD_DROP        -2      /* erase it */\n\ntypedef void (*ex_func_T)(exarg_T *eap);\n\ntypedef char_u *(*LineGetter)(int, void *, int, bool);\n\n/// Structure for command definition.\ntypedef struct cmdname {\n  char_u *cmd_name;    ///< Name of the command.\n  ex_func_T cmd_func;  ///< Function with implementation of this command.\n  uint32_t cmd_argt;     ///< Relevant flags from the declared above.\n  cmd_addr_T cmd_addr_type;  ///< Flag for address type\n} CommandDefinition;\n\n// A list used for saving values of \"emsg_silent\".  Used by ex_try() to save the\n// value of \"emsg_silent\" if it was non-zero.  When this is done, the CSF_SILENT\n// flag below is set.\ntypedef struct eslist_elem eslist_T;\nstruct eslist_elem {\n  int saved_emsg_silent;  // saved value of \"emsg_silent\"\n  eslist_T *next;         // next element on the list\n};\n\n// For conditional commands a stack is kept of nested conditionals.\n// When cs_idx < 0, there is no conditional command.\nenum {\n  CSTACK_LEN = 50,\n};\n\ntypedef struct {\n  int cs_flags[CSTACK_LEN];         // CSF_ flags\n  char cs_pending[CSTACK_LEN];      // CSTP_: what's pending in \":finally\"\n  union {\n    void *csp_rv[CSTACK_LEN];       // return typeval for pending return\n    void *csp_ex[CSTACK_LEN];       // exception for pending throw\n  } cs_pend;\n  void *cs_forinfo[CSTACK_LEN];     // info used by \":for\"\n  int cs_line[CSTACK_LEN];          // line nr of \":while\"/\":for\" line\n  int cs_idx;                       // current entry, or -1 if none\n  int cs_looplevel;                 // nr of nested \":while\"s and \":for\"s\n  int cs_trylevel;                  // nr of nested \":try\"s\n  eslist_T *cs_emsg_silent_list;    // saved values of \"emsg_silent\"\n  int cs_lflags;                    // loop flags: CSL_ flags\n} cstack_T;\n# define cs_rettv       cs_pend.csp_rv\n# define cs_exception   cs_pend.csp_ex\n\n// Flags for the cs_lflags item in cstack_T.\nenum {\n  CSL_HAD_LOOP =    1,  // just found \":while\" or \":for\"\n  CSL_HAD_ENDLOOP = 2,  // just found \":endwhile\" or \":endfor\"\n  CSL_HAD_CONT =    4,  // just found \":continue\"\n  CSL_HAD_FINA =    8,  // just found \":finally\"\n};\n\n/// Arguments used for Ex commands.\nstruct exarg {\n  char_u      *arg;             ///< argument of the command\n  char_u      *nextcmd;         ///< next command (NULL if none)\n  char_u      *cmd;             ///< the name of the command (except for :make)\n  char_u      **cmdlinep;       ///< pointer to pointer of allocated cmdline\n  cmdidx_T cmdidx;              ///< the index for the command\n  uint32_t argt;                ///< flags for the command\n  int skip;                     ///< don't execute the command, only parse it\n  int forceit;                  ///< TRUE if ! present\n  int addr_count;               ///< the number of addresses given\n  linenr_T line1;               ///< the first line number\n  linenr_T line2;               ///< the second line number or count\n  cmd_addr_T addr_type;         ///< type of the count/range\n  int flags;                    ///< extra flags after count: EXFLAG_\n  char_u      *do_ecmd_cmd;     ///< +command arg to be used in edited file\n  linenr_T do_ecmd_lnum;        ///< the line number in an edited file\n  int append;                   ///< TRUE with \":w >>file\" command\n  int usefilter;                ///< TRUE with \":w !command\" and \":r!command\"\n  int amount;                   ///< number of '>' or '<' for shift command\n  int regname;                  ///< register name (NUL if none)\n  int force_bin;                ///< 0, FORCE_BIN or FORCE_NOBIN\n  int read_edit;                ///< ++edit argument\n  int force_ff;                 ///< ++ff= argument (first char of argument)\n  int force_enc;                ///< ++enc= argument (index in cmd[])\n  int bad_char;                 ///< BAD_KEEP, BAD_DROP or replacement byte\n  int useridx;                  ///< user command index\n  char_u *errmsg;               ///< returned error message\n  LineGetter getline;           ///< Function used to get the next line\n  void   *cookie;               ///< argument for getline()\n  cstack_T *cstack;             ///< condition stack for \":if\" etc.\n  long verbose_save;            ///< saved value of p_verbose\n  int save_msg_silent;          ///< saved value of msg_silent\n  int did_esilent;              ///< how many times emsg_silent was incremented\n  bool did_sandbox;             ///< when true did sandbox++\n};\n\n#define FORCE_BIN 1             // \":edit ++bin file\"\n#define FORCE_NOBIN 2           // \":edit ++nobin file\"\n\n// Values for \"flags\"\n#define EXFLAG_LIST     0x01    // 'l': list\n#define EXFLAG_NR       0x02    // '#': number\n#define EXFLAG_PRINT    0x04    // 'p': print\n\n// used for completion on the command line\nstruct expand {\n  char_u *xp_pattern;           // start of item to expand\n  int xp_context;               // type of expansion\n  size_t xp_pattern_len;        // bytes in xp_pattern before cursor\n  char_u *xp_arg;               // completion function\n  sctx_T xp_script_ctx;         // SCTX for completion function\n  int xp_backslash;             // one of the XP_BS_ values\n#ifndef BACKSLASH_IN_FILENAME\n  int xp_shell;                 // TRUE for a shell command, more\n                                // characters need to be escaped\n#endif\n  int xp_numfiles;              // number of files found by file name completion\n  int xp_col;                   // cursor position in line\n  char_u **xp_files;            // list of files\n  char_u *xp_line;              // text being completed\n};\n\n// values for xp_backslash\n#define XP_BS_NONE      0       // nothing special for backslashes\n#define XP_BS_ONE       1       // uses one backslash before a space\n#define XP_BS_THREE     2       // uses three backslashes before a space\n\n/// Command modifiers \":vertical\", \":browse\", \":confirm\", \":hide\", etc. set a\n/// flag.  This needs to be saved for recursive commands, put them in a\n/// structure for easy manipulation.\ntypedef struct {\n  int split;                   ///< flags for win_split()\n  int tab;                     ///< > 0 when \":tab\" was used\n  bool browse;                 ///< true to invoke file dialog\n  bool confirm;                ///< true to invoke yes/no dialog\n  bool hide;                   ///< true when \":hide\" was used\n  bool keepalt;                ///< true when \":keepalt\" was used\n  bool keepjumps;              ///< true when \":keepjumps\" was used\n  bool keepmarks;              ///< true when \":keepmarks\" was used\n  bool keeppatterns;           ///< true when \":keeppatterns\" was used\n  bool lockmarks;              ///< true when \":lockmarks\" was used\n  bool noswapfile;             ///< true when \":noswapfile\" was used\n  char_u *save_ei;             ///< saved value of 'eventignore'\n  regmatch_T filter_regmatch;  ///< set by :filter /pat/\n  bool filter_force;           ///< set for :filter!\n} cmdmod_T;\n\n#endif  // NVIM_EX_CMDS_DEFS_H\n"}, "8": {"id": 8, "path": "src/nvim/getchar.h", "content": "#ifndef NVIM_GETCHAR_H\n#define NVIM_GETCHAR_H\n\n#include \"nvim/os/fileio.h\"\n#include \"nvim/types.h\"\n#include \"nvim/buffer_defs.h\"\n#include \"nvim/ex_cmds_defs.h\"\n#include \"nvim/vim.h\"\n\n/// Values for \"noremap\" argument of ins_typebuf()\n///\n/// Also used for map->m_noremap and menu->noremap[].\nenum RemapValues {\n  REMAP_YES = 0,  ///< Allow remapping.\n  REMAP_NONE = -1,  ///< No remapping.\n  REMAP_SCRIPT = -2,  ///< Remap script-local mappings only.\n  REMAP_SKIP = -3,  ///< No remapping for first char.\n};\n\n// Argument for flush_buffers().\ntypedef enum {\n  FLUSH_MINIMAL,\n  FLUSH_TYPEAHEAD,  // flush current typebuf contents\n  FLUSH_INPUT       // flush typebuf and inchar() input\n} flush_buffers_T;\n\n/// All possible |:map-arguments| usable in a |:map| command.\n///\n/// The <special> argument has no effect on mappings and is excluded from this\n/// struct declaration. |noremap| is included, since it behaves like a map\n/// argument when used in a mapping.\n///\n/// @see mapblock_T\nstruct map_arguments {\n  bool buffer;\n  bool expr;\n  bool noremap;\n  bool nowait;\n  bool script;\n  bool silent;\n  bool unique;\n\n  /// The {lhs} of the mapping.\n  ///\n  /// vim limits this to MAXMAPLEN characters, allowing us to use a static\n  /// buffer. Setting lhs_len to a value larger than MAXMAPLEN can signal\n  /// that {lhs} was too long and truncated.\n  char_u lhs[MAXMAPLEN + 1];\n  size_t lhs_len;\n\n  char_u *rhs;  /// The {rhs} of the mapping.\n  size_t rhs_len;\n  bool rhs_is_noop;  /// True when the {orig_rhs} is <nop>.\n\n  char_u *orig_rhs;  /// The original text of the {rhs}.\n  size_t orig_rhs_len;\n};\ntypedef struct map_arguments MapArguments;\n\n#define KEYLEN_PART_KEY -1  // keylen value for incomplete key-code\n#define KEYLEN_PART_MAP -2  // keylen value for incomplete mapping\n\n/// Maximum number of streams to read script from\nenum { NSCRIPT = 15 };\n\n/// Streams to read script from\nextern FileDescriptor *scriptin[NSCRIPT];\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"getchar.h.generated.h\"\n#endif\n#endif  // NVIM_GETCHAR_H\n"}, "9": {"id": 9, "path": "src/nvim/gettext.h", "content": "#ifndef NVIM_GETTEXT_H\n#define NVIM_GETTEXT_H\n\n#ifdef HAVE_WORKING_LIBINTL\n# include <libintl.h>\n# define _(x) gettext((char *)(x))\n// XXX do we actually need this?\n# ifdef gettext_noop\n#  define N_(x) gettext_noop(x)\n# else\n#  define N_(x) x\n# endif\n# define NGETTEXT(x, xs, n) ngettext(x, xs, n)\n// On a Mac, gettext's libintl.h defines \"setlocale\" to be replaced by\n// \"libintl_setlocal\" which leads to wrong return values. #9789\n# if defined(__APPLE__) && defined(setlocale)\n#  undef setlocale\n# endif\n#else\n# define _(x) ((char *)(x))\n# define N_(x) x\n# define NGETTEXT(x, xs, n) ((n) == 1 ? (x) : (xs))\n# define bindtextdomain(x, y)  // empty\n# define bind_textdomain_codeset(x, y)  // empty\n# define textdomain(x)  // empty\n#endif\n\n#endif  // NVIM_GETTEXT_H\n"}, "10": {"id": 10, "path": "src/nvim/globals.h", "content": "#ifndef NVIM_GLOBALS_H\n#define NVIM_GLOBALS_H\n\n#include <stdbool.h>\n#include <inttypes.h>\n\n#include \"nvim/macros.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/iconv.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/menu.h\"\n#include \"nvim/syntax_defs.h\"\n#include \"nvim/types.h\"\n#include \"nvim/event/loop.h\"\n#include \"nvim/os/os_defs.h\"\n\n#define IOSIZE         (1024+1)          // file I/O and sprintf buffer size\n\n# define MSG_BUF_LEN 480                 // length of buffer for small messages\n# define MSG_BUF_CLEN  (MSG_BUF_LEN / 6) // cell length (worst case: utf-8\n                                         // takes 6 bytes for one cell)\n\n#ifdef WIN32\n# define _PATHSEPSTR \"\\\\\"\n#else\n# define _PATHSEPSTR \"/\"\n#endif\n\n#ifndef FILETYPE_FILE\n# define FILETYPE_FILE  \"filetype.vim\"\n#endif\n\n#ifndef FTPLUGIN_FILE\n# define FTPLUGIN_FILE  \"ftplugin.vim\"\n#endif\n\n#ifndef INDENT_FILE\n# define INDENT_FILE    \"indent.vim\"\n#endif\n\n#ifndef FTOFF_FILE\n# define FTOFF_FILE     \"ftoff.vim\"\n#endif\n\n#ifndef FTPLUGOF_FILE\n# define FTPLUGOF_FILE  \"ftplugof.vim\"\n#endif\n\n#ifndef INDOFF_FILE\n# define INDOFF_FILE    \"indoff.vim\"\n#endif\n\n#define DFLT_ERRORFILE  \"errors.err\"\n\n#ifndef SYS_VIMRC_FILE\n# define SYS_VIMRC_FILE \"$VIM\" _PATHSEPSTR \"sysinit.vim\"\n#endif\n\n#ifndef DFLT_HELPFILE\n# define DFLT_HELPFILE  \"$VIMRUNTIME\" _PATHSEPSTR \"doc\" _PATHSEPSTR \"help.txt\"\n#endif\n\n#ifndef SYNTAX_FNAME\n# define SYNTAX_FNAME   \"$VIMRUNTIME\" _PATHSEPSTR \"syntax\" _PATHSEPSTR \"%s.vim\"\n#endif\n\n#ifndef EXRC_FILE\n# define EXRC_FILE      \".exrc\"\n#endif\n\n#ifndef VIMRC_FILE\n# define VIMRC_FILE     \".nvimrc\"\n#endif\n\nEXTERN struct nvim_stats_s {\n  int64_t fsync;\n  int64_t redraw;\n} g_stats INIT(= { 0, 0 });\n\n// Values for \"starting\".\n#define NO_SCREEN       2       // no screen updating yet\n#define NO_BUFFERS      1       // not all buffers loaded yet\n//                      0          not starting anymore\n\n// Number of Rows and Columns in the screen.\n// Note: Use default_grid.Rows and default_grid.Columns to access items in\n// default_grid.chars[]. They may have different values when the screen\n// wasn't (re)allocated yet after setting Rows or Columns (e.g., when starting\n// up).\n#define DFLT_COLS       80              // default value for 'columns'\n#define DFLT_ROWS       24              // default value for 'lines'\nEXTERN int Rows INIT(= DFLT_ROWS);     // nr of rows in the screen\nEXTERN int Columns INIT(= DFLT_COLS);  // nr of columns in the screen\n\nEXTERN NS ns_hl_active INIT(= 0);         // current ns that defines highlights\nEXTERN bool ns_hl_changed INIT(= false);  // highlight need update\n\n\n// We use 64-bit file functions here, if available.  E.g. ftello() returns\n// off_t instead of long, which helps if long is 32 bit and off_t is 64 bit.\n// We assume that when fseeko() is available then ftello() is too.\n// Note that Windows has different function names.\n#if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)\ntypedef __int64 off_T;\n# ifdef __MINGW32__\n#  define vim_lseek lseek64\n#  define vim_fseek fseeko64\n#  define vim_ftell ftello64\n# else\n#  define vim_lseek _lseeki64\n#  define vim_fseek _fseeki64\n#  define vim_ftell _ftelli64\n# endif\n#else\ntypedef off_t off_T;\n# ifdef HAVE_FSEEKO\n#  define vim_lseek lseek\n#  define vim_ftell ftello\n#  define vim_fseek fseeko\n# else\n#  define vim_lseek lseek\n#  define vim_ftell ftell\n#  define vim_fseek(a, b, c) fseek(a, (long)b, c)\n# endif\n#endif\n\n// When vgetc() is called, it sets mod_mask to the set of modifiers that are\n// held down based on the MOD_MASK_* symbols that are read first.\nEXTERN int mod_mask INIT(= 0x0);  // current key modifiers\n\n\n// Cmdline_row is the row where the command line starts, just below the\n// last window.\n// When the cmdline gets longer than the available space the screen gets\n// scrolled up. After a CTRL-D (show matches), after hitting ':' after\n// \"hit return\", and for the :global command, the command line is\n// temporarily moved.  The old position is restored with the next call to\n// update_screen().\nEXTERN int cmdline_row;\n\nEXTERN bool redraw_cmdline INIT(= false);          // cmdline must be redrawn\nEXTERN bool clear_cmdline INIT(= false);           // cmdline must be cleared\nEXTERN bool mode_displayed INIT(= false);          // mode is being displayed\nEXTERN int cmdline_star INIT(= false);             // cmdline is encrypted\nEXTERN bool redrawing_cmdline INIT(= false);       // cmdline is being redrawn\nEXTERN bool cmdline_was_last_drawn INIT(= false);  // cmdline was last drawn\n\nEXTERN bool exec_from_reg INIT(= false);         // executing register\n\n// When '$' is included in 'cpoptions' option set:\n// When a change command is given that deletes only part of a line, a dollar\n// is put at the end of the changed text. dollar_vcol is set to the virtual\n// column of this '$'.  -1 is used to indicate no $ is being displayed.\nEXTERN colnr_T dollar_vcol INIT(= -1);\n\n// Variables for Insert mode completion.\n\n// Length in bytes of the text being completed (this is deleted to be replaced\n// by the match.)\nEXTERN int compl_length INIT(= 0);\n\n// Set when character typed while looking for matches and it means we should\n// stop looking for matches.\nEXTERN int compl_interrupted INIT(= false);\n\n// Set when doing something for completion that may call edit() recursively,\n// which is not allowed. Also used to disable folding during completion\nEXTERN bool compl_busy INIT(= false);\n\n// List of flags for method of completion.\nEXTERN int compl_cont_status INIT(= 0);\n# define CONT_ADDING    1       // \"normal\" or \"adding\" expansion\n# define CONT_INTRPT   (2 + 4)  // a ^X interrupted the current expansion\n                                // it's set only iff N_ADDS is set\n# define CONT_N_ADDS    4       // next ^X<> will add-new or expand-current\n# define CONT_S_IPOS    8       // next ^X<> will set initial_pos?\n                                // if so, word-wise-expansion will set SOL\n# define CONT_SOL       16      // pattern includes start of line, just for\n                                // word-wise expansion, not set for ^X^L\n# define CONT_LOCAL     32      // for ctrl_x_mode 0, ^X^P/^X^N do a local\n                                // expansion, (eg use complete=.)\n\nEXTERN char_u *edit_submode INIT(= NULL);        // msg for CTRL-X submode\nEXTERN char_u *edit_submode_pre INIT(= NULL);    // prepended to edit_submode\nEXTERN char_u *edit_submode_extra INIT(= NULL);  // appended to edit_submode\nEXTERN hlf_T edit_submode_highl;                 // highl. method for extra info\n\n// state for putting characters in the message area\nEXTERN int cmdmsg_rl INIT(= false);  // cmdline is drawn right to left\nEXTERN int msg_col;\nEXTERN int msg_row;\nEXTERN int msg_scrolled;        // Number of screen lines that windows have\n                                // scrolled because of printing messages.\n// when true don't set need_wait_return in msg_puts_attr()\n// when msg_scrolled is non-zero\nEXTERN bool msg_scrolled_ign INIT(= false);\n// Whether the screen is damaged due to scrolling. Sometimes msg_scrolled\n// is reset before the screen is redrawn, so we need to keep track of this.\nEXTERN bool msg_did_scroll INIT(= false);\n\n\nEXTERN char_u *keep_msg INIT(= NULL);       // msg to be shown after redraw\nEXTERN int keep_msg_attr INIT(= 0);         // highlight attr for keep_msg\nEXTERN bool keep_msg_more INIT(= false);    // keep_msg was set by msgmore()\nEXTERN bool need_fileinfo INIT(= false);    // do fileinfo() after redraw\nEXTERN int msg_scroll INIT(= false);        // msg_start() will scroll\nEXTERN bool msg_didout INIT(= false);       // msg_outstr() was used in line\nEXTERN bool msg_didany INIT(= false);       // msg_outstr() was used at all\nEXTERN bool msg_nowait INIT(= false);       // don't wait for this msg\nEXTERN int emsg_off INIT(= 0);              // don't display errors for now,\n                                            // unless 'debug' is set.\nEXTERN bool info_message INIT(= false);     // printing informative message\nEXTERN bool msg_hist_off INIT(= false);     // don't add messages to history\nEXTERN bool need_clr_eos INIT(= false);     // need to clear text before\n                                            // displaying a message.\nEXTERN int emsg_skip INIT(= 0);             // don't display errors for\n                                            // expression that is skipped\nEXTERN bool emsg_severe INIT(= false);      // use message of next of several\n                                            //  emsg() calls for throw\nEXTERN bool did_endif INIT(= false);        // just had \":endif\"\nEXTERN dict_T vimvardict;                   // Dictionary with v: variables\nEXTERN dict_T globvardict;                  // Dictionary with g: variables\n/// g: value\n#define globvarht globvardict.dv_hashtab\nEXTERN int did_emsg;                        // set by emsg() when the message\n                                            // is displayed or thrown\nEXTERN bool called_vim_beep;                // set if vim_beep() is called\nEXTERN bool did_emsg_syntax;                // did_emsg set because of a\n                                            // syntax error\nEXTERN int called_emsg;                     // always set by emsg()\nEXTERN int ex_exitval INIT(= 0);            // exit value for ex mode\nEXTERN bool emsg_on_display INIT(= false);  // there is an error message\nEXTERN bool rc_did_emsg INIT(= false);      // vim_regcomp() called emsg()\n\nEXTERN int no_wait_return INIT(= 0);         // don't wait for return for now\nEXTERN bool need_wait_return INIT(= false);  // need to wait for return later\nEXTERN bool did_wait_return INIT(= false);   // wait_return() was used and\n                                             // nothing written since then\nEXTERN bool need_maketitle INIT(= true);     // call maketitle() soon\n\nEXTERN int quit_more INIT(= false);         // 'q' hit at \"--more--\" msg\nEXTERN int vgetc_busy INIT(= 0);            // when inside vgetc() then > 0\n\nEXTERN bool didset_vim INIT(= false);         // did set $VIM ourselves\nEXTERN bool didset_vimruntime INIT(= false);  // idem for $VIMRUNTIME\n\n/// Lines left before a \"more\" message.  Ex mode needs to be able to reset this\n/// after you type something.\nEXTERN int lines_left INIT(= -1);           // lines left for listing\nEXTERN int msg_no_more INIT(= false);       // don't use more prompt, truncate\n                                            // messages\n\nEXTERN char_u *sourcing_name INIT(= NULL);  // name of error message source\nEXTERN linenr_T sourcing_lnum INIT(= 0);    // line number of the source file\n\nEXTERN int ex_nesting_level INIT(= 0);          // nesting level\nEXTERN int debug_break_level INIT(= -1);        // break below this level\nEXTERN bool debug_did_msg INIT(= false);        // did \"debug mode\" message\nEXTERN int debug_tick INIT(= 0);                // breakpoint change count\nEXTERN int debug_backtrace_level INIT(= 0);     // breakpoint backtrace level\n\n// Values for \"do_profiling\".\n#define PROF_NONE       0       ///< profiling not started\n#define PROF_YES        1       ///< profiling busy\n#define PROF_PAUSED     2       ///< profiling paused\nEXTERN int do_profiling INIT(= PROF_NONE);      ///< PROF_ values\n\n/// Exception currently being thrown.  Used to pass an exception to a different\n/// cstack.  Also used for discarding an exception before it is caught or made\n/// pending.\nEXTERN except_T *current_exception;\n\n/// Set when a throw that cannot be handled in do_cmdline() must be propagated\n/// to the cstack of the previously called do_cmdline().\nEXTERN int need_rethrow INIT(= false);\n\n/// Set when a \":finish\" or \":return\" that cannot be handled in do_cmdline()\n/// must be propagated to the cstack of the previously called do_cmdline().\nEXTERN int check_cstack INIT(= false);\n\n/// Number of nested try conditionals (across function calls and \":source\"\n/// commands).\nEXTERN int trylevel INIT(= 0);\n\n/// When \"force_abort\" is true, always skip commands after an error message,\n/// even after the outermost \":endif\", \":endwhile\" or \":endfor\" or for a\n/// function without the \"abort\" flag.  It is set to true when \"trylevel\" is\n/// non-zero (and \":silent!\" was not used) or an exception is being thrown at\n/// the time an error is detected.  It is set to false when \"trylevel\" gets\n/// zero again and there was no error or interrupt or throw.\nEXTERN int force_abort INIT(= false);\n\n/// \"msg_list\" points to a variable in the stack of do_cmdline() which keeps\n/// the list of arguments of several emsg() calls, one of which is to be\n/// converted to an error exception immediately after the failing command\n/// returns.  The message to be used for the exception value is pointed to by\n/// the \"throw_msg\" field of the first element in the list.  It is usually the\n/// same as the \"msg\" field of that element, but can be identical to the \"msg\"\n/// field of a later list element, when the \"emsg_severe\" flag was set when the\n/// emsg() call was made.\nEXTERN struct msglist **msg_list INIT(= NULL);\n\n/// When set, don't convert an error to an exception.  Used when displaying the\n/// interrupt message or reporting an exception that is still uncaught at the\n/// top level (which has already been discarded then).  Also used for the error\n/// message when no exception can be thrown.\nEXTERN bool suppress_errthrow INIT(= false);\n\n/// The stack of all caught and not finished exceptions.  The exception on the\n/// top of the stack is the one got by evaluation of v:exception.  The complete\n/// stack of all caught and pending exceptions is embedded in the various\n/// cstacks; the pending exceptions, however, are not on the caught stack.\nEXTERN except_T *caught_stack INIT(= NULL);\n\n\n///\n/// Garbage collection can only take place when we are sure there are no Lists\n/// or Dictionaries being used internally.  This is flagged with\n/// \"may_garbage_collect\" when we are at the toplevel.\n/// \"want_garbage_collect\" is set by the garbagecollect() function, which means\n/// we do garbage collection before waiting for a char at the toplevel.\n/// \"garbage_collect_at_exit\" indicates garbagecollect(1) was called.\n///\nEXTERN bool may_garbage_collect INIT(= false);\nEXTERN int want_garbage_collect INIT(= false);\nEXTERN int garbage_collect_at_exit INIT(= false);\n\n// Special values for current_SID.\n#define SID_MODELINE    -1      // when using a modeline\n#define SID_CMDARG      -2      // for \"--cmd\" argument\n#define SID_CARG        -3      // for \"-c\" argument\n#define SID_ENV         -4      // for sourcing environment variable\n#define SID_ERROR       -5      // option was reset because of an error\n#define SID_NONE        -6      // don't set scriptID\n#define SID_WINLAYOUT   -7      // changing window size\n#define SID_LUA         -8      // for Lua scripts/chunks\n#define SID_API_CLIENT  -9      // for API clients\n#define SID_STR         -10     // for sourcing a string\n\n// Script CTX being sourced or was sourced to define the current function.\nEXTERN sctx_T current_sctx INIT(= { 0 COMMA 0 COMMA 0 });\n// ID of the current channel making a client API call\nEXTERN uint64_t current_channel_id INIT(= 0);\n\nEXTERN bool did_source_packages INIT(= false);\n\n// Scope information for the code that indirectly triggered the current\n// provider function call\nEXTERN struct caller_scope {\n  sctx_T script_ctx;\n  uint8_t *sourcing_name, *autocmd_fname, *autocmd_match;\n  linenr_T sourcing_lnum;\n  int autocmd_bufnr;\n  void *funccalp;\n} provider_caller_scope;\nEXTERN int provider_call_nesting INIT(= 0);\n\n\nEXTERN int t_colors INIT(= 256);                // int value of T_CCO\n\n// When highlight_match is true, highlight a match, starting at the cursor\n// position.  Search_match_lines is the number of lines after the match (0 for\n// a match within one line), search_match_endcol the column number of the\n// character just after the match in the last line.\nEXTERN bool highlight_match INIT(= false);         // show search match pos\nEXTERN linenr_T search_match_lines;                // lines of of matched string\nEXTERN colnr_T search_match_endcol;                // col nr of match end\nEXTERN linenr_T search_first_line INIT(= 0);       // for :{FIRST},{last}s/pat\nEXTERN linenr_T search_last_line INIT(= MAXLNUM);  // for :{first},{LAST}s/pat\n\nEXTERN bool no_smartcase INIT(= false);          // don't use 'smartcase' once\n\nEXTERN int need_check_timestamps INIT(= false);  // need to check file\n                                                 // timestamps asap\nEXTERN int did_check_timestamps INIT(= false);   // did check timestamps\n                                                 // recently\nEXTERN int no_check_timestamps INIT(= 0);        // Don't check timestamps\n\nEXTERN int autocmd_busy INIT(= false);           // Is apply_autocmds() busy?\nEXTERN int autocmd_no_enter INIT(= false);       // *Enter autocmds disabled\nEXTERN int autocmd_no_leave INIT(= false);       // *Leave autocmds disabled\nEXTERN int modified_was_set;                     // did \":set modified\"\nEXTERN int did_filetype INIT(= false);           // FileType event found\n// value for did_filetype when starting to execute autocommands\nEXTERN int keep_filetype INIT(= false);\n\n// When deleting the current buffer, another one must be loaded.\n// If we know which one is preferred, au_new_curbuf is set to it.\nEXTERN bufref_T au_new_curbuf INIT(= { NULL, 0, 0 });\n\n// When deleting a buffer/window and autocmd_busy is true, do not free the\n// buffer/window. but link it in the list starting with\n// au_pending_free_buf/ap_pending_free_win, using b_next/w_next.\n// Free the buffer/window when autocmd_busy is being set to false.\nEXTERN buf_T *au_pending_free_buf INIT(= NULL);\nEXTERN win_T *au_pending_free_win INIT(= NULL);\n\n// Mouse coordinates, set by handle_mouse_event()\nEXTERN int mouse_grid;\nEXTERN int mouse_row;\nEXTERN int mouse_col;\nEXTERN bool mouse_past_bottom INIT(= false);  // mouse below last line\nEXTERN bool mouse_past_eol INIT(= false);     // mouse right of line\nEXTERN int mouse_dragging INIT(= 0);          // extending Visual area with\n                                              // mouse dragging\n\n// The root of the menu hierarchy.\nEXTERN vimmenu_T        *root_menu INIT(= NULL);\n// While defining the system menu, sys_menu is true.  This avoids\n// overruling of menus that the user already defined.\nEXTERN int sys_menu INIT(= false);\n\n// While redrawing the screen this flag is set.  It means the screen size\n// ('lines' and 'rows') must not be changed.\nEXTERN int updating_screen INIT(= 0);\n\n// All windows are linked in a list. firstwin points to the first entry,\n// lastwin to the last entry (can be the same as firstwin) and curwin to the\n// currently active window.\nEXTERN win_T    *firstwin;              // first window\nEXTERN win_T    *lastwin;               // last window\nEXTERN win_T    *prevwin INIT(= NULL);  // previous window\n# define ONE_WINDOW (firstwin == lastwin)\n# define FOR_ALL_FRAMES(frp, first_frame) \\\n  for (frp = first_frame; frp != NULL; frp = frp->fr_next)  // NOLINT\n\n// When using this macro \"break\" only breaks out of the inner loop. Use \"goto\"\n// to break out of the tabpage loop.\n# define FOR_ALL_TAB_WINDOWS(tp, wp) \\\n  FOR_ALL_TABS(tp) \\\n    FOR_ALL_WINDOWS_IN_TAB(wp, tp)\n\n// -V:FOR_ALL_WINDOWS_IN_TAB:501\n# define FOR_ALL_WINDOWS_IN_TAB(wp, tp) \\\n  for (win_T *wp = ((tp) == curtab) \\\n              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)\n\nEXTERN win_T    *curwin;        // currently active window\n\nEXTERN win_T    *aucmd_win;     // window used in aucmd_prepbuf()\nEXTERN int aucmd_win_used INIT(= false);  // aucmd_win is being used\n\n// The window layout is kept in a tree of frames.  topframe points to the top\n// of the tree.\nEXTERN frame_T  *topframe;      // top of the window frame tree\n\n// Tab pages are alternative topframes.  \"first_tabpage\" points to the first\n// one in the list, \"curtab\" is the current one.\nEXTERN tabpage_T    *first_tabpage;\nEXTERN tabpage_T    *lastused_tabpage;\nEXTERN tabpage_T    *curtab;\nEXTERN bool redraw_tabline INIT(= false);  // need to redraw tabline\n\n// Iterates over all tabs in the tab list\n# define FOR_ALL_TABS(tp) for (tabpage_T *tp = first_tabpage; tp != NULL; tp = tp->tp_next)\n\n// All buffers are linked in a list. 'firstbuf' points to the first entry,\n// 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.\nEXTERN buf_T    *firstbuf INIT(= NULL);  // first buffer\nEXTERN buf_T    *lastbuf INIT(= NULL);   // last buffer\nEXTERN buf_T    *curbuf INIT(= NULL);    // currently active buffer\n\n// Iterates over all buffers in the buffer list.\n#define FOR_ALL_BUFFERS(buf) \\\n  for (buf_T *buf = firstbuf; buf != NULL; buf = buf->b_next)\n#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\\n  for (buf_T *buf = lastbuf; buf != NULL; buf = buf->b_prev)\n\n// Iterate through all the signs placed in a buffer\n#define FOR_ALL_SIGNS_IN_BUF(buf, sign) \\\n  for (sign = buf->b_signlist; sign != NULL; sign = sign->se_next)   // NOLINT\n\n\n// List of files being edited (global argument list).  curwin->w_alist points\n// to this when the window is using the global argument list.\nEXTERN alist_T global_alist;    // global argument list\nEXTERN int max_alist_id INIT(= 0);     ///< the previous argument list id\nEXTERN bool arg_had_last INIT(= false);     // accessed last file in\n                                            // global_alist\n\nEXTERN int ru_col;              // column for ruler\nEXTERN int ru_wid;              // 'rulerfmt' width of ruler when non-zero\nEXTERN int sc_col;              // column for shown command\n\n// When starting or exiting some things are done differently (e.g. screen\n// updating).\n\n// First NO_SCREEN, then NO_BUFFERS, then 0 when startup finished.\nEXTERN int starting INIT(= NO_SCREEN);\n// true when planning to exit. Might keep running if there is a changed buffer.\nEXTERN bool exiting INIT(= false);\n// internal value of v:dying\nEXTERN int v_dying INIT(= 0);\n// is stdin a terminal?\nEXTERN int stdin_isatty INIT(= true);\n// is stdout a terminal?\nEXTERN int stdout_isatty INIT(= true);\n// true when doing full-screen output, otherwise only writing some messages.\n// volatile because it is used in a signal handler.\nEXTERN volatile int full_screen INIT(= false);\n\n/// Non-zero when only \"safe\" commands are allowed, e.g. when sourcing .exrc or\n/// .vimrc in current directory.\nEXTERN int secure INIT(= 0);\n\n/// Non-zero when changing text and jumping to another window/buffer is not\n/// allowed.\nEXTERN int textlock INIT(= 0);\n\n/// Non-zero when no buffer name can be changed, no buffer can be deleted and\n/// current directory can't be changed. Used for SwapExists et al.\nEXTERN int allbuf_lock INIT(= 0);\n\n/// Non-zero when evaluating an expression in a \"sandbox\".  Several things are\n/// not allowed then.\nEXTERN int sandbox INIT(= 0);\n\n/// Batch-mode: \"-es\" or \"-Es\" commandline argument was given.\nEXTERN int silent_mode INIT(= false);\n\n/// Start position of active Visual selection.\nEXTERN pos_T VIsual;\n/// Whether Visual mode is active.\nEXTERN int VIsual_active INIT(= false);\n/// Whether Select mode is active.\nEXTERN int VIsual_select INIT(= false);\n/// Restart Select mode when next cmd finished\nEXTERN int restart_VIsual_select INIT(= 0);\n/// Whether to restart the selection after a Select-mode mapping or menu.\nEXTERN int VIsual_reselect;\n/// Type of Visual mode.\nEXTERN int VIsual_mode INIT(= 'v');\n/// true when redoing Visual.\nEXTERN int redo_VIsual_busy INIT(= false);\n\n/// When pasting text with the middle mouse button in visual mode with\n/// restart_edit set, remember where it started so we can set Insstart.\nEXTERN pos_T where_paste_started;\n\n// This flag is used to make auto-indent work right on lines where only a\n// <RETURN> or <ESC> is typed. It is set when an auto-indent is done, and\n// reset when any other editing is done on the line. If an <ESC> or <RETURN>\n// is received, and did_ai is true, the line is truncated.\nEXTERN bool did_ai INIT(= false);\n\n// Column of first char after autoindent.  0 when no autoindent done.  Used\n// when 'backspace' is 0, to avoid backspacing over autoindent.\nEXTERN colnr_T ai_col INIT(= 0);\n\n// This is a character which will end a start-middle-end comment when typed as\n// the first character on a new line.  It is taken from the last character of\n// the \"end\" comment leader when the COM_AUTO_END flag is given for that\n// comment end in 'comments'.  It is only valid when did_ai is true.\nEXTERN int end_comment_pending INIT(= NUL);\n\n// This flag is set after a \":syncbind\" to let the check_scrollbind() function\n// know that it should not attempt to perform scrollbinding due to the scroll\n// that was a result of the \":syncbind.\" (Otherwise, check_scrollbind() will\n// undo some of the work done by \":syncbind.\")  -ralston\nEXTERN bool did_syncbind INIT(= false);\n\n// This flag is set when a smart indent has been performed. When the next typed\n// character is a '{' the inserted tab will be deleted again.\nEXTERN bool did_si INIT(= false);\n\n// This flag is set after an auto indent. If the next typed character is a '}'\n// one indent will be removed.\nEXTERN bool can_si INIT(= false);\n\n// This flag is set after an \"O\" command. If the next typed character is a '{'\n// one indent will be removed.\nEXTERN bool can_si_back INIT(= false);\n\n// w_cursor before formatting text.\nEXTERN pos_T saved_cursor INIT(= { 0, 0, 0 });\n\n// Stuff for insert mode.\nEXTERN pos_T Insstart;                  // This is where the latest\n                                        // insert/append mode started.\n\n// This is where the latest insert/append mode started. In contrast to\n// Insstart, this won't be reset by certain keys and is needed for\n// op_insert(), to detect correctly where inserting by the user started.\nEXTERN pos_T Insstart_orig;\n\n// Stuff for VREPLACE mode.\nEXTERN int orig_line_count INIT(= 0);       // Line count when \"gR\" started\nEXTERN int vr_lines_changed INIT(= 0);      // #Lines changed by \"gR\" so far\n\n// increase around internal delete/replace\nEXTERN int inhibit_delete_count INIT(= 0);\n\n// These flags are set based upon 'fileencoding'.\n// The characters are internally stored as UTF-8\n// to avoid trouble with NUL bytes.\n# define DBCS_JPN       932     // japan\n# define DBCS_JPNU      9932    // euc-jp\n# define DBCS_KOR       949     // korea\n# define DBCS_KORU      9949    // euc-kr\n# define DBCS_CHS       936     // chinese\n# define DBCS_CHSU      9936    // euc-cn\n# define DBCS_CHT       950     // taiwan\n# define DBCS_CHTU      9950    // euc-tw\n# define DBCS_2BYTE     1       // 2byte-\n# define DBCS_DEBUG     -1\n\n/// Encoding used when 'fencs' is set to \"default\"\nEXTERN char_u *fenc_default INIT(= NULL);\n\n/// \"State\" is the main state of Vim.\n/// There are other variables that modify the state:\n///    Visual_mode:    When State is NORMAL or INSERT.\n///    finish_op  :    When State is NORMAL, after typing the operator and\n///                    before typing the motion command.\n///    motion_force:   Last motion_force from do_pending_operator()\n///    debug_mode:     Debug mode\nEXTERN int State INIT(= NORMAL);        // This is the current state of the\n                                        // command interpreter.\nEXTERN bool debug_mode INIT(= false);\nEXTERN bool finish_op INIT(= false);    // true while an operator is pending\nEXTERN long opcount INIT(= 0);          // count for pending operator\nEXTERN int motion_force INIT(=0);       // motion force for pending operator\n\n// Ex Mode (Q) state\nEXTERN bool exmode_active INIT(= false);  // true if Ex mode is active\nEXTERN bool ex_no_reprint INIT(=false);   // No need to print after z or p.\n\nEXTERN int reg_recording INIT(= 0);     // register for recording  or zero\nEXTERN int reg_executing INIT(= 0);     // register being executed or zero\n\nEXTERN int no_mapping INIT(= false);    // currently no mapping allowed\nEXTERN int no_zero_mapping INIT(= 0);   // mapping zero not allowed\nEXTERN int no_u_sync INIT(= 0);         // Don't call u_sync()\nEXTERN int u_sync_once INIT(= 0);       // Call u_sync() once when evaluating\n                                        // an expression.\n\nEXTERN bool force_restart_edit INIT(= false);  // force restart_edit after\n                                               // ex_normal returns\nEXTERN int restart_edit INIT(= 0);      // call edit when next cmd finished\nEXTERN int arrow_used;                  // Normally false, set to true after\n                                        // hitting cursor key in insert mode.\n                                        // Used by vgetorpeek() to decide when\n                                        // to call u_sync()\nEXTERN bool ins_at_eol INIT(= false);   // put cursor after eol when\n                                        // restarting edit after CTRL-O\n\nEXTERN bool no_abbr INIT(= true);       // true when no abbreviations loaded\n\nEXTERN int mapped_ctrl_c INIT(= 0);  // Modes where CTRL-C is mapped.\n\nEXTERN cmdmod_T cmdmod;                 // Ex command modifiers\n\nEXTERN int msg_silent INIT(= 0);         // don't print messages\nEXTERN int emsg_silent INIT(= 0);        // don't print error messages\nEXTERN bool emsg_noredir INIT(= false);  // don't redirect error messages\nEXTERN bool cmd_silent INIT(= false);    // don't echo the command line\n\n// Values for swap_exists_action: what to do when swap file already exists\n#define SEA_NONE        0       // don't use dialog\n#define SEA_DIALOG      1       // use dialog when possible\n#define SEA_QUIT        2       // quit editing the file\n#define SEA_RECOVER     3       // recover the file\n\nEXTERN int swap_exists_action INIT(= SEA_NONE);\n// For dialog when swap file already\n// exists.\nEXTERN bool swap_exists_did_quit INIT(= false);\n// Selected \"quit\" at the dialog.\n\nEXTERN char_u IObuff[IOSIZE];               ///< Buffer for sprintf, I/O, etc.\nEXTERN char_u NameBuff[MAXPATHL];           ///< Buffer for expanding file names\nEXTERN char_u msg_buf[MSG_BUF_LEN];         ///< Small buffer for messages\nEXTERN char os_buf[                         ///< Buffer for the os/ layer\n#if MAXPATHL > IOSIZE\nMAXPATHL\n#else\nIOSIZE\n#endif\n];\n\n// When non-zero, postpone redrawing.\nEXTERN int RedrawingDisabled INIT(= 0);\n\nEXTERN int readonlymode INIT(= false);      // Set to true for \"view\"\nEXTERN int recoverymode INIT(= false);      // Set to true for \"-r\" option\n\n// typeahead buffer\nEXTERN typebuf_T typebuf INIT(= { NULL, NULL, 0, 0, 0, 0, 0, 0, 0 });\n\nEXTERN int ex_normal_busy INIT(= 0);     // recursiveness of ex_normal()\nEXTERN int ex_normal_lock INIT(= 0);     // forbid use of ex_normal()\nEXTERN int ignore_script INIT(= false);  // ignore script input\nEXTERN int stop_insert_mode;             // for \":stopinsert\" and 'insertmode'\nEXTERN bool KeyTyped;                    // true if user typed current char\nEXTERN int KeyStuffed;                   // true if current char from stuffbuf\nEXTERN int maptick INIT(= 0);            // tick for each non-mapped char\n\nEXTERN int must_redraw INIT(= 0);           // type of redraw necessary\nEXTERN bool skip_redraw INIT(= false);      // skip redraw once\nEXTERN bool do_redraw INIT(= false);        // extra redraw once\nEXTERN bool must_redraw_pum INIT(= false);  // redraw pum. NB: must_redraw\n                                            // should also be set.\n\nEXTERN bool need_highlight_changed INIT(= true);\n\nEXTERN FILE *scriptout INIT(= NULL);  ///< Stream to write script to.\n\n// volatile because it is used in a signal handler.\nEXTERN volatile int got_int INIT(= false);  // set to true when interrupt\n                                            // signal occurred\nEXTERN bool bangredo INIT(= false);         // set to true with ! command\nEXTERN int searchcmdlen;                    // length of previous search cmd\nEXTERN int reg_do_extmatch INIT(= 0);       // Used when compiling regexp:\n                                            // REX_SET to allow \\z\\(...\\),\n                                            // REX_USE to allow \\z\\1 et al.\n// Used by vim_regexec(): strings for \\z\\1...\\z\\9\nEXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL);\n// Set by vim_regexec() to store \\z\\(...\\) matches\nEXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL);\n\nEXTERN bool did_outofmem_msg INIT(= false);\n// set after out of memory msg\nEXTERN bool did_swapwrite_msg INIT(= false);\n// set after swap write error msg\nEXTERN int global_busy INIT(= 0);           // set when :global is executing\nEXTERN bool listcmd_busy INIT(= false);     // set when :argdo, :windo or\n                                            // :bufdo is executing\nEXTERN bool need_start_insertmode INIT(= false);\n// start insert mode soon\nEXTERN char_u *last_cmdline INIT(= NULL);      // last command line (for \":)\nEXTERN char_u *repeat_cmdline INIT(= NULL);    // command line for \".\"\nEXTERN char_u *new_last_cmdline INIT(= NULL);  // new value for last_cmdline\nEXTERN char_u *autocmd_fname INIT(= NULL);     // fname for <afile> on cmdline\nEXTERN int autocmd_bufnr INIT(= 0);            // fnum for <abuf> on cmdline\nEXTERN char_u *autocmd_match INIT(= NULL);     // name for <amatch> on cmdline\nEXTERN bool did_cursorhold INIT(= false);      // set when CursorHold t'gerd\n\nEXTERN int postponed_split INIT(= 0);        // for CTRL-W CTRL-] command\nEXTERN int postponed_split_flags INIT(= 0);  // args for win_split()\nEXTERN int postponed_split_tab INIT(= 0);    // cmdmod.tab\nEXTERN int g_do_tagpreview INIT(= 0);  // for tag preview commands:\n                                       // height of preview window\nEXTERN bool g_tag_at_cursor INIT(= false);  // whether the tag command comes\n                                            // from the command line (0) or was\n                                            // invoked as a normal command (1)\n\nEXTERN int replace_offset INIT(= 0);        // offset for replace_push()\n\nEXTERN char_u   *escape_chars INIT(= (char_u *)\" \\t\\\\\\\"|\");\n// need backslash in cmd line\n\nEXTERN int keep_help_flag INIT(= false);  // doing :ta from help file\n\n// When a string option is NULL (which only happens in out-of-memory\n// situations), it is set to empty_option, to avoid having to check for NULL\n// everywhere.\nEXTERN char_u   *empty_option INIT(= (char_u *)\"\");\n\nEXTERN bool redir_off INIT(= false);        // no redirection for a moment\nEXTERN FILE *redir_fd INIT(= NULL);         // message redirection file\nEXTERN int redir_reg INIT(= 0);             // message redirection register\nEXTERN int redir_vname INIT(= 0);           // message redirection variable\nEXTERN garray_T *capture_ga INIT(= NULL);   // captured output for execute()\n\nEXTERN char_u langmap_mapchar[256];     // mapping for language keys\n\nEXTERN int save_p_ls INIT(= -1);        // Save 'laststatus' setting\nEXTERN int save_p_wmh INIT(= -1);       // Save 'winminheight' setting\nEXTERN int wild_menu_showing INIT(= 0);\nenum {\n  WM_SHOWN = 1,     ///< wildmenu showing\n  WM_SCROLLED = 2,  ///< wildmenu showing with scroll\n  WM_LIST = 3,      ///< cmdline CTRL-D\n};\n\n\n// Some file names are stored in pathdef.c, which is generated from the\n// Makefile to make their value depend on the Makefile.\n#ifdef HAVE_PATHDEF\nextern char *default_vim_dir;\nextern char *default_vimruntime_dir;\nextern char *default_lib_dir;\nextern char_u *compiled_user;\nextern char_u *compiled_sys;\n#endif\n\n// When a window has a local directory, the absolute path of the global\n// current directory is stored here (in allocated memory).  If the current\n// directory is not a local directory, globaldir is NULL.\nEXTERN char_u   *globaldir INIT(= NULL);\n\n// Whether 'keymodel' contains \"stopsel\" and \"startsel\".\nEXTERN bool km_stopsel INIT(= false);\nEXTERN bool km_startsel INIT(= false);\n\nEXTERN int cedit_key INIT(= -1);     ///< key value of 'cedit' option\nEXTERN int cmdwin_type INIT(= 0);    ///< type of cmdline window or 0\nEXTERN int cmdwin_result INIT(= 0);  ///< result of cmdline window or 0\nEXTERN int cmdwin_level INIT(= 0);   ///< cmdline recursion level\n\nEXTERN char_u no_lines_msg[] INIT(= N_(\"--No lines in buffer--\"));\n\n// When \":global\" is used to number of substitutions and changed lines is\n// accumulated until it's finished.\n// Also used for \":spellrepall\".\nEXTERN long sub_nsubs;       // total number of substitutions\nEXTERN linenr_T sub_nlines;  // total number of lines changed\n\n// table to store parsed 'wildmode'\nEXTERN char_u wim_flags[4];\n\n// whether titlestring and iconstring contains statusline syntax\n# define STL_IN_ICON    1\n# define STL_IN_TITLE   2\nEXTERN int stl_syntax INIT(= 0);\n\n// don't use 'hlsearch' temporarily\nEXTERN bool no_hlsearch INIT(= false);\n\n// Page number used for %N in 'pageheader' and 'guitablabel'.\nEXTERN linenr_T printer_page_num;\n\n\nEXTERN bool typebuf_was_filled INIT(= false);     // received text from client\n                                                  // or from feedkeys()\n\n\n#ifdef BACKSLASH_IN_FILENAME\nEXTERN char psepc INIT(= '\\\\');            // normal path separator character\nEXTERN char psepcN INIT(= '/');            // abnormal path separator character\nEXTERN char pseps[2] INIT(= { '\\\\', 0 });  // normal path separator string\n#endif\n\n// Set to kTrue when an operator is being executed with virtual editing\n// kNone when no operator is being executed, kFalse otherwise.\nEXTERN TriState virtual_op INIT(= kNone);\n\n// Display tick, incremented for each call to update_screen()\nEXTERN disptick_T display_tick INIT(= 0);\n\n// Line in which spell checking wasn't highlighted because it touched the\n// cursor position in Insert mode.\nEXTERN linenr_T spell_redraw_lnum INIT(= 0);\n\n\n// The error messages that can be shared are included here.\n// Excluded are errors that are only used once and debugging messages.\nEXTERN char_u e_abort[] INIT(= N_(\"E470: Command aborted\"));\nEXTERN char_u e_afterinit[] INIT(= N_(\n        \"E905: Cannot set this option after startup\"));\nEXTERN char_u e_api_spawn_failed[] INIT(= N_(\"E903: Could not spawn API job\"));\nEXTERN char_u e_argreq[] INIT(= N_(\"E471: Argument required\"));\nEXTERN char_u e_backslash[] INIT(= N_(\"E10: \\\\ should be followed by /, ? or &\"));\nEXTERN char_u e_cmdwin[] INIT(= N_(\n        \"E11: Invalid in command-line window; <CR> executes, CTRL-C quits\"));\nEXTERN char_u e_curdir[] INIT(= N_(\n        \"E12: Command not allowed from exrc/vimrc in current dir or tag search\"));\nEXTERN char_u e_endif[] INIT(= N_(\"E171: Missing :endif\"));\nEXTERN char_u e_endtry[] INIT(= N_(\"E600: Missing :endtry\"));\nEXTERN char_u e_endwhile[] INIT(= N_(\"E170: Missing :endwhile\"));\nEXTERN char_u e_endfor[] INIT(= N_(\"E170: Missing :endfor\"));\nEXTERN char_u e_while[] INIT(= N_(\"E588: :endwhile without :while\"));\nEXTERN char_u e_for[] INIT(= N_(\"E588: :endfor without :for\"));\nEXTERN char_u e_exists[] INIT(= N_(\"E13: File exists (add ! to override)\"));\nEXTERN char_u e_failed[] INIT(= N_(\"E472: Command failed\"));\nEXTERN char_u e_internal[] INIT(= N_(\"E473: Internal error\"));\nEXTERN char_u e_intern2[] INIT(= N_(\"E685: Internal error: %s\"));\nEXTERN char_u e_interr[] INIT(= N_(\"Interrupted\"));\nEXTERN char_u e_invarg[] INIT(= N_(\"E474: Invalid argument\"));\nEXTERN char_u e_invarg2[] INIT(= N_(\"E475: Invalid argument: %s\"));\nEXTERN char_u e_invargval[] INIT(= N_(\"E475: Invalid value for argument %s\"));\nEXTERN char_u e_invargNval[] INIT(= N_(\n    \"E475: Invalid value for argument %s: %s\"));\nEXTERN char_u e_duparg2[] INIT(= N_(\"E983: Duplicate argument: %s\"));\nEXTERN char_u e_invexpr2[] INIT(= N_(\"E15: Invalid expression: %s\"));\nEXTERN char_u e_invrange[] INIT(= N_(\"E16: Invalid range\"));\nEXTERN char_u e_invcmd[] INIT(= N_(\"E476: Invalid command\"));\nEXTERN char_u e_isadir2[] INIT(= N_(\"E17: \\\"%s\\\" is a directory\"));\nEXTERN char_u e_no_spell[] INIT(= N_(\"E756: Spell checking is not possible\"));\nEXTERN char_u e_invchan[] INIT(= N_(\"E900: Invalid channel id\"));\nEXTERN char_u e_invchanjob[] INIT(= N_(\"E900: Invalid channel id: not a job\"));\nEXTERN char_u e_jobtblfull[] INIT(= N_(\"E901: Job table is full\"));\nEXTERN char_u e_jobspawn[] INIT(= N_(\n    \"E903: Process failed to start: %s: \\\"%s\\\"\"));\nEXTERN char_u e_channotpty[] INIT(= N_(\"E904: channel is not a pty\"));\nEXTERN char_u e_stdiochan2[] INIT(= N_(\n    \"E905: Couldn't open stdio channel: %s\"));\nEXTERN char_u e_invstream[] INIT(= N_(\"E906: invalid stream for channel\"));\nEXTERN char_u e_invstreamrpc[] INIT(= N_(\n    \"E906: invalid stream for rpc channel, use 'rpc'\"));\nEXTERN char_u e_streamkey[] INIT(= N_(\n    \"E5210: dict key '%s' already set for buffered stream in channel %\"\n    PRIu64));\nEXTERN char_u e_libcall[] INIT(= N_(\"E364: Library call failed for \\\"%s()\\\"\"));\nEXTERN char e_fsync[] INIT(= N_(\"E667: Fsync failed: %s\"));\nEXTERN char_u e_mkdir[] INIT(= N_(\"E739: Cannot create directory %s: %s\"));\nEXTERN char_u e_markinval[] INIT(= N_(\"E19: Mark has invalid line number\"));\nEXTERN char_u e_marknotset[] INIT(= N_(\"E20: Mark not set\"));\nEXTERN char_u e_modifiable[] INIT(= N_(\n        \"E21: Cannot make changes, 'modifiable' is off\"));\nEXTERN char_u e_nesting[] INIT(= N_(\"E22: Scripts nested too deep\"));\nEXTERN char_u e_noalt[] INIT(= N_(\"E23: No alternate file\"));\nEXTERN char_u e_noabbr[] INIT(= N_(\"E24: No such abbreviation\"));\nEXTERN char_u e_nobang[] INIT(= N_(\"E477: No ! allowed\"));\nEXTERN char_u e_nogroup[] INIT(= N_(\"E28: No such highlight group name: %s\"));\nEXTERN char_u e_noinstext[] INIT(= N_(\"E29: No inserted text yet\"));\nEXTERN char_u e_nolastcmd[] INIT(= N_(\"E30: No previous command line\"));\nEXTERN char_u e_nomap[] INIT(= N_(\"E31: No such mapping\"));\nEXTERN char_u e_nomatch[] INIT(= N_(\"E479: No match\"));\nEXTERN char_u e_nomatch2[] INIT(= N_(\"E480: No match: %s\"));\nEXTERN char_u e_noname[] INIT(= N_(\"E32: No file name\"));\nEXTERN char_u e_nopresub[] INIT(= N_(\n        \"E33: No previous substitute regular expression\"));\nEXTERN char_u e_noprev[] INIT(= N_(\"E34: No previous command\"));\nEXTERN char_u e_noprevre[] INIT(= N_(\"E35: No previous regular expression\"));\nEXTERN char_u e_norange[] INIT(= N_(\"E481: No range allowed\"));\nEXTERN char_u e_noroom[] INIT(= N_(\"E36: Not enough room\"));\nEXTERN char_u e_notmp[] INIT(= N_(\"E483: Can't get temp file name\"));\nEXTERN char_u e_notopen[] INIT(= N_(\"E484: Can't open file %s\"));\nEXTERN char_u e_notopen_2[] INIT(= N_(\"E484: Can't open file %s: %s\"));\nEXTERN char_u e_notread[] INIT(= N_(\"E485: Can't read file %s\"));\nEXTERN char_u e_null[] INIT(= N_(\"E38: Null argument\"));\nEXTERN char_u e_number_exp[] INIT(= N_(\"E39: Number expected\"));\nEXTERN char_u e_openerrf[] INIT(= N_(\"E40: Can't open errorfile %s\"));\nEXTERN char_u e_outofmem[] INIT(= N_(\"E41: Out of memory!\"));\nEXTERN char_u e_patnotf[] INIT(= N_(\"Pattern not found\"));\nEXTERN char_u e_patnotf2[] INIT(= N_(\"E486: Pattern not found: %s\"));\nEXTERN char_u e_positive[] INIT(= N_(\"E487: Argument must be positive\"));\nEXTERN char_u e_prev_dir[] INIT(= N_(\n        \"E459: Cannot go back to previous directory\"));\n\nEXTERN char_u e_quickfix[] INIT(= N_(\"E42: No Errors\"));\nEXTERN char_u e_loclist[] INIT(= N_(\"E776: No location list\"));\nEXTERN char_u e_re_damg[] INIT(= N_(\"E43: Damaged match string\"));\nEXTERN char_u e_re_corr[] INIT(= N_(\"E44: Corrupted regexp program\"));\nEXTERN char_u e_readonly[] INIT(= N_(\n    \"E45: 'readonly' option is set (add ! to override)\"));\nEXTERN char_u e_readonlyvar[] INIT(= N_(\n    \"E46: Cannot change read-only variable \\\"%.*s\\\"\"));\nEXTERN char_u e_stringreq[] INIT(= N_(\"E928: String required\"));\nEXTERN char_u e_dictreq[] INIT(= N_(\"E715: Dictionary required\"));\nEXTERN char_u e_toomanyarg[] INIT(= N_(\n    \"E118: Too many arguments for function: %s\"));\nEXTERN char_u e_dictkey[] INIT(= N_(\n    \"E716: Key not present in Dictionary: \\\"%s\\\"\"));\nEXTERN char_u e_listreq[] INIT(= N_(\"E714: List required\"));\nEXTERN char_u e_listdictarg[] INIT(= N_(\n    \"E712: Argument of %s must be a List or Dictionary\"));\nEXTERN char_u e_readerrf[] INIT(= N_(\"E47: Error while reading errorfile\"));\nEXTERN char_u e_sandbox[] INIT(= N_(\"E48: Not allowed in sandbox\"));\nEXTERN char_u e_secure[] INIT(= N_(\"E523: Not allowed here\"));\nEXTERN char_u e_screenmode[] INIT(= N_(\n        \"E359: Screen mode setting not supported\"));\nEXTERN char_u e_scroll[] INIT(= N_(\"E49: Invalid scroll size\"));\nEXTERN char_u e_shellempty[] INIT(= N_(\"E91: 'shell' option is empty\"));\nEXTERN char_u e_signdata[] INIT(= N_(\"E255: Couldn't read in sign data!\"));\nEXTERN char_u e_swapclose[] INIT(= N_(\"E72: Close error on swap file\"));\nEXTERN char_u e_tagstack[] INIT(= N_(\"E73: tag stack empty\"));\nEXTERN char_u e_toocompl[] INIT(= N_(\"E74: Command too complex\"));\nEXTERN char_u e_longname[] INIT(= N_(\"E75: Name too long\"));\nEXTERN char_u e_toomsbra[] INIT(= N_(\"E76: Too many [\"));\nEXTERN char_u e_toomany[] INIT(= N_(\"E77: Too many file names\"));\nEXTERN char_u e_trailing[] INIT(= N_(\"E488: Trailing characters\"));\nEXTERN char_u e_trailing2[] INIT(= N_(\"E488: Trailing characters: %s\"));\nEXTERN char_u e_umark[] INIT(= N_(\"E78: Unknown mark\"));\nEXTERN char_u e_wildexpand[] INIT(= N_(\"E79: Cannot expand wildcards\"));\nEXTERN char_u e_winheight[] INIT(= N_(\n        \"E591: 'winheight' cannot be smaller than 'winminheight'\"));\nEXTERN char_u e_winwidth[] INIT(= N_(\n        \"E592: 'winwidth' cannot be smaller than 'winminwidth'\"));\nEXTERN char_u e_write[] INIT(= N_(\"E80: Error while writing\"));\nEXTERN char_u e_zerocount[] INIT(= N_(\"E939: Positive count required\"));\nEXTERN char_u e_usingsid[] INIT(= N_(\n    \"E81: Using <SID> not in a script context\"));\nEXTERN char_u e_missingparen[] INIT(= N_(\"E107: Missing parentheses: %s\"));\nEXTERN char_u e_maxmempat[] INIT(= N_(\n        \"E363: pattern uses more memory than 'maxmempattern'\"));\nEXTERN char_u e_emptybuf[] INIT(= N_(\"E749: empty buffer\"));\nEXTERN char_u e_nobufnr[] INIT(= N_(\"E86: Buffer %\" PRId64 \" does not exist\"));\n\nEXTERN char_u e_invalpat[] INIT(= N_(\n        \"E682: Invalid search pattern or delimiter\"));\nEXTERN char_u e_bufloaded[] INIT(= N_(\"E139: File is loaded in another buffer\"));\nEXTERN char_u e_notset[] INIT(= N_(\"E764: Option '%s' is not set\"));\nEXTERN char_u e_invalidreg[] INIT(= N_(\"E850: Invalid register name\"));\nEXTERN char_u e_dirnotf[] INIT(= N_(\n    \"E919: Directory not found in '%s': \\\"%s\\\"\"));\nEXTERN char_u e_au_recursive[] INIT(= N_(\n    \"E952: Autocommand caused recursive behavior\"));\nEXTERN char_u e_autocmd_close[] INIT(= N_(\n    \"E813: Cannot close autocmd window\"));\nEXTERN char_u e_unsupportedoption[] INIT(= N_(\"E519: Option not supported\"));\nEXTERN char_u e_fnametoolong[] INIT(= N_(\"E856: Filename too long\"));\nEXTERN char_u e_float_as_string[] INIT(= N_(\"E806: using Float as a String\"));\n\nEXTERN char_u e_autocmd_err[] INIT(=N_(\n    \"E5500: autocmd has thrown an exception: %s\"));\nEXTERN char_u e_cmdmap_err[] INIT(=N_(\n    \"E5520: <Cmd> mapping must end with <CR>\"));\nEXTERN char_u e_cmdmap_repeated[] INIT(=N_(\n    \"E5521: <Cmd> mapping must end with <CR> before second <Cmd>\"));\nEXTERN char_u e_cmdmap_key[] INIT(=N_(\n    \"E5522: <Cmd> mapping must not include %s key\"));\n\nEXTERN char_u e_api_error[] INIT(=N_(\n    \"E5555: API call: %s\"));\n\nEXTERN char e_luv_api_disabled[] INIT(=N_(\n    \"E5560: %s must not be called in a lua loop callback\"));\n\nEXTERN char_u e_floatonly[] INIT(=N_(\n    \"E5601: Cannot close window, only floating window would remain\"));\nEXTERN char_u e_floatexchange[] INIT(=N_(\n    \"E5602: Cannot exchange or rotate float\"));\n\nEXTERN char e_cannot_define_autocommands_for_all_events[] INIT(= N_(\n    \"E1155: Cannot define autocommands for ALL events\"));\n\nEXTERN char top_bot_msg[] INIT(= N_(\"search hit TOP, continuing at BOTTOM\"));\nEXTERN char bot_top_msg[] INIT(= N_(\"search hit BOTTOM, continuing at TOP\"));\n\nEXTERN char line_msg[] INIT(= N_(\" line \"));\n\n// For undo we need to know the lowest time possible.\nEXTERN time_t starttime;\n\nEXTERN FILE *time_fd INIT(= NULL);  // where to write startup timing\n\n// Some compilers warn for not using a return value, but in some situations we\n// can't do anything useful with the value.  Assign to this variable to avoid\n// the warning.\nEXTERN int vim_ignored;\n\n// Start a msgpack-rpc channel over stdin/stdout.\nEXTERN bool embedded_mode INIT(= false);\n// Do not start a UI nor read/write to stdio (unless embedding).\nEXTERN bool headless_mode INIT(= false);\n\n/// Used to track the status of external functions.\n/// Currently only used for iconv().\ntypedef enum {\n  kUnknown,\n  kWorking,\n  kBroken\n} WorkingStatus;\n\n/// The scope of a working-directory command like `:cd`.\n///\n/// Scopes are enumerated from lowest to highest. When adding a scope make sure\n/// to update all functions using scopes as well, such as the implementation of\n/// `getcwd()`. When using scopes as limits (e.g. in loops) don't use the scopes\n/// directly, use `MIN_CD_SCOPE` and `MAX_CD_SCOPE` instead.\ntypedef enum {\n  kCdScopeInvalid = -1,\n  kCdScopeWindow,  ///< Affects one window.\n  kCdScopeTab,     ///< Affects one tab page.\n  kCdScopeGlobal,  ///< Affects the entire Nvim instance.\n} CdScope;\n\n#define MIN_CD_SCOPE  kCdScopeWindow\n#define MAX_CD_SCOPE  kCdScopeGlobal\n\n// Only filled for Win32.\nEXTERN char windowsVersion[20] INIT(= { 0 });\n\n#endif  // NVIM_GLOBALS_H\n"}, "11": {"id": 11, "path": "src/nvim/hashtab.h", "content": "#ifndef NVIM_HASHTAB_H\n#define NVIM_HASHTAB_H\n\n#include <stddef.h>\n\n#include \"nvim/types.h\"\n\n/// Magic number used for hashitem \"hi_key\" value indicating a deleted item\n///\n/// Only the address is used.\nextern char hash_removed;\n\n/// Type for hash number (hash calculation result).\ntypedef size_t hash_T;\n\n/// The address of \"hash_removed\" is used as a magic number\n/// for hi_key to indicate a removed item.\n#define HI_KEY_REMOVED ((char_u *)&hash_removed)\n#define HASHITEM_EMPTY(hi) ((hi)->hi_key == NULL \\\n                            || (hi)->hi_key == (char_u *)&hash_removed)\n\n/// Hashtable item.\n///\n/// Each item has a NUL terminated string key.\n/// A key can appear only once in the table.\n///\n/// A hash number is computed from the key for quick lookup.  When the hashes\n/// of two different keys point to the same entry an algorithm is used to\n/// iterate over other entries in the table until the right one is found.\n/// To make the iteration work removed keys are different from entries where a\n/// key was never present.\n///\n/// Note that this does not contain a pointer to the key and another pointer to\n/// the value. Instead, it is assumed that the key is contained within the\n/// value, so that you can get a pointer to the value subtracting an offset from\n/// the pointer to the key.\n/// This reduces the size of this item by 1/3.\ntypedef struct hashitem_S {\n  /// Cached hash number for hi_key.\n  hash_T hi_hash;\n\n  /// Item key.\n  ///\n  /// Possible values mean the following:\n  /// NULL                      : Item was never used.\n  /// HI_KEY_REMOVED            : Item was removed.\n  /// (Any other pointer value) : Item is currently being used.\n  char_u *hi_key;\n} hashitem_T;\n\n/// Initial size for a hashtable.\n/// Our items are relatively small and growing is expensive, thus start with 16.\n/// Must be a power of 2.\n/// This allows for storing 10 items (2/3 of 16) before a resize is needed.\n#define HT_INIT_SIZE 16\n\n/// An array-based hashtable.\n///\n/// Keys are NUL terminated strings. They cannot be repeated within a table.\n/// Values are of any type.\n///\n/// The hashtable grows to accommodate more entries when needed.\ntypedef struct hashtable_S {\n  hash_T ht_mask;               /// mask used for hash value\n                                /// (nr of items in array is \"ht_mask\" + 1)\n  size_t ht_used;               /// number of items used\n  size_t ht_filled;             /// number of items used or removed\n  int ht_locked;                /// counter for hash_lock()\n  hashitem_T *ht_array;         /// points to the array, allocated when it's\n                                /// not \"ht_smallarray\"\n  hashitem_T ht_smallarray[HT_INIT_SIZE];      /// initial array\n} hashtab_T;\n\n/// Iterate over a hashtab\n///\n/// @param[in]  ht  Hashtab to iterate over.\n/// @param  hi  Name of the variable with current hashtab entry.\n/// @param  code  Cycle body.\n#define HASHTAB_ITER(ht, hi, code) \\\n    do { \\\n      hashtab_T *const hi##ht_ = (ht); \\\n      size_t hi##todo_ = hi##ht_->ht_used; \\\n      for (hashitem_T *hi = hi##ht_->ht_array; hi##todo_; hi++) { \\\n        if (!HASHITEM_EMPTY(hi)) { \\\n          hi##todo_--; \\\n          { \\\n            code \\\n          } \\\n        } \\\n      } \\\n    } while (0)\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"hashtab.h.generated.h\"\n#endif\n\n#endif  // NVIM_HASHTAB_H\n"}, "13": {"id": 13, "path": "src/nvim/lib/klist.h", "content": "/* The MIT License\n\n   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef _AC_KLIST_H\n#define _AC_KLIST_H\n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"nvim/memory.h\"\n#include \"nvim/func_attr.h\"\n\n\n#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f) \\\n    typedef struct { \\\n        size_t cnt, n, max; \\\n        kmptype_t **buf; \\\n    } kmp_##name##_t; \\\n    static inline kmp_##name##_t *kmp_init_##name(void) { \\\n        return xcalloc(1, sizeof(kmp_##name##_t)); \\\n    } \\\n    static inline void kmp_destroy_##name(kmp_##name##_t *mp) \\\n        REAL_FATTR_UNUSED; \\\n    static inline void kmp_destroy_##name(kmp_##name##_t *mp) { \\\n        size_t k; \\\n        for (k = 0; k < mp->n; k++) { \\\n            kmpfree_f(mp->buf[k]); XFREE_CLEAR(mp->buf[k]); \\\n        } \\\n        XFREE_CLEAR(mp->buf); XFREE_CLEAR(mp); \\\n    } \\\n    static inline kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) { \\\n        mp->cnt++; \\\n        if (mp->n == 0) { \\\n          return xcalloc(1, sizeof(kmptype_t)); \\\n        } \\\n        return mp->buf[--mp->n]; \\\n    } \\\n    static inline void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \\\n        mp->cnt--; \\\n        if (mp->n == mp->max) { \\\n            mp->max = mp->max ? (mp->max << 1) : 16; \\\n            mp->buf = xrealloc(mp->buf, sizeof(kmptype_t *) * mp->max); \\\n        } \\\n        mp->buf[mp->n++] = p; \\\n    }\n\n#define kmempool_t(name) kmp_##name##_t\n#define kmp_init(name) kmp_init_##name()\n#define kmp_destroy(name, mp) kmp_destroy_##name(mp)\n#define kmp_alloc(name, mp) kmp_alloc_##name(mp)\n#define kmp_free(name, mp, p) kmp_free_##name(mp, p)\n\n#define KLIST_INIT(name, kltype_t, kmpfree_t) \\\n    struct __kl1_##name { \\\n        kltype_t data; \\\n        struct __kl1_##name *next; \\\n    }; \\\n    typedef struct __kl1_##name kl1_##name; \\\n    KMEMPOOL_INIT(name, kl1_##name, kmpfree_t) \\\n    typedef struct { \\\n        kl1_##name *head, *tail; \\\n        kmp_##name##_t *mp; \\\n        size_t size; \\\n    } kl_##name##_t; \\\n    static inline kl_##name##_t *kl_init_##name(void) { \\\n        kl_##name##_t *kl = xcalloc(1, sizeof(kl_##name##_t)); \\\n        kl->mp = kmp_init(name); \\\n        kl->head = kl->tail = kmp_alloc(name, kl->mp); \\\n        kl->head->next = 0; \\\n        return kl; \\\n    } \\\n    static inline void kl_destroy_##name(kl_##name##_t *kl) \\\n        REAL_FATTR_UNUSED; \\\n    static inline void kl_destroy_##name(kl_##name##_t *kl) { \\\n        kl1_##name *p; \\\n        for (p = kl->head; p != kl->tail; p = p->next) { \\\n            kmp_free(name, kl->mp, p); \\\n        } \\\n        kmp_free(name, kl->mp, p); \\\n        kmp_destroy(name, kl->mp); \\\n        XFREE_CLEAR(kl); \\\n    } \\\n    static inline void kl_push_##name(kl_##name##_t *kl, kltype_t d) { \\\n        kl1_##name *q, *p = kmp_alloc(name, kl->mp); \\\n        q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p; \\\n        kl->size++; \\\n        q->data = d; \\\n    } \\\n    static inline kltype_t kl_shift_at_##name(kl_##name##_t *kl, \\\n                                              kl1_##name **n) { \\\n        assert((*n)->next); \\\n        kl1_##name *p; \\\n        kl->size--; \\\n        p = *n; \\\n        *n = (*n)->next; \\\n        if (p == kl->head) { \\\n          kl->head = *n; \\\n        } \\\n        kltype_t d = p->data; \\\n        kmp_free(name, kl->mp, p); \\\n        return d; \\\n    }\n\n#define kliter_t(name) kl1_##name\n#define klist_t(name) kl_##name##_t\n#define kl_val(iter) ((iter)->data)\n#define kl_next(iter) ((iter)->next)\n#define kl_begin(kl) ((kl)->head)\n#define kl_end(kl) ((kl)->tail)\n\n#define kl_init(name) kl_init_##name()\n#define kl_destroy(name, kl) kl_destroy_##name(kl)\n#define kl_push(name, kl, d) kl_push_##name(kl, d)\n#define kl_shift_at(name, kl, node) kl_shift_at_##name(kl, node)\n#define kl_shift(name, kl) kl_shift_at(name, kl, &kl->head)\n#define kl_empty(kl) ((kl)->size == 0)\n// Iteration macros. It's ok to modify the list while iterating as long as a\n// `break` statement is executed before the next iteration.\n#define kl_iter(name, kl, p) kl_iter_at(name, kl, p, NULL)\n#define kl_iter_at(name, kl, p, h) \\\n  for (kl1_##name **p = h ? h : &kl->head; *p != kl->tail; p = &(*p)->next)\n\n#endif\n"}, "15": {"id": 15, "path": "src/nvim/lib/queue.h", "content": "// Queue implemented by circularly-linked list.\n//\n// Adapted from libuv. Simpler and more efficient than klist.h for implementing\n// queues that support arbitrary insertion/removal.\n//\n// Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n#ifndef NVIM_LIB_QUEUE_H\n#define NVIM_LIB_QUEUE_H\n\n#include <stddef.h>\n\n#include \"nvim/func_attr.h\"\n\ntypedef struct _queue {\n  struct _queue *next;\n  struct _queue *prev;\n} QUEUE;\n\n// Public macros.\n#define QUEUE_DATA(ptr, type, field) \\\n  ((type *)((char *)(ptr) - offsetof(type, field)))\n\n// Important note: the node currently being processed can be safely deleted.\n// otherwise, mutating the list while QUEUE_FOREACH is iterating over its\n// elements results in undefined behavior.\n#define QUEUE_FOREACH(q, h, code) \\\n  (q) = (h)->next; \\\n  while((q) != (h)) { \\\n    QUEUE *next = q->next; \\\n    code \\\n    (q) = next; \\\n  }\n\n\n// ffi.cdef is unable to swallow `bool` in place of `int` here.\nstatic inline int QUEUE_EMPTY(const QUEUE *const q)\n  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return q == q->next;\n}\n\n#define QUEUE_HEAD(q) (q)->next\n\nstatic inline void QUEUE_INIT(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE\n{\n  q->next = q;\n  q->prev = q;\n}\n\nstatic inline void QUEUE_ADD(QUEUE *const h, QUEUE *const n)\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  h->prev->next = n->next;\n  n->next->prev = h->prev;\n  h->prev = n->prev;\n  h->prev->next = h;\n}\n\nstatic inline void QUEUE_INSERT_HEAD(QUEUE *const h, QUEUE *const q)\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  q->next = h->next;\n  q->prev = h;\n  q->next->prev = q;\n  h->next = q;\n}\n\nstatic inline void QUEUE_INSERT_TAIL(QUEUE *const h, QUEUE *const q)\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  q->next = h;\n  q->prev = h->prev;\n  q->prev->next = q;\n  h->prev = q;\n}\n\nstatic inline void QUEUE_REMOVE(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE\n{\n  q->prev->next = q->next;\n  q->next->prev = q->prev;\n}\n\n#endif  // NVIM_LIB_QUEUE_H\n"}, "18": {"id": 18, "path": "src/nvim/option_defs.h", "content": "#ifndef NVIM_OPTION_DEFS_H\n#define NVIM_OPTION_DEFS_H\n\n#include \"nvim/types.h\"\n#include \"nvim/macros.h\"  // For EXTERN\n#include \"eval/typval.h\"  // For scid_T\n\n// option_defs.h: definition of global variables for settable options\n\n// Return value from get_option_value_strict\n#define SOPT_BOOL 0x01     // Boolean option\n#define SOPT_NUM 0x02      // Number option\n#define SOPT_STRING 0x04   // String option\n#define SOPT_GLOBAL 0x08   // Option has global value\n#define SOPT_WIN 0x10      // Option has window-local value\n#define SOPT_BUF 0x20      // Option has buffer-local value\n#define SOPT_UNSET 0x40    // Option does not have local value set\n\n// Option types for various functions in option.c\n#define SREQ_GLOBAL 0  // Request global option value\n#define SREQ_WIN 1     // Request window-local option value\n#define SREQ_BUF 2     // Request buffer-local option value\n\n// Default values for 'errorformat'.\n// The \"%f|%l| %m\" one is used for when the contents of the quickfix window is\n// written to a file.\n#ifdef WIN32\n# define DFLT_EFM \"%f(%l) \\\\=: %t%*\\\\D%n: %m,%*[^\\\"]\\\"%f\\\"%*\\\\D%l: %m,%f(%l) \\\\=: %m,%*[^ ] %f %l: %m,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,%f|%l| %m\"\n#else\n# define DFLT_EFM \"%*[^\\\"]\\\"%f\\\"%*\\\\D%l: %m,\\\"%f\\\"%*\\\\D%l: %m,%-G%f:%l: (Each undeclared identifier is reported only once,%-G%f:%l: for each function it appears in.),%-GIn file included from %f:%l:%c:,%-GIn file included from %f:%l:%c\\\\,,%-GIn file included from %f:%l:%c,%-GIn file included from %f:%l,%-G%*[ ]from %f:%l:%c,%-G%*[ ]from %f:%l:,%-G%*[ ]from %f:%l\\\\,,%-G%*[ ]from %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\\\"%f\\\"\\\\, line %l%*\\\\D%c%*[^ ] %m,%D%*\\\\a[%*\\\\d]: Entering directory %*[`']%f',%X%*\\\\a[%*\\\\d]: Leaving directory %*[`']%f',%D%*\\\\a: Entering directory %*[`']%f',%X%*\\\\a: Leaving directory %*[`']%f',%DMaking %*\\\\a in %f,%f|%l| %m\"\n#endif\n\n#define DFLT_GREPFORMAT \"%f:%l:%m,%f:%l%m,%f  %l%m\"\n\n// default values for b_p_ff 'fileformat' and p_ffs 'fileformats'\n#define FF_DOS          \"dos\"\n#define FF_MAC          \"mac\"\n#define FF_UNIX         \"unix\"\n\n#ifdef USE_CRNL\n# define DFLT_FF        \"dos\"\n# define DFLT_FFS_VIM   \"dos,unix\"\n# define DFLT_FFS_VI    \"dos,unix\"      // also autodetect in compatible mode\n#else\n#  define DFLT_FF       \"unix\"\n#  define DFLT_FFS_VIM  \"unix,dos\"\n#   define DFLT_FFS_VI  \"\"\n#endif\n\n\n// Possible values for 'encoding'\n# define ENC_UCSBOM     \"ucs-bom\"       // check for BOM at start of file\n\n// default value for 'encoding'\n# define ENC_DFLT       \"utf-8\"\n\n// end-of-line style\n#define EOL_UNKNOWN     -1      // not defined yet\n#define EOL_UNIX        0       // NL\n#define EOL_DOS         1       // CR NL\n#define EOL_MAC         2       // CR\n\n// Formatting options for p_fo 'formatoptions'\n#define FO_WRAP         't'\n#define FO_WRAP_COMS    'c'\n#define FO_RET_COMS     'r'\n#define FO_OPEN_COMS    'o'\n#define FO_Q_COMS       'q'\n#define FO_Q_NUMBER     'n'\n#define FO_Q_SECOND     '2'\n#define FO_INS_VI       'v'\n#define FO_INS_LONG     'l'\n#define FO_INS_BLANK    'b'\n#define FO_MBYTE_BREAK  'm'     // break before/after multi-byte char\n#define FO_MBYTE_JOIN   'M'     // no space before/after multi-byte char\n#define FO_MBYTE_JOIN2  'B'     // no space between multi-byte chars\n#define FO_ONE_LETTER   '1'\n#define FO_WHITE_PAR    'w'     // trailing white space continues paragr.\n#define FO_AUTO         'a'     // automatic formatting\n#define FO_RIGOROUS_TW  ']'     // respect textwidth rigorously\n#define FO_REMOVE_COMS  'j'     // remove comment leaders when joining lines\n#define FO_PERIOD_ABBR  'p'     // don't break a single space after a period\n\n#define DFLT_FO_VI      \"vt\"\n#define DFLT_FO_VIM     \"tcqj\"\n#define FO_ALL          \"tcroq2vlb1mMBn,aw]jp\"   // for do_set()\n\n// characters for the p_cpo option:\n#define CPO_ALTREAD     'a'     // \":read\" sets alternate file name\n#define CPO_ALTWRITE    'A'     // \":write\" sets alternate file name\n#define CPO_BAR         'b'     // \"\\|\" ends a mapping\n#define CPO_BSLASH      'B'     // backslash in mapping is not special\n#define CPO_SEARCH      'c'\n#define CPO_CONCAT      'C'     // Don't concatenate sourced lines\n#define CPO_DOTTAG      'd'     // \"./tags\" in 'tags' is in current dir\n#define CPO_DIGRAPH     'D'     // No digraph after \"r\", \"f\", etc.\n#define CPO_EXECBUF     'e'\n#define CPO_EMPTYREGION 'E'     // operating on empty region is an error\n#define CPO_FNAMER      'f'     // set file name for \":r file\"\n#define CPO_FNAMEW      'F'     // set file name for \":w file\"\n#define CPO_INTMOD      'i'     // interrupt a read makes buffer modified\n#define CPO_INDENT      'I'     // remove auto-indent more often\n#define CPO_ENDOFSENT   'J'     // need two spaces to detect end of sentence\n#define CPO_KOFFSET     'K'     // don't wait for key code in mappings\n#define CPO_LITERAL     'l'     // take char after backslash in [] literal\n#define CPO_LISTWM      'L'     // 'list' changes wrapmargin\n#define CPO_SHOWMATCH   'm'\n#define CPO_MATCHBSL    'M'     // \"%\" ignores use of backslashes\n#define CPO_NUMCOL      'n'     // 'number' column also used for text\n#define CPO_LINEOFF     'o'\n#define CPO_OVERNEW     'O'     // silently overwrite new file\n#define CPO_LISP        'p'     // 'lisp' indenting\n#define CPO_FNAMEAPP    'P'     // set file name for \":w >>file\"\n#define CPO_JOINCOL     'q'     // with \"3J\" use column after first join\n#define CPO_REDO        'r'\n#define CPO_REMMARK     'R'     // remove marks when filtering\n#define CPO_BUFOPT      's'\n#define CPO_BUFOPTGLOB  'S'\n#define CPO_TAGPAT      't'\n#define CPO_UNDO        'u'     // \"u\" undoes itself\n#define CPO_BACKSPACE   'v'     // \"v\" keep deleted text\n#define CPO_FWRITE      'W'     // \"w!\" doesn't overwrite readonly files\n#define CPO_ESC         'x'\n#define CPO_REPLCNT     'X'     // \"R\" with a count only deletes chars once\n#define CPO_YANK        'y'\n#define CPO_KEEPRO      'Z'     // don't reset 'readonly' on \":w!\"\n#define CPO_DOLLAR      '$'\n#define CPO_FILTER      '!'\n#define CPO_MATCH       '%'\n#define CPO_PLUS        '+'     // \":write file\" resets 'modified'\n#define CPO_REGAPPEND   '>'     // insert NL when appending to a register\n#define CPO_SCOLON      ';'     // using \",\" and \";\" will skip over char if\n                                // cursor would not move\n#define CPO_CHANGEW     '_'     // \"cw\" special-case\n// default values for Vim and Vi\n#define CPO_VIM         \"aABceFs_\"\n#define CPO_VI          \"aAbBcCdDeEfFiIJKlLmMnoOpPqrRsStuvWxXyZ$!%+>;_\"\n\n// characters for p_ww option:\n#define WW_ALL          \"bshl<>[],~\"\n\n// characters for p_mouse option:\n#define MOUSE_NORMAL    'n'             // use mouse in Normal mode\n#define MOUSE_VISUAL    'v'             // use mouse in Visual/Select mode\n#define MOUSE_INSERT    'i'             // use mouse in Insert mode\n#define MOUSE_COMMAND   'c'             // use mouse in Command-line mode\n#define MOUSE_HELP      'h'             // use mouse in help buffers\n#define MOUSE_RETURN    'r'             // use mouse for hit-return message\n#define MOUSE_A         \"nvich\"         // used for 'a' flag\n#define MOUSE_ALL       \"anvichr\"       // all possible characters\n#define MOUSE_NONE      ' '             // don't use Visual selection\n#define MOUSE_NONEF     'x'             // forced modeless selection\n\n#define COCU_ALL        \"nvic\"          // flags for 'concealcursor'\n\n/// characters for p_shm option:\nenum {\n  SHM_RO             = 'r',  ///< Readonly.\n  SHM_MOD            = 'm',  ///< Modified.\n  SHM_FILE           = 'f',  ///< (file 1 of 2)\n  SHM_LAST           = 'i',  ///< Last line incomplete.\n  SHM_TEXT           = 'x',  ///< Tx instead of textmode.\n  SHM_LINES          = 'l',  ///< \"L\" instead of \"lines\".\n  SHM_NEW            = 'n',  ///< \"[New]\" instead of \"[New file]\".\n  SHM_WRI            = 'w',  ///< \"[w]\" instead of \"written\".\n  SHM_ABBREVIATIONS  = 'a',  ///< Use abbreviations from #SHM_ALL_ABBREVIATIONS.\n  SHM_WRITE          = 'W',  ///< Don't use \"written\" at all.\n  SHM_TRUNC          = 't',  ///< Truncate file messages.\n  SHM_TRUNCALL       = 'T',  ///< Truncate all messages.\n  SHM_OVER           = 'o',  ///< Overwrite file messages.\n  SHM_OVERALL        = 'O',  ///< Overwrite more messages.\n  SHM_SEARCH         = 's',  ///< No search hit bottom messages.\n  SHM_ATTENTION      = 'A',  ///< No ATTENTION messages.\n  SHM_INTRO          = 'I',  ///< Intro messages.\n  SHM_COMPLETIONMENU = 'c',  ///< Completion menu messages.\n  SHM_RECORDING      = 'q',  ///< Short recording message.\n  SHM_FILEINFO       = 'F',  ///< No file info messages.\n  SHM_SEARCHCOUNT    = 'S',  ///< Search sats: '[1/10]'\n};\n/// Represented by 'a' flag.\n#define SHM_ALL_ABBREVIATIONS ((char_u[]) { \\\n  SHM_RO, SHM_MOD, SHM_FILE, SHM_LAST, SHM_TEXT, SHM_LINES, SHM_NEW, SHM_WRI, \\\n  0, \\\n})\n\n// characters for p_go:\n#define GO_ASEL         'a'             // autoselect\n#define GO_ASELML       'A'             // autoselect modeless selection\n#define GO_BOT          'b'             // use bottom scrollbar\n#define GO_CONDIALOG    'c'             // use console dialog\n#define GO_DARKTHEME    'd'             // use dark theme variant\n#define GO_TABLINE      'e'             // may show tabline\n#define GO_FORG         'f'             // start GUI in foreground\n#define GO_GREY         'g'             // use grey menu items\n#define GO_HORSCROLL    'h'             // flexible horizontal scrolling\n#define GO_ICON         'i'             // use Vim icon\n#define GO_LEFT         'l'             // use left scrollbar\n#define GO_VLEFT        'L'             // left scrollbar with vert split\n#define GO_MENUS        'm'             // use menu bar\n#define GO_NOSYSMENU    'M'             // don't source system menu\n#define GO_POINTER      'p'             // pointer enter/leave callbacks\n#define GO_ASELPLUS     'P'             // autoselectPlus\n#define GO_RIGHT        'r'             // use right scrollbar\n#define GO_VRIGHT       'R'             // right scrollbar with vert split\n#define GO_TOOLBAR      'T'             // add toolbar\n#define GO_FOOTER       'F'             // add footer\n#define GO_VERTICAL     'v'             // arrange dialog buttons vertically\n#define GO_KEEPWINSIZE  'k'             // keep GUI window size\n#define GO_ALL \"aAbcdefFghilmMprTvk\"    // all possible flags for 'go'\n\n// flags for 'comments' option\n#define COM_NEST        'n'             // comments strings nest\n#define COM_BLANK       'b'             // needs blank after string\n#define COM_START       's'             // start of comment\n#define COM_MIDDLE      'm'             // middle of comment\n#define COM_END         'e'             // end of comment\n#define COM_AUTO_END    'x'             // last char of end closes comment\n#define COM_FIRST       'f'             // first line comment only\n#define COM_LEFT        'l'             // left adjusted\n#define COM_RIGHT       'r'             // right adjusted\n#define COM_NOBACK      'O'             // don't use for \"O\" command\n#define COM_ALL         \"nbsmexflrO\"    // all flags for 'comments' option\n#define COM_MAX_LEN     50              // maximum length of a part\n\n/// 'statusline' option flags\nenum {\n  STL_FILEPATH        = 'f',  ///< Path of file in buffer.\n  STL_FULLPATH        = 'F',  ///< Full path of file in buffer.\n  STL_FILENAME        = 't',  ///< Last part (tail) of file path.\n  STL_COLUMN          = 'c',  ///< Column og cursor.\n  STL_VIRTCOL         = 'v',  ///< Virtual column.\n  STL_VIRTCOL_ALT     = 'V',  ///< - with 'if different' display.\n  STL_LINE            = 'l',  ///< Line number of cursor.\n  STL_NUMLINES        = 'L',  ///< Number of lines in buffer.\n  STL_BUFNO           = 'n',  ///< Current buffer number.\n  STL_KEYMAP          = 'k',  ///< 'keymap' when active.\n  STL_OFFSET          = 'o',  ///< Offset of character under cursor.\n  STL_OFFSET_X        = 'O',  ///< - in hexadecimal.\n  STL_BYTEVAL         = 'b',  ///< Byte value of character.\n  STL_BYTEVAL_X       = 'B',  ///< - in hexadecimal.\n  STL_ROFLAG          = 'r',  ///< Readonly flag.\n  STL_ROFLAG_ALT      = 'R',  ///< - other display.\n  STL_HELPFLAG        = 'h',  ///< Window is showing a help file.\n  STL_HELPFLAG_ALT    = 'H',  ///< - other display.\n  STL_FILETYPE        = 'y',  ///< 'filetype'.\n  STL_FILETYPE_ALT    = 'Y',  ///< - other display.\n  STL_PREVIEWFLAG     = 'w',  ///< Window is showing the preview buf.\n  STL_PREVIEWFLAG_ALT = 'W',  ///< - other display.\n  STL_MODIFIED        = 'm',  ///< Modified flag.\n  STL_MODIFIED_ALT    = 'M',  ///< - other display.\n  STL_QUICKFIX        = 'q',  ///< Quickfix window description.\n  STL_PERCENTAGE      = 'p',  ///< Percentage through file.\n  STL_ALTPERCENT      = 'P',  ///< Percentage as TOP BOT ALL or NN%.\n  STL_ARGLISTSTAT     = 'a',  ///< Argument list status as (x of y).\n  STL_PAGENUM         = 'N',  ///< Page number (when printing).\n  STL_VIM_EXPR        = '{',  ///< Start of expression to substitute.\n  STL_SEPARATE        = '=',  ///< Separation between alignment sections.\n  STL_TRUNCMARK       = '<',  ///< Truncation mark if line is too long.\n  STL_USER_HL         = '*',  ///< Highlight from (User)1..9 or 0.\n  STL_HIGHLIGHT       = '#',  ///< Highlight name.\n  STL_TABPAGENR       = 'T',  ///< Tab page label nr.\n  STL_TABCLOSENR      = 'X',  ///< Tab page close nr.\n  STL_CLICK_FUNC      = '@',  ///< Click region start.\n};\n/// C string containing all 'statusline' option flags\n#define STL_ALL ((char_u[]) { \\\n  STL_FILEPATH, STL_FULLPATH, STL_FILENAME, STL_COLUMN, STL_VIRTCOL, \\\n  STL_VIRTCOL_ALT, STL_LINE, STL_NUMLINES, STL_BUFNO, STL_KEYMAP, STL_OFFSET, \\\n  STL_OFFSET_X, STL_BYTEVAL, STL_BYTEVAL_X, STL_ROFLAG, STL_ROFLAG_ALT, \\\n  STL_HELPFLAG, STL_HELPFLAG_ALT, STL_FILETYPE, STL_FILETYPE_ALT, \\\n  STL_PREVIEWFLAG, STL_PREVIEWFLAG_ALT, STL_MODIFIED, STL_MODIFIED_ALT, \\\n  STL_QUICKFIX, STL_PERCENTAGE, STL_ALTPERCENT, STL_ARGLISTSTAT, STL_PAGENUM, \\\n  STL_VIM_EXPR, STL_SEPARATE, STL_TRUNCMARK, STL_USER_HL, STL_HIGHLIGHT, \\\n  STL_TABPAGENR, STL_TABCLOSENR, STL_CLICK_FUNC, \\\n  0, \\\n})\n\n// flags used for parsed 'wildmode'\n#define WIM_FULL        0x01\n#define WIM_LONGEST     0x02\n#define WIM_LIST        0x04\n#define WIM_BUFLASTUSED 0x08\n\n// arguments for can_bs()\n// each defined char should be unique over all values\n// except for BS_START, that intentionally also matches BS_NOSTOP\n// because BS_NOSTOP behaves exactly the same except it\n// does not stop at the start of the insert point\n#define BS_INDENT       'i'     // \"Indent\"\n#define BS_EOL          'l'     // \"eoL\"\n#define BS_START        's'     // \"Start\"\n#define BS_NOSTOP       'p'     // \"nostoP\n\n// flags for the 'culopt' option\n#define CULOPT_LINE     0x01    // Highlight complete line\n#define CULOPT_SCRLINE  0x02    // Highlight screen line\n#define CULOPT_NBR      0x04    // Highlight Number column\n\n#define LISPWORD_VALUE \\\n  \"defun,define,defmacro,set!,lambda,if,case,let,flet,let*,letrec,do,do*,define-syntax,let-syntax,letrec-syntax,destructuring-bind,defpackage,defparameter,defstruct,deftype,defvar,do-all-symbols,do-external-symbols,do-symbols,dolist,dotimes,ecase,etypecase,eval-when,labels,macrolet,multiple-value-bind,multiple-value-call,multiple-value-prog1,multiple-value-setq,prog1,progv,typecase,unless,unwind-protect,when,with-input-from-string,with-open-file,with-open-stream,with-output-to-string,with-package-iterator,define-condition,handler-bind,handler-case,restart-bind,restart-case,with-simple-restart,store-value,use-value,muffle-warning,abort,continue,with-slots,with-slots*,with-accessors,with-accessors*,defclass,defmethod,print-unreadable-object\"\n\n/*\n * The following are actual variables for the options\n */\n\nEXTERN long p_aleph;            // 'aleph'\nEXTERN int p_acd;               // 'autochdir'\nEXTERN char_u   *p_ambw;        // 'ambiwidth'\nEXTERN int p_ar;                // 'autoread'\nEXTERN int p_aw;                // 'autowrite'\nEXTERN int p_awa;               // 'autowriteall'\nEXTERN char_u   *p_bs;          // 'backspace'\nEXTERN char_u   *p_bg;          // 'background'\nEXTERN int p_bk;                // 'backup'\nEXTERN char_u   *p_bkc;         // 'backupcopy'\nEXTERN unsigned int bkc_flags;  ///< flags from 'backupcopy'\n#ifdef IN_OPTION_C\nstatic char *(p_bkc_values[]) =\n{\"yes\", \"auto\", \"no\", \"breaksymlink\", \"breakhardlink\", NULL};\n#endif\n# define BKC_YES                0x001\n# define BKC_AUTO               0x002\n# define BKC_NO                 0x004\n# define BKC_BREAKSYMLINK       0x008\n# define BKC_BREAKHARDLINK      0x010\nEXTERN char_u *p_bdir;            // 'backupdir'\nEXTERN char_u *p_bex;             // 'backupext'\nEXTERN char_u *p_bo;              // 'belloff'\nEXTERN char breakat_flags[256];   // which characters are in 'breakat'\nEXTERN unsigned bo_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_bo_values[]) = {\"all\", \"backspace\", \"cursor\", \"complete\",\n  \"copy\", \"ctrlg\", \"error\", \"esc\", \"ex\",\n  \"hangul\", \"insertmode\", \"lang\", \"mess\",\n  \"showmatch\", \"operator\", \"register\", \"shell\",\n  \"spell\", \"wildmode\", NULL};\n# endif\n\n// values for the 'belloff' option\n#define BO_ALL    0x0001\n#define BO_BS     0x0002\n#define BO_CRSR   0x0004\n#define BO_COMPL  0x0008\n#define BO_COPY   0x0010\n#define BO_CTRLG  0x0020\n#define BO_ERROR  0x0040\n#define BO_ESC    0x0080\n#define BO_EX     0x0100\n#define BO_HANGUL 0x0200\n#define BO_IM     0x0400\n#define BO_LANG   0x0800\n#define BO_MESS   0x1000\n#define BO_MATCH  0x2000\n#define BO_OPER   0x4000\n#define BO_REG    0x8000\n#define BO_SH     0x10000\n#define BO_SPELL  0x20000\n#define BO_WILD   0x40000\n\nEXTERN char_u   *p_bsk;         // 'backupskip'\nEXTERN char_u   *p_breakat;     // 'breakat'\nEXTERN char_u   *p_cmp;         // 'casemap'\nEXTERN unsigned cmp_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_cmp_values[]) = {\"internal\", \"keepascii\", NULL};\n# endif\n# define CMP_INTERNAL           0x001\n# define CMP_KEEPASCII          0x002\nEXTERN char_u   *p_enc;         // 'encoding'\nEXTERN int p_deco;              // 'delcombine'\nEXTERN char_u   *p_ccv;         // 'charconvert'\nEXTERN char_u   *p_cedit;       // 'cedit'\nEXTERN char_u   *p_cb;          // 'clipboard'\nEXTERN unsigned cb_flags;\n#ifdef IN_OPTION_C\nstatic char *(p_cb_values[]) = {\"unnamed\", \"unnamedplus\", NULL};\n#endif\n# define CB_UNNAMED             0x001\n# define CB_UNNAMEDPLUS         0x002\n# define CB_UNNAMEDMASK         (CB_UNNAMED | CB_UNNAMEDPLUS)\nEXTERN long p_cwh;              // 'cmdwinheight'\nEXTERN long p_ch;               // 'cmdheight'\nEXTERN long p_columns;          // 'columns'\nEXTERN int p_confirm;           // 'confirm'\nEXTERN char_u   *p_cot;         // 'completeopt'\n# ifdef BACKSLASH_IN_FILENAME\nEXTERN char_u   *p_csl;         // 'completeslash'\n# endif\nEXTERN long p_pb;               // 'pumblend'\nEXTERN long p_ph;               // 'pumheight'\nEXTERN long p_pw;               // 'pumwidth'\nEXTERN char_u   *p_cpo;         // 'cpoptions'\nEXTERN char_u   *p_csprg;       // 'cscopeprg'\nEXTERN int p_csre;              // 'cscoperelative'\nEXTERN char_u   *p_csqf;        // 'cscopequickfix'\n#  define       CSQF_CMDS   \"sgdctefia\"\n#  define       CSQF_FLAGS  \"+-0\"\nEXTERN int p_cst;               // 'cscopetag'\nEXTERN long p_csto;             // 'cscopetagorder'\nEXTERN long p_cspc;             // 'cscopepathcomp'\nEXTERN int p_csverbose;         // 'cscopeverbose'\nEXTERN char_u   *p_debug;       // 'debug'\nEXTERN char_u   *p_def;         // 'define'\nEXTERN char_u   *p_inc;\nEXTERN char_u   *p_dip;         // 'diffopt'\nEXTERN char_u   *p_dex;         // 'diffexpr'\nEXTERN char_u   *p_dict;        // 'dictionary'\nEXTERN int p_dg;                // 'digraph'\nEXTERN char_u   *p_dir;         // 'directory'\nEXTERN char_u   *p_dy;          // 'display'\nEXTERN unsigned dy_flags;\n#ifdef IN_OPTION_C\nstatic char *(p_dy_values[]) = { \"lastline\", \"truncate\", \"uhex\", \"msgsep\",\n                                  NULL };\n#endif\n#define DY_LASTLINE             0x001\n#define DY_TRUNCATE             0x002\n#define DY_UHEX                 0x004\n// code should use msg_use_msgsep() to check if msgsep is active\n#define DY_MSGSEP               0x008\nEXTERN int p_ed;                // 'edcompatible'\nEXTERN int p_emoji;             // 'emoji'\nEXTERN char_u   *p_ead;         // 'eadirection'\nEXTERN int p_ea;                // 'equalalways'\nEXTERN char_u   *p_ep;          // 'equalprg'\nEXTERN int p_eb;                // 'errorbells'\nEXTERN char_u   *p_ef;          // 'errorfile'\nEXTERN char_u   *p_efm;         // 'errorformat'\nEXTERN char_u   *p_gefm;        // 'grepformat'\nEXTERN char_u   *p_gp;          // 'grepprg'\nEXTERN char_u   *p_ei;          // 'eventignore'\nEXTERN int p_exrc;              // 'exrc'\nEXTERN char_u   *p_fencs;       // 'fileencodings'\nEXTERN char_u   *p_ffs;         // 'fileformats'\nEXTERN int p_fic;               // 'fileignorecase'\nEXTERN char_u   *p_fcl;         // 'foldclose'\nEXTERN long p_fdls;             // 'foldlevelstart'\nEXTERN char_u   *p_fdo;         // 'foldopen'\nEXTERN unsigned fdo_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_fdo_values[]) = {\"all\", \"block\", \"hor\", \"mark\", \"percent\",\n                                 \"quickfix\", \"search\", \"tag\", \"insert\",\n                                 \"undo\", \"jump\", NULL};\n# endif\n# define FDO_ALL                0x001\n# define FDO_BLOCK              0x002\n# define FDO_HOR                0x004\n# define FDO_MARK               0x008\n# define FDO_PERCENT            0x010\n# define FDO_QUICKFIX           0x020\n# define FDO_SEARCH             0x040\n# define FDO_TAG                0x080\n# define FDO_INSERT             0x100\n# define FDO_UNDO               0x200\n# define FDO_JUMP               0x400\nEXTERN char_u   *p_fp;          // 'formatprg'\nEXTERN int p_fs;                // 'fsync'\nEXTERN int p_gd;                // 'gdefault'\nEXTERN char_u   *p_pdev;        // 'printdevice'\nEXTERN char_u   *p_penc;        // 'printencoding'\nEXTERN char_u   *p_pexpr;       // 'printexpr'\nEXTERN char_u   *p_pmfn;        // 'printmbfont'\nEXTERN char_u   *p_pmcs;        // 'printmbcharset'\nEXTERN char_u   *p_pfn;         // 'printfont'\nEXTERN char_u   *p_popt;        // 'printoptions'\nEXTERN char_u   *p_header;      // 'printheader'\nEXTERN char_u   *p_guicursor;   // 'guicursor'\nEXTERN char_u   *p_guifont;     // 'guifont'\nEXTERN char_u   *p_guifontwide;  // 'guifontwide'\nEXTERN char_u   *p_hf;          // 'helpfile'\nEXTERN long p_hh;               // 'helpheight'\nEXTERN char_u   *p_hlg;         // 'helplang'\nEXTERN int p_hid;               // 'hidden'\nEXTERN char_u   *p_hl;          // 'highlight'\nEXTERN int p_hls;               // 'hlsearch'\nEXTERN long p_hi;               // 'history'\nEXTERN int p_hkmap;             // 'hkmap'\nEXTERN int p_hkmapp;            // 'hkmapp'\nEXTERN int p_arshape;           // 'arabicshape'\nEXTERN int p_icon;              // 'icon'\nEXTERN char_u   *p_iconstring;  // 'iconstring'\nEXTERN int p_ic;                // 'ignorecase'\nEXTERN int p_is;                // 'incsearch'\nEXTERN char_u   *p_icm;         // 'inccommand'\nEXTERN int p_im;                // 'insertmode'\nEXTERN char_u   *p_isf;         // 'isfname'\nEXTERN char_u   *p_isi;         // 'isident'\nEXTERN char_u   *p_isp;         // 'isprint'\nEXTERN int p_js;                // 'joinspaces'\nEXTERN char_u *p_jop;           // 'jumpooptions'\nEXTERN unsigned jop_flags;\n#ifdef IN_OPTION_C\nstatic char *(p_jop_values[]) = { \"stack\", NULL };\n#endif\n#define JOP_STACK               0x01\nEXTERN char_u   *p_kp;          // 'keywordprg'\nEXTERN char_u   *p_km;          // 'keymodel'\nEXTERN char_u   *p_langmap;     // 'langmap'\nEXTERN int p_lnr;               // 'langnoremap'\nEXTERN int p_lrm;               // 'langremap'\nEXTERN char_u   *p_lm;          // 'langmenu'\nEXTERN long     p_lines;        // 'lines'\nEXTERN long     p_linespace;    // 'linespace'\nEXTERN char_u   *p_lispwords;   // 'lispwords'\nEXTERN long p_ls;               // 'laststatus'\nEXTERN long p_stal;             // 'showtabline'\nEXTERN char_u   *p_lcs;         // 'listchars'\n\nEXTERN int p_lz;                // 'lazyredraw'\nEXTERN int p_lpl;               // 'loadplugins'\nEXTERN int p_magic;             // 'magic'\nEXTERN char_u   *p_menc;        // 'makeencoding'\nEXTERN char_u   *p_mef;         // 'makeef'\nEXTERN char_u   *p_mp;          // 'makeprg'\nEXTERN char_u   *p_cc;          // 'colorcolumn'\nEXTERN int p_cc_cols[256];      // array for 'colorcolumn' columns\nEXTERN long p_mat;              // 'matchtime'\nEXTERN long p_mco;              // 'maxcombine'\nEXTERN long p_mfd;              // 'maxfuncdepth'\nEXTERN long p_mmd;              // 'maxmapdepth'\nEXTERN long p_mmp;              // 'maxmempattern'\nEXTERN long p_mis;              // 'menuitems'\nEXTERN char_u   *p_msm;         // 'mkspellmem'\nEXTERN long p_mle;              // 'modelineexpr'\nEXTERN long p_mls;              // 'modelines'\nEXTERN char_u   *p_mouse;       // 'mouse'\nEXTERN char_u   *p_mousem;      // 'mousemodel'\nEXTERN long p_mousef;           // 'mousefocus'\nEXTERN long p_mouset;           // 'mousetime'\nEXTERN int p_more;              // 'more'\nEXTERN char_u   *p_opfunc;      // 'operatorfunc'\nEXTERN char_u   *p_para;        // 'paragraphs'\nEXTERN int p_paste;             // 'paste'\nEXTERN char_u   *p_pt;          // 'pastetoggle'\nEXTERN char_u   *p_pex;         // 'patchexpr'\nEXTERN char_u   *p_pm;          // 'patchmode'\nEXTERN char_u   *p_path;        // 'path'\nEXTERN char_u   *p_cdpath;      // 'cdpath'\nEXTERN long p_pyx;              // 'pyxversion'\nEXTERN char_u *p_rdb;           // 'redrawdebug'\nEXTERN unsigned rdb_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_rdb_values[]) = {\n  \"compositor\",\n  \"nothrottle\",\n  \"invalid\",\n  \"nodelta\",\n  NULL\n};\n# endif\n# define RDB_COMPOSITOR         0x001\n# define RDB_NOTHROTTLE         0x002\n# define RDB_INVALID            0x004\n# define RDB_NODELTA            0x008\n\nEXTERN long p_rdt;              // 'redrawtime'\nEXTERN int p_remap;             // 'remap'\nEXTERN long p_re;               // 'regexpengine'\nEXTERN long p_report;           // 'report'\nEXTERN long p_pvh;              // 'previewheight'\nEXTERN int p_ari;               // 'allowrevins'\nEXTERN int p_ri;                // 'revins'\nEXTERN int p_ru;                // 'ruler'\nEXTERN char_u   *p_ruf;         // 'rulerformat'\nEXTERN char_u   *p_pp;          // 'packpath'\nEXTERN char_u   *p_qftf;        // 'quickfixtextfunc'\nEXTERN char_u   *p_rtp;         // 'runtimepath'\nEXTERN long p_scbk;             // 'scrollback'\nEXTERN long p_sj;               // 'scrolljump'\nEXTERN long p_so;               // 'scrolloff'\nEXTERN char_u   *p_sbo;         // 'scrollopt'\nEXTERN char_u   *p_sections;    // 'sections'\nEXTERN int p_secure;            // 'secure'\nEXTERN char_u   *p_sel;         // 'selection'\nEXTERN char_u   *p_slm;         // 'selectmode'\nEXTERN char_u   *p_ssop;        // 'sessionoptions'\nEXTERN unsigned ssop_flags;\n# ifdef IN_OPTION_C\n// Also used for 'viewoptions'!  Keep in sync with SSOP_ flags.\nstatic char *(p_ssop_values[]) = {\n  \"buffers\", \"winpos\", \"resize\", \"winsize\",\n  \"localoptions\", \"options\", \"help\", \"blank\", \"globals\", \"slash\", \"unix\",\n  \"sesdir\", \"curdir\", \"folds\", \"cursor\", \"tabpages\", \"terminal\", \"skiprtp\",\n  NULL\n};\n# endif\n# define SSOP_BUFFERS           0x001\n# define SSOP_WINPOS            0x002\n# define SSOP_RESIZE            0x004\n# define SSOP_WINSIZE           0x008\n# define SSOP_LOCALOPTIONS      0x010\n# define SSOP_OPTIONS           0x020\n# define SSOP_HELP              0x040\n# define SSOP_BLANK             0x080\n# define SSOP_GLOBALS           0x100\n# define SSOP_SLASH             0x200  // Deprecated, always set.\n# define SSOP_UNIX              0x400  // Deprecated, always set.\n# define SSOP_SESDIR            0x800\n# define SSOP_CURDIR            0x1000\n# define SSOP_FOLDS             0x2000\n# define SSOP_CURSOR            0x4000\n# define SSOP_TABPAGES          0x8000\n# define SSOP_TERMINAL          0x10000\n# define SSOP_SKIP_RTP          0x20000\n\nEXTERN char_u   *p_sh;          // 'shell'\nEXTERN char_u   *p_shcf;        // 'shellcmdflag'\nEXTERN char_u   *p_sp;          // 'shellpipe'\nEXTERN char_u   *p_shq;         // 'shellquote'\nEXTERN char_u   *p_sxq;         // 'shellxquote'\nEXTERN char_u   *p_sxe;         // 'shellxescape'\nEXTERN char_u   *p_srr;         // 'shellredir'\nEXTERN int p_stmp;              // 'shelltemp'\n#ifdef BACKSLASH_IN_FILENAME\nEXTERN int p_ssl;               // 'shellslash'\n#endif\nEXTERN char_u   *p_stl;         // 'statusline'\nEXTERN int p_sr;                // 'shiftround'\nEXTERN char_u   *p_shm;         // 'shortmess'\nEXTERN char_u   *p_sbr;         // 'showbreak'\nEXTERN int p_sc;                // 'showcmd'\nEXTERN int p_sft;               // 'showfulltag'\nEXTERN int p_sm;                // 'showmatch'\nEXTERN int p_smd;               // 'showmode'\nEXTERN long p_ss;               // 'sidescroll'\nEXTERN long p_siso;             // 'sidescrolloff'\nEXTERN int p_scs;               // 'smartcase'\nEXTERN int p_sta;               // 'smarttab'\nEXTERN int p_sb;                // 'splitbelow'\nEXTERN long p_tpm;              // 'tabpagemax'\nEXTERN char_u   *p_tal;         // 'tabline'\nEXTERN char_u   *p_tpf;         // 'termpastefilter'\nEXTERN unsigned int tpf_flags;  ///< flags from 'termpastefilter'\n#ifdef IN_OPTION_C\nstatic char *(p_tpf_values[]) =\n  { \"BS\", \"HT\", \"FF\", \"ESC\", \"DEL\", \"C0\", \"C1\", NULL };\n#endif\n# define TPF_BS                 0x001\n# define TPF_HT                 0x002\n# define TPF_FF                 0x004\n# define TPF_ESC                0x008\n# define TPF_DEL                0x010\n# define TPF_C0                 0x020\n# define TPF_C1                 0x040\nEXTERN char_u   *p_sps;         // 'spellsuggest'\nEXTERN int p_spr;               // 'splitright'\nEXTERN int p_sol;               // 'startofline'\nEXTERN char_u   *p_su;          // 'suffixes'\nEXTERN char_u   *p_swb;         // 'switchbuf'\nEXTERN unsigned swb_flags;\n#ifdef IN_OPTION_C\nstatic char *(p_swb_values[]) =\n  { \"useopen\", \"usetab\", \"split\", \"newtab\", \"vsplit\", \"uselast\", NULL };\n#endif\n#define SWB_USEOPEN             0x001\n#define SWB_USETAB              0x002\n#define SWB_SPLIT               0x004\n#define SWB_NEWTAB              0x008\n#define SWB_VSPLIT              0x010\n#define SWB_USELAST             0x020\nEXTERN int p_tbs;               ///< 'tagbsearch'\nEXTERN char_u *p_tc;            ///< 'tagcase'\nEXTERN unsigned tc_flags;       ///< flags from 'tagcase'\n#ifdef IN_OPTION_C\nstatic char *(p_tc_values[]) =\n  { \"followic\", \"ignore\", \"match\", \"followscs\", \"smart\", NULL };\n#endif\n#define TC_FOLLOWIC             0x01\n#define TC_IGNORE               0x02\n#define TC_MATCH                0x04\n#define TC_FOLLOWSCS            0x08\n#define TC_SMART                0x10\nEXTERN long p_tl;               ///< 'taglength'\nEXTERN int p_tr;                ///< 'tagrelative'\nEXTERN char_u *p_tags;          ///< 'tags'\nEXTERN int p_tgst;              ///< 'tagstack'\nEXTERN int p_tbidi;             ///< 'termbidi'\nEXTERN int p_terse;             ///< 'terse'\nEXTERN int p_to;                ///< 'tildeop'\nEXTERN int p_timeout;           ///< 'timeout'\nEXTERN long p_tm;               ///< 'timeoutlen'\nEXTERN int p_title;             ///< 'title'\nEXTERN long p_titlelen;         ///< 'titlelen'\nEXTERN char_u *p_titleold;      ///< 'titleold'\nEXTERN char_u *p_titlestring;   ///< 'titlestring'\nEXTERN char_u *p_tsr;           ///< 'thesaurus'\nEXTERN int p_tgc;               ///< 'termguicolors'\nEXTERN int p_ttimeout;          ///< 'ttimeout'\nEXTERN long p_ttm;              ///< 'ttimeoutlen'\nEXTERN char_u *p_udir;          ///< 'undodir'\nEXTERN long p_ul;               ///< 'undolevels'\nEXTERN long p_ur;               ///< 'undoreload'\nEXTERN long p_uc;               ///< 'updatecount'\nEXTERN long p_ut;               ///< 'updatetime'\nEXTERN char_u *p_fcs;           ///< 'fillchar'\nEXTERN char_u *p_shada;         ///< 'shada'\nEXTERN char *p_shadafile;       ///< 'shadafile'\nEXTERN char_u *p_vdir;          ///< 'viewdir'\nEXTERN char_u *p_vop;           ///< 'viewoptions'\nEXTERN unsigned vop_flags;      ///< uses SSOP_ flags\nEXTERN int p_vb;                ///< 'visualbell'\nEXTERN char_u *p_ve;            ///< 'virtualedit'\nEXTERN unsigned ve_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", NULL};\n# endif\n# define VE_BLOCK       5       // includes \"all\"\n# define VE_INSERT      6       // includes \"all\"\n# define VE_ALL         4\n# define VE_ONEMORE     8\nEXTERN long p_verbose;          // 'verbose'\n#ifdef IN_OPTION_C\nchar_u *p_vfile = (char_u *)\"\";   // used before options are initialized\n#else\nextern char_u   *p_vfile;       // 'verbosefile'\n#endif\nEXTERN int p_warn;              // 'warn'\nEXTERN char_u   *p_wop;         // 'wildoptions'\nEXTERN unsigned wop_flags;\n# ifdef IN_OPTION_C\nstatic char *(p_wop_values[]) =  { \"tagfile\", \"pum\", NULL };\n#endif\n#define WOP_TAGFILE             0x01\n#define WOP_PUM                 0x02\nEXTERN long p_window;           // 'window'\nEXTERN char_u   *p_wak;         // 'winaltkeys'\nEXTERN char_u   *p_wig;         // 'wildignore'\nEXTERN char_u   *p_ww;          // 'whichwrap'\nEXTERN long p_wc;               // 'wildchar'\nEXTERN long p_wcm;              // 'wildcharm'\nEXTERN int p_wic;               // 'wildignorecase'\nEXTERN char_u   *p_wim;         // 'wildmode'\nEXTERN int p_wmnu;              // 'wildmenu'\nEXTERN long p_wh;               // 'winheight'\nEXTERN long p_wmh;              // 'winminheight'\nEXTERN long p_wmw;              // 'winminwidth'\nEXTERN long p_wiw;              // 'winwidth'\nEXTERN int p_ws;                // 'wrapscan'\nEXTERN int p_write;             // 'write'\nEXTERN int p_wa;                // 'writeany'\nEXTERN int p_wb;                // 'writebackup'\nEXTERN long p_wd;               // 'writedelay'\n\nEXTERN int p_force_on;          ///< options that cannot be turned off.\nEXTERN int p_force_off;         ///< options that cannot be turned on.\n\n//\n// \"indir\" values for buffer-local options.\n// These need to be defined globally, so that the BV_COUNT can be used with\n// b_p_scriptID[].\n//\nenum {\n  BV_AI = 0\n  , BV_AR\n  , BV_BH\n  , BV_BKC\n  , BV_BT\n  , BV_EFM\n  , BV_GP\n  , BV_MP\n  , BV_BIN\n  , BV_BL\n  , BV_BOMB\n  , BV_CHANNEL\n  , BV_CI\n  , BV_CIN\n  , BV_CINK\n  , BV_CINO\n  , BV_CINW\n  , BV_CM\n  , BV_CMS\n  , BV_COM\n  , BV_CPT\n  , BV_DICT\n  , BV_TSR\n  , BV_CSL\n  , BV_CFU\n  , BV_DEF\n  , BV_INC\n  , BV_EOL\n  , BV_FIXEOL\n  , BV_EP\n  , BV_ET\n  , BV_FENC\n  , BV_FP\n  , BV_BEXPR\n  , BV_FEX\n  , BV_FF\n  , BV_FLP\n  , BV_FO\n  , BV_FT\n  , BV_IMI\n  , BV_IMS\n  , BV_INDE\n  , BV_INDK\n  , BV_INEX\n  , BV_INF\n  , BV_ISK\n  , BV_KMAP\n  , BV_KP\n  , BV_LISP\n  , BV_LW\n  , BV_MENC\n  , BV_MA\n  , BV_ML\n  , BV_MOD\n  , BV_MPS\n  , BV_NF\n  , BV_OFU\n  , BV_PATH\n  , BV_PI\n  , BV_QE\n  , BV_RO\n  , BV_SCBK\n  , BV_SI\n  , BV_SMC\n  , BV_SYN\n  , BV_SPC\n  , BV_SPF\n  , BV_SPL\n  , BV_SPO\n  , BV_STS\n  , BV_SUA\n  , BV_SW\n  , BV_SWF\n  , BV_TFU\n  , BV_TAGS\n  , BV_TC\n  , BV_TS\n  , BV_TW\n  , BV_TX\n  , BV_UDF\n  , BV_UL\n  , BV_WM\n  , BV_VSTS\n  , BV_VTS\n  , BV_COUNT        // must be the last one\n};\n\n/*\n * \"indir\" values for window-local options.\n * These need to be defined globally, so that the WV_COUNT can be used in the\n * window structure.\n */\nenum {\n  WV_LIST = 0\n  , WV_ARAB\n  , WV_COCU\n  , WV_COLE\n  , WV_CRBIND\n  , WV_BRI\n  , WV_BRIOPT\n  , WV_DIFF\n  , WV_FDC\n  , WV_FEN\n  , WV_FDI\n  , WV_FDL\n  , WV_FDM\n  , WV_FML\n  , WV_FDN\n  , WV_FDE\n  , WV_FDT\n  , WV_FMR\n  , WV_LBR\n  , WV_NU\n  , WV_RNU\n  , WV_NUW\n  , WV_PVW\n  , WV_RL\n  , WV_RLC\n  , WV_SCBIND\n  , WV_SCROLL\n  , WV_SISO\n  , WV_SO\n  , WV_SPELL\n  , WV_CUC\n  , WV_CUL\n  , WV_CULOPT\n  , WV_CC\n  , WV_STL\n  , WV_WFH\n  , WV_WFW\n  , WV_WRAP\n  , WV_SCL\n  , WV_WINHL\n  , WV_FCS\n  , WV_LCS\n  , WV_WINBL\n  , WV_COUNT        // must be the last one\n};\n\n// Value for b_p_ul indicating the global value must be used.\n#define NO_LOCAL_UNDOLEVEL -123456\n\n#define SB_MAX 100000  // Maximum 'scrollback' value.\n\n/// Stores an identifier of a script or channel that last set an option.\ntypedef struct {\n  sctx_T script_ctx;       /// script context where the option was last set\n  uint64_t channel_id;     /// Only used when script_id is SID_API_CLIENT.\n} LastSet;\n\n#endif // NVIM_OPTION_DEFS_H\n"}, "19": {"id": 19, "path": "src/nvim/rbuffer.h", "content": "// Specialized ring buffer. This is basically an array that wraps read/write\n// pointers around the memory region. It should be more efficient than the old\n// RBuffer which required memmove() calls to relocate read/write positions.\n//\n// The main purpose of RBuffer is simplify memory management when reading from\n// uv_stream_t instances:\n//\n// - The event loop writes data to a RBuffer, advancing the write pointer\n// - The main loop reads data, advancing the read pointer\n// - If the buffer becomes full(size == capacity) the rstream is temporarily\n//   stopped(automatic backpressure handling)\n//\n// Reference: http://en.wikipedia.org/wiki/Circular_buffer\n#ifndef NVIM_RBUFFER_H\n#define NVIM_RBUFFER_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n// Macros that simplify working with the read/write pointers directly by hiding\n// ring buffer wrap logic. Some examples:\n//\n// - Pass the write pointer to a function(write_data) that incrementally\n//   produces data, returning the number of bytes actually written to the\n//   ring buffer:\n//\n//       RBUFFER_UNTIL_FULL(rbuf, ptr, cnt)\n//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));\n//\n// - Pass the read pointer to a function(read_data) that incrementally\n//   consumes data, returning the number of bytes actually read from the\n//   ring buffer:\n//\n//       RBUFFER_UNTIL_EMPTY(rbuf, ptr, cnt)\n//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));\n//\n// Note that the rbuffer_{produced,consumed} calls are necessary or these macros\n// create infinite loops\n#define RBUFFER_UNTIL_EMPTY(buf, rptr, rcnt) \\\n  for (size_t rcnt = 0, _r = 1; _r; _r = 0)  /* NOLINT(readability/braces) */ \\\n    for (  /* NOLINT(readability/braces) */ \\\n        char *rptr = rbuffer_read_ptr(buf, &rcnt); \\\n        buf->size; \\\n        rptr = rbuffer_read_ptr(buf, &rcnt))\n\n#define RBUFFER_UNTIL_FULL(buf, wptr, wcnt) \\\n  for (size_t wcnt = 0, _r = 1; _r; _r = 0)  /* NOLINT(readability/braces) */ \\\n    for (  /* NOLINT(readability/braces) */ \\\n        char *wptr = rbuffer_write_ptr(buf, &wcnt); \\\n        rbuffer_space(buf); \\\n        wptr = rbuffer_write_ptr(buf, &wcnt))\n\n\n// Iteration\n#define RBUFFER_EACH(buf, c, i) \\\n  for (size_t i = 0;  /* NOLINT(readability/braces) */ \\\n       i < buf->size; \\\n       i = buf->size) \\\n      for (char c = 0;  /* NOLINT(readability/braces) */ \\\n           i < buf->size ? ((int)(c = *rbuffer_get(buf, i))) || 1 : 0; \\\n           i++)\n\n#define RBUFFER_EACH_REVERSE(buf, c, i) \\\n  for (size_t i = buf->size;  /* NOLINT(readability/braces) */ \\\n       i != SIZE_MAX; \\\n       i = SIZE_MAX) \\\n      for (char c = 0;  /* NOLINT(readability/braces) */ \\\n           i-- > 0 ? ((int)(c = *rbuffer_get(buf, i))) || 1 : 0; \\\n           )\n\ntypedef struct rbuffer RBuffer;\n/// Type of function invoked during certain events:\n///   - When the RBuffer switches to the full state\n///   - When the RBuffer switches to the non-full state\ntypedef void(*rbuffer_callback)(RBuffer *buf, void *data);\n\nstruct rbuffer {\n  rbuffer_callback full_cb, nonfull_cb;\n  void *data;\n  size_t size;\n  // helper memory used to by rbuffer_reset if required\n  char *temp;\n  char *end_ptr, *read_ptr, *write_ptr;\n  char start_ptr[];\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"rbuffer.h.generated.h\"\n#endif\n\n#endif  // NVIM_RBUFFER_H\n"}, "20": {"id": 20, "path": "src/nvim/regexp_defs.h", "content": "/*\n * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE\n *\n * This is NOT the original regular expression code as written by Henry\n * Spencer.  This code has been modified specifically for use with Vim, and\n * should not be used apart from compiling Vim.  If you want a good regular\n * expression library, get the original code.\n *\n * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE\n */\n\n#ifndef NVIM_REGEXP_DEFS_H\n#define NVIM_REGEXP_DEFS_H\n\n#include <stdbool.h>\n\n#include \"nvim/pos.h\"\n#include \"nvim/types.h\"\n#include \"nvim/profile.h\"\n\n/*\n * The number of sub-matches is limited to 10.\n * The first one (index 0) is the whole match, referenced with \"\\0\".\n * The second one (index 1) is the first sub-match, referenced with \"\\1\".\n * This goes up to the tenth (index 9), referenced with \"\\9\".\n */\n#define NSUBEXP  10\n\n/*\n * In the NFA engine: how many braces are allowed.\n * TODO(RE): Use dynamic memory allocation instead of static, like here\n */\n#define NFA_MAX_BRACES 20\n\n// In the NFA engine: how many states are allowed.\n#define NFA_MAX_STATES 100000\n#define NFA_TOO_EXPENSIVE -1\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\n#define AUTOMATIC_ENGINE    0\n#define BACKTRACKING_ENGINE 1\n#define NFA_ENGINE          2\n\ntypedef struct regengine regengine_T;\ntypedef struct regprog regprog_T;\ntypedef struct reg_extmatch reg_extmatch_T;\n\n/// Structure to be used for multi-line matching.\n/// Sub-match \"no\" starts in line \"startpos[no].lnum\" column \"startpos[no].col\"\n/// and ends in line \"endpos[no].lnum\" just before column \"endpos[no].col\".\n/// The line numbers are relative to the first line, thus startpos[0].lnum is\n/// always 0.\n/// When there is no match, the line number is -1.\ntypedef struct {\n  regprog_T           *regprog;\n  lpos_T startpos[NSUBEXP];\n  lpos_T endpos[NSUBEXP];\n  int rmm_ic;\n  colnr_T rmm_maxcol;  /// when not zero: maximum column\n} regmmatch_T;\n\n#include \"nvim/buffer_defs.h\"\n\n/*\n * Structure returned by vim_regcomp() to pass on to vim_regexec().\n * This is the general structure. For the actual matcher, two specific\n * structures are used. See code below.\n */\nstruct regprog {\n  regengine_T *engine;\n  unsigned regflags;\n  unsigned re_engine;  ///< Automatic, backtracking or NFA engine.\n  unsigned re_flags;   ///< Second argument for vim_regcomp().\n  bool re_in_use;      ///< prog is being executed\n};\n\n/*\n * Structure used by the back track matcher.\n * These fields are only to be used in regexp.c!\n * See regexp.c for an explanation.\n */\ntypedef struct {\n  // These four members implement regprog_T.\n  regengine_T *engine;\n  unsigned regflags;\n  unsigned re_engine;\n  unsigned re_flags;\n  bool re_in_use;\n\n  int regstart;\n  char_u reganch;\n  char_u              *regmust;\n  int regmlen;\n  char_u reghasz;\n  char_u program[1];                    // actually longer..\n} bt_regprog_T;\n\n// Structure representing a NFA state.\n// An NFA state may have no outgoing edge, when it is a NFA_MATCH state.\ntypedef struct nfa_state nfa_state_T;\nstruct nfa_state {\n  int c;\n  nfa_state_T         *out;\n  nfa_state_T         *out1;\n  int id;\n  int lastlist[2];                   // 0: normal, 1: recursive\n  int val;\n};\n\n/*\n * Structure used by the NFA matcher.\n */\ntypedef struct {\n  // These four members implement regprog_T.\n  regengine_T *engine;\n  unsigned regflags;\n  unsigned re_engine;\n  unsigned re_flags;\n  bool re_in_use;\n\n  nfa_state_T         *start;           // points into state[]\n\n  int reganch;                          // pattern starts with ^\n  int regstart;                         // char at start of pattern\n  char_u              *match_text;      // plain text to match with\n\n  int has_zend;                         // pattern contains \\ze\n  int has_backref;                      // pattern contains \\1 .. \\9\n  int reghasz;\n  char_u              *pattern;\n  int nsubexp;                          // number of ()\n  int nstate;\n  nfa_state_T state[1];                 // actually longer..\n} nfa_regprog_T;\n\n/*\n * Structure to be used for single-line matching.\n * Sub-match \"no\" starts at \"startp[no]\" and ends just before \"endp[no]\".\n * When there is no match, the pointer is NULL.\n */\ntypedef struct {\n  regprog_T           *regprog;\n  char_u              *startp[NSUBEXP];\n  char_u              *endp[NSUBEXP];\n  bool                 rm_ic;\n} regmatch_T;\n\n/*\n * Structure used to store external references: \"\\z\\(\\)\" to \"\\z\\1\".\n * Use a reference count to avoid the need to copy this around.  When it goes\n * from 1 to zero the matches need to be freed.\n */\nstruct reg_extmatch {\n  int16_t refcnt;\n  char_u              *matches[NSUBEXP];\n};\n\nstruct regengine {\n  regprog_T   *(*regcomp)(char_u *, int);\n  void (*regfree)(regprog_T *);\n  int (*regexec_nl)(regmatch_T *, char_u *, colnr_T, bool);\n  long (*regexec_multi)(regmmatch_T *, win_T *, buf_T *, linenr_T, colnr_T,\n                        proftime_T *, int *);\n  char_u      *expr;\n};\n\n#endif  // NVIM_REGEXP_DEFS_H\n"}, "21": {"id": 21, "path": "src/nvim/strings.h", "content": "#ifndef NVIM_STRINGS_H\n#define NVIM_STRINGS_H\n\n#include <stdbool.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"nvim/types.h\"\n#include \"nvim/eval/typval.h\"\n\n/// Append string to string and return pointer to the next byte\n///\n/// Unlike strcat, this one does *not* add NUL byte and returns pointer to the\n/// past of the added string.\n///\n/// @param[out]  dst  String to append to.\n/// @param[in]  src  String to append.\n///\n/// @return pointer to the byte just past the appended byte.\nstatic inline char *strappend(char *const dst, const char *const src)\n  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n  FUNC_ATTR_NONNULL_RET\n{\n  const size_t src_len = strlen(src);\n  return (char *)memmove(dst, src, src_len) + src_len;\n}\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"strings.h.generated.h\"\n#endif\n#endif  // NVIM_STRINGS_H\n"}, "22": {"id": 22, "path": "src/nvim/syntax_defs.h", "content": "#ifndef NVIM_SYNTAX_DEFS_H\n#define NVIM_SYNTAX_DEFS_H\n\n#include \"nvim/highlight_defs.h\"\n\n# define SST_MIN_ENTRIES 150    /* minimal size for state stack array */\n# define SST_MAX_ENTRIES 1000   /* maximal size for state stack array */\n# define SST_FIX_STATES  7      /* size of sst_stack[]. */\n# define SST_DIST        16     /* normal distance between entries */\n# define SST_INVALID    (synstate_T *)-1        /* invalid syn_state pointer */\n\ntypedef struct syn_state synstate_T;\n\n#include \"nvim/buffer_defs.h\"\n#include \"nvim/regexp_defs.h\"\n\n/* struct passed to in_id_list() */\nstruct sp_syn {\n  int inc_tag;                  // \":syn include\" unique tag\n  int16_t id;                   // highlight group ID of item\n  int16_t *cont_in_list;        // cont.in group IDs, if non-zero\n};\n\n/*\n * Each keyword has one keyentry, which is linked in a hash list.\n */\ntypedef struct keyentry keyentry_T;\n\nstruct keyentry {\n  keyentry_T  *ke_next;         // next entry with identical \"keyword[]\"\n  struct sp_syn k_syn;          // struct passed to in_id_list()\n  int16_t *next_list;           // ID list for next match (if non-zero)\n  int flags;\n  int k_char;                   // conceal substitute character\n  char_u keyword[1];            // actually longer\n};\n\n/*\n * Struct used to store one state of the state stack.\n */\ntypedef struct buf_state {\n  int bs_idx;                    /* index of pattern */\n  int bs_flags;                  /* flags for pattern */\n  int bs_seqnr;                  /* stores si_seqnr */\n  int bs_cchar;                  /* stores si_cchar */\n  reg_extmatch_T *bs_extmatch;   /* external matches from start pattern */\n} bufstate_T;\n\n/*\n * syn_state contains the syntax state stack for the start of one line.\n * Used by b_sst_array[].\n */\nstruct syn_state {\n  synstate_T  *sst_next;        /* next entry in used or free list */\n  linenr_T sst_lnum;            /* line number for this state */\n  union {\n    bufstate_T sst_stack[SST_FIX_STATES];          /* short state stack */\n    garray_T sst_ga;            /* growarray for long state stack */\n  } sst_union;\n  int sst_next_flags;           // flags for sst_next_list\n  int sst_stacksize;            // number of states on the stack\n  int16_t *sst_next_list;       // \"nextgroup\" list in this state\n                                // (this is a copy, don't free it!\n  disptick_T sst_tick;          // tick when last displayed\n  linenr_T sst_change_lnum;     // when non-zero, change in this line\n                                // may have made the state invalid\n};\n\n#endif // NVIM_SYNTAX_DEFS_H\n"}, "23": {"id": 23, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 15, "file": 0, "line": 18}, "message": "hash_key_removed (fixit)"}, {"location": {"col": 15, "file": 0, "line": 18}, "message": "declaration uses identifier '_hash_key_removed', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "build/include/hashtab.h.generated.h", "reportHash": "61aac78b137aa52fa8b00aa6910e6633", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 0, "line": 18}, "message": "hash_key_removed (fixit)"}, {"location": {"col": 15, "file": 0, "line": 18}, "message": "declaration uses identifier '_hash_key_removed', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "build/include/hashtab.h.generated.h", "reportHash": "094a2c18ef8b7238b8a061c2859f8703", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 0, "line": 18}, "message": "hash_key_removed (fixit)"}, {"location": {"col": 15, "file": 0, "line": 18}, "message": "declaration uses identifier '_hash_key_removed', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "build/include/hashtab.h.generated.h", "reportHash": "a64a45220077e66f2573ffca22226308", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 1, "line": 18}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 1, "line": 18}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "f27d37e0c686dd5a90b49f5290a3862c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 1, "line": 23}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 1, "line": 23}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "7004372a077819b77d743281f7157213", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 1, "line": 27}, "message": "() (fixit)"}, {"location": {"col": 22, "file": 1, "line": 27}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "8135d47d7876bf78e717add67f6f9499", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 1, "line": 31}, "message": "() (fixit)"}, {"location": {"col": 20, "file": 1, "line": 31}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "18fcc16f1a34a38a3b832a83984dfe0a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 1, "line": 37}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 1, "line": 37}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "0d5cc424e3ee44f108e589a7238e58f0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 1, "line": 41}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 1, "line": 41}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "0d5cc424e3ee44f108e589a7238e58f0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 1, "line": 45}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 1, "line": 45}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "0d5cc424e3ee44f108e589a7238e58f0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 1, "line": 49}, "message": "() (fixit)"}, {"location": {"col": 19, "file": 1, "line": 49}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "6f407919158db62bff3e9775cceceb79", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 1, "line": 53}, "message": "() (fixit)"}, {"location": {"col": 24, "file": 1, "line": 53}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "1ac306d2c32d1e02d81b3b24b885ed0a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 1, "line": 57}, "message": "() (fixit)"}, {"location": {"col": 20, "file": 1, "line": 57}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "b23154c38878929f815132c3deb28166", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 70, "file": 1, "line": 63}, "message": "() (fixit)"}, {"location": {"col": 70, "file": 1, "line": 63}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "d748ffe231d1f54fd3c500efcf400fa9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 1, "line": 73}, "message": "(   ) (fixit)"}, {"location": {"col": 3, "file": 1, "line": 73}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "5f332a471bab2972886ad2af89554327", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 1, "line": 74}, "message": "(   ) (fixit)"}, {"location": {"col": 3, "file": 1, "line": 74}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "017633a5deffa8f478a919e9c1493288", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 53, "file": 1, "line": 76}, "message": "() (fixit)"}, {"location": {"col": 53, "file": 1, "line": 76}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/api/private/helpers.h", "reportHash": "0ca2ee175e3e5851ff36b183eaa10787", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 49}, "message": "(  ) (fixit)"}, {"location": {"col": 26, "file": 2, "line": 49}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/buffer_defs.h", "reportHash": "4b0f74a8ae4936cd200cdf0fd867d9f5", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 2, "line": 657}, "message": "( ) (fixit)"}, {"location": {"col": 28, "file": 2, "line": 657}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/buffer_defs.h", "reportHash": "c6547e1b1ace074ba047c6ce81c432dd", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 34, "file": 2, "line": 1401}, "message": "() (fixit)"}, {"location": {"col": 34, "file": 2, "line": 1401}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/buffer_defs.h", "reportHash": "1d64a483578d3ff333c08947078a1980", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 3, "line": 748}, "message": "TV_LIST_ITER_MOD (fixit)"}, {"location": {"col": 9, "file": 3, "line": 748}, "message": "declaration uses identifier '_TV_LIST_ITER_MOD', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "3211cd9c03c0527d99e89229af6c7823", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 748}, "message": "TV_LIST_ITER_MOD (fixit)"}, {"location": {"col": 9, "file": 3, "line": 748}, "message": "declaration uses identifier '_TV_LIST_ITER_MOD', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "5fd5b405de82102e738b0eb32aeb3f44", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 748}, "message": "TV_LIST_ITER_MOD (fixit)"}, {"location": {"col": 9, "file": 3, "line": 748}, "message": "declaration uses identifier '_TV_LIST_ITER_MOD', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "116ccc6223b1a52cf5368708f6b1fff2", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 35, "file": 3, "line": 753}, "message": "( ) (fixit)"}, {"location": {"col": 35, "file": 3, "line": 753}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "11bbcc98254e2c5814da1160e506e23d", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 3, "line": 754}, "message": "( ) (fixit)"}, {"location": {"col": 14, "file": 3, "line": 754}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "06af9dea2c378e3c732cdd49a48ff398", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 3, "line": 754}, "message": "( ) (fixit)"}, {"location": {"col": 26, "file": 3, "line": 754}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "625d152e0a21ec505b5439f58c641826", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 3, "line": 754}, "message": "( ) (fixit)"}, {"location": {"col": 31, "file": 3, "line": 754}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval/typval.h", "reportHash": "70940c679a3520f63533934a3c963633", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 4, "line": 18}, "message": "() (fixit)"}, {"location": {"col": 12, "file": 4, "line": 18}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/event/defs.h", "reportHash": "521e63714ad73a27d7d262c12d0d9e68", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 4, "line": 23}, "message": "() (fixit)"}, {"location": {"col": 27, "file": 4, "line": 23}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/event/defs.h", "reportHash": "a3e971758a85e77d9d646dd9dd19e253", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 5, "line": 79}, "message": "(         ) (fixit)"}, {"location": {"col": 9, "file": 5, "line": 79}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/event/loop.h", "reportHash": "31c87c167164c173f917e8e5228af916", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 6, "line": 88}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 6, "line": 88}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/ex_cmds_defs.h", "reportHash": "17c392e6f09d46986b021fc25a063716", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 6, "line": 89}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 6, "line": 89}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/ex_cmds_defs.h", "reportHash": "38496bd8ca343ff45f176d4d020c7f64", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 8, "line": 60}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 8, "line": 60}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/getchar.h", "reportHash": "e9999a5c349bfcb510a1b245069ebaba", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 8, "line": 61}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 8, "line": 61}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/getchar.h", "reportHash": "696408a8700c4e20e103c4fa59f897b5", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 9, "line": 6}, "message": "declaration uses identifier '_', which is reserved in the global namespace; cannot be fixed automatically"}], "macros": [], "notes": [], "path": "src/nvim/gettext.h", "reportHash": "c940bea1880699975b87b87c8404fa8d", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 9, "line": 6}, "message": "declaration uses identifier '_', which is reserved in the global namespace; cannot be fixed automatically"}], "macros": [], "notes": [], "path": "src/nvim/gettext.h", "reportHash": "737e42fd9b97b981ab082dc993a551ea", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 9, "line": 6}, "message": "declaration uses identifier '_', which is reserved in the global namespace; cannot be fixed automatically"}], "macros": [], "notes": [], "path": "src/nvim/gettext.h", "reportHash": "132e4edce519d61547e33dad23a00687", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 10, "line": 26}, "message": "PATHSEPSTR (fixit)"}, {"location": {"col": 10, "file": 10, "line": 26}, "message": "declaration uses identifier '_PATHSEPSTR', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "839ab660fbf1573ad54c64eec6d0d93a", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 10, "line": 26}, "message": "PATHSEPSTR (fixit)"}, {"location": {"col": 10, "file": 10, "line": 26}, "message": "declaration uses identifier '_PATHSEPSTR', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "ca44985bdaba8c461772204fee5a2194", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 10, "line": 26}, "message": "PATHSEPSTR (fixit)"}, {"location": {"col": 10, "file": 10, "line": 26}, "message": "declaration uses identifier '_PATHSEPSTR', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "050b200aed4f00646dc81d0c0632dd2f", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 10, "line": 329}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 329}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "c75d77995a7d4fd72c3ae69c8db3a997", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 330}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 330}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "5051776c64f190e09e45ddcce1437dba", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 331}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 331}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "1f73a3522c9250bff1b5119b13fac10a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 332}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 332}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "a3f08b0bc526f52849833d6f7817f059", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 333}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 333}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "e7f78cc4874b3cc3241677e1571b9e0c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 334}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 334}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "9417b242cd20fa396ca92d467202c3e3", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 335}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 335}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "6a29ec5acb99cd67d465d7db484939b2", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 336}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 336}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "60aa98715050fbab85b53294854bc10b", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 337}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 337}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "bd2bfa1c6a920876882c85041bf21e36", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 338}, "message": "(  ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 338}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "3304d25a0efe33482593e3573ca34b70", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 10, "line": 435}, "message": "( ) (fixit)"}, {"location": {"col": 15, "file": 10, "line": 435}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "bbff397404a1596dd21abb1ac7aff063", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 47, "file": 10, "line": 436}, "message": "( ) (fixit)"}, {"location": {"col": 47, "file": 10, "line": 436}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "399ff9015c267d2877ff6fe7d79d7cc5", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 59, "file": 10, "line": 436}, "message": "( ) (fixit)"}, {"location": {"col": 59, "file": 10, "line": 436}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "353d30733175013a97d45612fab78c44", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 10, "line": 436}, "message": "( ) (fixit)"}, {"location": {"col": 64, "file": 10, "line": 436}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "73bb0538dd6dd5f8dc4d0ba6884c2839", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 43, "file": 10, "line": 455}, "message": "( ) (fixit)"}, {"location": {"col": 43, "file": 10, "line": 455}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "1ca79c3e623f2301559f660094da3485", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 63, "file": 10, "line": 455}, "message": "( ) (fixit)"}, {"location": {"col": 63, "file": 10, "line": 455}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "b3e9210e1fee4356bca24e19004429bd", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 75, "file": 10, "line": 455}, "message": "( ) (fixit)"}, {"location": {"col": 75, "file": 10, "line": 455}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "02953b7dfa48f8a3dc0a4291122f421a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 80, "file": 10, "line": 455}, "message": "( ) (fixit)"}, {"location": {"col": 80, "file": 10, "line": 455}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "50be909a7738576646ed638d9b46112e", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 10, "line": 465}, "message": "(  ) (fixit)"}, {"location": {"col": 15, "file": 10, "line": 465}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "344c2197258fca0a5701917b51fc1d73", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 10, "line": 465}, "message": "(  ) (fixit)"}, {"location": {"col": 31, "file": 10, "line": 465}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "0c2cd47fd9cbbb7f751c4667b043115a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 44, "file": 10, "line": 465}, "message": "(  ) (fixit)"}, {"location": {"col": 44, "file": 10, "line": 465}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "c3e87a0d578f2ce586d93b7eeab2aecc", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 50, "file": 10, "line": 465}, "message": "(  ) (fixit)"}, {"location": {"col": 50, "file": 10, "line": 465}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "4604e7c84fda4f72842994d7e89fde07", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 10, "line": 467}, "message": "(  ) (fixit)"}, {"location": {"col": 15, "file": 10, "line": 467}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "c485eadff53c44d12e971025c82f7e77", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 10, "line": 467}, "message": "(  ) (fixit)"}, {"location": {"col": 30, "file": 10, "line": 467}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "f17e2ed84e372dde41c13cc0ac85e784", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 43, "file": 10, "line": 467}, "message": "(  ) (fixit)"}, {"location": {"col": 43, "file": 10, "line": 467}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "c38942e50ff32c02e2d03ec5dc73735f", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 10, "line": 467}, "message": "(  ) (fixit)"}, {"location": {"col": 49, "file": 10, "line": 467}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "838bb6e9bdd4a4a56e15a28c075ad9f0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 10, "line": 605}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 10, "line": 605}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/globals.h", "reportHash": "6a54fbe12e4d4b1599a6c7b811e0a773", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 11, "line": 83}, "message": "( ) (fixit)"}, {"location": {"col": 24, "file": 11, "line": 83}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/hashtab.h", "reportHash": "3be9642c260c06172ee8dd2bddd82fda", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 59, "file": 11, "line": 83}, "message": "( ) (fixit)"}, {"location": {"col": 59, "file": 11, "line": 83}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/hashtab.h", "reportHash": "65b273a7d15474eed9a126c6541412db", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 13, "line": 27}, "message": "AC_KLIST_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 27}, "message": "declaration uses identifier '_AC_KLIST_H', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "6be471d52a4d4b76edcb6c284d8f572e", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 27}, "message": "AC_KLIST_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 27}, "message": "declaration uses identifier '_AC_KLIST_H', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "6e8c64475d07b608a0c71bfd54742e57", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 27}, "message": "AC_KLIST_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 27}, "message": "declaration uses identifier '_AC_KLIST_H', which is a reserved identifier"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "3259c53eb7f0bd8f56b164c1ce35f307", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 39}, "message": "(        ) (fixit)"}, {"location": {"col": 9, "file": 13, "line": 39}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "4856a38b64c4bbd73529d7fe019483d4", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 13, "line": 53}, "message": "(        ) (fixit)"}, {"location": {"col": 19, "file": 13, "line": 53}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "246d63f65497eb3c8f17742163d9f6be", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 60, "file": 13, "line": 60}, "message": "(        ) (fixit)"}, {"location": {"col": 60, "file": 13, "line": 60}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "6d3bf5810d80028d016f40b7ae7936b0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 51, "file": 13, "line": 137}, "message": "( ) (fixit)"}, {"location": {"col": 51, "file": 13, "line": 137}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "be9454de698be96aa2e3b729724f554f", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 21, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "f044398bb7fc94891aa1d9e1c5be5b69", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 25, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "11160fa0284fba68c58478cc976f1108", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 29, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "e81549f207aca6de747a21ae4861e64b", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 34, "file": 13, "line": 143}, "message": "( ) (fixit)"}, {"location": {"col": 34, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "d0e051719f1b0da0d8625b12afe7e71e", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 45, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 45, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "9ed4cd4d823c348d9e9e875893256f50", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 50, "file": 13, "line": 143}, "message": "( ) (fixit)"}, {"location": {"col": 50, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "92fc9fed28df7aa8f2e796fcd0c49771", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 60, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 60, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "a42581aeabeaba59a8dbc160c1f33eac", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 67, "file": 13, "line": 143}, "message": "() (fixit)"}, {"location": {"col": 67, "file": 13, "line": 143}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/klist.h", "reportHash": "4f471ce8852539535fe37cb5c9552607", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 15, "line": 27}, "message": "queue (fixit)"}, {"location": {"col": 16, "file": 15, "line": 27}, "message": "declaration uses identifier '_queue', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "src/nvim/lib/queue.h", "reportHash": "12302610655c9d6c031bfdb2b0fc2471", "checkerName": "bugprone-reserved-identifier", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 15, "line": 27}, "message": "queue (fixit)"}, {"location": {"col": 16, "file": 15, "line": 27}, "message": "declaration uses identifier '_queue', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "src/nvim/lib/queue.h", "reportHash": "cc8d34c747d5f541d7113a454a5409ca", "checkerName": "cert-dcl37-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 15, "line": 27}, "message": "queue (fixit)"}, {"location": {"col": 16, "file": 15, "line": 27}, "message": "declaration uses identifier '_queue', which is reserved in the global namespace"}], "macros": [], "notes": [], "path": "src/nvim/lib/queue.h", "reportHash": "9f25ed9e4cac4a44b4c462d932eaa527", "checkerName": "cert-dcl51-cpp", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 15, "line": 42}, "message": "() (fixit)"}, {"location": {"col": 19, "file": 15, "line": 42}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/lib/queue.h", "reportHash": "082e809e86062a15b7cc4ee2f754e4d9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 18, "line": 58}, "message": "( ) (fixit)"}, {"location": {"col": 25, "file": 18, "line": 58}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/option_defs.h", "reportHash": "651d13f26b7b0ac1f2c4cc63cc6be52b", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 18, "line": 893}, "message": "(      ) (fixit)"}, {"location": {"col": 28, "file": 18, "line": 893}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/option_defs.h", "reportHash": "6096317f61970bda3ec4d9671ca214c4", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 19, "line": 42}, "message": "(   ) (fixit)"}, {"location": {"col": 15, "file": 19, "line": 42}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "8eb446ceb04b038bf4c879aa35c06d9a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 45, "file": 19, "line": 42}, "message": "(   ) (fixit)"}, {"location": {"col": 45, "file": 19, "line": 42}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "e1dc64723d09b44e0d2f002719c253b4", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 19, "line": 43}, "message": "(  ) (fixit)"}, {"location": {"col": 9, "file": 19, "line": 43}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "bd9ddd9a235d40a9d47efa290b7b1c40", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 19, "line": 44}, "message": "(   ) (fixit)"}, {"location": {"col": 9, "file": 19, "line": 44}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "5e9993c22529fb56176198818accd46b", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 19, "line": 44}, "message": "(   ) (fixit)"}, {"location": {"col": 39, "file": 19, "line": 44}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "c2a0665d727be73758856988be2e6676", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 19, "line": 49}, "message": "(   ) (fixit)"}, {"location": {"col": 15, "file": 19, "line": 49}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "6f622a5f6d192a09172ad9a18ef46985", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 46, "file": 19, "line": 49}, "message": "(   ) (fixit)"}, {"location": {"col": 46, "file": 19, "line": 49}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "cd072fe7c5dcb23ca2123c5e505e3c6f", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 19, "line": 51}, "message": "(   ) (fixit)"}, {"location": {"col": 9, "file": 19, "line": 51}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "b188fc507cd36c8a6feb8dcfec0aef7d", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 40, "file": 19, "line": 51}, "message": "(   ) (fixit)"}, {"location": {"col": 40, "file": 19, "line": 51}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "3dd222acb70efdb27313dcb259945adb", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 19, "line": 57}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 19, "line": 57}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "9d76b9554e6f8e860fe9b0289a03cf21", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 19, "line": 57}, "message": "(  ) (fixit)"}, {"location": {"col": 12, "file": 19, "line": 57}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "98e70c50162fce70b3c404c7aa2c3b06", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 19, "line": 58}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 19, "line": 58}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "9fcee8889e0a78f91303a3415d12f178", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 19, "line": 58}, "message": "(  ) (fixit)"}, {"location": {"col": 12, "file": 19, "line": 58}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "a55c7f45c895a9fca0e13afc9aba750e", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 19, "line": 59}, "message": "() (fixit)"}, {"location": {"col": 17, "file": 19, "line": 59}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "ac0f7d342b78b517ee5503cb75dc5c7c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 19, "line": 60}, "message": "() (fixit)"}, {"location": {"col": 12, "file": 19, "line": 60}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "18de0acd6c0e9a772364fd28a9fd569c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 19, "line": 60}, "message": "(  ) (fixit)"}, {"location": {"col": 16, "file": 19, "line": 60}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "81cf705f2544b8bc7bfef34d3fb22146", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 19, "line": 60}, "message": "() (fixit)"}, {"location": {"col": 35, "file": 19, "line": 60}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "7c4088792cba9fa54df93521d19d2bb3", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 19, "line": 61}, "message": "() (fixit)"}, {"location": {"col": 12, "file": 19, "line": 61}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "2d43fd62a23bad9cf2d271845f25f20e", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 19, "line": 64}, "message": "(  ) (fixit)"}, {"location": {"col": 19, "file": 19, "line": 64}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "784f8fa97ec35540dec5da9b11ea189f", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 19, "line": 65}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 19, "line": 65}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "6623f9e3917821a867e188d86905aa69", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 19, "line": 66}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 19, "line": 66}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "5beb12fa936da4af5866dd873ad11c51", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 19, "line": 67}, "message": "() (fixit)"}, {"location": {"col": 17, "file": 19, "line": 67}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "ac0f7d342b78b517ee5503cb75dc5c7c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 19, "line": 68}, "message": "() (fixit)"}, {"location": {"col": 12, "file": 19, "line": 68}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "ae47c41aef3aaee728c25e1e8d727ad9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 19, "line": 68}, "message": "() (fixit)"}, {"location": {"col": 29, "file": 19, "line": 68}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/rbuffer.h", "reportHash": "fe26865f1bb5ef47aba930078b27fc7e", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 20, "line": 37}, "message": "( ) (fixit)"}, {"location": {"col": 27, "file": 20, "line": 37}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp_defs.h", "reportHash": "338629c05976d39af9ba2687d3959a75", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 44, "file": 21, "line": 25}, "message": "+ 1 (fixit)"}, {"location": {"col": 18, "file": 21, "line": 25}, "message": "the result from calling 'memmove' is not null-terminated"}], "macros": [], "notes": [], "path": "src/nvim/strings.h", "reportHash": "a42a34005717b89ed9e3cbcb05b8437b", "checkerName": "bugprone-not-null-terminated-result", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 22, "line": 10}, "message": "(               ) (fixit)"}, {"location": {"col": 39, "file": 22, "line": 10}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/syntax_defs.h", "reportHash": "c9cf94887f177666052de8d6595d5f31", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 23, "line": 328}, "message": "( ) (fixit)"}, {"location": {"col": 29, "file": 23, "line": 328}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/vim.h", "reportHash": "da3a8e201fa1c600d81626a407d38436", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 23, "line": 329}, "message": "( ) (fixit)"}, {"location": {"col": 29, "file": 23, "line": 329}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/vim.h", "reportHash": "a011442822101e8610bba03f6a84465f", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
