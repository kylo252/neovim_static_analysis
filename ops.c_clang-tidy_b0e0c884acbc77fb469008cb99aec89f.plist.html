<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "src/nvim/ops.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,\n *        op_change, op_yank, do_put, do_join\n */\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/assert.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/typval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/log.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/extmark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/path.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/state.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/macros.h\"\n#include \"nvim/window.h\"\n#include \"nvim/lib/kvec.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/time.h\"\n\nstatic yankreg_T y_regs[NUM_REGISTERS];\n\nstatic yankreg_T *y_previous = NULL; /* ptr to last written yankreg */\n\n// for behavior between start_batch_changes() and end_batch_changes())\nstatic int batch_change_count = 0;           // inside a script\nstatic bool clipboard_delay_update = false;  // delay clipboard update\nstatic bool clipboard_needs_update = false;  // clipboard was updated\nstatic bool clipboard_didwarn = false;\n\n/*\n * structure used by block_prep, op_delete and op_yank for blockwise operators\n * also op_change, op_shift, op_insert, op_replace - AKelly\n */\nstruct block_def {\n  int startspaces;              /* 'extra' cols before first char */\n  int endspaces;                /* 'extra' cols after last char */\n  int textlen;                  /* chars in block */\n  char_u      *textstart;       /* pointer to 1st char (partially) in block */\n  colnr_T textcol;              /* index of chars (partially) in block */\n  colnr_T start_vcol;           /* start col of 1st char wholly inside block */\n  colnr_T end_vcol;             /* start col of 1st char wholly after block */\n  int is_short;                 /* TRUE if line is too short to fit in block */\n  int is_MAX;                   /* TRUE if curswant==MAXCOL when starting */\n  int is_oneChar;               /* TRUE if block within one character */\n  int pre_whitesp;              /* screen cols of ws before block */\n  int pre_whitesp_c;            /* chars of ws before block */\n  colnr_T end_char_vcols;       /* number of vcols of post-block char */\n  colnr_T start_char_vcols;       /* number of vcols of pre-block char */\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"ops.c.generated.h\"\n#endif\n\n// Flags for third item in \"opchars\".\n#define OPF_LINES  1  // operator always works on lines\n#define OPF_CHANGE 2  // operator changes text\n\n/*\n * The names of operators.\n * IMPORTANT: Index must correspond with defines in vim.h!!!\n * The third field indicates whether the operator always works on lines.\n */\nstatic char opchars[][3] =\n{\n  { NUL, NUL, 0 },                       // OP_NOP\n  { 'd', NUL, OPF_CHANGE },              // OP_DELETE\n  { 'y', NUL, 0 },                       // OP_YANK\n  { 'c', NUL, OPF_CHANGE },              // OP_CHANGE\n  { '<', NUL, OPF_LINES | OPF_CHANGE },  // OP_LSHIFT\n  { '>', NUL, OPF_LINES | OPF_CHANGE },  // OP_RSHIFT\n  { '!', NUL, OPF_LINES | OPF_CHANGE },  // OP_FILTER\n  { 'g', '~', OPF_CHANGE },              // OP_TILDE\n  { '=', NUL, OPF_LINES | OPF_CHANGE },  // OP_INDENT\n  { 'g', 'q', OPF_LINES | OPF_CHANGE },  // OP_FORMAT\n  { ':', NUL, OPF_LINES },               // OP_COLON\n  { 'g', 'U', OPF_CHANGE },              // OP_UPPER\n  { 'g', 'u', OPF_CHANGE },              // OP_LOWER\n  { 'J', NUL, OPF_LINES | OPF_CHANGE },  // DO_JOIN\n  { 'g', 'J', OPF_LINES | OPF_CHANGE },  // DO_JOIN_NS\n  { 'g', '?', OPF_CHANGE },              // OP_ROT13\n  { 'r', NUL, OPF_CHANGE },              // OP_REPLACE\n  { 'I', NUL, OPF_CHANGE },              // OP_INSERT\n  { 'A', NUL, OPF_CHANGE },              // OP_APPEND\n  { 'z', 'f', 0         },               // OP_FOLD\n  { 'z', 'o', OPF_LINES },               // OP_FOLDOPEN\n  { 'z', 'O', OPF_LINES },               // OP_FOLDOPENREC\n  { 'z', 'c', OPF_LINES },               // OP_FOLDCLOSE\n  { 'z', 'C', OPF_LINES },               // OP_FOLDCLOSEREC\n  { 'z', 'd', OPF_LINES },               // OP_FOLDDEL\n  { 'z', 'D', OPF_LINES },               // OP_FOLDDELREC\n  { 'g', 'w', OPF_LINES | OPF_CHANGE },  // OP_FORMAT2\n  { 'g', '@', OPF_CHANGE },              // OP_FUNCTION\n  { Ctrl_A, NUL, OPF_CHANGE },           // OP_NR_ADD\n  { Ctrl_X, NUL, OPF_CHANGE },           // OP_NR_SUB\n};\n\n/*\n * Translate a command name into an operator type.\n * Must only be called with a valid operator name!\n */\nint get_op_type(int char1, int char2)\n{\n  int i;\n\n  if (char1 == 'r') {\n    // ignore second character\n    return OP_REPLACE;\n  }\n  if (char1 == '~') {\n    // when tilde is an operator\n    return OP_TILDE;\n  }\n  if (char1 == 'g' && char2 == Ctrl_A) {\n    // add\n    return OP_NR_ADD;\n  }\n  if (char1 == 'g' && char2 == Ctrl_X) {\n    // subtract\n    return OP_NR_SUB;\n  }\n  if (char1 == 'z' && char2 == 'y') {  // OP_YANK\n    return OP_YANK;\n  }\n  for (i = 0;; i++) {\n    if (opchars[i][0] == char1 && opchars[i][1] == char2) {\n      break;\n    }\n    if (i == (int)(ARRAY_SIZE(opchars) - 1)) {\n      internal_error(\"get_op_type()\");\n      break;\n    }\n  }\n  return i;\n}\n\n/*\n * Return TRUE if operator \"op\" always works on whole lines.\n */\nint op_on_lines(int op)\n{\n  return opchars[op][2] & OPF_LINES;\n}\n\n// Return TRUE if operator \"op\" changes text.\nint op_is_change(int op)\n{\n    return opchars[op][2] & OPF_CHANGE;\n}\n\n/*\n * Get first operator command character.\n * Returns 'g' or 'z' if there is another command character.\n */\nint get_op_char(int optype)\n{\n  return opchars[optype][0];\n}\n\n/*\n * Get second operator command character.\n */\nint get_extra_op_char(int optype)\n{\n  return opchars[optype][1];\n}\n\n/*\n * op_shift - handle a shift operation\n */\nvoid op_shift(oparg_T *oap, int curs_top, int amount)\n{\n  long i;\n  int first_char;\n  char_u          *s;\n  int block_col = 0;\n\n  if (u_save((linenr_T)(oap->start.lnum - 1),\n          (linenr_T)(oap->end.lnum + 1)) == FAIL)\n    return;\n\n  if (oap->motion_type == kMTBlockWise) {\n    block_col = curwin->w_cursor.col;\n  }\n\n  for (i = oap->line_count - 1; i >= 0; i--) {\n    first_char = *get_cursor_line_ptr();\n    if (first_char == NUL) {  // empty line\n      curwin->w_cursor.col = 0;\n    } else if (oap->motion_type == kMTBlockWise) {\n      shift_block(oap, amount);\n    } else if (first_char != '#' || !preprocs_left()) {\n      // Move the line right if it doesn't start with '#', 'smartindent'\n      // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.\n      shift_line(oap->op_type == OP_LSHIFT, p_sr, amount, false);\n    }\n    ++curwin->w_cursor.lnum;\n  }\n\n  if (oap->motion_type == kMTBlockWise) {\n    curwin->w_cursor.lnum = oap->start.lnum;\n    curwin->w_cursor.col = block_col;\n  } else if (curs_top) { /* put cursor on first line, for \">>\" */\n    curwin->w_cursor.lnum = oap->start.lnum;\n    beginline(BL_SOL | BL_FIX);       /* shift_line() may have set cursor.col */\n  } else\n    --curwin->w_cursor.lnum;            /* put cursor on last line, for \":>\" */\n\n  // The cursor line is not in a closed fold\n  foldOpenCursor();\n\n  if (oap->line_count > p_report) {\n    if (oap->op_type == OP_RSHIFT)\n      s = (char_u *)\">\";\n    else\n      s = (char_u *)\"<\";\n    if (oap->line_count == 1) {\n      if (amount == 1)\n        sprintf((char *)IObuff, _(\"1 line %sed 1 time\"), s);\n      else\n        sprintf((char *)IObuff, _(\"1 line %sed %d times\"), s, amount);\n    } else {\n      if (amount == 1)\n        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed 1 time\"),\n            (int64_t)oap->line_count, s);\n      else\n        sprintf((char *)IObuff, _(\"%\" PRId64 \" lines %sed %d times\"),\n            (int64_t)oap->line_count, s, amount);\n    }\n    msg_attr_keep(IObuff, 0, true, false);\n  }\n\n  /*\n   * Set \"'[\" and \"']\" marks.\n   */\n  curbuf->b_op_start = oap->start;\n  curbuf->b_op_end.lnum = oap->end.lnum;\n  curbuf->b_op_end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n  if (curbuf->b_op_end.col > 0) {\n    curbuf->b_op_end.col--;\n  }\n\n  changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L, true);\n}\n\n// Shift the current line one shiftwidth left (if left != 0) or right\n// leaves cursor on first blank in the line.\nvoid shift_line(\n    int left,\n    int round,\n    int amount,\n    int call_changed_bytes  // call changed_bytes()\n)\n{\n  int count;\n  int i, j;\n  int p_sw = (int)get_sw_value_indent(curbuf);\n\n  count = get_indent();  // get current indent\n\n  if (round) {  // round off indent\n    i = count / p_sw;  // number of p_sw rounded down\n    j = count % p_sw;  // extra spaces\n    if (j && left) {  // first remove extra spaces\n      amount--;\n    }\n    if (left) {\n      i -= amount;\n      if (i < 0)\n        i = 0;\n    } else\n      i += amount;\n    count = i * p_sw;\n  } else {  // original vi indent\n    if (left) {\n      count -= p_sw * amount;\n      if (count < 0)\n        count = 0;\n    } else\n      count += p_sw * amount;\n  }\n\n  // Set new indent\n  if (State & VREPLACE_FLAG) {\n    change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);\n  } else {\n    (void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);\n  }\n}\n\n/*\n * Shift one line of the current block one shiftwidth right or left.\n * Leaves cursor on first character in block.\n */\nstatic void shift_block(oparg_T *oap, int amount)\n{\n  const bool left = (oap->op_type == OP_LSHIFT);\n  const int oldstate = State;\n  char_u *newp;\n  const int oldcol = curwin->w_cursor.col;\n  int p_sw = (int)get_sw_value_indent(curbuf);\n  long *p_vts = curbuf->b_p_vts_array;\n  const long p_ts = curbuf->b_p_ts;\n  struct block_def bd;\n  int incr;\n  int i = 0, j = 0;\n  const int old_p_ri = p_ri;\n\n  p_ri = 0;                     /* don't want revins in indent */\n\n  State = INSERT;               // don't want REPLACE for State\n  block_prep(oap, &bd, curwin->w_cursor.lnum, true);\n  if (bd.is_short) {\n    return;\n  }\n\n  // total is number of screen columns to be inserted/removed\n  int total = (int)((unsigned)amount * (unsigned)p_sw);\n  if ((total / p_sw) != amount) {\n    return;   // multiplication overflow\n  }\n\n  char_u *const oldp = get_cursor_line_ptr();\n\n  int startcol, oldlen, newlen;\n\n  if (!left) {\n    /*\n     *  1. Get start vcol\n     *  2. Total ws vcols\n     *  3. Divvy into TABs & spp\n     *  4. Construct new string\n     */\n    total += bd.pre_whitesp;    // all virtual WS up to & incl a split TAB\n    colnr_T ws_vcol = bd.start_vcol - bd.pre_whitesp;\n    char_u * old_textstart = bd.textstart;\n    if (bd.startspaces) {\n      if (utfc_ptr2len(bd.textstart) == 1) {\n        bd.textstart++;\n      } else {\n        ws_vcol = 0;\n        bd.startspaces = 0;\n      }\n    }\n    for (; ascii_iswhite(*bd.textstart); ) {\n      // TODO: is passing bd.textstart for start of the line OK?\n      incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart, (colnr_T)(bd.start_vcol));\n      total += incr;\n      bd.start_vcol += incr;\n    }\n    /* OK, now total=all the VWS reqd, and textstart points at the 1st\n     * non-ws char in the block. */\n    if (!curbuf->b_p_et) {\n      tabstop_fromto(ws_vcol, ws_vcol + total, p_ts, p_vts, &i, &j);\n    } else {\n      j = total;\n    }\n\n    // if we're splitting a TAB, allow for it\n    int col_pre = bd.pre_whitesp_c - (bd.startspaces != 0);\n    bd.textcol -= col_pre;\n    const int len = (int)STRLEN(bd.textstart) + 1;\n    int col = bd.textcol + i +j + len;\n    assert(col >= 0);\n    newp = (char_u *)xmalloc((size_t)col);\n    memset(newp, NUL, (size_t)col);\n    memmove(newp, oldp, (size_t)bd.textcol);\n    startcol = bd.textcol;\n    oldlen = (int)(bd.textstart-old_textstart) + col_pre;\n    newlen = i+j;\n    memset(newp + bd.textcol, TAB, (size_t)i);\n    memset(newp + bd.textcol + i, ' ', (size_t)j);\n    /* the end */\n    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);\n  } else {  // left\n    colnr_T destination_col;      // column to which text in block will\n                                  // be shifted\n    char_u *verbatim_copy_end;    // end of the part of the line which is\n                                  // copied verbatim\n    colnr_T verbatim_copy_width;  // the (displayed) width of this part\n                                  // of line\n    size_t fill;                  // nr of spaces that replace a TAB\n    size_t new_line_len;          // the length of the line after the\n                                  // block shift\n    char_u      *non_white = bd.textstart;\n\n    /*\n     * Firstly, let's find the first non-whitespace character that is\n     * displayed after the block's start column and the character's column\n     * number. Also, let's calculate the width of all the whitespace\n     * characters that are displayed in the block and precede the searched\n     * non-whitespace character.\n     */\n\n    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character,\n     * the part of which is displayed at the block's beginning. Let's start\n     * searching from the next character. */\n    if (bd.startspaces) {\n      MB_PTR_ADV(non_white);\n    }\n\n    // The character's column is in \"bd.start_vcol\".\n    colnr_T non_white_col = bd.start_vcol;\n\n    while (ascii_iswhite(*non_white)) {\n      incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);\n      non_white_col += incr;\n    }\n\n\n    const colnr_T block_space_width = non_white_col - oap->start_vcol;\n    // We will shift by \"total\" or \"block_space_width\", whichever is less.\n    const colnr_T shift_amount = block_space_width < total\n        ? block_space_width\n        : total;\n    // The column to which we will shift the text.\n    destination_col = non_white_col - shift_amount;\n\n    /* Now let's find out how much of the beginning of the line we can\n     * reuse without modification.  */\n    verbatim_copy_end = bd.textstart;\n    verbatim_copy_width = bd.start_vcol;\n\n    /* If \"bd.startspaces\" is set, \"bd.textstart\" points to the character\n     * preceding the block. We have to subtract its width to obtain its\n     * column number.  */\n    if (bd.startspaces)\n      verbatim_copy_width -= bd.start_char_vcols;\n    while (verbatim_copy_width < destination_col) {\n      char_u *line = verbatim_copy_end;\n\n      // TODO: is passing verbatim_copy_end for start of the line OK?\n      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);\n      if (verbatim_copy_width + incr > destination_col)\n        break;\n      verbatim_copy_width += incr;\n      MB_PTR_ADV(verbatim_copy_end);\n    }\n\n    /* If \"destination_col\" is different from the width of the initial\n    * part of the line that will be copied, it means we encountered a tab\n    * character, which we will have to partly replace with spaces.  */\n    assert(destination_col - verbatim_copy_width >= 0);\n    fill = (size_t)(destination_col - verbatim_copy_width);\n\n    assert(verbatim_copy_end - oldp >= 0);\n    const size_t verbatim_diff = (size_t)(verbatim_copy_end - oldp);\n    // The replacement line will consist of:\n    // - the beginning of the original line up to \"verbatim_copy_end\",\n    // - \"fill\" number of spaces,\n    // - the rest of the line, pointed to by non_white.\n    new_line_len = verbatim_diff + fill + STRLEN(non_white) + 1;\n\n    newp = (char_u *)xmalloc(new_line_len);\n    startcol = (int)verbatim_diff;\n    oldlen = bd.textcol + (int)(non_white - bd.textstart) - (int)verbatim_diff;\n    newlen = (int)fill;\n    memmove(newp, oldp, verbatim_diff);\n    memset(newp + verbatim_diff, ' ', fill);\n    STRMOVE(newp + verbatim_diff + fill, non_white);\n  }\n  // replace the line\n  ml_replace(curwin->w_cursor.lnum, newp, false);\n  changed_bytes(curwin->w_cursor.lnum, (colnr_T)bd.textcol);\n  extmark_splice_cols(curbuf, (int)curwin->w_cursor.lnum-1, startcol,\n                      oldlen, newlen,\n                      kExtmarkUndo);\n  State = oldstate;\n  curwin->w_cursor.col = oldcol;\n  p_ri = old_p_ri;\n}\n\n/*\n * Insert string \"s\" (b_insert ? before : after) block :AKelly\n * Caller must prepare for undo.\n */\nstatic void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)\n{\n  int p_ts;\n  int count = 0;                // extra spaces to replace a cut TAB\n  int spaces = 0;               // non-zero if cutting a TAB\n  colnr_T offset;               // pointer along new line\n  size_t s_len = STRLEN(s);\n  char_u      *newp, *oldp;     // new, old lines\n  linenr_T lnum;                // loop var\n  int oldstate = State;\n  State = INSERT;               // don't want REPLACE for State\n\n  for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++) {\n    block_prep(oap, bdp, lnum, true);\n    if (bdp->is_short && b_insert) {\n      continue;  // OP_INSERT, line ends before block start\n    }\n\n    oldp = ml_get(lnum);\n\n    if (b_insert) {\n      p_ts = bdp->start_char_vcols;\n      spaces = bdp->startspaces;\n      if (spaces != 0)\n        count = p_ts - 1;         /* we're cutting a TAB */\n      offset = bdp->textcol;\n    } else { /* append */\n      p_ts = bdp->end_char_vcols;\n      if (!bdp->is_short) {     /* spaces = padding after block */\n        spaces = (bdp->endspaces ? p_ts - bdp->endspaces : 0);\n        if (spaces != 0)\n          count = p_ts - 1;           /* we're cutting a TAB */\n        offset = bdp->textcol + bdp->textlen - (spaces != 0);\n      } else { /* spaces = padding to block edge */\n                 /* if $ used, just append to EOL (ie spaces==0) */\n        if (!bdp->is_MAX)\n          spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n        count = spaces;\n        offset = bdp->textcol + bdp->textlen;\n      }\n    }\n\n    if (spaces > 0) {\n      int off;\n\n      // Avoid starting halfway through a multi-byte character.\n      if (b_insert) {\n        off = utf_head_off(oldp, oldp + offset + spaces);\n      } else {\n        off = (*mb_off_next)(oldp, oldp + offset);\n        offset += off;\n      }\n      spaces -= off;\n      count -= off;\n    }\n\n    assert(count >= 0);\n    newp = (char_u *)xmalloc(STRLEN(oldp) + s_len + (size_t)count + 1);\n\n    // copy up to shifted part\n    memmove(newp, oldp, (size_t)offset);\n    oldp += offset;\n    int startcol = offset;\n\n    // insert pre-padding\n    memset(newp + offset, ' ', (size_t)spaces);\n\n    // copy the new text\n    memmove(newp + offset + spaces, s, s_len);\n    offset += (int)s_len;\n\n    int skipped = 0;\n    if (spaces && !bdp->is_short) {\n      // insert post-padding\n      memset(newp + offset + spaces, ' ', (size_t)(p_ts - spaces));\n      // We're splitting a TAB, don't copy it.\n      oldp++;\n      // We allowed for that TAB, remember this now\n      count++;\n      skipped = 1;\n    }\n\n    if (spaces > 0)\n      offset += count;\n    STRMOVE(newp + offset, oldp);\n\n    ml_replace(lnum, newp, false);\n    extmark_splice_cols(curbuf, (int)lnum-1, startcol,\n                        skipped, offset-startcol, kExtmarkUndo);\n\n    if (lnum == oap->end.lnum) {\n      /* Set \"']\" mark to the end of the block instead of the end of\n       * the insert in the first line.  */\n      curbuf->b_op_end.lnum = oap->end.lnum;\n      curbuf->b_op_end.col = offset;\n    }\n  }   /* for all lnum */\n\n  changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L, true);\n\n  State = oldstate;\n}\n\n/*\n * op_reindent - handle reindenting a block of lines.\n */\nvoid op_reindent(oparg_T *oap, Indenter how)\n{\n  long i;\n  char_u      *l;\n  int amount;\n  linenr_T first_changed = 0;\n  linenr_T last_changed = 0;\n  linenr_T start_lnum = curwin->w_cursor.lnum;\n\n  /* Don't even try when 'modifiable' is off. */\n  if (!MODIFIABLE(curbuf)) {\n    EMSG(_(e_modifiable));\n    return;\n  }\n\n  for (i = oap->line_count - 1; i >= 0 && !got_int; i--) {\n    /* it's a slow thing to do, so give feedback so there's no worry that\n     * the computer's just hung. */\n\n    if (i > 1\n        && (i % 50 == 0 || i == oap->line_count - 1)\n        && oap->line_count > p_report)\n      smsg(_(\"%\" PRId64 \" lines to indent... \"), (int64_t)i);\n\n    /*\n     * Be vi-compatible: For lisp indenting the first line is not\n     * indented, unless there is only one line.\n     */\n    if (i != oap->line_count - 1 || oap->line_count == 1\n        || how != get_lisp_indent) {\n      l = skipwhite(get_cursor_line_ptr());\n      if (*l == NUL)                        /* empty or blank line */\n        amount = 0;\n      else\n        amount = how();                     /* get the indent for this line */\n\n      if (amount >= 0 && set_indent(amount, SIN_UNDO)) {\n        // did change the indent, call changed_lines() later\n        if (first_changed == 0) {\n          first_changed = curwin->w_cursor.lnum;\n        }\n        last_changed = curwin->w_cursor.lnum;\n      }\n    }\n    ++curwin->w_cursor.lnum;\n    curwin->w_cursor.col = 0;      /* make sure it's valid */\n  }\n\n  /* put cursor on first non-blank of indented line */\n  curwin->w_cursor.lnum = start_lnum;\n  beginline(BL_SOL | BL_FIX);\n\n  /* Mark changed lines so that they will be redrawn.  When Visual\n   * highlighting was present, need to continue until the last line.  When\n   * there is no change still need to remove the Visual highlighting. */\n  if (last_changed != 0) {\n    changed_lines(first_changed, 0,\n                  oap->is_VIsual ? start_lnum + oap->line_count :\n                  last_changed + 1, 0L, true);\n  } else if (oap->is_VIsual) {\n    redraw_curbuf_later(INVERTED);\n  }\n\n  if (oap->line_count > p_report) {\n    i = oap->line_count - (i + 1);\n    if (i == 1)\n      MSG(_(\"1 line indented \"));\n    else\n      smsg(_(\"%\" PRId64 \" lines indented \"), (int64_t)i);\n  }\n  /* set '[ and '] marks */\n  curbuf->b_op_start = oap->start;\n  curbuf->b_op_end = oap->end;\n}\n\n/*\n * Keep the last expression line here, for repeating.\n */\nstatic char_u   *expr_line = NULL;\n\n/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\nint get_expr_register(void)\n{\n  char_u      *new_line;\n\n  new_line = getcmdline('=', 0L, 0, true);\n  if (new_line == NULL) {\n    return NUL;\n  }\n  if (*new_line == NUL) {  // use previous line\n    xfree(new_line);\n  } else {\n    set_expr_line(new_line);\n  }\n  return '=';\n}\n\n/*\n * Set the expression for the '=' register.\n * Argument must be an allocated string.\n */\nvoid set_expr_line(char_u *new_line)\n{\n  xfree(expr_line);\n  expr_line = new_line;\n}\n\n/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\nchar_u *get_expr_line(void)\n{\n  char_u      *expr_copy;\n  char_u      *rv;\n  static int nested = 0;\n\n  if (expr_line == NULL)\n    return NULL;\n\n  /* Make a copy of the expression, because evaluating it may cause it to be\n   * changed. */\n  expr_copy = vim_strsave(expr_line);\n\n  /* When we are invoked recursively limit the evaluation to 10 levels.\n   * Then return the string as-is. */\n  if (nested >= 10)\n    return expr_copy;\n\n  ++nested;\n  rv = eval_to_string(expr_copy, NULL, TRUE);\n  --nested;\n  xfree(expr_copy);\n  return rv;\n}\n\n/*\n * Get the '=' register expression itself, without evaluating it.\n */\nchar_u *get_expr_line_src(void)\n{\n  if (expr_line == NULL)\n    return NULL;\n  return vim_strsave(expr_line);\n}\n\n/// Returns whether `regname` is a valid name of a yank register.\n/// Note: There is no check for 0 (default register), caller should do this.\n/// The black hole register '_' is regarded as valid.\n///\n/// @param regname name of register\n/// @param writing allow only writable registers\nbool valid_yank_reg(int regname, bool writing)\n{\n  if ((regname > 0 && ASCII_ISALNUM(regname))\n      || (!writing && vim_strchr((char_u *) \"/.%:=\" , regname) != NULL)\n      || regname == '#'\n      || regname == '\"'\n      || regname == '-'\n      || regname == '_'\n      || regname == '*'\n      || regname == '+') {\n    return true;\n  }\n  return false;\n}\n\ntypedef enum {\n  YREG_PASTE,\n  YREG_YANK,\n  YREG_PUT,\n} yreg_mode_t;\n\n/// Return yankreg_T to use, according to the value of `regname`.\n/// Cannot handle the '_' (black hole) register.\n/// Must only be called with a valid register name!\n///\n/// @param regname The name of the register used or 0 for the unnamed register\n/// @param mode One of the following three flags:\n///\n/// `YREG_PASTE`:\n/// Prepare for pasting the register `regname`. With no regname specified,\n/// read from last written register, or from unnamed clipboard (depending on the\n/// `clipboard=unnamed` option). Queries the clipboard provider if necessary.\n///\n/// `YREG_YANK`:\n/// Preparare for yanking into `regname`. With no regname specified,\n/// yank into `\"0` register. Update `y_previous` for next unnamed paste.\n///\n/// `YREG_PUT`:\n/// Obtain the location that would be read when pasting `regname`.\nyankreg_T *get_yank_register(int regname, int mode)\n{\n  yankreg_T *reg;\n\n  if (mode == YREG_PASTE && get_clipboard(regname, &reg, false)) {\n    // reg is set to clipboard contents.\n    return reg;\n  } else if (mode != YREG_YANK\n      && (regname == 0 || regname == '\"' || regname == '*' || regname == '+')\n      && y_previous != NULL) {\n    // in case clipboard not available, paste from previous used register\n    return y_previous;\n  }\n\n  int i = op_reg_index(regname);\n  // when not 0-9, a-z, A-Z or '-'/'+'/'*': use register 0\n  if (i == -1) {\n    i = 0;\n  }\n  reg = &y_regs[i];\n\n  if (mode == YREG_YANK) {\n    // remember the written register for unnamed paste\n    y_previous = reg;\n  }\n  return reg;\n}\n\nstatic bool is_append_register(int regname)\n{\n  return ASCII_ISUPPER(regname);\n}\n\n/// @see get_yank_register\n/// @returns true when register should be inserted literally\n/// (selection or clipboard)\nstatic inline bool is_literal_register(int regname)\n  FUNC_ATTR_CONST\n{\n  return regname == '*' || regname == '+';\n}\n\n/// Returns a copy of contents in register `name`\n/// for use in do_put. Should be freed by caller.\nyankreg_T *copy_register(int name)\n  FUNC_ATTR_NONNULL_RET\n{\n  yankreg_T *reg = get_yank_register(name, YREG_PASTE);\n\n  yankreg_T *copy = xmalloc(sizeof(yankreg_T));\n  *copy = *reg;\n  if (copy->y_size == 0) {\n    copy->y_array = NULL;\n  } else {\n    copy->y_array = xcalloc(copy->y_size, sizeof(char_u *));\n    for (size_t i = 0; i < copy->y_size; i++) {\n      copy->y_array[i] = vim_strsave(reg->y_array[i]);\n    }\n  }\n  return copy;\n}\n\n/// check if the current yank register has kMTLineWise register type\nbool yank_register_mline(int regname)\n{\n  if (regname != 0 && !valid_yank_reg(regname, false)) {\n    return false;\n  }\n  if (regname == '_') {  // black hole is always empty\n    return false;\n  }\n  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n  return reg->y_type == kMTLineWise;\n}\n\n/*\n * Start or stop recording into a yank register.\n *\n * Return FAIL for failure, OK otherwise.\n */\nint do_record(int c)\n{\n  char_u          *p;\n  static int regname;\n  yankreg_T  *old_y_previous;\n  int retval;\n\n  if (reg_recording == 0) {\n    // start recording\n    // registers 0-9, a-z and \" are allowed\n    if (c < 0 || (!ASCII_ISALNUM(c) && c != '\"')) {\n      retval = FAIL;\n    } else {\n      reg_recording = c;\n      showmode();\n      regname = c;\n      retval = OK;\n    }\n  } else {                        /* stop recording */\n    /*\n     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this\n     * needs to be removed again to put it in a register.  exec_reg then\n     * adds the escaping back later.\n     */\n    reg_recording = 0;\n    if (ui_has(kUIMessages)) {\n      showmode();\n    } else {\n      MSG(\"\");\n    }\n    p = get_recorded();\n    if (p == NULL)\n      retval = FAIL;\n    else {\n      /* Remove escaping for CSI and K_SPECIAL in multi-byte chars. */\n      vim_unescape_csi(p);\n\n      /*\n       * We don't want to change the default register here, so save and\n       * restore the current register name.\n       */\n      old_y_previous = y_previous;\n\n      retval = stuff_yank(regname, p);\n\n      y_previous = old_y_previous;\n    }\n  }\n  return retval;\n}\n\nstatic void set_yreg_additional_data(yankreg_T *reg, dict_T *additional_data)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (reg->additional_data == additional_data) {\n    return;\n  }\n  tv_dict_unref(reg->additional_data);\n  reg->additional_data = additional_data;\n}\n\n/*\n * Stuff string \"p\" into yank register \"regname\" as a single line (append if\n * uppercase). \"p\" must have been allocated.\n *\n * return FAIL for failure, OK otherwise\n */\nstatic int stuff_yank(int regname, char_u *p)\n{\n  /* check for read-only register */\n  if (regname != 0 && !valid_yank_reg(regname, true)) {\n    xfree(p);\n    return FAIL;\n  }\n  if (regname == '_') {             /* black hole: don't do anything */\n    xfree(p);\n    return OK;\n  }\n  yankreg_T *reg = get_yank_register(regname, YREG_YANK);\n  if (is_append_register(regname) && reg->y_array != NULL) {\n    char_u **pp = &(reg->y_array[reg->y_size - 1]);\n    char_u *lp = xmalloc(STRLEN(*pp) + STRLEN(p) + 1);\n    STRCPY(lp, *pp);\n    // TODO(philix): use xstpcpy() in stuff_yank()\n    STRCAT(lp, p);\n    xfree(p);\n    xfree(*pp);\n    *pp = lp;\n  } else {\n    free_register(reg);\n    set_yreg_additional_data(reg, NULL);\n    reg->y_array = (char_u **)xmalloc(sizeof(char_u *));\n    reg->y_array[0] = p;\n    reg->y_size = 1;\n    reg->y_type = kMTCharWise;\n  }\n  reg->timestamp = os_time();\n  return OK;\n}\n\nstatic int execreg_lastc = NUL;\n\n/// Execute a yank register: copy it into the stuff buffer\n///\n/// Return FAIL for failure, OK otherwise\nint\ndo_execreg(\n    int regname,\n    int colon,                      /* insert ':' before each line */\n    int addcr,                      /* always add '\\n' to end of line */\n    int silent                     /* set \"silent\" flag in typeahead buffer */\n)\n{\n  char_u *p;\n  int retval = OK;\n\n  if (regname == '@') {                 /* repeat previous one */\n    if (execreg_lastc == NUL) {\n      EMSG(_(\"E748: No previously used register\"));\n      return FAIL;\n    }\n    regname = execreg_lastc;\n  }\n  /* check for valid regname */\n  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {\n    emsg_invreg(regname);\n    return FAIL;\n  }\n  execreg_lastc = regname;\n\n  if (regname == '_')                   /* black hole: don't stuff anything */\n    return OK;\n\n  if (regname == ':') {                 /* use last command line */\n    if (last_cmdline == NULL) {\n      EMSG(_(e_nolastcmd));\n      return FAIL;\n    }\n    // don't keep the cmdline containing @:\n    XFREE_CLEAR(new_last_cmdline);\n    // Escape all control characters with a CTRL-V\n    p = vim_strsave_escaped_ext(\n        last_cmdline,\n        (char_u *)\"\\001\\002\\003\\004\\005\\006\\007\"\n        \"\\010\\011\\012\\013\\014\\015\\016\\017\"\n        \"\\020\\021\\022\\023\\024\\025\\026\\027\"\n        \"\\030\\031\\032\\033\\034\\035\\036\\037\",\n        Ctrl_V, false);\n    // When in Visual mode \"'<,'>\" will be prepended to the command.\n    // Remove it when it's already there.\n    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0) {\n      retval = put_in_typebuf(p + 5, true, true, silent);\n    } else {\n      retval = put_in_typebuf(p, true, true, silent);\n    }\n    xfree(p);\n  } else if (regname == '=') {\n    p = get_expr_line();\n    if (p == NULL)\n      return FAIL;\n    retval = put_in_typebuf(p, true, colon, silent);\n    xfree(p);\n  } else if (regname == '.') {        /* use last inserted text */\n    p = get_last_insert_save();\n    if (p == NULL) {\n      EMSG(_(e_noinstext));\n      return FAIL;\n    }\n    retval = put_in_typebuf(p, false, colon, silent);\n    xfree(p);\n  } else {\n    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n    if (reg->y_array == NULL)\n      return FAIL;\n\n    // Disallow remapping for \":@r\".\n    int remap = colon ? REMAP_NONE : REMAP_YES;\n\n    /*\n     * Insert lines into typeahead buffer, from last one to first one.\n     */\n    put_reedit_in_typebuf(silent);\n    char_u *escaped;\n    for (size_t i = reg->y_size; i-- > 0;) {  // from y_size - 1 to 0 included\n      // insert NL between lines and after last line if type is kMTLineWise\n      if (reg->y_type == kMTLineWise || i < reg->y_size - 1 || addcr) {\n        if (ins_typebuf((char_u *)\"\\n\", remap, 0, true, silent) == FAIL) {\n          return FAIL;\n        }\n      }\n      escaped = vim_strsave_escape_csi(reg->y_array[i]);\n      retval = ins_typebuf(escaped, remap, 0, true, silent);\n      xfree(escaped);\n      if (retval == FAIL) {\n        return FAIL;\n      }\n      if (colon\n          && ins_typebuf((char_u *)\":\", remap, 0, true, silent) == FAIL) {\n        return FAIL;\n      }\n    }\n    reg_executing = regname == 0 ? '\"' : regname;  // disable the 'q' command\n  }\n  return retval;\n}\n\n/*\n * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's\n * used only after other typeahead has been processed.\n */\nstatic void put_reedit_in_typebuf(int silent)\n{\n  char_u buf[3];\n\n  if (restart_edit != NUL) {\n    if (restart_edit == 'V') {\n      buf[0] = 'g';\n      buf[1] = 'R';\n      buf[2] = NUL;\n    } else {\n      buf[0] = (char_u)(restart_edit == 'I' ? 'i' : restart_edit);\n      buf[1] = NUL;\n    }\n    if (ins_typebuf(buf, REMAP_NONE, 0, true, silent) == OK) {\n      restart_edit = NUL;\n    }\n  }\n}\n\n/// Insert register contents \"s\" into the typeahead buffer, so that it will be\n/// executed again.\n///\n/// @param esc    when true then it is to be taken literally: Escape CSI\n///               characters and no remapping.\n/// @param colon  add ':' before the line\nstatic int put_in_typebuf(char_u *s, bool esc, bool colon, int silent)\n{\n  int retval = OK;\n\n  put_reedit_in_typebuf(silent);\n  if (colon) {\n    retval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, true, silent);\n  }\n  if (retval == OK) {\n    char_u  *p;\n\n    if (esc) {\n      p = vim_strsave_escape_csi(s);\n    } else {\n      p = s;\n    }\n    if (p == NULL) {\n      retval = FAIL;\n    } else {\n      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES, 0, true, silent);\n    }\n    if (esc) {\n      xfree(p);\n    }\n  }\n  if (colon && retval == OK) {\n    retval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, true, silent);\n  }\n  return retval;\n}\n\n/*\n * Insert a yank register: copy it into the Read buffer.\n * Used by CTRL-R command and middle mouse button in insert mode.\n *\n * return FAIL for failure, OK otherwise\n */\nint insert_reg(\n    int regname,\n    bool literally_arg            // insert literally, not as if typed\n)\n{\n  int retval = OK;\n  bool allocated;\n  const bool literally = literally_arg || is_literal_register(regname);\n\n  /*\n   * It is possible to get into an endless loop by having CTRL-R a in\n   * register a and then, in insert mode, doing CTRL-R a.\n   * If you hit CTRL-C, the loop will be broken here.\n   */\n  os_breakcheck();\n  if (got_int)\n    return FAIL;\n\n  /* check for valid regname */\n  if (regname != NUL && !valid_yank_reg(regname, false))\n    return FAIL;\n\n  char_u *arg;\n  if (regname == '.') {  // Insert last inserted text.\n    retval = stuff_inserted(NUL, 1L, true);\n  } else if (get_spec_reg(regname, &arg, &allocated, true)) {\n    if (arg == NULL) {\n      return FAIL;\n    }\n    stuffescaped((const char *)arg, literally);\n    if (allocated) {\n      xfree(arg);\n    }\n  } else {  // Name or number register.\n    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n    if (reg->y_array == NULL) {\n      retval = FAIL;\n    } else {\n      for (size_t i = 0; i < reg->y_size; i++) {\n        if (regname == '-') {\n          AppendCharToRedobuff(Ctrl_R);\n          AppendCharToRedobuff(regname);\n          do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);\n        } else {\n          stuffescaped((const char *)reg->y_array[i], literally);\n        }\n        // Insert a newline between lines and after last line if\n        // y_type is kMTLineWise.\n        if (reg->y_type == kMTLineWise || i < reg->y_size - 1) {\n          stuffcharReadbuff('\\n');\n        }\n      }\n    }\n  }\n\n  return retval;\n}\n\n/*\n * Stuff a string into the typeahead buffer, such that edit() will insert it\n * literally (\"literally\" TRUE) or interpret is as typed characters.\n */\nstatic void stuffescaped(const char *arg, int literally)\n{\n  while (*arg != NUL) {\n    // Stuff a sequence of normal ASCII characters, that's fast.  Also\n    // stuff K_SPECIAL to get the effect of a special key when \"literally\"\n    // is TRUE.\n    const char *const start = arg;\n    while ((*arg >= ' ' && *arg < DEL) || ((uint8_t)(*arg) == K_SPECIAL\n                                           && !literally)) {\n      arg++;\n    }\n    if (arg > start) {\n      stuffReadbuffLen(start, (long)(arg - start));\n    }\n\n    /* stuff a single special character */\n    if (*arg != NUL) {\n      const int c = mb_cptr2char_adv((const char_u **)&arg);\n      if (literally && ((c < ' ' && c != TAB) || c == DEL)) {\n        stuffcharReadbuff(Ctrl_V);\n      }\n      stuffcharReadbuff(c);\n    }\n  }\n}\n\n// If \"regname\" is a special register, return true and store a pointer to its\n// value in \"argp\".\nbool get_spec_reg(\n    int regname,\n    char_u **argp,\n    bool *allocated,        // return: true when value was allocated\n    bool errmsg             // give error message when failing\n)\n{\n  size_t cnt;\n\n  *argp = NULL;\n  *allocated = false;\n  switch (regname) {\n  case '%':                     /* file name */\n    if (errmsg)\n      check_fname();            /* will give emsg if not set */\n    *argp = curbuf->b_fname;\n    return true;\n\n  case '#':                       // alternate file name\n    *argp = getaltfname(errmsg);  // may give emsg if not set\n    return true;\n\n  case '=':                     /* result of expression */\n    *argp = get_expr_line();\n    *allocated = true;\n    return true;\n\n  case ':':                     /* last command line */\n    if (last_cmdline == NULL && errmsg)\n      EMSG(_(e_nolastcmd));\n    *argp = last_cmdline;\n    return true;\n\n  case '/':                     /* last search-pattern */\n    if (last_search_pat() == NULL && errmsg)\n      EMSG(_(e_noprevre));\n    *argp = last_search_pat();\n    return true;\n\n  case '.':                     /* last inserted text */\n    *argp = get_last_insert_save();\n    *allocated = true;\n    if (*argp == NULL && errmsg) {\n      EMSG(_(e_noinstext));\n    }\n    return true;\n\n  case Ctrl_F:                  // Filename under cursor\n  case Ctrl_P:                  // Path under cursor, expand via \"path\"\n    if (!errmsg) {\n      return false;\n    }\n    *argp = file_name_at_cursor(\n        FNAME_MESS | FNAME_HYP | (regname == Ctrl_P ? FNAME_EXP : 0),\n        1L, NULL);\n    *allocated = true;\n    return true;\n\n  case Ctrl_W:                  // word under cursor\n  case Ctrl_A:                  // WORD (mnemonic All) under cursor\n    if (!errmsg) {\n      return false;\n    }\n    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W\n                                         ? (FIND_IDENT|FIND_STRING)\n                                         : FIND_STRING));\n    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;\n    *allocated = true;\n    return true;\n\n  case Ctrl_L:                  // Line under cursor\n    if (!errmsg) {\n      return false;\n    }\n\n    *argp = ml_get_buf(curwin->w_buffer, curwin->w_cursor.lnum, false);\n    return true;\n\n  case '_':                     /* black hole: always empty */\n    *argp = (char_u *)\"\";\n    return true;\n  }\n\n  return false;\n}\n\n/// Paste a yank register into the command line.\n/// Only for non-special registers.\n/// Used by CTRL-R in command-line mode.\n/// insert_reg() can't be used here, because special characters from the\n/// register contents will be interpreted as commands.\n///\n/// @param regname   Register name.\n/// @param literally_arg Insert text literally instead of \"as typed\".\n/// @param remcr     When true, don't add CR characters.\n///\n/// @returns FAIL for failure, OK otherwise\nbool cmdline_paste_reg(int regname, bool literally_arg, bool remcr)\n{\n  const bool literally = literally_arg || is_literal_register(regname);\n\n  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n  if (reg->y_array == NULL)\n    return FAIL;\n\n  for (size_t i = 0; i < reg->y_size; i++) {\n    cmdline_paste_str(reg->y_array[i], literally);\n\n    // Insert ^M between lines, unless `remcr` is true.\n    if (i < reg->y_size - 1 && !remcr) {\n      cmdline_paste_str((char_u *)\"\\r\", literally);\n    }\n\n    /* Check for CTRL-C, in case someone tries to paste a few thousand\n     * lines and gets bored. */\n    os_breakcheck();\n    if (got_int)\n      return FAIL;\n  }\n  return OK;\n}\n\n// Shift the delete registers: \"9 is cleared, \"8 becomes \"9, etc.\nstatic void shift_delete_registers(bool y_append)\n{\n  free_register(&y_regs[9]);  // free register \"9\n  for (int n = 9; n > 1; n--) {\n    y_regs[n] = y_regs[n - 1];\n  }\n  if (!y_append) {\n    y_previous = &y_regs[1];\n  }\n  y_regs[1].y_array = NULL;  // set register \"1 to empty\n}\n\n/*\n * Handle a delete operation.\n *\n * Return FAIL if undo failed, OK otherwise.\n */\nint op_delete(oparg_T *oap)\n{\n  int n;\n  linenr_T lnum;\n  char_u              *ptr;\n  char_u              *newp, *oldp;\n  struct block_def bd = { 0 };\n  linenr_T old_lcount = curbuf->b_ml.ml_line_count;\n\n  if (curbuf->b_ml.ml_flags & ML_EMPTY) {  // nothing to do\n    return OK;\n  }\n\n  // Nothing to delete, return here. Do prepare undo, for op_change().\n  if (oap->empty) {\n    return u_save_cursor();\n  }\n\n  if (!MODIFIABLE(curbuf)) {\n    EMSG(_(e_modifiable));\n    return FAIL;\n  }\n\n  mb_adjust_opend(oap);\n\n  /*\n   * Imitate the strange Vi behaviour: If the delete spans more than one\n   * line and motion_type == kMTCharWise and the result is a blank line, make the\n   * delete linewise.  Don't do this for the change command or Visual mode.\n   */\n  if (oap->motion_type == kMTCharWise\n      && !oap->is_VIsual\n      && oap->line_count > 1\n      && oap->motion_force == NUL\n      && oap->op_type == OP_DELETE) {\n    ptr = ml_get(oap->end.lnum) + oap->end.col;\n    if (*ptr != NUL)\n      ptr += oap->inclusive;\n    ptr = skipwhite(ptr);\n    if (*ptr == NUL && inindent(0)) {\n      oap->motion_type = kMTLineWise;\n    }\n  }\n\n  /*\n   * Check for trying to delete (e.g. \"D\") in an empty line.\n   * Note: For the change operator it is ok.\n   */\n  if (oap->motion_type != kMTLineWise\n      && oap->line_count == 1\n      && oap->op_type == OP_DELETE\n      && *ml_get(oap->start.lnum) == NUL) {\n    // It's an error to operate on an empty region, when 'E' included in\n    // 'cpoptions' (Vi compatible).\n    if (virtual_op) {\n      // Virtual editing: Nothing gets deleted, but we set the '[ and ']\n      // marks as if it happened.\n      goto setmarks;\n    }\n    if (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL) {\n      beep_flush();\n    }\n    return OK;\n  }\n\n  /*\n   * Do a yank of whatever we're about to delete.\n   * If a yank register was specified, put the deleted text into that\n   * register.  For the black hole register '_' don't yank anything.\n   */\n  if (oap->regname != '_') {\n    yankreg_T *reg = NULL;\n    int did_yank = false;\n    if (oap->regname != 0) {\n      // yank without message\n      did_yank = op_yank(oap, false, true);\n      if (!did_yank) {\n        // op_yank failed, don't do anything\n        return OK;\n      }\n    }\n\n    /*\n     * Put deleted text into register 1 and shift number registers if the\n     * delete contains a line break, or when a regname has been specified.\n     */\n    if (oap->regname != 0 || oap->motion_type == kMTLineWise\n        || oap->line_count > 1 || oap->use_reg_one) {\n      shift_delete_registers(is_append_register(oap->regname));\n      reg = &y_regs[1];\n      op_yank_reg(oap, false, reg, false);\n      did_yank = true;\n    }\n\n    /* Yank into small delete register when no named register specified\n     * and the delete is within one line. */\n    if (oap->regname == 0 && oap->motion_type != kMTLineWise\n        && oap->line_count == 1) {\n      reg = get_yank_register('-', YREG_YANK);\n      op_yank_reg(oap, false, reg, false);\n      did_yank = true;\n    }\n\n    if (did_yank || oap->regname == 0) {\n      if (reg == NULL) {\n        abort();\n      }\n      set_clipboard(oap->regname, reg);\n      do_autocmd_textyankpost(oap, reg);\n    }\n\n  }\n\n  /*\n   * block mode delete\n   */\n  if (oap->motion_type == kMTBlockWise) {\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n               (linenr_T)(oap->end.lnum + 1)) == FAIL) {\n      return FAIL;\n    }\n\n    for (lnum = curwin->w_cursor.lnum; lnum <= oap->end.lnum; lnum++) {\n      block_prep(oap, &bd, lnum, true);\n      if (bd.textlen == 0) {            // nothing to delete\n        continue;\n      }\n\n      /* Adjust cursor position for tab replaced by spaces and 'lbr'. */\n      if (lnum == curwin->w_cursor.lnum) {\n        curwin->w_cursor.col = bd.textcol + bd.startspaces;\n        curwin->w_cursor.coladd = 0;\n      }\n\n      // n == number of chars deleted\n      // If we delete a TAB, it may be replaced by several characters.\n      // Thus the number of characters may increase!\n      n = bd.textlen - bd.startspaces - bd.endspaces;\n      oldp = ml_get(lnum);\n      newp = (char_u *)xmalloc(STRLEN(oldp) - (size_t)n + 1);\n      // copy up to deleted part\n      memmove(newp, oldp, (size_t)bd.textcol);\n      // insert spaces\n      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces +\n             (size_t)bd.endspaces);\n      // copy the part after the deleted part\n      oldp += bd.textcol + bd.textlen;\n      STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);\n      // replace the line\n      ml_replace(lnum, newp, false);\n\n      extmark_splice_cols(curbuf, (int)lnum-1, bd.textcol,\n                          bd.textlen, bd.startspaces+bd.endspaces,\n                          kExtmarkUndo);\n    }\n\n    check_cursor_col();\n    changed_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n                  oap->end.lnum + 1, 0L, true);\n    oap->line_count = 0;  // no lines deleted\n  } else if (oap->motion_type == kMTLineWise) {\n    if (oap->op_type == OP_CHANGE) {\n      // Delete the lines except the first one.  Temporarily move the\n      // cursor to the next line.  Save the current line number, if the\n      // last line is deleted it may be changed.\n\n      if (oap->line_count > 1) {\n        lnum = curwin->w_cursor.lnum;\n        curwin->w_cursor.lnum++;\n        del_lines(oap->line_count - 1, true);\n        curwin->w_cursor.lnum = lnum;\n      }\n      if (u_save_cursor() == FAIL)\n        return FAIL;\n      if (curbuf->b_p_ai) {                 // don't delete indent\n        beginline(BL_WHITE);                // cursor on first non-white\n        did_ai = true;                      // delete the indent when ESC hit\n        ai_col = curwin->w_cursor.col;\n      } else {\n        beginline(0);                       // cursor in column 0\n      }\n\n      int old_len = (int)STRLEN(ml_get(curwin->w_cursor.lnum));\n      truncate_line(false);         // delete the rest of the line\n\n      extmark_splice_cols(curbuf,\n                          (int)curwin->w_cursor.lnum-1, curwin->w_cursor.col,\n                          old_len - curwin->w_cursor.col, 0, kExtmarkUndo);\n\n                                    // leave cursor past last char in line\n      if (oap->line_count > 1) {\n        u_clearline();              // \"U\" command not possible after \"2cc\"\n      }\n    } else {\n      del_lines(oap->line_count, true);\n      beginline(BL_WHITE | BL_FIX);\n      u_clearline();            /* \"U\" command not possible after \"dd\" */\n    }\n  } else {\n    if (virtual_op) {\n      int endcol = 0;\n\n      /* For virtualedit: break the tabs that are partly included. */\n      if (gchar_pos(&oap->start) == '\\t') {\n        if (u_save_cursor() == FAIL)            /* save first line for undo */\n          return FAIL;\n        if (oap->line_count == 1)\n          endcol = getviscol2(oap->end.col, oap->end.coladd);\n        coladvance_force(getviscol2(oap->start.col, oap->start.coladd));\n        oap->start = curwin->w_cursor;\n        if (oap->line_count == 1) {\n          coladvance(endcol);\n          oap->end.col = curwin->w_cursor.col;\n          oap->end.coladd = curwin->w_cursor.coladd;\n          curwin->w_cursor = oap->start;\n        }\n      }\n\n      /* Break a tab only when it's included in the area. */\n      if (gchar_pos(&oap->end) == '\\t'\n          && oap->end.coladd == 0\n          && oap->inclusive) {\n        /* save last line for undo */\n        if (u_save((linenr_T)(oap->end.lnum - 1),\n                (linenr_T)(oap->end.lnum + 1)) == FAIL)\n          return FAIL;\n        curwin->w_cursor = oap->end;\n        coladvance_force(getviscol2(oap->end.col, oap->end.coladd));\n        oap->end = curwin->w_cursor;\n        curwin->w_cursor = oap->start;\n      }\n      mb_adjust_opend(oap);\n    }\n\n    if (oap->line_count == 1) {         /* delete characters within one line */\n      if (u_save_cursor() == FAIL)              /* save line for undo */\n        return FAIL;\n\n      /* if 'cpoptions' contains '$', display '$' at end of change */\n      if (           vim_strchr(p_cpo, CPO_DOLLAR) != NULL\n                     && oap->op_type == OP_CHANGE\n                     && oap->end.lnum == curwin->w_cursor.lnum\n                     && !oap->is_VIsual\n                     )\n        display_dollar(oap->end.col - !oap->inclusive);\n\n      n = oap->end.col - oap->start.col + 1 - !oap->inclusive;\n\n      if (virtual_op) {\n        /* fix up things for virtualedit-delete:\n         * break the tabs which are going to get in our way\n         */\n        char_u          *curline = get_cursor_line_ptr();\n        int len = (int)STRLEN(curline);\n\n        if (oap->end.coladd != 0\n            && (int)oap->end.col >= len - 1\n            && !(oap->start.coladd && (int)oap->end.col >= len - 1))\n          n++;\n        /* Delete at least one char (e.g, when on a control char). */\n        if (n == 0 && oap->start.coladd != oap->end.coladd)\n          n = 1;\n\n        /* When deleted a char in the line, reset coladd. */\n        if (gchar_cursor() != NUL)\n          curwin->w_cursor.coladd = 0;\n      }\n\n      (void)del_bytes((colnr_T)n, !virtual_op,\n                      oap->op_type == OP_DELETE && !oap->is_VIsual);\n    } else {\n      // delete characters between lines\n      pos_T curpos;\n\n      /* save deleted and changed lines for undo */\n      if (u_save((linenr_T)(curwin->w_cursor.lnum - 1),\n              (linenr_T)(curwin->w_cursor.lnum + oap->line_count)) == FAIL)\n        return FAIL;\n\n      curbuf_splice_pending++;\n      pos_T startpos = curwin->w_cursor;  // start position for delete\n      bcount_t deleted_bytes = get_region_bytecount(\n          curbuf, startpos.lnum, oap->end.lnum, startpos.col,\n          oap->end.col) + oap->inclusive;\n      truncate_line(true);        // delete from cursor to end of line\n\n      curpos = curwin->w_cursor;  // remember curwin->w_cursor\n      curwin->w_cursor.lnum++;\n\n      del_lines(oap->line_count - 2, false);\n\n      // delete from start of line until op_end\n      n = (oap->end.col + 1 - !oap->inclusive);\n      curwin->w_cursor.col = 0;\n      (void)del_bytes((colnr_T)n, !virtual_op,\n                      oap->op_type == OP_DELETE && !oap->is_VIsual);\n      curwin->w_cursor = curpos;  // restore curwin->w_cursor\n      (void)do_join(2, false, false, false, false);\n      curbuf_splice_pending--;\n      extmark_splice(curbuf, (int)startpos.lnum-1, startpos.col,\n                     (int)oap->line_count-1, n, deleted_bytes,\n                     0, 0, 0, kExtmarkUndo);\n    }\n    auto_format(false, true);\n  }\n\n  msgmore(curbuf->b_ml.ml_line_count - old_lcount);\n\nsetmarks:\n  if (oap->motion_type == kMTBlockWise) {\n    curbuf->b_op_end.lnum = oap->end.lnum;\n    curbuf->b_op_end.col = oap->start.col;\n  } else {\n    curbuf->b_op_end = oap->start;\n  }\n  curbuf->b_op_start = oap->start;\n\n  return OK;\n}\n\n/*\n * Adjust end of operating area for ending on a multi-byte character.\n * Used for deletion.\n */\nstatic void mb_adjust_opend(oparg_T *oap)\n{\n  char_u      *p;\n\n  if (oap->inclusive) {\n    p = ml_get(oap->end.lnum);\n    oap->end.col += mb_tail_off(p, p + oap->end.col);\n  }\n}\n\n/*\n * Put character 'c' at position 'lp'\n */\nstatic inline void pbyte(pos_T lp, int c)\n{\n  assert(c <= UCHAR_MAX);\n  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char_u)c;\n  if (!curbuf_splice_pending) {\n    extmark_splice_cols(curbuf, (int)lp.lnum-1, lp.col, 1, 1, kExtmarkUndo);\n  }\n}\n\n// Replace the character under the cursor with \"c\".\n// This takes care of multi-byte characters.\nstatic void replace_character(int c)\n{\n  const int n = State;\n\n  State = REPLACE;\n  ins_char(c);\n  State = n;\n  // Backup to the replaced character.\n  dec_cursor();\n}\n\n/*\n * Replace a whole area with one character.\n */\nint op_replace(oparg_T *oap, int c)\n{\n  int n, numc;\n  int num_chars;\n  char_u              *newp, *oldp;\n  colnr_T oldlen;\n  struct block_def bd;\n  char_u              *after_p = NULL;\n  int had_ctrl_v_cr = false;\n\n  if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n    return OK;              /* nothing to do */\n\n  if (c == REPLACE_CR_NCHAR) {\n    had_ctrl_v_cr = true;\n    c = CAR;\n  } else if (c == REPLACE_NL_NCHAR) {\n    had_ctrl_v_cr = true;\n    c = NL;\n  }\n\n  mb_adjust_opend(oap);\n\n  if (u_save((linenr_T)(oap->start.lnum - 1),\n          (linenr_T)(oap->end.lnum + 1)) == FAIL)\n    return FAIL;\n\n  /*\n   * block mode replace\n   */\n  if (oap->motion_type == kMTBlockWise) {\n    bd.is_MAX = (curwin->w_curswant == MAXCOL);\n    for (; curwin->w_cursor.lnum <= oap->end.lnum; curwin->w_cursor.lnum++) {\n      curwin->w_cursor.col = 0;       // make sure cursor position is valid\n      block_prep(oap, &bd, curwin->w_cursor.lnum, true);\n      if (bd.textlen == 0 && (!virtual_op || bd.is_MAX)) {\n        continue;                     // nothing to replace\n      }\n\n      /* n == number of extra chars required\n       * If we split a TAB, it may be replaced by several characters.\n       * Thus the number of characters may increase!\n       */\n      /* If the range starts in virtual space, count the initial\n       * coladd offset as part of \"startspaces\" */\n      if (virtual_op && bd.is_short && *bd.textstart == NUL) {\n        pos_T vpos;\n\n        vpos.lnum = curwin->w_cursor.lnum;\n        getvpos(&vpos, oap->start_vcol);\n        bd.startspaces += vpos.coladd;\n        n = bd.startspaces;\n      } else\n        /* allow for pre spaces */\n        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n      /* allow for post spp */\n      n += (bd.endspaces\n            && !bd.is_oneChar\n            && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n      /* Figure out how many characters to replace. */\n      numc = oap->end_vcol - oap->start_vcol + 1;\n      if (bd.is_short && (!virtual_op || bd.is_MAX))\n        numc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n      /* A double-wide character can be replaced only up to half the\n       * times. */\n      if ((*mb_char2cells)(c) > 1) {\n        if ((numc & 1) && !bd.is_short) {\n          ++bd.endspaces;\n          ++n;\n        }\n        numc = numc / 2;\n      }\n\n      /* Compute bytes needed, move character count to num_chars. */\n      num_chars = numc;\n      numc *= (*mb_char2len)(c);\n\n      oldp = get_cursor_line_ptr();\n      oldlen = (int)STRLEN(oldp);\n\n      size_t newp_size = (size_t)bd.textcol + (size_t)bd.startspaces;\n      if (had_ctrl_v_cr || (c != '\\r' && c != '\\n')) {\n        newp_size += (size_t)numc;\n        if (!bd.is_short) {\n          newp_size += (size_t)(bd.endspaces + oldlen\n                                - bd.textcol - bd.textlen);\n        }\n      }\n      newp = xmallocz(newp_size);\n      // copy up to deleted part\n      memmove(newp, oldp, (size_t)bd.textcol);\n      oldp += bd.textcol + bd.textlen;\n      // insert pre-spaces\n      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n      // insert replacement chars CHECK FOR ALLOCATED SPACE\n      // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR literally.\n      size_t after_p_len = 0;\n      int col = oldlen - bd.textcol - bd.textlen + 1;\n      assert(col >= 0);\n      int newrows = 0, newcols = 0;\n      if (had_ctrl_v_cr || (c != '\\r' && c != '\\n')) {\n          // strlen(newp) at this point\n          int newp_len = bd.textcol + bd.startspaces;\n          while (--num_chars >= 0) {\n            newp_len += utf_char2bytes(c, newp + newp_len);\n          }\n          if (!bd.is_short) {\n            // insert post-spaces\n            memset(newp + newp_len, ' ', (size_t)bd.endspaces);\n            newp_len += bd.endspaces;\n            // copy the part after the changed part\n            memmove(newp + newp_len, oldp, (size_t)col);\n          }\n          newcols = newp_len - bd.textcol;\n      } else {\n        // Replacing with \\r or \\n means splitting the line.\n        after_p_len = (size_t)col;\n        after_p = (char_u *)xmalloc(after_p_len);\n        memmove(after_p, oldp, after_p_len);\n        newrows = 1;\n      }\n      // replace the line\n      ml_replace(curwin->w_cursor.lnum, newp, false);\n      curbuf_splice_pending++;\n      linenr_T baselnum = curwin->w_cursor.lnum;\n      if (after_p != NULL) {\n        ml_append(curwin->w_cursor.lnum++, after_p, (int)after_p_len, false);\n        appended_lines_mark(curwin->w_cursor.lnum, 1L);\n        oap->end.lnum++;\n        xfree(after_p);\n      }\n      curbuf_splice_pending--;\n      extmark_splice(curbuf, (int)baselnum-1, bd.textcol,\n                     0, bd.textlen, bd.textlen,\n                     newrows, newcols, newrows+newcols, kExtmarkUndo);\n    }\n  } else {\n    // Characterwise or linewise motion replace.\n    if (oap->motion_type == kMTLineWise) {\n      oap->start.col = 0;\n      curwin->w_cursor.col = 0;\n      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n      if (oap->end.col)\n        --oap->end.col;\n    } else if (!oap->inclusive)\n      dec(&(oap->end));\n\n    // TODO(bfredl): we could batch all the splicing\n    // done on the same line, at least\n    while (ltoreq(curwin->w_cursor, oap->end)) {\n      n = gchar_cursor();\n      if (n != NUL) {\n        if ((*mb_char2len)(c) > 1 || (*mb_char2len)(n) > 1) {\n          /* This is slow, but it handles replacing a single-byte\n           * with a multi-byte and the other way around. */\n          if (curwin->w_cursor.lnum == oap->end.lnum)\n            oap->end.col += (*mb_char2len)(c) - (*mb_char2len)(n);\n          replace_character(c);\n        } else {\n          if (n == TAB) {\n            int end_vcol = 0;\n\n            if (curwin->w_cursor.lnum == oap->end.lnum) {\n              /* oap->end has to be recalculated when\n               * the tab breaks */\n              end_vcol = getviscol2(oap->end.col,\n                  oap->end.coladd);\n            }\n            coladvance_force(getviscol());\n            if (curwin->w_cursor.lnum == oap->end.lnum)\n              getvpos(&oap->end, end_vcol);\n          }\n          pbyte(curwin->w_cursor, c);\n        }\n      } else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum) {\n        int virtcols = oap->end.coladd;\n\n        if (curwin->w_cursor.lnum == oap->start.lnum\n            && oap->start.col == oap->end.col && oap->start.coladd)\n          virtcols -= oap->start.coladd;\n\n        /* oap->end has been trimmed so it's effectively inclusive;\n         * as a result an extra +1 must be counted so we don't\n         * trample the NUL byte. */\n        coladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n        curwin->w_cursor.col -= (virtcols + 1);\n        for (; virtcols >= 0; virtcols--) {\n          if (utf_char2len(c) > 1) {\n            replace_character(c);\n          } else {\n            pbyte(curwin->w_cursor, c);\n          }\n          if (inc(&curwin->w_cursor) == -1) {\n            break;\n          }\n        }\n      }\n\n      /* Advance to next character, stop at the end of the file. */\n      if (inc_cursor() == -1)\n        break;\n    }\n  }\n\n  curwin->w_cursor = oap->start;\n  check_cursor();\n  changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L, true);\n\n  /* Set \"'[\" and \"']\" marks. */\n  curbuf->b_op_start = oap->start;\n  curbuf->b_op_end = oap->end;\n\n  return OK;\n}\n\n\n/*\n * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\".\n */\nvoid op_tilde(oparg_T *oap)\n{\n  pos_T pos;\n  struct block_def bd;\n  int did_change = FALSE;\n\n  if (u_save((linenr_T)(oap->start.lnum - 1),\n          (linenr_T)(oap->end.lnum + 1)) == FAIL)\n    return;\n\n  pos = oap->start;\n  if (oap->motion_type == kMTBlockWise) {  // Visual block mode\n    for (; pos.lnum <= oap->end.lnum; pos.lnum++) {\n      int one_change;\n\n      block_prep(oap, &bd, pos.lnum, false);\n      pos.col = bd.textcol;\n      one_change = swapchars(oap->op_type, &pos, bd.textlen);\n      did_change |= one_change;\n\n    }\n    if (did_change) {\n      changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L, true);\n    }\n  } else {  // not block mode\n    if (oap->motion_type == kMTLineWise) {\n      oap->start.col = 0;\n      pos.col = 0;\n      oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n      if (oap->end.col)\n        --oap->end.col;\n    } else if (!oap->inclusive)\n      dec(&(oap->end));\n\n    if (pos.lnum == oap->end.lnum)\n      did_change = swapchars(oap->op_type, &pos,\n          oap->end.col - pos.col + 1);\n    else\n      for (;; ) {\n        did_change |= swapchars(oap->op_type, &pos,\n            pos.lnum == oap->end.lnum ? oap->end.col + 1 :\n            (int)STRLEN(ml_get_pos(&pos)));\n        if (ltoreq(oap->end, pos) || inc(&pos) == -1)\n          break;\n      }\n    if (did_change) {\n      changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,\n                    0L, true);\n    }\n  }\n\n  if (!did_change && oap->is_VIsual)\n    /* No change: need to remove the Visual selection */\n    redraw_curbuf_later(INVERTED);\n\n  /*\n   * Set '[ and '] marks.\n   */\n  curbuf->b_op_start = oap->start;\n  curbuf->b_op_end = oap->end;\n\n  if (oap->line_count > p_report) {\n    if (oap->line_count == 1)\n      MSG(_(\"1 line changed\"));\n    else\n      smsg(_(\"%\" PRId64 \" lines changed\"), (int64_t)oap->line_count);\n  }\n}\n\n/*\n * Invoke swapchar() on \"length\" bytes at position \"pos\".\n * \"pos\" is advanced to just after the changed characters.\n * \"length\" is rounded up to include the whole last multi-byte character.\n * Also works correctly when the number of bytes changes.\n * Returns TRUE if some character was changed.\n */\nstatic int swapchars(int op_type, pos_T *pos, int length)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int did_change = 0;\n\n  for (int todo = length; todo > 0; todo--) {\n    const int len = utfc_ptr2len(ml_get_pos(pos));\n\n    // we're counting bytes, not characters\n    if (len > 0) {\n      todo -= len - 1;\n    }\n    did_change |= swapchar(op_type, pos);\n    if (inc(pos) == -1)        /* at end of file */\n      break;\n  }\n  return did_change;\n}\n\n// If op_type == OP_UPPER: make uppercase,\n// if op_type == OP_LOWER: make lowercase,\n// if op_type == OP_ROT13: do rot13 encoding,\n// else swap case of character at 'pos'\n// returns true when something actually changed.\nbool swapchar(int op_type, pos_T *pos)\n  FUNC_ATTR_NONNULL_ARG(2)\n{\n  const int c = gchar_pos(pos);\n\n  // Only do rot13 encoding for ASCII characters.\n  if (c >= 0x80 && op_type == OP_ROT13) {\n    return false;\n  }\n\n  if (op_type == OP_UPPER && c == 0xdf) {\n    pos_T sp = curwin->w_cursor;\n\n    /* Special handling of German sharp s: change to \"SS\". */\n    curwin->w_cursor = *pos;\n    del_char(false);\n    ins_char('S');\n    ins_char('S');\n    curwin->w_cursor = sp;\n    inc(pos);\n  }\n\n  int nc = c;\n  if (mb_islower(c)) {\n    if (op_type == OP_ROT13) {\n      nc = ROT13(c, 'a');\n    } else if (op_type != OP_LOWER) {\n      nc = mb_toupper(c);\n    }\n  } else if (mb_isupper(c)) {\n    if (op_type == OP_ROT13) {\n      nc = ROT13(c, 'A');\n    } else if (op_type != OP_UPPER) {\n      nc = mb_tolower(c);\n    }\n  }\n  if (nc != c) {\n    if (c >= 0x80 || nc >= 0x80) {\n      pos_T sp = curwin->w_cursor;\n\n      curwin->w_cursor = *pos;\n      // don't use del_char(), it also removes composing chars\n      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), false, false);\n      ins_char(nc);\n      curwin->w_cursor = sp;\n    } else {\n      pbyte(*pos, nc);\n    }\n    return true;\n  }\n  return false;\n}\n\n/*\n * op_insert - Insert and append operators for Visual mode.\n */\nvoid op_insert(oparg_T *oap, long count1)\n{\n  long ins_len, pre_textlen = 0;\n  char_u              *firstline, *ins_text;\n  colnr_T ind_pre = 0;\n  struct block_def bd;\n  int i;\n  pos_T t1;\n\n  /* edit() changes this - record it for OP_APPEND */\n  bd.is_MAX = (curwin->w_curswant == MAXCOL);\n\n  /* vis block is still marked. Get rid of it now. */\n  curwin->w_cursor.lnum = oap->start.lnum;\n  update_screen(INVERTED);\n\n  if (oap->motion_type == kMTBlockWise) {\n    // When 'virtualedit' is used, need to insert the extra spaces before\n    // doing block_prep().  When only \"block\" is used, virtual edit is\n    // already disabled, but still need it when calling\n    // coladvance_force().\n    if (curwin->w_cursor.coladd > 0) {\n      unsigned old_ve_flags = ve_flags;\n\n      ve_flags = VE_ALL;\n      if (u_save_cursor() == FAIL)\n        return;\n      coladvance_force(oap->op_type == OP_APPEND\n          ? oap->end_vcol + 1 : getviscol());\n      if (oap->op_type == OP_APPEND)\n        --curwin->w_cursor.col;\n      ve_flags = old_ve_flags;\n    }\n    // Get the info about the block before entering the text\n    block_prep(oap, &bd, oap->start.lnum, true);\n    // Get indent information\n    ind_pre = (colnr_T)getwhitecols_curline();\n    firstline = ml_get(oap->start.lnum) + bd.textcol;\n\n    if (oap->op_type == OP_APPEND) {\n      firstline += bd.textlen;\n    }\n    pre_textlen = (long)STRLEN(firstline);\n  }\n\n  if (oap->op_type == OP_APPEND) {\n    if (oap->motion_type == kMTBlockWise\n        && curwin->w_cursor.coladd == 0\n        ) {\n      /* Move the cursor to the character right of the block. */\n      curwin->w_set_curswant = TRUE;\n      while (*get_cursor_pos_ptr() != NUL\n             && (curwin->w_cursor.col < bd.textcol + bd.textlen))\n        ++curwin->w_cursor.col;\n      if (bd.is_short && !bd.is_MAX) {\n        /* First line was too short, make it longer and adjust the\n         * values in \"bd\". */\n        if (u_save_cursor() == FAIL)\n          return;\n        for (i = 0; i < bd.endspaces; i++) {\n          ins_char(' ');\n        }\n        bd.textlen += bd.endspaces;\n      }\n    } else {\n      curwin->w_cursor = oap->end;\n      check_cursor_col();\n\n      // Works just like an 'i'nsert on the next character.\n      if (!LINEEMPTY(curwin->w_cursor.lnum)\n          && oap->start_vcol != oap->end_vcol) {\n        inc_cursor();\n      }\n    }\n  }\n\n  t1 = oap->start;\n  (void)edit(NUL, false, (linenr_T)count1);\n\n  // When a tab was inserted, and the characters in front of the tab\n  // have been converted to a tab as well, the column of the cursor\n  // might have actually been reduced, so need to adjust here. */\n  if (t1.lnum == curbuf->b_op_start_orig.lnum\n      && lt(curbuf->b_op_start_orig, t1)) {\n    oap->start = curbuf->b_op_start_orig;\n  }\n\n  /* If user has moved off this line, we don't know what to do, so do\n   * nothing.\n   * Also don't repeat the insert when Insert mode ended with CTRL-C. */\n  if (curwin->w_cursor.lnum != oap->start.lnum || got_int)\n    return;\n\n  if (oap->motion_type == kMTBlockWise) {\n    struct block_def bd2;\n    bool did_indent = false;\n\n    // if indent kicked in, the firstline might have changed\n    // but only do that, if the indent actually increased\n    const colnr_T ind_post = (colnr_T)getwhitecols_curline();\n    if (curbuf->b_op_start.col > ind_pre && ind_post > ind_pre) {\n      bd.textcol += ind_post - ind_pre;\n      bd.start_vcol += ind_post - ind_pre;\n      did_indent = true;\n    }\n\n    // The user may have moved the cursor before inserting something, try\n    // to adjust the block for that.  But only do it, if the difference\n    // does not come from indent kicking in.\n    if (oap->start.lnum == curbuf->b_op_start_orig.lnum\n        && !bd.is_MAX\n        && !did_indent) {\n      if (oap->op_type == OP_INSERT\n          && oap->start.col + oap->start.coladd\n          != curbuf->b_op_start_orig.col + curbuf->b_op_start_orig.coladd) {\n        int t = getviscol2(curbuf->b_op_start_orig.col,\n                           curbuf->b_op_start_orig.coladd);\n        oap->start.col = curbuf->b_op_start_orig.col;\n        pre_textlen -= t - oap->start_vcol;\n        oap->start_vcol = t;\n      } else if (oap->op_type == OP_APPEND\n                 && oap->end.col + oap->end.coladd\n                 >= curbuf->b_op_start_orig.col\n                 + curbuf->b_op_start_orig.coladd) {\n        int t = getviscol2(curbuf->b_op_start_orig.col,\n                           curbuf->b_op_start_orig.coladd);\n        oap->start.col = curbuf->b_op_start_orig.col;\n        /* reset pre_textlen to the value of OP_INSERT */\n        pre_textlen += bd.textlen;\n        pre_textlen -= t - oap->start_vcol;\n        oap->start_vcol = t;\n        oap->op_type = OP_INSERT;\n      }\n    }\n\n    /*\n     * Spaces and tabs in the indent may have changed to other spaces and\n     * tabs.  Get the starting column again and correct the length.\n     * Don't do this when \"$\" used, end-of-line will have changed.\n     */\n    block_prep(oap, &bd2, oap->start.lnum, true);\n    if (!bd.is_MAX || bd2.textlen < bd.textlen) {\n      if (oap->op_type == OP_APPEND) {\n        pre_textlen += bd2.textlen - bd.textlen;\n        if (bd2.endspaces)\n          --bd2.textlen;\n      }\n      bd.textcol = bd2.textcol;\n      bd.textlen = bd2.textlen;\n    }\n\n    /*\n     * Subsequent calls to ml_get() flush the firstline data - take a\n     * copy of the required string.\n     */\n    firstline = ml_get(oap->start.lnum);\n    const size_t len = STRLEN(firstline);\n    colnr_T add = bd.textcol;\n    if (oap->op_type == OP_APPEND) {\n      add += bd.textlen;\n    }\n    if ((size_t)add > len) {\n      firstline += len;  // short line, point to the NUL\n    } else {\n      firstline += add;\n    }\n    ins_len = (long)STRLEN(firstline) - pre_textlen;\n    if (pre_textlen >= 0 && ins_len > 0) {\n      ins_text = vim_strnsave(firstline, (size_t)ins_len);\n      // block handled here\n      if (u_save(oap->start.lnum, (linenr_T)(oap->end.lnum + 1)) == OK) {\n        block_insert(oap, ins_text, (oap->op_type == OP_INSERT), &bd);\n      }\n\n      curwin->w_cursor.col = oap->start.col;\n      check_cursor();\n      xfree(ins_text);\n    }\n  }\n}\n\n/*\n * op_change - handle a change operation\n *\n * return TRUE if edit() returns because of a CTRL-O command\n */\nint op_change(oparg_T *oap)\n{\n  colnr_T l;\n  int retval;\n  long offset;\n  linenr_T linenr;\n  long ins_len;\n  long pre_textlen = 0;\n  long pre_indent = 0;\n  char_u *newp;\n  char_u *firstline;\n  char_u *ins_text;\n  char_u *oldp;\n  struct block_def bd;\n\n  l = oap->start.col;\n  if (oap->motion_type == kMTLineWise) {\n    l = 0;\n    if (!p_paste && curbuf->b_p_si\n        && !curbuf->b_p_cin\n        )\n      can_si = true;            // It's like opening a new line, do si\n  }\n\n  /* First delete the text in the region.  In an empty buffer only need to\n   * save for undo */\n  if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n    if (u_save_cursor() == FAIL)\n      return FALSE;\n  } else if (op_delete(oap) == FAIL)\n    return FALSE;\n\n  if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)\n      && !virtual_op) {\n    inc_cursor();\n  }\n\n  // check for still on same line (<CR> in inserted text meaningless)\n  // skip blank lines too\n  if (oap->motion_type == kMTBlockWise) {\n    // Add spaces before getting the current line length.\n    if (virtual_op && (curwin->w_cursor.coladd > 0\n                       || gchar_cursor() == NUL)) {\n      coladvance_force(getviscol());\n    }\n    firstline = ml_get(oap->start.lnum);\n    pre_textlen = (long)STRLEN(firstline);\n    pre_indent = (long)getwhitecols(firstline);\n    bd.textcol = curwin->w_cursor.col;\n  }\n\n  if (oap->motion_type == kMTLineWise) {\n    fix_indent();\n  }\n\n  retval = edit(NUL, FALSE, (linenr_T)1);\n\n  /*\n   * In Visual block mode, handle copying the new text to all lines of the\n   * block.\n   * Don't repeat the insert when Insert mode ended with CTRL-C.\n   */\n  if (oap->motion_type == kMTBlockWise\n      && oap->start.lnum != oap->end.lnum && !got_int) {\n    // Auto-indenting may have changed the indent.  If the cursor was past\n    // the indent, exclude that indent change from the inserted text.\n    firstline = ml_get(oap->start.lnum);\n    if (bd.textcol > (colnr_T)pre_indent) {\n      long new_indent = (long)getwhitecols(firstline);\n\n      pre_textlen += new_indent - pre_indent;\n      bd.textcol += (colnr_T)(new_indent - pre_indent);\n    }\n\n    ins_len = (long)STRLEN(firstline) - pre_textlen;\n    if (ins_len > 0) {\n      /* Subsequent calls to ml_get() flush the firstline data - take a\n       * copy of the inserted text.  */\n      ins_text = (char_u *)xmalloc((size_t)(ins_len + 1));\n      STRLCPY(ins_text, firstline + bd.textcol, ins_len + 1);\n      for (linenr = oap->start.lnum + 1; linenr <= oap->end.lnum;\n           linenr++) {\n        block_prep(oap, &bd, linenr, true);\n        if (!bd.is_short || virtual_op) {\n          pos_T vpos;\n\n          /* If the block starts in virtual space, count the\n           * initial coladd offset as part of \"startspaces\" */\n          if (bd.is_short) {\n            vpos.lnum = linenr;\n            (void)getvpos(&vpos, oap->start_vcol);\n          } else {\n            vpos.coladd = 0;\n          }\n          oldp = ml_get(linenr);\n          newp = xmalloc(STRLEN(oldp) + (size_t)vpos.coladd\n                         + (size_t)ins_len + 1);\n          // copy up to block start\n          memmove(newp, oldp, (size_t)bd.textcol);\n          offset = bd.textcol;\n          memset(newp + offset, ' ', (size_t)vpos.coladd);\n          offset += vpos.coladd;\n          memmove(newp + offset, ins_text, (size_t)ins_len);\n          offset += ins_len;\n          oldp += bd.textcol;\n          STRMOVE(newp + offset, oldp);\n          ml_replace(linenr, newp, false);\n          extmark_splice_cols(curbuf, (int)linenr-1, bd.textcol,\n                              0, vpos.coladd+(int)ins_len, kExtmarkUndo);\n        }\n      }\n      check_cursor();\n      changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L, true);\n      xfree(ins_text);\n    }\n  }\n\n  return retval;\n}\n\n/*\n * set all the yank registers to empty (called from main())\n */\nvoid init_yank(void)\n{\n  memset(&(y_regs[0]), 0, sizeof(y_regs));\n}\n\n#if defined(EXITFREE)\nvoid clear_registers(void)\n{\n  int i;\n\n  for (i = 0; i < NUM_REGISTERS; i++) {\n    free_register(&y_regs[i]);\n  }\n}\n\n#endif\n\n\n /// Free contents of yankreg `reg`.\n /// Called for normal freeing and in case of error.\n /// `reg` must not be NULL (but `reg->y_array` might be)\nvoid free_register(yankreg_T *reg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  set_yreg_additional_data(reg, NULL);\n  if (reg->y_array != NULL) {\n    for (size_t i = reg->y_size; i-- > 0;) {  // from y_size - 1 to 0 included\n      xfree(reg->y_array[i]);\n    }\n    XFREE_CLEAR(reg->y_array);\n  }\n}\n\n/// Yanks the text between \"oap->start\" and \"oap->end\" into a yank register.\n/// If we are to append (uppercase register), we first yank into a new yank\n/// register and then concatenate the old and the new one.\n///\n/// @param oap operator arguments\n/// @param message show message when more than `&report` lines are yanked.\n/// @param deleting whether the function was called from a delete operation.\n/// @returns whether the operation register was writable.\nbool op_yank(oparg_T *oap, bool message, int deleting)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // check for read-only register\n  if (oap->regname != 0 && !valid_yank_reg(oap->regname, true)) {\n    beep_flush();\n    return false;\n  }\n  if (oap->regname == '_') {\n    return true; // black hole: nothing to do\n  }\n\n  yankreg_T *reg = get_yank_register(oap->regname, YREG_YANK);\n  op_yank_reg(oap, message, reg, is_append_register(oap->regname));\n  // op_delete will set_clipboard and do_autocmd\n  if (!deleting) {\n    set_clipboard(oap->regname, reg);\n    do_autocmd_textyankpost(oap, reg);\n  }\n\n  return true;\n}\n\nstatic void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)\n{\n  yankreg_T newreg;  // new yank register when appending\n  char_u **new_ptr;\n  linenr_T lnum;     // current line number\n  size_t j;\n  MotionType yank_type = oap->motion_type;\n  size_t yanklines = (size_t)oap->line_count;\n  linenr_T yankendlnum = oap->end.lnum;\n  char_u *p;\n  char_u *pnew;\n  struct block_def bd;\n\n  yankreg_T *curr = reg;  // copy of current register\n  // append to existing contents\n  if (append && reg->y_array != NULL) {\n    reg = &newreg;\n  } else {\n    free_register(reg);  // free previously yanked lines\n  }\n\n  // If the cursor was in column 1 before and after the movement, and the\n  // operator is not inclusive, the yank is always linewise.\n  if (oap->motion_type == kMTCharWise\n      && oap->start.col == 0\n      && !oap->inclusive\n      && (!oap->is_VIsual || *p_sel == 'o')\n      && oap->end.col == 0\n      && yanklines > 1) {\n    yank_type = kMTLineWise;\n    yankendlnum--;\n    yanklines--;\n  }\n\n  reg->y_size = yanklines;\n  reg->y_type = yank_type;  // set the yank register type\n  reg->y_width = 0;\n  reg->y_array = xcalloc(yanklines, sizeof(char_u *));\n  reg->additional_data = NULL;\n  reg->timestamp = os_time();\n\n  size_t y_idx = 0;  // index in y_array[]\n  lnum = oap->start.lnum;\n\n  if (yank_type == kMTBlockWise) {\n    // Visual block mode\n    reg->y_width = oap->end_vcol - oap->start_vcol;\n\n    if (curwin->w_curswant == MAXCOL && reg->y_width > 0)\n      reg->y_width--;\n  }\n\n  for (; lnum <= yankendlnum; lnum++, y_idx++) {\n    switch (reg->y_type) {\n    case kMTBlockWise:\n      block_prep(oap, &bd, lnum, false);\n      yank_copy_line(reg, &bd, y_idx, oap->excl_tr_ws);\n      break;\n\n    case kMTLineWise:\n      reg->y_array[y_idx] = vim_strsave(ml_get(lnum));\n      break;\n\n    case kMTCharWise:\n    {\n      colnr_T startcol = 0, endcol = MAXCOL;\n      int is_oneChar = false;\n      colnr_T cs, ce;\n      p = ml_get(lnum);\n      bd.startspaces = 0;\n      bd.endspaces = 0;\n\n      if (lnum == oap->start.lnum) {\n        startcol = oap->start.col;\n        if (virtual_op) {\n          getvcol(curwin, &oap->start, &cs, NULL, &ce);\n          if (ce != cs && oap->start.coladd > 0) {\n            /* Part of a tab selected -- but don't\n             * double-count it. */\n            bd.startspaces = (ce - cs + 1)\n                             - oap->start.coladd;\n            startcol++;\n          }\n        }\n      }\n\n      if (lnum == oap->end.lnum) {\n        endcol = oap->end.col;\n        if (virtual_op) {\n          getvcol(curwin, &oap->end, &cs, NULL, &ce);\n          if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n                                   // Don't add space for double-wide\n                                   // char; endcol will be on last byte\n                                   // of multi-byte char.\n                                   && utf_head_off(p, p + endcol) == 0)) {\n            if (oap->start.lnum == oap->end.lnum\n                && oap->start.col == oap->end.col) {\n              // Special case: inside a single char\n              is_oneChar = true;\n              bd.startspaces = oap->end.coladd\n                               - oap->start.coladd + oap->inclusive;\n              endcol = startcol;\n            } else {\n              bd.endspaces = oap->end.coladd\n                             + oap->inclusive;\n              endcol -= oap->inclusive;\n            }\n          }\n        }\n      }\n      if (endcol == MAXCOL)\n        endcol = (colnr_T)STRLEN(p);\n      if (startcol > endcol\n          || is_oneChar\n          ) {\n        bd.textlen = 0;\n      } else {\n        bd.textlen = endcol - startcol + oap->inclusive;\n      }\n      bd.textstart = p + startcol;\n      yank_copy_line(reg, &bd, y_idx, false);\n      break;\n    }\n    // NOTREACHED\n    case kMTUnknown:\n        abort();\n    }\n  }\n\n  if (curr != reg) {      /* append the new block to the old block */\n    new_ptr = xmalloc(sizeof(char_u *) * (curr->y_size + reg->y_size));\n    for (j = 0; j < curr->y_size; ++j)\n      new_ptr[j] = curr->y_array[j];\n    xfree(curr->y_array);\n    curr->y_array = new_ptr;\n\n    if (yank_type == kMTLineWise) {\n      // kMTLineWise overrides kMTCharWise and kMTBlockWise\n      curr->y_type = kMTLineWise;\n    }\n\n    // Concatenate the last line of the old block with the first line of\n    // the new block, unless being Vi compatible.\n    if (curr->y_type == kMTCharWise\n        && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL) {\n      pnew = xmalloc(STRLEN(curr->y_array[curr->y_size - 1])\n                     + STRLEN(reg->y_array[0]) + 1);\n      STRCPY(pnew, curr->y_array[--j]);\n      STRCAT(pnew, reg->y_array[0]);\n      xfree(curr->y_array[j]);\n      xfree(reg->y_array[0]);\n      curr->y_array[j++] = pnew;\n      y_idx = 1;\n    } else\n      y_idx = 0;\n    while (y_idx < reg->y_size)\n      curr->y_array[j++] = reg->y_array[y_idx++];\n    curr->y_size = j;\n    xfree(reg->y_array);\n  }\n  if (curwin->w_p_rnu) {\n    redraw_later(curwin, SOME_VALID);  // cursor moved to start\n  }\n  if (message) {  // Display message about yank?\n    if (yank_type == kMTCharWise && yanklines == 1) {\n      yanklines = 0;\n    }\n    // Some versions of Vi use \">=\" here, some don't...\n    if (yanklines > (size_t)p_report) {\n      char namebuf[100];\n\n      if (oap->regname == NUL) {\n        *namebuf = NUL;\n      } else {\n        vim_snprintf(namebuf, sizeof(namebuf), _(\" into \\\"%c\"), oap->regname);\n      }\n\n      // redisplay now, so message is not deleted\n      update_topline_redraw();\n      if (yanklines == 1) {\n        if (yank_type == kMTBlockWise) {\n          smsg(_(\"block of 1 line yanked%s\"), namebuf);\n        } else {\n          smsg(_(\"1 line yanked%s\"), namebuf);\n        }\n      } else if (yank_type == kMTBlockWise) {\n        smsg(_(\"block of %\" PRId64 \" lines yanked%s\"),\n             (int64_t)yanklines, namebuf);\n      } else {\n        smsg(_(\"%\" PRId64 \" lines yanked%s\"), (int64_t)yanklines, namebuf);\n      }\n    }\n  }\n\n  /*\n   * Set \"'[\" and \"']\" marks.\n   */\n  curbuf->b_op_start = oap->start;\n  curbuf->b_op_end = oap->end;\n  if (yank_type == kMTLineWise) {\n    curbuf->b_op_start.col = 0;\n    curbuf->b_op_end.col = MAXCOL;\n  }\n\n  return;\n}\n\n// Copy a block range into a register.\n// If \"exclude_trailing_space\" is set, do not copy trailing whitespaces.\nstatic void yank_copy_line(yankreg_T *reg, struct block_def *bd,\n                           size_t y_idx, bool exclude_trailing_space)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (exclude_trailing_space) {\n    bd->endspaces = 0;\n  }\n  int size = bd->startspaces + bd->endspaces + bd->textlen;\n  assert(size >= 0);\n  char_u *pnew = xmallocz((size_t)size);\n  reg->y_array[y_idx] = pnew;\n  memset(pnew, ' ', (size_t)bd->startspaces);\n  pnew += bd->startspaces;\n  memmove(pnew, bd->textstart, (size_t)bd->textlen);\n  pnew += bd->textlen;\n  memset(pnew, ' ', (size_t)bd->endspaces);\n  pnew += bd->endspaces;\n  if (exclude_trailing_space) {\n    int s = bd->textlen + bd->endspaces;\n\n    while (ascii_iswhite(*(bd->textstart + s - 1)) && s > 0) {\n      s = s - utf_head_off(bd->textstart, bd->textstart + s - 1) - 1;\n      pnew--;\n    }\n  }\n  *pnew = NUL;\n}\n\n/// Execute autocommands for TextYankPost.\n///\n/// @param oap Operator arguments.\n/// @param reg The yank register used.\nstatic void do_autocmd_textyankpost(oparg_T *oap, yankreg_T *reg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  static bool recursive = false;\n\n  if (recursive || !has_event(EVENT_TEXTYANKPOST)) {\n    // No autocommand was defined, or we yanked from this autocommand.\n    return;\n  }\n\n  recursive = true;\n\n  // Set the v:event dictionary with information about the yank.\n  dict_T *dict = get_vim_var_dict(VV_EVENT);\n\n  // The yanked text contents.\n  list_T *const list = tv_list_alloc((ptrdiff_t)reg->y_size);\n  for (size_t i = 0; i < reg->y_size; i++) {\n    tv_list_append_string(list, (const char *)reg->y_array[i], -1);\n  }\n  tv_list_set_lock(list, VAR_FIXED);\n  tv_dict_add_list(dict, S_LEN(\"regcontents\"), list);\n\n  // Register type.\n  char buf[NUMBUFLEN+2];\n  format_reg_type(reg->y_type, reg->y_width, buf, ARRAY_SIZE(buf));\n  tv_dict_add_str(dict, S_LEN(\"regtype\"), buf);\n\n  // Name of requested register, or empty string for unnamed operation.\n  buf[0] = (char)oap->regname;\n  buf[1] = NUL;\n  tv_dict_add_str(dict, S_LEN(\"regname\"), buf);\n\n  // Motion type: inclusive or exclusive.\n  tv_dict_add_bool(dict, S_LEN(\"inclusive\"),\n                   oap->inclusive ? kBoolVarTrue : kBoolVarFalse);\n\n  // Kind of operation: yank, delete, change).\n  buf[0] = (char)get_op_char(oap->op_type);\n  buf[1] = NUL;\n  tv_dict_add_str(dict, S_LEN(\"operator\"), buf);\n\n  // Selection type: visual or not.\n  tv_dict_add_bool(dict, S_LEN(\"visual\"),\n                   oap->is_VIsual ? kBoolVarTrue : kBoolVarFalse);\n\n  tv_dict_set_keys_readonly(dict);\n  textlock++;\n  apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, false, curbuf);\n  textlock--;\n  tv_dict_clear(dict);\n\n  recursive = false;\n}\n\n// Put contents of register \"regname\" into the text.\n// Caller must check \"regname\" to be valid!\n// \"flags\": PUT_FIXINDENT     make indent look nice\n//          PUT_CURSEND       leave cursor after end of new text\n//          PUT_LINE          force linewise put (\":put\")\n//          PUT_BLOCK_INNER   in block mode, do not add trailing spaces\n// dir: BACKWARD for 'P', FORWARD for 'p'\nvoid do_put(int regname, yankreg_T *reg, int dir, long count, int flags)\n{\n  char_u *ptr;\n  char_u *newp;\n  char_u *oldp;\n  int yanklen;\n  size_t totlen = 0;  // init for gcc\n  linenr_T lnum = 0;\n  colnr_T col = 0;\n  size_t i;  // index in y_array[]\n  MotionType y_type;\n  size_t y_size;\n  size_t oldlen;\n  int y_width = 0;\n  colnr_T vcol = 0;\n  int delcount;\n  int incr = 0;\n  struct block_def bd;\n  char_u      **y_array = NULL;\n  long nr_lines = 0;\n  pos_T new_cursor;\n  int indent;\n  int orig_indent = 0;                  /* init for gcc */\n  int indent_diff = 0;                  /* init for gcc */\n  int first_indent = TRUE;\n  int lendiff = 0;\n  pos_T old_pos;\n  char_u      *insert_string = NULL;\n  bool allocated = false;\n  long cnt;\n\n  if (flags & PUT_FIXINDENT)\n    orig_indent = get_indent();\n\n  curbuf->b_op_start = curwin->w_cursor;        /* default for '[ mark */\n  curbuf->b_op_end = curwin->w_cursor;          /* default for '] mark */\n\n  /*\n   * Using inserted text works differently, because the register includes\n   * special characters (newlines, etc.).\n   */\n  if (regname == '.' && !reg) {\n    bool non_linewise_vis = (VIsual_active && VIsual_mode != 'V');\n\n    // PUT_LINE has special handling below which means we use 'i' to start.\n    char command_start_char = non_linewise_vis ? 'c' :\n      (flags & PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));\n\n    // To avoid 'autoindent' on linewise puts, create a new line with `:put _`.\n    if (flags & PUT_LINE) {\n      do_put('_', NULL, dir, 1, PUT_LINE);\n    }\n\n    // If given a count when putting linewise, we stuff the readbuf with the\n    // dot register 'count' times split by newlines.\n    if (flags & PUT_LINE) {\n      stuffcharReadbuff(command_start_char);\n      for (; count > 0; count--) {\n        (void)stuff_inserted(NUL, 1, count != 1);\n        if (count != 1) {\n          // To avoid 'autoindent' affecting the text, use Ctrl_U to remove any\n          // whitespace. Can't just insert Ctrl_U into readbuf1, this would go\n          // back to the previous line in the case of 'noautoindent' and\n          // 'backspace' includes \"eol\". So we insert a dummy space for Ctrl_U\n          // to consume.\n          stuffReadbuff(\"\\n \");\n          stuffcharReadbuff(Ctrl_U);\n        }\n      }\n    } else {\n      (void)stuff_inserted(command_start_char, count, false);\n    }\n\n    // Putting the text is done later, so can't move the cursor to the next\n    // character.  Simulate it with motion commands after the insert.\n    if (flags & PUT_CURSEND) {\n      if (flags & PUT_LINE) {\n        stuffReadbuff(\"j0\");\n      } else {\n        // Avoid ringing the bell from attempting to move into the space after\n        // the current line. We can stuff the readbuffer with \"l\" if:\n        // 1) 'virtualedit' is \"all\" or \"onemore\"\n        // 2) We are not at the end of the line\n        // 3) We are not  (one past the end of the line && on the last line)\n        //    This allows a visual put over a selection one past the end of the\n        //    line joining the current line with the one below.\n\n        // curwin->w_cursor.col marks the byte position of the cursor in the\n        // currunt line. It increases up to a max of\n        // STRLEN(ml_get(curwin->w_cursor.lnum)). With 'virtualedit' and the\n        // cursor past the end of the line, curwin->w_cursor.coladd is\n        // incremented instead of curwin->w_cursor.col.\n        char_u *cursor_pos = get_cursor_pos_ptr();\n        bool one_past_line = (*cursor_pos == NUL);\n        bool eol = false;\n        if (!one_past_line) {\n          eol = (*(cursor_pos + mb_ptr2len(cursor_pos)) == NUL);\n        }\n\n        bool ve_allows = (ve_flags == VE_ALL || ve_flags == VE_ONEMORE);\n        bool eof = curbuf->b_ml.ml_line_count == curwin->w_cursor.lnum\n                   && one_past_line;\n        if (ve_allows || !(eol || eof)) {\n          stuffcharReadbuff('l');\n        }\n      }\n    } else if (flags & PUT_LINE) {\n      stuffReadbuff(\"g'[\");\n    }\n\n    // So the 'u' command restores cursor position after \".p, save the cursor\n    // position now (though not saving any text).\n    if (command_start_char == 'a') {\n      if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL) {\n        return;\n      }\n    }\n    return;\n  }\n\n  /*\n   * For special registers '%' (file name), '#' (alternate file name) and\n   * ':' (last command line), etc. we have to create a fake yank register.\n   */\n  if (!reg && get_spec_reg(regname, &insert_string, &allocated, true)) {\n    if (insert_string == NULL) {\n      return;\n    }\n  }\n\n  if (!curbuf->terminal) {\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make y_array invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL) {\n      return;\n    }\n  }\n\n  if (insert_string != NULL) {\n    y_type = kMTCharWise;\n    if (regname == '=') {\n      /* For the = register we need to split the string at NL\n       * characters.\n       * Loop twice: count the number of lines and save them. */\n      for (;; ) {\n        y_size = 0;\n        ptr = insert_string;\n        while (ptr != NULL) {\n          if (y_array != NULL)\n            y_array[y_size] = ptr;\n          ++y_size;\n          ptr = vim_strchr(ptr, '\\n');\n          if (ptr != NULL) {\n            if (y_array != NULL)\n              *ptr = NUL;\n            ++ptr;\n            /* A trailing '\\n' makes the register linewise. */\n            if (*ptr == NUL) {\n              y_type = kMTLineWise;\n              break;\n            }\n          }\n        }\n        if (y_array != NULL)\n          break;\n        y_array = (char_u **)xmalloc(y_size * sizeof(char_u *));\n      }\n    } else {\n      y_size = 1;               /* use fake one-line yank register */\n      y_array = &insert_string;\n    }\n  } else {\n    // in case of replacing visually selected text\n    // the yankreg might already have been saved to avoid\n    // just restoring the deleted text.\n    if (reg == NULL) {\n      reg = get_yank_register(regname, YREG_PASTE);\n    }\n\n    y_type = reg->y_type;\n    y_width = reg->y_width;\n    y_size = reg->y_size;\n    y_array = reg->y_array;\n  }\n\n  if (curbuf->terminal) {\n    terminal_paste(count, y_array, y_size);\n    return;\n  }\n\n  if (y_type == kMTLineWise) {\n    if (flags & PUT_LINE_SPLIT) {\n      // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n      // between.\n      if (u_save_cursor() == FAIL) {\n        goto end;\n      }\n      char_u *p = get_cursor_pos_ptr();\n      if (dir == FORWARD && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n      ptr = vim_strsave(p);\n      ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, false);\n      xfree(ptr);\n\n      oldp = get_cursor_line_ptr();\n      p = oldp + curwin->w_cursor.col;\n      if (dir == FORWARD && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n      ptr = vim_strnsave(oldp, (size_t)(p - oldp));\n      ml_replace(curwin->w_cursor.lnum, ptr, false);\n      nr_lines++;\n      dir = FORWARD;\n    }\n    if (flags & PUT_LINE_FORWARD) {\n      /* Must be \"p\" for a Visual block, put lines below the block. */\n      curwin->w_cursor = curbuf->b_visual.vi_end;\n      dir = FORWARD;\n    }\n    curbuf->b_op_start = curwin->w_cursor;      /* default for '[ mark */\n    curbuf->b_op_end = curwin->w_cursor;        /* default for '] mark */\n  }\n\n  if (flags & PUT_LINE) {  // :put command or \"p\" in Visual line mode.\n    y_type = kMTLineWise;\n  }\n\n  if (y_size == 0 || y_array == NULL) {\n    EMSG2(_(\"E353: Nothing in register %s\"),\n        regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n    goto end;\n  }\n\n  if (y_type == kMTBlockWise) {\n    lnum = curwin->w_cursor.lnum + (linenr_T)y_size + 1;\n    if (lnum > curbuf->b_ml.ml_line_count) {\n      lnum = curbuf->b_ml.ml_line_count + 1;\n    }\n    if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL) {\n      goto end;\n    }\n  } else if (y_type == kMTLineWise) {\n    lnum = curwin->w_cursor.lnum;\n    // Correct line number for closed fold.  Don't move the cursor yet,\n    // u_save() uses it.\n    if (dir == BACKWARD) {\n      (void)hasFolding(lnum, &lnum, NULL);\n    } else {\n      (void)hasFolding(lnum, NULL, &lnum);\n    }\n    if (dir == FORWARD) {\n      lnum++;\n    }\n    // In an empty buffer the empty line is going to be replaced, include\n    // it in the saved lines.\n    if ((buf_is_empty(curbuf) ?\n         u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) {\n      goto end;\n    }\n    if (dir == FORWARD) {\n      curwin->w_cursor.lnum = lnum - 1;\n    } else {\n      curwin->w_cursor.lnum = lnum;\n    }\n    curbuf->b_op_start = curwin->w_cursor;      // for mark_adjust()\n  } else if (u_save_cursor() == FAIL) {\n    goto end;\n  }\n\n  yanklen = (int)STRLEN(y_array[0]);\n\n  if (ve_flags == VE_ALL && y_type == kMTCharWise) {\n    if (gchar_cursor() == TAB) {\n      /* Don't need to insert spaces when \"p\" on the last position of a\n       * tab or \"P\" on the first position. */\n      int viscol = getviscol();\n      if (dir == FORWARD\n          ? tabstop_padding(viscol, curbuf->b_p_ts, curbuf->b_p_vts_array) != 1\n          : curwin->w_cursor.coladd > 0) {\n        coladvance_force(viscol);\n      } else {\n        curwin->w_cursor.coladd = 0;\n      }\n    } else if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL) {\n      coladvance_force(getviscol() + (dir == FORWARD));\n    }\n  }\n\n  lnum = curwin->w_cursor.lnum;\n  col = curwin->w_cursor.col;\n\n  /*\n   * Block mode\n   */\n  if (y_type == kMTBlockWise) {\n    int c = gchar_cursor();\n    colnr_T endcol2 = 0;\n\n    if (dir == FORWARD && c != NUL) {\n      if (ve_flags == VE_ALL)\n        getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n      else\n        getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n      // move to start of next multi-byte character\n      curwin->w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());\n      col++;\n    } else {\n      getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n    }\n\n    col += curwin->w_cursor.coladd;\n    if (ve_flags == VE_ALL\n        && (curwin->w_cursor.coladd > 0\n            || endcol2 == curwin->w_cursor.col)) {\n      if (dir == FORWARD && c == NUL) {\n        col++;\n      }\n      if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0) {\n        curwin->w_cursor.col++;\n      }\n      if (c == TAB) {\n        if (dir == BACKWARD && curwin->w_cursor.col)\n          curwin->w_cursor.col--;\n        if (dir == FORWARD && col - 1 == endcol2)\n          curwin->w_cursor.col++;\n      }\n    }\n    curwin->w_cursor.coladd = 0;\n    bd.textcol = 0;\n    for (i = 0; i < y_size; i++) {\n      int spaces = 0;\n      char shortline;\n      // can just be 0 or 1, needed for blockwise paste beyond the current\n      // buffer end\n      int lines_appended = 0;\n\n      bd.startspaces = 0;\n      bd.endspaces = 0;\n      vcol = 0;\n      delcount = 0;\n\n      /* add a new line */\n      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count) {\n        if (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n                      (colnr_T)1, false) == FAIL) {\n          break;\n        }\n        nr_lines++;\n        lines_appended = 1;\n      }\n      /* get the old line and advance to the position to insert at */\n      oldp = get_cursor_line_ptr();\n      oldlen = STRLEN(oldp);\n      for (ptr = oldp; vcol < col && *ptr; ) {\n        /* Count a tab for what it's worth (if list mode not on) */\n        incr = lbr_chartabsize_adv(oldp, &ptr, (colnr_T)vcol);\n        vcol += incr;\n      }\n      bd.textcol = (colnr_T)(ptr - oldp);\n\n      shortline = (vcol < col) || (vcol == col && !*ptr);\n\n      if (vcol < col)       /* line too short, padd with spaces */\n        bd.startspaces = col - vcol;\n      else if (vcol > col) {\n        bd.endspaces = vcol - col;\n        bd.startspaces = incr - bd.endspaces;\n        --bd.textcol;\n        delcount = 1;\n        bd.textcol -= utf_head_off(oldp, oldp + bd.textcol);\n        if (oldp[bd.textcol] != TAB) {\n          /* Only a Tab can be split into spaces.  Other\n           * characters will have to be moved to after the\n           * block, causing misalignment. */\n          delcount = 0;\n          bd.endspaces = 0;\n        }\n      }\n\n      yanklen = (int)STRLEN(y_array[i]);\n\n      if ((flags & PUT_BLOCK_INNER) == 0) {\n        // calculate number of spaces required to fill right side of\n        // block\n        spaces = y_width + 1;\n        for (int j = 0; j < yanklen; j++) {\n          spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n        }\n        if (spaces < 0) {\n          spaces = 0;\n        }\n      }\n\n      // insert the new text\n      totlen = (size_t)(count * (yanklen + spaces)\n                        + bd.startspaces + bd.endspaces);\n      int addcount = (int)totlen + lines_appended;\n      newp = (char_u *)xmalloc(totlen + oldlen + 1);\n      // copy part up to cursor to new line\n      ptr = newp;\n      memmove(ptr, oldp, (size_t)bd.textcol);\n      ptr += bd.textcol;\n      // may insert some spaces before the new text\n      memset(ptr, ' ', (size_t)bd.startspaces);\n      ptr += bd.startspaces;\n      // insert the new text\n      for (long j = 0; j < count; j++) {\n        memmove(ptr, y_array[i], (size_t)yanklen);\n        ptr += yanklen;\n\n        // insert block's trailing spaces only if there's text behind\n        if ((j < count - 1 || !shortline) && spaces) {\n          memset(ptr, ' ', (size_t)spaces);\n          ptr += spaces;\n        } else {\n          addcount -= spaces;\n        }\n      }\n      // may insert some spaces after the new text\n      memset(ptr, ' ', (size_t)bd.endspaces);\n      ptr += bd.endspaces;\n      // move the text after the cursor to the end of the line.\n      int columns = (int)oldlen - bd.textcol - delcount + 1;\n      assert(columns >= 0);\n      memmove(ptr, oldp + bd.textcol + delcount, (size_t)columns);\n      ml_replace(curwin->w_cursor.lnum, newp, false);\n      extmark_splice_cols(curbuf, (int)curwin->w_cursor.lnum-1, bd.textcol,\n                          delcount, addcount, kExtmarkUndo);\n\n      ++curwin->w_cursor.lnum;\n      if (i == 0)\n        curwin->w_cursor.col += bd.startspaces;\n    }\n\n    changed_lines(lnum, 0, curbuf->b_op_start.lnum + (linenr_T)y_size\n                  - (linenr_T)nr_lines , nr_lines, true);\n\n    /* Set '[ mark. */\n    curbuf->b_op_start = curwin->w_cursor;\n    curbuf->b_op_start.lnum = lnum;\n\n    /* adjust '] mark */\n    curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n    curbuf->b_op_end.col = bd.textcol + (colnr_T)totlen - 1;\n    curbuf->b_op_end.coladd = 0;\n    if (flags & PUT_CURSEND) {\n      colnr_T len;\n\n      curwin->w_cursor = curbuf->b_op_end;\n      curwin->w_cursor.col++;\n\n      /* in Insert mode we might be after the NUL, correct for that */\n      len = (colnr_T)STRLEN(get_cursor_line_ptr());\n      if (curwin->w_cursor.col > len)\n        curwin->w_cursor.col = len;\n    } else\n      curwin->w_cursor.lnum = lnum;\n  } else {\n    // Character or Line mode\n    if (y_type == kMTCharWise) {\n      // if type is kMTCharWise, FORWARD is the same as BACKWARD on the next\n      // char\n      if (dir == FORWARD && gchar_cursor() != NUL) {\n        int bytelen = (*mb_ptr2len)(get_cursor_pos_ptr());\n\n        // put it on the next of the multi-byte character.\n        col += bytelen;\n        if (yanklen) {\n          curwin->w_cursor.col += bytelen;\n          curbuf->b_op_end.col += bytelen;\n        }\n      }\n      curbuf->b_op_start = curwin->w_cursor;\n    }\n    /*\n     * Line mode: BACKWARD is the same as FORWARD on the previous line\n     */\n    else if (dir == BACKWARD)\n      --lnum;\n    new_cursor = curwin->w_cursor;\n\n    // simple case: insert into one line at a time\n    if (y_type == kMTCharWise && y_size == 1) {\n      linenr_T end_lnum = 0;  // init for gcc\n      linenr_T start_lnum = lnum;\n\n      if (VIsual_active) {\n        end_lnum = curbuf->b_visual.vi_end.lnum;\n        if (end_lnum < curbuf->b_visual.vi_start.lnum) {\n            end_lnum = curbuf->b_visual.vi_start.lnum;\n        }\n        if (end_lnum > start_lnum) {\n          // \"col\" is valid for the first line, in following lines\n          // the virtual column needs to be used.  Matters for\n          // multi-byte characters.\n          pos_T pos = {\n            .lnum = lnum,\n            .col = col,\n            .coladd = 0,\n          };\n          getvcol(curwin, &pos, NULL, &vcol, NULL);\n        }\n      }\n\n      do {\n        totlen = (size_t)(count * yanklen);\n        if (totlen > 0) {\n          oldp = ml_get(lnum);\n          if (lnum > start_lnum) {\n            pos_T pos = {\n              .lnum = lnum,\n            };\n            if (getvpos(&pos, vcol) == OK) {\n              col = pos.col;\n            } else {\n              col = MAXCOL;\n            }\n          }\n          if (VIsual_active && col > (int)STRLEN(oldp)) {\n            lnum++;\n            continue;\n          }\n          newp = (char_u *)xmalloc((size_t)(STRLEN(oldp) + totlen + 1));\n          memmove(newp, oldp, (size_t)col);\n          ptr = newp + col;\n          for (i = 0; i < (size_t)count; i++) {\n            memmove(ptr, y_array[0], (size_t)yanklen);\n            ptr += yanklen;\n          }\n          STRMOVE(ptr, oldp + col);\n          ml_replace(lnum, newp, false);\n          // Place cursor on last putted char.\n          if (lnum == curwin->w_cursor.lnum) {\n            // make sure curwin->w_virtcol is updated\n            changed_cline_bef_curs();\n            curwin->w_cursor.col += (colnr_T)(totlen - 1);\n          }\n          changed_bytes(lnum, col);\n          extmark_splice_cols(curbuf, (int)lnum-1, col,\n                              0, (int)totlen, kExtmarkUndo);\n        }\n        if (VIsual_active) {\n          lnum++;\n        }\n      } while (VIsual_active && lnum <= end_lnum);\n\n      if (VIsual_active) {  /* reset lnum to the last visual line */\n        lnum--;\n      }\n\n      curbuf->b_op_end = curwin->w_cursor;\n      // For \"CTRL-O p\" in Insert mode, put cursor after last char\n      if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND))) {\n        curwin->w_cursor.col++;\n      }\n    } else {\n      // Insert at least one line.  When y_type is kMTCharWise, break the first\n      // line in two.\n      for (cnt = 1; cnt <= count; cnt++) {\n        i = 0;\n        if (y_type == kMTCharWise) {\n          // Split the current line in two at the insert position.\n          // First insert y_array[size - 1] in front of second line.\n          // Then append y_array[0] to first line.\n          lnum = new_cursor.lnum;\n          ptr = ml_get(lnum) + col;\n          totlen = STRLEN(y_array[y_size - 1]);\n          newp = (char_u *) xmalloc((size_t)(STRLEN(ptr) + totlen + 1));\n          STRCPY(newp, y_array[y_size - 1]);\n          STRCAT(newp, ptr);\n          // insert second line\n          ml_append(lnum, newp, (colnr_T)0, false);\n          xfree(newp);\n\n          oldp = ml_get(lnum);\n          newp = (char_u *)xmalloc((size_t)col + (size_t)yanklen + 1);\n          // copy first part of line\n          memmove(newp, oldp, (size_t)col);\n          // append to first line\n          memmove(newp + col, y_array[0], (size_t)yanklen + 1);\n          ml_replace(lnum, newp, false);\n\n          curwin->w_cursor.lnum = lnum;\n          i = 1;\n        }\n\n        for (; i < y_size; i++) {\n          if ((y_type != kMTCharWise || i < y_size - 1)\n              && ml_append(lnum, y_array[i], (colnr_T)0, false)\n              == FAIL) {\n            goto error;\n          }\n          lnum++;\n          ++nr_lines;\n          if (flags & PUT_FIXINDENT) {\n            old_pos = curwin->w_cursor;\n            curwin->w_cursor.lnum = lnum;\n            ptr = ml_get(lnum);\n            if (cnt == count && i == y_size - 1)\n              lendiff = (int)STRLEN(ptr);\n            if (*ptr == '#' && preprocs_left())\n              indent = 0;                   /* Leave # lines at start */\n            else if (*ptr == NUL)\n              indent = 0;                   /* Ignore empty lines */\n            else if (first_indent) {\n              indent_diff = orig_indent - get_indent();\n              indent = orig_indent;\n              first_indent = FALSE;\n            } else if ((indent = get_indent() + indent_diff) < 0)\n              indent = 0;\n            (void)set_indent(indent, SIN_NOMARK);\n            curwin->w_cursor = old_pos;\n            /* remember how many chars were removed */\n            if (cnt == count && i == y_size - 1)\n              lendiff -= (int)STRLEN(ml_get(lnum));\n          }\n        }\n\n        bcount_t totsize = 0;\n        int lastsize = 0;\n        if (y_type == kMTCharWise\n            || (y_type == kMTLineWise && flags & PUT_LINE_SPLIT)) {\n          for (i = 0; i < y_size-1; i++) {\n            totsize += (bcount_t)STRLEN(y_array[i]) + 1;\n          }\n          lastsize = (int)STRLEN(y_array[y_size-1]);\n          totsize += lastsize;\n        }\n        if (y_type == kMTCharWise) {\n          extmark_splice(curbuf, (int)new_cursor.lnum-1, col, 0, 0, 0,\n                         (int)y_size-1, lastsize, totsize,\n                         kExtmarkUndo);\n        } else if (y_type == kMTLineWise && flags & PUT_LINE_SPLIT) {\n          // Account for last pasted NL + last NL\n          extmark_splice(curbuf, (int)new_cursor.lnum-1, col + 1, 0, 0, 0,\n                         (int)y_size+1, 0, totsize+2, kExtmarkUndo);\n        }\n      }\n\nerror:\n      // Adjust marks.\n      if (y_type == kMTLineWise) {\n        curbuf->b_op_start.col = 0;\n        if (dir == FORWARD)\n          curbuf->b_op_start.lnum++;\n      }\n\n      ExtmarkOp kind = (y_type == kMTLineWise && !(flags & PUT_LINE_SPLIT))\n                       ? kExtmarkUndo : kExtmarkNOOP;\n      mark_adjust(curbuf->b_op_start.lnum + (y_type == kMTCharWise),\n                  (linenr_T)MAXLNUM, nr_lines, 0L, kind);\n\n      // note changed text for displaying and folding\n      if (y_type == kMTCharWise) {\n        changed_lines(curwin->w_cursor.lnum, col,\n                      curwin->w_cursor.lnum + 1, nr_lines, true);\n      } else {\n        changed_lines(curbuf->b_op_start.lnum, 0,\n                      curbuf->b_op_start.lnum, nr_lines, true);\n      }\n\n      /* put '] mark at last inserted character */\n      curbuf->b_op_end.lnum = lnum;\n      /* correct length for change in indent */\n      col = (colnr_T)STRLEN(y_array[y_size - 1]) - lendiff;\n      if (col > 1)\n        curbuf->b_op_end.col = col - 1;\n      else\n        curbuf->b_op_end.col = 0;\n\n      if (flags & PUT_CURSLINE) {\n        /* \":put\": put cursor on last inserted line */\n        curwin->w_cursor.lnum = lnum;\n        beginline(BL_WHITE | BL_FIX);\n      } else if (flags & PUT_CURSEND) {\n        // put cursor after inserted text\n        if (y_type == kMTLineWise) {\n          if (lnum >= curbuf->b_ml.ml_line_count) {\n            curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n          } else {\n            curwin->w_cursor.lnum = lnum + 1;\n          }\n          curwin->w_cursor.col = 0;\n        } else {\n          curwin->w_cursor.lnum = lnum;\n          curwin->w_cursor.col = col;\n        }\n      } else if (y_type == kMTLineWise) {\n        // put cursor on first non-blank in first inserted line\n        curwin->w_cursor.col = 0;\n        if (dir == FORWARD)\n          ++curwin->w_cursor.lnum;\n        beginline(BL_WHITE | BL_FIX);\n      } else            /* put cursor on first inserted character */\n        curwin->w_cursor = new_cursor;\n    }\n  }\n\n  msgmore(nr_lines);\n  curwin->w_set_curswant = TRUE;\n\nend:\n  if (allocated)\n    xfree(insert_string);\n  if (regname == '=')\n    xfree(y_array);\n\n  VIsual_active = FALSE;\n\n  /* If the cursor is past the end of the line put it at the end. */\n  adjust_cursor_eol();\n}  // NOLINT(readability/fn_size)\n\n/*\n * When the cursor is on the NUL past the end of the line and it should not be\n * there move it left.\n */\nvoid adjust_cursor_eol(void)\n{\n  if (curwin->w_cursor.col > 0\n      && gchar_cursor() == NUL\n      && (ve_flags & VE_ONEMORE) == 0\n      && !(restart_edit || (State & INSERT))) {\n    /* Put the cursor on the last character in the line. */\n    dec_cursor();\n\n    if (ve_flags == VE_ALL) {\n      colnr_T scol, ecol;\n\n      /* Coladd is set to the width of the last character. */\n      getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n      curwin->w_cursor.coladd = ecol - scol + 1;\n    }\n  }\n}\n\n/*\n * Return TRUE if lines starting with '#' should be left aligned.\n */\nint preprocs_left(void)\n{\n  return ((curbuf->b_p_si && !curbuf->b_p_cin)\n          || (curbuf->b_p_cin && in_cinkeys('#', ' ', true)\n              && curbuf->b_ind_hash_comment == 0));\n}\n\n/* Return the character name of the register with the given number */\nint get_register_name(int num)\n{\n  if (num == -1)\n    return '\"';\n  else if (num < 10)\n    return num + '0';\n  else if (num == DELETION_REGISTER)\n    return '-';\n  else if (num == STAR_REGISTER)\n    return '*';\n  else if (num == PLUS_REGISTER)\n    return '+';\n  else {\n    return num + 'a' - 10;\n  }\n}\n\n/*\n * \":dis\" and \":registers\": Display the contents of the yank registers.\n */\nvoid ex_display(exarg_T *eap)\n{\n  char_u *p;\n  yankreg_T *yb;\n  int name;\n  char_u *arg = eap->arg;\n  int clen;\n  char_u type[2];\n\n  if (arg != NULL && *arg == NUL)\n    arg = NULL;\n  int attr = HL_ATTR(HLF_8);\n\n  // Highlight title\n  msg_puts_title(_(\"\\nType Name Content\"));\n  for (int i = -1; i < NUM_REGISTERS && !got_int; i++) {\n    name = get_register_name(i);\n    switch (get_reg_type(name, NULL)) {\n      case kMTLineWise: type[0] = 'l'; break;\n      case kMTCharWise: type[0] = 'c'; break;\n      default: type[0] = 'b'; break;\n    }\n\n    if (arg != NULL && vim_strchr(arg, name) == NULL) {\n      continue;             /* did not ask for this register */\n    }\n\n\n    if (i == -1) {\n      if (y_previous != NULL)\n        yb = y_previous;\n      else\n        yb = &(y_regs[0]);\n    } else\n      yb = &(y_regs[i]);\n\n    get_clipboard(name, &yb, true);\n\n    if (name == mb_tolower(redir_reg)\n        || (redir_reg == '\"' && yb == y_previous)) {\n      continue;  // do not list register being written to, the\n                 // pointer can be freed\n    }\n\n    if (yb->y_array != NULL) {\n      msg_putchar('\\n');\n      msg_puts(\"  \");\n      msg_putchar(type[0]);\n      msg_puts(\"  \");\n      msg_putchar('\"');\n      msg_putchar(name);\n      MSG_PUTS(\"   \");\n\n      int n = Columns - 11;\n      for (size_t j = 0; j < yb->y_size && n > 1; j++) {\n        if (j) {\n          MSG_PUTS_ATTR(\"^J\", attr);\n          n -= 2;\n        }\n        for (p = yb->y_array[j]; *p && (n -= ptr2cells(p)) >= 0; p++) {  // -V1019 NOLINT(whitespace/line_length)\n          clen = (*mb_ptr2len)(p);\n          msg_outtrans_len(p, clen);\n          p += clen - 1;\n        }\n      }\n      if (n > 1 && yb->y_type == kMTLineWise) {\n        MSG_PUTS_ATTR(\"^J\", attr);\n      }\n      ui_flush();  // show one line at a time\n    }\n    os_breakcheck();\n  }\n\n  /*\n   * display last inserted text\n   */\n  if ((p = get_last_insert()) != NULL\n      && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int) {\n    msg_puts(\"\\n  c  \\\".   \");\n    dis_msg(p, true);\n  }\n\n  /*\n   * display last command line\n   */\n  if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)\n      && !got_int) {\n    msg_puts(\"\\n  c  \\\":   \");\n    dis_msg(last_cmdline, false);\n  }\n\n  /*\n   * display current file name\n   */\n  if (curbuf->b_fname != NULL\n      && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int) {\n    msg_puts(\"\\n  c  \\\"%   \");\n    dis_msg(curbuf->b_fname, false);\n  }\n\n  /*\n   * display alternate file name\n   */\n  if ((arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int) {\n    char_u      *fname;\n    linenr_T dummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) != FAIL) {\n      msg_puts(\"\\n  c  \\\"#   \");\n      dis_msg(fname, false);\n    }\n  }\n\n  /*\n   * display last search pattern\n   */\n  if (last_search_pat() != NULL\n      && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int) {\n    msg_puts(\"\\n  c  \\\"/   \");\n    dis_msg(last_search_pat(), false);\n  }\n\n  /*\n   * display last used expression\n   */\n  if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)\n      && !got_int) {\n    msg_puts(\"\\n  c  \\\"=   \");\n    dis_msg(expr_line, false);\n  }\n}\n\n/*\n * display a string for do_dis()\n * truncate at end of screen line\n */\nstatic void\ndis_msg(\n    const char_u *p,\n    bool skip_esc     // if true, ignore trailing ESC\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int n;\n  int l;\n\n  n = Columns - 6;\n  while (*p != NUL\n         && !(*p == ESC && skip_esc && *(p + 1) == NUL)\n         && (n -= ptr2cells(p)) >= 0) {\n    if ((l = utfc_ptr2len(p)) > 1) {\n      msg_outtrans_len(p, l);\n      p += l;\n    } else\n      msg_outtrans_len(p++, 1);\n  }\n  os_breakcheck();\n}\n\n/// If \\p \"process\" is true and the line begins with a comment leader (possibly\n/// after some white space), return a pointer to the text after it.\n/// Put a boolean value indicating whether the line ends with an unclosed\n/// comment in \"is_comment\".\n///\n/// @param line - line to be processed\n/// @param process - if false, will only check whether the line ends\n///         with an unclosed comment,\n/// @param include_space - whether to skip space following the comment leader\n/// @param[out] is_comment - whether the current line ends with an unclosed\n///  comment.\nchar_u *skip_comment(\n    char_u *line, bool process, bool include_space, bool *is_comment\n)\n{\n  char_u *comment_flags = NULL;\n  int lead_len;\n  int leader_offset = get_last_leader_offset(line, &comment_flags);\n\n  *is_comment = false;\n  if (leader_offset != -1) {\n    /* Let's check whether the line ends with an unclosed comment.\n     * If the last comment leader has COM_END in flags, there's no comment.\n     */\n    while (*comment_flags) {\n      if (*comment_flags == COM_END\n          || *comment_flags == ':') {\n        break;\n      }\n      comment_flags++;\n    }\n    if (*comment_flags != COM_END) {\n      *is_comment = true;\n    }\n  }\n\n  if (process == false) {\n    return line;\n  }\n\n  lead_len = get_leader_len(line, &comment_flags, false, include_space);\n\n  if (lead_len == 0)\n    return line;\n\n  /* Find:\n   * - COM_END,\n   * - colon,\n   * whichever comes first.\n   */\n  while (*comment_flags) {\n    if (*comment_flags == COM_END\n        || *comment_flags == ':') {\n      break;\n    }\n    ++comment_flags;\n  }\n\n  /* If we found a colon, it means that we are not processing a line\n   * starting with a closing part of a three-part comment. That's good,\n   * because we don't want to remove those as this would be annoying.\n   */\n  if (*comment_flags == ':' || *comment_flags == NUL) {\n    line += lead_len;\n  }\n\n  return line;\n}\n\n// Join 'count' lines (minimal 2) at cursor position.\n// When \"save_undo\" is TRUE save lines for undo first.\n// Set \"use_formatoptions\" to FALSE when e.g. processing backspace and comment\n// leaders should not be removed.\n// When setmark is true, sets the '[ and '] mark, else, the caller is expected\n// to set those marks.\n//\n// return FAIL for failure, OK otherwise\nint do_join(size_t count,\n            int insert_space,\n            int save_undo,\n            int use_formatoptions,\n            bool setmark)\n{\n  char_u      *curr = NULL;\n  char_u      *curr_start = NULL;\n  char_u      *cend;\n  char_u      *newp;\n  char_u      *spaces;          /* number of spaces inserted before a line */\n  int endcurr1 = NUL;\n  int endcurr2 = NUL;\n  int currsize = 0;             /* size of the current line */\n  int sumsize = 0;              /* size of the long new line */\n  linenr_T t;\n  colnr_T col = 0;\n  int ret = OK;\n  int         *comments = NULL;\n  int remove_comments = (use_formatoptions == TRUE)\n                        && has_format_option(FO_REMOVE_COMS);\n  bool prev_was_comment = false;\n  assert(count >= 1);\n\n  if (save_undo && u_save(curwin->w_cursor.lnum - 1,\n                          curwin->w_cursor.lnum + (linenr_T)count) == FAIL) {\n    return FAIL;\n  }\n  // Allocate an array to store the number of spaces inserted before each\n  // line.  We will use it to pre-compute the length of the new line and the\n  // proper placement of each original line in the new one.\n  spaces = xcalloc(count, 1);\n  if (remove_comments) {\n    comments = xcalloc(count, sizeof(*comments));\n  }\n\n  // Don't move anything, just compute the final line length\n  // and setup the array of space strings lengths\n  for (t = 0; t < (linenr_T)count; t++) {\n    curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));\n    if (t == 0 && setmark) {\n      // Set the '[ mark.\n      curwin->w_buffer->b_op_start.lnum = curwin->w_cursor.lnum;\n      curwin->w_buffer->b_op_start.col = (colnr_T)STRLEN(curr);\n    }\n    if (remove_comments) {\n      // We don't want to remove the comment leader if the\n      // previous line is not a comment.\n      if (t > 0 && prev_was_comment) {\n        char_u *new_curr = skip_comment(curr, true, insert_space,\n                                        &prev_was_comment);\n        comments[t] = (int)(new_curr - curr);\n        curr = new_curr;\n      } else {\n        curr = skip_comment(curr, false, insert_space, &prev_was_comment);\n      }\n    }\n\n    if (insert_space && t > 0) {\n      curr = skipwhite(curr);\n      if (*curr != NUL\n          && *curr != ')'\n          && sumsize != 0\n          && endcurr1 != TAB\n          && (!has_format_option(FO_MBYTE_JOIN)\n              || (utf_ptr2char(curr) < 0x100 && endcurr1 < 0x100))\n          && (!has_format_option(FO_MBYTE_JOIN2)\n              || (utf_ptr2char(curr) < 0x100 && !utf_eat_space(endcurr1))\n              || (endcurr1 < 0x100 && !utf_eat_space(utf_ptr2char(curr))))\n          ) {\n        /* don't add a space if the line is ending in a space */\n        if (endcurr1 == ' ')\n          endcurr1 = endcurr2;\n        else\n          ++spaces[t];\n        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.\n        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {\n          ++spaces[t];\n        }\n      }\n    }\n\n    if (t > 0 && curbuf_splice_pending == 0) {\n      colnr_T removed = (int)(curr- curr_start);\n      extmark_splice(curbuf, (int)curwin->w_cursor.lnum-1, sumsize,\n                     1, removed, removed + 1,\n                     0, spaces[t], spaces[t],\n                     kExtmarkUndo);\n    }\n    currsize = (int)STRLEN(curr);\n    sumsize += currsize + spaces[t];\n    endcurr1 = endcurr2 = NUL;\n    if (insert_space && currsize > 0) {\n      cend = curr + currsize;\n      MB_PTR_BACK(curr, cend);\n      endcurr1 = utf_ptr2char(cend);\n      if (cend > curr) {\n        MB_PTR_BACK(curr, cend);\n        endcurr2 = utf_ptr2char(cend);\n      }\n    }\n    line_breakcheck();\n    if (got_int) {\n      ret = FAIL;\n      goto theend;\n    }\n  }\n\n  // store the column position before last line\n  col = sumsize - currsize - spaces[count - 1];\n\n  // allocate the space for the new line\n  newp = (char_u *)xmalloc((size_t)sumsize + 1);\n  cend = newp + sumsize;\n  *cend = 0;\n\n  /*\n   * Move affected lines to the new long one.\n   *\n   * Move marks from each deleted line to the joined line, adjusting the\n   * column.  This is not Vi compatible, but Vi deletes the marks, thus that\n   * should not really be a problem.\n   */\n\n  curbuf_splice_pending++;\n\n  for (t = (linenr_T)count - 1;; t--) {\n    cend -= currsize;\n    memmove(cend, curr, (size_t)currsize);\n    if (spaces[t] > 0) {\n      cend -= spaces[t];\n      memset(cend, ' ', (size_t)(spaces[t]));\n    }\n\n    // If deleting more spaces than adding, the cursor moves no more than\n    // what is added if it is inside these spaces.\n    const int spaces_removed = (int)((curr - curr_start) - spaces[t]);\n    linenr_T lnum = curwin->w_cursor.lnum + t;\n    colnr_T mincol = (colnr_T)0;\n    long lnum_amount = (linenr_T)-t;\n    long col_amount = (long)(cend - newp - spaces_removed);\n\n    mark_col_adjust(lnum, mincol, lnum_amount, col_amount, spaces_removed);\n\n    if (t == 0) {\n      break;\n    }\n\n    curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));\n    if (remove_comments)\n      curr += comments[t - 1];\n    if (insert_space && t > 1)\n      curr = skipwhite(curr);\n    currsize = (int)STRLEN(curr);\n  }\n\n  ml_replace(curwin->w_cursor.lnum, newp, false);\n\n  if (setmark) {\n    // Set the '] mark.\n    curwin->w_buffer->b_op_end.lnum = curwin->w_cursor.lnum;\n    curwin->w_buffer->b_op_end.col = sumsize;\n  }\n\n  /* Only report the change in the first line here, del_lines() will report\n   * the deleted line. */\n  changed_lines(curwin->w_cursor.lnum, currsize,\n                curwin->w_cursor.lnum + 1, 0L, true);\n\n  /*\n   * Delete following lines. To do this we move the cursor there\n   * briefly, and then move it back. After del_lines() the cursor may\n   * have moved up (last line deleted), so the current lnum is kept in t.\n   */\n  t = curwin->w_cursor.lnum;\n  curwin->w_cursor.lnum++;\n  del_lines((long)count - 1, false);\n  curwin->w_cursor.lnum = t;\n  curbuf_splice_pending--;\n  curbuf->deleted_bytes2 = 0;\n\n  /*\n   * Set the cursor column:\n   * Vi compatible: use the column of the first join\n   * vim:\t      use the column of the last join\n   */\n  curwin->w_cursor.col =\n    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);\n  check_cursor_col();\n\n  curwin->w_cursor.coladd = 0;\n  curwin->w_set_curswant = TRUE;\n\ntheend:\n  xfree(spaces);\n  if (remove_comments)\n    xfree(comments);\n  return ret;\n}\n\n/*\n * Return TRUE if the two comment leaders given are the same.  \"lnum\" is\n * the first line.  White-space is ignored.  Note that the whole of\n * 'leader1' must match 'leader2_len' characters from 'leader2' -- webb\n */\nstatic int same_leader(linenr_T lnum, int leader1_len, char_u *leader1_flags, int leader2_len, char_u *leader2_flags)\n{\n  int idx1 = 0, idx2 = 0;\n  char_u  *p;\n  char_u  *line1;\n  char_u  *line2;\n\n  if (leader1_len == 0)\n    return leader2_len == 0;\n\n  /*\n   * If first leader has 'f' flag, the lines can be joined only if the\n   * second line does not have a leader.\n   * If first leader has 'e' flag, the lines can never be joined.\n   * If fist leader has 's' flag, the lines can only be joined if there is\n   * some text after it and the second line has the 'm' flag.\n   */\n  if (leader1_flags != NULL) {\n    for (p = leader1_flags; *p && *p != ':'; ++p) {\n      if (*p == COM_FIRST)\n        return leader2_len == 0;\n      if (*p == COM_END)\n        return FALSE;\n      if (*p == COM_START) {\n        if (*(ml_get(lnum) + leader1_len) == NUL)\n          return FALSE;\n        if (leader2_flags == NULL || leader2_len == 0)\n          return FALSE;\n        for (p = leader2_flags; *p && *p != ':'; ++p)\n          if (*p == COM_MIDDLE)\n            return TRUE;\n        return FALSE;\n      }\n    }\n  }\n\n  /*\n   * Get current line and next line, compare the leaders.\n   * The first line has to be saved, only one line can be locked at a time.\n   */\n  line1 = vim_strsave(ml_get(lnum));\n  for (idx1 = 0; ascii_iswhite(line1[idx1]); ++idx1)\n    ;\n  line2 = ml_get(lnum + 1);\n  for (idx2 = 0; idx2 < leader2_len; ++idx2) {\n    if (!ascii_iswhite(line2[idx2])) {\n      if (line1[idx1++] != line2[idx2])\n        break;\n    } else\n      while (ascii_iswhite(line1[idx1]))\n        ++idx1;\n  }\n  xfree(line1);\n\n  return idx2 == leader2_len && idx1 == leader1_len;\n}\n\n/*\n * Implementation of the format operator 'gq'.\n */\nvoid\nop_format(\n    oparg_T *oap,\n    int keep_cursor                        /* keep cursor on same text char */\n)\n{\n  long old_line_count = curbuf->b_ml.ml_line_count;\n\n  /* Place the cursor where the \"gq\" or \"gw\" command was given, so that \"u\"\n   * can put it back there. */\n  curwin->w_cursor = oap->cursor_start;\n\n  if (u_save((linenr_T)(oap->start.lnum - 1),\n          (linenr_T)(oap->end.lnum + 1)) == FAIL)\n    return;\n  curwin->w_cursor = oap->start;\n\n  if (oap->is_VIsual)\n    /* When there is no change: need to remove the Visual selection */\n    redraw_curbuf_later(INVERTED);\n\n  /* Set '[ mark at the start of the formatted area */\n  curbuf->b_op_start = oap->start;\n\n  /* For \"gw\" remember the cursor position and put it back below (adjusted\n   * for joined and split lines). */\n  if (keep_cursor)\n    saved_cursor = oap->cursor_start;\n\n  format_lines(oap->line_count, keep_cursor);\n\n  /*\n   * Leave the cursor at the first non-blank of the last formatted line.\n   * If the cursor was moved one line back (e.g. with \"Q}\") go to the next\n   * line, so \".\" will do the next lines.\n   */\n  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n    ++curwin->w_cursor.lnum;\n  beginline(BL_WHITE | BL_FIX);\n  old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n  msgmore(old_line_count);\n\n  /* put '] mark on the end of the formatted area */\n  curbuf->b_op_end = curwin->w_cursor;\n\n  if (keep_cursor) {\n    curwin->w_cursor = saved_cursor;\n    saved_cursor.lnum = 0;\n  }\n\n  if (oap->is_VIsual) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_old_cursor_lnum != 0) {\n        /* When lines have been inserted or deleted, adjust the end of\n         * the Visual area to be redrawn. */\n        if (wp->w_old_cursor_lnum > wp->w_old_visual_lnum) {\n          wp->w_old_cursor_lnum += old_line_count;\n        } else {\n          wp->w_old_visual_lnum += old_line_count;\n        }\n      }\n    }\n  }\n}\n\n/*\n * Implementation of the format operator 'gq' for when using 'formatexpr'.\n */\nvoid op_formatexpr(oparg_T *oap)\n{\n  if (oap->is_VIsual)\n    /* When there is no change: need to remove the Visual selection */\n    redraw_curbuf_later(INVERTED);\n\n  if (fex_format(oap->start.lnum, oap->line_count, NUL) != 0)\n    /* As documented: when 'formatexpr' returns non-zero fall back to\n     * internal formatting. */\n    op_format(oap, FALSE);\n}\n\nint\nfex_format(\n    linenr_T lnum,\n    long count,\n    int c                  /* character to be inserted */\n)\n{\n  int use_sandbox = was_set_insecurely(\n      curwin, (char_u *)\"formatexpr\", OPT_LOCAL);\n  int r;\n  char_u *fex;\n\n  /*\n   * Set v:lnum to the first line number and v:count to the number of lines.\n   * Set v:char to the character to be inserted (can be NUL).\n   */\n  set_vim_var_nr(VV_LNUM, (varnumber_T)lnum);\n  set_vim_var_nr(VV_COUNT, (varnumber_T)count);\n  set_vim_var_char(c);\n\n  // Make a copy, the option could be changed while calling it.\n  fex = vim_strsave(curbuf->b_p_fex);\n  // Evaluate the function.\n  if (use_sandbox) {\n    sandbox++;\n  }\n  r = (int)eval_to_number(fex);\n  if (use_sandbox) {\n    sandbox--;\n  }\n\n  set_vim_var_string(VV_CHAR, NULL, -1);\n  xfree(fex);\n\n  return r;\n}\n\n/*\n * Format \"line_count\" lines, starting at the cursor position.\n * When \"line_count\" is negative, format until the end of the paragraph.\n * Lines after the cursor line are saved for undo, caller must have saved the\n * first line.\n */\nvoid\nformat_lines(\n    linenr_T line_count,\n    int avoid_fex                          /* don't use 'formatexpr' */\n)\n{\n  bool is_not_par;                  // current line not part of parag.\n  bool next_is_not_par;             // next line not part of paragraph\n  bool is_end_par;                  // at end of paragraph\n  bool prev_is_end_par = false;     // prev. line not part of parag.\n  bool next_is_start_par = false;\n  int leader_len = 0;               // leader len of current line\n  int next_leader_len;              // leader len of next line\n  char_u *leader_flags = NULL;      // flags for leader of current line\n  char_u *next_leader_flags;        // flags for leader of next line\n  bool advance = true;\n  int second_indent = -1;           // indent for second line (comment aware)\n  bool first_par_line = true;\n  int smd_save;\n  long count;\n  bool need_set_indent = true;      // set indent of next paragraph\n  bool force_format = false;\n  const int old_State = State;\n\n  // length of a line to force formatting: 3 * 'tw'\n  const int max_len = comp_textwidth(true) * 3;\n\n  // check for 'q', '2' and '1' in 'formatoptions'\n  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments\n  int do_comments_list = 0;  // format comments with 'n' or '2'\n  const bool do_second_indent = has_format_option(FO_Q_SECOND);\n  const bool do_number_indent = has_format_option(FO_Q_NUMBER);\n  const bool do_trail_white = has_format_option(FO_WHITE_PAR);\n\n  // Get info about the previous and current line.\n  if (curwin->w_cursor.lnum > 1) {\n    is_not_par = fmt_check_par(curwin->w_cursor.lnum - 1,\n                               &leader_len, &leader_flags, do_comments);\n  } else {\n    is_not_par = true;\n  }\n  next_is_not_par = fmt_check_par(curwin->w_cursor.lnum\n      , &next_leader_len, &next_leader_flags, do_comments\n      );\n  is_end_par = (is_not_par || next_is_not_par);\n  if (!is_end_par && do_trail_white)\n    is_end_par = !ends_in_white(curwin->w_cursor.lnum - 1);\n\n  curwin->w_cursor.lnum--;\n  for (count = line_count; count != 0 && !got_int; --count) {\n    /*\n     * Advance to next paragraph.\n     */\n    if (advance) {\n      curwin->w_cursor.lnum++;\n      prev_is_end_par = is_end_par;\n      is_not_par = next_is_not_par;\n      leader_len = next_leader_len;\n      leader_flags = next_leader_flags;\n    }\n\n    /*\n     * The last line to be formatted.\n     */\n    if (count == 1 || curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count) {\n      next_is_not_par = true;\n      next_leader_len = 0;\n      next_leader_flags = NULL;\n    } else {\n      next_is_not_par = fmt_check_par(curwin->w_cursor.lnum + 1\n          , &next_leader_len, &next_leader_flags, do_comments\n          );\n      if (do_number_indent)\n        next_is_start_par =\n          (get_number_indent(curwin->w_cursor.lnum + 1) > 0);\n    }\n    advance = true;\n    is_end_par = (is_not_par || next_is_not_par || next_is_start_par);\n    if (!is_end_par && do_trail_white)\n      is_end_par = !ends_in_white(curwin->w_cursor.lnum);\n\n    /*\n     * Skip lines that are not in a paragraph.\n     */\n    if (is_not_par) {\n      if (line_count < 0)\n        break;\n    } else {\n      /*\n       * For the first line of a paragraph, check indent of second line.\n       * Don't do this for comments and empty lines.\n       */\n      if (first_par_line\n          && (do_second_indent || do_number_indent)\n          && prev_is_end_par\n          && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {\n        if (do_second_indent && !LINEEMPTY(curwin->w_cursor.lnum + 1)) {\n          if (leader_len == 0 && next_leader_len == 0) {\n            /* no comment found */\n            second_indent =\n              get_indent_lnum(curwin->w_cursor.lnum + 1);\n          } else {\n            second_indent = next_leader_len;\n            do_comments_list = 1;\n          }\n        } else if (do_number_indent) {\n          if (leader_len == 0 && next_leader_len == 0) {\n            /* no comment found */\n            second_indent =\n              get_number_indent(curwin->w_cursor.lnum);\n          } else {\n            /* get_number_indent() is now \"comment aware\"... */\n            second_indent =\n              get_number_indent(curwin->w_cursor.lnum);\n            do_comments_list = 1;\n          }\n        }\n      }\n\n      /*\n       * When the comment leader changes, it's the end of the paragraph.\n       */\n      if (curwin->w_cursor.lnum >= curbuf->b_ml.ml_line_count\n          || !same_leader(curwin->w_cursor.lnum,\n              leader_len, leader_flags,\n              next_leader_len, next_leader_flags)\n          )\n        is_end_par = true;\n\n      /*\n       * If we have got to the end of a paragraph, or the line is\n       * getting long, format it.\n       */\n      if (is_end_par || force_format) {\n        if (need_set_indent)\n          /* replace indent in first line with minimal number of\n           * tabs and spaces, according to current options */\n          (void)set_indent(get_indent(), SIN_CHANGED);\n\n        // put cursor on last non-space\n        State = NORMAL;  // don't go past end-of-line\n        coladvance(MAXCOL);\n        while (curwin->w_cursor.col && ascii_isspace(gchar_cursor())) {\n          dec_cursor();\n        }\n\n        /* do the formatting, without 'showmode' */\n        State = INSERT;         /* for open_line() */\n        smd_save = p_smd;\n        p_smd = FALSE;\n        insertchar(NUL, INSCHAR_FORMAT\n            + (do_comments ? INSCHAR_DO_COM : 0)\n            + (do_comments && do_comments_list\n               ? INSCHAR_COM_LIST : 0)\n            + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);\n        State = old_State;\n        p_smd = smd_save;\n        second_indent = -1;\n        /* at end of par.: need to set indent of next par. */\n        need_set_indent = is_end_par;\n        if (is_end_par) {\n          /* When called with a negative line count, break at the\n           * end of the paragraph. */\n          if (line_count < 0)\n            break;\n          first_par_line = true;\n        }\n        force_format = false;\n      }\n\n      /*\n       * When still in same paragraph, join the lines together.  But\n       * first delete the leader from the second line.\n       */\n      if (!is_end_par) {\n        advance = false;\n        curwin->w_cursor.lnum++;\n        curwin->w_cursor.col = 0;\n        if (line_count < 0 && u_save_cursor() == FAIL)\n          break;\n        if (next_leader_len > 0) {\n          (void)del_bytes(next_leader_len, false, false);\n          mark_col_adjust(curwin->w_cursor.lnum, (colnr_T)0, 0L,\n                          (long)-next_leader_len, 0);\n        } else if (second_indent > 0) {   // the \"leader\" for FO_Q_SECOND\n          int indent = (int)getwhitecols_curline();\n\n          if (indent > 0) {\n            (void)del_bytes(indent, false, false);\n            mark_col_adjust(curwin->w_cursor.lnum,\n                            (colnr_T)0, 0L, (long)-indent, 0);\n          }\n        }\n        curwin->w_cursor.lnum--;\n        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {\n          beep_flush();\n          break;\n        }\n        first_par_line = false;\n        // If the line is getting long, format it next time\n        if (STRLEN(get_cursor_line_ptr()) > (size_t)max_len) {\n          force_format = true;\n        } else {\n          force_format = false;\n        }\n      }\n    }\n    line_breakcheck();\n  }\n}\n\n/*\n * Return TRUE if line \"lnum\" ends in a white character.\n */\nstatic int ends_in_white(linenr_T lnum)\n{\n  char_u      *s = ml_get(lnum);\n  size_t l;\n\n  if (*s == NUL)\n    return FALSE;\n  l = STRLEN(s) - 1;\n  return ascii_iswhite(s[l]);\n}\n\n/*\n * Blank lines, and lines containing only the comment leader, are left\n * untouched by the formatting.  The function returns TRUE in this\n * case.  It also returns TRUE when a line starts with the end of a comment\n * ('e' in comment flags), so that this line is skipped, and not joined to the\n * previous line.  A new paragraph starts after a blank line, or when the\n * comment leader changes -- webb.\n */\nstatic int fmt_check_par(linenr_T lnum, int *leader_len, char_u **leader_flags, int do_comments)\n{\n  char_u      *flags = NULL;        /* init for GCC */\n  char_u      *ptr;\n\n  ptr = ml_get(lnum);\n  if (do_comments)\n    *leader_len = get_leader_len(ptr, leader_flags, FALSE, TRUE);\n  else\n    *leader_len = 0;\n\n  if (*leader_len > 0) {\n    /*\n     * Search for 'e' flag in comment leader flags.\n     */\n    flags = *leader_flags;\n    while (*flags && *flags != ':' && *flags != COM_END)\n      ++flags;\n  }\n\n  return *skipwhite(ptr + *leader_len) == NUL\n         || (*leader_len > 0 && *flags == COM_END)\n         || startPS(lnum, NUL, FALSE);\n}\n\n/*\n * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the\n * previous line is in the same paragraph.  Used for auto-formatting.\n */\nint paragraph_start(linenr_T lnum)\n{\n  char_u *p;\n  int leader_len = 0;                // leader len of current line\n  char_u *leader_flags = NULL;       // flags for leader of current line\n  int next_leader_len = 0;           // leader len of next line\n  char_u *next_leader_flags = NULL;  // flags for leader of next line\n\n  if (lnum <= 1)\n    return TRUE;                /* start of the file */\n\n  p = ml_get(lnum - 1);\n  if (*p == NUL)\n    return TRUE;                /* after empty line */\n\n  const bool do_comments = has_format_option(FO_Q_COMS);  // format comments\n  if (fmt_check_par(lnum - 1, &leader_len, &leader_flags, do_comments)) {\n    return true;  // after non-paragraph line\n  }\n\n  if (fmt_check_par(lnum, &next_leader_len, &next_leader_flags, do_comments)) {\n    return true;  // \"lnum\" is not a paragraph line\n  }\n\n  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1))\n    return TRUE;                /* missing trailing space in previous line. */\n\n  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0))\n    return TRUE;                /* numbered item starts in \"lnum\". */\n\n  if (!same_leader(lnum - 1, leader_len, leader_flags,\n          next_leader_len, next_leader_flags))\n    return TRUE;                /* change of comment leader. */\n\n  return FALSE;\n}\n\n/*\n * prepare a few things for block mode yank/delete/tilde\n *\n * for delete:\n * - textlen includes the first/last char to be (partly) deleted\n * - start/endspaces is the number of columns that are taken by the\n *   first/last deleted char minus the number of columns that have to be\n *   deleted.\n * for yank and tilde:\n * - textlen includes the first/last char to be wholly yanked\n * - start/endspaces is the number of columns of the first/last yanked char\n *   that are to be yanked.\n */\nstatic void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum,\n                       bool is_del)\n{\n  int incr = 0;\n  char_u      *pend;\n  char_u      *pstart;\n  char_u      *line;\n  char_u      *prev_pstart;\n  char_u      *prev_pend;\n  const int lbr_saved = curwin->w_p_lbr;\n\n  // Avoid a problem with unwanted linebreaks in block mode.\n  curwin->w_p_lbr = false;\n  bdp->startspaces = 0;\n  bdp->endspaces = 0;\n  bdp->textlen = 0;\n  bdp->start_vcol = 0;\n  bdp->end_vcol = 0;\n  bdp->is_short = false;\n  bdp->is_oneChar = false;\n  bdp->pre_whitesp = 0;\n  bdp->pre_whitesp_c = 0;\n  bdp->end_char_vcols = 0;\n  bdp->start_char_vcols = 0;\n\n  line = ml_get(lnum);\n  pstart = line;\n  prev_pstart = line;\n  while (bdp->start_vcol < oap->start_vcol && *pstart) {\n    /* Count a tab for what it's worth (if list mode not on) */\n    incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);\n    bdp->start_vcol += incr;\n    if (ascii_iswhite(*pstart)) {\n      bdp->pre_whitesp += incr;\n      bdp->pre_whitesp_c++;\n    } else {\n      bdp->pre_whitesp = 0;\n      bdp->pre_whitesp_c = 0;\n    }\n    prev_pstart = pstart;\n    MB_PTR_ADV(pstart);\n  }\n  bdp->start_char_vcols = incr;\n  if (bdp->start_vcol < oap->start_vcol) {      /* line too short */\n    bdp->end_vcol = bdp->start_vcol;\n    bdp->is_short = true;\n    if (!is_del || oap->op_type == OP_APPEND) {\n      bdp->endspaces = oap->end_vcol - oap->start_vcol + 1;\n    }\n  } else {\n    /* notice: this converts partly selected Multibyte characters to\n     * spaces, too. */\n    bdp->startspaces = bdp->start_vcol - oap->start_vcol;\n    if (is_del && bdp->startspaces)\n      bdp->startspaces = bdp->start_char_vcols - bdp->startspaces;\n    pend = pstart;\n    bdp->end_vcol = bdp->start_vcol;\n    if (bdp->end_vcol > oap->end_vcol) {  // it's all in one character\n      bdp->is_oneChar = true;\n      if (oap->op_type == OP_INSERT) {\n        bdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n      } else if (oap->op_type == OP_APPEND) {\n        bdp->startspaces += oap->end_vcol - oap->start_vcol + 1;\n        bdp->endspaces = bdp->start_char_vcols - bdp->startspaces;\n      } else {\n        bdp->startspaces = oap->end_vcol - oap->start_vcol + 1;\n        if (is_del && oap->op_type != OP_LSHIFT) {\n          /* just putting the sum of those two into\n           * bdp->startspaces doesn't work for Visual replace,\n           * so we have to split the tab in two */\n          bdp->startspaces = bdp->start_char_vcols\n                             - (bdp->start_vcol - oap->start_vcol);\n          bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n        }\n      }\n    } else {\n      prev_pend = pend;\n      while (bdp->end_vcol <= oap->end_vcol && *pend != NUL) {\n        /* Count a tab for what it's worth (if list mode not on) */\n        prev_pend = pend;\n        incr = lbr_chartabsize_adv(line, &pend, (colnr_T)bdp->end_vcol);\n        bdp->end_vcol += incr;\n      }\n      if (bdp->end_vcol <= oap->end_vcol\n          && (!is_del\n              || oap->op_type == OP_APPEND\n              || oap->op_type == OP_REPLACE)) {  // line too short\n        bdp->is_short = true;\n        // Alternative: include spaces to fill up the block.\n        // Disadvantage: can lead to trailing spaces when the line is\n        // short where the text is put\n        // if (!is_del || oap->op_type == OP_APPEND)\n        if (oap->op_type == OP_APPEND || virtual_op) {\n          bdp->endspaces = oap->end_vcol - bdp->end_vcol\n                           + oap->inclusive;\n        }\n      } else if (bdp->end_vcol > oap->end_vcol) {\n        bdp->endspaces = bdp->end_vcol - oap->end_vcol - 1;\n        if (!is_del && bdp->endspaces) {\n          bdp->endspaces = incr - bdp->endspaces;\n          if (pend != pstart)\n            pend = prev_pend;\n        }\n      }\n    }\n    bdp->end_char_vcols = incr;\n    if (is_del && bdp->startspaces)\n      pstart = prev_pstart;\n    bdp->textlen = (int)(pend - pstart);\n  }\n  bdp->textcol = (colnr_T) (pstart - line);\n  bdp->textstart = pstart;\n  curwin->w_p_lbr = lbr_saved;\n}\n\n/// Handle the add/subtract operator.\n///\n/// @param[in]  oap      Arguments of operator.\n/// @param[in]  Prenum1  Amount of addition or subtraction.\n/// @param[in]  g_cmd    Prefixed with `g`.\nvoid op_addsub(oparg_T *oap, linenr_T Prenum1, bool g_cmd)\n{\n  pos_T pos;\n  struct block_def bd;\n  ssize_t change_cnt = 0;\n  linenr_T amount = Prenum1;\n\n  if (!VIsual_active) {\n    pos = curwin->w_cursor;\n    if (u_save_cursor() == FAIL) {\n      return;\n    }\n    change_cnt = do_addsub(oap->op_type, &pos, 0, amount);\n    if (change_cnt) {\n      changed_lines(pos.lnum, 0, pos.lnum + 1, 0L, true);\n    }\n  } else {\n    int one_change;\n    int length;\n    pos_T startpos;\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n               (linenr_T)(oap->end.lnum + 1)) == FAIL) {\n      return;\n    }\n\n    pos = oap->start;\n    for (; pos.lnum <= oap->end.lnum; pos.lnum++) {\n      if (oap->motion_type == kMTBlockWise) {\n        // Visual block mode\n        block_prep(oap, &bd, pos.lnum, false);\n        pos.col = bd.textcol;\n        length = bd.textlen;\n      } else if (oap->motion_type == kMTLineWise) {\n        curwin->w_cursor.col = 0;\n        pos.col = 0;\n        length = (colnr_T)STRLEN(ml_get(pos.lnum));\n      } else {\n        // oap->motion_type == kMTCharWise\n        if (pos.lnum == oap->start.lnum && !oap->inclusive) {\n          dec(&(oap->end));\n        }\n        length = (colnr_T)STRLEN(ml_get(pos.lnum));\n        pos.col = 0;\n        if (pos.lnum == oap->start.lnum) {\n          pos.col += oap->start.col;\n          length -= oap->start.col;\n        }\n        if (pos.lnum == oap->end.lnum) {\n          length = (int)STRLEN(ml_get(oap->end.lnum));\n          if (oap->end.col >= length) {\n            oap->end.col = length - 1;\n          }\n          length = oap->end.col - pos.col + 1;\n        }\n      }\n      one_change = do_addsub(oap->op_type, &pos, length, amount);\n      if (one_change) {\n        // Remember the start position of the first change.\n        if (change_cnt == 0) {\n          startpos = curbuf->b_op_start;\n        }\n        change_cnt++;\n      }\n\n      if (g_cmd && one_change) {\n        amount += Prenum1;\n      }\n    }\n    if (change_cnt) {\n      changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L, true);\n    }\n\n    if (!change_cnt && oap->is_VIsual) {\n      // No change: need to remove the Visual selection\n      redraw_curbuf_later(INVERTED);\n    }\n\n    // Set '[ mark if something changed. Keep the last end\n    // position from do_addsub().\n    if (change_cnt > 0) {\n      curbuf->b_op_start = startpos;\n    }\n\n    if (change_cnt > p_report) {\n      if (change_cnt == 1) {\n        MSG(_(\"1 line changed\"));\n      } else {\n        smsg((char *)_(\"%\" PRId64 \" lines changed\"), (int64_t)change_cnt);\n      }\n    }\n  }\n}\n\n/// Add or subtract from a number in a line.\n///\n/// @param op_type OP_NR_ADD or OP_NR_SUB.\n/// @param pos     Cursor position.\n/// @param length  Target number length.\n/// @param Prenum1 Amount of addition or subtraction.\n///\n/// @return true if some character was changed.\nint do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1)\n{\n  int col;\n  char_u      *buf1 = NULL;\n  char_u buf2[NUMBUFLEN];\n  int pre;  // 'X' or 'x': hex; '0': octal; 'B' or 'b': bin\n  static bool hexupper = false;  // 0xABC\n  uvarnumber_T n;\n  uvarnumber_T oldn;\n  char_u      *ptr;\n  int c;\n  int todel;\n  int firstdigit;\n  bool negative = false;\n  bool was_positive = true;\n  bool visual = VIsual_active;\n  bool did_change = false;\n  pos_T save_cursor = curwin->w_cursor;\n  int maxlen = 0;\n  pos_T startpos;\n  pos_T endpos;\n  colnr_T save_coladd = 0;\n\n  const bool do_hex = vim_strchr(curbuf->b_p_nf, 'x') != NULL;    // \"heX\"\n  const bool do_oct = vim_strchr(curbuf->b_p_nf, 'o') != NULL;    // \"Octal\"\n  const bool do_bin = vim_strchr(curbuf->b_p_nf, 'b') != NULL;    // \"Bin\"\n  const bool do_alpha = vim_strchr(curbuf->b_p_nf, 'p') != NULL;  // \"alPha\"\n  // \"Unsigned\"\n  const bool do_unsigned = vim_strchr(curbuf->b_p_nf, 'u') != NULL;\n\n  if (virtual_active()) {\n    save_coladd = pos->coladd;\n    pos->coladd = 0;\n  }\n\n  curwin->w_cursor = *pos;\n  ptr = ml_get(pos->lnum);\n  col = pos->col;\n\n  if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr)) {\n    goto theend;\n  }\n\n  // First check if we are on a hexadecimal number, after the \"0x\".\n  if (!VIsual_active) {\n    if (do_bin) {\n      while (col > 0 && ascii_isbdigit(ptr[col])) {\n        col--;\n        col -= utf_head_off(ptr, ptr + col);\n      }\n    }\n\n    if (do_hex) {\n      while (col > 0 && ascii_isxdigit(ptr[col])) {\n        col--;\n        col -= utf_head_off(ptr, ptr + col);\n      }\n    }\n    if (do_bin\n        && do_hex\n        && !((col > 0\n              && (ptr[col] == 'X' || ptr[col] == 'x')\n              && ptr[col - 1] == '0'\n              && !utf_head_off(ptr, ptr + col - 1)\n              && ascii_isxdigit(ptr[col + 1])))) {\n        // In case of binary/hexadecimal pattern overlap match, rescan\n\n        col = curwin->w_cursor.col;\n\n        while (col > 0 && ascii_isdigit(ptr[col])) {\n          col--;\n          col -= utf_head_off(ptr, ptr + col);\n        }\n    }\n\n    if ((do_hex\n         && col > 0\n         && (ptr[col] == 'X' || ptr[col] == 'x')\n         && ptr[col - 1] == '0'\n         && !utf_head_off(ptr, ptr + col - 1)\n         && ascii_isxdigit(ptr[col + 1]))\n        || (do_bin\n            && col > 0\n            && (ptr[col] == 'B' || ptr[col] == 'b')\n            && ptr[col - 1] == '0'\n            && !utf_head_off(ptr, ptr + col - 1)\n            && ascii_isbdigit(ptr[col + 1]))) {\n      // Found hexadecimal or binary number, move to its start.\n        col--;\n        col -= utf_head_off(ptr, ptr + col);\n    } else {\n      // Search forward and then backward to find the start of number.\n      col = pos->col;\n\n      while (ptr[col] != NUL\n             && !ascii_isdigit(ptr[col])\n             && !(do_alpha && ASCII_ISALPHA(ptr[col]))) {\n        col++;\n      }\n\n      while (col > 0\n             && ascii_isdigit(ptr[col - 1])\n             && !(do_alpha && ASCII_ISALPHA(ptr[col]))) {\n        col--;\n      }\n    }\n  }\n\n  if (visual) {\n    while (ptr[col] != NUL && length > 0 && !ascii_isdigit(ptr[col])\n           && !(do_alpha && ASCII_ISALPHA(ptr[col]))) {\n      int mb_len = utfc_ptr2len(ptr + col);\n\n      col += mb_len;\n      length -= mb_len;\n    }\n\n    if (length == 0) {\n      goto theend;\n    }\n\n    if (col > pos->col && ptr[col - 1] == '-'\n        && !utf_head_off(ptr, ptr + col - 1)\n        && !do_unsigned) {\n      negative = true;\n      was_positive = false;\n    }\n  }\n\n  // If a number was found, and saving for undo works, replace the number.\n  firstdigit = ptr[col];\n  if (!ascii_isdigit(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit))) {\n    beep_flush();\n    goto theend;\n  }\n\n  if (do_alpha && ASCII_ISALPHA(firstdigit)) {\n    // decrement or increment alphabetic character\n    if (op_type == OP_NR_SUB) {\n      if (CharOrd(firstdigit) < Prenum1) {\n        if (isupper(firstdigit)) {\n          firstdigit = 'A';\n        } else {\n          firstdigit = 'a';\n        }\n      } else {\n        firstdigit -= (int)Prenum1;\n      }\n    } else {\n      if (26 - CharOrd(firstdigit) - 1 < Prenum1) {\n        if (isupper(firstdigit)) {\n          firstdigit = 'Z';\n        } else {\n          firstdigit = 'z';\n        }\n      } else {\n        firstdigit += (int)Prenum1;\n      }\n    }\n    curwin->w_cursor.col = col;\n    startpos = curwin->w_cursor;\n    did_change = true;\n    (void)del_char(false);\n    ins_char(firstdigit);\n    endpos = curwin->w_cursor;\n    curwin->w_cursor.col = col;\n  } else {\n    if (col > 0 && ptr[col - 1] == '-'\n        && !utf_head_off(ptr, ptr + col - 1)\n        && !visual\n        && !do_unsigned) {\n      // negative number\n      col--;\n      negative = true;\n    }\n\n    // get the number value (unsigned)\n    if (visual && VIsual_mode != 'V') {\n      maxlen = (curbuf->b_visual.vi_curswant == MAXCOL\n                ? (int)STRLEN(ptr) - col\n                : length);\n    }\n\n    vim_str2nr(ptr + col, &pre, &length,\n               0 + (do_bin ? STR2NR_BIN : 0)\n               + (do_oct ? STR2NR_OCT : 0)\n               + (do_hex ? STR2NR_HEX : 0),\n               NULL, &n, maxlen);\n\n    // ignore leading '-' for hex, octal and bin numbers\n    if (pre && negative) {\n      col++;\n      length--;\n      negative = false;\n    }\n\n    // add or subtract\n    bool subtract = false;\n    if (op_type == OP_NR_SUB) {\n      subtract ^= true;\n    }\n    if (negative) {\n      subtract ^= true;\n    }\n\n    oldn = n;\n\n    n = subtract ? n - (uvarnumber_T)Prenum1\n                 : n + (uvarnumber_T)Prenum1;\n\n    // handle wraparound for decimal numbers\n    if (!pre) {\n      if (subtract) {\n        if (n > oldn) {\n          n = 1 + (n ^ (uvarnumber_T)-1);\n          negative ^= true;\n        }\n      } else {\n        // add\n        if (n < oldn) {\n          n = (n ^ (uvarnumber_T)-1);\n          negative ^= true;\n        }\n      }\n      if (n == 0) {\n        negative = false;\n      }\n    }\n\n    if (do_unsigned && negative) {\n      if (subtract) {\n        // sticking at zero.\n        n = (uvarnumber_T)0;\n      } else {\n        // sticking at 2^64 - 1.\n        n = (uvarnumber_T)(-1);\n      }\n      negative = false;\n    }\n\n    if (visual && !was_positive && !negative && col > 0) {\n      // need to remove the '-'\n      col--;\n      length++;\n    }\n\n    // Delete the old number.\n    curwin->w_cursor.col = col;\n    startpos = curwin->w_cursor;\n    did_change = true;\n    todel = length;\n    c = gchar_cursor();\n\n    // Don't include the '-' in the length, only the length of the part\n    // after it is kept the same.\n    if (c == '-') {\n      length--;\n    }\n    while (todel-- > 0) {\n      if (c < 0x100 && isalpha(c)) {\n        if (isupper(c)) {\n          hexupper = true;\n        } else {\n          hexupper = false;\n        }\n      }\n      // del_char() will mark line needing displaying\n      (void)del_char(false);\n      c = gchar_cursor();\n    }\n\n    // Prepare the leading characters in buf1[].\n    // When there are many leading zeros it could be very long.\n    // Allocate a bit too much.\n    buf1 = xmalloc((size_t)length + NUMBUFLEN);\n    ptr = buf1;\n    if (negative && (!visual || was_positive)) {\n      *ptr++ = '-';\n    }\n    if (pre) {\n      *ptr++ = '0';\n      length--;\n    }\n    if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') {\n      *ptr++ = (char_u)pre;\n      length--;\n    }\n\n    // Put the number characters in buf2[].\n    if (pre == 'b' || pre == 'B') {\n      size_t bits = 0;\n      size_t i = 0;\n\n      // leading zeros\n      for (bits = 8 * sizeof(n); bits > 0; bits--) {\n          if ((n >> (bits - 1)) & 0x1) {\n            break;\n          }\n      }\n\n      while (bits > 0) {\n          buf2[i++] = ((n >> --bits) & 0x1) ? '1' : '0';\n      }\n\n      buf2[i] = '\\0';\n\n    } else if (pre == 0) {\n      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), \"%\" PRIu64, (uint64_t)n);\n    } else if (pre == '0') {\n      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), \"%\" PRIo64, (uint64_t)n);\n    } else if (hexupper) {\n      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), \"%\" PRIX64, (uint64_t)n);\n    } else {\n      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), \"%\" PRIx64, (uint64_t)n);\n    }\n    length -= (int)STRLEN(buf2);\n\n    // Adjust number of zeros to the new number of digits, so the\n    // total length of the number remains the same.\n    // Don't do this when\n    // the result may look like an octal number.\n    if (firstdigit == '0' && !(do_oct && pre == 0)) {\n      while (length-- > 0) {\n        *ptr++ = '0';\n      }\n    }\n    *ptr = NUL;\n    STRCAT(buf1, buf2);\n    ins_str(buf1);              // insert the new number\n    endpos = curwin->w_cursor;\n    if (curwin->w_cursor.col) {\n      curwin->w_cursor.col--;\n    }\n  }\n\n  // set the '[ and '] marks\n  curbuf->b_op_start = startpos;\n  curbuf->b_op_end = endpos;\n  if (curbuf->b_op_end.col > 0) {\n    curbuf->b_op_end.col--;\n  }\n\ntheend:\n  xfree(buf1);\n  if (visual) {\n    curwin->w_cursor = save_cursor;\n  } else if (did_change) {\n    curwin->w_set_curswant = true;\n  } else if (virtual_active()) {\n    curwin->w_cursor.coladd = save_coladd;\n  }\n\n  return did_change;\n}\n\n/*\n * Return the type of a register.\n * Used for getregtype()\n * Returns kMTUnknown for error.\n */\nMotionType get_reg_type(int regname, colnr_T *reg_width)\n{\n  switch (regname) {\n    case '%':     // file name\n    case '#':     // alternate file name\n    case '=':     // expression\n    case ':':     // last command line\n    case '/':     // last search-pattern\n    case '.':     // last inserted text\n    case Ctrl_F:  // Filename under cursor\n    case Ctrl_P:  // Path under cursor, expand via \"path\"\n    case Ctrl_W:  // word under cursor\n    case Ctrl_A:  // WORD (mnemonic All) under cursor\n    case '_':     // black hole: always empty\n      return kMTCharWise;\n  }\n\n  if (regname != NUL && !valid_yank_reg(regname, false)) {\n    return kMTUnknown;\n  }\n\n  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n\n  if (reg->y_array != NULL) {\n    if (reg_width != NULL && reg->y_type == kMTBlockWise) {\n      *reg_width = reg->y_width;\n    }\n    return reg->y_type;\n  }\n  return kMTUnknown;\n}\n\n/// Format the register type as a string.\n///\n/// @param reg_type The register type.\n/// @param reg_width The width, only used if \"reg_type\" is kMTBlockWise.\n/// @param[out] buf Buffer to store formatted string. The allocated size should\n///                 be at least NUMBUFLEN+2 to always fit the value.\n/// @param buf_len The allocated size of the buffer.\nvoid format_reg_type(MotionType reg_type, colnr_T reg_width,\n                     char *buf, size_t buf_len)\n  FUNC_ATTR_NONNULL_ALL\n{\n  assert(buf_len > 1);\n  switch (reg_type) {\n    case kMTLineWise:\n      buf[0] = 'V';\n      buf[1] = NUL;\n      break;\n    case kMTCharWise:\n      buf[0] = 'v';\n      buf[1] = NUL;\n      break;\n    case kMTBlockWise:\n      snprintf(buf, buf_len, CTRL_V_STR \"%\" PRIdCOLNR, reg_width + 1);\n      break;\n    case kMTUnknown:\n      buf[0] = NUL;\n      break;\n  }\n}\n\n\n/// When `flags` has `kGRegList` return a list with text `s`.\n/// Otherwise just return `s`.\n///\n/// Returns a void * for use in get_reg_contents().\nstatic void *get_reg_wrap_one_line(char_u *s, int flags)\n{\n  if (!(flags & kGRegList)) {\n    return s;\n  }\n  list_T *const list = tv_list_alloc(1);\n  tv_list_append_allocated_string(list, (char *)s);\n  return list;\n}\n\n/// Gets the contents of a register.\n/// @remark Used for `@r` in expressions and for `getreg()`.\n///\n/// @param regname  The register.\n/// @param flags    see @ref GRegFlags\n///\n/// @returns The contents of the register as an allocated string.\n/// @returns A linked list when `flags` contains @ref kGRegList.\n/// @returns NULL for error.\nvoid *get_reg_contents(int regname, int flags)\n{\n  // Don't allow using an expression register inside an expression.\n  if (regname == '=') {\n    if (flags & kGRegNoExpr) {\n      return NULL;\n    }\n    if (flags & kGRegExprSrc) {\n      return get_reg_wrap_one_line(get_expr_line_src(), flags);\n    }\n    return get_reg_wrap_one_line(get_expr_line(), flags);\n  }\n\n  if (regname == '@')       /* \"@@\" is used for unnamed register */\n    regname = '\"';\n\n  /* check for valid regname */\n  if (regname != NUL && !valid_yank_reg(regname, false))\n    return NULL;\n\n  char_u *retval;\n  bool allocated;\n  if (get_spec_reg(regname, &retval, &allocated, false)) {\n    if (retval == NULL) {\n      return NULL;\n    }\n    if (allocated) {\n      return get_reg_wrap_one_line(retval, flags);\n    }\n    return get_reg_wrap_one_line(vim_strsave(retval), flags);\n  }\n\n  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);\n  if (reg->y_array == NULL)\n    return NULL;\n\n  if (flags & kGRegList) {\n    list_T *const list = tv_list_alloc((ptrdiff_t)reg->y_size);\n    for (size_t i = 0; i < reg->y_size; i++) {\n      tv_list_append_string(list, (const char *)reg->y_array[i], -1);\n    }\n\n    return list;\n  }\n\n  /*\n   * Compute length of resulting string.\n   */\n  size_t len = 0;\n  for (size_t i = 0; i < reg->y_size; i++) {\n    len += STRLEN(reg->y_array[i]);\n    /*\n     * Insert a newline between lines and after last line if\n     * y_type is kMTLineWise.\n     */\n    if (reg->y_type == kMTLineWise || i < reg->y_size - 1) {\n      len++;\n    }\n  }\n\n  retval = xmalloc(len + 1);\n\n  /*\n   * Copy the lines of the yank register into the string.\n   */\n  len = 0;\n  for (size_t i = 0; i < reg->y_size; i++) {\n    STRCPY(retval + len, reg->y_array[i]);\n    len += STRLEN(retval + len);\n\n    /*\n     * Insert a NL between lines and after the last line if y_type is\n     * kMTLineWise.\n     */\n    if (reg->y_type == kMTLineWise || i < reg->y_size - 1) {\n      retval[len++] = '\\n';\n    }\n  }\n  retval[len] = NUL;\n\n  return retval;\n}\n\nstatic yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)\n{\n  if (!valid_yank_reg(name, true)) {  // check for valid reg name\n    emsg_invreg(name);\n    return NULL;\n  }\n\n  // Don't want to change the current (unnamed) register.\n  *old_y_previous = y_previous;\n\n  yankreg_T *reg = get_yank_register(name, YREG_YANK);\n  if (!is_append_register(name) && !must_append) {\n      free_register(reg);\n  }\n  return reg;\n}\n\nstatic void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)\n{\n  // Send text of clipboard register to the clipboard.\n  set_clipboard(name, reg);\n\n  // ':let @\" = \"val\"' should change the meaning of the \"\" register\n  if (name != '\"') {\n    y_previous = old_y_previous;\n  }\n}\n\n/// write_reg_contents - store `str` in register `name`\n///\n/// @see write_reg_contents_ex\nvoid write_reg_contents(int name, const char_u *str, ssize_t len,\n                        int must_append)\n{\n  write_reg_contents_ex(name, str, len, must_append, kMTUnknown, 0L);\n}\n\nvoid write_reg_contents_lst(int name, char_u **strings,\n                            bool must_append, MotionType yank_type,\n                            colnr_T block_len)\n{\n  if (name == '/' || name == '=') {\n    char_u  *s = strings[0];\n    if (strings[0] == NULL) {\n      s = (char_u *)\"\";\n    } else if (strings[1] != NULL) {\n      EMSG(_(\"E883: search pattern and expression register may not \"\n             \"contain two or more lines\"));\n      return;\n    }\n    write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);\n    return;\n  }\n\n  // black hole: nothing to do\n  if (name == '_') {\n    return;\n  }\n\n  yankreg_T  *old_y_previous, *reg;\n  if (!(reg = init_write_reg(name, &old_y_previous, must_append))) {\n    return;\n  }\n\n  str_to_reg(reg, yank_type, (char_u *)strings, STRLEN((char_u *)strings),\n             block_len, true);\n  finish_write_reg(name, reg, old_y_previous);\n}\n\n/// write_reg_contents_ex - store `str` in register `name`\n///\n/// If `str` ends in '\\n' or '\\r', use linewise, otherwise use charwise.\n///\n/// @warning when `name` is '/', `len` and `must_append` are ignored. This\n///          means that `str` MUST be NUL-terminated.\n///\n/// @param name The name of the register\n/// @param str The contents to write\n/// @param len If >= 0, write `len` bytes of `str`. Otherwise, write\n///               `strlen(str)` bytes. If `len` is larger than the\n///               allocated size of `src`, the behaviour is undefined.\n/// @param must_append If true, append the contents of `str` to the current\n///                    contents of the register. Note that regardless of\n///                    `must_append`, this function will append when `name`\n///                    is an uppercase letter.\n/// @param yank_type The motion type (kMTUnknown to auto detect)\n/// @param block_len width of visual block\nvoid write_reg_contents_ex(int name,\n                           const char_u *str,\n                           ssize_t len,\n                           bool must_append,\n                           MotionType yank_type,\n                           colnr_T block_len)\n{\n  if (len < 0) {\n    len = (ssize_t) STRLEN(str);\n  }\n\n  /* Special case: '/' search pattern */\n  if (name == '/') {\n    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);\n    return;\n  }\n\n  if (name == '#') {\n    buf_T *buf;\n\n    if (ascii_isdigit(*str)) {\n      int num = atoi((char *)str);\n\n      buf = buflist_findnr(num);\n      if (buf == NULL) {\n        EMSGN(_(e_nobufnr), (long)num);\n      }\n    } else {\n      buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),\n                                           true, false, false));\n    }\n    if (buf == NULL) {\n      return;\n    }\n    curwin->w_alt_fnum = buf->b_fnum;\n    return;\n  }\n\n  if (name == '=') {\n    size_t offset = 0;\n    size_t totlen = (size_t) len;\n\n    if (must_append && expr_line) {\n      // append has been specified and expr_line already exists, so we'll\n      // append the new string to expr_line.\n      size_t exprlen = STRLEN(expr_line);\n\n      totlen += exprlen;\n      offset = exprlen;\n    }\n\n    // modify the global expr_line, extend/shrink it if necessary (realloc).\n    // Copy the input string into the adjusted memory at the specified\n    // offset.\n    expr_line = xrealloc(expr_line, totlen + 1);\n    memcpy(expr_line + offset, str, (size_t)len);\n    expr_line[totlen] = NUL;\n\n    return;\n  }\n\n  if (name == '_') {        // black hole: nothing to do\n    return;\n  }\n\n  yankreg_T  *old_y_previous, *reg;\n  if (!(reg = init_write_reg(name, &old_y_previous, must_append))) {\n    return;\n  }\n  str_to_reg(reg, yank_type, str, (size_t)len, block_len, false);\n  finish_write_reg(name, reg, old_y_previous);\n}\n\n/// str_to_reg - Put a string into a register.\n///\n/// When the register is not empty, the string is appended.\n///\n/// @param y_ptr pointer to yank register\n/// @param yank_type The motion type (kMTUnknown to auto detect)\n/// @param str string or list of strings to put in register\n/// @param len length of the string (Ignored when str_list=true.)\n/// @param blocklen width of visual block, or -1 for \"I don't know.\"\n/// @param str_list True if str is `char_u **`.\nstatic void str_to_reg(yankreg_T *y_ptr, MotionType yank_type,\n                       const char_u *str, size_t len, colnr_T blocklen,\n                       bool str_list)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (y_ptr->y_array == NULL) {  // NULL means empty register\n    y_ptr->y_size = 0;\n  }\n\n  if (yank_type == kMTUnknown) {\n    yank_type = ((str_list\n                  || (len > 0 && (str[len - 1] == NL || str[len - 1] == CAR)))\n                 ? kMTLineWise : kMTCharWise);\n  }\n\n  size_t newlines = 0;\n  bool extraline = false;  // extra line at the end\n  bool append = false;     // append to last line in register\n\n  // Count the number of lines within the string\n  if (str_list) {\n    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss) {\n      newlines++;\n    }\n  } else {\n    newlines = memcnt(str, '\\n', len);\n    if (yank_type == kMTCharWise || len == 0 || str[len - 1] != '\\n') {\n      extraline = 1;\n      ++newlines;         // count extra newline at the end\n    }\n    if (y_ptr->y_size > 0 && y_ptr->y_type == kMTCharWise) {\n      append = true;\n      --newlines;         // uncount newline when appending first line\n    }\n  }\n\n\n  // Grow the register array to hold the pointers to the new lines.\n  char_u **pp = xrealloc(y_ptr->y_array,\n                         (y_ptr->y_size + newlines) * sizeof(char_u *));\n  y_ptr->y_array = pp;\n\n  size_t lnum = y_ptr->y_size;  // The current line number.\n\n  // If called with `blocklen < 0`, we have to update the yank reg's width.\n  size_t maxlen = 0;\n\n  // Find the end of each line and save it into the array.\n  if (str_list) {\n    for (char_u **ss = (char_u **) str; *ss != NULL; ++ss, ++lnum) {\n      size_t ss_len = STRLEN(*ss);\n      pp[lnum] = xmemdupz(*ss, ss_len);\n      if (ss_len > maxlen) {\n        maxlen = ss_len;\n      }\n    }\n  } else {\n    size_t line_len;\n    for (const char_u *start = str, *end = str + len;\n         start < end + extraline;\n         start += line_len + 1, lnum++) {\n      assert(end - start >= 0);\n      line_len = (size_t)((char_u *)xmemscan(start, '\\n',\n                                             (size_t)(end - start)) - start);\n      if (line_len > maxlen) {\n        maxlen = line_len;\n      }\n\n      // When appending, copy the previous line and free it after.\n      size_t extra = append ? STRLEN(pp[--lnum]) : 0;\n      char_u *s = xmallocz(line_len + extra);\n      memcpy(s, pp[lnum], extra);\n      memcpy(s + extra, start, line_len);\n      size_t s_len = extra + line_len;\n\n      if (append) {\n        xfree(pp[lnum]);\n        append = false;  // only first line is appended\n      }\n      pp[lnum] = s;\n\n      // Convert NULs to '\\n' to prevent truncation.\n      memchrsub(pp[lnum], NUL, '\\n', s_len);\n    }\n  }\n  y_ptr->y_type = yank_type;\n  y_ptr->y_size = lnum;\n  set_yreg_additional_data(y_ptr, NULL);\n  y_ptr->timestamp = os_time();\n  if (yank_type == kMTBlockWise) {\n    y_ptr->y_width = (blocklen == -1 ? (colnr_T) maxlen - 1 : blocklen);\n  } else {\n    y_ptr->y_width = 0;\n  }\n}\n\nvoid clear_oparg(oparg_T *oap)\n{\n  memset(oap, 0, sizeof(oparg_T));\n}\n\n\n/*\n *  Count the number of bytes, characters and \"words\" in a line.\n *\n *  \"Words\" are counted by looking for boundaries between non-space and\n *  space characters.  (it seems to produce results that match 'wc'.)\n *\n *  Return value is byte count; word count for the line is added to \"*wc\".\n *  Char count is added to \"*cc\".\n *\n *  The function will only examine the first \"limit\" characters in the\n *  line, stopping if it encounters an end-of-line (NUL byte).  In that\n *  case, eol_size will be added to the character count to account for\n *  the size of the EOL character.\n */\nstatic varnumber_T line_count_info(char_u *line, varnumber_T *wc,\n                                   varnumber_T *cc, varnumber_T limit,\n                                   int eol_size)\n{\n  varnumber_T i;\n  varnumber_T words = 0;\n  varnumber_T chars = 0;\n  int is_word = 0;\n\n  for (i = 0; i < limit && line[i] != NUL; ) {\n    if (is_word) {\n      if (ascii_isspace(line[i])) {\n        words++;\n        is_word = 0;\n      }\n    } else if (!ascii_isspace(line[i]))\n      is_word = 1;\n    ++chars;\n    i += (*mb_ptr2len)(line + i);\n  }\n\n  if (is_word)\n    words++;\n  *wc += words;\n\n  /* Add eol_size if the end of line was reached before hitting limit. */\n  if (i < limit && line[i] == NUL) {\n    i += eol_size;\n    chars += eol_size;\n  }\n  *cc += chars;\n  return i;\n}\n\n/// Give some info about the position of the cursor (for \"g CTRL-G\").\n/// In Visual mode, give some info about the selected region.  (In this case,\n/// the *_count_cursor variables store running totals for the selection.)\n/// When \"dict\" is not NULL store the info there instead of showing it.\nvoid cursor_pos_info(dict_T *dict)\n{\n  char_u      *p;\n  char_u buf1[50];\n  char_u buf2[40];\n  linenr_T lnum;\n  varnumber_T byte_count = 0;\n  varnumber_T bom_count = 0;\n  varnumber_T byte_count_cursor = 0;\n  varnumber_T char_count = 0;\n  varnumber_T char_count_cursor = 0;\n  varnumber_T word_count = 0;\n  varnumber_T word_count_cursor = 0;\n  int eol_size;\n  varnumber_T last_check = 100000L;\n  long line_count_selected = 0;\n  pos_T min_pos, max_pos;\n  oparg_T oparg;\n  struct block_def bd;\n  const int l_VIsual_active = VIsual_active;\n  const int l_VIsual_mode = VIsual_mode;\n\n  // Compute the length of the file in characters.\n  if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n    if (dict == NULL) {\n      MSG(_(no_lines_msg));\n      return;\n    }\n  } else {\n    if (get_fileformat(curbuf) == EOL_DOS)\n      eol_size = 2;\n    else\n      eol_size = 1;\n\n    if (l_VIsual_active) {\n      if (lt(VIsual, curwin->w_cursor)) {\n        min_pos = VIsual;\n        max_pos = curwin->w_cursor;\n      } else {\n        min_pos = curwin->w_cursor;\n        max_pos = VIsual;\n      }\n      if (*p_sel == 'e' && max_pos.col > 0)\n        --max_pos.col;\n\n      if (l_VIsual_mode == Ctrl_V) {\n        char_u * saved_sbr = p_sbr;\n\n        /* Make 'sbr' empty for a moment to get the correct size. */\n        p_sbr = empty_option;\n        oparg.is_VIsual = true;\n        oparg.motion_type = kMTBlockWise;\n        oparg.op_type = OP_NOP;\n        getvcols(curwin, &min_pos, &max_pos,\n            &oparg.start_vcol, &oparg.end_vcol);\n        p_sbr = saved_sbr;\n        if (curwin->w_curswant == MAXCOL)\n          oparg.end_vcol = MAXCOL;\n        /* Swap the start, end vcol if needed */\n        if (oparg.end_vcol < oparg.start_vcol) {\n          oparg.end_vcol += oparg.start_vcol;\n          oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;\n          oparg.end_vcol -= oparg.start_vcol;\n        }\n      }\n      line_count_selected = max_pos.lnum - min_pos.lnum + 1;\n    }\n\n    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {\n      /* Check for a CTRL-C every 100000 characters. */\n      if (byte_count > last_check) {\n        os_breakcheck();\n        if (got_int)\n          return;\n        last_check = byte_count + 100000L;\n      }\n\n      /* Do extra processing for VIsual mode. */\n      if (l_VIsual_active\n          && lnum >= min_pos.lnum && lnum <= max_pos.lnum) {\n        char_u      *s = NULL;\n        long len = 0L;\n\n        switch (l_VIsual_mode) {\n        case Ctrl_V:\n          virtual_op = virtual_active();\n          block_prep(&oparg, &bd, lnum, false);\n          virtual_op = kNone;\n          s = bd.textstart;\n          len = (long)bd.textlen;\n          break;\n        case 'V':\n          s = ml_get(lnum);\n          len = MAXCOL;\n          break;\n        case 'v':\n        {\n          colnr_T start_col = (lnum == min_pos.lnum)\n                              ? min_pos.col : 0;\n          colnr_T end_col = (lnum == max_pos.lnum)\n                            ? max_pos.col - start_col + 1 : MAXCOL;\n\n          s = ml_get(lnum) + start_col;\n          len = end_col;\n        }\n        break;\n        }\n        if (s != NULL) {\n          byte_count_cursor += line_count_info(s, &word_count_cursor,\n              &char_count_cursor, len, eol_size);\n          if (lnum == curbuf->b_ml.ml_line_count\n              && !curbuf->b_p_eol\n              && (curbuf->b_p_bin || !curbuf->b_p_fixeol)\n              && (long)STRLEN(s) < len)\n            byte_count_cursor -= eol_size;\n        }\n      } else {\n        /* In non-visual mode, check for the line the cursor is on */\n        if (lnum == curwin->w_cursor.lnum) {\n          word_count_cursor += word_count;\n          char_count_cursor += char_count;\n          byte_count_cursor = byte_count\n            + line_count_info(ml_get(lnum), &word_count_cursor,\n                              &char_count_cursor,\n                              (varnumber_T)curwin->w_cursor.col + 1,\n                              eol_size);\n        }\n      }\n      // Add to the running totals\n      byte_count += line_count_info(ml_get(lnum), &word_count, &char_count,\n                                    (varnumber_T)MAXCOL, eol_size);\n    }\n\n    // Correction for when last line doesn't have an EOL.\n    if (!curbuf->b_p_eol && (curbuf->b_p_bin || !curbuf->b_p_fixeol)) {\n      byte_count -= eol_size;\n    }\n\n    if (dict == NULL) {\n      if (l_VIsual_active) {\n        if (l_VIsual_mode == Ctrl_V && curwin->w_curswant < MAXCOL) {\n          getvcols(curwin, &min_pos, &max_pos, &min_pos.col, &max_pos.col);\n          int64_t cols;\n          STRICT_SUB(oparg.end_vcol + 1, oparg.start_vcol, &cols, int64_t);\n          vim_snprintf((char *)buf1, sizeof(buf1), _(\"%\" PRId64 \" Cols; \"),\n                       cols);\n        } else {\n          buf1[0] = NUL;\n        }\n\n        if (char_count_cursor == byte_count_cursor\n            && char_count == byte_count) {\n          vim_snprintf((char *)IObuff, IOSIZE,\n                       _(\"Selected %s%\" PRId64 \" of %\" PRId64 \" Lines;\"\n                         \" %\" PRId64 \" of %\" PRId64 \" Words;\"\n                         \" %\" PRId64 \" of %\" PRId64 \" Bytes\"),\n                       buf1, (int64_t)line_count_selected,\n                       (int64_t)curbuf->b_ml.ml_line_count,\n                       (int64_t)word_count_cursor, (int64_t)word_count,\n                       (int64_t)byte_count_cursor, (int64_t)byte_count);\n        } else {\n          vim_snprintf((char *)IObuff, IOSIZE,\n                       _(\"Selected %s%\" PRId64 \" of %\" PRId64 \" Lines;\"\n                         \" %\" PRId64 \" of %\" PRId64 \" Words;\"\n                         \" %\" PRId64 \" of %\" PRId64 \" Chars;\"\n                         \" %\" PRId64 \" of %\" PRId64 \" Bytes\"),\n                       buf1, (int64_t)line_count_selected,\n                       (int64_t)curbuf->b_ml.ml_line_count,\n                       (int64_t)word_count_cursor, (int64_t)word_count,\n                       (int64_t)char_count_cursor, (int64_t)char_count,\n                       (int64_t)byte_count_cursor, (int64_t)byte_count);\n        }\n      } else {\n        p = get_cursor_line_ptr();\n        validate_virtcol();\n        col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,\n                  (int)curwin->w_virtcol + 1);\n        col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));\n\n        if (char_count_cursor == byte_count_cursor\n            && char_count == byte_count) {\n          vim_snprintf((char *)IObuff, IOSIZE,\n                       _(\"Col %s of %s; Line %\" PRId64 \" of %\" PRId64 \";\"\n                         \" Word %\" PRId64 \" of %\" PRId64 \";\"\n                         \" Byte %\" PRId64 \" of %\" PRId64 \"\"),\n                       (char *)buf1, (char *)buf2,\n                       (int64_t)curwin->w_cursor.lnum,\n                       (int64_t)curbuf->b_ml.ml_line_count,\n                       (int64_t)word_count_cursor, (int64_t)word_count,\n                       (int64_t)byte_count_cursor, (int64_t)byte_count);\n        } else {\n          vim_snprintf((char *)IObuff, IOSIZE,\n                       _(\"Col %s of %s; Line %\" PRId64 \" of %\" PRId64 \";\"\n                         \" Word %\" PRId64 \" of %\" PRId64 \";\"\n                         \" Char %\" PRId64 \" of %\" PRId64 \";\"\n                         \" Byte %\" PRId64 \" of %\" PRId64 \"\"),\n                       (char *)buf1, (char *)buf2,\n                       (int64_t)curwin->w_cursor.lnum,\n                       (int64_t)curbuf->b_ml.ml_line_count,\n                       (int64_t)word_count_cursor, (int64_t)word_count,\n                       (int64_t)char_count_cursor, (int64_t)char_count,\n                       (int64_t)byte_count_cursor, (int64_t)byte_count);\n        }\n      }\n    }\n\n    bom_count = bomb_size();\n    if (dict == NULL && bom_count > 0) {\n      const size_t len = STRLEN(IObuff);\n      vim_snprintf((char *)IObuff + len, IOSIZE - len,\n                   _(\"(+%\" PRId64 \" for BOM)\"), (int64_t)bom_count);\n    }\n    if (dict == NULL) {\n      // Don't shorten this message, the user asked for it.\n      p = p_shm;\n      p_shm = (char_u *)\"\";\n      msg(IObuff);\n      p_shm = p;\n    }\n  }\n\n  if (dict != NULL) {\n    // Don't shorten this message, the user asked for it.\n    tv_dict_add_nr(dict, S_LEN(\"words\"), (varnumber_T)word_count);\n    tv_dict_add_nr(dict, S_LEN(\"chars\"), (varnumber_T)char_count);\n    tv_dict_add_nr(dict, S_LEN(\"bytes\"), (varnumber_T)(byte_count + bom_count));\n\n    STATIC_ASSERT(sizeof(\"visual\") == sizeof(\"cursor\"),\n                  \"key_len argument in tv_dict_add_nr is wrong\");\n    tv_dict_add_nr(dict, l_VIsual_active ? \"visual_bytes\" : \"cursor_bytes\",\n                   sizeof(\"visual_bytes\") - 1, (varnumber_T)byte_count_cursor);\n    tv_dict_add_nr(dict, l_VIsual_active ? \"visual_chars\" : \"cursor_chars\",\n                   sizeof(\"visual_chars\") - 1, (varnumber_T)char_count_cursor);\n    tv_dict_add_nr(dict, l_VIsual_active ? \"visual_words\" : \"cursor_words\",\n                   sizeof(\"visual_words\") - 1, (varnumber_T)word_count_cursor);\n  }\n}\n\n/// Check if the default register (used in an unnamed paste) should be a\n/// clipboard register. This happens when `clipboard=unnamed[plus]` is set\n/// and a provider is available.\n///\n/// @returns the name of of a clipboard register that should be used, or `NUL` if none.\nint get_default_register_name(void)\n{\n  int name = NUL;\n  adjust_clipboard_name(&name, true, false);\n  return name;\n}\n\n/// Determine if register `*name` should be used as a clipboard.\n/// In an unnamed operation, `*name` is `NUL` and will be adjusted to */+ if\n/// `clipboard=unnamed[plus]` is set.\n///\n/// @param name The name of register, or `NUL` if unnamed.\n/// @param quiet Suppress error messages\n/// @param writing if we're setting the contents of the clipboard\n///\n/// @returns the yankreg that should be written into, or `NULL`\n/// if the register isn't a clipboard or provider isn't available.\nstatic yankreg_T *adjust_clipboard_name(int *name, bool quiet, bool writing)\n{\n#define MSG_NO_CLIP \"clipboard: No provider. \" \\\n  \"Try \\\":checkhealth\\\" or \\\":h clipboard\\\".\"\n\n  yankreg_T *target = NULL;\n  bool explicit_cb_reg = (*name == '*' || *name == '+');\n  bool implicit_cb_reg = (*name == NUL) && (cb_flags & CB_UNNAMEDMASK);\n  if (!explicit_cb_reg && !implicit_cb_reg) {\n    goto end;\n  }\n\n  if (!eval_has_provider(\"clipboard\")) {\n    if (batch_change_count == 1 && !quiet\n        && (!clipboard_didwarn || (explicit_cb_reg && !redirecting()))) {\n      clipboard_didwarn = true;\n      // Do NOT error (emsg()) here--if it interrupts :redir we get into\n      // a weird state, stuck in \"redirect mode\".\n      msg((char_u *)MSG_NO_CLIP);\n    }\n    // ... else, be silent (don't flood during :while, :redir, etc.).\n    goto end;\n  }\n\n  if (explicit_cb_reg) {\n    target = &y_regs[*name == '*' ? STAR_REGISTER : PLUS_REGISTER];\n    if (writing && (cb_flags & (*name == '*' ? CB_UNNAMED : CB_UNNAMEDPLUS))) {\n      clipboard_needs_update = false;\n    }\n    goto end;\n  } else {  // unnamed register: \"implicit\" clipboard\n    if (writing && clipboard_delay_update) {\n      // For \"set\" (copy), defer the clipboard call.\n      clipboard_needs_update = true;\n      goto end;\n    } else if (!writing && clipboard_needs_update) {\n      // For \"get\" (paste), use the internal value.\n      goto end;\n    }\n\n    if (cb_flags & CB_UNNAMEDPLUS) {\n      *name = (cb_flags & CB_UNNAMED && writing) ? '\"': '+';\n      target = &y_regs[PLUS_REGISTER];\n    } else {\n      *name = '*';\n      target = &y_regs[STAR_REGISTER];\n    }\n    goto end;\n  }\n\nend:\n  return target;\n}\n\n/// @param[out] reg Expected to be empty\nbool prepare_yankreg_from_object(yankreg_T *reg, String regtype, size_t lines)\n{\n  char type = regtype.data ? regtype.data[0] : NUL;\n\n  switch (type) {\n  case 0:\n    reg->y_type = kMTUnknown;\n    break;\n  case 'v': case 'c':\n    reg->y_type = kMTCharWise;\n    break;\n  case 'V': case 'l':\n    reg->y_type = kMTLineWise;\n    break;\n  case 'b': case Ctrl_V:\n    reg->y_type = kMTBlockWise;\n    break;\n  default:\n    return false;\n  }\n\n  reg->y_width = 0;\n  if (regtype.size > 1) {\n    if (reg->y_type != kMTBlockWise) {\n      return false;\n    }\n\n    // allow \"b7\" for a block at least 7 spaces wide\n    if (!ascii_isdigit(regtype.data[1])) {\n      return false;\n    }\n    const char *p = regtype.data+1;\n    reg->y_width = getdigits_int((char_u **)&p, false, 1) - 1;\n    if (regtype.size > (size_t)(p-regtype.data)) {\n      return false;\n    }\n  }\n\n  reg->y_array = xcalloc(lines, sizeof(uint8_t *));\n  reg->y_size = lines;\n  reg->additional_data = NULL;\n  reg->timestamp = 0;\n  return true;\n}\n\nvoid finish_yankreg_from_object(yankreg_T *reg, bool clipboard_adjust)\n{\n  if (reg->y_size > 0 && strlen((char *)reg->y_array[reg->y_size-1]) == 0) {\n    // a known-to-be charwise yank might have a final linebreak\n    // but otherwise there is no line after the final newline\n    if (reg->y_type != kMTCharWise) {\n      if (reg->y_type == kMTUnknown || clipboard_adjust) {\n        xfree(reg->y_array[reg->y_size-1]);\n        reg->y_size--;\n      }\n      if (reg->y_type == kMTUnknown) {\n        reg->y_type = kMTLineWise;\n      }\n    }\n  } else {\n    if (reg->y_type == kMTUnknown) {\n      reg->y_type = kMTCharWise;\n    }\n  }\n\n  if (reg->y_type == kMTBlockWise) {\n    size_t maxlen = 0;\n    for (size_t i = 0; i < reg->y_size; i++) {\n      size_t rowlen = STRLEN(reg->y_array[i]);\n      if (rowlen > maxlen) {\n        maxlen = rowlen;\n      }\n    }\n    assert(maxlen <= INT_MAX);\n    reg->y_width = MAX(reg->y_width, (int)maxlen - 1);\n  }\n}\n\nstatic bool get_clipboard(int name, yankreg_T **target, bool quiet)\n{\n  // show message on error\n  bool errmsg = true;\n\n  yankreg_T *reg = adjust_clipboard_name(&name, quiet, false);\n  if (reg == NULL) {\n    return false;\n  }\n  free_register(reg);\n\n  list_T *const args = tv_list_alloc(1);\n  const char regname = (char)name;\n  tv_list_append_string(args, &regname, 1);\n\n  typval_T result = eval_call_provider(\"clipboard\", \"get\", args, false);\n\n  if (result.v_type != VAR_LIST) {\n    if (result.v_type == VAR_NUMBER && result.vval.v_number == 0) {\n      // failure has already been indicated by provider\n      errmsg = false;\n    }\n    goto err;\n  }\n\n  list_T *res = result.vval.v_list;\n  list_T *lines = NULL;\n  if (tv_list_len(res) == 2\n      && TV_LIST_ITEM_TV(tv_list_first(res))->v_type == VAR_LIST) {\n    lines = TV_LIST_ITEM_TV(tv_list_first(res))->vval.v_list;\n    if (TV_LIST_ITEM_TV(tv_list_last(res))->v_type != VAR_STRING) {\n      goto err;\n    }\n    char_u *regtype = TV_LIST_ITEM_TV(tv_list_last(res))->vval.v_string;\n    if (regtype == NULL || strlen((char *)regtype) > 1) {\n      goto err;\n    }\n    switch (regtype[0]) {\n    case 0:\n      reg->y_type = kMTUnknown;\n      break;\n    case 'v': case 'c':\n      reg->y_type = kMTCharWise;\n      break;\n    case 'V': case 'l':\n      reg->y_type = kMTLineWise;\n      break;\n    case 'b': case Ctrl_V:\n      reg->y_type = kMTBlockWise;\n      break;\n    default:\n      goto err;\n    }\n  } else {\n    lines = res;\n    // provider did not specify regtype, calculate it below\n    reg->y_type = kMTUnknown;\n  }\n\n  reg->y_array = xcalloc((size_t)tv_list_len(lines), sizeof(char_u *));\n  reg->y_size = (size_t)tv_list_len(lines);\n  reg->additional_data = NULL;\n  reg->timestamp = 0;\n  // Timestamp is not saved for clipboard registers because clipboard registers\n  // are not saved in the ShaDa file.\n\n  size_t tv_idx = 0;\n  TV_LIST_ITER_CONST(lines, li, {\n    if (TV_LIST_ITEM_TV(li)->v_type != VAR_STRING) {\n      goto err;\n    }\n    reg->y_array[tv_idx++] = (char_u *)xstrdupnul(\n        (const char *)TV_LIST_ITEM_TV(li)->vval.v_string);\n  });\n\n  if (reg->y_size > 0 && strlen((char*)reg->y_array[reg->y_size-1]) == 0) {\n    // a known-to-be charwise yank might have a final linebreak\n    // but otherwise there is no line after the final newline\n    if (reg->y_type != kMTCharWise) {\n      xfree(reg->y_array[reg->y_size-1]);\n      reg->y_size--;\n      if (reg->y_type == kMTUnknown) {\n        reg->y_type = kMTLineWise;\n      }\n    }\n  } else {\n    if (reg->y_type == kMTUnknown) {\n      reg->y_type = kMTCharWise;\n    }\n  }\n\n  if (reg->y_type == kMTBlockWise) {\n    size_t maxlen = 0;\n    for (size_t i = 0; i < reg->y_size; i++) {\n      size_t rowlen = STRLEN(reg->y_array[i]);\n      if (rowlen > maxlen) {\n        maxlen = rowlen;\n      }\n    }\n    assert(maxlen <= INT_MAX);\n    reg->y_width = (int)maxlen - 1;\n  }\n\n  *target = reg;\n  return true;\n\nerr:\n  if (reg->y_array) {\n    for (size_t i = 0; i < reg->y_size; i++) {\n      xfree(reg->y_array[i]);\n    }\n    xfree(reg->y_array);\n  }\n  reg->y_array = NULL;\n  reg->y_size = 0;\n  reg->additional_data = NULL;\n  reg->timestamp = 0;\n  if (errmsg) {\n    EMSG(\"clipboard: provider returned invalid data\");\n  }\n  *target = reg;\n  return false;\n}\n\nstatic void set_clipboard(int name, yankreg_T *reg)\n{\n  if (!adjust_clipboard_name(&name, false, true)) {\n    return;\n  }\n\n  list_T *const lines = tv_list_alloc(\n      (ptrdiff_t)reg->y_size + (reg->y_type != kMTCharWise));\n\n  for (size_t i = 0; i < reg->y_size; i++) {\n    tv_list_append_string(lines, (const char *)reg->y_array[i], -1);\n  }\n\n  char regtype;\n  switch (reg->y_type) {\n    case kMTLineWise: {\n      regtype = 'V';\n      tv_list_append_string(lines, NULL, 0);\n      break;\n    }\n    case kMTCharWise: {\n      regtype = 'v';\n      break;\n    }\n    case kMTBlockWise: {\n      regtype = 'b';\n      tv_list_append_string(lines, NULL, 0);\n      break;\n    }\n    case kMTUnknown: {\n      abort();\n    }\n  }\n\n  list_T *args = tv_list_alloc(3);\n  tv_list_append_list(args, lines);\n  tv_list_append_string(args, &regtype, 1);  // -V614\n  tv_list_append_string(args, ((char[]) { (char)name }), 1);\n\n  (void)eval_call_provider(\"clipboard\", \"set\", args, true);\n}\n\n/// Avoid slow things (clipboard) during batch operations (while/for-loops).\nvoid start_batch_changes(void)\n{\n  if (++batch_change_count > 1) {\n    return;\n  }\n  clipboard_delay_update = true;\n}\n\n/// Counterpart to start_batch_changes().\nvoid end_batch_changes(void)\n{\n  if (--batch_change_count > 0) {\n    // recursive\n    return;\n  }\n  clipboard_delay_update = false;\n  if (clipboard_needs_update) {\n    // must be before, as set_clipboard will invoke\n    // start/end_batch_changes recursively\n    clipboard_needs_update = false;\n    // unnamed (\"implicit\" clipboard)\n    set_clipboard(NUL, y_previous);\n  }\n}\n\nint save_batch_count(void)\n{\n  int save_count = batch_change_count;\n  batch_change_count = 0;\n  clipboard_delay_update = false;\n  if (clipboard_needs_update) {\n    clipboard_needs_update = false;\n    // unnamed (\"implicit\" clipboard)\n    set_clipboard(NUL, y_previous);\n  }\n  return save_count;\n}\n\nvoid restore_batch_count(int save_count)\n{\n  assert(batch_change_count == 0);\n  batch_change_count = save_count;\n  if (batch_change_count > 0) {\n    clipboard_delay_update = true;\n  }\n}\n\n\n/// Check whether register is empty\nstatic inline bool reg_empty(const yankreg_T *const reg)\n  FUNC_ATTR_PURE\n{\n  return (reg->y_array == NULL\n          || reg->y_size == 0\n          || (reg->y_size == 1\n              && reg->y_type == kMTCharWise\n              && *(reg->y_array[0]) == NUL));\n}\n\n/// Iterate over global registers.\n///\n/// @see op_register_iter\nconst void *op_global_reg_iter(const void *const iter, char *const name,\n                               yankreg_T *const reg, bool *is_unnamed)\n  FUNC_ATTR_NONNULL_ARG(2, 3, 4) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return op_reg_iter(iter, y_regs, name, reg, is_unnamed);\n}\n\n/// Iterate over registers `regs`.\n///\n/// @param[in]   iter      Iterator. Pass NULL to start iteration.\n/// @param[in]   regs      Registers list to be iterated.\n/// @param[out]  name      Register name.\n/// @param[out]  reg       Register contents.\n///\n/// @return Pointer that must be passed to next `op_register_iter` call or\n///         NULL if iteration is over.\nconst void *op_reg_iter(const void *const iter, const yankreg_T *const regs,\n                        char *const name, yankreg_T *const reg,\n                        bool *is_unnamed)\n  FUNC_ATTR_NONNULL_ARG(3, 4, 5) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  *name = NUL;\n  const yankreg_T *iter_reg = (iter == NULL\n                               ? &(regs[0])\n                               : (const yankreg_T *const)iter);\n  while (iter_reg - &(regs[0]) < NUM_SAVED_REGISTERS && reg_empty(iter_reg)) {\n    iter_reg++;\n  }\n  if (iter_reg - &(regs[0]) == NUM_SAVED_REGISTERS || reg_empty(iter_reg)) {\n    return NULL;\n  }\n  int iter_off = (int)(iter_reg - &(regs[0]));\n  *name = (char)get_register_name(iter_off);\n  *reg = *iter_reg;\n  *is_unnamed = (iter_reg == y_previous);\n  while (++iter_reg - &(regs[0]) < NUM_SAVED_REGISTERS) {\n    if (!reg_empty(iter_reg)) {\n      return (void *) iter_reg;\n    }\n  }\n  return NULL;\n}\n\n/// Get a number of non-empty registers\nsize_t op_reg_amount(void)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  size_t ret = 0;\n  for (size_t i = 0; i < NUM_SAVED_REGISTERS; i++) {\n    if (!reg_empty(y_regs + i)) {\n      ret++;\n    }\n  }\n  return ret;\n}\n\n/// Set register to a given value\n///\n/// @param[in]  name  Register name.\n/// @param[in]  reg  Register value.\n/// @param[in]  is_unnamed  Whether to set the unnamed regiseter to reg\n///\n/// @return true on success, false on failure.\nbool op_reg_set(const char name, const yankreg_T reg, bool is_unnamed)\n{\n  int i = op_reg_index(name);\n  if (i == -1) {\n    return false;\n  }\n  free_register(&y_regs[i]);\n  y_regs[i] = reg;\n\n  if (is_unnamed) {\n    y_previous = &y_regs[i];\n  }\n  return true;\n}\n\n/// Get register with the given name\n///\n/// @param[in]  name  Register name.\n///\n/// @return Pointer to the register contents or NULL.\nconst yankreg_T *op_reg_get(const char name)\n{\n  int i = op_reg_index(name);\n  if (i == -1) {\n    return NULL;\n  }\n  return &y_regs[i];\n}\n\n/// Set the previous yank register\n///\n/// @param[in]  name  Register name.\n///\n/// @return true on success, false on failure.\nbool op_reg_set_previous(const char name)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int i = op_reg_index(name);\n  if (i == -1) {\n    return false;\n  }\n\n  y_previous = &y_regs[i];\n  return true;\n}\n\n/// Get the byte count of buffer region. End-exclusive.\n///\n/// @return number of bytes\nbcount_t get_region_bytecount(buf_T *buf, linenr_T start_lnum,\n                              linenr_T end_lnum, colnr_T start_col,\n                              colnr_T end_col)\n{\n  linenr_T max_lnum = buf->b_ml.ml_line_count;\n  if (start_lnum > max_lnum) {\n    return 0;\n  }\n  if (start_lnum == end_lnum) {\n    return end_col - start_col;\n  }\n  const char *first = (const char *)ml_get_buf(buf, start_lnum, false);\n  bcount_t deleted_bytes = (bcount_t)STRLEN(first) - start_col + 1;\n\n  for (linenr_T i = 1; i <= end_lnum-start_lnum-1; i++) {\n    if (start_lnum + i > max_lnum) {\n      return deleted_bytes;\n    }\n    deleted_bytes += (bcount_t)STRLEN(\n        ml_get_buf(buf, start_lnum + i, false)) + 1;\n  }\n  if (end_lnum > max_lnum) {\n    return deleted_bytes;\n  }\n  return deleted_bytes + end_col;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 20, "line": 2858}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/ops.c", "reportHash": "bd6690cf994231b19ef957c8d69a41b2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 20, "line": 3174}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/ops.c", "reportHash": "a9153e2c2d6ba18d876dc2fe83388190", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 20, "line": 3415}, "message": "end of the original"}, {"location": {"col": 15, "file": 20, "line": 3417}, "message": "clone 1 starts here"}, {"location": {"col": 15, "file": 20, "line": 3423}, "message": "clone 2 starts here"}, {"location": {"col": 15, "file": 20, "line": 3415}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/ops.c", "reportHash": "90e57f1116a7c36ec64dcc39d7456429", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 17, "file": 20, "line": 5376}, "message": "'atoi' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "src/nvim/ops.c", "reportHash": "d6138e65b8a0e55d3ef40a5da59740ad", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 20, "line": 5909}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/ops.c", "reportHash": "e52fd2f738e5995c8cf4a16c7ddbd0f3", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
