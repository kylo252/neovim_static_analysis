<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "src/nvim/screen.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// screen.c: code for displaying on the screen\n//\n// Output to the screen (console, terminal emulator or GUI window) is minimized\n// by remembering what is already on the screen, and only updating the parts\n// that changed.\n//\n// The grid_*() functions write to the screen and handle updating grid->lines[].\n//\n// update_screen() is the function that updates all windows and status lines.\n// It is called from the main loop when must_redraw is non-zero.  It may be\n// called from other places when an immediate screen update is needed.\n//\n// The part of the buffer that is displayed in a window is set with:\n// - w_topline (first buffer line in window)\n// - w_topfill (filler lines above the first line)\n// - w_leftcol (leftmost window cell in window),\n// - w_skipcol (skipped window cells of first line)\n//\n// Commands that only move the cursor around in a window, do not need to take\n// action to update the display.  The main loop will check if w_topline is\n// valid and update it (scroll the window) when needed.\n//\n// Commands that scroll a window change w_topline and must call\n// check_cursor() to move the cursor into the visible part of the window, and\n// call redraw_later(wp, VALID) to have the window displayed by update_screen()\n// later.\n//\n// Commands that change text in the buffer must call changed_bytes() or\n// changed_lines() to mark the area that changed and will require updating\n// later.  The main loop will call update_screen(), which will update each\n// window that shows the changed buffer.  This assumes text above the change\n// can remain displayed as it is.  Text after the change may need updating for\n// scrolling, folding and syntax highlighting.\n//\n// Commands that change how a window is displayed (e.g., setting 'list') or\n// invalidate the contents of a window in another way (e.g., change fold\n// settings), must call redraw_later(wp, NOT_VALID) to have the whole window\n// redisplayed by update_screen() later.\n//\n// Commands that change how a buffer is displayed (e.g., setting 'tabstop')\n// must call redraw_curbuf_later(NOT_VALID) to have all the windows for the\n// buffer redisplayed by update_screen() later.\n//\n// Commands that change highlighting and possibly cause a scroll too must call\n// redraw_later(wp, SOME_VALID) to update the whole window but still use\n// scrolling to avoid redrawing everything.  But the length of displayed lines\n// must not change, use NOT_VALID then.\n//\n// Commands that move the window position must call redraw_later(wp, NOT_VALID).\n// TODO(neovim): should minimize redrawing by scrolling when possible.\n//\n// Commands that change everything (e.g., resizing the screen) must call\n// redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).\n//\n// Things that are handled indirectly:\n// - When messages scroll the screen up, msg_scrolled will be set and\n//   update_screen() called to redraw.\n///\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/api/vim.h\"\n#include \"nvim/arabic.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/cursor_shape.h\"\n#include \"nvim/decoration.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/extmark.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/highlight.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/lib/kvec.h\"\n#include \"nvim/log.h\"\n#include \"nvim/lua/executor.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/menu.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/popupmnu.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/sign.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/state.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/ui_compositor.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/version.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/window.h\"\n\n#define MB_FILLER_CHAR '<'  /* character used when a double-width character\n                             * doesn't fit. */\n\ntypedef kvec_withinit_t(DecorProvider *, 4) Providers;\n\n// temporary buffer for rendering a single screenline, so it can be\n// compared with previous contents to calculate smallest delta.\n// Per-cell attributes\nstatic size_t linebuf_size = 0;\nstatic schar_T *linebuf_char = NULL;\nstatic sattr_T *linebuf_attr = NULL;\n\nstatic match_T search_hl;       // used for 'hlsearch' highlight matching\n\nStlClickDefinition *tab_page_click_defs = NULL;\n\nlong tab_page_click_defs_size = 0;\n\n// for line_putchar. Contains the state that needs to be remembered from\n// putting one character to the next.\ntypedef struct {\n  const char *p;\n  int prev_c;  // previous Arabic character\n  int prev_c1;  // first composing char for prev_c\n} LineState;\n#define LINE_STATE(p) { p, 0, 0 }\n\n/// Whether to call \"ui_call_grid_resize\" in win_grid_alloc\nstatic bool send_grid_resize = false;\n\nstatic bool conceal_cursor_used = false;\n\nstatic bool redraw_popupmenu = false;\nstatic bool msg_grid_invalid = false;\n\nstatic bool resizing = false;\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"screen.c.generated.h\"\n#endif\n#define SEARCH_HL_PRIORITY 0\n\nstatic char * provider_err = NULL;\n\nstatic bool provider_invoke(NS ns_id, const char *name, LuaRef ref, Array args, bool default_true)\n{\n  Error err = ERROR_INIT;\n\n  textlock++;\n  provider_active = true;\n  Object ret = nlua_call_ref(ref, name, args, true, &err);\n  provider_active = false;\n  textlock--;\n\n  if (!ERROR_SET(&err)\n      && api_object_to_bool(ret, \"provider %s retval\", default_true, &err)) {\n    return true;\n  }\n\n  if (ERROR_SET(&err)) {\n    const char *ns_name = describe_ns(ns_id);\n    ELOG(\"error in provider %s:%s: %s\", ns_name, name, err.msg);\n    bool verbose_errs = true;  // TODO(bfredl):\n    if (verbose_errs && provider_err == NULL) {\n      static char errbuf[IOSIZE];\n      snprintf(errbuf, sizeof errbuf, \"%s: %s\", ns_name, err.msg);\n      provider_err = xstrdup(errbuf);\n    }\n  }\n\n  api_free_object(ret);\n  return false;\n}\n\n/// Redraw a window later, with update_screen(type).\n///\n/// Set must_redraw only if not already set to a higher value.\n/// e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.\nvoid redraw_later(win_T *wp, int type)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (!exiting && wp->w_redr_type < type) {\n    wp->w_redr_type = type;\n    if (type >= NOT_VALID) {\n      wp->w_lines_valid = 0;\n    }\n    if (must_redraw < type) {   // must_redraw is the maximum of all windows\n      must_redraw = type;\n    }\n  }\n}\n\n/*\n * Mark all windows to be redrawn later.\n */\nvoid redraw_all_later(int type)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    redraw_later(wp, type);\n  }\n  // This may be needed when switching tabs.\n  if (must_redraw < type) {\n    must_redraw = type;\n  }\n}\n\nvoid screen_invalidate_highlights(void)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    redraw_later(wp, NOT_VALID);\n    wp->w_grid_alloc.valid = false;\n  }\n}\n\n/*\n * Mark all windows that are editing the current buffer to be updated later.\n */\nvoid redraw_curbuf_later(int type)\n{\n  redraw_buf_later(curbuf, type);\n}\n\nvoid redraw_buf_later(buf_T *buf, int type)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_buffer == buf) {\n      redraw_later(wp, type);\n    }\n  }\n}\n\nvoid redraw_buf_line_later(buf_T *buf,  linenr_T line)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_buffer == buf\n        && line >= wp->w_topline && line < wp->w_botline) {\n      redrawWinline(wp, line);\n    }\n  }\n}\n\nvoid redraw_buf_range_later(buf_T *buf,  linenr_T firstline, linenr_T lastline)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_buffer == buf\n        && lastline >= wp->w_topline && firstline < wp->w_botline) {\n      if (wp->w_redraw_top == 0 || wp->w_redraw_top > firstline) {\n        wp->w_redraw_top = firstline;\n      }\n      if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lastline) {\n        wp->w_redraw_bot = lastline;\n      }\n      redraw_later(wp, VALID);\n    }\n  }\n}\n\n/*\n * Changed something in the current window, at buffer line \"lnum\", that\n * requires that line and possibly other lines to be redrawn.\n * Used when entering/leaving Insert mode with the cursor on a folded line.\n * Used to remove the \"$\" from a change command.\n * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot\n * may become invalid and the whole window will have to be redrawn.\n */\nvoid redrawWinline(win_T *wp, linenr_T lnum)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (lnum >= wp->w_topline\n      && lnum < wp->w_botline) {\n    if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum) {\n      wp->w_redraw_top = lnum;\n    }\n    if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum) {\n      wp->w_redraw_bot = lnum;\n    }\n    redraw_later(wp, VALID);\n  }\n}\n\n/*\n * update all windows that are editing the current buffer\n */\nvoid update_curbuf(int type)\n{\n  redraw_curbuf_later(type);\n  update_screen(type);\n}\n\n/// Redraw the parts of the screen that is marked for redraw.\n///\n/// Most code shouldn't call this directly, rather use redraw_later() and\n/// and redraw_all_later() to mark parts of the screen as needing a redraw.\n///\n/// @param type set to a NOT_VALID to force redraw of entire screen\nint update_screen(int type)\n{\n  static bool did_intro = false;\n\n  // Don't do anything if the screen structures are (not yet) valid.\n  // A VimResized autocmd can invoke redrawing in the middle of a resize,\n  // which would bypass the checks in screen_resize for popupmenu etc.\n  if (!default_grid.chars || resizing) {\n    return FAIL;\n  }\n\n  // May have postponed updating diffs.\n  if (need_diff_redraw) {\n    diff_redraw(true);\n  }\n\n  if (must_redraw) {\n    if (type < must_redraw) {       // use maximal type\n      type = must_redraw;\n    }\n\n    /* must_redraw is reset here, so that when we run into some weird\n    * reason to redraw while busy redrawing (e.g., asynchronous\n    * scrolling), or update_topline() in win_update() will cause a\n    * scroll, the screen will be redrawn later or in win_update(). */\n    must_redraw = 0;\n  }\n\n  // Need to update w_lines[].\n  if (curwin->w_lines_valid == 0 && type < NOT_VALID) {\n    type = NOT_VALID;\n  }\n\n  /* Postpone the redrawing when it's not needed and when being called\n   * recursively. */\n  if (!redrawing() || updating_screen) {\n    must_redraw = type;\n    if (type > INVERTED_ALL) {\n      curwin->w_lines_valid = 0;  // don't use w_lines[].wl_size now\n    }\n    return FAIL;\n  }\n  updating_screen = 1;\n\n  display_tick++;           // let syntax code know we're in a next round of\n                            // display updating\n\n  // Tricky: vim code can reset msg_scrolled behind our back, so need\n  // separate bookkeeping for now.\n  if (msg_did_scroll) {\n    msg_did_scroll = false;\n    msg_scrolled_at_flush = 0;\n  }\n\n  if (type >= CLEAR || !default_grid.valid) {\n    ui_comp_set_screen_valid(false);\n  }\n\n  // if the screen was scrolled up when displaying a message, scroll it down\n  if (msg_scrolled || msg_grid_invalid) {\n    clear_cmdline = true;\n    int valid = MAX(Rows - msg_scrollsize(), 0);\n    if (msg_grid.chars) {\n      // non-displayed part of msg_grid is considered invalid.\n      for (int i = 0; i < MIN(msg_scrollsize(), msg_grid.Rows); i++) {\n        grid_clear_line(&msg_grid, msg_grid.line_offset[i],\n                        (int)msg_grid.Columns, false);\n      }\n    }\n    if (msg_use_msgsep()) {\n      msg_grid.throttled = false;\n      // CLEAR is already handled\n      if (type == NOT_VALID && !ui_has(kUIMultigrid) && msg_scrolled) {\n        ui_comp_set_screen_valid(false);\n        for (int i = valid; i < Rows-p_ch; i++) {\n          grid_clear_line(&default_grid, default_grid.line_offset[i],\n                          Columns, false);\n        }\n        FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n          if (wp->w_floating) {\n            continue;\n          }\n          if (W_ENDROW(wp) > valid) {\n            wp->w_redr_type = MAX(wp->w_redr_type, NOT_VALID);\n          }\n          if (W_ENDROW(wp) + wp->w_status_height > valid) {\n            wp->w_redr_status = true;\n          }\n        }\n      }\n      msg_grid_set_pos(Rows-p_ch, false);\n      msg_grid_invalid = false;\n    } else if (msg_scrolled > Rows - 5) {  // clearing is faster\n      type = CLEAR;\n    } else if (type != CLEAR) {\n      check_for_delay(false);\n      grid_ins_lines(&default_grid, 0, msg_scrolled, Rows, 0, Columns);\n      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n        if (wp->w_floating) {\n          continue;\n        }\n        if (wp->w_winrow < msg_scrolled) {\n          if (W_ENDROW(wp) > msg_scrolled\n              && wp->w_redr_type < REDRAW_TOP\n              && wp->w_lines_valid > 0\n              && wp->w_topline == wp->w_lines[0].wl_lnum) {\n            wp->w_upd_rows = msg_scrolled - wp->w_winrow;\n            wp->w_redr_type = REDRAW_TOP;\n          } else {\n            wp->w_redr_type = NOT_VALID;\n            if (W_ENDROW(wp) + wp->w_status_height\n                <= msg_scrolled) {\n              wp->w_redr_status = TRUE;\n            }\n          }\n        }\n      }\n      redraw_cmdline = true;\n      redraw_tabline = true;\n    }\n    msg_scrolled = 0;\n    msg_scrolled_at_flush = 0;\n    need_wait_return = false;\n  }\n\n  win_ui_flush();\n  msg_ext_check_clear();\n\n  // reset cmdline_row now (may have been changed temporarily)\n  compute_cmdrow();\n\n  // Check for changed highlighting\n  if (need_highlight_changed) {\n    highlight_changed();\n  }\n\n  if (type == CLEAR) {          // first clear screen\n    screenclear();              // will reset clear_cmdline\n    cmdline_screen_cleared();   // clear external cmdline state\n    type = NOT_VALID;\n    // must_redraw may be set indirectly, avoid another redraw later\n    must_redraw = 0;\n  } else if (!default_grid.valid) {\n    grid_invalidate(&default_grid);\n    default_grid.valid = true;\n  }\n\n  // After disabling msgsep the grid might not have been deallocated yet,\n  // hence we also need to check msg_grid.chars\n  if (type == NOT_VALID && (msg_use_grid() || msg_grid.chars)) {\n    grid_fill(&default_grid, Rows-p_ch, Rows, 0, Columns, ' ', ' ', 0);\n  }\n\n  ui_comp_set_screen_valid(true);\n\n  Providers providers;\n  kvi_init(providers);\n  for (size_t i = 0; i < kv_size(decor_providers); i++) {\n    DecorProvider *p = &kv_A(decor_providers, i);\n    if (!p->active) {\n      continue;\n    }\n\n    bool active;\n    if (p->redraw_start != LUA_NOREF) {\n      FIXED_TEMP_ARRAY(args, 2);\n      args.items[0] = INTEGER_OBJ(display_tick);\n      args.items[1] = INTEGER_OBJ(type);\n      active = provider_invoke(p->ns_id, \"start\", p->redraw_start, args, true);\n    } else {\n      active = true;\n    }\n\n    if (active) {\n      kvi_push(providers, p);\n    }\n  }\n\n  // \"start\" callback could have changed highlights for global elements\n  if (win_check_ns_hl(NULL)) {\n    redraw_cmdline = true;\n    redraw_tabline = true;\n  }\n\n  if (clear_cmdline) {          // going to clear cmdline (done below)\n    check_for_delay(FALSE);\n  }\n\n  /* Force redraw when width of 'number' or 'relativenumber' column\n   * changes. */\n  if (curwin->w_redr_type < NOT_VALID\n      && curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)\n                               ? number_width(curwin) : 0)) {\n    curwin->w_redr_type = NOT_VALID;\n  }\n\n  /*\n   * Only start redrawing if there is really something to do.\n   */\n  if (type == INVERTED) {\n    update_curswant();\n  }\n  if (curwin->w_redr_type < type\n      && !((type == VALID\n            && curwin->w_lines[0].wl_valid\n            && curwin->w_topfill == curwin->w_old_topfill\n            && curwin->w_botfill == curwin->w_old_botfill\n            && curwin->w_topline == curwin->w_lines[0].wl_lnum)\n           || (type == INVERTED\n               && VIsual_active\n               && curwin->w_old_cursor_lnum == curwin->w_cursor.lnum\n               && curwin->w_old_visual_mode == VIsual_mode\n               && (curwin->w_valid & VALID_VIRTCOL)\n               && curwin->w_old_curswant == curwin->w_curswant)\n           )) {\n    curwin->w_redr_type = type;\n  }\n\n  // Redraw the tab pages line if needed.\n  if (redraw_tabline || type >= NOT_VALID) {\n    update_window_hl(curwin, type >= NOT_VALID);\n    FOR_ALL_TABS(tp) {\n      if (tp != curtab) {\n        update_window_hl(tp->tp_curwin, type >= NOT_VALID);\n      }\n    }\n    draw_tabline();\n  }\n\n  /*\n   * Correct stored syntax highlighting info for changes in each displayed\n   * buffer.  Each buffer must only be done once.\n   */\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    update_window_hl(wp, type >= NOT_VALID);\n\n    buf_T *buf = wp->w_buffer;\n    if (buf->b_mod_set) {\n      if (buf->b_mod_tick_syn < display_tick\n          && syntax_present(wp)) {\n        syn_stack_apply_changes(buf);\n        buf->b_mod_tick_syn = display_tick;\n      }\n\n      if (buf->b_mod_tick_decor < display_tick) {\n        for (size_t i = 0; i < kv_size(providers); i++) {\n          DecorProvider *p = kv_A(providers, i);\n          if (p && p->redraw_buf != LUA_NOREF) {\n            FIXED_TEMP_ARRAY(args, 1);\n            args.items[0] = BUFFER_OBJ(buf->handle);\n            provider_invoke(p->ns_id, \"buf\", p->redraw_buf, args, true);\n          }\n        }\n        buf->b_mod_tick_decor = display_tick;\n      }\n    }\n  }\n\n  /*\n   * Go from top to bottom through the windows, redrawing the ones that need\n   * it.\n   */\n  bool did_one = false;\n  search_hl.rm.regprog = NULL;\n\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_redr_type == CLEAR && wp->w_floating && wp->w_grid_alloc.chars) {\n      grid_invalidate(&wp->w_grid_alloc);\n      wp->w_redr_type = NOT_VALID;\n    }\n\n    // reallocate grid if needed.\n    win_grid_alloc(wp);\n\n    if (wp->w_redr_border || wp->w_redr_type >= NOT_VALID) {\n      win_redr_border(wp);\n    }\n\n    if (wp->w_redr_type != 0) {\n      if (!did_one) {\n        did_one = true;\n        start_search_hl();\n      }\n      win_update(wp, &providers);\n    }\n\n    // redraw status line after the window to minimize cursor movement\n    if (wp->w_redr_status) {\n      win_redr_status(wp);\n    }\n  }\n\n  end_search_hl();\n\n  // May need to redraw the popup menu.\n  if (pum_drawn() && must_redraw_pum) {\n    pum_redraw();\n  }\n\n  send_grid_resize = false;\n\n  /* Reset b_mod_set flags.  Going through all windows is probably faster\n   * than going through all buffers (there could be many buffers). */\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    wp->w_buffer->b_mod_set = false;\n  }\n\n  updating_screen = 0;\n\n  /* Clear or redraw the command line.  Done last, because scrolling may\n   * mess up the command line. */\n  if (clear_cmdline || redraw_cmdline) {\n    showmode();\n  }\n\n  // May put up an introductory message when not editing a file\n  if (!did_intro) {\n    maybe_intro_message();\n  }\n  did_intro = true;\n\n  for (size_t i = 0; i < kv_size(providers); i++) {\n    DecorProvider *p = kv_A(providers, i);\n    if (!p->active) {\n      continue;\n    }\n\n    if (p->redraw_end != LUA_NOREF) {\n      FIXED_TEMP_ARRAY(args, 1);\n      args.items[0] = INTEGER_OBJ(display_tick);\n      provider_invoke(p->ns_id, \"end\", p->redraw_end, args, true);\n    }\n  }\n  kvi_destroy(providers);\n\n\n  // either cmdline is cleared, not drawn or mode is last drawn\n  cmdline_was_last_drawn = false;\n  return OK;\n}\n\n// Return true if the cursor line in window \"wp\" may be concealed, according\n// to the 'concealcursor' option.\nbool conceal_cursor_line(const win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int c;\n\n  if (*wp->w_p_cocu == NUL) {\n    return false;\n  }\n  if (get_real_state() & VISUAL) {\n    c = 'v';\n  } else if (State & INSERT) {\n    c = 'i';\n  } else if (State & NORMAL) {\n    c = 'n';\n  } else if (State & CMDLINE) {\n    c = 'c';\n  } else {\n    return false;\n  }\n  return vim_strchr(wp->w_p_cocu, c) != NULL;\n}\n\n// Check if the cursor line needs to be redrawn because of 'concealcursor'.\n//\n// When cursor is moved at the same time, both lines will be redrawn regardless.\nvoid conceal_check_cursor_line(void)\n{\n  bool should_conceal = conceal_cursor_line(curwin);\n  if (curwin->w_p_cole > 0 && (conceal_cursor_used != should_conceal)) {\n    redrawWinline(curwin, curwin->w_cursor.lnum);\n    // Need to recompute cursor column, e.g., when starting Visual mode\n    // without concealing. */\n    curs_columns(curwin, true);\n  }\n}\n\n/// Whether cursorline is drawn in a special way\n///\n/// If true, both old and new cursorline will need\n/// to be redrawn when moving cursor within windows.\n/// TODO(bfredl): VIsual_active shouldn't be needed, but is used to fix a glitch\n///               caused by scrolling.\nbool win_cursorline_standout(const win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return wp->w_p_cul\n         || (wp->w_p_cole > 0 && (VIsual_active || !conceal_cursor_line(wp)));\n}\n\n/*\n * Update a single window.\n *\n * This may cause the windows below it also to be redrawn (when clearing the\n * screen or scrolling lines).\n *\n * How the window is redrawn depends on wp->w_redr_type.  Each type also\n * implies the one below it.\n * NOT_VALID    redraw the whole window\n * SOME_VALID   redraw the whole window but do scroll when possible\n * REDRAW_TOP   redraw the top w_upd_rows window lines, otherwise like VALID\n * INVERTED     redraw the changed part of the Visual area\n * INVERTED_ALL redraw the whole Visual area\n * VALID        1. scroll up/down to adjust for a changed w_topline\n *              2. update lines at the top when scrolled down\n *              3. redraw changed text:\n *                 - if wp->w_buffer->b_mod_set set, update lines between\n *                   b_mod_top and b_mod_bot.\n *                 - if wp->w_redraw_top non-zero, redraw lines between\n *                   wp->w_redraw_top and wp->w_redr_bot.\n *                 - continue redrawing when syntax status is invalid.\n *              4. if scrolled up, update lines at the bottom.\n * This results in three areas that may need updating:\n * top: from first row to top_end (when scrolled down)\n * mid: from mid_start to mid_end (update inversion or changed text)\n * bot: from bot_start to last row (when scrolled up)\n */\nstatic void win_update(win_T *wp, Providers *providers)\n{\n  buf_T       *buf = wp->w_buffer;\n  int type;\n  int top_end = 0;              /* Below last row of the top area that needs\n                                   updating.  0 when no top area updating. */\n  int mid_start = 999;          /* first row of the mid area that needs\n                                   updating.  999 when no mid area updating. */\n  int mid_end = 0;              /* Below last row of the mid area that needs\n                                   updating.  0 when no mid area updating. */\n  int bot_start = 999;          /* first row of the bot area that needs\n                                   updating.  999 when no bot area updating */\n  bool scrolled_down = false;   // true when scrolled down when w_topline got smaller a bit\n  bool top_to_mod = false;      // redraw above mod_top\n\n  int row;                      // current window row to display\n  linenr_T lnum;                // current buffer lnum to display\n  int idx;                      // current index in w_lines[]\n  int srow;                     // starting row of the current line\n\n  bool eof = false;             // if true, we hit the end of the file\n  bool didline = false;         // if true, we finished the last line\n  int i;\n  long j;\n  static bool recursive = false;  // being called recursively\n  const linenr_T old_botline = wp->w_botline;\n  const int old_wrow = wp->w_wrow;\n  const int old_wcol = wp->w_wcol;\n  // Remember what happened to the previous line.\n#define DID_NONE 1      // didn't update a line\n#define DID_LINE 2      // updated a normal line\n#define DID_FOLD 3      // updated a folded line\n  int did_update = DID_NONE;\n  linenr_T syntax_last_parsed = 0;              // last parsed text line\n  linenr_T mod_top = 0;\n  linenr_T mod_bot = 0;\n  int save_got_int;\n\n\n  // If we can compute a change in the automatic sizing of the sign column\n  // under 'signcolumn=auto:X' and signs currently placed in the buffer, better\n  // figuring it out here so we can redraw the entire screen for it.\n  buf_signcols(buf);\n\n  type = wp->w_redr_type;\n\n  if (type >= NOT_VALID) {\n    wp->w_redr_status = true;\n    wp->w_lines_valid = 0;\n  }\n\n  // Window is zero-height: nothing to draw.\n  if (wp->w_grid.Rows == 0) {\n    wp->w_redr_type = 0;\n    return;\n  }\n\n  // Window is zero-width: Only need to draw the separator.\n  if (wp->w_grid.Columns == 0) {\n    // draw the vertical separator right of this window\n    draw_vsep_win(wp, 0);\n    wp->w_redr_type = 0;\n    return;\n  }\n\n  init_search_hl(wp);\n\n  /* Force redraw when width of 'number' or 'relativenumber' column\n   * changes. */\n  i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;\n  if (wp->w_nrwidth != i) {\n    type = NOT_VALID;\n    wp->w_nrwidth = i;\n\n    if (buf->terminal) {\n      terminal_check_size(buf->terminal);\n    }\n  } else if (buf->b_mod_set\n             && buf->b_mod_xlines != 0\n             && wp->w_redraw_top != 0) {\n    // When there are both inserted/deleted lines and specific lines to be\n    // redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw\n    // everything (only happens when redrawing is off for while).\n    type = NOT_VALID;\n  } else {\n    /*\n     * Set mod_top to the first line that needs displaying because of\n     * changes.  Set mod_bot to the first line after the changes.\n     */\n    mod_top = wp->w_redraw_top;\n    if (wp->w_redraw_bot != 0) {\n      mod_bot = wp->w_redraw_bot + 1;\n    } else {\n      mod_bot = 0;\n    }\n    if (buf->b_mod_set) {\n      if (mod_top == 0 || mod_top > buf->b_mod_top) {\n        mod_top = buf->b_mod_top;\n        /* Need to redraw lines above the change that may be included\n         * in a pattern match. */\n        if (syntax_present(wp)) {\n          mod_top -= buf->b_s.b_syn_sync_linebreaks;\n          if (mod_top < 1) {\n            mod_top = 1;\n          }\n        }\n      }\n      if (mod_bot == 0 || mod_bot < buf->b_mod_bot) {\n        mod_bot = buf->b_mod_bot;\n      }\n\n      // When 'hlsearch' is on and using a multi-line search pattern, a\n      // change in one line may make the Search highlighting in a\n      // previous line invalid.  Simple solution: redraw all visible\n      // lines above the change.\n      // Same for a match pattern.\n      if (search_hl.rm.regprog != NULL\n          && re_multiline(search_hl.rm.regprog)) {\n        top_to_mod = true;\n      } else {\n        const matchitem_T *cur = wp->w_match_head;\n        while (cur != NULL) {\n          if (cur->match.regprog != NULL\n              && re_multiline(cur->match.regprog)) {\n            top_to_mod = true;\n            break;\n          }\n          cur = cur->next;\n        }\n      }\n    }\n    if (mod_top != 0 && hasAnyFolding(wp)) {\n      linenr_T lnumt, lnumb;\n\n      /*\n       * A change in a line can cause lines above it to become folded or\n       * unfolded.  Find the top most buffer line that may be affected.\n       * If the line was previously folded and displayed, get the first\n       * line of that fold.  If the line is folded now, get the first\n       * folded line.  Use the minimum of these two.\n       */\n\n      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to\n       * the line below it.  If there is no valid entry, use w_topline.\n       * Find the first valid w_lines[] entry below mod_bot.  Set lnumb\n       * to this line.  If there is no valid entry, use MAXLNUM. */\n      lnumt = wp->w_topline;\n      lnumb = MAXLNUM;\n      for (i = 0; i < wp->w_lines_valid; ++i) {\n        if (wp->w_lines[i].wl_valid) {\n          if (wp->w_lines[i].wl_lastlnum < mod_top) {\n            lnumt = wp->w_lines[i].wl_lastlnum + 1;\n          }\n          if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot) {\n            lnumb = wp->w_lines[i].wl_lnum;\n            // When there is a fold column it might need updating\n            // in the next line (\"J\" just above an open fold).\n            if (compute_foldcolumn(wp, 0) > 0) {\n              lnumb++;\n            }\n          }\n        }\n      }\n\n      (void)hasFoldingWin(wp, mod_top, &mod_top, NULL, true, NULL);\n      if (mod_top > lnumt) {\n        mod_top = lnumt;\n      }\n\n      // Now do the same for the bottom line (one above mod_bot).\n      mod_bot--;\n      (void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, true, NULL);\n      mod_bot++;\n      if (mod_bot < lnumb) {\n        mod_bot = lnumb;\n      }\n    }\n\n    /* When a change starts above w_topline and the end is below\n     * w_topline, start redrawing at w_topline.\n     * If the end of the change is above w_topline: do like no change was\n     * made, but redraw the first line to find changes in syntax. */\n    if (mod_top != 0 && mod_top < wp->w_topline) {\n      if (mod_bot > wp->w_topline) {\n        mod_top = wp->w_topline;\n      } else if (syntax_present(wp)) {\n        top_end = 1;\n      }\n    }\n\n    /* When line numbers are displayed need to redraw all lines below\n     * inserted/deleted lines. */\n    if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu) {\n      mod_bot = MAXLNUM;\n    }\n  }\n  wp->w_redraw_top = 0;  // reset for next time\n  wp->w_redraw_bot = 0;\n\n  /*\n   * When only displaying the lines at the top, set top_end.  Used when\n   * window has scrolled down for msg_scrolled.\n   */\n  if (type == REDRAW_TOP) {\n    j = 0;\n    for (i = 0; i < wp->w_lines_valid; ++i) {\n      j += wp->w_lines[i].wl_size;\n      if (j >= wp->w_upd_rows) {\n        top_end = j;\n        break;\n      }\n    }\n    if (top_end == 0) {\n      // not found (cannot happen?): redraw everything\n      type = NOT_VALID;\n    } else {\n      // top area defined, the rest is VALID\n      type = VALID;\n    }\n  }\n\n  /*\n   * If there are no changes on the screen that require a complete redraw,\n   * handle three cases:\n   * 1: we are off the top of the screen by a few lines: scroll down\n   * 2: wp->w_topline is below wp->w_lines[0].wl_lnum: may scroll up\n   * 3: wp->w_topline is wp->w_lines[0].wl_lnum: find first entry in\n   *    w_lines[] that needs updating.\n   */\n  if ((type == VALID || type == SOME_VALID\n       || type == INVERTED || type == INVERTED_ALL)\n      && !wp->w_botfill && !wp->w_old_botfill) {\n    if (mod_top != 0\n        && wp->w_topline == mod_top\n        && (!wp->w_lines[0].wl_valid\n            || wp->w_topline <= wp->w_lines[0].wl_lnum)) {\n      // w_topline is the first changed line and window is not scrolled,\n      // the scrolling from changed lines will be done further down.\n    } else if (wp->w_lines[0].wl_valid\n               && (wp->w_topline < wp->w_lines[0].wl_lnum\n                   || (wp->w_topline == wp->w_lines[0].wl_lnum\n                       && wp->w_topfill > wp->w_old_topfill)\n                   )) {\n      /*\n       * New topline is above old topline: May scroll down.\n       */\n      if (hasAnyFolding(wp)) {\n        linenr_T ln;\n\n        /* count the number of lines we are off, counting a sequence\n         * of folded lines as one */\n        j = 0;\n        for (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ln++) {\n          j++;\n          if (j >= wp->w_grid.Rows - 2) {\n            break;\n          }\n          (void)hasFoldingWin(wp, ln, NULL, &ln, true, NULL);\n        }\n      } else {\n        j = wp->w_lines[0].wl_lnum - wp->w_topline;\n      }\n      if (j < wp->w_grid.Rows - 2) {               // not too far off\n        i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);\n        // insert extra lines for previously invisible filler lines\n        if (wp->w_lines[0].wl_lnum != wp->w_topline) {\n          i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)\n               - wp->w_old_topfill;\n        }\n        if (i != 0 && i < wp->w_grid.Rows - 2) {  // less than a screen off\n          // Try to insert the correct number of lines.\n          // If not the last window, delete the lines at the bottom.\n          // win_ins_lines may fail when the terminal can't do it.\n          win_scroll_lines(wp, 0, i);\n          if (wp->w_lines_valid != 0) {\n            // Need to update rows that are new, stop at the\n            // first one that scrolled down.\n            top_end = i;\n            scrolled_down = true;\n\n            // Move the entries that were scrolled, disable\n            // the entries for the lines to be redrawn.\n            if ((wp->w_lines_valid += j) > wp->w_grid.Rows) {\n              wp->w_lines_valid = wp->w_grid.Rows;\n            }\n            for (idx = wp->w_lines_valid; idx - j >= 0; idx--) {\n              wp->w_lines[idx] = wp->w_lines[idx - j];\n            }\n            while (idx >= 0) {\n              wp->w_lines[idx--].wl_valid = false;\n            }\n          }\n        } else {\n          mid_start = 0;  // redraw all lines\n        }\n      } else {\n        mid_start = 0;  // redraw all lines\n      }\n    } else {\n      /*\n       * New topline is at or below old topline: May scroll up.\n       * When topline didn't change, find first entry in w_lines[] that\n       * needs updating.\n       */\n\n      // try to find wp->w_topline in wp->w_lines[].wl_lnum\n      j = -1;\n      row = 0;\n      for (i = 0; i < wp->w_lines_valid; i++) {\n        if (wp->w_lines[i].wl_valid\n            && wp->w_lines[i].wl_lnum == wp->w_topline) {\n          j = i;\n          break;\n        }\n        row += wp->w_lines[i].wl_size;\n      }\n      if (j == -1) {\n        /* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all\n         * lines */\n        mid_start = 0;\n      } else {\n        /*\n         * Try to delete the correct number of lines.\n         * wp->w_topline is at wp->w_lines[i].wl_lnum.\n         */\n        /* If the topline didn't change, delete old filler lines,\n         * otherwise delete filler lines of the new topline... */\n        if (wp->w_lines[0].wl_lnum == wp->w_topline) {\n          row += wp->w_old_topfill;\n        } else {\n          row += diff_check_fill(wp, wp->w_topline);\n        }\n        // ... but don't delete new filler lines.\n        row -= wp->w_topfill;\n        if (row > 0) {\n          win_scroll_lines(wp, 0, -row);\n          bot_start = wp->w_grid.Rows - row;\n        }\n        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {\n          /*\n           * Skip the lines (below the deleted lines) that are still\n           * valid and don't need redrawing.    Copy their info\n           * upwards, to compensate for the deleted lines.  Set\n           * bot_start to the first row that needs redrawing.\n           */\n          bot_start = 0;\n          idx = 0;\n          for (;; ) {\n            wp->w_lines[idx] = wp->w_lines[j];\n            /* stop at line that didn't fit, unless it is still\n             * valid (no lines deleted) */\n            if (row > 0 && bot_start + row\n                + (int)wp->w_lines[j].wl_size > wp->w_grid.Rows) {\n              wp->w_lines_valid = idx + 1;\n              break;\n            }\n            bot_start += wp->w_lines[idx++].wl_size;\n\n            // stop at the last valid entry in w_lines[].wl_size\n            if (++j >= wp->w_lines_valid) {\n              wp->w_lines_valid = idx;\n              break;\n            }\n          }\n          /* Correct the first entry for filler lines at the top\n           * when it won't get updated below. */\n          if (wp->w_p_diff && bot_start > 0) {\n            wp->w_lines[0].wl_size =\n              plines_win_nofill(wp, wp->w_topline, true)\n              + wp->w_topfill;\n          }\n        }\n      }\n    }\n\n    // When starting redraw in the first line, redraw all lines.\n    if (mid_start == 0) {\n      mid_end = wp->w_grid.Rows;\n    }\n  } else {\n    // Not VALID or INVERTED: redraw all lines.\n    mid_start = 0;\n    mid_end = wp->w_grid.Rows;\n  }\n\n  if (type == SOME_VALID) {\n    // SOME_VALID: redraw all lines.\n    mid_start = 0;\n    mid_end = wp->w_grid.Rows;\n    type = NOT_VALID;\n  }\n\n  // check if we are updating or removing the inverted part\n  if ((VIsual_active && buf == curwin->w_buffer)\n      || (wp->w_old_cursor_lnum != 0 && type != NOT_VALID)) {\n    linenr_T from, to;\n\n    if (VIsual_active) {\n      if (VIsual_mode != wp->w_old_visual_mode || type == INVERTED_ALL) {\n        // If the type of Visual selection changed, redraw the whole\n        // selection.  Also when the ownership of the X selection is\n        // gained or lost.\n        if (curwin->w_cursor.lnum < VIsual.lnum) {\n          from = curwin->w_cursor.lnum;\n          to = VIsual.lnum;\n        } else {\n          from = VIsual.lnum;\n          to = curwin->w_cursor.lnum;\n        }\n        // redraw more when the cursor moved as well\n        if (wp->w_old_cursor_lnum < from) {\n          from = wp->w_old_cursor_lnum;\n        }\n        if (wp->w_old_cursor_lnum > to) {\n          to = wp->w_old_cursor_lnum;\n        }\n        if (wp->w_old_visual_lnum < from) {\n          from = wp->w_old_visual_lnum;\n        }\n        if (wp->w_old_visual_lnum > to) {\n          to = wp->w_old_visual_lnum;\n        }\n      } else {\n        /*\n         * Find the line numbers that need to be updated: The lines\n         * between the old cursor position and the current cursor\n         * position.  Also check if the Visual position changed.\n         */\n        if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum) {\n          from = curwin->w_cursor.lnum;\n          to = wp->w_old_cursor_lnum;\n        } else {\n          from = wp->w_old_cursor_lnum;\n          to = curwin->w_cursor.lnum;\n          if (from == 0) {              // Visual mode just started\n            from = to;\n          }\n        }\n\n        if (VIsual.lnum != wp->w_old_visual_lnum\n            || VIsual.col != wp->w_old_visual_col) {\n          if (wp->w_old_visual_lnum < from\n              && wp->w_old_visual_lnum != 0) {\n            from = wp->w_old_visual_lnum;\n          }\n          if (wp->w_old_visual_lnum > to) {\n            to = wp->w_old_visual_lnum;\n          }\n          if (VIsual.lnum < from) {\n            from = VIsual.lnum;\n          }\n          if (VIsual.lnum > to) {\n            to = VIsual.lnum;\n          }\n        }\n      }\n\n      /*\n       * If in block mode and changed column or curwin->w_curswant:\n       * update all lines.\n       * First compute the actual start and end column.\n       */\n      if (VIsual_mode == Ctrl_V) {\n        colnr_T fromc, toc;\n        int save_ve_flags = ve_flags;\n\n        if (curwin->w_p_lbr) {\n          ve_flags = VE_ALL;\n        }\n\n        getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);\n        ve_flags = save_ve_flags;\n        toc++;\n        // Highlight to the end of the line, unless 'virtualedit' has\n        // \"block\".\n        if (curwin->w_curswant == MAXCOL && !(ve_flags & VE_BLOCK)) {\n          toc = MAXCOL;\n        }\n\n        if (fromc != wp->w_old_cursor_fcol\n            || toc != wp->w_old_cursor_lcol) {\n          if (from > VIsual.lnum) {\n            from = VIsual.lnum;\n          }\n          if (to < VIsual.lnum) {\n            to = VIsual.lnum;\n          }\n        }\n        wp->w_old_cursor_fcol = fromc;\n        wp->w_old_cursor_lcol = toc;\n      }\n    } else {\n      // Use the line numbers of the old Visual area.\n      if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum) {\n        from = wp->w_old_cursor_lnum;\n        to = wp->w_old_visual_lnum;\n      } else {\n        from = wp->w_old_visual_lnum;\n        to = wp->w_old_cursor_lnum;\n      }\n    }\n\n    /*\n     * There is no need to update lines above the top of the window.\n     */\n    if (from < wp->w_topline) {\n      from = wp->w_topline;\n    }\n\n    /*\n     * If we know the value of w_botline, use it to restrict the update to\n     * the lines that are visible in the window.\n     */\n    if (wp->w_valid & VALID_BOTLINE) {\n      if (from >= wp->w_botline) {\n        from = wp->w_botline - 1;\n      }\n      if (to >= wp->w_botline) {\n        to = wp->w_botline - 1;\n      }\n    }\n\n    /*\n     * Find the minimal part to be updated.\n     * Watch out for scrolling that made entries in w_lines[] invalid.\n     * E.g., CTRL-U makes the first half of w_lines[] invalid and sets\n     * top_end; need to redraw from top_end to the \"to\" line.\n     * A middle mouse click with a Visual selection may change the text\n     * above the Visual area and reset wl_valid, do count these for\n     * mid_end (in srow).\n     */\n    if (mid_start > 0) {\n      lnum = wp->w_topline;\n      idx = 0;\n      srow = 0;\n      if (scrolled_down) {\n        mid_start = top_end;\n      } else {\n        mid_start = 0;\n      }\n      while (lnum < from && idx < wp->w_lines_valid) {          // find start\n        if (wp->w_lines[idx].wl_valid) {\n          mid_start += wp->w_lines[idx].wl_size;\n        } else if (!scrolled_down) {\n          srow += wp->w_lines[idx].wl_size;\n        }\n        ++idx;\n        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid) {\n          lnum = wp->w_lines[idx].wl_lnum;\n        } else {\n          ++lnum;\n        }\n      }\n      srow += mid_start;\n      mid_end = wp->w_grid.Rows;\n      for (; idx < wp->w_lines_valid; idx++) {                  // find end\n        if (wp->w_lines[idx].wl_valid\n            && wp->w_lines[idx].wl_lnum >= to + 1) {\n          // Only update until first row of this line\n          mid_end = srow;\n          break;\n        }\n        srow += wp->w_lines[idx].wl_size;\n      }\n    }\n  }\n\n  if (VIsual_active && buf == curwin->w_buffer) {\n    wp->w_old_visual_mode = VIsual_mode;\n    wp->w_old_cursor_lnum = curwin->w_cursor.lnum;\n    wp->w_old_visual_lnum = VIsual.lnum;\n    wp->w_old_visual_col = VIsual.col;\n    wp->w_old_curswant = curwin->w_curswant;\n  } else {\n    wp->w_old_visual_mode = 0;\n    wp->w_old_cursor_lnum = 0;\n    wp->w_old_visual_lnum = 0;\n    wp->w_old_visual_col = 0;\n  }\n\n  // reset got_int, otherwise regexp won't work\n  save_got_int = got_int;\n  got_int = 0;\n  // Set the time limit to 'redrawtime'.\n  proftime_T syntax_tm = profile_setlimit(p_rdt);\n  syn_set_timeout(&syntax_tm);\n\n  /*\n   * Update all the window rows.\n   */\n  idx = 0;              // first entry in w_lines[].wl_size\n  row = 0;\n  srow = 0;\n  lnum = wp->w_topline;  // first line shown in window\n\n  decor_redraw_reset(buf, &decor_state);\n\n  Providers line_providers;\n  kvi_init(line_providers);\n\n  linenr_T knownmax = ((wp->w_valid & VALID_BOTLINE)\n                       ? wp->w_botline\n                       : (wp->w_topline + wp->w_height_inner));\n\n  for (size_t k = 0; k < kv_size(*providers); k++) {\n    DecorProvider *p = kv_A(*providers, k);\n    if (p && p->redraw_win != LUA_NOREF) {\n      FIXED_TEMP_ARRAY(args, 4);\n      args.items[0] = WINDOW_OBJ(wp->handle);\n      args.items[1] = BUFFER_OBJ(buf->handle);\n      // TODO(bfredl): we are not using this, but should be first drawn line?\n      args.items[2] = INTEGER_OBJ(wp->w_topline-1);\n      args.items[3] = INTEGER_OBJ(knownmax);\n      if (provider_invoke(p->ns_id, \"win\", p->redraw_win, args, true)) {\n        kvi_push(line_providers, p);\n      }\n    }\n  }\n\n  win_check_ns_hl(wp);\n\n\n  for (;; ) {\n    /* stop updating when reached the end of the window (check for _past_\n     * the end of the window is at the end of the loop) */\n    if (row == wp->w_grid.Rows) {\n      didline = true;\n      break;\n    }\n\n    // stop updating when hit the end of the file\n    if (lnum > buf->b_ml.ml_line_count) {\n      eof = true;\n      break;\n    }\n\n    /* Remember the starting row of the line that is going to be dealt\n     * with.  It is used further down when the line doesn't fit. */\n    srow = row;\n\n    // Update a line when it is in an area that needs updating, when it\n    // has changes or w_lines[idx] is invalid.\n    // \"bot_start\" may be halfway a wrapped line after using\n    // win_scroll_lines(), check if the current line includes it.\n    // When syntax folding is being used, the saved syntax states will\n    // already have been updated, we can't see where the syntax state is\n    // the same again, just update until the end of the window.\n    if (row < top_end\n        || (row >= mid_start && row < mid_end)\n        || top_to_mod\n        || idx >= wp->w_lines_valid\n        || (row + wp->w_lines[idx].wl_size > bot_start)\n        || (mod_top != 0\n            && (lnum == mod_top\n                || (lnum >= mod_top\n                    && (lnum < mod_bot\n                        || did_update == DID_FOLD\n                        || (did_update == DID_LINE\n                            && syntax_present(wp)\n                            && ((foldmethodIsSyntax(wp)\n                                 && hasAnyFolding(wp))\n                                || syntax_check_changed(lnum)))\n                        // match in fixed position might need redraw\n                        // if lines were inserted or deleted\n                        || (wp->w_match_head != NULL\n                            && buf->b_mod_xlines != 0)))))\n        || (wp->w_p_cul && (lnum == wp->w_cursor.lnum\n                            || lnum == wp->w_last_cursorline))) {\n      if (lnum == mod_top) {\n        top_to_mod = false;\n      }\n\n      /*\n       * When at start of changed lines: May scroll following lines\n       * up or down to minimize redrawing.\n       * Don't do this when the change continues until the end.\n       * Don't scroll when dollar_vcol >= 0, keep the \"$\".\n       * Don't scroll when redrawing the top, scrolled already above.\n       */\n      if (lnum == mod_top\n          && mod_bot != MAXLNUM\n          && !(dollar_vcol >= 0 && mod_bot == mod_top + 1)\n          && row >= top_end) {\n        int old_rows = 0;\n        int new_rows = 0;\n        int xtra_rows;\n        linenr_T l;\n\n        /* Count the old number of window rows, using w_lines[], which\n         * should still contain the sizes for the lines as they are\n         * currently displayed. */\n        for (i = idx; i < wp->w_lines_valid; ++i) {\n          /* Only valid lines have a meaningful wl_lnum.  Invalid\n           * lines are part of the changed area. */\n          if (wp->w_lines[i].wl_valid\n              && wp->w_lines[i].wl_lnum == mod_bot) {\n            break;\n          }\n          old_rows += wp->w_lines[i].wl_size;\n          if (wp->w_lines[i].wl_valid\n              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {\n            /* Must have found the last valid entry above mod_bot.\n             * Add following invalid entries. */\n            ++i;\n            while (i < wp->w_lines_valid\n                   && !wp->w_lines[i].wl_valid) {\n              old_rows += wp->w_lines[i++].wl_size;\n            }\n            break;\n          }\n        }\n\n        if (i >= wp->w_lines_valid) {\n          /* We can't find a valid line below the changed lines,\n           * need to redraw until the end of the window.\n           * Inserting/deleting lines has no use. */\n          bot_start = 0;\n        } else {\n          /* Able to count old number of rows: Count new window\n           * rows, and may insert/delete lines */\n          j = idx;\n          for (l = lnum; l < mod_bot; l++) {\n            if (hasFoldingWin(wp, l, NULL, &l, true, NULL)) {\n              new_rows++;\n            } else if (l == wp->w_topline) {\n              new_rows += plines_win_nofill(wp, l, true) + wp->w_topfill;\n            } else {\n              new_rows += plines_win(wp, l, true);\n            }\n            j++;\n            if (new_rows > wp->w_grid.Rows - row - 2) {\n              // it's getting too much, must redraw the rest\n              new_rows = 9999;\n              break;\n            }\n          }\n          xtra_rows = new_rows - old_rows;\n          if (xtra_rows < 0) {\n            /* May scroll text up.  If there is not enough\n             * remaining text or scrolling fails, must redraw the\n             * rest.  If scrolling works, must redraw the text\n             * below the scrolled text. */\n            if (row - xtra_rows >= wp->w_grid.Rows - 2) {\n              mod_bot = MAXLNUM;\n            } else {\n              win_scroll_lines(wp, row, xtra_rows);\n              bot_start = wp->w_grid.Rows + xtra_rows;\n            }\n          } else if (xtra_rows > 0) {\n            /* May scroll text down.  If there is not enough\n             * remaining text of scrolling fails, must redraw the\n             * rest. */\n            if (row + xtra_rows >= wp->w_grid.Rows - 2) {\n              mod_bot = MAXLNUM;\n            } else {\n              win_scroll_lines(wp, row + old_rows, xtra_rows);\n              if (top_end > row + old_rows) {\n                // Scrolled the part at the top that requires\n                // updating down.\n                top_end += xtra_rows;\n              }\n            }\n          }\n\n          /* When not updating the rest, may need to move w_lines[]\n           * entries. */\n          if (mod_bot != MAXLNUM && i != j) {\n            if (j < i) {\n              int x = row + new_rows;\n\n              // move entries in w_lines[] upwards\n              for (;; ) {\n                // stop at last valid entry in w_lines[]\n                if (i >= wp->w_lines_valid) {\n                  wp->w_lines_valid = j;\n                  break;\n                }\n                wp->w_lines[j] = wp->w_lines[i];\n                // stop at a line that won't fit\n                if (x + (int)wp->w_lines[j].wl_size\n                    > wp->w_grid.Rows) {\n                  wp->w_lines_valid = j + 1;\n                  break;\n                }\n                x += wp->w_lines[j++].wl_size;\n                ++i;\n              }\n              if (bot_start > x) {\n                bot_start = x;\n              }\n            } else {       // j > i\n                           // move entries in w_lines[] downwards\n              j -= i;\n              wp->w_lines_valid += j;\n              if (wp->w_lines_valid > wp->w_grid.Rows) {\n                wp->w_lines_valid = wp->w_grid.Rows;\n              }\n              for (i = wp->w_lines_valid; i - j >= idx; i--) {\n                wp->w_lines[i] = wp->w_lines[i - j];\n              }\n\n              /* The w_lines[] entries for inserted lines are\n               * now invalid, but wl_size may be used above.\n               * Reset to zero. */\n              while (i >= idx) {\n                wp->w_lines[i].wl_size = 0;\n                wp->w_lines[i--].wl_valid = FALSE;\n              }\n            }\n          }\n        }\n      }\n\n      /*\n       * When lines are folded, display one line for all of them.\n       * Otherwise, display normally (can be several display lines when\n       * 'wrap' is on).\n       */\n      foldinfo_T foldinfo = fold_info(wp, lnum);\n\n      if (foldinfo.fi_lines == 0\n          && idx < wp->w_lines_valid\n          && wp->w_lines[idx].wl_valid\n          && wp->w_lines[idx].wl_lnum == lnum\n          && lnum > wp->w_topline\n          && !(dy_flags & (DY_LASTLINE | DY_TRUNCATE))\n          && srow + wp->w_lines[idx].wl_size > wp->w_grid.Rows\n          && diff_check_fill(wp, lnum) == 0) {\n        // This line is not going to fit.  Don't draw anything here,\n        // will draw \"@  \" lines below.\n        row = wp->w_grid.Rows + 1;\n      } else {\n        prepare_search_hl(wp, lnum);\n        // Let the syntax stuff know we skipped a few lines.\n        if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum\n            && syntax_present(wp)) {\n          syntax_end_parsing(syntax_last_parsed + 1);\n        }\n\n        // Display one line\n        row = win_line(wp, lnum, srow,\n                       foldinfo.fi_lines ? srow : wp->w_grid.Rows,\n                       mod_top == 0, false, foldinfo, &line_providers);\n\n        wp->w_lines[idx].wl_folded = foldinfo.fi_lines != 0;\n        wp->w_lines[idx].wl_lastlnum = lnum;\n        did_update = DID_LINE;\n\n        if (foldinfo.fi_lines > 0) {\n          did_update = DID_FOLD;\n          foldinfo.fi_lines--;\n          wp->w_lines[idx].wl_lastlnum = lnum + foldinfo.fi_lines;\n        }\n\n        syntax_last_parsed = lnum;\n      }\n\n      wp->w_lines[idx].wl_lnum = lnum;\n      wp->w_lines[idx].wl_valid = true;\n\n      if (row > wp->w_grid.Rows) {         // past end of grid\n        // we may need the size of that too long line later on\n        if (dollar_vcol == -1) {\n          wp->w_lines[idx].wl_size = plines_win(wp, lnum, true);\n        }\n        idx++;\n        break;\n      }\n      if (dollar_vcol == -1) {\n        wp->w_lines[idx].wl_size = row - srow;\n      }\n      idx++;\n      lnum += foldinfo.fi_lines + 1;\n    } else {\n      if (wp->w_p_rnu) {\n        // 'relativenumber' set: The text doesn't need to be drawn, but\n        // the number column nearly always does.\n        foldinfo_T info = fold_info(wp, lnum);\n        (void)win_line(wp, lnum, srow, wp->w_grid.Rows, true, true,\n                       info, &line_providers);\n      }\n\n      // This line does not need to be drawn, advance to the next one.\n      row += wp->w_lines[idx++].wl_size;\n      if (row > wp->w_grid.Rows) {  // past end of screen\n        break;\n      }\n      lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;\n      did_update = DID_NONE;\n    }\n\n    if (lnum > buf->b_ml.ml_line_count) {\n      eof = true;\n      break;\n    }\n  }\n  /*\n   * End of loop over all window lines.\n   */\n\n\n  if (idx > wp->w_lines_valid) {\n    wp->w_lines_valid = idx;\n  }\n\n  /*\n   * Let the syntax stuff know we stop parsing here.\n   */\n  if (syntax_last_parsed != 0 && syntax_present(wp)) {\n    syntax_end_parsing(syntax_last_parsed + 1);\n  }\n\n  /*\n   * If we didn't hit the end of the file, and we didn't finish the last\n   * line we were working on, then the line didn't fit.\n   */\n  wp->w_empty_rows = 0;\n  wp->w_filler_rows = 0;\n  if (!eof && !didline) {\n    int at_attr = hl_combine_attr(wp->w_hl_attr_normal,\n                                  win_hl_attr(wp, HLF_AT));\n    if (lnum == wp->w_topline) {\n      /*\n       * Single line that does not fit!\n       * Don't overwrite it, it can be edited.\n       */\n      wp->w_botline = lnum + 1;\n    } else if (diff_check_fill(wp, lnum) >= wp->w_grid.Rows - srow) {\n      // Window ends in filler lines.\n      wp->w_botline = lnum;\n      wp->w_filler_rows = wp->w_grid.Rows - srow;\n    } else if (dy_flags & DY_TRUNCATE) {      // 'display' has \"truncate\"\n      int scr_row = wp->w_grid.Rows - 1;\n\n      // Last line isn't finished: Display \"@@@\" in the last screen line.\n      grid_puts_len(&wp->w_grid, (char_u *)\"@@\", 2, scr_row, 0, at_attr);\n\n      grid_fill(&wp->w_grid, scr_row, scr_row + 1, 2, wp->w_grid.Columns,\n                '@', ' ', at_attr);\n      set_empty_rows(wp, srow);\n      wp->w_botline = lnum;\n    } else if (dy_flags & DY_LASTLINE) {      // 'display' has \"lastline\"\n      // Last line isn't finished: Display \"@@@\" at the end.\n      grid_fill(&wp->w_grid, wp->w_grid.Rows - 1, wp->w_grid.Rows,\n                wp->w_grid.Columns - 3, wp->w_grid.Columns, '@', '@', at_attr);\n      set_empty_rows(wp, srow);\n      wp->w_botline = lnum;\n    } else {\n      win_draw_end(wp, '@', ' ', true, srow, wp->w_grid.Rows, HLF_AT);\n      wp->w_botline = lnum;\n    }\n  } else {\n    if (eof) {  // we hit the end of the file\n      wp->w_botline = buf->b_ml.ml_line_count + 1;\n      j = diff_check_fill(wp, wp->w_botline);\n      if (j > 0 && !wp->w_botfill) {\n        // display filler lines at the end of the file\n        if (char2cells(wp->w_p_fcs_chars.diff) > 1) {\n          i = '-';\n        } else {\n          i = wp->w_p_fcs_chars.diff;\n        }\n        if (row + j > wp->w_grid.Rows) {\n          j = wp->w_grid.Rows - row;\n        }\n        win_draw_end(wp, i, i, true, row, row + (int)j, HLF_DED);\n        row += j;\n      }\n    } else if (dollar_vcol == -1) {\n      wp->w_botline = lnum;\n    }\n\n    // make sure the rest of the screen is blank\n    // write the 'eob' character to rows that aren't part of the file.\n    win_draw_end(wp, wp->w_p_fcs_chars.eob, ' ', false, row, wp->w_grid.Rows,\n                 HLF_EOB);\n  }\n\n  kvi_destroy(line_providers);\n\n  if (wp->w_redr_type >= REDRAW_TOP) {\n    draw_vsep_win(wp, 0);\n  }\n  syn_set_timeout(NULL);\n\n  // Reset the type of redrawing required, the window has been updated.\n  wp->w_redr_type = 0;\n  wp->w_old_topfill = wp->w_topfill;\n  wp->w_old_botfill = wp->w_botfill;\n\n  if (dollar_vcol == -1) {\n    /*\n     * There is a trick with w_botline.  If we invalidate it on each\n     * change that might modify it, this will cause a lot of expensive\n     * calls to plines_win() in update_topline() each time.  Therefore the\n     * value of w_botline is often approximated, and this value is used to\n     * compute the value of w_topline.  If the value of w_botline was\n     * wrong, check that the value of w_topline is correct (cursor is on\n     * the visible part of the text).  If it's not, we need to redraw\n     * again.  Mostly this just means scrolling up a few lines, so it\n     * doesn't look too bad.  Only do this for the current window (where\n     * changes are relevant).\n     */\n    wp->w_valid |= VALID_BOTLINE;\n    wp->w_viewport_invalid = true;\n    if (wp == curwin && wp->w_botline != old_botline && !recursive) {\n      const linenr_T old_topline = wp->w_topline;\n      const int new_wcol = wp->w_wcol;\n      recursive = true;\n      curwin->w_valid &= ~VALID_TOPLINE;\n      update_topline(curwin);  // may invalidate w_botline again\n\n      if (old_wcol != new_wcol\n          && (wp->w_valid & (VALID_WCOL|VALID_WROW))\n          != (VALID_WCOL|VALID_WROW)) {\n        // A win_line() call applied a fix to screen cursor column to\n        // accommodate concealment of cursor line, but in this call to\n        // update_topline() the cursor's row or column got invalidated.\n        // If they are left invalid, setcursor() will recompute them\n        // but there won't be any further win_line() call to re-fix the\n        // column and the cursor will end up misplaced.  So we call\n        // cursor validation now and reapply the fix again (or call\n        // win_line() to do it for us).\n        validate_cursor();\n        if (wp->w_wcol == old_wcol\n            && wp->w_wrow == old_wrow\n            && old_topline == wp->w_topline) {\n          wp->w_wcol = new_wcol;\n        } else {\n          redrawWinline(wp, wp->w_cursor.lnum);\n        }\n      }\n      // New redraw either due to updated topline or due to wcol fix.\n      if (wp->w_redr_type != 0) {\n        // Don't update for changes in buffer again.\n        i = curbuf->b_mod_set;\n        curbuf->b_mod_set = false;\n        j = curbuf->b_mod_xlines;\n        curbuf->b_mod_xlines = 0;\n        win_update(curwin, providers);\n        curbuf->b_mod_set = i;\n        curbuf->b_mod_xlines = j;\n      }\n      // Other windows might have w_redr_type raised in update_topline().\n      must_redraw = 0;\n      FOR_ALL_WINDOWS_IN_TAB(wwp, curtab) {\n        if (wwp->w_redr_type > must_redraw) {\n          must_redraw = wwp->w_redr_type;\n        }\n      }\n      recursive = false;\n    }\n  }\n\n\n  // restore got_int, unless CTRL-C was hit while redrawing\n  if (!got_int) {\n    got_int = save_got_int;\n  }\n}  // NOLINT(readability/fn_size)\n\n/// Returns width of the signcolumn that should be used for the whole window\n///\n/// @param wp window we want signcolumn width from\n/// @return max width of signcolumn (cell unit)\n///\n/// @note Returns a constant for now but hopefully we can improve neovim so that\n///       the returned value width adapts to the maximum number of marks to draw\n///       for the window\n/// TODO(teto)\nint win_signcol_width(win_T *wp)\n{\n  // 2 is vim default value\n  return 2;\n}\n\n/// Call grid_fill() with columns adjusted for 'rightleft' if needed.\n/// Return the new offset.\nstatic int win_fill_end(win_T *wp, int c1, int c2, int off, int width, int row, int endrow,\n                        int attr)\n{\n  int nn = off + width;\n\n  if (nn > wp->w_grid.Columns) {\n    nn = wp->w_grid.Columns;\n  }\n\n  if (wp->w_p_rl) {\n    grid_fill(&wp->w_grid, row, endrow, W_ENDCOL(wp) - nn, W_ENDCOL(wp) - off,\n              c1, c2, attr);\n  } else {\n    grid_fill(&wp->w_grid, row, endrow, off, nn, c1, c2, attr);\n  }\n\n  return nn;\n}\n\n/// Clear lines near the end of the window and mark the unused lines with \"c1\".\n/// Use \"c2\" as filler character.\n/// When \"draw_margin\" is true, then draw the sign/fold/number columns.\nstatic void win_draw_end(win_T *wp, int c1, int c2, bool draw_margin, int row, int endrow, hlf_T hl)\n{\n  assert(hl >= 0 && hl < HLF_COUNT);\n  int n = 0;\n\n  if (draw_margin) {\n    // draw the fold column\n    int fdc = compute_foldcolumn(wp, 0);\n    if (fdc > 0) {\n      n = win_fill_end(wp, ' ', ' ', n, fdc, row, endrow,\n                       win_hl_attr(wp, HLF_FC));\n    }\n    // draw the sign column\n    int count = win_signcol_count(wp);\n    if (count > 0) {\n      n = win_fill_end(wp, ' ', ' ', n, win_signcol_width(wp) * count, row,\n                       endrow, win_hl_attr(wp, HLF_SC));\n    }\n    // draw the number column\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) == NULL) {\n      n = win_fill_end(wp, ' ', ' ', n, number_width(wp) + 1, row, endrow,\n                       win_hl_attr(wp, HLF_N));\n    }\n  }\n\n  int attr = hl_combine_attr(wp->w_hl_attr_normal, win_hl_attr(wp, hl));\n\n  if (wp->w_p_rl) {\n    grid_fill(&wp->w_grid, row, endrow, wp->w_wincol, W_ENDCOL(wp) - 1 - n,\n              c2, c2, attr);\n    grid_fill(&wp->w_grid, row, endrow, W_ENDCOL(wp) - 1 - n, W_ENDCOL(wp) - n,\n              c1, c2, attr);\n  } else {\n    grid_fill(&wp->w_grid, row, endrow, n, wp->w_grid.Columns, c1, c2, attr);\n  }\n\n  set_empty_rows(wp, row);\n}\n\n\n/// Advance **color_cols\n///\n/// @return  true when there are columns to draw.\nstatic bool advance_color_col(int vcol, int **color_cols)\n{\n  while (**color_cols >= 0 && vcol > **color_cols) {\n    ++*color_cols;\n  }\n  return **color_cols >= 0;\n}\n\n// Compute the width of the foldcolumn.  Based on 'foldcolumn' and how much\n// space is available for window \"wp\", minus \"col\".\nstatic int compute_foldcolumn(win_T *wp, int col)\n{\n  int fdc = win_fdccol_count(wp);\n  int wmw = wp == curwin && p_wmw == 0 ? 1 : p_wmw;\n  int wwidth = wp->w_grid.Columns;\n\n  if (fdc > wwidth - (col + wmw)) {\n    fdc = wwidth - (col + wmw);\n  }\n  return fdc;\n}\n\n/// Put a single char from an UTF-8 buffer into a line buffer.\n///\n/// Handles composing chars and arabic shaping state.\nstatic int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl)\n{\n  const char_u *p = (char_u *)s->p;\n  int cells = utf_ptr2cells(p);\n  int c_len = utfc_ptr2len(p);\n  int u8c, u8cc[MAX_MCO];\n  if (cells > maxcells) {\n    return -1;\n  }\n  u8c = utfc_ptr2char(p, u8cc);\n  if (*p < 0x80 && u8cc[0] == 0) {\n    schar_from_ascii(dest[0], *p);\n    s->prev_c = u8c;\n  } else {\n    if (p_arshape && !p_tbidi && arabic_char(u8c)) {\n      // Do Arabic shaping.\n      int pc, pc1, nc;\n      int pcc[MAX_MCO];\n      int firstbyte = *p;\n\n      // The idea of what is the previous and next\n      // character depends on 'rightleft'.\n      if (rl) {\n        pc = s->prev_c;\n        pc1 = s->prev_c1;\n        nc = utf_ptr2char(p + c_len);\n        s->prev_c1 = u8cc[0];\n      } else {\n        pc = utfc_ptr2char(p + c_len, pcc);\n        nc = s->prev_c;\n        pc1 = pcc[0];\n      }\n      s->prev_c = u8c;\n\n      u8c = arabic_shape(u8c, &firstbyte, &u8cc[0], pc, pc1, nc);\n    } else {\n      s->prev_c = u8c;\n    }\n    schar_from_cc(dest[0], u8c, u8cc);\n  }\n  if (cells > 1) {\n    dest[1][0] = 0;\n  }\n  s->p += c_len;\n  return cells;\n}\n\n\n/// Fills the foldcolumn at \"p\" for window \"wp\".\n/// Only to be called when 'foldcolumn' > 0.\n///\n/// @param[out] p  Char array to write into\n/// @param lnum    Absolute current line number\n/// @param closed  Whether it is in 'foldcolumn' mode\n///\n/// Assume monocell characters\n/// @return number of chars added to \\param p\nstatic size_t fill_foldcolumn(char_u *p, win_T *wp, foldinfo_T foldinfo, linenr_T lnum)\n{\n  int i = 0;\n  int level;\n  int first_level;\n  int fdc = compute_foldcolumn(wp, 0);    // available cell width\n  size_t char_counter = 0;\n  int symbol = 0;\n  int len = 0;\n  bool closed = foldinfo.fi_lines > 0;\n  // Init to all spaces.\n  memset(p, ' ', MAX_MCO * fdc + 1);\n\n  level = foldinfo.fi_level;\n\n  // If the column is too narrow, we start at the lowest level that\n  // fits and use numbers to indicated the depth.\n  first_level = level - fdc - closed + 1;\n  if (first_level < 1) {\n    first_level = 1;\n  }\n\n  for (i = 0; i  < MIN(fdc, level); i++) {\n    if (foldinfo.fi_lnum == lnum\n        && first_level + i >= foldinfo.fi_low_level) {\n      symbol = wp->w_p_fcs_chars.foldopen;\n    } else if (first_level == 1) {\n      symbol = wp->w_p_fcs_chars.foldsep;\n    } else if (first_level + i <= 9) {\n      symbol = '0' + first_level + i;\n    } else {\n      symbol = '>';\n    }\n\n    len = utf_char2bytes(symbol, &p[char_counter]);\n    char_counter += len;\n    if (first_level + i >= level) {\n      i++;\n      break;\n    }\n  }\n\n  if (closed) {\n    if (symbol != 0) {\n      // rollback previous write\n      char_counter -= len;\n      memset(&p[char_counter], ' ', len);\n    }\n    len = utf_char2bytes(wp->w_p_fcs_chars.foldclosed, &p[char_counter]);\n    char_counter += len;\n  }\n\n  return MAX(char_counter + (fdc-i), (size_t)fdc);\n}\n\n/// Display line \"lnum\" of window 'wp' on the screen.\n/// wp->w_virtcol needs to be valid.\n///\n/// @param lnum         line to display\n/// @param startrow     first row relative to window grid\n/// @param endrow       last grid row to be redrawn\n/// @param nochange     not updating for changed text\n/// @param number_only  only update the number column\n/// @param foldinfo     fold info for this line\n/// @param[in, out] providers  decoration providers active this line\n///                            items will be disables if they cause errors\n///                            or explicitly return `false`.\n///\n/// @return             the number of last row the line occupies.\nstatic int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,\n                    bool number_only, foldinfo_T foldinfo, Providers *providers)\n{\n  int c = 0;                          // init for GCC\n  long vcol = 0;                      // virtual column (for tabs)\n  long vcol_sbr = -1;                 // virtual column after showbreak\n  long vcol_prev = -1;                // \"vcol\" of previous character\n  char_u      *line;                  // current line\n  char_u      *ptr;                   // current position in \"line\"\n  int row;                            // row in the window, excl w_winrow\n  ScreenGrid *grid = &wp->w_grid;     // grid specific to the window\n\n  char_u extra[57];                   // sign, line number and 'fdc' must\n                                      // fit in here\n  int n_extra = 0;                    // number of extra chars\n  char_u      *p_extra = NULL;        // string of extra chars, plus NUL\n  char_u      *p_extra_free = NULL;   // p_extra needs to be freed\n  int c_extra = NUL;                  // extra chars, all the same\n  int c_final = NUL;                  // final char, mandatory if set\n  int extra_attr = 0;                 // attributes when n_extra != 0\n  static char_u *at_end_str = (char_u *)\"\";  // used for p_extra when displaying\n                                             // curwin->w_p_lcs_chars.eol at\n                                             // end-of-line\n  int lcs_eol_one = wp->w_p_lcs_chars.eol;     // 'eol'  until it's been used\n  int lcs_prec_todo = wp->w_p_lcs_chars.prec;  // 'prec' until it's been used\n  bool has_fold = foldinfo.fi_level != 0 && foldinfo.fi_lines > 0;\n\n  // saved \"extra\" items for when draw_state becomes WL_LINE (again)\n  int saved_n_extra = 0;\n  char_u      *saved_p_extra = NULL;\n  int saved_c_extra = 0;\n  int saved_c_final = 0;\n  int saved_char_attr = 0;\n\n  int n_attr = 0;                       // chars with special attr\n  int saved_attr2 = 0;                  // char_attr saved for n_attr\n  int n_attr3 = 0;                      // chars with overruling special attr\n  int saved_attr3 = 0;                  // char_attr saved for n_attr3\n\n  int n_skip = 0;                       // nr of chars to skip for 'nowrap'\n\n  int fromcol = -10;                    // start of inverting\n  int tocol = MAXCOL;                   // end of inverting\n  int fromcol_prev = -2;                // start of inverting after cursor\n  bool noinvcur = false;                // don't invert the cursor\n  int lnum_in_visual_area = false;\n  pos_T pos;\n  long v;\n\n  int char_attr = 0;                    // attributes for next character\n  int attr_pri = FALSE;                 // char_attr has priority\n  int area_highlighting = FALSE;           /* Visual or incsearch highlighting\n                                              in this line */\n  int attr = 0;                         // attributes for area highlighting\n  int area_attr = 0;                    // attributes desired by highlighting\n  int search_attr = 0;                  // attributes desired by 'hlsearch'\n  int vcol_save_attr = 0;               // saved attr for 'cursorcolumn'\n  int syntax_attr = 0;                  // attributes desired by syntax\n  int has_syntax = FALSE;               // this buffer has syntax highl.\n  int save_did_emsg;\n  int eol_hl_off = 0;                   // 1 if highlighted char after EOL\n  bool draw_color_col = false;          // highlight colorcolumn\n  int *color_cols = NULL;               // pointer to according columns array\n  bool has_spell = false;               // this buffer has spell checking\n# define SPWORDLEN 150\n  char_u nextline[SPWORDLEN * 2];       // text with start of the next line\n  int nextlinecol = 0;                  // column where nextline[] starts\n  int nextline_idx = 0;                 /* index in nextline[] where next line\n                                           starts */\n  int spell_attr = 0;                   // attributes desired by spelling\n  int word_end = 0;                     // last byte with same spell_attr\n  static linenr_T checked_lnum = 0;     // line number for \"checked_col\"\n  static int checked_col = 0;           /* column in \"checked_lnum\" up to which\n                                         * there are no spell errors */\n  static int cap_col = -1;              // column to check for Cap word\n  static linenr_T capcol_lnum = 0;      // line number where \"cap_col\"\n  int cur_checked_col = 0;              // checked column for current line\n  int extra_check = 0;                  // has syntax or linebreak\n  int multi_attr = 0;                   // attributes desired by multibyte\n  int mb_l = 1;                         // multi-byte byte length\n  int mb_c = 0;                         // decoded multi-byte character\n  bool mb_utf8 = false;                 // screen char is UTF-8 char\n  int u8cc[MAX_MCO];                    // composing UTF-8 chars\n  int filler_lines;                     // nr of filler lines to be drawn\n  int filler_todo;                      // nr of filler lines still to do + 1\n  hlf_T diff_hlf = (hlf_T)0;            // type of diff highlighting\n  int change_start = MAXCOL;            // first col of changed area\n  int change_end = -1;                  // last col of changed area\n  colnr_T trailcol = MAXCOL;            // start of trailing spaces\n  colnr_T leadcol = 0;                  // start of leading spaces\n  bool need_showbreak = false;          // overlong line, skip first x chars\n  sign_attrs_T sattrs[SIGN_SHOW_MAX];   // attributes for signs\n  int num_signs;                        // number of signs for line\n  int line_attr = 0;                    // attribute for the whole line\n  int line_attr_save;\n  int line_attr_lowprio = 0;            // low-priority attribute for the line\n  int line_attr_lowprio_save;\n  matchitem_T *cur;                     // points to the match list\n  match_T     *shl;                     // points to search_hl or a match\n  bool shl_flag;                        // flag to indicate whether search_hl\n                                        // has been processed or not\n  bool prevcol_hl_flag;                 // flag to indicate whether prevcol\n                                        // equals startcol of search_hl or one\n                                        // of the matches\n  int prev_c = 0;                       // previous Arabic character\n  int prev_c1 = 0;                      // first composing char for prev_c\n\n  bool search_attr_from_match = false;  // if search_attr is from :match\n  bool has_decor = false;               // this buffer has decoration\n  int win_col_offset = 0;               // offset for window columns\n\n  char_u buf_fold[FOLD_TEXT_LEN + 1];   // Hold value returned by get_foldtext\n\n  bool area_active = false;\n\n  int cul_attr = 0;                     // set when 'cursorline' active\n  // 'cursorlineopt' has \"screenline\" and cursor is in this line\n  bool cul_screenline = false;\n  // margin columns for the screen line, needed for when 'cursorlineopt'\n  // contains \"screenline\"\n  int left_curline_col = 0;\n  int right_curline_col = 0;\n\n  // draw_state: items that are drawn in sequence:\n#define WL_START        0               // nothing done yet\n# define WL_CMDLINE     WL_START + 1    // cmdline window column\n# define WL_FOLD        WL_CMDLINE + 1  // 'foldcolumn'\n# define WL_SIGN        WL_FOLD + 1     // column for signs\n#define WL_NR           WL_SIGN + 1     // line number\n# define WL_BRI         WL_NR + 1       // 'breakindent'\n# define WL_SBR         WL_BRI + 1       // 'showbreak' or 'diff'\n#define WL_LINE         WL_SBR + 1      // text in the line\n  int draw_state = WL_START;            // what to draw next\n\n  int syntax_flags    = 0;\n  int syntax_seqnr    = 0;\n  int prev_syntax_id  = 0;\n  int conceal_attr    = win_hl_attr(wp, HLF_CONCEAL);\n  bool is_concealing  = false;\n  int boguscols       = 0;              ///< nonexistent columns added to\n                                        ///< force wrapping\n  int vcol_off        = 0;              ///< offset for concealed characters\n  int did_wcol        = false;\n  int match_conc      = 0;              ///< cchar for match functions\n  int old_boguscols = 0;\n# define VCOL_HLC (vcol - vcol_off)\n# define FIX_FOR_BOGUSCOLS \\\n  { \\\n    n_extra += vcol_off; \\\n    vcol -= vcol_off; \\\n    vcol_off = 0; \\\n    col -= boguscols; \\\n    old_boguscols = boguscols; \\\n    boguscols = 0; \\\n  }\n\n  if (startrow > endrow) {              // past the end already!\n    return startrow;\n  }\n\n  row = startrow;\n\n  buf_T *buf = wp->w_buffer;\n\n  if (!number_only) {\n    // To speed up the loop below, set extra_check when there is linebreak,\n    // trailing white space and/or syntax processing to be done.\n    extra_check = wp->w_p_lbr;\n    if (syntax_present(wp) && !wp->w_s->b_syn_error && !wp->w_s->b_syn_slow) {\n      // Prepare for syntax highlighting in this line.  When there is an\n      // error, stop syntax highlighting.\n      save_did_emsg = did_emsg;\n      did_emsg = false;\n      syntax_start(wp, lnum);\n      if (did_emsg) {\n        wp->w_s->b_syn_error = true;\n      } else {\n        did_emsg = save_did_emsg;\n        if (!wp->w_s->b_syn_slow) {\n          has_syntax = true;\n          extra_check = true;\n        }\n      }\n    }\n\n    has_decor = decor_redraw_line(wp->w_buffer, lnum-1,\n                                  &decor_state);\n\n    for (size_t k = 0; k < kv_size(*providers); k++) {\n      DecorProvider *p = kv_A(*providers, k);\n      if (p && p->redraw_line != LUA_NOREF) {\n        FIXED_TEMP_ARRAY(args, 3);\n        args.items[0] = WINDOW_OBJ(wp->handle);\n        args.items[1] = BUFFER_OBJ(buf->handle);\n        args.items[2] = INTEGER_OBJ(lnum-1);\n        if (provider_invoke(p->ns_id, \"line\", p->redraw_line, args, true)) {\n          has_decor = true;\n        } else {\n          // return 'false' or error: skip rest of this window\n          kv_A(*providers, k) = NULL;\n        }\n\n        win_check_ns_hl(wp);\n      }\n    }\n\n    if (provider_err) {\n      Decoration err_decor = DECORATION_INIT;\n      int hl_err = syn_check_group((char_u *)S_LEN(\"ErrorMsg\"));\n      kv_push(err_decor.virt_text,\n              ((VirtTextChunk){ .text = provider_err,\n                                .hl_id = hl_err }));\n      err_decor.virt_text_width = mb_string2cells((char_u *)provider_err);\n      decor_add_ephemeral(lnum-1, 0, lnum-1, 0, &err_decor);\n      provider_err = NULL;\n      has_decor = true;\n    }\n\n    if (has_decor) {\n      extra_check = true;\n    }\n\n    // Check for columns to display for 'colorcolumn'.\n    color_cols = wp->w_buffer->terminal ? NULL : wp->w_p_cc_cols;\n    if (color_cols != NULL) {\n      draw_color_col = advance_color_col(VCOL_HLC, &color_cols);\n    }\n\n    if (wp->w_p_spell\n        && !has_fold\n        && *wp->w_s->b_p_spl != NUL\n        && !GA_EMPTY(&wp->w_s->b_langp)\n        && *(char **)(wp->w_s->b_langp.ga_data) != NULL) {\n      // Prepare for spell checking.\n      has_spell = true;\n      extra_check = true;\n\n      // Get the start of the next line, so that words that wrap to the next\n      // line are found too: \"et<line-break>al.\".\n      // Trick: skip a few chars for C/shell/Vim comments\n      nextline[SPWORDLEN] = NUL;\n      if (lnum < wp->w_buffer->b_ml.ml_line_count) {\n        line = ml_get_buf(wp->w_buffer, lnum + 1, false);\n        spell_cat_line(nextline + SPWORDLEN, line, SPWORDLEN);\n      }\n\n      // When a word wrapped from the previous line the start of the current\n      // line is valid.\n      if (lnum == checked_lnum) {\n        cur_checked_col = checked_col;\n      }\n      checked_lnum = 0;\n\n      // When there was a sentence end in the previous line may require a\n      // word starting with capital in this line.  In line 1 always check\n      // the first word.\n      if (lnum != capcol_lnum) {\n        cap_col = -1;\n      }\n      if (lnum == 1) {\n        cap_col = 0;\n      }\n      capcol_lnum = 0;\n    }\n\n    // handle Visual active in this window\n    if (VIsual_active && wp->w_buffer == curwin->w_buffer) {\n      pos_T *top, *bot;\n\n      if (ltoreq(curwin->w_cursor, VIsual)) {\n        // Visual is after curwin->w_cursor\n        top = &curwin->w_cursor;\n        bot = &VIsual;\n      } else {\n        // Visual is before curwin->w_cursor\n        top = &VIsual;\n        bot = &curwin->w_cursor;\n      }\n      lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);\n      if (VIsual_mode == Ctrl_V) {\n        // block mode\n        if (lnum_in_visual_area) {\n          fromcol = wp->w_old_cursor_fcol;\n          tocol = wp->w_old_cursor_lcol;\n        }\n      } else {\n        // non-block mode\n        if (lnum > top->lnum && lnum <= bot->lnum) {\n          fromcol = 0;\n        } else if (lnum == top->lnum) {\n          if (VIsual_mode == 'V') {       // linewise\n            fromcol = 0;\n          } else {\n            getvvcol(wp, top, (colnr_T *)&fromcol, NULL, NULL);\n            if (gchar_pos(top) == NUL) {\n              tocol = fromcol + 1;\n            }\n          }\n        }\n        if (VIsual_mode != 'V' && lnum == bot->lnum) {\n          if (*p_sel == 'e' && bot->col == 0\n              && bot->coladd == 0) {\n            fromcol = -10;\n            tocol = MAXCOL;\n          } else if (bot->col == MAXCOL) {\n            tocol = MAXCOL;\n          } else {\n            pos = *bot;\n            if (*p_sel == 'e') {\n              getvvcol(wp, &pos, (colnr_T *)&tocol, NULL, NULL);\n            } else {\n              getvvcol(wp, &pos, NULL, NULL, (colnr_T *)&tocol);\n              tocol++;\n            }\n          }\n        }\n      }\n\n      // Check if the char under the cursor should be inverted (highlighted).\n      if (!highlight_match && lnum == curwin->w_cursor.lnum && wp == curwin\n          && cursor_is_block_during_visual(*p_sel == 'e')) {\n        noinvcur = true;\n      }\n\n      // if inverting in this line set area_highlighting\n      if (fromcol >= 0) {\n        area_highlighting = true;\n        attr = win_hl_attr(wp, HLF_V);\n      }\n      // handle 'incsearch' and \":s///c\" highlighting\n    } else if (highlight_match\n               && wp == curwin\n               && !has_fold\n               && lnum >= curwin->w_cursor.lnum\n               && lnum <= curwin->w_cursor.lnum + search_match_lines) {\n      if (lnum == curwin->w_cursor.lnum) {\n        getvcol(curwin, &(curwin->w_cursor),\n                (colnr_T *)&fromcol, NULL, NULL);\n      } else {\n        fromcol = 0;\n      }\n      if (lnum == curwin->w_cursor.lnum + search_match_lines) {\n        pos.lnum = lnum;\n        pos.col = search_match_endcol;\n        getvcol(curwin, &pos, (colnr_T *)&tocol, NULL, NULL);\n      }\n      // do at least one character; happens when past end of line\n      if (fromcol == tocol && search_match_endcol) {\n        tocol = fromcol + 1;\n      }\n      area_highlighting = true;\n      attr = win_hl_attr(wp, HLF_I);\n    }\n  }\n\n  filler_lines = diff_check(wp, lnum);\n  if (filler_lines < 0) {\n    if (filler_lines == -1) {\n      if (diff_find_change(wp, lnum, &change_start, &change_end)) {\n        diff_hlf = HLF_ADD;             // added line\n      } else if (change_start == 0) {\n        diff_hlf = HLF_TXD;             // changed text\n      } else {\n        diff_hlf = HLF_CHD;             // changed line\n      }\n    } else {\n      diff_hlf = HLF_ADD;               // added line\n    }\n    filler_lines = 0;\n    area_highlighting = TRUE;\n  }\n  if (lnum == wp->w_topline) {\n    filler_lines = wp->w_topfill;\n  }\n  filler_todo = filler_lines;\n\n  // Cursor line highlighting for 'cursorline' in the current window.\n  if (lnum == wp->w_cursor.lnum) {\n    // Do not show the cursor line in the text when Visual mode is active,\n    // because it's not clear what is selected then.\n    if (wp->w_p_cul && !(wp == curwin && VIsual_active)\n        && wp->w_p_culopt_flags != CULOPT_NBR) {\n      cul_screenline = (wp->w_p_wrap\n                        && (wp->w_p_culopt_flags & CULOPT_SCRLINE));\n      if (!cul_screenline) {\n        cul_attr = win_hl_attr(wp, HLF_CUL);\n        HlAttrs ae = syn_attr2entry(cul_attr);\n        // We make a compromise here (#7383):\n        //  * low-priority CursorLine if fg is not set\n        //  * high-priority (\"same as Vim\" priority) CursorLine if fg is set\n        if (ae.rgb_fg_color == -1 && ae.cterm_fg_color == 0) {\n          line_attr_lowprio = cul_attr;\n        } else {\n          if (!(State & INSERT) && bt_quickfix(wp->w_buffer)\n              && qf_current_entry(wp) == lnum) {\n            line_attr = hl_combine_attr(cul_attr, line_attr);\n          } else {\n            line_attr = cul_attr;\n          }\n        }\n      } else {\n        margin_columns_win(wp, &left_curline_col, &right_curline_col);\n      }\n      area_highlighting = true;\n    }\n    // Update w_last_cursorline even if Visual mode is active.\n    wp->w_last_cursorline = wp->w_cursor.lnum;\n  }\n\n  memset(sattrs, 0, sizeof(sattrs));\n  num_signs = buf_get_signattrs(wp->w_buffer, lnum, sattrs);\n\n  // If this line has a sign with line highlighting set line_attr.\n  // TODO(bfredl, vigoux): this should not take priority over decoration!\n  sign_attrs_T * sattr = sign_get_attr(SIGN_LINEHL, sattrs, 0, 1);\n  if (sattr != NULL) {\n    line_attr = sattr->sat_linehl;\n  }\n\n  // Highlight the current line in the quickfix window.\n  if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum) {\n    line_attr = win_hl_attr(wp, HLF_QFL);\n  }\n\n  if (line_attr_lowprio || line_attr) {\n    area_highlighting = true;\n  }\n\n  if (cul_screenline) {\n    line_attr_save = line_attr;\n    line_attr_lowprio_save = line_attr_lowprio;\n  }\n\n  line = ml_get_buf(wp->w_buffer, lnum, false);\n  ptr = line;\n\n  if (has_spell && !number_only) {\n    // For checking first word with a capital skip white space.\n    if (cap_col == 0) {\n      cap_col = (int)getwhitecols(line);\n    }\n\n    /* To be able to spell-check over line boundaries copy the end of the\n     * current line into nextline[].  Above the start of the next line was\n     * copied to nextline[SPWORDLEN]. */\n    if (nextline[SPWORDLEN] == NUL) {\n      // No next line or it is empty.\n      nextlinecol = MAXCOL;\n      nextline_idx = 0;\n    } else {\n      v = (long)STRLEN(line);\n      if (v < SPWORDLEN) {\n        /* Short line, use it completely and append the start of the\n         * next line. */\n        nextlinecol = 0;\n        memmove(nextline, line, (size_t)v);\n        STRMOVE(nextline + v, nextline + SPWORDLEN);\n        nextline_idx = v + 1;\n      } else {\n        // Long line, use only the last SPWORDLEN bytes.\n        nextlinecol = v - SPWORDLEN;\n        memmove(nextline, line + nextlinecol, SPWORDLEN);  // -V512\n        nextline_idx = SPWORDLEN + 1;\n      }\n    }\n  }\n\n  if (wp->w_p_list && !has_fold) {\n    if (wp->w_p_lcs_chars.space\n        || wp->w_p_lcs_chars.trail\n        || wp->w_p_lcs_chars.lead\n        || wp->w_p_lcs_chars.nbsp) {\n      extra_check = true;\n    }\n    // find start of trailing whitespace\n    if (wp->w_p_lcs_chars.trail) {\n      trailcol = (colnr_T)STRLEN(ptr);\n      while (trailcol > (colnr_T)0 && ascii_iswhite(ptr[trailcol - 1])) {\n        trailcol--;\n      }\n      trailcol += (colnr_T)(ptr - line);\n    }\n    // find end of leading whitespace\n    if (wp->w_p_lcs_chars.lead) {\n      leadcol = 0;\n      while (ascii_iswhite(ptr[leadcol])) {\n        leadcol++;\n      }\n      if (ptr[leadcol] == NUL) {\n        // in a line full of spaces all of them are treated as trailing\n        leadcol = (colnr_T)0;\n      } else {\n        // keep track of the first column not filled with spaces\n        leadcol += (colnr_T)(ptr - line) + 1;\n      }\n    }\n  }\n\n  /*\n   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the\n   * first character to be displayed.\n   */\n  if (wp->w_p_wrap) {\n    v = wp->w_skipcol;\n  } else {\n    v = wp->w_leftcol;\n  }\n  if (v > 0 && !number_only) {\n    char_u  *prev_ptr = ptr;\n    while (vcol < v && *ptr != NUL) {\n      c = win_lbr_chartabsize(wp, line, ptr, (colnr_T)vcol, NULL);\n      vcol += c;\n      prev_ptr = ptr;\n      MB_PTR_ADV(ptr);\n    }\n\n    // When:\n    // - 'cuc' is set, or\n    // - 'colorcolumn' is set, or\n    // - 'virtualedit' is set, or\n    // - the visual mode is active,\n    // the end of the line may be before the start of the displayed part.\n    if (vcol < v && (wp->w_p_cuc\n                     || draw_color_col\n                     || virtual_active()\n                     || (VIsual_active && wp->w_buffer == curwin->w_buffer))) {\n      vcol = v;\n    }\n\n    /* Handle a character that's not completely on the screen: Put ptr at\n     * that character but skip the first few screen characters. */\n    if (vcol > v) {\n      vcol -= c;\n      ptr = prev_ptr;\n      // If the character fits on the screen, don't need to skip it.\n      // Except for a TAB.\n      if (utf_ptr2cells(ptr) >= c || *ptr == TAB) {\n        n_skip = v - vcol;\n      }\n    }\n\n    /*\n     * Adjust for when the inverted text is before the screen,\n     * and when the start of the inverted text is before the screen.\n     */\n    if (tocol <= vcol) {\n      fromcol = 0;\n    } else if (fromcol >= 0 && fromcol < vcol) {\n      fromcol = vcol;\n    }\n\n    // When w_skipcol is non-zero, first line needs 'showbreak'\n    if (wp->w_p_wrap) {\n      need_showbreak = true;\n    }\n    // When spell checking a word we need to figure out the start of the\n    // word and if it's badly spelled or not.\n    if (has_spell) {\n      size_t len;\n      colnr_T linecol = (colnr_T)(ptr - line);\n      hlf_T spell_hlf = HLF_COUNT;\n\n      pos = wp->w_cursor;\n      wp->w_cursor.lnum = lnum;\n      wp->w_cursor.col = linecol;\n      len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);\n\n      // spell_move_to() may call ml_get() and make \"line\" invalid\n      line = ml_get_buf(wp->w_buffer, lnum, false);\n      ptr = line + linecol;\n\n      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {\n        /* no bad word found at line start, don't check until end of a\n         * word */\n        spell_hlf = HLF_COUNT;\n        word_end = (int)(spell_to_word_end(ptr, wp) - line + 1);\n      } else {\n        // bad word found, use attributes until end of word\n        assert(len <= INT_MAX);\n        word_end = wp->w_cursor.col + (int)len + 1;\n\n        // Turn index into actual attributes.\n        if (spell_hlf != HLF_COUNT) {\n          spell_attr = highlight_attr[spell_hlf];\n        }\n      }\n      wp->w_cursor = pos;\n\n      // Need to restart syntax highlighting for this line.\n      if (has_syntax) {\n        syntax_start(wp, lnum);\n      }\n    }\n  }\n\n  /*\n   * Correct highlighting for cursor that can't be disabled.\n   * Avoids having to check this for each character.\n   */\n  if (fromcol >= 0) {\n    if (noinvcur) {\n      if ((colnr_T)fromcol == wp->w_virtcol) {\n        /* highlighting starts at cursor, let it start just after the\n         * cursor */\n        fromcol_prev = fromcol;\n        fromcol = -1;\n      } else if ((colnr_T)fromcol < wp->w_virtcol) {\n        // restart highlighting after the cursor\n        fromcol_prev = wp->w_virtcol;\n      }\n    }\n    if (fromcol >= tocol) {\n      fromcol = -1;\n    }\n  }\n\n  /*\n   * Handle highlighting the last used search pattern and matches.\n   * Do this for both search_hl and the match list.\n   */\n  cur = wp->w_match_head;\n  shl_flag = false;\n  while ((cur != NULL || !shl_flag) && !number_only\n         && !has_fold) {\n    if (!shl_flag) {\n      shl = &search_hl;\n      shl_flag = true;\n    } else {\n      shl = &cur->hl;  // -V595\n    }\n    shl->startcol = MAXCOL;\n    shl->endcol = MAXCOL;\n    shl->attr_cur = 0;\n    shl->is_addpos = false;\n    v = (long)(ptr - line);\n    if (cur != NULL) {\n      cur->pos.cur = 0;\n    }\n    next_search_hl(wp, shl, lnum, (colnr_T)v,\n                   shl == &search_hl ? NULL : cur);\n    if (wp->w_s->b_syn_slow) {\n      has_syntax = false;\n    }\n\n    // Need to get the line again, a multi-line regexp may have made it\n    // invalid.\n    line = ml_get_buf(wp->w_buffer, lnum, false);\n    ptr = line + v;\n\n    if (shl->lnum != 0 && shl->lnum <= lnum) {\n      if (shl->lnum == lnum) {\n        shl->startcol = shl->rm.startpos[0].col;\n      } else {\n        shl->startcol = 0;\n      }\n      if (lnum == shl->lnum + shl->rm.endpos[0].lnum\n          - shl->rm.startpos[0].lnum) {\n        shl->endcol = shl->rm.endpos[0].col;\n      } else {\n        shl->endcol = MAXCOL;\n      }\n      // Highlight one character for an empty match.\n      if (shl->startcol == shl->endcol) {\n        if (line[shl->endcol] != NUL) {\n          shl->endcol += (*mb_ptr2len)(line + shl->endcol);\n        } else {\n          ++shl->endcol;\n        }\n      }\n      if ((long)shl->startcol < v) {   // match at leftcol\n        shl->attr_cur = shl->attr;\n        search_attr = shl->attr;\n        search_attr_from_match = shl != &search_hl;\n      }\n      area_highlighting = true;\n    }\n    if (shl != &search_hl && cur != NULL) {\n      cur = cur->next;\n    }\n  }\n\n  unsigned off = 0;  // Offset relative start of line\n  int col = 0;  // Visual column on screen.\n  if (wp->w_p_rl) {\n    // Rightleft window: process the text in the normal direction, but put\n    // it in linebuf_char[off] from right to left.  Start at the\n    // rightmost column of the window.\n    col = grid->Columns - 1;\n    off += col;\n  }\n\n  // won't highlight after TERM_ATTRS_MAX columns\n  int term_attrs[TERM_ATTRS_MAX] = { 0 };\n  if (wp->w_buffer->terminal) {\n    terminal_get_line_attributes(wp->w_buffer->terminal, wp, lnum, term_attrs);\n    extra_check = true;\n  }\n\n  int sign_idx = 0;\n  // Repeat for the whole displayed line.\n  for (;; ) {\n    int has_match_conc = 0;  ///< match wants to conceal\n    bool did_decrement_ptr = false;\n\n    // Skip this quickly when working on the text.\n    if (draw_state != WL_LINE) {\n      if (cul_screenline) {\n        cul_attr = 0;\n        line_attr = line_attr_save;\n        line_attr_lowprio = line_attr_lowprio_save;\n      }\n\n      if (draw_state == WL_CMDLINE - 1 && n_extra == 0) {\n        draw_state = WL_CMDLINE;\n        if (cmdwin_type != 0 && wp == curwin) {\n          // Draw the cmdline character.\n          n_extra = 1;\n          c_extra = cmdwin_type;\n          c_final = NUL;\n          char_attr = win_hl_attr(wp, HLF_AT);\n        }\n      }\n\n      if (draw_state == WL_FOLD - 1 && n_extra == 0) {\n        int fdc = compute_foldcolumn(wp, 0);\n\n        draw_state = WL_FOLD;\n        if (fdc > 0) {\n          // Draw the 'foldcolumn'.  Allocate a buffer, \"extra\" may\n          // already be in use.\n          xfree(p_extra_free);\n          p_extra_free = xmalloc(MAX_MCO * fdc + 1);\n          n_extra = (int)fill_foldcolumn(p_extra_free, wp, foldinfo, lnum);\n          p_extra_free[n_extra] = NUL;\n          p_extra = p_extra_free;\n          c_extra = NUL;\n          c_final = NUL;\n          char_attr = win_hl_attr(wp, HLF_FC);\n        }\n      }\n\n      // sign column, this is hit until sign_idx reaches count\n      if (draw_state == WL_SIGN - 1 && n_extra == 0) {\n        draw_state = WL_SIGN;\n        /* Show the sign column when there are any signs in this\n         * buffer or when using Netbeans. */\n        int count = win_signcol_count(wp);\n        if (count > 0) {\n          get_sign_display_info(false, wp, sattrs, row,\n                                startrow, filler_lines, filler_todo, count,\n                                &c_extra, &c_final, extra, sizeof(extra),\n                                &p_extra, &n_extra,\n                                &char_attr, &draw_state, &sign_idx);\n        }\n      }\n\n      if (draw_state == WL_NR - 1 && n_extra == 0) {\n        draw_state = WL_NR;\n        /* Display the absolute or relative line number. After the\n         * first fill with blanks when the 'n' flag isn't in 'cpo' */\n        if ((wp->w_p_nu || wp->w_p_rnu)\n            && (row == startrow + filler_lines\n                || vim_strchr(p_cpo, CPO_NUMCOL) == NULL)) {\n          // If 'signcolumn' is set to 'number' and a sign is present\n          // in 'lnum', then display the sign instead of the line\n          // number.\n          if (*wp->w_p_scl == 'n' && *(wp->w_p_scl + 1) == 'u'\n              && num_signs > 0) {\n            int count = win_signcol_count(wp);\n            get_sign_display_info(true, wp, sattrs, row,\n                                  startrow, filler_lines, filler_todo, count,\n                                  &c_extra, &c_final, extra, sizeof(extra),\n                                  &p_extra, &n_extra,\n                                  &char_attr, &draw_state, &sign_idx);\n          } else {\n            if (row == startrow + filler_lines) {\n              // Draw the line number (empty space after wrapping). */\n              long num;\n              char *fmt = \"%*ld \";\n\n              if (wp->w_p_nu && !wp->w_p_rnu) {\n                // 'number' + 'norelativenumber'\n                num = (long)lnum;\n              } else {\n                // 'relativenumber', don't use negative numbers\n                num = labs((long)get_cursor_rel_lnum(wp, lnum));\n                if (num == 0 && wp->w_p_nu && wp->w_p_rnu) {\n                  // 'number' + 'relativenumber'\n                  num = lnum;\n                  fmt = \"%-*ld \";\n                }\n              }\n\n              snprintf((char *)extra, sizeof(extra),\n                       fmt, number_width(wp), num);\n              if (wp->w_skipcol > 0) {\n                for (p_extra = extra; *p_extra == ' '; p_extra++) {\n                  *p_extra = '-';\n                }\n              }\n              if (wp->w_p_rl) {                       // reverse line numbers\n                // like rl_mirror(), but keep the space at the end\n                char_u *p2 = skipwhite(extra);\n                p2 = skiptowhite(p2) - 1;\n                for (char_u *p1 = skipwhite(extra); p1 < p2; p1++, p2--) {\n                  const int t = *p1;\n                  *p1 = *p2;\n                  *p2 = t;\n                }\n              }\n              p_extra = extra;\n              c_extra = NUL;\n              c_final = NUL;\n            } else {\n              c_extra = ' ';\n              c_final = NUL;\n            }\n            n_extra = number_width(wp) + 1;\n            char_attr = win_hl_attr(wp, HLF_N);\n\n            if (wp->w_p_rnu && lnum < wp->w_cursor.lnum) {\n              // Use LineNrAbove\n              char_attr = win_hl_attr(wp, HLF_LNA);\n            }\n            if (wp->w_p_rnu && lnum > wp->w_cursor.lnum) {\n              // Use LineNrBelow\n              char_attr = win_hl_attr(wp, HLF_LNB);\n            }\n\n            sign_attrs_T *num_sattr = sign_get_attr(SIGN_NUMHL, sattrs, 0, 1);\n            if (num_sattr != NULL) {\n              // :sign defined with \"numhl\" highlight.\n              char_attr = num_sattr->sat_numhl;\n            } else if (wp->w_p_cul\n                       && lnum == wp->w_cursor.lnum\n                       && (wp->w_p_culopt_flags & CULOPT_NBR)\n                       && (row == startrow\n                           || wp->w_p_culopt_flags & CULOPT_LINE)\n                       && filler_todo == 0) {\n              // When 'cursorline' is set highlight the line number of\n              // the current line differently.\n              // When 'cursorlineopt' has \"screenline\" only highlight\n              // the line number itself.\n              // TODO(vim): Can we use CursorLine instead of CursorLineNr\n              // when CursorLineNr isn't set?\n              char_attr = win_hl_attr(wp, HLF_CLN);\n            }\n          }\n        }\n      }\n\n      if (draw_state == WL_NR && n_extra == 0) {\n        win_col_offset = off;\n      }\n\n      if (wp->w_briopt_sbr && draw_state == WL_BRI - 1\n          && n_extra == 0 && *p_sbr != NUL) {\n        // draw indent after showbreak value\n        draw_state = WL_BRI;\n      } else if (wp->w_briopt_sbr && draw_state == WL_SBR && n_extra == 0) {\n        // after the showbreak, draw the breakindent\n        draw_state = WL_BRI - 1;\n      }\n\n      // draw 'breakindent': indent wrapped text accordingly\n      if (draw_state == WL_BRI - 1 && n_extra == 0) {\n        draw_state = WL_BRI;\n        // if need_showbreak is set, breakindent also applies\n        if (wp->w_p_bri && (row != startrow || need_showbreak)\n            && filler_lines == 0) {\n          char_attr = 0;\n\n          if (diff_hlf != (hlf_T)0) {\n            char_attr = win_hl_attr(wp, diff_hlf);\n          }\n          p_extra = NULL;\n          c_extra = ' ';\n          c_final = NUL;\n          n_extra =\n            get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, false));\n          if (row == startrow) {\n            n_extra -= win_col_off2(wp);\n            if (n_extra < 0) {\n              n_extra = 0;\n            }\n          }\n          if (wp->w_skipcol > 0 && wp->w_p_wrap && wp->w_briopt_sbr) {\n            need_showbreak = false;\n          }\n          // Correct end of highlighted area for 'breakindent',\n          // required wen 'linebreak' is also set.\n          if (tocol == vcol) {\n            tocol += n_extra;\n          }\n        }\n      }\n\n      if (draw_state == WL_SBR - 1 && n_extra == 0) {\n        draw_state = WL_SBR;\n        if (filler_todo > 0) {\n          // draw \"deleted\" diff line(s)\n          if (char2cells(wp->w_p_fcs_chars.diff) > 1) {\n            c_extra = '-';\n            c_final = NUL;\n          } else {\n            c_extra = wp->w_p_fcs_chars.diff;\n            c_final = NUL;\n          }\n          if (wp->w_p_rl) {\n            n_extra = col + 1;\n          } else {\n            n_extra = grid->Columns - col;\n          }\n          char_attr = win_hl_attr(wp, HLF_DED);\n        }\n        if (*p_sbr != NUL && need_showbreak) {\n          // Draw 'showbreak' at the start of each broken line.\n          p_extra = p_sbr;\n          c_extra = NUL;\n          c_final = NUL;\n          n_extra = (int)STRLEN(p_sbr);\n          char_attr = win_hl_attr(wp, HLF_AT);\n          if (wp->w_skipcol == 0 || !wp->w_p_wrap) {\n            need_showbreak = false;\n          }\n          vcol_sbr = vcol + MB_CHARLEN(p_sbr);\n          /* Correct end of highlighted area for 'showbreak',\n           * required when 'linebreak' is also set. */\n          if (tocol == vcol) {\n            tocol += n_extra;\n          }\n          // Combine 'showbreak' with 'cursorline', prioritizing 'showbreak'.\n          if (cul_attr) {\n            char_attr = hl_combine_attr(cul_attr, char_attr);\n          }\n        }\n      }\n\n      if (draw_state == WL_LINE - 1 && n_extra == 0) {\n        sign_idx = 0;\n        draw_state = WL_LINE;\n\n        if (has_decor && row == startrow + filler_lines) {\n          // hide virt_text on text hidden by 'nowrap'\n          decor_redraw_col(wp->w_buffer, vcol, off, true, &decor_state);\n        }\n\n        if (saved_n_extra) {\n          // Continue item from end of wrapped line.\n          n_extra = saved_n_extra;\n          c_extra = saved_c_extra;\n          c_final = saved_c_final;\n          p_extra = saved_p_extra;\n          char_attr = saved_char_attr;\n        } else {\n          char_attr = 0;\n        }\n      }\n    }\n\n    if (cul_screenline && draw_state == WL_LINE\n        && vcol >= left_curline_col\n        && vcol < right_curline_col) {\n      cul_attr = win_hl_attr(wp, HLF_CUL);\n      HlAttrs ae = syn_attr2entry(cul_attr);\n      if (ae.rgb_fg_color == -1 && ae.cterm_fg_color == 0) {\n        line_attr_lowprio = cul_attr;\n      } else {\n        if (!(State & INSERT) && bt_quickfix(wp->w_buffer)\n            && qf_current_entry(wp) == lnum) {\n          line_attr = hl_combine_attr(cul_attr, line_attr);\n        } else {\n          line_attr = cul_attr;\n        }\n      }\n    }\n\n    // When still displaying '$' of change command, stop at cursor\n    if (((dollar_vcol >= 0\n          && wp == curwin\n          && lnum == wp->w_cursor.lnum\n          && vcol >= (long)wp->w_virtcol)\n         || (number_only && draw_state > WL_NR))\n        && filler_todo <= 0) {\n      draw_virt_text(buf, win_col_offset, &col, grid->Columns);\n      grid_put_linebuf(grid, row, 0, col, -grid->Columns, wp->w_p_rl, wp,\n                       wp->w_hl_attr_normal, false);\n      // Pretend we have finished updating the window.  Except when\n      // 'cursorcolumn' is set.\n      if (wp->w_p_cuc) {\n        row = wp->w_cline_row + wp->w_cline_height;\n      } else {\n        row = grid->Rows;\n      }\n      break;\n    }\n\n    if (draw_state == WL_LINE\n        && has_fold\n        && vcol == 0\n        && n_extra == 0\n        && row == startrow) {\n      char_attr = win_hl_attr(wp, HLF_FL);\n\n      linenr_T lnume = lnum + foldinfo.fi_lines - 1;\n      memset(buf_fold, ' ', FOLD_TEXT_LEN);\n      p_extra = get_foldtext(wp, lnum, lnume, foldinfo, buf_fold);\n      n_extra = STRLEN(p_extra);\n\n      if (p_extra != buf_fold) {\n        xfree(p_extra_free);\n        p_extra_free = p_extra;\n      }\n      c_extra = NUL;\n      c_final = NUL;\n      p_extra[n_extra] = NUL;\n    }\n\n    if (draw_state == WL_LINE\n        && has_fold\n        && col < grid->Columns\n        && n_extra == 0\n        && row == startrow) {\n      // fill rest of line with 'fold'\n      c_extra = wp->w_p_fcs_chars.fold;\n      c_final = NUL;\n\n      n_extra = wp->w_p_rl ? (col + 1) : (grid->Columns - col);\n    }\n\n    if (draw_state == WL_LINE\n        && has_fold\n        && col >= grid->Columns\n        && n_extra != 0\n        && row == startrow) {\n      // Truncate the folding.\n      n_extra = 0;\n    }\n\n    if (draw_state == WL_LINE && (area_highlighting || has_spell)) {\n      // handle Visual or match highlighting in this line\n      if (vcol == fromcol\n          || (vcol + 1 == fromcol && n_extra == 0\n              && utf_ptr2cells(ptr) > 1)\n          || ((int)vcol_prev == fromcol_prev\n              && vcol_prev < vcol               // not at margin\n              && vcol < tocol)) {\n        area_attr = attr;                       // start highlighting\n        if (area_highlighting) {\n          area_active = true;\n        }\n      } else if (area_attr != 0 && (vcol == tocol\n                                    || (noinvcur\n                                        && (colnr_T)vcol == wp->w_virtcol))) {\n        area_attr = 0;                          // stop highlighting\n        area_active = false;\n      }\n\n      if (!n_extra) {\n        /*\n         * Check for start/end of search pattern match.\n         * After end, check for start/end of next match.\n         * When another match, have to check for start again.\n         * Watch out for matching an empty string!\n         * Do this for 'search_hl' and the match list (ordered by\n         * priority).\n         */\n        v = (long)(ptr - line);\n        cur = wp->w_match_head;\n        shl_flag = false;\n        while (cur != NULL || !shl_flag) {\n          if (!shl_flag\n              && (cur == NULL || cur->priority > SEARCH_HL_PRIORITY)) {\n            shl = &search_hl;\n            shl_flag = true;\n          } else {\n            shl = &cur->hl;\n          }\n          if (cur != NULL) {\n            cur->pos.cur = 0;\n          }\n          bool pos_inprogress = true;  // mark that a position match search is\n                                       // in progress\n          while (shl->rm.regprog != NULL\n                 || (cur != NULL && pos_inprogress)) {\n            if (shl->startcol != MAXCOL\n                && v >= (long)shl->startcol\n                && v < (long)shl->endcol) {\n              int tmp_col = v + utfc_ptr2len(ptr);\n\n              if (shl->endcol < tmp_col) {\n                shl->endcol = tmp_col;\n              }\n              shl->attr_cur = shl->attr;\n              // Match with the \"Conceal\" group results in hiding\n              // the match.\n              if (cur != NULL\n                  && shl != &search_hl\n                  && syn_name2id((char_u *)\"Conceal\") == cur->hlg_id) {\n                has_match_conc = v == (long)shl->startcol ? 2 : 1;\n                match_conc = cur->conceal_char;\n              } else {\n                has_match_conc = 0;\n              }\n            } else if (v == (long)shl->endcol) {\n              shl->attr_cur = 0;\n\n              next_search_hl(wp, shl, lnum, (colnr_T)v,\n                             shl == &search_hl ? NULL : cur);\n              pos_inprogress = !(cur == NULL || cur->pos.cur == 0);\n\n              // Need to get the line again, a multi-line regexp\n              // may have made it invalid.\n              line = ml_get_buf(wp->w_buffer, lnum, false);\n              ptr = line + v;\n\n              if (shl->lnum == lnum) {\n                shl->startcol = shl->rm.startpos[0].col;\n                if (shl->rm.endpos[0].lnum == 0) {\n                  shl->endcol = shl->rm.endpos[0].col;\n                } else {\n                  shl->endcol = MAXCOL;\n                }\n\n                if (shl->startcol == shl->endcol) {\n                  // highlight empty match, try again after it\n                  shl->endcol += (*mb_ptr2len)(line + shl->endcol);\n                }\n\n                // Loop to check if the match starts at the\n                // current position\n                continue;\n              }\n            }\n            break;\n          }\n          if (shl != &search_hl && cur != NULL) {\n            cur = cur->next;\n          }\n        }\n\n        /* Use attributes from match with highest priority among\n         * 'search_hl' and the match list. */\n        search_attr_from_match = false;\n        search_attr = search_hl.attr_cur;\n        cur = wp->w_match_head;\n        shl_flag = false;\n        while (cur != NULL || !shl_flag) {\n          if (!shl_flag\n              && (cur == NULL || cur->priority > SEARCH_HL_PRIORITY)) {\n            shl = &search_hl;\n            shl_flag = true;\n          } else {\n            shl = &cur->hl;\n          }\n          if (shl->attr_cur != 0) {\n            search_attr = shl->attr_cur;\n            search_attr_from_match = shl != &search_hl;\n          }\n          if (shl != &search_hl && cur != NULL) {\n            cur = cur->next;\n          }\n        }\n        // Only highlight one character after the last column.\n        if (*ptr == NUL\n            && (wp->w_p_list && lcs_eol_one == -1)) {\n          search_attr = 0;\n        }\n\n        // Do not allow a conceal over EOL otherwise EOL will be missed\n        // and bad things happen.\n        if (*ptr == NUL) {\n          has_match_conc = 0;\n        }\n      }\n\n      if (diff_hlf != (hlf_T)0) {\n        if (diff_hlf == HLF_CHD && ptr - line >= change_start\n            && n_extra == 0) {\n          diff_hlf = HLF_TXD;                   // changed text\n        }\n        if (diff_hlf == HLF_TXD && ptr - line > change_end\n            && n_extra == 0) {\n          diff_hlf = HLF_CHD;                   // changed line\n        }\n        line_attr = win_hl_attr(wp, diff_hlf);\n        // Overlay CursorLine onto diff-mode highlight.\n        if (cul_attr) {\n          line_attr = 0 != line_attr_lowprio  // Low-priority CursorLine\n            ? hl_combine_attr(hl_combine_attr(cul_attr, line_attr),\n                              hl_get_underline())\n            : hl_combine_attr(line_attr, cul_attr);\n        }\n      }\n\n      // Decide which of the highlight attributes to use.\n      attr_pri = true;\n\n      if (area_attr != 0) {\n        char_attr = hl_combine_attr(line_attr, area_attr);\n      } else if (search_attr != 0) {\n        char_attr = hl_combine_attr(line_attr, search_attr);\n      }\n      // Use line_attr when not in the Visual or 'incsearch' area\n      // (area_attr may be 0 when \"noinvcur\" is set).\n      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)\n                                  || vcol < fromcol || vcol_prev < fromcol_prev\n                                  || vcol >= tocol)) {\n        char_attr = line_attr;\n      } else {\n        attr_pri = false;\n        if (has_syntax) {\n          char_attr = syntax_attr;\n        } else {\n          char_attr = 0;\n        }\n      }\n    }\n\n    // Get the next character to put on the screen.\n    //\n    // The \"p_extra\" points to the extra stuff that is inserted to\n    // represent special characters (non-printable stuff) and other\n    // things.  When all characters are the same, c_extra is used.\n    // If c_final is set, it will compulsorily be used at the end.\n    // \"p_extra\" must end in a NUL to avoid mb_ptr2len() reads past\n    // \"p_extra[n_extra]\".\n    // For the '$' of the 'list' option, n_extra == 1, p_extra == \"\".\n    if (n_extra > 0) {\n      if (c_extra != NUL || (n_extra == 1 && c_final != NUL)) {\n        c = (n_extra == 1 && c_final != NUL) ? c_final : c_extra;\n        mb_c = c;               // doesn't handle non-utf-8 multi-byte!\n        if (utf_char2len(c) > 1) {\n          mb_utf8 = true;\n          u8cc[0] = 0;\n          c = 0xc0;\n        } else {\n          mb_utf8 = false;\n        }\n      } else {\n        assert(p_extra != NULL);\n        c = *p_extra;\n        mb_c = c;\n        // If the UTF-8 character is more than one byte:\n        // Decode it into \"mb_c\".\n        mb_l = utfc_ptr2len(p_extra);\n        mb_utf8 = false;\n        if (mb_l > n_extra) {\n          mb_l = 1;\n        } else if (mb_l > 1) {\n          mb_c = utfc_ptr2char(p_extra, u8cc);\n          mb_utf8 = true;\n          c = 0xc0;\n        }\n        if (mb_l == 0) {          // at the NUL at end-of-line\n          mb_l = 1;\n        }\n\n        // If a double-width char doesn't fit display a '>' in the last column.\n        if ((wp->w_p_rl ? (col <= 0) : (col >= grid->Columns - 1))\n            && (*mb_char2cells)(mb_c) == 2) {\n          c = '>';\n          mb_c = c;\n          mb_l = 1;\n          (void)mb_l;\n          multi_attr = win_hl_attr(wp, HLF_AT);\n\n          if (cul_attr) {\n            multi_attr = 0 != line_attr_lowprio\n              ? hl_combine_attr(cul_attr, multi_attr)\n              : hl_combine_attr(multi_attr, cul_attr);\n          }\n\n          // put the pointer back to output the double-width\n          // character at the start of the next line.\n          n_extra++;\n          p_extra--;\n        } else {\n          n_extra -= mb_l - 1;\n          p_extra += mb_l - 1;\n        }\n        p_extra++;\n      }\n      n_extra--;\n    } else if (foldinfo.fi_lines > 0) {\n      // skip writing the buffer line itself\n      c = NUL;\n      XFREE_CLEAR(p_extra_free);\n    } else {\n      int c0;\n\n      XFREE_CLEAR(p_extra_free);\n\n      // Get a character from the line itself.\n      c0 = c = *ptr;\n      mb_c = c;\n      // If the UTF-8 character is more than one byte: Decode it\n      // into \"mb_c\".\n      mb_l = utfc_ptr2len(ptr);\n      mb_utf8 = false;\n      if (mb_l > 1) {\n        mb_c = utfc_ptr2char(ptr, u8cc);\n        // Overlong encoded ASCII or ASCII with composing char\n        // is displayed normally, except a NUL.\n        if (mb_c < 0x80) {\n          c0 = c = mb_c;\n        }\n        mb_utf8 = true;\n\n        // At start of the line we can have a composing char.\n        // Draw it as a space with a composing char.\n        if (utf_iscomposing(mb_c)) {\n          int i;\n\n          for (i = MAX_MCO - 1; i > 0; i--) {\n            u8cc[i] = u8cc[i - 1];\n          }\n          u8cc[0] = mb_c;\n          mb_c = ' ';\n        }\n      }\n\n      if ((mb_l == 1 && c >= 0x80)\n          || (mb_l >= 1 && mb_c == 0)\n          || (mb_l > 1 && (!vim_isprintc(mb_c)))) {\n        // Illegal UTF-8 byte: display as <xx>.\n        // Non-BMP character : display as ? or fullwidth ?.\n        transchar_hex((char *)extra, mb_c);\n        if (wp->w_p_rl) {  // reverse\n          rl_mirror(extra);\n        }\n\n        p_extra = extra;\n        c = *p_extra;\n        mb_c = mb_ptr2char_adv((const char_u **)&p_extra);\n        mb_utf8 = (c >= 0x80);\n        n_extra = (int)STRLEN(p_extra);\n        c_extra = NUL;\n        c_final = NUL;\n        if (area_attr == 0 && search_attr == 0) {\n          n_attr = n_extra + 1;\n          extra_attr = win_hl_attr(wp, HLF_8);\n          saved_attr2 = char_attr;               // save current attr\n        }\n      } else if (mb_l == 0) {        // at the NUL at end-of-line\n        mb_l = 1;\n      } else if (p_arshape && !p_tbidi && arabic_char(mb_c)) {\n        // Do Arabic shaping.\n        int pc, pc1, nc;\n        int pcc[MAX_MCO];\n\n        // The idea of what is the previous and next\n        // character depends on 'rightleft'.\n        if (wp->w_p_rl) {\n          pc = prev_c;\n          pc1 = prev_c1;\n          nc = utf_ptr2char(ptr + mb_l);\n          prev_c1 = u8cc[0];\n        } else {\n          pc = utfc_ptr2char(ptr + mb_l, pcc);\n          nc = prev_c;\n          pc1 = pcc[0];\n        }\n        prev_c = mb_c;\n\n        mb_c = arabic_shape(mb_c, &c, &u8cc[0], pc, pc1, nc);\n      } else {\n        prev_c = mb_c;\n      }\n      // If a double-width char doesn't fit display a '>' in the\n      // last column; the character is displayed at the start of the\n      // next line.\n      if ((wp->w_p_rl ? (col <= 0) :\n           (col >= grid->Columns - 1))\n          && (*mb_char2cells)(mb_c) == 2) {\n        c = '>';\n        mb_c = c;\n        mb_utf8 = false;\n        mb_l = 1;\n        multi_attr = win_hl_attr(wp, HLF_AT);\n        // Put pointer back so that the character will be\n        // displayed at the start of the next line.\n        ptr--;\n        did_decrement_ptr = true;\n      } else if (*ptr != NUL) {\n        ptr += mb_l - 1;\n      }\n\n      // If a double-width char doesn't fit at the left side display a '<' in\n      // the first column.  Don't do this for unprintable characters.\n      if (n_skip > 0 && mb_l > 1 && n_extra == 0) {\n        n_extra = 1;\n        c_extra = MB_FILLER_CHAR;\n        c_final = NUL;\n        c = ' ';\n        if (area_attr == 0 && search_attr == 0) {\n          n_attr = n_extra + 1;\n          extra_attr = win_hl_attr(wp, HLF_AT);\n          saved_attr2 = char_attr;             // save current attr\n        }\n        mb_c = c;\n        mb_utf8 = false;\n        mb_l = 1;\n      }\n      ptr++;\n\n      if (extra_check) {\n        bool can_spell = true;\n\n        /* Get syntax attribute, unless still at the start of the line\n         * (double-wide char that doesn't fit). */\n        v = (long)(ptr - line);\n        if (has_syntax && v > 0) {\n          /* Get the syntax attribute for the character.  If there\n           * is an error, disable syntax highlighting. */\n          save_did_emsg = did_emsg;\n          did_emsg = FALSE;\n\n          syntax_attr = get_syntax_attr((colnr_T)v - 1,\n                                        has_spell ? &can_spell : NULL, false);\n\n          if (did_emsg) {\n            wp->w_s->b_syn_error = TRUE;\n            has_syntax = FALSE;\n          } else {\n            did_emsg = save_did_emsg;\n          }\n\n          // Need to get the line again, a multi-line regexp may\n          // have made it invalid.\n          line = ml_get_buf(wp->w_buffer, lnum, false);\n          ptr = line + v;\n\n          if (!attr_pri) {\n            if (cul_attr) {\n              char_attr = 0 != line_attr_lowprio\n                ? hl_combine_attr(cul_attr, syntax_attr)\n                : hl_combine_attr(syntax_attr, cul_attr);\n            } else {\n              char_attr = syntax_attr;\n            }\n          } else {\n            char_attr = hl_combine_attr(syntax_attr, char_attr);\n          }\n          // no concealing past the end of the line, it interferes\n          // with line highlighting.\n          if (c == NUL) {\n            syntax_flags = 0;\n          } else {\n            syntax_flags = get_syntax_info(&syntax_seqnr);\n          }\n        } else if (!attr_pri) {\n          char_attr = 0;\n        }\n\n        /* Check spelling (unless at the end of the line).\n         * Only do this when there is no syntax highlighting, the\n         * @Spell cluster is not used or the current syntax item\n         * contains the @Spell cluster. */\n        v = (long)(ptr - line);\n        if (has_spell && v >= word_end && v > cur_checked_col) {\n          spell_attr = 0;\n          if (!attr_pri) {\n            char_attr = syntax_attr;\n          }\n          if (c != 0 && (!has_syntax || can_spell)) {\n            char_u *prev_ptr;\n            char_u *p;\n            int len;\n            hlf_T spell_hlf = HLF_COUNT;\n            prev_ptr = ptr - mb_l;\n            v -= mb_l - 1;\n\n            /* Use nextline[] if possible, it has the start of the\n             * next line concatenated. */\n            if ((prev_ptr - line) - nextlinecol >= 0) {\n              p = nextline + ((prev_ptr - line) - nextlinecol);\n            } else {\n              p = prev_ptr;\n            }\n            cap_col -= (int)(prev_ptr - line);\n            size_t tmplen = spell_check(wp, p, &spell_hlf, &cap_col, nochange);\n            assert(tmplen <= INT_MAX);\n            len = (int)tmplen;\n            word_end = v + len;\n\n            /* In Insert mode only highlight a word that\n             * doesn't touch the cursor. */\n            if (spell_hlf != HLF_COUNT\n                && (State & INSERT) != 0\n                && wp->w_cursor.lnum == lnum\n                && wp->w_cursor.col >=\n                (colnr_T)(prev_ptr - line)\n                && wp->w_cursor.col < (colnr_T)word_end) {\n              spell_hlf = HLF_COUNT;\n              spell_redraw_lnum = lnum;\n            }\n\n            if (spell_hlf == HLF_COUNT && p != prev_ptr\n                && (p - nextline) + len > nextline_idx) {\n              /* Remember that the good word continues at the\n               * start of the next line. */\n              checked_lnum = lnum + 1;\n              checked_col = (int)((p - nextline) + len - nextline_idx);\n            }\n\n            // Turn index into actual attributes.\n            if (spell_hlf != HLF_COUNT) {\n              spell_attr = highlight_attr[spell_hlf];\n            }\n\n            if (cap_col > 0) {\n              if (p != prev_ptr\n                  && (p - nextline) + cap_col >= nextline_idx) {\n                /* Remember that the word in the next line\n                 * must start with a capital. */\n                capcol_lnum = lnum + 1;\n                cap_col = (int)((p - nextline) + cap_col\n                                - nextline_idx);\n              } else {\n                // Compute the actual column.\n                cap_col += (int)(prev_ptr - line);\n              }\n            }\n          }\n        }\n        if (spell_attr != 0) {\n          if (!attr_pri) {\n            char_attr = hl_combine_attr(char_attr, spell_attr);\n          } else {\n            char_attr = hl_combine_attr(spell_attr, char_attr);\n          }\n        }\n\n        if (wp->w_buffer->terminal) {\n          char_attr = hl_combine_attr(term_attrs[vcol], char_attr);\n        }\n\n        if (has_decor && v > 0) {\n          bool selected = (area_active || (area_highlighting && noinvcur\n                                           && (colnr_T)vcol == wp->w_virtcol));\n          int extmark_attr = decor_redraw_col(wp->w_buffer, (colnr_T)v-1, off,\n                                              selected, &decor_state);\n          if (extmark_attr != 0) {\n            if (!attr_pri) {\n              char_attr = hl_combine_attr(char_attr, extmark_attr);\n            } else {\n              char_attr = hl_combine_attr(extmark_attr, char_attr);\n            }\n          }\n        }\n\n        // Found last space before word: check for line break.\n        if (wp->w_p_lbr && c0 == c && vim_isbreak(c)\n            && !vim_isbreak((int)(*ptr))) {\n          int mb_off = utf_head_off(line, ptr - 1);\n          char_u *p = ptr - (mb_off + 1);\n          // TODO: is passing p for start of the line OK?\n          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;\n          if (c == TAB && n_extra + col > grid->Columns) {\n            n_extra = tabstop_padding(vcol, wp->w_buffer->b_p_ts,\n                                      wp->w_buffer->b_p_vts_array) - 1;\n          }\n          c_extra = mb_off > 0 ? MB_FILLER_CHAR : ' ';\n          c_final = NUL;\n          if (ascii_iswhite(c)) {\n            if (c == TAB) {\n              // See \"Tab alignment\" below.\n              FIX_FOR_BOGUSCOLS;\n            }\n            if (!wp->w_p_list) {\n              c = ' ';\n            }\n          }\n        }\n\n        // 'list': change char 160 to 'nbsp' and space to 'space'.\n        if (wp->w_p_list\n            && (((c == 160\n                  || (mb_utf8 && (mb_c == 160 || mb_c == 0x202f)))\n                 && curwin->w_p_lcs_chars.nbsp)\n                || (c == ' ' && curwin->w_p_lcs_chars.space\n                    && ptr - line >= leadcol\n                    && ptr - line <= trailcol))) {\n          c = (c == ' ') ? wp->w_p_lcs_chars.space : wp->w_p_lcs_chars.nbsp;\n          n_attr = 1;\n          extra_attr = win_hl_attr(wp, HLF_0);\n          saved_attr2 = char_attr;  // save current attr\n          mb_c = c;\n          if (utf_char2len(c) > 1) {\n            mb_utf8 = true;\n            u8cc[0] = 0;\n            c = 0xc0;\n          } else {\n            mb_utf8 = false;\n          }\n        }\n\n        if ((trailcol != MAXCOL && ptr > line + trailcol && c == ' ')\n            || (leadcol != 0 && ptr < line + leadcol && c == ' ')) {\n          c = (ptr > line + trailcol) ? wp->w_p_lcs_chars.trail\n                                      : wp->w_p_lcs_chars.lead;\n          n_attr = 1;\n          extra_attr = win_hl_attr(wp, HLF_0);\n          saved_attr2 = char_attr;  // save current attr\n          mb_c = c;\n          if (utf_char2len(c) > 1) {\n            mb_utf8 = true;\n            u8cc[0] = 0;\n            c = 0xc0;\n          } else {\n            mb_utf8 = false;\n          }\n        }\n      }\n\n      /*\n       * Handling of non-printable characters.\n       */\n      if (!vim_isprintc(c)) {\n        // when getting a character from the file, we may have to\n        // turn it into something else on the way to putting it on the screen.\n        if (c == TAB && (!wp->w_p_list || wp->w_p_lcs_chars.tab1)) {\n          int tab_len = 0;\n          long vcol_adjusted = vcol;  // removed showbreak length\n          // Only adjust the tab_len, when at the first column after the\n          // showbreak value was drawn.\n          if (*p_sbr != NUL && vcol == vcol_sbr && wp->w_p_wrap) {\n            vcol_adjusted = vcol - MB_CHARLEN(p_sbr);\n          }\n          // tab amount depends on current column\n          tab_len = tabstop_padding(vcol_adjusted,\n                                    wp->w_buffer->b_p_ts,\n                                    wp->w_buffer->b_p_vts_array) - 1;\n\n          if (!wp->w_p_lbr || !wp->w_p_list) {\n            n_extra = tab_len;\n          } else {\n            char_u *p;\n            int    i;\n            int    saved_nextra = n_extra;\n\n            if (vcol_off > 0) {\n              // there are characters to conceal\n              tab_len += vcol_off;\n            }\n            // boguscols before FIX_FOR_BOGUSCOLS macro from above.\n            if (wp->w_p_lcs_chars.tab1 && old_boguscols > 0\n                && n_extra > tab_len) {\n              tab_len += n_extra - tab_len;\n            }\n\n            // if n_extra > 0, it gives the number of chars\n            // to use for a tab, else we need to calculate the width\n            // for a tab\n            int len = (tab_len * mb_char2len(wp->w_p_lcs_chars.tab2));\n            if (n_extra > 0) {\n              len += n_extra - tab_len;\n            }\n            c = wp->w_p_lcs_chars.tab1;\n            p = xmalloc(len + 1);\n            memset(p, ' ', len);\n            p[len] = NUL;\n            xfree(p_extra_free);\n            p_extra_free = p;\n            for (i = 0; i < tab_len; i++) {\n              if (*p == NUL) {\n                tab_len = i;\n                break;\n              }\n              int lcs = wp->w_p_lcs_chars.tab2;\n\n              // if tab3 is given, need to change the char\n              // for tab\n              if (wp->w_p_lcs_chars.tab3 && i == tab_len - 1) {\n                lcs = wp->w_p_lcs_chars.tab3;\n              }\n              utf_char2bytes(lcs, p);\n              p += mb_char2len(lcs);\n              n_extra += mb_char2len(lcs) - (saved_nextra > 0 ? 1 : 0);\n            }\n            p_extra = p_extra_free;\n\n            // n_extra will be increased by FIX_FOX_BOGUSCOLS\n            // macro below, so need to adjust for that here\n            if (vcol_off > 0) {\n              n_extra -= vcol_off;\n            }\n          }\n\n          {\n            int vc_saved = vcol_off;\n\n            // Tab alignment should be identical regardless of\n            // 'conceallevel' value. So tab compensates of all\n            // previous concealed characters, and thus resets\n            // vcol_off and boguscols accumulated so far in the\n            // line. Note that the tab can be longer than\n            // 'tabstop' when there are concealed characters.\n            FIX_FOR_BOGUSCOLS;\n\n            // Make sure, the highlighting for the tab char will be\n            // correctly set further below (effectively reverts the\n            // FIX_FOR_BOGSUCOLS macro.\n            if (n_extra == tab_len + vc_saved && wp->w_p_list\n                && wp->w_p_lcs_chars.tab1) {\n              tab_len += vc_saved;\n            }\n          }\n\n          mb_utf8 = false;  // don't draw as UTF-8\n          if (wp->w_p_list) {\n            c = (n_extra == 0 && wp->w_p_lcs_chars.tab3)\n                 ? wp->w_p_lcs_chars.tab3\n                 : wp->w_p_lcs_chars.tab1;\n            if (wp->w_p_lbr) {\n              c_extra = NUL;  // using p_extra from above\n            } else {\n              c_extra = wp->w_p_lcs_chars.tab2;\n            }\n            c_final = wp->w_p_lcs_chars.tab3;\n            n_attr = tab_len + 1;\n            extra_attr = win_hl_attr(wp, HLF_0);\n            saved_attr2 = char_attr;  // save current attr\n            mb_c = c;\n            if (utf_char2len(c) > 1) {\n              mb_utf8 = true;\n              u8cc[0] = 0;\n              c = 0xc0;\n            }\n          } else {\n            c_final = NUL;\n            c_extra = ' ';\n            c = ' ';\n          }\n        } else if (c == NUL\n                   && (wp->w_p_list\n                       || ((fromcol >= 0 || fromcol_prev >= 0)\n                           && tocol > vcol\n                           && VIsual_mode != Ctrl_V\n                           && (wp->w_p_rl ? (col >= 0) : (col < grid->Columns))\n                           && !(noinvcur\n                                && lnum == wp->w_cursor.lnum\n                                && (colnr_T)vcol == wp->w_virtcol)))\n                   && lcs_eol_one > 0) {\n          // Display a '$' after the line or highlight an extra\n          // character if the line break is included.\n          // For a diff line the highlighting continues after the \"$\".\n          if (diff_hlf == (hlf_T)0\n              && line_attr == 0\n              && line_attr_lowprio == 0) {\n            // In virtualedit, visual selections may extend beyond end of line\n            if (area_highlighting && virtual_active()\n                && tocol != MAXCOL && vcol < tocol) {\n              n_extra = 0;\n            } else {\n              p_extra = at_end_str;\n              n_extra = 1;\n              c_extra = NUL;\n              c_final = NUL;\n            }\n          }\n          if (wp->w_p_list && wp->w_p_lcs_chars.eol > 0) {\n            c = wp->w_p_lcs_chars.eol;\n          } else {\n            c = ' ';\n          }\n          lcs_eol_one = -1;\n          ptr--;  // put it back at the NUL\n          extra_attr = win_hl_attr(wp, HLF_AT);\n          n_attr = 1;\n          mb_c = c;\n          if (utf_char2len(c) > 1) {\n            mb_utf8 = true;\n            u8cc[0] = 0;\n            c = 0xc0;\n          } else {\n            mb_utf8 = false;                    // don't draw as UTF-8\n          }\n        } else if (c != NUL) {\n          p_extra = transchar_buf(wp->w_buffer, c);\n          if (n_extra == 0) {\n            n_extra = byte2cells(c) - 1;\n          }\n          if ((dy_flags & DY_UHEX) && wp->w_p_rl) {\n            rl_mirror(p_extra);                 // reverse \"<12>\"\n          }\n          c_extra = NUL;\n          c_final = NUL;\n          if (wp->w_p_lbr) {\n            char_u *p;\n\n            c = *p_extra;\n            p = xmalloc(n_extra + 1);\n            memset(p, ' ', n_extra);\n            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);\n            p[n_extra] = NUL;\n            xfree(p_extra_free);\n            p_extra_free = p_extra = p;\n          } else {\n            n_extra = byte2cells(c) - 1;\n            c = *p_extra++;\n          }\n          n_attr = n_extra + 1;\n          extra_attr = win_hl_attr(wp, HLF_8);\n          saved_attr2 = char_attr;  // save current attr\n          mb_utf8 = false;   // don't draw as UTF-8\n        } else if (VIsual_active\n                   && (VIsual_mode == Ctrl_V || VIsual_mode == 'v')\n                   && virtual_active()\n                   && tocol != MAXCOL\n                   && vcol < tocol\n                   && (wp->w_p_rl ? (col >= 0) : (col < grid->Columns))) {\n          c = ' ';\n          ptr--;  // put it back at the NUL\n        }\n      }\n\n      if (wp->w_p_cole > 0\n          && (wp != curwin || lnum != wp->w_cursor.lnum\n              || conceal_cursor_line(wp))\n          && ((syntax_flags & HL_CONCEAL) != 0 || has_match_conc > 0)\n          && !(lnum_in_visual_area\n               && vim_strchr(wp->w_p_cocu, 'v') == NULL)) {\n        char_attr = conceal_attr;\n        if ((prev_syntax_id != syntax_seqnr || has_match_conc > 1)\n            && (syn_get_sub_char() != NUL\n                || (has_match_conc && match_conc)\n                || wp->w_p_cole == 1)\n            && wp->w_p_cole != 3) {\n          // First time at this concealed item: display one\n          // character.\n          if (has_match_conc && match_conc) {\n            c = match_conc;\n          } else if (syn_get_sub_char() != NUL) {\n            c = syn_get_sub_char();\n          } else if (wp->w_p_lcs_chars.conceal != NUL) {\n            c = wp->w_p_lcs_chars.conceal;\n          } else {\n            c = ' ';\n          }\n\n          prev_syntax_id = syntax_seqnr;\n\n          if (n_extra > 0) {\n            vcol_off += n_extra;\n          }\n          vcol += n_extra;\n          if (wp->w_p_wrap && n_extra > 0) {\n            if (wp->w_p_rl) {\n              col -= n_extra;\n              boguscols -= n_extra;\n            } else {\n              boguscols += n_extra;\n              col += n_extra;\n            }\n          }\n          n_extra = 0;\n          n_attr = 0;\n        } else if (n_skip == 0) {\n          is_concealing = true;\n          n_skip = 1;\n        }\n        mb_c = c;\n        if (utf_char2len(c) > 1) {\n          mb_utf8 = true;\n          u8cc[0] = 0;\n          c = 0xc0;\n        } else {\n          mb_utf8 = false;              // don't draw as UTF-8\n        }\n      } else {\n        prev_syntax_id = 0;\n        is_concealing = false;\n      }\n\n      if (n_skip > 0 && did_decrement_ptr) {\n        // not showing the '>', put pointer back to avoid getting stuck\n        ptr++;\n      }\n    }  // end of printing from buffer content\n\n    /* In the cursor line and we may be concealing characters: correct\n     * the cursor column when we reach its position. */\n    if (!did_wcol && draw_state == WL_LINE\n        && wp == curwin && lnum == wp->w_cursor.lnum\n        && conceal_cursor_line(wp)\n        && (int)wp->w_virtcol <= vcol + n_skip) {\n      if (wp->w_p_rl) {\n        wp->w_wcol = grid->Columns - col + boguscols - 1;\n      } else {\n        wp->w_wcol = col - boguscols;\n      }\n      wp->w_wrow = row;\n      did_wcol = true;\n      wp->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n    }\n\n    // Don't override visual selection highlighting.\n    if (n_attr > 0 && draw_state == WL_LINE && !search_attr_from_match) {\n      char_attr = hl_combine_attr(char_attr, extra_attr);\n    }\n\n    // Handle the case where we are in column 0 but not on the first\n    // character of the line and the user wants us to show us a\n    // special character (via 'listchars' option \"precedes:<char>\".\n    if (lcs_prec_todo != NUL\n        && wp->w_p_list\n        && (wp->w_p_wrap ? (wp->w_skipcol > 0 && row == 0) : wp->w_leftcol > 0)\n        && filler_todo <= 0\n        && draw_state > WL_NR\n        && c != NUL) {\n      c = wp->w_p_lcs_chars.prec;\n      lcs_prec_todo = NUL;\n      if ((*mb_char2cells)(mb_c) > 1) {\n        // Double-width character being overwritten by the \"precedes\"\n        // character, need to fill up half the character.\n        c_extra = MB_FILLER_CHAR;\n        c_final = NUL;\n        n_extra = 1;\n        n_attr = 2;\n        extra_attr = win_hl_attr(wp, HLF_AT);\n      }\n      mb_c = c;\n      if (utf_char2len(c) > 1) {\n        mb_utf8 = true;\n        u8cc[0] = 0;\n        c = 0xc0;\n      } else {\n        mb_utf8 = false;  // don't draw as UTF-8\n      }\n      saved_attr3 = char_attr;  // save current attr\n      char_attr = win_hl_attr(wp, HLF_AT);  // overwriting char_attr\n      n_attr3 = 1;\n    }\n\n    // At end of the text line or just after the last character.\n    if (c == NUL && eol_hl_off == 0) {\n      long prevcol = (long)(ptr - line) - 1;\n\n      // we're not really at that column when skipping some text\n      if ((long)(wp->w_p_wrap ? wp->w_skipcol : wp->w_leftcol) > prevcol) {\n        prevcol++;\n      }\n\n      // Invert at least one char, used for Visual and empty line or\n      // highlight match at end of line. If it's beyond the last\n      // char on the screen, just overwrite that one (tricky!)  Not\n      // needed when a '$' was displayed for 'list'.\n      prevcol_hl_flag = false;\n      if (!search_hl.is_addpos && prevcol == (long)search_hl.startcol) {\n        prevcol_hl_flag = true;\n      } else {\n        cur = wp->w_match_head;\n        while (cur != NULL) {\n          if (!cur->hl.is_addpos && prevcol == (long)cur->hl.startcol) {\n            prevcol_hl_flag = true;\n            break;\n          }\n          cur = cur->next;\n        }\n      }\n      if (wp->w_p_lcs_chars.eol == lcs_eol_one\n          && ((area_attr != 0 && vcol == fromcol\n               && (VIsual_mode != Ctrl_V\n                   || lnum == VIsual.lnum\n                   || lnum == curwin->w_cursor.lnum))\n              // highlight 'hlsearch' match at end of line\n              || prevcol_hl_flag)) {\n        int n = 0;\n\n        if (wp->w_p_rl) {\n          if (col < 0) {\n            n = 1;\n          }\n        } else {\n          if (col >= grid->Columns) {\n            n = -1;\n          }\n        }\n        if (n != 0) {\n          /* At the window boundary, highlight the last character\n           * instead (better than nothing). */\n          off += n;\n          col += n;\n        } else {\n          // Add a blank character to highlight.\n          schar_from_ascii(linebuf_char[off], ' ');\n        }\n        if (area_attr == 0 && !has_fold) {\n          // Use attributes from match with highest priority among\n          // 'search_hl' and the match list.\n          char_attr = search_hl.attr;\n          cur = wp->w_match_head;\n          shl_flag = false;\n          while (cur != NULL || !shl_flag) {\n            if (!shl_flag\n                && (cur == NULL || cur->priority > SEARCH_HL_PRIORITY)) {\n              shl = &search_hl;\n              shl_flag = true;\n            } else {\n              shl = &cur->hl;\n            }\n            if ((ptr - line) - 1 == (long)shl->startcol\n                && (shl == &search_hl || !shl->is_addpos)) {\n              char_attr = shl->attr;\n            }\n            if (shl != &search_hl && cur != NULL) {\n              cur = cur->next;\n            }\n          }\n        }\n\n        int eol_attr = char_attr;\n        if (cul_attr) {\n          eol_attr = hl_combine_attr(cul_attr, eol_attr);\n        }\n        linebuf_attr[off] = eol_attr;\n        if (wp->w_p_rl) {\n          --col;\n          --off;\n        } else {\n          ++col;\n          ++off;\n        }\n        ++vcol;\n        eol_hl_off = 1;\n      }\n      // Highlight 'cursorcolumn' & 'colorcolumn' past end of the line.\n      if (wp->w_p_wrap) {\n        v = wp->w_skipcol;\n      } else {\n        v = wp->w_leftcol;\n      }\n\n      // check if line ends before left margin\n      if (vcol < v + col - win_col_off(wp)) {\n        vcol = v + col - win_col_off(wp);\n      }\n      // Get rid of the boguscols now, we want to draw until the right\n      // edge for 'cursorcolumn'.\n      col -= boguscols;\n      // boguscols = 0;  // Disabled because value never read after this\n\n      if (draw_color_col) {\n        draw_color_col = advance_color_col(VCOL_HLC, &color_cols);\n      }\n\n      bool has_virttext = false;\n      // Make sure alignment is the same regardless\n      // if listchars=eol:X is used or not.\n      int eol_skip = (wp->w_p_lcs_chars.eol == lcs_eol_one && eol_hl_off == 0\n                      ? 1 : 0);\n\n      if (has_decor) {\n        has_virttext = decor_redraw_eol(wp->w_buffer, &decor_state, &line_attr,\n                                        col + eol_skip);\n      }\n\n      if (((wp->w_p_cuc\n            && (int)wp->w_virtcol >= VCOL_HLC - eol_hl_off\n            && (int)wp->w_virtcol <\n            grid->Columns * (row - startrow + 1) + v\n            && lnum != wp->w_cursor.lnum)\n           || draw_color_col || line_attr_lowprio || line_attr\n           || diff_hlf != (hlf_T)0 || has_virttext)) {\n        int rightmost_vcol = 0;\n        int i;\n\n        if (wp->w_p_cuc) {\n          rightmost_vcol = wp->w_virtcol;\n        }\n\n        if (draw_color_col) {\n          // determine rightmost colorcolumn to possibly draw\n          for (i = 0; color_cols[i] >= 0; i++) {\n            if (rightmost_vcol < color_cols[i]) {\n              rightmost_vcol = color_cols[i];\n            }\n          }\n        }\n\n        int cuc_attr = win_hl_attr(wp, HLF_CUC);\n        int mc_attr = win_hl_attr(wp, HLF_MC);\n\n        int diff_attr = 0;\n        if (diff_hlf == HLF_TXD) {\n          diff_hlf = HLF_CHD;\n        }\n        if (diff_hlf != 0) {\n          diff_attr = win_hl_attr(wp, diff_hlf);\n        }\n\n        int base_attr = hl_combine_attr(line_attr_lowprio, diff_attr);\n        if (base_attr || line_attr || has_virttext) {\n          rightmost_vcol = INT_MAX;\n        }\n\n        int col_stride = wp->w_p_rl ? -1 : 1;\n\n        while (wp->w_p_rl ? col >= 0 : col < grid->Columns) {\n          schar_from_ascii(linebuf_char[off], ' ');\n          col += col_stride;\n          if (draw_color_col) {\n            draw_color_col = advance_color_col(VCOL_HLC, &color_cols);\n          }\n\n          int col_attr = base_attr;\n\n          if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol) {\n            col_attr = cuc_attr;\n          } else if (draw_color_col && VCOL_HLC == *color_cols) {\n            col_attr = mc_attr;\n          }\n\n          col_attr = hl_combine_attr(col_attr, line_attr);\n\n          linebuf_attr[off] = col_attr;\n          off += col_stride;\n\n          if (VCOL_HLC >= rightmost_vcol) {\n            break;\n          }\n\n          vcol += 1;\n        }\n      }\n\n      // TODO(bfredl): integrate with the common beyond-the-end-loop\n      if (wp->w_buffer->terminal) {\n        // terminal buffers may need to highlight beyond the end of the\n        // logical line\n        int n = wp->w_p_rl ? -1 : 1;\n        while (col >= 0 && col < grid->Columns) {\n          schar_from_ascii(linebuf_char[off], ' ');\n          linebuf_attr[off] = vcol >= TERM_ATTRS_MAX ? 0 : term_attrs[vcol];\n          off += n;\n          vcol += n;\n          col += n;\n        }\n      }\n\n      draw_virt_text(buf, win_col_offset, &col, grid->Columns);\n      grid_put_linebuf(grid, row, 0, col, grid->Columns, wp->w_p_rl, wp,\n                       wp->w_hl_attr_normal, false);\n      row++;\n\n      /*\n       * Update w_cline_height and w_cline_folded if the cursor line was\n       * updated (saves a call to plines_win() later).\n       */\n      if (wp == curwin && lnum == curwin->w_cursor.lnum) {\n        curwin->w_cline_row = startrow;\n        curwin->w_cline_height = row - startrow;\n        curwin->w_cline_folded = foldinfo.fi_lines > 0;\n        curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);\n        conceal_cursor_used = conceal_cursor_line(curwin);\n      }\n      break;\n    }\n\n    // Show \"extends\" character from 'listchars' if beyond the line end and\n    // 'list' is set.\n    if (wp->w_p_lcs_chars.ext != NUL\n        && wp->w_p_list\n        && !wp->w_p_wrap\n        && filler_todo <= 0\n        && (wp->w_p_rl ? col == 0 : col == grid->Columns - 1)\n        && !has_fold\n        && (*ptr != NUL\n            || lcs_eol_one > 0\n            || (n_extra && (c_extra != NUL || *p_extra != NUL)))) {\n      c = wp->w_p_lcs_chars.ext;\n      char_attr = win_hl_attr(wp, HLF_AT);\n      mb_c = c;\n      if (utf_char2len(c) > 1) {\n        mb_utf8 = true;\n        u8cc[0] = 0;\n        c = 0xc0;\n      } else {\n        mb_utf8 = false;\n      }\n    }\n\n    // advance to the next 'colorcolumn'\n    if (draw_color_col) {\n      draw_color_col = advance_color_col(VCOL_HLC, &color_cols);\n    }\n\n    // Highlight the cursor column if 'cursorcolumn' is set.  But don't\n    // highlight the cursor position itself.\n    // Also highlight the 'colorcolumn' if it is different than\n    // 'cursorcolumn'\n    // Also highlight the 'colorcolumn' if 'breakindent' and/or 'showbreak'\n    // options are set\n    vcol_save_attr = -1;\n    if ((draw_state == WL_LINE\n         || draw_state == WL_BRI\n         || draw_state == WL_SBR)\n        && !lnum_in_visual_area\n        && search_attr == 0\n        && area_attr == 0\n        && filler_todo <= 0) {\n      if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol\n          && lnum != wp->w_cursor.lnum) {\n        vcol_save_attr = char_attr;\n        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUC), char_attr);\n      } else if (draw_color_col && VCOL_HLC == *color_cols) {\n        vcol_save_attr = char_attr;\n        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_MC), char_attr);\n      }\n    }\n\n    // Apply lowest-priority line attr now, so everything can override it.\n    if (draw_state == WL_LINE) {\n      char_attr = hl_combine_attr(line_attr_lowprio, char_attr);\n    }\n\n    // Store character to be displayed.\n    // Skip characters that are left of the screen for 'nowrap'.\n    vcol_prev = vcol;\n    if (draw_state < WL_LINE || n_skip <= 0) {\n      //\n      // Store the character.\n      //\n      if (wp->w_p_rl && (*mb_char2cells)(mb_c) > 1) {\n        // A double-wide character is: put first halve in left cell.\n        off--;\n        col--;\n      }\n      if (mb_utf8) {\n        schar_from_cc(linebuf_char[off], mb_c, u8cc);\n      } else {\n        schar_from_ascii(linebuf_char[off], c);\n      }\n      if (multi_attr) {\n        linebuf_attr[off] = multi_attr;\n        multi_attr = 0;\n      } else {\n        linebuf_attr[off] = char_attr;\n      }\n\n      if ((*mb_char2cells)(mb_c) > 1) {\n        // Need to fill two screen columns.\n        off++;\n        col++;\n        // UTF-8: Put a 0 in the second screen char.\n        linebuf_char[off][0] = 0;\n        if (draw_state > WL_NR && filler_todo <= 0) {\n          vcol++;\n        }\n        // When \"tocol\" is halfway through a character, set it to the end of\n        // the character, otherwise highlighting won't stop.\n        if (tocol == vcol) {\n          tocol++;\n        }\n        if (wp->w_p_rl) {\n          // now it's time to backup one cell\n          --off;\n          --col;\n        }\n      }\n      if (wp->w_p_rl) {\n        --off;\n        --col;\n      } else {\n        ++off;\n        ++col;\n      }\n    } else if (wp->w_p_cole > 0 && is_concealing) {\n      --n_skip;\n      ++vcol_off;\n      if (n_extra > 0) {\n        vcol_off += n_extra;\n      }\n      if (wp->w_p_wrap) {\n        /*\n         * Special voodoo required if 'wrap' is on.\n         *\n         * Advance the column indicator to force the line\n         * drawing to wrap early. This will make the line\n         * take up the same screen space when parts are concealed,\n         * so that cursor line computations aren't messed up.\n         *\n         * To avoid the fictitious advance of 'col' causing\n         * trailing junk to be written out of the screen line\n         * we are building, 'boguscols' keeps track of the number\n         * of bad columns we have advanced.\n         */\n        if (n_extra > 0) {\n          vcol += n_extra;\n          if (wp->w_p_rl) {\n            col -= n_extra;\n            boguscols -= n_extra;\n          } else {\n            col += n_extra;\n            boguscols += n_extra;\n          }\n          n_extra = 0;\n          n_attr = 0;\n        }\n\n\n        if ((*mb_char2cells)(mb_c) > 1) {\n          // Need to fill two screen columns.\n          if (wp->w_p_rl) {\n            --boguscols;\n            --col;\n          } else {\n            ++boguscols;\n            ++col;\n          }\n        }\n\n        if (wp->w_p_rl) {\n          --boguscols;\n          --col;\n        } else {\n          ++boguscols;\n          ++col;\n        }\n      } else {\n        if (n_extra > 0) {\n          vcol += n_extra;\n          n_extra = 0;\n          n_attr = 0;\n        }\n      }\n    } else {\n      --n_skip;\n    }\n\n    /* Only advance the \"vcol\" when after the 'number' or 'relativenumber'\n     * column. */\n    if (draw_state > WL_NR\n        && filler_todo <= 0) {\n      ++vcol;\n    }\n\n    if (vcol_save_attr >= 0) {\n      char_attr = vcol_save_attr;\n    }\n\n    // restore attributes after \"predeces\" in 'listchars'\n    if (draw_state > WL_NR && n_attr3 > 0 && --n_attr3 == 0) {\n      char_attr = saved_attr3;\n    }\n\n    // restore attributes after last 'listchars' or 'number' char\n    if (n_attr > 0 && draw_state == WL_LINE && --n_attr == 0) {\n      char_attr = saved_attr2;\n    }\n\n    /*\n     * At end of screen line and there is more to come: Display the line\n     * so far.  If there is no more to display it is caught above.\n     */\n    if ((wp->w_p_rl ? (col < 0) : (col >= grid->Columns))\n        && foldinfo.fi_lines == 0\n        && (*ptr != NUL\n            || filler_todo > 0\n            || (wp->w_p_list && wp->w_p_lcs_chars.eol != NUL\n                && p_extra != at_end_str)\n            || (n_extra != 0 &&\n                (c_extra != NUL || *p_extra != NUL)))) {\n      bool wrap = wp->w_p_wrap       // Wrapping enabled.\n                  && filler_todo <= 0          // Not drawing diff filler lines.\n                  && lcs_eol_one != -1         // Haven't printed the lcs_eol character.\n                  && row != endrow - 1         // Not the last line being displayed.\n                  && (grid->Columns == Columns  // Window spans the width of the screen,\n                      || ui_has(kUIMultigrid))  // or has dedicated grid.\n                  && !wp->w_p_rl;              // Not right-to-left.\n\n      int draw_col = col - boguscols;\n      draw_virt_text(buf, win_col_offset, &draw_col, grid->Columns);\n      grid_put_linebuf(grid, row, 0, draw_col, grid->Columns, wp->w_p_rl,\n                       wp, wp->w_hl_attr_normal, wrap);\n      if (wrap) {\n        ScreenGrid *current_grid = grid;\n        int current_row = row, dummy_col = 0;  // dummy_col unused\n        screen_adjust_grid(&current_grid, &current_row, &dummy_col);\n\n        // Force a redraw of the first column of the next line.\n        current_grid->attrs[current_grid->line_offset[current_row+1]] = -1;\n\n        // Remember that the line wraps, used for modeless copy.\n        current_grid->line_wraps[current_row] = true;\n      }\n\n      boguscols = 0;\n      row++;\n\n      /* When not wrapping and finished diff lines, or when displayed\n       * '$' and highlighting until last column, break here. */\n      if ((!wp->w_p_wrap\n           && filler_todo <= 0\n           ) || lcs_eol_one == -1) {\n        break;\n      }\n\n      // When the window is too narrow draw all \"@\" lines.\n      if (draw_state != WL_LINE && filler_todo <= 0) {\n        win_draw_end(wp, '@', ' ', true, row, wp->w_grid.Rows, HLF_AT);\n        row = endrow;\n      }\n\n      // When line got too long for screen break here.\n      if (row == endrow) {\n        ++row;\n        break;\n      }\n\n      col = 0;\n      off = 0;\n      if (wp->w_p_rl) {\n        col = grid->Columns - 1;  // col is not used if breaking!\n        off += col;\n      }\n\n      // reset the drawing state for the start of a wrapped line\n      draw_state = WL_START;\n      saved_n_extra = n_extra;\n      saved_p_extra = p_extra;\n      saved_c_extra = c_extra;\n      saved_c_final = c_final;\n      saved_char_attr = char_attr;\n      n_extra = 0;\n      lcs_prec_todo = wp->w_p_lcs_chars.prec;\n      if (filler_todo <= 0) {\n        need_showbreak = true;\n      }\n      filler_todo--;\n      // When the filler lines are actually below the last line of the\n      // file, don't draw the line itself, break here.\n      if (filler_todo == 0 && wp->w_botfill) {\n        break;\n      }\n    }\n  }     // for every character in the line\n\n  // After an empty line check first word for capital.\n  if (*skipwhite(line) == NUL) {\n    capcol_lnum = lnum + 1;\n    cap_col = 0;\n  }\n\n  xfree(p_extra_free);\n  return row;\n}\n\nvoid draw_virt_text(buf_T *buf, int col_off, int *end_col, int max_col)\n{\n  DecorState *state = &decor_state;\n  int right_pos = max_col;\n  bool do_eol = state->eol_col > -1;\n  for (size_t i = 0; i < kv_size(state->active); i++) {\n    DecorRange *item = &kv_A(state->active, i);\n    if (item->start_row == state->row && kv_size(item->decor.virt_text)) {\n      if (item->win_col == -1) {\n        if (item->decor.virt_text_pos == kVTRightAlign) {\n          right_pos -= item->decor.virt_text_width;\n          item->win_col = right_pos;\n        } else if (item->decor.virt_text_pos == kVTEndOfLine && do_eol) {\n          item->win_col = state->eol_col;\n          state->eol_col += item->decor.virt_text_width;\n        } else if (item->decor.virt_text_pos == kVTWinCol) {\n          item->win_col = MAX(item->decor.col+col_off, 0);\n        }\n      }\n      if (item->win_col < 0) {\n        continue;\n      }\n      VirtText vt = item->decor.virt_text;\n      HlMode hl_mode = item->decor.hl_mode;\n      LineState s = LINE_STATE(\"\");\n      int virt_attr = 0;\n      int col = item->win_col;\n      size_t virt_pos = 0;\n      item->win_col = -2;  // deactivate\n\n      while (col < max_col) {\n        if (!*s.p) {\n          if (virt_pos >= kv_size(vt)) {\n            break;\n          }\n          virt_attr = 0;\n          do {\n            s.p = kv_A(vt, virt_pos).text;\n            int hl_id = kv_A(vt, virt_pos).hl_id;\n            virt_attr = hl_combine_attr(virt_attr,\n                                        hl_id > 0 ? syn_id2attr(hl_id) : 0);\n            virt_pos++;\n          } while (!s.p && virt_pos < kv_size(vt));\n          if (!s.p) {\n            break;\n          }\n        }\n        int attr;\n        bool through = false;\n        if (hl_mode == kHlModeCombine) {\n          attr = hl_combine_attr(linebuf_attr[col], virt_attr);\n        } else if (hl_mode == kHlModeBlend) {\n          through = (*s.p == ' ');\n          attr = hl_blend_attrs(linebuf_attr[col], virt_attr, &through);\n        } else {\n          attr = virt_attr;\n        }\n        schar_T dummy[2];\n        int cells = line_putchar(&s, through ? dummy : &linebuf_char[col],\n                                 max_col-col, false);\n        linebuf_attr[col++] = attr;\n        if (cells > 1) {\n          linebuf_attr[col++] = attr;\n        }\n      }\n      *end_col = MAX(*end_col, col);\n    }\n  }\n}\n\n/// Determine if dedicated window grid should be used or the default_grid\n///\n/// If UI did not request multigrid support, draw all windows on the\n/// default_grid.\n///\n/// NB: this function can only been used with window grids in a context where\n/// win_grid_alloc already has been called!\n///\n/// If the default_grid is used, adjust window relative positions to global\n/// screen positions.\nvoid screen_adjust_grid(ScreenGrid **grid, int *row_off, int *col_off)\n{\n  if ((*grid)->target) {\n    *row_off += (*grid)->row_offset;\n    *col_off += (*grid)->col_offset;\n    *grid = (*grid)->target;\n  }\n}\n\n// Get information needed to display the sign in line 'lnum' in window 'wp'.\n// If 'nrcol' is TRUE, the sign is going to be displayed in the number column.\n// Otherwise the sign is going to be displayed in the sign column.\n//\n// @param count max number of signs\n// @param[out] n_extrap number of characters from pp_extra to display\n// @param[in, out] sign_idxp Index of the displayed sign\nstatic void get_sign_display_info(bool nrcol, win_T *wp, sign_attrs_T sattrs[], int row,\n                                  int startrow, int filler_lines, int filler_todo, int count,\n                                  int *c_extrap, int *c_finalp, char_u *extra, size_t extra_size,\n                                  char_u **pp_extra, int *n_extrap, int *char_attrp,\n                                  int *draw_statep, int *sign_idxp)\n{\n  // Draw cells with the sign value or blank.\n  *c_extrap = ' ';\n  *c_finalp = NUL;\n  if (nrcol) {\n    *n_extrap = number_width(wp) + 1;\n  } else {\n    *char_attrp = win_hl_attr(wp, HLF_SC);\n    *n_extrap = win_signcol_width(wp);\n  }\n\n  if (row == startrow + filler_lines && filler_todo <= 0) {\n    sign_attrs_T *sattr = sign_get_attr(SIGN_TEXT, sattrs, *sign_idxp, count);\n    if (sattr != NULL) {\n      *pp_extra = sattr->sat_text;\n      if (*pp_extra != NULL) {\n        *c_extrap = NUL;\n        *c_finalp = NUL;\n\n        if (nrcol) {\n          int n, width = number_width(wp) - 2;\n          for (n = 0; n < width; n++) {\n            extra[n] = ' ';\n          }\n          extra[n] = NUL;\n          STRCAT(extra, *pp_extra);\n          STRCAT(extra, \" \");\n          *pp_extra = extra;\n          *n_extrap = (int)STRLEN(*pp_extra);\n        } else {\n          int symbol_blen = (int)STRLEN(*pp_extra);\n\n          // TODO(oni-link): Is sign text already extended to\n          // full cell width?\n          assert((size_t)win_signcol_width(wp) >= mb_string2cells(*pp_extra));\n          // symbol(s) bytes + (filling spaces) (one byte each)\n          *n_extrap = symbol_blen +\n                      (win_signcol_width(wp) - mb_string2cells(*pp_extra));\n\n          assert(extra_size > (size_t)symbol_blen);\n          memset(extra, ' ', extra_size);\n          memcpy(extra, *pp_extra, symbol_blen);\n\n          *pp_extra = extra;\n          (*pp_extra)[*n_extrap] = NUL;\n        }\n      }\n      *char_attrp = sattr->sat_texthl;\n    }\n  }\n\n  (*sign_idxp)++;\n  if (*sign_idxp < count) {\n    *draw_statep = WL_SIGN - 1;\n  } else {\n    *sign_idxp = 0;\n  }\n}\n\n\n/*\n * Check whether the given character needs redrawing:\n * - the (first byte of the) character is different\n * - the attributes are different\n * - the character is multi-byte and the next byte is different\n * - the character is two cells wide and the second cell differs.\n */\nstatic int grid_char_needs_redraw(ScreenGrid *grid, int off_from, int off_to, int cols)\n{\n  return (cols > 0\n          && ((schar_cmp(linebuf_char[off_from], grid->chars[off_to])\n               || linebuf_attr[off_from] != grid->attrs[off_to]\n               || (line_off2cells(linebuf_char, off_from, off_from + cols) > 1\n                   && schar_cmp(linebuf_char[off_from + 1],\n                                grid->chars[off_to + 1])))\n              || rdb_flags & RDB_NODELTA));\n}\n\n/// Move one buffered line to the window grid, but only the characters that\n/// have actually changed.  Handle insert/delete character.\n/// \"coloff\" gives the first column on the grid for this line.\n/// \"endcol\" gives the columns where valid characters are.\n/// \"clear_width\" is the width of the window.  It's > 0 if the rest of the line\n/// needs to be cleared, negative otherwise.\n/// \"rlflag\" is TRUE in a rightleft window:\n///    When TRUE and \"clear_width\" > 0, clear columns 0 to \"endcol\"\n///    When FALSE and \"clear_width\" > 0, clear columns \"endcol\" to \"clear_width\"\n/// If \"wrap\" is true, then hint to the UI that \"row\" contains a line\n/// which has wrapped into the next row.\nstatic void grid_put_linebuf(ScreenGrid *grid, int row, int coloff, int endcol, int clear_width,\n                             int rlflag, win_T *wp, int bg_attr, bool wrap)\n{\n  unsigned off_from;\n  unsigned off_to;\n  unsigned max_off_from;\n  unsigned max_off_to;\n  int col = 0;\n  bool redraw_this;                         // Does character need redraw?\n  bool redraw_next;                         // redraw_this for next character\n  bool clear_next = false;\n  int char_cells;                           // 1: normal char\n                                            // 2: occupies two display cells\n  int start_dirty = -1, end_dirty = 0;\n\n  // TODO(bfredl): check all callsites and eliminate\n  // Check for illegal row and col, just in case\n  if (row >= grid->Rows) {\n    row = grid->Rows - 1;\n  }\n  if (endcol > grid->Columns) {\n    endcol = grid->Columns;\n  }\n\n  screen_adjust_grid(&grid, &row, &coloff);\n\n  // Safety check. Avoids clang warnings down the call stack.\n  if (grid->chars == NULL || row >= grid->Rows || coloff >= grid->Columns) {\n    DLOG(\"invalid state, skipped\");\n    return;\n  }\n\n  off_from = 0;\n  off_to = grid->line_offset[row] + coloff;\n  max_off_from = linebuf_size;\n  max_off_to = grid->line_offset[row] + grid->Columns;\n\n  if (rlflag) {\n    // Clear rest first, because it's left of the text.\n    if (clear_width > 0) {\n      while (col <= endcol && grid->chars[off_to][0] == ' '\n             && grid->chars[off_to][1] == NUL\n             && grid->attrs[off_to] == bg_attr) {\n        ++off_to;\n        ++col;\n      }\n      if (col <= endcol) {\n        grid_fill(grid, row, row + 1, col + coloff, endcol + coloff + 1,\n                  ' ', ' ', bg_attr);\n      }\n    }\n    col = endcol + 1;\n    off_to = grid->line_offset[row] + col + coloff;\n    off_from += col;\n    endcol = (clear_width > 0 ? clear_width : -clear_width);\n  }\n\n  if (bg_attr) {\n    for (int c = col; c < endcol; c++) {\n      linebuf_attr[off_from+c] =\n        hl_combine_attr(bg_attr, linebuf_attr[off_from+c]);\n    }\n  }\n\n  redraw_next = grid_char_needs_redraw(grid, off_from, off_to, endcol - col);\n\n  while (col < endcol) {\n    char_cells = 1;\n    if (col + 1 < endcol) {\n      char_cells = line_off2cells(linebuf_char, off_from, max_off_from);\n    }\n    redraw_this = redraw_next;\n    redraw_next = grid_char_needs_redraw(grid, off_from + char_cells,\n                                         off_to + char_cells,\n                                         endcol - col - char_cells);\n\n    if (redraw_this) {\n      if (start_dirty == -1) {\n        start_dirty = col;\n      }\n      end_dirty = col + char_cells;\n      // When writing a single-width character over a double-width\n      // character and at the end of the redrawn text, need to clear out\n      // the right halve of the old character.\n      // Also required when writing the right halve of a double-width\n      // char over the left halve of an existing one\n      if (col + char_cells == endcol\n          && ((char_cells == 1\n               && grid_off2cells(grid, off_to, max_off_to) > 1)\n              || (char_cells == 2\n                  && grid_off2cells(grid, off_to, max_off_to) == 1\n                  && grid_off2cells(grid, off_to + 1, max_off_to) > 1))) {\n        clear_next = true;\n      }\n\n      schar_copy(grid->chars[off_to], linebuf_char[off_from]);\n      if (char_cells == 2) {\n        schar_copy(grid->chars[off_to+1], linebuf_char[off_from+1]);\n      }\n\n      grid->attrs[off_to] = linebuf_attr[off_from];\n      // For simplicity set the attributes of second half of a\n      // double-wide character equal to the first half.\n      if (char_cells == 2) {\n        grid->attrs[off_to + 1] = linebuf_attr[off_from];\n      }\n    }\n\n    off_to += char_cells;\n    off_from += char_cells;\n    col += char_cells;\n  }\n\n  if (clear_next) {\n    /* Clear the second half of a double-wide character of which the left\n     * half was overwritten with a single-wide character. */\n    schar_from_ascii(grid->chars[off_to], ' ');\n    end_dirty++;\n  }\n\n  int clear_end = -1;\n  if (clear_width > 0 && !rlflag) {\n    // blank out the rest of the line\n    // TODO(bfredl): we could cache winline widths\n    while (col < clear_width) {\n      if (grid->chars[off_to][0] != ' '\n          || grid->chars[off_to][1] != NUL\n          || grid->attrs[off_to] != bg_attr) {\n        grid->chars[off_to][0] = ' ';\n        grid->chars[off_to][1] = NUL;\n        grid->attrs[off_to] = bg_attr;\n        if (start_dirty == -1) {\n          start_dirty = col;\n          end_dirty = col;\n        } else if (clear_end == -1) {\n          end_dirty = endcol;\n        }\n        clear_end = col+1;\n      }\n      col++;\n      off_to++;\n    }\n  }\n\n  if (clear_width > 0 || wp->w_width != grid->Columns) {\n    // If we cleared after the end of the line, it did not wrap.\n    // For vsplit, line wrapping is not possible.\n    grid->line_wraps[row] = false;\n  }\n\n  if (clear_end < end_dirty) {\n    clear_end = end_dirty;\n  }\n  if (start_dirty == -1) {\n    start_dirty = end_dirty;\n  }\n  if (clear_end > start_dirty) {\n    ui_line(grid, row, coloff+start_dirty, coloff+end_dirty, coloff+clear_end,\n            bg_attr, wrap);\n  }\n}\n\n/*\n * Mirror text \"str\" for right-left displaying.\n * Only works for single-byte characters (e.g., numbers).\n */\nvoid rl_mirror(char_u *str)\n{\n  char_u      *p1, *p2;\n  int t;\n\n  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2) {\n    t = *p1;\n    *p1 = *p2;\n    *p2 = t;\n  }\n}\n\n/*\n * mark all status lines for redraw; used after first :cd\n */\nvoid status_redraw_all(void)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_status_height) {\n      wp->w_redr_status = true;\n      redraw_later(wp, VALID);\n    }\n  }\n}\n\n/// Marks all status lines of the current buffer for redraw.\nvoid status_redraw_curbuf(void)\n{\n  status_redraw_buf(curbuf);\n}\n\n/// Marks all status lines of the specified buffer for redraw.\nvoid status_redraw_buf(buf_T *buf)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_status_height != 0 && wp->w_buffer == buf) {\n      wp->w_redr_status = true;\n      redraw_later(wp, VALID);\n    }\n  }\n}\n\n/*\n * Redraw all status lines that need to be redrawn.\n */\nvoid redraw_statuslines(void)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_redr_status) {\n      win_redr_status(wp);\n    }\n  }\n  if (redraw_tabline) {\n    draw_tabline();\n  }\n}\n\n/*\n * Redraw all status lines at the bottom of frame \"frp\".\n */\nvoid win_redraw_last_status(const frame_T *frp)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (frp->fr_layout == FR_LEAF) {\n    frp->fr_win->w_redr_status = true;\n  } else if (frp->fr_layout == FR_ROW) {\n    FOR_ALL_FRAMES(frp, frp->fr_child) {\n      win_redraw_last_status(frp);\n    }\n  } else {\n    assert(frp->fr_layout == FR_COL);\n    frp = frp->fr_child;\n    while (frp->fr_next != NULL) {\n      frp = frp->fr_next;\n    }\n    win_redraw_last_status(frp);\n  }\n}\n\n/*\n * Draw the verticap separator right of window \"wp\" starting with line \"row\".\n */\nstatic void draw_vsep_win(win_T *wp, int row)\n{\n  int hl;\n  int c;\n\n  if (wp->w_vsep_width) {\n    // draw the vertical separator right of this window\n    c = fillchar_vsep(wp, &hl);\n    grid_fill(&default_grid, wp->w_winrow + row, W_ENDROW(wp),\n              W_ENDCOL(wp), W_ENDCOL(wp) + 1, c, ' ', hl);\n  }\n}\n\n\n/*\n * Get the length of an item as it will be shown in the status line.\n */\nstatic int status_match_len(expand_T *xp, char_u *s)\n{\n  int len = 0;\n\n  int emenu = (xp->xp_context == EXPAND_MENUS\n               || xp->xp_context == EXPAND_MENUNAMES);\n\n  // Check for menu separators - replace with '|'.\n  if (emenu && menu_is_separator(s)) {\n    return 1;\n  }\n\n  while (*s != NUL) {\n    s += skip_status_match_char(xp, s);\n    len += ptr2cells(s);\n    MB_PTR_ADV(s);\n  }\n\n  return len;\n}\n\n/*\n * Return the number of characters that should be skipped in a status match.\n * These are backslashes used for escaping.  Do show backslashes in help tags.\n */\nstatic int skip_status_match_char(expand_T *xp, char_u *s)\n{\n  if ((rem_backslash(s) && xp->xp_context != EXPAND_HELP)\n      || ((xp->xp_context == EXPAND_MENUS\n           || xp->xp_context == EXPAND_MENUNAMES)\n          && (s[0] == '\\t' ||\n              (s[0] == '\\\\' && s[1] != NUL)))) {\n#ifndef BACKSLASH_IN_FILENAME\n    if (xp->xp_shell && csh_like_shell() && s[1] == '\\\\' && s[2] == '!') {\n      return 2;\n    }\n#endif\n    return 1;\n  }\n  return 0;\n}\n\n/*\n * Show wildchar matches in the status line.\n * Show at least the \"match\" item.\n * We start at item 'first_match' in the list and show all matches that fit.\n *\n * If inversion is possible we use it. Else '=' characters are used.\n */\nvoid win_redr_status_matches(expand_T *xp, int num_matches, char_u **matches,          // list of matches\n                             int match, int showtail)\n{\n#define L_MATCH(m) (showtail ? sm_gettail(matches[m], false) : matches[m])\n  int row;\n  char_u      *buf;\n  int len;\n  int clen;                     // length in screen cells\n  int fillchar;\n  int attr;\n  int i;\n  bool highlight = true;\n  char_u      *selstart = NULL;\n  int selstart_col = 0;\n  char_u      *selend = NULL;\n  static int first_match = 0;\n  bool add_left = false;\n  char_u      *s;\n  int emenu;\n  int l;\n\n  if (matches == NULL) {        // interrupted completion?\n    return;\n  }\n\n  buf = xmalloc(Columns * MB_MAXBYTES + 1);\n\n  if (match == -1) {    // don't show match but original text\n    match = 0;\n    highlight = false;\n  }\n  // count 1 for the ending \">\"\n  clen = status_match_len(xp, L_MATCH(match)) + 3;\n  if (match == 0) {\n    first_match = 0;\n  } else if (match < first_match) {\n    // jumping left, as far as we can go\n    first_match = match;\n    add_left = true;\n  } else {\n    // check if match fits on the screen\n    for (i = first_match; i < match; ++i) {\n      clen += status_match_len(xp, L_MATCH(i)) + 2;\n    }\n    if (first_match > 0) {\n      clen += 2;\n    }\n    // jumping right, put match at the left\n    if ((long)clen > Columns) {\n      first_match = match;\n      // if showing the last match, we can add some on the left\n      clen = 2;\n      for (i = match; i < num_matches; ++i) {\n        clen += status_match_len(xp, L_MATCH(i)) + 2;\n        if ((long)clen >= Columns) {\n          break;\n        }\n      }\n      if (i == num_matches) {\n        add_left = true;\n      }\n    }\n  }\n  if (add_left) {\n    while (first_match > 0) {\n      clen += status_match_len(xp, L_MATCH(first_match - 1)) + 2;\n      if ((long)clen >= Columns) {\n        break;\n      }\n      first_match--;\n    }\n  }\n\n  fillchar = fillchar_status(&attr, curwin);\n\n  if (first_match == 0) {\n    *buf = NUL;\n    len = 0;\n  } else {\n    STRCPY(buf, \"< \");\n    len = 2;\n  }\n  clen = len;\n\n  i = first_match;\n  while ((long)(clen + status_match_len(xp, L_MATCH(i)) + 2) < Columns) {\n    if (i == match) {\n      selstart = buf + len;\n      selstart_col = clen;\n    }\n\n    s = L_MATCH(i);\n    // Check for menu separators - replace with '|'\n    emenu = (xp->xp_context == EXPAND_MENUS\n             || xp->xp_context == EXPAND_MENUNAMES);\n    if (emenu && menu_is_separator(s)) {\n      STRCPY(buf + len, transchar('|'));\n      l = (int)STRLEN(buf + len);\n      len += l;\n      clen += l;\n    } else {\n      for (; *s != NUL; ++s) {\n        s += skip_status_match_char(xp, s);\n        clen += ptr2cells(s);\n        if ((l = (*mb_ptr2len)(s)) > 1) {\n          STRNCPY(buf + len, s, l);  // NOLINT(runtime/printf)\n          s += l - 1;\n          len += l;\n        } else {\n          STRCPY(buf + len, transchar_byte(*s));\n          len += (int)STRLEN(buf + len);\n        }\n      }\n    }\n    if (i == match) {\n      selend = buf + len;\n    }\n\n    *(buf + len++) = ' ';\n    *(buf + len++) = ' ';\n    clen += 2;\n    if (++i == num_matches) {\n      break;\n    }\n  }\n\n  if (i != num_matches) {\n    *(buf + len++) = '>';\n    ++clen;\n  }\n\n  buf[len] = NUL;\n\n  row = cmdline_row - 1;\n  if (row >= 0) {\n    if (wild_menu_showing == 0 || wild_menu_showing == WM_LIST) {\n      if (msg_scrolled > 0) {\n        /* Put the wildmenu just above the command line.  If there is\n         * no room, scroll the screen one line up. */\n        if (cmdline_row == Rows - 1) {\n          msg_scroll_up(false);\n          msg_scrolled++;\n        } else {\n          cmdline_row++;\n          row++;\n        }\n        wild_menu_showing = WM_SCROLLED;\n      } else {\n        /* Create status line if needed by setting 'laststatus' to 2.\n         * Set 'winminheight' to zero to avoid that the window is\n         * resized. */\n        if (lastwin->w_status_height == 0) {\n          save_p_ls = p_ls;\n          save_p_wmh = p_wmh;\n          p_ls = 2;\n          p_wmh = 0;\n          last_status(false);\n        }\n        wild_menu_showing = WM_SHOWN;\n      }\n    }\n\n    // Tricky: wildmenu can be drawn either over a status line, or at empty\n    // scrolled space in the message output\n    ScreenGrid *grid = (wild_menu_showing == WM_SCROLLED)\n                        ? &msg_grid_adj : &default_grid;\n\n    grid_puts(grid, buf, row, 0, attr);\n    if (selstart != NULL && highlight) {\n      *selend = NUL;\n      grid_puts(grid, selstart, row, selstart_col, HL_ATTR(HLF_WM));\n    }\n\n    grid_fill(grid, row, row + 1, clen, Columns,\n              fillchar, fillchar, attr);\n  }\n\n  win_redraw_last_status(topframe);\n  xfree(buf);\n}\n\n/// Redraw the status line of window `wp`.\n///\n/// If inversion is possible we use it. Else '=' characters are used.\nstatic void win_redr_status(win_T *wp)\n{\n  int row;\n  char_u      *p;\n  int len;\n  int fillchar;\n  int attr;\n  int this_ru_col;\n  static int busy = FALSE;\n\n  // May get here recursively when 'statusline' (indirectly)\n  // invokes \":redrawstatus\".  Simply ignore the call then.\n  if (busy\n      // Also ignore if wildmenu is showing.\n      || (wild_menu_showing != 0 && !ui_has(kUIWildmenu))) {\n    return;\n  }\n  busy = true;\n\n  wp->w_redr_status = FALSE;\n  if (wp->w_status_height == 0) {\n    // no status line, can only be last window\n    redraw_cmdline = true;\n  } else if (!redrawing()) {\n    // Don't redraw right now, do it later. Don't update status line when\n    // popup menu is visible and may be drawn over it\n    wp->w_redr_status = true;\n  } else if (*p_stl != NUL || *wp->w_p_stl != NUL) {\n    // redraw custom status line\n    redraw_custom_statusline(wp);\n  } else {\n    fillchar = fillchar_status(&attr, wp);\n\n    get_trans_bufname(wp->w_buffer);\n    p = NameBuff;\n    len = (int)STRLEN(p);\n\n    if (bt_help(wp->w_buffer)\n        || wp->w_p_pvw\n        || bufIsChanged(wp->w_buffer)\n        || wp->w_buffer->b_p_ro) {\n      *(p + len++) = ' ';\n    }\n    if (bt_help(wp->w_buffer)) {\n      STRCPY(p + len, _(\"[Help]\"));\n      len += (int)STRLEN(p + len);\n    }\n    if (wp->w_p_pvw) {\n      STRCPY(p + len, _(\"[Preview]\"));\n      len += (int)STRLEN(p + len);\n    }\n    if (bufIsChanged(wp->w_buffer)) {\n      STRCPY(p + len, \"[+]\");\n      len += 3;\n    }\n    if (wp->w_buffer->b_p_ro) {\n      STRCPY(p + len, _(\"[RO]\"));\n      // len += (int)STRLEN(p + len);  // dead assignment\n    }\n\n    this_ru_col = ru_col - (Columns - wp->w_width);\n    if (this_ru_col < (wp->w_width + 1) / 2) {\n      this_ru_col = (wp->w_width + 1) / 2;\n    }\n    if (this_ru_col <= 1) {\n      p = (char_u *)\"<\";                // No room for file name!\n      len = 1;\n    } else {\n      int clen = 0, i;\n\n      // Count total number of display cells.\n      clen = (int)mb_string2cells(p);\n\n      // Find first character that will fit.\n      // Going from start to end is much faster for DBCS.\n      for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n           i += utfc_ptr2len(p + i)) {\n        clen -= utf_ptr2cells(p + i);\n      }\n      len = clen;\n      if (i > 0) {\n        p = p + i - 1;\n        *p = '<';\n        ++len;\n      }\n    }\n\n    row = W_ENDROW(wp);\n    grid_puts(&default_grid, p, row, wp->w_wincol, attr);\n    grid_fill(&default_grid, row, row + 1, len + wp->w_wincol,\n              this_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n    if (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n        && this_ru_col - len > (int)(STRLEN(NameBuff) + 1)) {\n      grid_puts(&default_grid, NameBuff, row,\n                (int)(this_ru_col - STRLEN(NameBuff) - 1), attr);\n    }\n\n    win_redr_ruler(wp, true);\n  }\n\n  /*\n   * May need to draw the character below the vertical separator.\n   */\n  if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing()) {\n    if (stl_connected(wp)) {\n      fillchar = fillchar_status(&attr, wp);\n    } else {\n      fillchar = fillchar_vsep(wp, &attr);\n    }\n    grid_putchar(&default_grid, fillchar, W_ENDROW(wp), W_ENDCOL(wp), attr);\n  }\n  busy = FALSE;\n}\n\n/*\n * Redraw the status line according to 'statusline' and take care of any\n * errors encountered.\n */\nstatic void redraw_custom_statusline(win_T *wp)\n{\n  static bool entered = false;\n  int saved_did_emsg = did_emsg;\n\n  /* When called recursively return.  This can happen when the statusline\n   * contains an expression that triggers a redraw. */\n  if (entered) {\n    return;\n  }\n  entered = true;\n\n  did_emsg = false;\n  win_redr_custom(wp, false);\n  if (did_emsg) {\n    // When there is an error disable the statusline, otherwise the\n    // display is messed up with errors and a redraw triggers the problem\n    // again and again.\n    set_string_option_direct(\"statusline\", -1, (char_u *)\"\",\n                             OPT_FREE | (*wp->w_p_stl != NUL\n                                         ? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);\n  }\n  did_emsg |= saved_did_emsg;\n  entered = false;\n}\n\n/// Only call if (wp->w_vsep_width != 0).\n///\n/// @return  true if the status line of window \"wp\" is connected to the status\n/// line of the window right of it.  If not, then it's a vertical separator.\nbool stl_connected(win_T *wp)\n{\n  frame_T     *fr;\n\n  fr = wp->w_frame;\n  while (fr->fr_parent != NULL) {\n    if (fr->fr_parent->fr_layout == FR_COL) {\n      if (fr->fr_next != NULL) {\n        break;\n      }\n    } else {\n      if (fr->fr_next != NULL) {\n        return true;\n      }\n    }\n    fr = fr->fr_parent;\n  }\n  return false;\n}\n\n\n/// Get the value to show for the language mappings, active 'keymap'.\n///\n/// @param fmt  format string containing one %s item\n/// @param buf  buffer for the result\n/// @param len  length of buffer\nbool get_keymap_str(win_T *wp, char_u *fmt, char_u *buf, int len)\n{\n  char_u      *p;\n\n  if (wp->w_buffer->b_p_iminsert != B_IMODE_LMAP) {\n    return false;\n  }\n\n  {\n    buf_T   *old_curbuf = curbuf;\n    win_T   *old_curwin = curwin;\n    char_u  *s;\n\n    curbuf = wp->w_buffer;\n    curwin = wp;\n    STRCPY(buf, \"b:keymap_name\");       // must be writable\n    ++emsg_skip;\n    s = p = eval_to_string(buf, NULL, FALSE);\n    --emsg_skip;\n    curbuf = old_curbuf;\n    curwin = old_curwin;\n    if (p == NULL || *p == NUL) {\n      if (wp->w_buffer->b_kmap_state & KEYMAP_LOADED) {\n        p = wp->w_buffer->b_p_keymap;\n      } else {\n        p = (char_u *)\"lang\";\n      }\n    }\n    if (vim_snprintf((char *)buf, len, (char *)fmt, p) > len - 1) {\n      buf[0] = NUL;\n    }\n    xfree(s);\n  }\n  return buf[0] != NUL;\n}\n\n/*\n * Redraw the status line or ruler of window \"wp\".\n * When \"wp\" is NULL redraw the tab pages line from 'tabline'.\n */\nstatic void win_redr_custom(win_T *wp, bool draw_ruler)\n{\n  static bool entered = false;\n  int attr;\n  int curattr;\n  int row;\n  int col = 0;\n  int maxwidth;\n  int width;\n  int n;\n  int len;\n  int fillchar;\n  char_u buf[MAXPATHL];\n  char_u      *stl;\n  char_u      *p;\n  stl_hlrec_t *hltab;\n  StlClickRecord *tabtab;\n  int use_sandbox = false;\n  win_T       *ewp;\n  int p_crb_save;\n\n  ScreenGrid *grid = &default_grid;\n\n  /* There is a tiny chance that this gets called recursively: When\n   * redrawing a status line triggers redrawing the ruler or tabline.\n   * Avoid trouble by not allowing recursion. */\n  if (entered) {\n    return;\n  }\n  entered = true;\n\n  // setup environment for the task at hand\n  if (wp == NULL) {\n    // Use 'tabline'.  Always at the first line of the screen.\n    stl = p_tal;\n    row = 0;\n    fillchar = ' ';\n    attr = HL_ATTR(HLF_TPF);\n    maxwidth = Columns;\n    use_sandbox = was_set_insecurely(wp, (char_u *)\"tabline\", 0);\n  } else {\n    row = W_ENDROW(wp);\n    fillchar = fillchar_status(&attr, wp);\n    maxwidth = wp->w_width;\n\n    if (draw_ruler) {\n      stl = p_ruf;\n      // advance past any leading group spec - implicit in ru_col\n      if (*stl == '%') {\n        if (*++stl == '-') {\n          stl++;\n        }\n        if (atoi((char *)stl)) {\n          while (ascii_isdigit(*stl)) {\n            stl++;\n          }\n        }\n        if (*stl++ != '(') {\n          stl = p_ruf;\n        }\n      }\n      col = ru_col - (Columns - wp->w_width);\n      if (col < (wp->w_width + 1) / 2) {\n        col = (wp->w_width + 1) / 2;\n      }\n      maxwidth = wp->w_width - col;\n      if (!wp->w_status_height) {\n        grid = &msg_grid_adj;\n        row = Rows - 1;\n        maxwidth--;  // writing in last column may cause scrolling\n        fillchar = ' ';\n        attr = HL_ATTR(HLF_MSG);\n      }\n\n      use_sandbox = was_set_insecurely(wp, (char_u *)\"rulerformat\", 0);\n    } else {\n      if (*wp->w_p_stl != NUL) {\n        stl = wp->w_p_stl;\n      } else {\n        stl = p_stl;\n      }\n      use_sandbox = was_set_insecurely(wp, (char_u *)\"statusline\",\n                                       *wp->w_p_stl == NUL ? 0 : OPT_LOCAL);\n    }\n\n    col += wp->w_wincol;\n  }\n\n  if (maxwidth <= 0) {\n    goto theend;\n  }\n\n  /* Temporarily reset 'cursorbind', we don't want a side effect from moving\n   * the cursor away and back. */\n  ewp = wp == NULL ? curwin : wp;\n  p_crb_save = ewp->w_p_crb;\n  ewp->w_p_crb = FALSE;\n\n  /* Make a copy, because the statusline may include a function call that\n   * might change the option value and free the memory. */\n  stl = vim_strsave(stl);\n  width =\n    build_stl_str_hl(ewp, buf, sizeof(buf), stl, use_sandbox,\n                     fillchar, maxwidth, &hltab, &tabtab);\n  xfree(stl);\n  ewp->w_p_crb = p_crb_save;\n\n  // Make all characters printable.\n  p = (char_u *)transstr((const char *)buf);\n  len = STRLCPY(buf, p, sizeof(buf));\n  len = (size_t)len < sizeof(buf) ? len : (int)sizeof(buf) - 1;\n  xfree(p);\n\n  // fill up with \"fillchar\"\n  while (width < maxwidth && len < (int)sizeof(buf) - 1) {\n    len += utf_char2bytes(fillchar, buf + len);\n    width++;\n  }\n  buf[len] = NUL;\n\n  /*\n   * Draw each snippet with the specified highlighting.\n   */\n  grid_puts_line_start(grid, row);\n\n  curattr = attr;\n  p = buf;\n  for (n = 0; hltab[n].start != NULL; n++) {\n    int textlen = (int)(hltab[n].start - p);\n    grid_puts_len(grid, p, textlen, row, col, curattr);\n    col += vim_strnsize(p, textlen);\n    p = hltab[n].start;\n\n    if (hltab[n].userhl == 0) {\n      curattr = attr;\n    } else if (hltab[n].userhl < 0) {\n      curattr = syn_id2attr(-hltab[n].userhl);\n    } else if (wp != NULL && wp != curwin && wp->w_status_height != 0) {\n      curattr = highlight_stlnc[hltab[n].userhl - 1];\n    } else {\n      curattr = highlight_user[hltab[n].userhl - 1];\n    }\n  }\n  // Make sure to use an empty string instead of p, if p is beyond buf + len.\n  grid_puts(grid, p >= buf + len ? (char_u *)\"\" : p, row, col,\n            curattr);\n\n  grid_puts_line_flush(false);\n\n  if (wp == NULL) {\n    // Fill the tab_page_click_defs array for clicking in the tab pages line.\n    col = 0;\n    len = 0;\n    p = buf;\n    StlClickDefinition cur_click_def = {\n      .type = kStlClickDisabled,\n    };\n    for (n = 0; tabtab[n].start != NULL; n++) {\n      len += vim_strnsize(p, (int)(tabtab[n].start - (char *)p));\n      while (col < len) {\n        tab_page_click_defs[col++] = cur_click_def;\n      }\n      p = (char_u *)tabtab[n].start;\n      cur_click_def = tabtab[n].def;\n    }\n    while (col < Columns) {\n      tab_page_click_defs[col++] = cur_click_def;\n    }\n  }\n\ntheend:\n  entered = false;\n}\n\nstatic void win_redr_border(win_T *wp)\n{\n  wp->w_redr_border = false;\n  if (!(wp->w_floating && wp->w_float_config.border)) {\n    return;\n  }\n\n  ScreenGrid *grid = &wp->w_grid_alloc;\n\n  schar_T *chars = wp->w_float_config.border_chars;\n  int *attrs = wp->w_float_config.border_attr;\n\n\n  int *adj = wp->w_border_adj;\n  int irow = wp->w_height_inner, icol = wp->w_width_inner;\n\n  if (adj[0]) {\n    grid_puts_line_start(grid, 0);\n    if (adj[3]) {\n      grid_put_schar(grid, 0, 0, chars[0], attrs[0]);\n    }\n    for (int i = 0; i < icol; i++) {\n      grid_put_schar(grid, 0, i+adj[3], chars[1], attrs[1]);\n    }\n    if (adj[1]) {\n      grid_put_schar(grid, 0, icol+adj[3], chars[2], attrs[2]);\n    }\n    grid_puts_line_flush(false);\n  }\n\n  for (int i = 0; i < irow; i++) {\n    if (adj[3]) {\n      grid_puts_line_start(grid, i+adj[0]);\n      grid_put_schar(grid, i+adj[0], 0, chars[7], attrs[7]);\n      grid_puts_line_flush(false);\n    }\n    if (adj[1]) {\n      int ic = (i == 0 && !adj[0] && chars[2][0]) ? 2 : 3;\n      grid_puts_line_start(grid, i+adj[0]);\n      grid_put_schar(grid, i+adj[0], icol+adj[3], chars[ic], attrs[ic]);\n      grid_puts_line_flush(false);\n    }\n  }\n\n  if (adj[2]) {\n    grid_puts_line_start(grid, irow+adj[0]);\n    if (adj[3]) {\n      grid_put_schar(grid, irow+adj[0], 0, chars[6], attrs[6]);\n    }\n    for (int i = 0; i < icol; i++) {\n      int ic = (i == 0 && !adj[3] && chars[6][0]) ? 6 : 5;\n      grid_put_schar(grid, irow+adj[0], i+adj[3], chars[ic], attrs[ic]);\n    }\n    grid_put_schar(grid, irow+adj[0], icol+adj[3], chars[4], attrs[4]);\n    grid_puts_line_flush(false);\n  }\n}\n\n// Low-level functions to manipulate individual character cells on the\n// screen grid.\n\n/// Put a ASCII character in a screen cell.\nstatic void schar_from_ascii(char_u *p, const char c)\n{\n  p[0] = c;\n  p[1] = 0;\n}\n\n/// Put a unicode character in a screen cell.\nstatic int schar_from_char(char_u *p, int c)\n{\n  int len = utf_char2bytes(c, p);\n  p[len] = NUL;\n  return len;\n}\n\n/// Put a unicode char, and up to MAX_MCO composing chars, in a screen cell.\nstatic int schar_from_cc(char_u *p, int c, int u8cc[MAX_MCO])\n{\n  int len = utf_char2bytes(c, p);\n  for (int i = 0; i < MAX_MCO; i++) {\n    if (u8cc[i] == 0) {\n      break;\n    }\n    len += utf_char2bytes(u8cc[i], p + len);\n  }\n  p[len] = 0;\n  return len;\n}\n\n/// compare the contents of two screen cells.\nstatic int schar_cmp(char_u *sc1, char_u *sc2)\n{\n  return STRNCMP(sc1, sc2, sizeof(schar_T));\n}\n\n/// copy the contents of screen cell `sc2` into cell `sc1`\nstatic void schar_copy(char_u *sc1, char_u *sc2)\n{\n  STRLCPY(sc1, sc2, sizeof(schar_T));\n}\n\nstatic int line_off2cells(schar_T *line, size_t off, size_t max_off)\n{\n  return (off + 1 < max_off && line[off + 1][0] == 0) ? 2 : 1;\n}\n\n/// Return number of display cells for char at grid->chars[off].\n/// We make sure that the offset used is less than \"max_off\".\nstatic int grid_off2cells(ScreenGrid *grid, size_t off, size_t max_off)\n{\n  return line_off2cells(grid->chars, off, max_off);\n}\n\n/// Return true if the character at \"row\"/\"col\" on the screen is the left side\n/// of a double-width character.\n///\n/// Caller must make sure \"row\" and \"col\" are not invalid!\nbool grid_lefthalve(ScreenGrid *grid, int row, int col)\n{\n  screen_adjust_grid(&grid, &row, &col);\n\n  return grid_off2cells(grid, grid->line_offset[row] + col,\n                        grid->line_offset[row] + grid->Columns) > 1;\n}\n\n/// Correct a position on the screen, if it's the right half of a double-wide\n/// char move it to the left half.  Returns the corrected column.\nint grid_fix_col(ScreenGrid *grid, int col, int row)\n{\n  int coloff = 0;\n  screen_adjust_grid(&grid, &row, &coloff);\n\n  col += coloff;\n  if (grid->chars != NULL && col > 0\n      && grid->chars[grid->line_offset[row] + col][0] == 0) {\n    return col - 1 - coloff;\n  }\n  return col - coloff;\n}\n\n/// output a single character directly to the grid\nvoid grid_putchar(ScreenGrid *grid, int c, int row, int col, int attr)\n{\n  char_u buf[MB_MAXBYTES + 1];\n\n  buf[utf_char2bytes(c, buf)] = NUL;\n  grid_puts(grid, buf, row, col, attr);\n}\n\n/// get a single character directly from grid.chars into \"bytes[]\".\n/// Also return its attribute in *attrp;\nvoid grid_getbytes(ScreenGrid *grid, int row, int col, char_u *bytes, int *attrp)\n{\n  unsigned off;\n\n  screen_adjust_grid(&grid, &row, &col);\n\n  // safety check\n  if (grid->chars != NULL && row < grid->Rows && col < grid->Columns) {\n    off = grid->line_offset[row] + col;\n    *attrp = grid->attrs[off];\n    schar_copy(bytes, grid->chars[off]);\n  }\n}\n\n\n/// put string '*text' on the window grid at position 'row' and 'col', with\n/// attributes 'attr', and update chars[] and attrs[].\n/// Note: only outputs within one row, message is truncated at grid boundary!\n/// Note: if grid, row and/or col is invalid, nothing is done.\nvoid grid_puts(ScreenGrid *grid, char_u *text, int row, int col, int attr)\n{\n  grid_puts_len(grid, text, -1, row, col, attr);\n}\n\nstatic ScreenGrid *put_dirty_grid = NULL;\nstatic int put_dirty_row = -1;\nstatic int put_dirty_first = INT_MAX;\nstatic int put_dirty_last = 0;\n\n/// Start a group of grid_puts_len calls that builds a single grid line.\n///\n/// Must be matched with a grid_puts_line_flush call before moving to\n/// another line.\nvoid grid_puts_line_start(ScreenGrid *grid, int row)\n{\n  int col = 0;  // unused\n  screen_adjust_grid(&grid, &row, &col);\n  assert(put_dirty_row == -1);\n  put_dirty_row = row;\n  put_dirty_grid = grid;\n}\n\nvoid grid_put_schar(ScreenGrid *grid, int row, int col, char_u *schar, int attr)\n{\n  assert(put_dirty_row == row);\n  unsigned int off = grid->line_offset[row] + col;\n  if (grid->attrs[off] != attr || schar_cmp(grid->chars[off], schar)) {\n    schar_copy(grid->chars[off], schar);\n    grid->attrs[off] = attr;\n\n    put_dirty_first = MIN(put_dirty_first, col);\n    // TODO(bfredl): Y U NO DOUBLEWIDTH?\n    put_dirty_last = MAX(put_dirty_last, col+1);\n  }\n}\n\n/// like grid_puts(), but output \"text[len]\".  When \"len\" is -1 output up to\n/// a NUL.\nvoid grid_puts_len(ScreenGrid *grid, char_u *text, int textlen, int row, int col, int attr)\n{\n  unsigned off;\n  char_u      *ptr = text;\n  int len = textlen;\n  int c;\n  unsigned max_off;\n  int mbyte_blen = 1;\n  int mbyte_cells = 1;\n  int u8c = 0;\n  int u8cc[MAX_MCO];\n  int clear_next_cell = FALSE;\n  int prev_c = 0;                       // previous Arabic character\n  int pc, nc, nc1;\n  int pcc[MAX_MCO];\n  int need_redraw;\n  bool do_flush = false;\n\n  screen_adjust_grid(&grid, &row, &col);\n\n  // Safety check. The check for negative row and column is to fix issue\n  // vim/vim#4102. TODO(neovim): find out why row/col could be negative.\n  if (grid->chars == NULL\n      || row >= grid->Rows || row < 0\n      || col >= grid->Columns || col < 0) {\n    return;\n  }\n\n  if (put_dirty_row == -1) {\n    grid_puts_line_start(grid, row);\n    do_flush = true;\n  } else {\n    if (grid != put_dirty_grid || row != put_dirty_row) {\n      abort();\n    }\n  }\n  off = grid->line_offset[row] + col;\n\n  /* When drawing over the right halve of a double-wide char clear out the\n   * left halve.  Only needed in a terminal. */\n  if (grid != &default_grid && col == 0 && grid_invalid_row(grid, row)) {\n    // redraw the previous cell, make it empty\n    put_dirty_first = -1;\n    put_dirty_last = MAX(put_dirty_last, 1);\n  }\n\n  max_off = grid->line_offset[row] + grid->Columns;\n  while (col < grid->Columns\n         && (len < 0 || (int)(ptr - text) < len)\n         && *ptr != NUL) {\n    c = *ptr;\n    // check if this is the first byte of a multibyte\n    if (len > 0) {\n      mbyte_blen = utfc_ptr2len_len(ptr, (int)((text + len) - ptr));\n    } else {\n      mbyte_blen = utfc_ptr2len(ptr);\n    }\n    if (len >= 0) {\n      u8c = utfc_ptr2char_len(ptr, u8cc, (int)((text + len) - ptr));\n    } else {\n      u8c = utfc_ptr2char(ptr, u8cc);\n    }\n    mbyte_cells = utf_char2cells(u8c);\n    if (p_arshape && !p_tbidi && arabic_char(u8c)) {\n      // Do Arabic shaping.\n      if (len >= 0 && (int)(ptr - text) + mbyte_blen >= len) {\n        // Past end of string to be displayed.\n        nc = NUL;\n        nc1 = NUL;\n      } else {\n        nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,\n                               (int)((text + len) - ptr - mbyte_blen));\n        nc1 = pcc[0];\n      }\n      pc = prev_c;\n      prev_c = u8c;\n      u8c = arabic_shape(u8c, &c, &u8cc[0], nc, nc1, pc);\n    } else {\n      prev_c = u8c;\n    }\n    if (col + mbyte_cells > grid->Columns) {\n      // Only 1 cell left, but character requires 2 cells:\n      // display a '>' in the last column to avoid wrapping. */\n      c = '>';\n      mbyte_cells = 1;\n    }\n\n    schar_T buf;\n    schar_from_cc(buf, u8c, u8cc);\n\n\n    need_redraw = schar_cmp(grid->chars[off], buf)\n                  || (mbyte_cells == 2 && grid->chars[off + 1][0] != 0)\n                  || grid->attrs[off] != attr\n                  || exmode_active;\n\n    if (need_redraw) {\n      // When at the end of the text and overwriting a two-cell\n      // character with a one-cell character, need to clear the next\n      // cell.  Also when overwriting the left halve of a two-cell char\n      // with the right halve of a two-cell char.  Do this only once\n      // (utf8_off2cells() may return 2 on the right halve).\n      if (clear_next_cell) {\n        clear_next_cell = false;\n      } else if ((len < 0 ? ptr[mbyte_blen] == NUL\n                          : ptr + mbyte_blen >= text + len)\n                 && ((mbyte_cells == 1\n                      && grid_off2cells(grid, off, max_off) > 1)\n                     || (mbyte_cells == 2\n                         && grid_off2cells(grid, off, max_off) == 1\n                         && grid_off2cells(grid, off + 1, max_off) > 1))) {\n        clear_next_cell = true;\n      }\n\n      schar_copy(grid->chars[off], buf);\n      grid->attrs[off] = attr;\n      if (mbyte_cells == 2) {\n        grid->chars[off + 1][0] = 0;\n        grid->attrs[off + 1] = attr;\n      }\n      put_dirty_first = MIN(put_dirty_first, col);\n      put_dirty_last = MAX(put_dirty_last, col+mbyte_cells);\n    }\n\n    off += mbyte_cells;\n    col += mbyte_cells;\n    ptr += mbyte_blen;\n    if (clear_next_cell) {\n      // This only happens at the end, display one space next.\n      ptr = (char_u *)\" \";\n      len = -1;\n    }\n  }\n\n  if (do_flush) {\n    grid_puts_line_flush(true);\n  }\n}\n\n/// End a group of grid_puts_len calls and send the screen buffer to the UI\n/// layer.\n///\n/// @param set_cursor Move the visible cursor to the end of the changed region.\n///                   This is a workaround for not yet refactored code paths\n///                   and shouldn't be used in new code.\nvoid grid_puts_line_flush(bool set_cursor)\n{\n  assert(put_dirty_row != -1);\n  if (put_dirty_first < put_dirty_last) {\n    if (set_cursor) {\n      ui_grid_cursor_goto(put_dirty_grid->handle, put_dirty_row,\n                          MIN(put_dirty_last, put_dirty_grid->Columns-1));\n    }\n    if (!put_dirty_grid->throttled) {\n      ui_line(put_dirty_grid, put_dirty_row, put_dirty_first, put_dirty_last,\n              put_dirty_last, 0, false);\n    } else if (put_dirty_grid->dirty_col) {\n      if (put_dirty_last > put_dirty_grid->dirty_col[put_dirty_row]) {\n        put_dirty_grid->dirty_col[put_dirty_row] = put_dirty_last;\n      }\n    }\n    put_dirty_first = INT_MAX;\n    put_dirty_last = 0;\n  }\n  put_dirty_row = -1;\n  put_dirty_grid = NULL;\n}\n\n/*\n * Prepare for 'hlsearch' highlighting.\n */\nstatic void start_search_hl(void)\n{\n  if (p_hls && !no_hlsearch) {\n    end_search_hl();  // just in case it wasn't called before\n    last_pat_prog(&search_hl.rm);\n    // Set the time limit to 'redrawtime'.\n    search_hl.tm = profile_setlimit(p_rdt);\n  }\n}\n\n/*\n * Clean up for 'hlsearch' highlighting.\n */\nstatic void end_search_hl(void)\n{\n  if (search_hl.rm.regprog != NULL) {\n    vim_regfree(search_hl.rm.regprog);\n    search_hl.rm.regprog = NULL;\n  }\n}\n\n\n/*\n * Init for calling prepare_search_hl().\n */\nstatic void init_search_hl(win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Setup for match and 'hlsearch' highlighting.  Disable any previous\n  // match\n  matchitem_T *cur = wp->w_match_head;\n  while (cur != NULL) {\n    cur->hl.rm = cur->match;\n    if (cur->hlg_id == 0) {\n      cur->hl.attr = 0;\n    } else {\n      cur->hl.attr = syn_id2attr(cur->hlg_id);\n    }\n    cur->hl.buf = wp->w_buffer;\n    cur->hl.lnum = 0;\n    cur->hl.first_lnum = 0;\n    // Set the time limit to 'redrawtime'.\n    cur->hl.tm = profile_setlimit(p_rdt);\n    cur = cur->next;\n  }\n  search_hl.buf = wp->w_buffer;\n  search_hl.lnum = 0;\n  search_hl.first_lnum = 0;\n  search_hl.attr = win_hl_attr(wp, HLF_L);\n\n  // time limit is set at the toplevel, for all windows\n}\n\n/*\n * Advance to the match in window \"wp\" line \"lnum\" or past it.\n */\nstatic void prepare_search_hl(win_T *wp, linenr_T lnum)\n  FUNC_ATTR_NONNULL_ALL\n{\n  matchitem_T *cur;             // points to the match list\n  match_T     *shl;             // points to search_hl or a match\n  bool shl_flag;                // flag to indicate whether search_hl\n                                // has been processed or not\n\n  // When using a multi-line pattern, start searching at the top\n  // of the window or just after a closed fold.\n  // Do this both for search_hl and the match list.\n  cur = wp->w_match_head;\n  shl_flag = false;\n  while (cur != NULL || shl_flag == false) {\n    if (shl_flag == false) {\n      shl = &search_hl;\n      shl_flag = true;\n    } else {\n      shl = &cur->hl;  // -V595\n    }\n    if (shl->rm.regprog != NULL\n        && shl->lnum == 0\n        && re_multiline(shl->rm.regprog)) {\n      if (shl->first_lnum == 0) {\n        for (shl->first_lnum = lnum;\n             shl->first_lnum > wp->w_topline;\n             shl->first_lnum--) {\n          if (hasFoldingWin(wp, shl->first_lnum - 1, NULL, NULL, true, NULL)) {\n            break;\n          }\n        }\n      }\n      if (cur != NULL) {\n        cur->pos.cur = 0;\n      }\n      bool pos_inprogress = true;  // mark that a position match search is\n                                   // in progress\n      int n = 0;\n      while (shl->first_lnum < lnum && (shl->rm.regprog != NULL\n                                        || (cur != NULL && pos_inprogress))) {\n        next_search_hl(wp, shl, shl->first_lnum, (colnr_T)n,\n                       shl == &search_hl ? NULL : cur);\n        pos_inprogress = !(cur == NULL ||  cur->pos.cur == 0);\n        if (shl->lnum != 0) {\n          shl->first_lnum = shl->lnum\n                            + shl->rm.endpos[0].lnum\n                            - shl->rm.startpos[0].lnum;\n          n = shl->rm.endpos[0].col;\n        } else {\n          ++shl->first_lnum;\n          n = 0;\n        }\n      }\n    }\n    if (shl != &search_hl && cur != NULL) {\n      cur = cur->next;\n    }\n  }\n}\n\n/*\n * Search for a next 'hlsearch' or match.\n * Uses shl->buf.\n * Sets shl->lnum and shl->rm contents.\n * Note: Assumes a previous match is always before \"lnum\", unless\n * shl->lnum is zero.\n * Careful: Any pointers for buffer lines will become invalid.\n */\nstatic void next_search_hl(win_T *win, match_T *shl,               // points to search_hl or a match\n                           linenr_T lnum, colnr_T mincol,                // minimal column for a match\n                           matchitem_T *cur               // to retrieve match positions if any\n                           )\n  FUNC_ATTR_NONNULL_ARG(2)\n{\n  linenr_T l;\n  colnr_T matchcol;\n  long nmatched = 0;\n  int save_called_emsg = called_emsg;\n\n  // for :{range}s/pat only highlight inside the range\n  if (lnum < search_first_line || lnum > search_last_line) {\n    shl->lnum = 0;\n    return;\n  }\n\n  if (shl->lnum != 0) {\n    // Check for three situations:\n    // 1. If the \"lnum\" is below a previous match, start a new search.\n    // 2. If the previous match includes \"mincol\", use it.\n    // 3. Continue after the previous match.\n    l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;\n    if (lnum > l) {\n      shl->lnum = 0;\n    } else if (lnum < l || shl->rm.endpos[0].col > mincol) {\n      return;\n    }\n  }\n\n  /*\n   * Repeat searching for a match until one is found that includes \"mincol\"\n   * or none is found in this line.\n   */\n  called_emsg = FALSE;\n  for (;; ) {\n    // Stop searching after passing the time limit.\n    if (profile_passed_limit(shl->tm)) {\n      shl->lnum = 0;                    // no match found in time\n      break;\n    }\n    // Three situations:\n    // 1. No useful previous match: search from start of line.\n    // 2. Not Vi compatible or empty match: continue at next character.\n    //    Break the loop if this is beyond the end of the line.\n    // 3. Vi compatible searching: continue at end of previous match.\n    if (shl->lnum == 0) {\n      matchcol = 0;\n    } else if (vim_strchr(p_cpo, CPO_SEARCH) == NULL\n               || (shl->rm.endpos[0].lnum == 0\n                   && shl->rm.endpos[0].col <= shl->rm.startpos[0].col)) {\n      char_u      *ml;\n\n      matchcol = shl->rm.startpos[0].col;\n      ml = ml_get_buf(shl->buf, lnum, false) + matchcol;\n      if (*ml == NUL) {\n        ++matchcol;\n        shl->lnum = 0;\n        break;\n      }\n      matchcol += mb_ptr2len(ml);\n    } else {\n      matchcol = shl->rm.endpos[0].col;\n    }\n\n    shl->lnum = lnum;\n    if (shl->rm.regprog != NULL) {\n      // Remember whether shl->rm is using a copy of the regprog in\n      // cur->match.\n      bool regprog_is_copy = (shl != &search_hl\n                              && cur != NULL\n                              && shl == &cur->hl\n                              && cur->match.regprog == cur->hl.rm.regprog);\n      int timed_out = false;\n\n      nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol,\n                                   &(shl->tm), &timed_out);\n      // Copy the regprog, in case it got freed and recompiled.\n      if (regprog_is_copy) {\n        cur->match.regprog = cur->hl.rm.regprog;\n      }\n      if (called_emsg || got_int || timed_out) {\n        // Error while handling regexp: stop using this regexp.\n        if (shl == &search_hl) {\n          // don't free regprog in the match list, it's a copy\n          vim_regfree(shl->rm.regprog);\n          set_no_hlsearch(true);\n        }\n        shl->rm.regprog = NULL;\n        shl->lnum = 0;\n        got_int = FALSE;  // avoid the \"Type :quit to exit Vim\" message\n        break;\n      }\n    } else if (cur != NULL) {\n      nmatched = next_search_hl_pos(shl, lnum, &(cur->pos), matchcol);\n    }\n    if (nmatched == 0) {\n      shl->lnum = 0;                    // no match found\n      break;\n    }\n    if (shl->rm.startpos[0].lnum > 0\n        || shl->rm.startpos[0].col >= mincol\n        || nmatched > 1\n        || shl->rm.endpos[0].col > mincol) {\n      shl->lnum += shl->rm.startpos[0].lnum;\n      break;                            // useful match found\n    }\n\n    // Restore called_emsg for assert_fails().\n    called_emsg = save_called_emsg;\n  }\n}\n\n/// If there is a match fill \"shl\" and return one.\n/// Return zero otherwise.\nstatic int next_search_hl_pos(match_T *shl,         // points to a match\n                              linenr_T lnum, posmatch_T *posmatch,  // match positions\n                              colnr_T mincol        // minimal column for a match\n                              )\n  FUNC_ATTR_NONNULL_ALL\n{\n  int i;\n  int found = -1;\n\n  shl->lnum = 0;\n  for (i = posmatch->cur; i < MAXPOSMATCH; i++) {\n    llpos_T *pos = &posmatch->pos[i];\n\n    if (pos->lnum == 0) {\n      break;\n    }\n    if (pos->len == 0 && pos->col < mincol) {\n      continue;\n    }\n    if (pos->lnum == lnum) {\n      if (found >= 0) {\n        // if this match comes before the one at \"found\" then swap\n        // them\n        if (pos->col < posmatch->pos[found].col) {\n          llpos_T tmp = *pos;\n\n          *pos = posmatch->pos[found];\n          posmatch->pos[found] = tmp;\n        }\n      } else {\n        found = i;\n      }\n    }\n  }\n  posmatch->cur = 0;\n  if (found >= 0) {\n    colnr_T start = posmatch->pos[found].col == 0\n                    ? 0: posmatch->pos[found].col - 1;\n    colnr_T end = posmatch->pos[found].col == 0\n                  ? MAXCOL : start + posmatch->pos[found].len;\n\n    shl->lnum = lnum;\n    shl->rm.startpos[0].lnum = 0;\n    shl->rm.startpos[0].col = start;\n    shl->rm.endpos[0].lnum = 0;\n    shl->rm.endpos[0].col = end;\n    shl->is_addpos = true;\n    posmatch->cur = found + 1;\n    return 1;\n  }\n  return 0;\n}\n\n\n/// Fill the grid from 'start_row' to 'end_row', from 'start_col' to 'end_col'\n/// with character 'c1' in first column followed by 'c2' in the other columns.\n/// Use attributes 'attr'.\nvoid grid_fill(ScreenGrid *grid, int start_row, int end_row, int start_col, int end_col, int c1,\n               int c2, int attr)\n{\n  schar_T sc;\n\n  int row_off = 0, col_off = 0;\n  screen_adjust_grid(&grid, &row_off, &col_off);\n  start_row += row_off;\n  end_row += row_off;\n  start_col += col_off;\n  end_col += col_off;\n\n  // safety check\n  if (end_row > grid->Rows) {\n    end_row = grid->Rows;\n  }\n  if (end_col > grid->Columns) {\n    end_col = grid->Columns;\n  }\n\n  // nothing to do\n  if (start_row >= end_row || start_col >= end_col) {\n    return;\n  }\n\n  for (int row = start_row; row < end_row; row++) {\n    // When drawing over the right halve of a double-wide char clear\n    // out the left halve.  When drawing over the left halve of a\n    // double wide-char clear out the right halve.  Only needed in a\n    // terminal.\n    if (start_col > 0 && grid_fix_col(grid, start_col, row) != start_col) {\n      grid_puts_len(grid, (char_u *)\" \", 1, row, start_col - 1, 0);\n    }\n    if (end_col < grid->Columns\n        && grid_fix_col(grid, end_col, row) != end_col) {\n      grid_puts_len(grid, (char_u *)\" \", 1, row, end_col, 0);\n    }\n\n    // if grid was resized (in ext_multigrid mode), the UI has no redraw updates\n    // for the newly resized grid. It is better mark everything as dirty and\n    // send all the updates.\n    int dirty_first = INT_MAX;\n    int dirty_last = 0;\n\n    int col = start_col;\n    schar_from_char(sc, c1);\n    int lineoff = grid->line_offset[row];\n    for (col = start_col; col < end_col; col++) {\n      int off = lineoff + col;\n      if (schar_cmp(grid->chars[off], sc)\n          || grid->attrs[off] != attr) {\n        schar_copy(grid->chars[off], sc);\n        grid->attrs[off] = attr;\n        if (dirty_first == INT_MAX) {\n          dirty_first = col;\n        }\n        dirty_last = col+1;\n      }\n      if (col == start_col) {\n        schar_from_char(sc, c2);\n      }\n    }\n    if (dirty_last > dirty_first) {\n      // TODO(bfredl): support a cleared suffix even with a batched line?\n      if (put_dirty_row == row) {\n        put_dirty_first = MIN(put_dirty_first, dirty_first);\n        put_dirty_last = MAX(put_dirty_last, dirty_last);\n      } else if (grid->throttled) {\n        // Note: assumes msg_grid is the only throttled grid\n        assert(grid == &msg_grid);\n        int dirty = 0;\n        if (attr != HL_ATTR(HLF_MSG) || c2 != ' ') {\n          dirty = dirty_last;\n        } else if (c1 != ' ') {\n          dirty = dirty_first + 1;\n        }\n        if (grid->dirty_col && dirty > grid->dirty_col[row]) {\n          grid->dirty_col[row] = dirty;\n        }\n      } else {\n        int last = c2 != ' ' ? dirty_last : dirty_first + (c1 != ' ');\n        ui_line(grid, row, dirty_first, last, dirty_last, attr, false);\n      }\n    }\n\n    if (end_col == grid->Columns) {\n      grid->line_wraps[row] = false;\n    }\n  }\n}\n\n/*\n * Check if there should be a delay.  Used before clearing or redrawing the\n * screen or the command line.\n */\nvoid check_for_delay(int check_msg_scroll)\n{\n  if ((emsg_on_display || (check_msg_scroll && msg_scroll))\n      && !did_wait_return\n      && emsg_silent == 0) {\n    ui_flush();\n    os_delay(1006L, true);\n    emsg_on_display = false;\n    if (check_msg_scroll) {\n      msg_scroll = false;\n    }\n  }\n}\n\n/// (Re)allocates a window grid if size changed while in ext_multigrid mode.\n/// Updates size, offsets and handle for the grid regardless.\n///\n/// If \"doclear\" is true, don't try to copy from the old grid rather clear the\n/// resized grid.\nvoid win_grid_alloc(win_T *wp)\n{\n  ScreenGrid *grid = &wp->w_grid;\n  ScreenGrid *grid_allocated = &wp->w_grid_alloc;\n\n  int rows = wp->w_height_inner;\n  int cols = wp->w_width_inner;\n  int total_rows = wp->w_height_outer;\n  int total_cols = wp->w_width_outer;\n\n  bool want_allocation = ui_has(kUIMultigrid) || wp->w_floating;\n  bool has_allocation = (grid_allocated->chars != NULL);\n\n  if (grid->Rows != rows) {\n    wp->w_lines_valid = 0;\n    xfree(wp->w_lines);\n    wp->w_lines = xcalloc(rows+1, sizeof(wline_T));\n  }\n\n  int was_resized = false;\n  if (want_allocation && (!has_allocation\n                          || grid_allocated->Rows != total_rows\n                          || grid_allocated->Columns != total_cols)) {\n    grid_alloc(grid_allocated, total_rows, total_cols,\n               wp->w_grid_alloc.valid, false);\n    grid_allocated->valid = true;\n    if (wp->w_floating && wp->w_float_config.border) {\n      wp->w_redr_border = true;\n    }\n    was_resized = true;\n  } else if (!want_allocation && has_allocation) {\n    // Single grid mode, all rendering will be redirected to default_grid.\n    // Only keep track of the size and offset of the window.\n    grid_free(grid_allocated);\n    grid_allocated->valid = false;\n    was_resized = true;\n  } else if (want_allocation && has_allocation && !wp->w_grid_alloc.valid) {\n    grid_invalidate(grid_allocated);\n    grid_allocated->valid = true;\n  }\n\n  grid->Rows = rows;\n  grid->Columns = cols;\n\n  if (want_allocation) {\n    grid->target = grid_allocated;\n    grid->row_offset = wp->w_border_adj[0];\n    grid->col_offset = wp->w_border_adj[3];\n  } else {\n    grid->target = &default_grid;\n    grid->row_offset = wp->w_winrow;\n    grid->col_offset = wp->w_wincol;\n  }\n\n  // send grid resize event if:\n  // - a grid was just resized\n  // - screen_resize was called and all grid sizes must be sent\n  // - the UI wants multigrid event (necessary)\n  if ((send_grid_resize || was_resized) && want_allocation) {\n    ui_call_grid_resize(grid_allocated->handle,\n                        grid_allocated->Columns, grid_allocated->Rows);\n  }\n}\n\n/// assign a handle to the grid. The grid need not be allocated.\nvoid grid_assign_handle(ScreenGrid *grid)\n{\n  static int last_grid_handle = DEFAULT_GRID_HANDLE;\n\n  // only assign a grid handle if not already\n  if (grid->handle == 0) {\n    grid->handle = ++last_grid_handle;\n  }\n}\n\n/// Resize the screen to Rows and Columns.\n///\n/// Allocate default_grid.chars[] and other grid arrays.\n///\n/// There may be some time between setting Rows and Columns and (re)allocating\n/// default_grid arrays.  This happens when starting up and when\n/// (manually) changing the shell size.  Always use default_grid.Rows and\n/// default_grid.Columns to access items in default_grid.chars[].  Use Rows\n/// and Columns for positioning text etc. where the final size of the shell is\n/// needed.\nvoid screenalloc(void)\n{\n  // It's possible that we produce an out-of-memory message below, which\n  // will cause this function to be called again.  To break the loop, just\n  // return here.\n  if (resizing) {\n    return;\n  }\n  resizing = true;\n\n  int retry_count = 0;\n\nretry:\n  // Allocation of the screen buffers is done only when the size changes and\n  // when Rows and Columns have been set and we have started doing full\n  // screen stuff.\n  if ((default_grid.chars != NULL\n       && Rows == default_grid.Rows\n       && Columns == default_grid.Columns\n       )\n      || Rows == 0\n      || Columns == 0\n      || (!full_screen && default_grid.chars == NULL)) {\n    resizing = false;\n    return;\n  }\n\n  /*\n   * Note that the window sizes are updated before reallocating the arrays,\n   * thus we must not redraw here!\n   */\n  ++RedrawingDisabled;\n\n  // win_new_shellsize will recompute floats position, but tell the\n  // compositor to not redraw them yet\n  ui_comp_set_screen_valid(false);\n  if (msg_grid.chars) {\n    msg_grid_invalid = true;\n  }\n\n  win_new_shellsize();      // fit the windows in the new sized shell\n\n  comp_col();           // recompute columns for shown command and ruler\n\n  // We're changing the size of the screen.\n  // - Allocate new arrays for default_grid\n  // - Move lines from the old arrays into the new arrays, clear extra\n  //   lines (unless the screen is going to be cleared).\n  // - Free the old arrays.\n  //\n  // If anything fails, make grid arrays NULL, so we don't do anything!\n  // Continuing with the old arrays may result in a crash, because the\n  // size is wrong.\n\n  grid_alloc(&default_grid, Rows, Columns, true, true);\n  StlClickDefinition *new_tab_page_click_defs =\n    xcalloc((size_t)Columns, sizeof(*new_tab_page_click_defs));\n\n  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);\n  xfree(tab_page_click_defs);\n\n  tab_page_click_defs = new_tab_page_click_defs;\n  tab_page_click_defs_size = Columns;\n\n  default_grid.comp_height = Rows;\n  default_grid.comp_width = Columns;\n\n  default_grid.row_offset = 0;\n  default_grid.col_offset = 0;\n  default_grid.handle = DEFAULT_GRID_HANDLE;\n\n  must_redraw = CLEAR;  // need to clear the screen later\n\n  RedrawingDisabled--;\n\n  /*\n   * Do not apply autocommands more than 3 times to avoid an endless loop\n   * in case applying autocommands always changes Rows or Columns.\n   */\n  if (starting == 0 && ++retry_count <= 3) {\n    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);\n    /* In rare cases, autocommands may have altered Rows or Columns,\n    * jump back to check if we need to allocate the screen again. */\n    goto retry;\n  }\n\n  resizing = false;\n}\n\nvoid grid_alloc(ScreenGrid *grid, int rows, int columns, bool copy, bool valid)\n{\n  int new_row;\n  ScreenGrid new = *grid;\n  assert(rows >= 0 && columns >= 0);\n  size_t ncells = (size_t)rows * columns;\n  new.chars = xmalloc(ncells * sizeof(schar_T));\n  new.attrs = xmalloc(ncells * sizeof(sattr_T));\n  new.line_offset = xmalloc((size_t)(rows * sizeof(unsigned)));\n  new.line_wraps = xmalloc((size_t)(rows * sizeof(char_u)));\n\n  new.Rows = rows;\n  new.Columns = columns;\n\n  for (new_row = 0; new_row < new.Rows; new_row++) {\n    new.line_offset[new_row] = new_row * new.Columns;\n    new.line_wraps[new_row] = false;\n\n    grid_clear_line(&new, new.line_offset[new_row], columns, valid);\n\n    if (copy) {\n      // If the screen is not going to be cleared, copy as much as\n      // possible from the old screen to the new one and clear the rest\n      // (used when resizing the window at the \"--more--\" prompt or when\n      // executing an external command, for the GUI).\n      if (new_row < grid->Rows && grid->chars != NULL) {\n        int len = MIN(grid->Columns, new.Columns);\n        memmove(new.chars + new.line_offset[new_row],\n                grid->chars + grid->line_offset[new_row],\n                (size_t)len * sizeof(schar_T));\n        memmove(new.attrs + new.line_offset[new_row],\n                grid->attrs + grid->line_offset[new_row],\n                (size_t)len * sizeof(sattr_T));\n      }\n    }\n  }\n  grid_free(grid);\n  *grid = new;\n\n  // Share a single scratch buffer for all grids, by\n  // ensuring it is as wide as the widest grid.\n  if (linebuf_size < (size_t)columns) {\n    xfree(linebuf_char);\n    xfree(linebuf_attr);\n    linebuf_char = xmalloc(columns * sizeof(schar_T));\n    linebuf_attr = xmalloc(columns * sizeof(sattr_T));\n    linebuf_size = columns;\n  }\n}\n\nvoid grid_free(ScreenGrid *grid)\n{\n  xfree(grid->chars);\n  xfree(grid->attrs);\n  xfree(grid->line_offset);\n  xfree(grid->line_wraps);\n\n  grid->chars = NULL;\n  grid->attrs = NULL;\n  grid->line_offset = NULL;\n  grid->line_wraps = NULL;\n}\n\n/// Doesn't allow reinit, so must only be called by free_all_mem!\nvoid screen_free_all_mem(void)\n{\n  grid_free(&default_grid);\n  xfree(linebuf_char);\n  xfree(linebuf_attr);\n}\n\n/// Clear tab_page_click_defs table\n///\n/// @param[out]  tpcd  Table to clear.\n/// @param[in]  tpcd_size  Size of the table.\nvoid clear_tab_page_click_defs(StlClickDefinition *const tpcd, const long tpcd_size)\n{\n  if (tpcd != NULL) {\n    for (long i = 0; i < tpcd_size; i++) {\n      if (i == 0 || tpcd[i].func != tpcd[i - 1].func) {\n        xfree(tpcd[i].func);\n      }\n    }\n    memset(tpcd, 0, (size_t)tpcd_size * sizeof(tpcd[0]));\n  }\n}\n\nvoid screenclear(void)\n{\n  check_for_delay(false);\n  screenalloc();  // allocate screen buffers if size changed\n\n  int i;\n\n  if (starting == NO_SCREEN || default_grid.chars == NULL) {\n    return;\n  }\n\n  // blank out the default grid\n  for (i = 0; i < default_grid.Rows; i++) {\n    grid_clear_line(&default_grid, default_grid.line_offset[i],\n                    (int)default_grid.Columns, true);\n    default_grid.line_wraps[i] = false;\n  }\n\n  ui_call_grid_clear(1);  // clear the display\n  ui_comp_set_screen_valid(true);\n\n  clear_cmdline = false;\n  mode_displayed = false;\n\n  redraw_all_later(NOT_VALID);\n  redraw_cmdline = true;\n  redraw_tabline = true;\n  redraw_popupmenu = true;\n  pum_invalidate();\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_floating) {\n      wp->w_redr_type = CLEAR;\n    }\n  }\n  if (must_redraw == CLEAR) {\n    must_redraw = NOT_VALID;  // no need to clear again\n  }\n  compute_cmdrow();\n  msg_row = cmdline_row;  // put cursor on last line for messages\n  msg_col = 0;\n  msg_scrolled = 0;  // can't scroll back\n  msg_didany = false;\n  msg_didout = false;\n  if (HL_ATTR(HLF_MSG) > 0 && msg_use_grid() && msg_grid.chars) {\n    grid_invalidate(&msg_grid);\n    msg_grid_validate();\n    msg_grid_invalid = false;\n    clear_cmdline = true;\n  }\n}\n\n/// clear a line in the grid starting at \"off\" until \"width\" characters\n/// are cleared.\nvoid grid_clear_line(ScreenGrid *grid, unsigned off, int width, bool valid)\n{\n  for (int col = 0; col < width; col++) {\n    schar_from_ascii(grid->chars[off + col], ' ');\n  }\n  int fill = valid ? 0 : -1;\n  (void)memset(grid->attrs + off, fill, (size_t)width * sizeof(sattr_T));\n}\n\nvoid grid_invalidate(ScreenGrid *grid)\n{\n  (void)memset(grid->attrs, -1, grid->Rows * grid->Columns * sizeof(sattr_T));\n}\n\nbool grid_invalid_row(ScreenGrid *grid, int row)\n{\n  return grid->attrs[grid->line_offset[row]] < 0;\n}\n\n\n\n/// Copy part of a grid line for vertically split window.\nstatic void linecopy(ScreenGrid *grid, int to, int from, int col, int width)\n{\n  unsigned off_to = grid->line_offset[to] + col;\n  unsigned off_from = grid->line_offset[from] + col;\n\n  memmove(grid->chars + off_to, grid->chars + off_from,\n          width * sizeof(schar_T));\n  memmove(grid->attrs + off_to, grid->attrs + off_from,\n          width * sizeof(sattr_T));\n}\n\n/*\n * Set cursor to its position in the current window.\n */\nvoid setcursor(void)\n{\n  if (redrawing()) {\n    validate_cursor();\n\n    ScreenGrid *grid = &curwin->w_grid;\n    int row = curwin->w_wrow;\n    int col = curwin->w_wcol;\n    if (curwin->w_p_rl) {\n      // With 'rightleft' set and the cursor on a double-wide character,\n      // position it on the leftmost column.\n      col = curwin->w_width_inner - curwin->w_wcol\n            - ((utf_ptr2cells(get_cursor_pos_ptr()) == 2\n                && vim_isprintc(gchar_cursor())) ? 2 : 1);\n    }\n\n    screen_adjust_grid(&grid, &row, &col);\n    ui_grid_cursor_goto(grid->handle, row, col);\n  }\n}\n\n/// Scroll 'line_count' lines at 'row' in window 'wp'.\n///\n/// Positive `line_count' means scrolling down, so that more space is available\n/// at 'row'. Negative `line_count` implies deleting lines at `row`.\nvoid win_scroll_lines(win_T *wp, int row, int line_count)\n{\n  if (!redrawing() || line_count == 0) {\n    return;\n  }\n\n  // No lines are being moved, just draw over the entire area\n  if (row + abs(line_count) >= wp->w_grid.Rows) {\n    return;\n  }\n\n  if (line_count < 0) {\n    grid_del_lines(&wp->w_grid, row, -line_count,\n                   wp->w_grid.Rows, 0, wp->w_grid.Columns);\n  } else {\n    grid_ins_lines(&wp->w_grid, row, line_count,\n                   wp->w_grid.Rows, 0, wp->w_grid.Columns);\n  }\n}\n\n/*\n * The rest of the routines in this file perform screen manipulations. The\n * given operation is performed physically on the screen. The corresponding\n * change is also made to the internal screen image. In this way, the editor\n * anticipates the effect of editing changes on the appearance of the screen.\n * That way, when we call screenupdate a complete redraw isn't usually\n * necessary. Another advantage is that we can keep adding code to anticipate\n * screen changes, and in the meantime, everything still works.\n */\n\n\n/// insert lines on the screen and move the existing lines down\n/// 'line_count' is the number of lines to be inserted.\n/// 'end' is the line after the scrolled part. Normally it is Rows.\n/// 'col' is the column from with we start inserting.\n//\n/// 'row', 'col' and 'end' are relative to the start of the region.\nvoid grid_ins_lines(ScreenGrid *grid, int row, int line_count, int end, int col, int width)\n{\n  int i;\n  int j;\n  unsigned temp;\n\n  int row_off = 0;\n  screen_adjust_grid(&grid, &row_off, &col);\n  row += row_off;\n  end += row_off;\n\n  if (line_count <= 0) {\n    return;\n  }\n\n  // Shift line_offset[] line_count down to reflect the inserted lines.\n  // Clear the inserted lines.\n  for (i = 0; i < line_count; i++) {\n    if (width != grid->Columns) {\n      // need to copy part of a line\n      j = end - 1 - i;\n      while ((j -= line_count) >= row) {\n        linecopy(grid, j + line_count, j, col, width);\n      }\n      j += line_count;\n      grid_clear_line(grid, grid->line_offset[j] + col, width, false);\n      grid->line_wraps[j] = false;\n    } else {\n      j = end - 1 - i;\n      temp = grid->line_offset[j];\n      while ((j -= line_count) >= row) {\n        grid->line_offset[j + line_count] = grid->line_offset[j];\n        grid->line_wraps[j + line_count] = grid->line_wraps[j];\n      }\n      grid->line_offset[j + line_count] = temp;\n      grid->line_wraps[j + line_count] = false;\n      grid_clear_line(grid, temp, (int)grid->Columns, false);\n    }\n  }\n\n  if (!grid->throttled) {\n    ui_call_grid_scroll(grid->handle, row, end, col, col+width, -line_count, 0);\n  }\n\n  return;\n}\n\n/// delete lines on the screen and move lines up.\n/// 'end' is the line after the scrolled part. Normally it is Rows.\n/// When scrolling region used 'off' is the offset from the top for the region.\n/// 'row' and 'end' are relative to the start of the region.\nvoid grid_del_lines(ScreenGrid *grid, int row, int line_count, int end, int col, int width)\n{\n  int j;\n  int i;\n  unsigned temp;\n\n  int row_off = 0;\n  screen_adjust_grid(&grid, &row_off, &col);\n  row += row_off;\n  end += row_off;\n\n  if (line_count <= 0) {\n    return;\n  }\n\n  // Now shift line_offset[] line_count up to reflect the deleted lines.\n  // Clear the inserted lines.\n  for (i = 0; i < line_count; i++) {\n    if (width != grid->Columns) {\n      // need to copy part of a line\n      j = row + i;\n      while ((j += line_count) <= end - 1) {\n        linecopy(grid, j - line_count, j, col, width);\n      }\n      j -= line_count;\n      grid_clear_line(grid, grid->line_offset[j] + col, width, false);\n      grid->line_wraps[j] = false;\n    } else {\n      // whole width, moving the line pointers is faster\n      j = row + i;\n      temp = grid->line_offset[j];\n      while ((j += line_count) <= end - 1) {\n        grid->line_offset[j - line_count] = grid->line_offset[j];\n        grid->line_wraps[j - line_count] = grid->line_wraps[j];\n      }\n      grid->line_offset[j - line_count] = temp;\n      grid->line_wraps[j - line_count] = false;\n      grid_clear_line(grid, temp, (int)grid->Columns, false);\n    }\n  }\n\n  if (!grid->throttled) {\n    ui_call_grid_scroll(grid->handle, row, end, col, col+width, line_count, 0);\n  }\n\n  return;\n}\n\n\n// Show the current mode and ruler.\n//\n// If clear_cmdline is true, clear the rest of the cmdline.\n// If clear_cmdline is false there may be a message there that needs to be\n// cleared only if a mode is shown.\n// Return the length of the message (0 if no message).\nint showmode(void)\n{\n  int need_clear;\n  int length = 0;\n  int do_mode;\n  int attr;\n  int sub_attr;\n\n  if (ui_has(kUIMessages) && clear_cmdline) {\n    msg_ext_clear(true);\n  }\n\n  // don't make non-flushed message part of the showmode\n  msg_ext_ui_flush();\n\n  msg_grid_validate();\n\n  do_mode = ((p_smd && msg_silent == 0)\n             && ((State & TERM_FOCUS)\n                 || (State & INSERT)\n                 || restart_edit\n                 || VIsual_active));\n  if (do_mode || reg_recording != 0) {\n    // Don't show mode right now, when not redrawing or inside a mapping.\n    // Call char_avail() only when we are going to show something, because\n    // it takes a bit of time.\n    if (!redrawing() || (char_avail() && !KeyTyped) || msg_silent != 0) {\n      redraw_cmdline = true;                    // show mode later\n      return 0;\n    }\n\n    bool nwr_save = need_wait_return;\n\n    // wait a bit before overwriting an important message\n    check_for_delay(FALSE);\n\n    // if the cmdline is more than one line high, erase top lines\n    need_clear = clear_cmdline;\n    if (clear_cmdline && cmdline_row < Rows - 1) {\n      msg_clr_cmdline();  // will reset clear_cmdline\n    }\n\n    // Position on the last line in the window, column 0\n    msg_pos_mode();\n    attr = HL_ATTR(HLF_CM);                     // Highlight mode\n\n    // When the screen is too narrow to show the entire mode message,\n    // avoid scrolling and truncate instead.\n    msg_no_more = true;\n    int save_lines_left = lines_left;\n    lines_left = 0;\n\n    if (do_mode) {\n      MSG_PUTS_ATTR(\"--\", attr);\n      // CTRL-X in Insert mode\n      if (edit_submode != NULL && !shortmess(SHM_COMPLETIONMENU)) {\n        // These messages can get long, avoid a wrap in a narrow window.\n        // Prefer showing edit_submode_extra. With external messages there\n        // is no imposed limit.\n        if (ui_has(kUIMessages)) {\n          length = INT_MAX;\n        } else {\n          length = (Rows - msg_row) * Columns - 3;\n        }\n        if (edit_submode_extra != NULL) {\n          length -= vim_strsize(edit_submode_extra);\n        }\n        if (length > 0) {\n          if (edit_submode_pre != NULL) {\n            length -= vim_strsize(edit_submode_pre);\n          }\n          if (length - vim_strsize(edit_submode) > 0) {\n            if (edit_submode_pre != NULL) {\n              msg_puts_attr((const char *)edit_submode_pre, attr);\n            }\n            msg_puts_attr((const char *)edit_submode, attr);\n          }\n          if (edit_submode_extra != NULL) {\n            MSG_PUTS_ATTR(\" \", attr);  // Add a space in between.\n            if ((int)edit_submode_highl < (int)HLF_COUNT) {\n              sub_attr = win_hl_attr(curwin, edit_submode_highl);\n            } else {\n              sub_attr = attr;\n            }\n            msg_puts_attr((const char *)edit_submode_extra, sub_attr);\n          }\n        }\n      } else {\n        if (State & TERM_FOCUS) {\n          MSG_PUTS_ATTR(_(\" TERMINAL\"), attr);\n        } else if (State & VREPLACE_FLAG) {\n          MSG_PUTS_ATTR(_(\" VREPLACE\"), attr);\n        } else if (State & REPLACE_FLAG) {\n          MSG_PUTS_ATTR(_(\" REPLACE\"), attr);\n        } else if (State & INSERT) {\n          if (p_ri) {\n            MSG_PUTS_ATTR(_(\" REVERSE\"), attr);\n          }\n          MSG_PUTS_ATTR(_(\" INSERT\"), attr);\n        } else if (restart_edit == 'I' || restart_edit == 'i'\n                   || restart_edit == 'a') {\n          MSG_PUTS_ATTR(_(\" (insert)\"), attr);\n        } else if (restart_edit == 'R') {\n          MSG_PUTS_ATTR(_(\" (replace)\"), attr);\n        } else if (restart_edit == 'V') {\n          MSG_PUTS_ATTR(_(\" (vreplace)\"), attr);\n        }\n        if (p_hkmap) {\n          MSG_PUTS_ATTR(_(\" Hebrew\"), attr);\n        }\n        if (State & LANGMAP) {\n          if (curwin->w_p_arab) {\n            MSG_PUTS_ATTR(_(\" Arabic\"), attr);\n          } else if (get_keymap_str(curwin, (char_u *)\" (%s)\",\n                                    NameBuff, MAXPATHL)) {\n            MSG_PUTS_ATTR(NameBuff, attr);\n          }\n        }\n        if ((State & INSERT) && p_paste) {\n          MSG_PUTS_ATTR(_(\" (paste)\"), attr);\n        }\n\n        if (VIsual_active) {\n          char *p;\n\n          /* Don't concatenate separate words to avoid translation\n           * problems. */\n          switch ((VIsual_select ? 4 : 0)\n                  + (VIsual_mode == Ctrl_V) * 2\n                  + (VIsual_mode == 'V')) {\n          case 0: p = N_(\" VISUAL\"); break;\n          case 1: p = N_(\" VISUAL LINE\"); break;\n          case 2: p = N_(\" VISUAL BLOCK\"); break;\n          case 4: p = N_(\" SELECT\"); break;\n          case 5: p = N_(\" SELECT LINE\"); break;\n          default: p = N_(\" SELECT BLOCK\"); break;\n          }\n          MSG_PUTS_ATTR(_(p), attr);\n        }\n        MSG_PUTS_ATTR(\" --\", attr);\n      }\n\n      need_clear = TRUE;\n    }\n    if (reg_recording != 0\n        && edit_submode == NULL             // otherwise it gets too long\n        ) {\n      recording_mode(attr);\n      need_clear = true;\n    }\n\n    mode_displayed = true;\n    if (need_clear || clear_cmdline) {\n      msg_clr_eos();\n    }\n    msg_didout = false;                 // overwrite this message\n    length = msg_col;\n    msg_col = 0;\n    msg_no_more = false;\n    lines_left = save_lines_left;\n    need_wait_return = nwr_save;        // never ask for hit-return for this\n  } else if (clear_cmdline && msg_silent == 0) {\n    // Clear the whole command line.  Will reset \"clear_cmdline\".\n    msg_clr_cmdline();\n  }\n\n  // NB: also handles clearing the showmode if it was empty or disabled\n  msg_ext_flush_showmode();\n\n  // In Visual mode the size of the selected area must be redrawn.\n  if (VIsual_active) {\n    clear_showcmd();\n  }\n\n  // If the last window has no status line, the ruler is after the mode\n  // message and must be redrawn\n  win_T *last = lastwin_nofloating();\n  if (redrawing() && last->w_status_height == 0) {\n    win_redr_ruler(last, true);\n  }\n  redraw_cmdline = false;\n  clear_cmdline = false;\n\n  return length;\n}\n\n/*\n * Position for a mode message.\n */\nstatic void msg_pos_mode(void)\n{\n  msg_col = 0;\n  msg_row = Rows - 1;\n}\n\n/// Delete mode message.  Used when ESC is typed which is expected to end\n/// Insert mode (but Insert mode didn't end yet!).\n/// Caller should check \"mode_displayed\".\nvoid unshowmode(bool force)\n{\n  // Don't delete it right now, when not redrawing or inside a mapping.\n  if (!redrawing() || (!force && char_avail() && !KeyTyped)) {\n    redraw_cmdline = true;  // delete mode later\n  } else {\n    clearmode();\n  }\n}\n\n// Clear the mode message.\nvoid clearmode(void)\n{\n  const int save_msg_row = msg_row;\n  const int save_msg_col = msg_col;\n\n  msg_ext_ui_flush();\n  msg_pos_mode();\n  if (reg_recording != 0) {\n    recording_mode(HL_ATTR(HLF_CM));\n  }\n  msg_clr_eos();\n  msg_ext_flush_showmode();\n\n  msg_col = save_msg_col;\n  msg_row = save_msg_row;\n}\n\nstatic void recording_mode(int attr)\n{\n  MSG_PUTS_ATTR(_(\"recording\"), attr);\n  if (!shortmess(SHM_RECORDING)) {\n    char_u s[4];\n    snprintf((char *)s, ARRAY_SIZE(s), \" @%c\", reg_recording);\n    MSG_PUTS_ATTR(s, attr);\n  }\n}\n\n/*\n * Draw the tab pages line at the top of the Vim window.\n */\nvoid draw_tabline(void)\n{\n  int tabcount = 0;\n  int tabwidth = 0;\n  int col = 0;\n  int scol = 0;\n  int attr;\n  win_T       *wp;\n  win_T       *cwp;\n  int wincount;\n  int modified;\n  int c;\n  int len;\n  int attr_nosel = HL_ATTR(HLF_TP);\n  int attr_fill = HL_ATTR(HLF_TPF);\n  char_u      *p;\n  int room;\n  int use_sep_chars = (t_colors < 8\n                       );\n\n  if (default_grid.chars == NULL) {\n    return;\n  }\n  redraw_tabline = false;\n\n  if (ui_has(kUITabline)) {\n    ui_ext_tabline_update();\n    return;\n  }\n\n  if (tabline_height() < 1) {\n    return;\n  }\n\n\n  // Init TabPageIdxs[] to zero: Clicking outside of tabs has no effect.\n  assert(Columns == tab_page_click_defs_size);\n  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);\n\n  // Use the 'tabline' option if it's set.\n  if (*p_tal != NUL) {\n    int saved_did_emsg = did_emsg;\n\n    // Check for an error.  If there is one we would loop in redrawing the\n    // screen.  Avoid that by making 'tabline' empty.\n    did_emsg = false;\n    win_redr_custom(NULL, false);\n    if (did_emsg) {\n      set_string_option_direct(\"tabline\", -1,\n                               (char_u *)\"\", OPT_FREE, SID_ERROR);\n    }\n    did_emsg |= saved_did_emsg;\n  } else {\n    FOR_ALL_TABS(tp) {\n      ++tabcount;\n    }\n\n    if (tabcount > 0) {\n      tabwidth = (Columns - 1 + tabcount / 2) / tabcount;\n    }\n\n    if (tabwidth < 6) {\n      tabwidth = 6;\n    }\n\n    attr = attr_nosel;\n    tabcount = 0;\n\n    FOR_ALL_TABS(tp) {\n      if (col >= Columns - 4) {\n        break;\n      }\n\n      scol = col;\n\n      if (tp == curtab) {\n        cwp = curwin;\n        wp = firstwin;\n      } else {\n        cwp = tp->tp_curwin;\n        wp = tp->tp_firstwin;\n      }\n\n\n      if (tp->tp_topframe == topframe) {\n        attr = win_hl_attr(cwp, HLF_TPS);\n      }\n      if (use_sep_chars && col > 0) {\n        grid_putchar(&default_grid, '|', 0, col++, attr);\n      }\n\n      if (tp->tp_topframe != topframe) {\n        attr = win_hl_attr(cwp, HLF_TP);\n      }\n\n      grid_putchar(&default_grid, ' ', 0, col++, attr);\n\n      modified = false;\n\n      for (wincount = 0; wp != NULL; wp = wp->w_next, ++wincount) {\n        if (bufIsChanged(wp->w_buffer)) {\n          modified = true;\n        }\n      }\n\n\n      if (modified || wincount > 1) {\n        if (wincount > 1) {\n          vim_snprintf((char *)NameBuff, MAXPATHL, \"%d\", wincount);\n          len = (int)STRLEN(NameBuff);\n          if (col + len >= Columns - 3) {\n            break;\n          }\n          grid_puts_len(&default_grid, NameBuff, len, 0, col,\n                        hl_combine_attr(attr, win_hl_attr(cwp, HLF_T)));\n          col += len;\n        }\n        if (modified) {\n          grid_puts_len(&default_grid, (char_u *)\"+\", 1, 0, col++, attr);\n        }\n        grid_putchar(&default_grid, ' ', 0, col++, attr);\n      }\n\n      room = scol - col + tabwidth - 1;\n      if (room > 0) {\n        // Get buffer name in NameBuff[]\n        get_trans_bufname(cwp->w_buffer);\n        (void)shorten_dir(NameBuff);\n        len = vim_strsize(NameBuff);\n        p = NameBuff;\n        while (len > room) {\n          len -= ptr2cells(p);\n          MB_PTR_ADV(p);\n        }\n        if (len > Columns - col - 1) {\n          len = Columns - col - 1;\n        }\n\n        grid_puts_len(&default_grid, p, (int)STRLEN(p), 0, col, attr);\n        col += len;\n      }\n      grid_putchar(&default_grid, ' ', 0, col++, attr);\n\n      // Store the tab page number in tab_page_click_defs[], so that\n      // jump_to_mouse() knows where each one is.\n      tabcount++;\n      while (scol < col) {\n        tab_page_click_defs[scol++] = (StlClickDefinition) {\n          .type = kStlClickTabSwitch,\n          .tabnr = tabcount,\n          .func = NULL,\n        };\n      }\n    }\n\n    if (use_sep_chars) {\n      c = '_';\n    } else {\n      c = ' ';\n    }\n    grid_fill(&default_grid, 0, 1, col, Columns, c, c, attr_fill);\n\n    // Put an \"X\" for closing the current tab if there are several.\n    if (first_tabpage->tp_next != NULL) {\n      grid_putchar(&default_grid, 'X', 0, Columns - 1, attr_nosel);\n      tab_page_click_defs[Columns - 1] = (StlClickDefinition) {\n        .type = kStlClickTabClose,\n        .tabnr = 999,\n        .func = NULL,\n      };\n    }\n  }\n\n  /* Reset the flag here again, in case evaluating 'tabline' causes it to be\n   * set. */\n  redraw_tabline = false;\n}\n\nvoid ui_ext_tabline_update(void)\n{\n  Array tabs = ARRAY_DICT_INIT;\n  FOR_ALL_TABS(tp) {\n    Dictionary tab_info = ARRAY_DICT_INIT;\n    PUT(tab_info, \"tab\", TABPAGE_OBJ(tp->handle));\n\n    win_T *cwp = (tp == curtab) ? curwin : tp->tp_curwin;\n    get_trans_bufname(cwp->w_buffer);\n    PUT(tab_info, \"name\", STRING_OBJ(cstr_to_string((char *)NameBuff)));\n\n    ADD(tabs, DICTIONARY_OBJ(tab_info));\n  }\n\n  Array buffers = ARRAY_DICT_INIT;\n  FOR_ALL_BUFFERS(buf) {\n    // Do not include unlisted buffers\n    if (!buf->b_p_bl) {\n      continue;\n    }\n\n    Dictionary buffer_info = ARRAY_DICT_INIT;\n    PUT(buffer_info, \"buffer\", BUFFER_OBJ(buf->handle));\n\n    get_trans_bufname(buf);\n    PUT(buffer_info, \"name\", STRING_OBJ(cstr_to_string((char *)NameBuff)));\n\n    ADD(buffers, DICTIONARY_OBJ(buffer_info));\n  }\n\n  ui_call_tabline_update(curtab->handle, tabs, curbuf->handle, buffers);\n}\n\n/*\n * Get buffer name for \"buf\" into NameBuff[].\n * Takes care of special buffer names and translates special characters.\n */\nvoid get_trans_bufname(buf_T *buf)\n{\n  if (buf_spname(buf) != NULL) {\n    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);\n  } else {\n    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n  }\n  trans_characters(NameBuff, MAXPATHL);\n}\n\n/*\n * Get the character to use in a status line.  Get its attributes in \"*attr\".\n */\nstatic int fillchar_status(int *attr, win_T *wp)\n{\n  int fill;\n  bool is_curwin = (wp == curwin);\n  if (is_curwin) {\n    *attr = win_hl_attr(wp, HLF_S);\n    fill = wp->w_p_fcs_chars.stl;\n  } else {\n    *attr = win_hl_attr(wp, HLF_SNC);\n    fill = wp->w_p_fcs_chars.stlnc;\n  }\n  /* Use fill when there is highlighting, and highlighting of current\n   * window differs, or the fillchars differ, or this is not the\n   * current window */\n  if (*attr != 0 && ((win_hl_attr(wp, HLF_S) != win_hl_attr(wp, HLF_SNC)\n                      || !is_curwin || ONE_WINDOW)\n                     || (wp->w_p_fcs_chars.stl != wp->w_p_fcs_chars.stlnc))) {\n    return fill;\n  }\n  if (is_curwin) {\n    return '^';\n  }\n  return '=';\n}\n\n/*\n * Get the character to use in a separator between vertically split windows.\n * Get its attributes in \"*attr\".\n */\nstatic int fillchar_vsep(win_T *wp, int *attr)\n{\n  *attr = win_hl_attr(wp, HLF_C);\n  return wp->w_p_fcs_chars.vert;\n}\n\n/*\n * Return TRUE if redrawing should currently be done.\n */\nint redrawing(void)\n{\n  return !RedrawingDisabled\n         && !(p_lz && char_avail() && !KeyTyped && !do_redraw);\n}\n\n/*\n * Return TRUE if printing messages should currently be done.\n */\nint messaging(void)\n{\n  return !(p_lz && char_avail() && !KeyTyped);\n}\n\n/// Show current status info in ruler and various other places\n///\n/// @param always  if false, only show ruler if position has changed.\nvoid showruler(bool always)\n{\n  if (!always && !redrawing()) {\n    return;\n  }\n  if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height) {\n    redraw_custom_statusline(curwin);\n  } else {\n    win_redr_ruler(curwin, always);\n  }\n\n  if (need_maketitle\n      || (p_icon && (stl_syntax & STL_IN_ICON))\n      || (p_title && (stl_syntax & STL_IN_TITLE))) {\n    maketitle();\n  }\n  // Redraw the tab pages line if needed.\n  if (redraw_tabline) {\n    draw_tabline();\n  }\n}\n\nstatic void win_redr_ruler(win_T *wp, bool always)\n{\n  static bool did_show_ext_ruler = false;\n\n  // If 'ruler' off or redrawing disabled, don't do anything\n  if (!p_ru) {\n    return;\n  }\n\n  /*\n   * Check if cursor.lnum is valid, since win_redr_ruler() may be called\n   * after deleting lines, before cursor.lnum is corrected.\n   */\n  if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count) {\n    return;\n  }\n\n  // Don't draw the ruler while doing insert-completion, it might overwrite\n  // the (long) mode message.\n  if (wp == lastwin && lastwin->w_status_height == 0) {\n    if (edit_submode != NULL) {\n      return;\n    }\n  }\n\n  if (*p_ruf) {\n    int save_called_emsg = called_emsg;\n\n    called_emsg = false;\n    win_redr_custom(wp, true);\n    if (called_emsg) {\n      set_string_option_direct(\"rulerformat\", -1, (char_u *)\"\",\n                               OPT_FREE, SID_ERROR);\n    }\n    called_emsg |= save_called_emsg;\n    return;\n  }\n\n  /*\n   * Check if not in Insert mode and the line is empty (will show \"0-1\").\n   */\n  int empty_line = FALSE;\n  if (!(State & INSERT)\n      && *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL) {\n    empty_line = TRUE;\n  }\n\n  /*\n   * Only draw the ruler when something changed.\n   */\n  validate_virtcol_win(wp);\n  if (redraw_cmdline\n      || always\n      || wp->w_cursor.lnum != wp->w_ru_cursor.lnum\n      || wp->w_cursor.col != wp->w_ru_cursor.col\n      || wp->w_virtcol != wp->w_ru_virtcol\n      || wp->w_cursor.coladd != wp->w_ru_cursor.coladd\n      || wp->w_topline != wp->w_ru_topline\n      || wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count\n      || wp->w_topfill != wp->w_ru_topfill\n      || empty_line != wp->w_ru_empty) {\n    int width;\n    int row;\n    int fillchar;\n    int attr;\n    int off;\n    bool part_of_status = false;\n\n    if (wp->w_status_height) {\n      row = W_ENDROW(wp);\n      fillchar = fillchar_status(&attr, wp);\n      off = wp->w_wincol;\n      width = wp->w_width;\n      part_of_status = true;\n    } else {\n      row = Rows - 1;\n      fillchar = ' ';\n      attr = HL_ATTR(HLF_MSG);\n      width = Columns;\n      off = 0;\n    }\n\n    // In list mode virtcol needs to be recomputed\n    colnr_T virtcol = wp->w_virtcol;\n    if (wp->w_p_list && wp->w_p_lcs_chars.tab1 == NUL) {\n      wp->w_p_list = false;\n      getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);\n      wp->w_p_list = true;\n    }\n\n#define RULER_BUF_LEN 70\n    char_u buffer[RULER_BUF_LEN];\n\n    /*\n     * Some sprintfs return the length, some return a pointer.\n     * To avoid portability problems we use strlen() here.\n     */\n    vim_snprintf((char *)buffer, RULER_BUF_LEN, \"%\" PRId64 \",\",\n                 (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L\n                                                          : (int64_t)wp->w_cursor.lnum);\n    size_t len = STRLEN(buffer);\n    col_print(buffer + len, RULER_BUF_LEN - len,\n              empty_line ? 0 : (int)wp->w_cursor.col + 1,\n              (int)virtcol + 1);\n\n    /*\n     * Add a \"50%\" if there is room for it.\n     * On the last line, don't print in the last column (scrolls the\n     * screen up on some terminals).\n     */\n    int i = (int)STRLEN(buffer);\n    get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);\n    int o = i + vim_strsize(buffer + i + 1);\n    if (wp->w_status_height == 0) {  // can't use last char of screen\n      o++;\n    }\n    int this_ru_col = ru_col - (Columns - width);\n    if (this_ru_col < 0) {\n      this_ru_col = 0;\n    }\n    // Never use more than half the window/screen width, leave the other half\n    // for the filename.\n    if (this_ru_col < (width + 1) / 2) {\n      this_ru_col = (width + 1) / 2;\n    }\n    if (this_ru_col + o < width) {\n      // Need at least 3 chars left for get_rel_pos() + NUL.\n      while (this_ru_col + o < width && RULER_BUF_LEN > i + 4) {\n        i += utf_char2bytes(fillchar, buffer + i);\n        o++;\n      }\n      get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);\n    }\n\n    if (ui_has(kUIMessages) && !part_of_status) {\n      Array content = ARRAY_DICT_INIT;\n      Array chunk = ARRAY_DICT_INIT;\n      ADD(chunk, INTEGER_OBJ(attr));\n      ADD(chunk, STRING_OBJ(cstr_to_string((char *)buffer)));\n      ADD(content, ARRAY_OBJ(chunk));\n      ui_call_msg_ruler(content);\n      did_show_ext_ruler = true;\n    } else {\n      if (did_show_ext_ruler) {\n        ui_call_msg_ruler((Array)ARRAY_DICT_INIT);\n        did_show_ext_ruler = false;\n      }\n      // Truncate at window boundary.\n      o = 0;\n      for (i = 0; buffer[i] != NUL; i += utfc_ptr2len(buffer + i)) {\n        o += utf_ptr2cells(buffer + i);\n        if (this_ru_col + o > width) {\n          buffer[i] = NUL;\n          break;\n        }\n      }\n\n      ScreenGrid *grid = part_of_status ? &default_grid : &msg_grid_adj;\n      grid_puts(grid, buffer, row, this_ru_col + off, attr);\n      grid_fill(grid, row, row + 1,\n                this_ru_col + off + (int)STRLEN(buffer), off + width, fillchar,\n                fillchar, attr);\n    }\n\n    wp->w_ru_cursor = wp->w_cursor;\n    wp->w_ru_virtcol = wp->w_virtcol;\n    wp->w_ru_empty = empty_line;\n    wp->w_ru_topline = wp->w_topline;\n    wp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;\n    wp->w_ru_topfill = wp->w_topfill;\n  }\n}\n\n/*\n * Return the width of the 'number' and 'relativenumber' column.\n * Caller may need to check if 'number' or 'relativenumber' is set.\n * Otherwise it depends on 'numberwidth' and the line count.\n */\nint number_width(win_T *wp)\n{\n  int n;\n  linenr_T lnum;\n\n  if (wp->w_p_rnu && !wp->w_p_nu) {\n    // cursor line shows \"0\"\n    lnum = wp->w_height_inner;\n  } else {\n    // cursor line shows absolute line number\n    lnum = wp->w_buffer->b_ml.ml_line_count;\n  }\n\n  if (lnum == wp->w_nrwidth_line_count) {\n    return wp->w_nrwidth_width;\n  }\n  wp->w_nrwidth_line_count = lnum;\n\n  n = 0;\n  do {\n    lnum /= 10;\n    ++n;\n  } while (lnum > 0);\n\n  // 'numberwidth' gives the minimal width plus one\n  if (n < wp->w_p_nuw - 1) {\n    n = wp->w_p_nuw - 1;\n  }\n\n  // If 'signcolumn' is set to 'number' and there is a sign to display, then\n  // the minimal width for the number column is 2.\n  if (n < 2 && (wp->w_buffer->b_signlist != NULL)\n      && (*wp->w_p_scl == 'n' && *(wp->w_p_scl + 1) == 'u')) {\n    n = 2;\n  }\n\n  wp->w_nrwidth_width = n;\n  return n;\n}\n\n/// Used when 'cursorlineopt' contains \"screenline\": compute the margins between\n/// which the highlighting is used.\nstatic void margin_columns_win(win_T *wp, int *left_col, int *right_col)\n{\n  // cache previous calculations depending on w_virtcol\n  static int saved_w_virtcol;\n  static win_T *prev_wp;\n  static int prev_left_col;\n  static int prev_right_col;\n  static int prev_col_off;\n\n  int cur_col_off = win_col_off(wp);\n  int width1;\n  int width2;\n\n  if (saved_w_virtcol == wp->w_virtcol && prev_wp == wp\n      && prev_col_off == cur_col_off) {\n    *right_col = prev_right_col;\n    *left_col = prev_left_col;\n    return;\n  }\n\n  width1 = wp->w_width - cur_col_off;\n  width2 = width1 + win_col_off2(wp);\n\n  *left_col = 0;\n  *right_col = width1;\n\n  if (wp->w_virtcol >= (colnr_T)width1) {\n    *right_col = width1 + ((wp->w_virtcol - width1) / width2 + 1) * width2;\n  }\n  if (wp->w_virtcol >= (colnr_T)width1 && width2 > 0) {\n    *left_col = (wp->w_virtcol - width1) / width2 * width2 + width1;\n  }\n\n  // cache values\n  prev_left_col = *left_col;\n  prev_right_col = *right_col;\n  prev_wp = wp;\n  saved_w_virtcol = wp->w_virtcol;\n  prev_col_off = cur_col_off;\n}\n\n/// Set dimensions of the Nvim application \"shell\".\nvoid screen_resize(int width, int height)\n{\n  static bool recursive = false;\n\n  // Avoid recursiveness, can happen when setting the window size causes\n  // another window-changed signal.\n  if (updating_screen || recursive) {\n    return;\n  }\n\n  if (width < 0 || height < 0) {    // just checking...\n    return;\n  }\n\n  if (State == HITRETURN || State == SETWSIZE) {\n    // postpone the resizing\n    State = SETWSIZE;\n    return;\n  }\n\n  /* curwin->w_buffer can be NULL when we are closing a window and the\n   * buffer has already been closed and removing a scrollbar causes a resize\n   * event. Don't resize then, it will happen after entering another buffer.\n   */\n  if (curwin->w_buffer == NULL) {\n    return;\n  }\n\n  recursive = true;\n\n  Rows = height;\n  Columns = width;\n  check_shellsize();\n  int max_p_ch = Rows - min_rows() + 1;\n  if (!ui_has(kUIMessages) && p_ch > max_p_ch) {\n    p_ch = max_p_ch ? max_p_ch : 1;\n  }\n  height = Rows;\n  width = Columns;\n  p_lines = Rows;\n  p_columns = Columns;\n  ui_call_grid_resize(1, width, height);\n\n  send_grid_resize = true;\n\n  /* The window layout used to be adjusted here, but it now happens in\n   * screenalloc() (also invoked from screenclear()).  That is because the\n   * \"recursive\" check above may skip this, but not screenalloc(). */\n\n  if (State != ASKMORE && State != EXTERNCMD && State != CONFIRM) {\n    screenclear();\n  }\n\n  if (starting != NO_SCREEN) {\n    maketitle();\n    changed_line_abv_curs();\n    invalidate_botline();\n\n    /*\n     * We only redraw when it's needed:\n     * - While at the more prompt or executing an external command, don't\n     *   redraw, but position the cursor.\n     * - While editing the command line, only redraw that.\n     * - in Ex mode, don't redraw anything.\n     * - Otherwise, redraw right now, and position the cursor.\n     * Always need to call update_screen() or screenalloc(), to make\n     * sure Rows/Columns and the size of the screen is correct!\n     */\n    if (State == ASKMORE || State == EXTERNCMD || State == CONFIRM\n        || exmode_active) {\n      screenalloc();\n      if (msg_grid.chars) {\n        msg_grid_validate();\n      }\n      // TODO(bfredl): sometimes messes up the output. Implement clear+redraw\n      // also for the pager? (or: what if the pager was just a modal window?)\n      ui_comp_set_screen_valid(true);\n      repeat_message();\n    } else {\n      if (curwin->w_p_scb) {\n        do_check_scrollbind(true);\n      }\n      if (State & CMDLINE) {\n        redraw_popupmenu = false;\n        update_screen(NOT_VALID);\n        redrawcmdline();\n        if (pum_drawn()) {\n          cmdline_pum_display(false);\n        }\n      } else {\n        update_topline(curwin);\n        if (pum_drawn()) {\n          // TODO(bfredl): ins_compl_show_pum wants to redraw the screen first.\n          // For now make sure the nested update_screen(0) won't redraw the\n          // pum at the old position. Try to untangle this later.\n          redraw_popupmenu = false;\n          ins_compl_show_pum();\n        }\n        update_screen(NOT_VALID);\n        if (redrawing()) {\n          setcursor();\n        }\n      }\n    }\n    ui_flush();\n  }\n  recursive = false;\n}\n\n/// Check if the new Nvim application \"shell\" dimensions are valid.\n/// Correct it if it's too small or way too big.\nvoid check_shellsize(void)\n{\n  if (Rows < min_rows()) {\n    // need room for one window and command line\n    Rows = min_rows();\n  }\n  limit_screen_size();\n}\n\n// Limit Rows and Columns to avoid an overflow in Rows * Columns.\nvoid limit_screen_size(void)\n{\n  if (Columns < MIN_COLUMNS) {\n    Columns = MIN_COLUMNS;\n  } else if (Columns > 10000) {\n    Columns = 10000;\n  }\n\n  if (Rows > 1000) {\n    Rows = 1000;\n  }\n}\n\nvoid win_new_shellsize(void)\n{\n  static long old_Rows = 0;\n  static long old_Columns = 0;\n\n  if (old_Rows != Rows) {\n    // If 'window' uses the whole screen, keep it using that.\n    // Don't change it when set with \"-w size\" on the command line.\n    if (p_window == old_Rows - 1 || (old_Rows == 0 && p_window == 0)) {\n      p_window = Rows - 1;\n    }\n    old_Rows = Rows;\n    shell_new_rows();  // update window sizes\n  }\n  if (old_Columns != Columns) {\n    old_Columns = Columns;\n    shell_new_columns();  // update window sizes\n  }\n}\n\nwin_T *get_win_by_grid_handle(handle_T handle)\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_grid_alloc.handle == handle) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n"}, "20": {"id": 20, "path": "src/nvim/lib/kvec.h", "content": "// The MIT License\n//\n// Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// An example:\n//\n//     #include \"kvec.h\"\n//     int main() {\n//       kvec_t(int) array = KV_INITIAL_VALUE;\n//       kv_push(array, 10); // append\n//       kv_a(array, 20) = 5; // dynamic\n//       kv_A(array, 20) = 4; // static\n//       kv_destroy(array);\n//       return 0;\n//     }\n\n#ifndef NVIM_LIB_KVEC_H\n#define NVIM_LIB_KVEC_H\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"nvim/memory.h\"\n#include \"nvim/os/os_defs.h\"\n\n#define kv_roundup32(x) \\\n    ((--(x)), \\\n     ((x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16), \\\n     (++(x)))\n\n#define KV_INITIAL_VALUE { .size = 0, .capacity = 0, .items = NULL }\n\n#define kvec_t(type) \\\n    struct { \\\n      size_t size; \\\n      size_t capacity; \\\n      type *items; \\\n    }\n\n#define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)\n#define kv_destroy(v) \\\n    do { \\\n      xfree((v).items); \\\n      kv_init(v); \\\n    } while (0)\n#define kv_A(v, i) ((v).items[(i)])\n#define kv_pop(v) ((v).items[--(v).size])\n#define kv_size(v) ((v).size)\n#define kv_max(v) ((v).capacity)\n#define kv_Z(v, i) kv_A(v, kv_size(v) - (i) - 1)\n#define kv_last(v) kv_Z(v, 0)\n\n/// Drop last n items from kvec without resizing\n///\n/// Previously spelled as `(void)kv_pop(v)`, repeated n times.\n///\n/// @param[out]  v  Kvec to drop items from.\n/// @param[in]  n  Number of elements to drop.\n#define kv_drop(v, n) ((v).size -= (n))\n\n#define kv_resize(v, s) \\\n    ((v).capacity = (s), \\\n     (v).items = xrealloc((v).items, sizeof((v).items[0]) * (v).capacity))\n\n#define kv_resize_full(v) \\\n    kv_resize(v, (v).capacity ? (v).capacity << 1 : 8)\n\n#define kv_copy(v1, v0) \\\n    do { \\\n      if ((v1).capacity < (v0).size) { \\\n        kv_resize(v1, (v0).size); \\\n      } \\\n      (v1).size = (v0).size; \\\n      memcpy((v1).items, (v0).items, sizeof((v1).items[0]) * (v0).size); \\\n    } while (0)\n\n#define kv_pushp(v) \\\n    ((((v).size == (v).capacity) ? (kv_resize_full(v), 0) : 0), \\\n     ((v).items + ((v).size++)))\n\n#define kv_push(v, x) \\\n    (*kv_pushp(v) = (x))\n\n#define kv_a(v, i) \\\n    (*(((v).capacity <= (size_t) (i) \\\n      ? ((v).capacity = (v).size = (i) + 1, \\\n         kv_roundup32((v).capacity), \\\n         kv_resize((v), (v).capacity), 0UL) \\\n      : ((v).size <= (size_t) (i) \\\n         ? (v).size = (i) + 1 \\\n         : 0UL)), \\\n     &(v).items[(i)]))\n\n/// Type of a vector with a few first members allocated on stack\n///\n/// Is compatible with #kv_A, #kv_pop, #kv_size, #kv_max, #kv_last.\n/// Is not compatible with #kv_resize, #kv_resize_full, #kv_copy, #kv_push,\n/// #kv_pushp, #kv_a, #kv_destroy.\n///\n/// @param[in]  type  Type of vector elements.\n/// @param[in]  init_size  Number of the elements in the initial array.\n#define kvec_withinit_t(type, INIT_SIZE) \\\n    struct { \\\n      size_t size; \\\n      size_t capacity; \\\n      type *items; \\\n      type init_array[INIT_SIZE]; \\\n    }\n\n/// Initialize vector with preallocated array\n///\n/// @param[out]  v  Vector to initialize.\n#define kvi_init(v) \\\n    ((v).capacity = ARRAY_SIZE((v).init_array), \\\n     (v).size = 0, \\\n     (v).items = (v).init_array)\n\n/// Move data to a new destination and free source\nstatic inline void *_memcpy_free(void *const restrict dest,\n                                 void *const restrict src,\n                                 const size_t size)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_ALWAYS_INLINE\n{\n  memcpy(dest, src, size);\n  XFREE_CLEAR(src);\n  return dest;\n}\n\n// -V:kvi_push:512\n\n/// Resize vector with preallocated array\n///\n/// @note May not resize to an array smaller then init_array: if requested,\n///       init_array will be used.\n///\n/// @param[out]  v  Vector to resize.\n/// @param[in]  s  New size.\n#define kvi_resize(v, s) \\\n    ((v).capacity = ((s) > ARRAY_SIZE((v).init_array) \\\n                     ? (s) \\\n                     : ARRAY_SIZE((v).init_array)), \\\n     (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) \\\n                  ? ((v).items == (v).init_array \\\n                     ? (v).items \\\n                     : _memcpy_free((v).init_array, (v).items, \\\n                                    (v).size * sizeof((v).items[0]))) \\\n                  : ((v).items == (v).init_array \\\n                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\\n                              (v).items, \\\n                              (v).size * sizeof((v).items[0])) \\\n                     : xrealloc((v).items, \\\n                                (v).capacity * sizeof((v).items[0])))))\n\n/// Resize vector with preallocated array when it is full\n///\n/// @param[out]  v  Vector to resize.\n#define kvi_resize_full(v) \\\n    /* ARRAY_SIZE((v).init_array) is the minimal capacity of this vector. */ \\\n    /* Thus when vector is full capacity may not be zero and it is safe */ \\\n    /* not to bother with checking whether (v).capacity is 0. But now */ \\\n    /* capacity is not guaranteed to have size that is a power of 2, it is */ \\\n    /* hard to fix this here and is not very necessary if users will use */ \\\n    /* 2^x initial array size. */ \\\n    kvi_resize(v, (v).capacity << 1)\n\n/// Get location where to store new element to a vector with preallocated array\n///\n/// @param[in,out]  v  Vector to push to.\n///\n/// @return Pointer to the place where new value should be stored.\n#define kvi_pushp(v) \\\n    ((((v).size == (v).capacity) ? (kvi_resize_full(v), 0) : 0), \\\n     ((v).items + ((v).size++)))\n\n/// Push value to a vector with preallocated array\n///\n/// @param[out]  v  Vector to push to.\n/// @param[in]  x  Value to push.\n#define kvi_push(v, x) \\\n    (*kvi_pushp(v) = (x))\n\n/// Free array of elements of a vector with preallocated array if needed\n///\n/// @param[out]  v  Vector to free.\n#define kvi_destroy(v) \\\n    do { \\\n      if ((v).items != (v).init_array) { \\\n        XFREE_CLEAR((v).items); \\\n      } \\\n    } while (0)\n\n#endif  // NVIM_LIB_KVEC_H\n"}, "22": {"id": 22, "path": "src/nvim/macros.h", "content": "#ifndef NVIM_MACROS_H\n#define NVIM_MACROS_H\n\n#include \"auto/config.h\"\n\n// EXTERN is only defined in main.c. That's where global variables are\n// actually defined and initialized.\n#ifndef EXTERN\n# define EXTERN extern\n# define INIT(...)\n#else\n# ifndef INIT\n#  define INIT(...) __VA_ARGS__\n#  define COMMA ,\n# endif\n#endif\n\n#ifndef MIN\n# define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n#ifndef MAX\n# define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#endif\n\n/// String with length\n///\n/// For use in functions which accept (char *s, size_t len) pair in arguments.\n///\n/// @param[in]  s  Static string.\n///\n/// @return `s, sizeof(s) - 1`\n#define S_LEN(s) (s), (sizeof(s) - 1)\n\n/// LINEEMPTY() - return TRUE if the line is empty\n#define LINEEMPTY(p) (*ml_get(p) == NUL)\n\n// toupper() and tolower() that use the current locale.\n// Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the\n// range 0 - 255.  toupper()/tolower() on some systems can't handle others.\n// Note: It is often better to use mb_tolower() and mb_toupper(), because many\n// toupper() and tolower() implementations only work for ASCII.\n#define TOUPPER_LOC toupper\n#define TOLOWER_LOC tolower\n\n// toupper() and tolower() for ASCII only and ignore the current locale.\n# define TOUPPER_ASC(c) (((c) < 'a' || (c) > 'z') ? (c) : (c) - ('a' - 'A'))\n# define TOLOWER_ASC(c) (((c) < 'A' || (c) > 'Z') ? (c) : (c) + ('a' - 'A'))\n\n// Like isalpha() but reject non-ASCII characters.  Can't be used with a\n// special key (negative value).\n# define ASCII_ISLOWER(c) ((unsigned)(c) >= 'a' && (unsigned)(c) <= 'z')\n# define ASCII_ISUPPER(c) ((unsigned)(c) >= 'A' && (unsigned)(c) <= 'Z')\n# define ASCII_ISALPHA(c) (ASCII_ISUPPER(c) || ASCII_ISLOWER(c))\n# define ASCII_ISALNUM(c) (ASCII_ISALPHA(c) || ascii_isdigit(c))\n\n// Returns empty string if it is NULL.\n#define EMPTY_IF_NULL(x) ((x) ? (x) : (char_u *)\"\")\n\n// Adjust chars in a language according to 'langmap' option.\n// NOTE that there is no noticeable overhead if 'langmap' is not set.\n// When set the overhead for characters < 256 is small.\n// Don't apply 'langmap' if the character comes from the Stuff buffer or from a\n// mapping and the langnoremap option was set.\n// The do-while is just to ignore a ';' after the macro.\n#  define LANGMAP_ADJUST(c, condition) \\\n  do { \\\n    if (*p_langmap \\\n        && (condition) \\\n        && (p_lrm || (vgetc_busy ? typebuf_maplen() == 0 : KeyTyped)) \\\n        && !KeyStuffed \\\n        && (c) >= 0) \\\n    { \\\n      if ((c) < 256) \\\n        c = langmap_mapchar[c]; \\\n      else \\\n        c = langmap_adjust_mb(c); \\\n    } \\\n  } while (0)\n\n#define WRITEBIN   \"wb\"        // no CR-LF translation\n#define READBIN    \"rb\"\n#define APPENDBIN  \"ab\"\n\n// mch_open_rw(): invoke os_open() with third argument for user R/W.\n#if defined(UNIX)  // open in rw------- mode\n# define mch_open_rw(n, f)      os_open((n), (f), (mode_t)0600)\n#elif defined(WIN32)\n# define mch_open_rw(n, f)      os_open((n), (f), S_IREAD | S_IWRITE)\n#else\n# define mch_open_rw(n, f)      os_open((n), (f), 0)\n#endif\n\n# define REPLACE_NORMAL(s) (((s) & REPLACE_FLAG) && !((s) & VREPLACE_FLAG))\n\n# define UTF_COMPOSINGLIKE(p1, p2)  utf_composinglike((p1), (p2))\n\n// MB_PTR_ADV(): advance a pointer to the next character, taking care of\n// multi-byte characters if needed.\n// MB_PTR_BACK(): backup a pointer to the previous character, taking care of\n// multi-byte characters if needed.\n// MB_COPY_CHAR(f, t): copy one char from \"f\" to \"t\" and advance the pointers.\n// PTR2CHAR(): get character from pointer.\n\n// Advance multi-byte pointer, skip over composing chars.\n# define MB_PTR_ADV(p)      (p += mb_ptr2len((char_u *)p))\n// Advance multi-byte pointer, do not skip over composing chars.\n# define MB_CPTR_ADV(p)     (p += utf_ptr2len(p))\n// Backup multi-byte pointer. Only use with \"p\" > \"s\" !\n# define MB_PTR_BACK(s, p) \\\n          (p -= utf_head_off((char_u *)s, (char_u *)p - 1) + 1)\n// get length of multi-byte char, not including composing chars\n# define MB_CPTR2LEN(p)     utf_ptr2len(p)\n\n# define MB_COPY_CHAR(f, t) mb_copy_char((const char_u **)(&f), &t);\n\n# define MB_CHARLEN(p)      mb_charlen(p)\n# define MB_CHAR2LEN(c)     mb_char2len(c)\n# define PTR2CHAR(p)        utf_ptr2char(p)\n\n# define RESET_BINDING(wp) \\\n  do { \\\n    (wp)->w_p_scb = false; \\\n    (wp)->w_p_crb = false; \\\n  } while (0)\n\n/// Calculate the length of a C array\n///\n/// This should be called with a real array. Calling this with a pointer is an\n/// error. A mechanism to detect many (though not all) of those errors at\n/// compile time is implemented. It works by the second division producing\n/// a division by zero in those cases (-Wdiv-by-zero in GCC).\n///\n/// -V:ARRAY_SIZE:1063\n#define ARRAY_SIZE(arr) \\\n    ((sizeof(arr)/sizeof((arr)[0])) \\\n     / ((size_t)(!(sizeof(arr) % sizeof((arr)[0])))))\n\n/// Get last array entry\n///\n/// This should be called with a real array. Calling this with a pointer is an\n/// error.\n#define ARRAY_LAST_ENTRY(arr) (arr)[ARRAY_SIZE(arr) - 1]\n\n// Duplicated in os/win_defs.h to avoid include-order sensitivity.\n#define RGB_(r, g, b) ((r << 16) | (g << 8) | b)\n\n#define STR_(x) #x\n#define STR(x) STR_(x)\n\n#ifndef __has_include\n# define NVIM_HAS_INCLUDE(x) 0\n#else\n# define NVIM_HAS_INCLUDE __has_include\n#endif\n\n#ifndef __has_attribute\n# define NVIM_HAS_ATTRIBUTE(x) 0\n#elif defined(__clang__) && __clang__ == 1 \\\n    && (__clang_major__ < 3 || (__clang_major__ == 3 && __clang_minor__ <= 5))\n// Starting in Clang 3.6, __has_attribute was fixed to only report true for\n// GNU-style attributes.  Prior to that, it reported true if _any_ backend\n// supported the attribute.\n# define NVIM_HAS_ATTRIBUTE(x) 0\n#else\n# define NVIM_HAS_ATTRIBUTE __has_attribute\n#endif\n\n#if NVIM_HAS_ATTRIBUTE(fallthrough) \\\n    && (!defined(__apple_build_version__) || __apple_build_version__ >= 7000000)\n# define FALLTHROUGH {} __attribute__((fallthrough))\n#else\n# define FALLTHROUGH\n#endif\n\n// -V:STRUCT_CAST:641\n\n/// Change type of structure pointers: cast `struct a *` to `struct b *`\n///\n/// Used to silence PVS errors.\n///\n/// @param  Type  Structure to cast to.\n/// @param  obj  Object to cast.\n///\n/// @return ((Type *)obj).\n#define STRUCT_CAST(Type, obj) ((Type *)(obj))\n\n// Type of uv_buf_t.len is platform-dependent.\n// Related: https://github.com/libuv/libuv/pull/1236\n#if defined(WIN32)\n# define UV_BUF_LEN(x)  (ULONG)(x)\n#else\n# define UV_BUF_LEN(x)  (x)\n#endif\n\n// Type of read()/write() `count` param is platform-dependent.\n#if defined(WIN32)\n# define IO_COUNT(x)  (unsigned)(x)\n#else\n# define IO_COUNT(x)  (x)\n#endif\n\n///\n/// PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES\n///\n#if defined(__clang__) && __clang__ == 1\n# define PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES \\\n  _Pragma(\"clang diagnostic push\") \\\n  _Pragma(\"clang diagnostic ignored \\\"-Wmissing-prototypes\\\"\")\n# ifdef HAVE_WIMPLICIT_FALLTHROUGH_FLAG\n#  define PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH \\\n    _Pragma(\"clang diagnostic push\") \\\n    _Pragma(\"clang diagnostic ignored \\\"-Wimplicit-fallthrough\\\"\")\n# else\n#  define PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH \\\n    _Pragma(\"clang diagnostic push\")\n# endif\n# define PRAGMA_DIAG_POP \\\n    _Pragma(\"clang diagnostic pop\")\n#elif defined(__GNUC__)\n# define PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES \\\n  _Pragma(\"GCC diagnostic push\") \\\n  _Pragma(\"GCC diagnostic ignored \\\"-Wmissing-prototypes\\\"\")\n# ifdef HAVE_WIMPLICIT_FALLTHROUGH_FLAG\n#  define PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH \\\n    _Pragma(\"GCC diagnostic push\") \\\n    _Pragma(\"GCC diagnostic ignored \\\"-Wimplicit-fallthrough\\\"\")\n# else\n#  define PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH \\\n    _Pragma(\"GCC diagnostic push\")\n# endif\n# define PRAGMA_DIAG_POP \\\n  _Pragma(\"GCC diagnostic pop\")\n#else\n# define PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES\n# define PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH\n# define PRAGMA_DIAG_POP\n#endif\n\n#define EMPTY_POS(a) ((a).lnum == 0 && (a).col == 0 && (a).coladd == 0)\n\n#endif  // NVIM_MACROS_H\n"}}, "reports": [{"events": [{"location": {"col": 24, "file": 27, "line": 412}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "d01b08bb014411bd9540b9ea83c71d57", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 27, "line": 472}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "168d15e40515e556b1801e38b0f6f059", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 20, "line": 134}, "message": "expanded from macro 'kvi_init'"}, {"location": {"col": 34, "file": 22, "line": 136}, "message": "expanded from macro 'ARRAY_SIZE'"}, {"location": {"col": 3, "file": 27, "line": 478}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "5f72cbaf16c130a6dedaed1e5fc132ba", "checkerName": "bugprone-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 20, "line": 200}, "message": "expanded from macro 'kvi_push'"}, {"location": {"col": 37, "file": 20, "line": 192}, "message": "expanded from macro 'kvi_pushp'"}, {"location": {"col": 5, "file": 20, "line": 184}, "message": "expanded from macro 'kvi_resize_full'"}, {"location": {"col": 28, "file": 20, "line": 159}, "message": "expanded from macro 'kvi_resize'"}, {"location": {"col": 34, "file": 22, "line": 136}, "message": "expanded from macro 'ARRAY_SIZE'"}, {"location": {"col": 7, "file": 27, "line": 496}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "908d3f59684f8c7d2ea1770af60c1940", "checkerName": "bugprone-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 19, "file": 27, "line": 950}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "654e96ef0a432a4f7b71e0ba8ba32a5a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 27, "line": 1024}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "96a5dcbdfd30f1d9fc76e2a761f4adfd", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 27, "line": 1206}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "4e14be5a37d24f99baa73a40c71c3cb1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 27, "line": 1310}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "2666c5fc205d5653ad6f836da8c929c7", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 20, "line": 134}, "message": "expanded from macro 'kvi_init'"}, {"location": {"col": 34, "file": 22, "line": 136}, "message": "expanded from macro 'ARRAY_SIZE'"}, {"location": {"col": 3, "file": 27, "line": 1340}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "5d9fddb6691eb2ab59084923e89c510d", "checkerName": "bugprone-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 20, "line": 200}, "message": "expanded from macro 'kvi_push'"}, {"location": {"col": 37, "file": 20, "line": 192}, "message": "expanded from macro 'kvi_pushp'"}, {"location": {"col": 5, "file": 20, "line": 184}, "message": "expanded from macro 'kvi_resize_full'"}, {"location": {"col": 28, "file": 20, "line": 159}, "message": "expanded from macro 'kvi_resize'"}, {"location": {"col": 34, "file": 22, "line": 136}, "message": "expanded from macro 'ARRAY_SIZE'"}, {"location": {"col": 9, "file": 27, "line": 1356}, "message": "suspicious usage of 'sizeof(A*)'; pointer to aggregate"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "bceb085ce905d3e6c2fbdd3d3b2c914a", "checkerName": "bugprone-sizeof-expression", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 39, "file": 27, "line": 1516}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "5417909ca41a3743532b9042862f7cab", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 27, "line": 1523}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "9ce68bb96e09db38e4fd87295ed3d959", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 27, "line": 1535}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "610c43db4bf247634296aad3296425cb", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 27, "line": 1586}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "747fa65f665bfda829becbfac696cc63", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 27, "line": 1708}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "ff649436e285c7acde247a9ab000aa2a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 46, "file": 27, "line": 1898}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "f87ee70434e1eea6b82dc2575bd84224", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 27, "line": 1921}, "message": "narrowing conversion from 'char_u' (aka 'unsigned char') to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "9b39e67ecae7c8a38dedfcc9c908af67", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2161}, "message": "(           ) (fixit)"}, {"location": {"col": 34, "file": 27, "line": 2161}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "adbe3839ae8b8166ca76e576bf1777ad", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2162}, "message": "(             ) (fixit)"}, {"location": {"col": 36, "file": 27, "line": 2162}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "74c630a8094b67d20b78f0e8b288929d", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2163}, "message": "(          ) (fixit)"}, {"location": {"col": 33, "file": 27, "line": 2163}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "e60a1a1e7ddb7f588c6c1ca380d5deb6", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2164}, "message": "(          ) (fixit)"}, {"location": {"col": 33, "file": 27, "line": 2164}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "7289ff58d42b5bef3dad9630e77e0750", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2165}, "message": "(        ) (fixit)"}, {"location": {"col": 31, "file": 27, "line": 2165}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "6311e4320c2159df24bddaf40cc912de", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2166}, "message": "(         ) (fixit)"}, {"location": {"col": 32, "file": 27, "line": 2166}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "ab47579b47ccd59c70085e28cdeaac39", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 27, "line": 2167}, "message": "(         ) (fixit)"}, {"location": {"col": 32, "file": 27, "line": 2167}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "68feeb173af190c7dfc998d9db450263", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 27, "line": 2221}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "d1c961884e79803f443428fbb425ded1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 27, "line": 2248}, "message": "narrowing conversion from 'size_t' (aka 'unsigned long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "7af0796b0ccc2b01b3ef6408534ffa07", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 27, "line": 2249}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "b3c17cd9994a42120f031c206f9b3a00", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 27, "line": 2249}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "76ed514b62b549fee6e9e4e309338cae", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 27, "line": 2493}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "f1b6a5deff0faeb641e95df573340aea", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 27, "line": 2496}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "b2bdc33ec0956e5d3411afc39cfa7f28", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 27, "line": 2573}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "98bba763eebb9e3b5198e62740dc7958", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 27, "line": 2584}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "912a293b9f3ccd34fd4f87168d0342a7", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 62, "file": 27, "line": 2730}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "953e593dfb6096f018ccfb2356d6f5b1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 27, "line": 2888}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "7e29454c331408c58a1083a7c93a72c9", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 42, "file": 27, "line": 2980}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "e2153e70d1f1c22d28a374c188da9391", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 48, "file": 27, "line": 2980}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "f82ef31ae87072d1649919b72393a912", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 27, "line": 3124}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "abf6e370f0b50d02d4ca3c1d236d934a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 27, "line": 3520}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "d34e4b0911a3d18c1f9b272381e47d56", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 75, "file": 27, "line": 3577}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "ca6e5b45d73f9f305f9a1d004d94a470", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 27, "line": 3596}, "message": "narrowing conversion from 'long' to signed type 'colnr_T' (aka 'int') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "14d8ca6bcadcc64ed00595ebd2b8e638", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 37, "file": 27, "line": 3667}, "message": "narrowing conversion from 'long' to signed type 'colnr_T' (aka 'int') is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "16cb90d4cac149e177482a60ac26fdaa", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 45, "file": 27, "line": 4269}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "93f049b3e6789b563e0f6ce888574e18", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 27, "line": 4623}, "message": "narrowing conversion from 'unsigned long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "2e36d7b5509e1189ea57d0bcb5718067", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 46, "file": 27, "line": 4740}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "004683b56f582cc42473967841267980", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 56, "file": 27, "line": 4740}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "3f7ae1197bbbe9d94cb0f0878fa2c2a0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 48, "file": 27, "line": 4748}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "047b9359f43dc89039daccbdc492b29c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 42, "file": 27, "line": 4749}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "1d1ca4d4c4e0aeffc04267781c80884c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 27, "line": 5075}, "message": "either cast from 'int' to 'long' is ineffective, or there is loss of precision before the conversion"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "bbada83ed8b7a41fca01cc592ef820e0", "checkerName": "bugprone-misplaced-widening-cast", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 23, "file": 27, "line": 5142}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "07b0f24afc5ee3e28059cef22cafa4a0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 27, "line": 5143}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "501421e0fb07da061a64e4844bc15c6f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 27, "line": 5441}, "message": "'atoi' used to convert a string to an integer value, but function will not report conversion errors; consider using 'strtol' instead"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "925e522a9f7f433e774ca4972b6a5678", "checkerName": "cert-err34-c", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 27, "line": 6286}, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "4f8fa950f754b52e45b3cbaa7c6030fd", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 27, "line": 7582}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "fa9585d6cf5c557bf30b50ff439fba97", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 27, "line": 7620}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/screen.c", "reportHash": "c35cc20d6696afece35738b1d6ef6109", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
