<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/search.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * search.c: code for normal mode searching commands\n */\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>             /* for INT_MAX on MSVC */\n\n#include \"nvim/ascii.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/search.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/indent.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/time.h\"\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"search.c.generated.h\"\n#endif\n\n//  This file contains various searching-related routines. These fall into\n//  three groups:\n//  1. string searches (for /, ?, n, and N)\n//  2. character searches within a single line (for f, F, t, T, etc)\n//  3. \"other\" kinds of searches like the '%' command, and 'word' searches.\n//\n//\n//  String searches\n//\n//  The string search functions are divided into two levels:\n//  lowest:  searchit(); uses a pos_T for starting position and found match.\n//  Highest: do_search(); uses curwin->w_cursor; calls searchit().\n//\n//  The last search pattern is remembered for repeating the same search.\n//  This pattern is shared between the :g, :s, ? and / commands.\n//  This is in search_regcomp().\n//\n//  The actual string matching is done using a heavily modified version of\n//  Henry Spencer's regular expression library.  See regexp.c.\n//\n//\n//\n// Two search patterns are remembered: One for the :substitute command and\n// one for other searches.  last_idx points to the one that was used the last\n// time.\n\nstatic struct spat spats[2] =\n{\n  // Last used search pattern\n  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},\n  // Last used substitute pattern\n  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}\n};\n\nstatic int last_idx = 0;        /* index in spats[] for RE_LAST */\n\nstatic char_u lastc[2] = { NUL, NUL };    // last character searched for\nstatic Direction lastcdir = FORWARD;      // last direction of character search\nstatic int last_t_cmd = true;             // last search t_cmd\nstatic char_u lastc_bytes[MB_MAXBYTES + 1];\nstatic int lastc_bytelen = 1;             // >1 for multi-byte char\n\n// copy of spats[], for keeping the search patterns while executing autocmds\nstatic struct spat saved_spats[2];\nstatic int saved_spats_last_idx = 0;\nstatic bool saved_spats_no_hlsearch = false;\n\nstatic char_u       *mr_pattern = NULL;    // pattern used by search_regcomp()\nstatic bool mr_pattern_alloced = false;    // mr_pattern was allocated\n\n/*\n * Type used by find_pattern_in_path() to remember which included files have\n * been searched already.\n */\ntypedef struct SearchedFile {\n  FILE        *fp;              /* File pointer */\n  char_u      *name;            /* Full name of file */\n  linenr_T lnum;                /* Line we were up to in file */\n  int matched;                  /* Found a match in this file */\n} SearchedFile;\n\n/*\n * translate search pattern for vim_regcomp()\n *\n * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)\n * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)\n * pat_save == RE_BOTH: save pat in both patterns (:global command)\n * pat_use  == RE_SEARCH: use previous search pattern if \"pat\" is NULL\n * pat_use  == RE_SUBST: use previous substitute pattern if \"pat\" is NULL\n * pat_use  == RE_LAST: use last used pattern if \"pat\" is NULL\n * options & SEARCH_HIS: put search string in history\n * options & SEARCH_KEEP: keep previous search pattern\n *\n * returns FAIL if failed, OK otherwise.\n */\nint\nsearch_regcomp(\n    char_u *pat,\n    int pat_save,\n    int pat_use,\n    int options,\n    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */\n)\n{\n  int magic;\n  int i;\n\n  rc_did_emsg = false;\n  magic = p_magic;\n\n  /*\n   * If no pattern given, use a previously defined pattern.\n   */\n  if (pat == NULL || *pat == NUL) {\n    if (pat_use == RE_LAST)\n      i = last_idx;\n    else\n      i = pat_use;\n    if (spats[i].pat == NULL) {         /* pattern was never defined */\n      if (pat_use == RE_SUBST)\n        EMSG(_(e_nopresub));\n      else\n        EMSG(_(e_noprevre));\n      rc_did_emsg = true;\n      return FAIL;\n    }\n    pat = spats[i].pat;\n    magic = spats[i].magic;\n    no_smartcase = spats[i].no_scs;\n  } else if (options & SEARCH_HIS) {      // put new pattern in history\n    add_to_history(HIST_SEARCH, pat, true, NUL);\n  }\n\n  if (mr_pattern_alloced) {\n    xfree(mr_pattern);\n    mr_pattern_alloced = false;\n  }\n\n  if (curwin->w_p_rl && *curwin->w_p_rlc == 's') {\n    mr_pattern = reverse_text(pat);\n    mr_pattern_alloced = true;\n  } else {\n    mr_pattern = pat;\n  }\n\n  /*\n   * Save the currently used pattern in the appropriate place,\n   * unless the pattern should not be remembered.\n   */\n  if (!(options & SEARCH_KEEP) && !cmdmod.keeppatterns) {\n    /* search or global command */\n    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)\n      save_re_pat(RE_SEARCH, pat, magic);\n    /* substitute or global command */\n    if (pat_save == RE_SUBST || pat_save == RE_BOTH)\n      save_re_pat(RE_SUBST, pat, magic);\n  }\n\n  regmatch->rmm_ic = ignorecase(pat);\n  regmatch->rmm_maxcol = 0;\n  regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);\n  if (regmatch->regprog == NULL)\n    return FAIL;\n  return OK;\n}\n\n/*\n * Get search pattern used by search_regcomp().\n */\nchar_u *get_search_pat(void)\n{\n  return mr_pattern;\n}\n\n/*\n * Reverse text into allocated memory.\n * Returns the allocated string.\n *\n * TODO(philix): move reverse_text() to strings.c\n */\nchar_u *reverse_text(char_u *s) FUNC_ATTR_NONNULL_RET\n{\n  /*\n   * Reverse the pattern.\n   */\n  size_t len = STRLEN(s);\n  char_u *rev = xmalloc(len + 1);\n  size_t rev_i = len;\n  for (size_t s_i = 0; s_i < len; s_i++) {\n    const int mb_len = utfc_ptr2len(s + s_i);\n    rev_i -= mb_len;\n    memmove(rev + rev_i, s + s_i, mb_len);\n    s_i += mb_len - 1;\n  }\n  rev[len] = NUL;\n\n  return rev;\n}\n\nvoid save_re_pat(int idx, char_u *pat, int magic)\n{\n  if (spats[idx].pat != pat) {\n    free_spat(&spats[idx]);\n    spats[idx].pat = vim_strsave(pat);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = no_smartcase;\n    spats[idx].timestamp = os_time();\n    spats[idx].additional_data = NULL;\n    last_idx = idx;\n    /* If 'hlsearch' set and search pat changed: need redraw. */\n    if (p_hls)\n      redraw_all_later(SOME_VALID);\n    set_no_hlsearch(false);\n  }\n}\n\n/*\n * Save the search patterns, so they can be restored later.\n * Used before/after executing autocommands and user functions.\n */\nstatic int save_level = 0;\n\nvoid save_search_patterns(void)\n{\n  if (save_level++ == 0) {\n    saved_spats[0] = spats[0];\n    if (spats[0].pat != NULL)\n      saved_spats[0].pat = vim_strsave(spats[0].pat);\n    saved_spats[1] = spats[1];\n    if (spats[1].pat != NULL)\n      saved_spats[1].pat = vim_strsave(spats[1].pat);\n    saved_spats_last_idx = last_idx;\n    saved_spats_no_hlsearch = no_hlsearch;\n  }\n}\n\nvoid restore_search_patterns(void)\n{\n  if (--save_level == 0) {\n    free_spat(&spats[0]);\n    spats[0] = saved_spats[0];\n    set_vv_searchforward();\n    free_spat(&spats[1]);\n    spats[1] = saved_spats[1];\n    last_idx = saved_spats_last_idx;\n    set_no_hlsearch(saved_spats_no_hlsearch);\n  }\n}\n\nstatic inline void free_spat(struct spat *const spat)\n{\n  xfree(spat->pat);\n  tv_dict_unref(spat->additional_data);\n}\n\n#if defined(EXITFREE)\nvoid free_search_patterns(void)\n{\n  free_spat(&spats[0]);\n  free_spat(&spats[1]);\n\n  memset(spats, 0, sizeof(spats));\n\n  if (mr_pattern_alloced) {\n    xfree(mr_pattern);\n    mr_pattern_alloced = false;\n    mr_pattern = NULL;\n  }\n}\n\n#endif\n\n// copy of spats[RE_SEARCH], for keeping the search patterns while incremental\n// searching\nstatic struct spat saved_last_search_spat;\nstatic int did_save_last_search_spat = 0;\nstatic int saved_last_idx = 0;\nstatic bool saved_no_hlsearch = false;\n\n/// Save and restore the search pattern for incremental highlight search\n/// feature.\n///\n/// It's similar to but different from save_search_patterns() and\n/// restore_search_patterns(), because the search pattern must be restored when\n/// cancelling incremental searching even if it's called inside user functions.\nvoid save_last_search_pattern(void)\n{\n  if (++did_save_last_search_spat != 1) {\n    // nested call, nothing to do\n    return;\n  }\n\n  saved_last_search_spat = spats[RE_SEARCH];\n  if (spats[RE_SEARCH].pat != NULL) {\n    saved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);\n  }\n  saved_last_idx = last_idx;\n  saved_no_hlsearch = no_hlsearch;\n}\n\nvoid restore_last_search_pattern(void)\n{\n  if (--did_save_last_search_spat > 0) {\n    // nested call, nothing to do\n    return;\n  }\n  if (did_save_last_search_spat != 0) {\n    iemsg(\"restore_last_search_pattern() called more often than\"\n          \" save_last_search_pattern()\");\n    return;\n  }\n\n  xfree(spats[RE_SEARCH].pat);\n  spats[RE_SEARCH] = saved_last_search_spat;\n  saved_last_search_spat.pat = NULL;\n  set_vv_searchforward();\n  last_idx = saved_last_idx;\n  set_no_hlsearch(saved_no_hlsearch);\n}\n\nchar_u *last_search_pattern(void)\n{\n  return spats[RE_SEARCH].pat;\n}\n\n/*\n * Return TRUE when case should be ignored for search pattern \"pat\".\n * Uses the 'ignorecase' and 'smartcase' options.\n */\nint ignorecase(char_u *pat)\n{\n  return ignorecase_opt(pat, p_ic, p_scs);\n}\n\n/// As ignorecase() put pass the \"ic\" and \"scs\" flags.\nint ignorecase_opt(char_u *pat, int ic_in, int scs)\n{\n  int ic = ic_in;\n  if (ic && !no_smartcase && scs\n      && !(ctrl_x_mode_not_default() && curbuf->b_p_inf)\n      ) {\n    ic = !pat_has_uppercase(pat);\n  }\n  no_smartcase = false;\n\n  return ic;\n}\n\n/// Returns true if pattern `pat` has an uppercase character.\nbool pat_has_uppercase(char_u *pat)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *p = pat;\n\n  while (*p != NUL) {\n    const int l = mb_ptr2len(p);\n\n    if (l > 1) {\n      if (mb_isupper(utf_ptr2char(p))) {\n        return true;\n      }\n      p += l;\n    } else if (*p == '\\\\') {\n      if (p[1] == '_' && p[2] != NUL) {  // skip \"\\_X\"\n        p += 3;\n      } else if (p[1] == '%' && p[2] != NUL) {  // skip \"\\%X\"\n        p += 3;\n      } else if (p[1] != NUL) {  // skip \"\\X\"\n        p += 2;\n      } else {\n        p += 1;\n      }\n    } else if (mb_isupper(*p)) {\n      return true;\n    } else {\n      p++;\n    }\n  }\n  return false;\n}\n\nconst char *last_csearch(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return (const char *)lastc_bytes;\n}\n\nint last_csearch_forward(void)\n{\n  return lastcdir == FORWARD;\n}\n\nint last_csearch_until(void)\n{\n  return last_t_cmd == TRUE;\n}\n\nvoid set_last_csearch(int c, char_u *s, int len)\n{\n  *lastc = c;\n  lastc_bytelen = len;\n  if (len)\n    memcpy(lastc_bytes, s, len);\n  else\n    memset(lastc_bytes, 0, sizeof(lastc_bytes));\n}\n\nvoid set_csearch_direction(Direction cdir)\n{\n  lastcdir = cdir;\n}\n\nvoid set_csearch_until(int t_cmd)\n{\n  last_t_cmd = t_cmd;\n}\n\nchar_u *last_search_pat(void)\n{\n  return spats[last_idx].pat;\n}\n\n/*\n * Reset search direction to forward.  For \"gd\" and \"gD\" commands.\n */\nvoid reset_search_dir(void)\n{\n  spats[0].off.dir = '/';\n  set_vv_searchforward();\n}\n\n/*\n * Set the last search pattern.  For \":let @/ =\" and ShaDa file.\n * Also set the saved search pattern, so that this works in an autocommand.\n */\nvoid set_last_search_pat(const char_u *s, int idx, int magic, int setlast)\n{\n  free_spat(&spats[idx]);\n  /* An empty string means that nothing should be matched. */\n  if (*s == NUL)\n    spats[idx].pat = NULL;\n  else\n    spats[idx].pat = (char_u *) xstrdup((char *) s);\n  spats[idx].timestamp = os_time();\n  spats[idx].additional_data = NULL;\n  spats[idx].magic = magic;\n  spats[idx].no_scs = false;\n  spats[idx].off.dir = '/';\n  set_vv_searchforward();\n  spats[idx].off.line = FALSE;\n  spats[idx].off.end = FALSE;\n  spats[idx].off.off = 0;\n  if (setlast)\n    last_idx = idx;\n  if (save_level) {\n    free_spat(&saved_spats[idx]);\n    saved_spats[idx] = spats[0];\n    if (spats[idx].pat == NULL)\n      saved_spats[idx].pat = NULL;\n    else\n      saved_spats[idx].pat = vim_strsave(spats[idx].pat);\n    saved_spats_last_idx = last_idx;\n  }\n  /* If 'hlsearch' set and search pat changed: need redraw. */\n  if (p_hls && idx == last_idx && !no_hlsearch)\n    redraw_all_later(SOME_VALID);\n}\n\n/*\n * Get a regexp program for the last used search pattern.\n * This is used for highlighting all matches in a window.\n * Values returned in regmatch->regprog and regmatch->rmm_ic.\n */\nvoid last_pat_prog(regmmatch_T *regmatch)\n{\n  if (spats[last_idx].pat == NULL) {\n    regmatch->regprog = NULL;\n    return;\n  }\n  ++emsg_off;           /* So it doesn't beep if bad expr */\n  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);\n  --emsg_off;\n}\n\n/// lowest level search function.\n/// Search for 'count'th occurrence of pattern \"pat\" in direction \"dir\".\n/// Start at position \"pos\" and return the found position in \"pos\".\n///\n/// if (options & SEARCH_MSG) == 0 don't give any messages\n/// if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages\n/// if (options & SEARCH_MSG) == SEARCH_MSG give all messages\n/// if (options & SEARCH_HIS) put search pattern in history\n/// if (options & SEARCH_END) return position at end of match\n/// if (options & SEARCH_START) accept match at pos itself\n/// if (options & SEARCH_KEEP) keep previous search pattern\n/// if (options & SEARCH_FOLD) match only once in a closed fold\n/// if (options & SEARCH_PEEK) check for typed char, cancel search\n/// if (options & SEARCH_COL) start at pos->col instead of zero\n///\n/// @returns FAIL (zero) for failure, non-zero for success.\n///          the index of the first matching\n///          subpattern plus one; one if there was none.\nint searchit(\n    win_T       *win,          // window to search in; can be NULL for a\n                               // buffer without a window!\n    buf_T       *buf,\n    pos_T       *pos,\n    pos_T       *end_pos,      // set to end of the match, unless NULL\n    Direction dir,\n    char_u      *pat,\n    long count,\n    int options,\n    int pat_use,               // which pattern to use when \"pat\" is empty\n    searchit_arg_T *extra_arg  // optional extra arguments, can be NULL\n)\n{\n  int found;\n  linenr_T lnum;                /* no init to shut up Apollo cc */\n  regmmatch_T regmatch;\n  char_u      *ptr;\n  colnr_T matchcol;\n  lpos_T endpos;\n  lpos_T matchpos;\n  int loop;\n  pos_T start_pos;\n  int at_first_line;\n  int extra_col;\n  int start_char_len;\n  bool match_ok;\n  long nmatched;\n  int submatch = 0;\n  bool first_match = true;\n  int save_called_emsg = called_emsg;\n  bool break_loop = false;\n  linenr_T stop_lnum = 0;  // stop after this line number when != 0\n  proftime_T *tm = NULL;   // timeout limit or NULL\n  int *timed_out = NULL;   // set when timed out or NULL\n\n  if (extra_arg != NULL) {\n      stop_lnum = extra_arg->sa_stop_lnum;\n      tm = extra_arg->sa_tm;\n      timed_out = &extra_arg->sa_timed_out;\n  }\n\n  if (search_regcomp(pat, RE_SEARCH, pat_use,\n          (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL) {\n    if ((options & SEARCH_MSG) && !rc_did_emsg)\n      EMSG2(_(\"E383: Invalid search string: %s\"), mr_pattern);\n    return FAIL;\n  }\n\n  /*\n   * find the string\n   */\n  called_emsg = FALSE;\n  do {  /* loop for count */\n    // When not accepting a match at the start position set \"extra_col\" to a\n    // non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL + 1\n    // is zero.\n    if (pos->col == MAXCOL) {\n      start_char_len = 0;\n    } else if (pos->lnum >= 1\n               && pos->lnum <= buf->b_ml.ml_line_count\n               && pos->col < MAXCOL - 2) {\n      // Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.\n      ptr = ml_get_buf(buf, pos->lnum, false);\n      if ((int)STRLEN(ptr) <= pos->col) {\n        start_char_len = 1;\n      } else {\n        start_char_len = utfc_ptr2len(ptr + pos->col);\n      }\n    } else {\n      start_char_len = 1;\n    }\n    if (dir == FORWARD) {\n      extra_col = (options & SEARCH_START) ? 0 : start_char_len;\n    } else {\n      extra_col = (options & SEARCH_START) ? start_char_len : 0;\n    }\n\n    start_pos = *pos;           /* remember start pos for detecting no match */\n    found = 0;                  /* default: not found */\n    at_first_line = TRUE;       /* default: start in first line */\n    if (pos->lnum == 0) {       /* correct lnum for when starting in line 0 */\n      pos->lnum = 1;\n      pos->col = 0;\n      at_first_line = FALSE;        /* not in first line now */\n    }\n\n    /*\n     * Start searching in current line, unless searching backwards and\n     * we're in column 0.\n     * If we are searching backwards, in column 0, and not including the\n     * current position, gain some efficiency by skipping back a line.\n     * Otherwise begin the search in the current line.\n     */\n    if (dir == BACKWARD && start_pos.col == 0\n        && (options & SEARCH_START) == 0) {\n      lnum = pos->lnum - 1;\n      at_first_line = FALSE;\n    } else\n      lnum = pos->lnum;\n\n    for (loop = 0; loop <= 1; ++loop) {     /* loop twice if 'wrapscan' set */\n      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;\n           lnum += dir, at_first_line = FALSE) {\n        /* Stop after checking \"stop_lnum\", if it's set. */\n        if (stop_lnum != 0 && (dir == FORWARD\n                               ? lnum > stop_lnum : lnum < stop_lnum))\n          break;\n        /* Stop after passing the \"tm\" time limit. */\n        if (tm != NULL && profile_passed_limit(*tm))\n          break;\n\n        // Look for a match somewhere in line \"lnum\".\n        colnr_T col = at_first_line && (options & SEARCH_COL) ? pos->col : 0;\n        nmatched = vim_regexec_multi(&regmatch, win, buf,\n                                     lnum, col, tm, timed_out);\n        // vim_regexec_multi() may clear \"regprog\"\n        if (regmatch.regprog == NULL) {\n          break;\n        }\n        // Abort searching on an error (e.g., out of stack).\n        if (called_emsg || (timed_out != NULL && *timed_out)) {\n          break;\n        }\n        if (nmatched > 0) {\n          /* match may actually be in another line when using \\zs */\n          matchpos = regmatch.startpos[0];\n          endpos = regmatch.endpos[0];\n          submatch = first_submatch(&regmatch);\n          // \"lnum\" may be past end of buffer for \"\\n\\zs\".\n          if (lnum + matchpos.lnum > buf->b_ml.ml_line_count) {\n            ptr = (char_u *)\"\";\n          } else {\n            ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);\n          }\n\n          /*\n           * Forward search in the first line: match should be after\n           * the start position. If not, continue at the end of the\n           * match (this is vi compatible) or on the next char.\n           */\n          if (dir == FORWARD && at_first_line) {\n            match_ok = true;\n            // When the match starts in a next line it's certainly\n            // past the start position.\n            // When match lands on a NUL the cursor will be put\n            // one back afterwards, compare with that position,\n            // otherwise \"/$\" will get stuck on end of line.\n            while (matchpos.lnum == 0\n                   && (((options & SEARCH_END) && first_match)\n                       ?  (nmatched == 1\n                           && (int)endpos.col - 1\n                           < (int)start_pos.col + extra_col)\n                       : ((int)matchpos.col\n                          - (ptr[matchpos.col] == NUL)\n                          < (int)start_pos.col + extra_col))) {\n              /*\n               * If vi-compatible searching, continue at the end\n               * of the match, otherwise continue one position\n               * forward.\n               */\n              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {\n                if (nmatched > 1) {\n                  /* end is in next line, thus no match in\n                   * this line */\n                  match_ok = false;\n                  break;\n                }\n                matchcol = endpos.col;\n                // for empty match (matchcol == matchpos.col): advance one char\n              } else {\n                // Prepare to start after first matched character.\n                matchcol = matchpos.col;\n              }\n\n              if (matchcol == matchpos.col && ptr[matchcol] != NUL) {\n                matchcol += utfc_ptr2len(ptr + matchcol);\n              }\n\n              if (matchcol == 0 && (options & SEARCH_START)) {\n                break;\n              }\n\n              if (ptr[matchcol] == NUL\n                  || (nmatched = vim_regexec_multi(&regmatch, win, buf,\n                                                   lnum, matchcol, tm,\n                                                   timed_out)) == 0) {\n                match_ok = false;\n                break;\n              }\n              // vim_regexec_multi() may clear \"regprog\"\n              if (regmatch.regprog == NULL) {\n                break;\n              }\n              matchpos = regmatch.startpos[0];\n              endpos = regmatch.endpos[0];\n              submatch = first_submatch(&regmatch);\n\n              // This while-loop only works with matchpos.lnum == 0.\n              // For bigger values the next line pointer ptr might not be a\n              // buffer line.\n              if (matchpos.lnum != 0) {\n                break;\n              }\n              // Need to get the line pointer again, a multi-line search may\n              // have made it invalid.\n              ptr = ml_get_buf(buf, lnum, false);\n            }\n            if (!match_ok)\n              continue;\n          }\n          if (dir == BACKWARD) {\n            /*\n             * Now, if there are multiple matches on this line,\n             * we have to get the last one. Or the last one before\n             * the cursor, if we're on that line.\n             * When putting the new cursor at the end, compare\n             * relative to the end of the match.\n             */\n            match_ok = false;\n            for (;; ) {\n              /* Remember a position that is before the start\n               * position, we use it if it's the last match in\n               * the line.  Always accept a position after\n               * wrapping around. */\n              if (loop\n                  || ((options & SEARCH_END)\n                      ? (lnum + regmatch.endpos[0].lnum\n                         < start_pos.lnum\n                         || (lnum + regmatch.endpos[0].lnum\n                             == start_pos.lnum\n                             && (int)regmatch.endpos[0].col - 1\n                             < (int)start_pos.col + extra_col))\n                      : (lnum + regmatch.startpos[0].lnum\n                         < start_pos.lnum\n                         || (lnum + regmatch.startpos[0].lnum\n                             == start_pos.lnum\n                             && (int)regmatch.startpos[0].col\n                             < (int)start_pos.col + extra_col)))) {\n                match_ok = true;\n                matchpos = regmatch.startpos[0];\n                endpos = regmatch.endpos[0];\n                submatch = first_submatch(&regmatch);\n              } else\n                break;\n\n              // We found a valid match, now check if there is\n              // another one after it.\n              // If vi-compatible searching, continue at the end\n              // of the match, otherwise continue one position\n              // forward.\n              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {\n                if (nmatched > 1) {\n                  break;\n                }\n                matchcol = endpos.col;\n                // for empty match: advance one char\n                if (matchcol == matchpos.col\n                    && ptr[matchcol] != NUL) {\n                  matchcol += mb_ptr2len(ptr + matchcol);\n                }\n              } else {\n                // Stop when the match is in a next line.\n                if (matchpos.lnum > 0) {\n                  break;\n                }\n                matchcol = matchpos.col;\n                if (ptr[matchcol] != NUL) {\n                  matchcol += mb_ptr2len(ptr + matchcol);\n                }\n              }\n              if (ptr[matchcol] == NUL\n                  || (nmatched = vim_regexec_multi(\n                      &regmatch, win, buf, lnum + matchpos.lnum, matchcol,\n                      tm, timed_out)) == 0) {\n                  // If the search timed out, we did find a match\n                  // but it might be the wrong one, so that's not\n                  // OK.\n                  if (tm != NULL && profile_passed_limit(*tm)) {\n                      match_ok = false;\n                  }\n                  break;\n              }\n              // vim_regexec_multi() may clear \"regprog\"\n              if (regmatch.regprog == NULL) {\n                break;\n              }\n              // Need to get the line pointer again, a\n              // multi-line search may have made it invalid.\n              ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);\n            }\n\n            /*\n             * If there is only a match after the cursor, skip\n             * this match.\n             */\n            if (!match_ok)\n              continue;\n          }\n\n          /* With the SEARCH_END option move to the last character\n           * of the match.  Don't do it for an empty match, end\n           * should be same as start then. */\n          if ((options & SEARCH_END) && !(options & SEARCH_NOOF)\n              && !(matchpos.lnum == endpos.lnum\n                   && matchpos.col == endpos.col)) {\n            /* For a match in the first column, set the position\n             * on the NUL in the previous line. */\n            pos->lnum = lnum + endpos.lnum;\n            pos->col = endpos.col;\n            if (endpos.col == 0) {\n              if (pos->lnum > 1) {              // just in case\n                pos->lnum--;\n                pos->col = (colnr_T)STRLEN(ml_get_buf(buf, pos->lnum, false));\n              }\n            } else {\n              pos->col--;\n              if (pos->lnum <= buf->b_ml.ml_line_count) {\n                ptr = ml_get_buf(buf, pos->lnum, false);\n                pos->col -= utf_head_off(ptr, ptr + pos->col);\n              }\n            }\n            if (end_pos != NULL) {\n              end_pos->lnum = lnum + matchpos.lnum;\n              end_pos->col = matchpos.col;\n            }\n          } else {\n            pos->lnum = lnum + matchpos.lnum;\n            pos->col = matchpos.col;\n            if (end_pos != NULL) {\n              end_pos->lnum = lnum + endpos.lnum;\n              end_pos->col = endpos.col;\n            }\n          }\n          pos->coladd = 0;\n          if (end_pos != NULL) {\n            end_pos->coladd = 0;\n          }\n          found = 1;\n          first_match = false;\n\n          /* Set variables used for 'incsearch' highlighting. */\n          search_match_lines = endpos.lnum - matchpos.lnum;\n          search_match_endcol = endpos.col;\n          break;\n        }\n        line_breakcheck();              /* stop if ctrl-C typed */\n        if (got_int)\n          break;\n\n        /* Cancel searching if a character was typed.  Used for\n         * 'incsearch'.  Don't check too often, that would slowdown\n         * searching too much. */\n        if ((options & SEARCH_PEEK)\n            && ((lnum - pos->lnum) & 0x3f) == 0\n            && char_avail()) {\n          break_loop = true;\n          break;\n        }\n\n        if (loop && lnum == start_pos.lnum)\n          break;                    /* if second loop, stop where started */\n      }\n      at_first_line = FALSE;\n\n      // vim_regexec_multi() may clear \"regprog\"\n      if (regmatch.regprog == NULL) {\n        break;\n      }\n\n      // Stop the search if wrapscan isn't set, \"stop_lnum\" is\n      // specified, after an interrupt, after a match and after looping\n      // twice.\n      if (!p_ws || stop_lnum != 0 || got_int || called_emsg\n          || (timed_out != NULL && *timed_out)\n          || break_loop\n          || found || loop) {\n        break;\n      }\n      //\n      // If 'wrapscan' is set we continue at the other end of the file.\n      // If 'shortmess' does not contain 's', we give a message.\n      // This message is also remembered in keep_msg for when the screen\n      // is redrawn. The keep_msg is cleared whenever another message is\n      // written.\n      //\n      if (dir == BACKWARD) {        // start second loop at the other end\n        lnum = buf->b_ml.ml_line_count;\n      } else {\n        lnum = 1;\n      }\n      if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG)) {\n        give_warning((char_u *)_(dir == BACKWARD\n                                 ? top_bot_msg : bot_top_msg), true);\n      }\n      if (extra_arg != NULL) {\n        extra_arg->sa_wrapped = true;\n      }\n    }\n    if (got_int || called_emsg\n        || (timed_out != NULL && *timed_out)\n        || break_loop\n        ) {\n      break;\n    }\n  } while (--count > 0 && found);   // stop after count matches or no match\n\n  vim_regfree(regmatch.regprog);\n\n  called_emsg |= save_called_emsg;\n\n  if (!found) {             /* did not find it */\n    if (got_int)\n      EMSG(_(e_interr));\n    else if ((options & SEARCH_MSG) == SEARCH_MSG) {\n      if (p_ws)\n        EMSG2(_(e_patnotf2), mr_pattern);\n      else if (lnum == 0)\n        EMSG2(_(\"E384: search hit TOP without match for: %s\"),\n            mr_pattern);\n      else\n        EMSG2(_(\"E385: search hit BOTTOM without match for: %s\"),\n            mr_pattern);\n    }\n    return FAIL;\n  }\n\n  /* A pattern like \"\\n\\zs\" may go past the last line. */\n  if (pos->lnum > buf->b_ml.ml_line_count) {\n    pos->lnum = buf->b_ml.ml_line_count;\n    pos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, false));\n    if (pos->col > 0) {\n      pos->col--;\n    }\n  }\n\n  return submatch + 1;\n}\n\nvoid set_search_direction(int cdir)\n{\n  spats[0].off.dir = cdir;\n}\n\nstatic void set_vv_searchforward(void)\n{\n  set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n// Return the number of the first subpat that matched.\n// Return zero if none of them matched.\nstatic int first_submatch(regmmatch_T *rp)\n{\n  int submatch;\n\n  for (submatch = 1;; ++submatch) {\n    if (rp->startpos[submatch].lnum >= 0)\n      break;\n    if (submatch == 9) {\n      submatch = 0;\n      break;\n    }\n  }\n  return submatch;\n}\n\n/*\n * Highest level string search function.\n * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'\n *    If 'dirc' is 0: use previous dir.\n *    If 'pat' is NULL or empty : use previous string.\n *    If 'options & SEARCH_REV' : go in reverse of previous dir.\n *    If 'options & SEARCH_ECHO': echo the search command and handle options\n *    If 'options & SEARCH_MSG' : may give error message\n *    If 'options & SEARCH_OPT' : interpret optional flags\n *    If 'options & SEARCH_HIS' : put search pattern in history\n *    If 'options & SEARCH_NOOF': don't add offset to position\n *    If 'options & SEARCH_MARK': set previous context mark\n *    If 'options & SEARCH_KEEP': keep previous search pattern\n *    If 'options & SEARCH_START': accept match at curpos itself\n *    If 'options & SEARCH_PEEK': check for typed char, cancel search\n *\n * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this\n * makes the movement linewise without moving the match position.\n *\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\nint do_search(\n    oparg_T         *oap,           // can be NULL\n    int dirc,                       // '/' or '?'\n    int search_delim,  // delimiter for search, e.g. '%' in s%regex%replacement\n    char_u          *pat,\n    long count,\n    int options,\n    searchit_arg_T  *sia        // optional arguments or NULL\n)\n{\n  pos_T pos;                    /* position of the last match */\n  char_u          *searchstr;\n  struct soffset old_off;\n  int retval;                   /* Return value */\n  char_u          *p;\n  long c;\n  char_u          *dircp;\n  char_u          *strcopy = NULL;\n  char_u          *ps;\n  char_u          *msgbuf = NULL;\n  size_t          len;\n  bool            has_offset = false;\n\n  /*\n   * A line offset is not remembered, this is vi compatible.\n   */\n  if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {\n    spats[0].off.line = FALSE;\n    spats[0].off.off = 0;\n  }\n\n  /*\n   * Save the values for when (options & SEARCH_KEEP) is used.\n   * (there is no \"if ()\" around this because gcc wants them initialized)\n   */\n  old_off = spats[0].off;\n\n  pos = curwin->w_cursor;       /* start searching at the cursor position */\n\n  /*\n   * Find out the direction of the search.\n   */\n  if (dirc == 0)\n    dirc = spats[0].off.dir;\n  else {\n    spats[0].off.dir = dirc;\n    set_vv_searchforward();\n  }\n  if (options & SEARCH_REV) {\n    if (dirc == '/')\n      dirc = '?';\n    else\n      dirc = '/';\n  }\n\n  /* If the cursor is in a closed fold, don't find another match in the same\n   * fold. */\n  if (dirc == '/') {\n    if (hasFolding(pos.lnum, NULL, &pos.lnum))\n      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */\n  } else {\n    if (hasFolding(pos.lnum, &pos.lnum, NULL))\n      pos.col = 0;\n  }\n\n  /*\n   * Turn 'hlsearch' highlighting back on.\n   */\n  if (no_hlsearch && !(options & SEARCH_KEEP)) {\n    redraw_all_later(SOME_VALID);\n    set_no_hlsearch(false);\n  }\n\n  /*\n   * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\".\n   */\n  for (;; ) {\n    bool show_top_bot_msg = false;\n\n    searchstr = pat;\n    dircp = NULL;\n    // use previous pattern\n    if (pat == NULL || *pat == NUL || *pat == search_delim) {\n      if (spats[RE_SEARCH].pat == NULL) {           // no previous pattern\n        searchstr = spats[RE_SUBST].pat;\n        if (searchstr == NULL) {\n          EMSG(_(e_noprevre));\n          retval = 0;\n          goto end_do_search;\n        }\n      } else {\n        /* make search_regcomp() use spats[RE_SEARCH].pat */\n        searchstr = (char_u *)\"\";\n      }\n    }\n\n    if (pat != NULL && *pat != NUL) {   /* look for (new) offset */\n      /*\n       * Find end of regular expression.\n       * If there is a matching '/' or '?', toss it.\n       */\n      ps = strcopy;\n      p = skip_regexp(pat, search_delim, p_magic, &strcopy);\n      if (strcopy != ps) {\n        /* made a copy of \"pat\" to change \"\\?\" to \"?\" */\n        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));\n        pat = strcopy;\n        searchstr = strcopy;\n      }\n      if (*p == search_delim) {\n        dircp = p;              // remember where we put the NUL\n        *p++ = NUL;\n      }\n      spats[0].off.line = FALSE;\n      spats[0].off.end = FALSE;\n      spats[0].off.off = 0;\n      // Check for a line offset or a character offset.\n      // For get_address (echo off) we don't check for a character\n      // offset, because it is meaningless and the 's' could be a\n      // substitute command.\n      if (*p == '+' || *p == '-' || ascii_isdigit(*p)) {\n        spats[0].off.line = true;\n      } else if ((options & SEARCH_OPT)\n                 && (*p == 'e' || *p == 's' || *p == 'b')) {\n        if (*p == 'e') {  // end\n          spats[0].off.end = true;\n        }\n        p++;\n      }\n      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */\n        /* 'nr' or '+nr' or '-nr' */\n        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))\n          spats[0].off.off = atol((char *)p);\n        else if (*p == '-')                 /* single '-' */\n          spats[0].off.off = -1;\n        else                                /* single '+' */\n          spats[0].off.off = 1;\n        ++p;\n        while (ascii_isdigit(*p))           /* skip number */\n          ++p;\n      }\n\n      /* compute length of search command for get_address() */\n      searchcmdlen += (int)(p - pat);\n\n      pat = p;                              /* put pat after search command */\n    }\n\n    if ((options & SEARCH_ECHO) && messaging() && !msg_silent\n        && (!cmd_silent || !shortmess(SHM_SEARCHCOUNT))) {\n      char_u      *trunc;\n      char_u      off_buf[40];\n      size_t      off_len = 0;\n\n      // Compute msg_row early.\n      msg_start();\n\n      // Get the offset, so we know how long it is.\n      if (!cmd_silent\n          && (spats[0].off.line || spats[0].off.end || spats[0].off.off)) {\n        p = off_buf;  // -V507\n        *p++ = dirc;\n        if (spats[0].off.end) {\n          *p++ = 'e';\n        } else if (!spats[0].off.line) {\n          *p++ = 's';\n        }\n        if (spats[0].off.off > 0 || spats[0].off.line) {\n          *p++ = '+';\n        }\n        *p = NUL;\n        if (spats[0].off.off != 0 || spats[0].off.line) {\n          snprintf((char *)p, sizeof(off_buf) - 1 - (p - off_buf),\n                   \"%\" PRId64, spats[0].off.off);\n        }\n        off_len = STRLEN(off_buf);\n      }\n\n      if (*searchstr == NUL) {\n        p = spats[0].pat;\n      } else {\n        p = searchstr;\n      }\n\n      if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent) {\n        // Reserve enough space for the search pattern + offset +\n        // search stat.  Use all the space available, so that the\n        // search state is right aligned.  If there is not enough space\n        // msg_strtrunc() will shorten in the middle.\n        if (ui_has(kUIMessages)) {\n          len = 0;  // adjusted below\n        } else if (msg_scrolled != 0 && !cmd_silent) {\n          // Use all the columns.\n          len = (Rows - msg_row) * Columns - 1;\n        } else {\n          // Use up to 'showcmd' column.\n          len = (Rows - msg_row - 1) * Columns + sc_col - 1;\n        }\n        if (len < STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3) {\n          len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;\n        }\n      } else {\n        // Reserve enough space for the search pattern + offset.\n        len = STRLEN(p) + off_len + 3;\n      }\n\n      xfree(msgbuf);\n      msgbuf = xmalloc(len);\n      memset(msgbuf, ' ', len);\n      msgbuf[len - 1] = NUL;\n\n      // do not fill the msgbuf buffer, if cmd_silent is set, leave it\n      // empty for the search_stat feature.\n      if (!cmd_silent) {\n        msgbuf[0] = dirc;\n        if (utf_iscomposing(utf_ptr2char(p))) {\n          // Use a space to draw the composing char on.\n          msgbuf[1] = ' ';\n          memmove(msgbuf + 2, p, STRLEN(p));\n        } else {\n          memmove(msgbuf + 1, p, STRLEN(p));\n        }\n        if (off_len > 0) {\n          memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);\n        }\n\n        trunc = msg_strtrunc(msgbuf, true);\n        if (trunc != NULL) {\n          xfree(msgbuf);\n          msgbuf = trunc;\n        }\n\n        // The search pattern could be shown on the right in rightleft\n        // mode, but the 'ruler' and 'showcmd' area use it too, thus\n        // it would be blanked out again very soon.  Show it on the\n        // left, but do reverse the text.\n        if (curwin->w_p_rl && *curwin->w_p_rlc == 's') {\n          char_u *r = reverse_text(trunc != NULL ? trunc : msgbuf);\n          xfree(msgbuf);\n          msgbuf = r;\n          // move reversed text to beginning of buffer\n          while (*r == ' ') {\n            r++;\n          }\n          size_t pat_len = msgbuf + STRLEN(msgbuf) - r;\n          memmove(msgbuf, r, pat_len);\n          // overwrite old text\n          if ((size_t)(r - msgbuf) >= pat_len) {\n            memset(r, ' ', pat_len);\n          } else {\n            memset(msgbuf + pat_len, ' ', r - msgbuf);\n          }\n        }\n        msg_outtrans(msgbuf);\n        msg_clr_eos();\n        msg_check();\n\n        gotocmdline(false);\n        ui_flush();\n        msg_nowait = true;  // don't wait for this message\n      }\n    }\n\n    /*\n     * If there is a character offset, subtract it from the current\n     * position, so we don't get stuck at \"?pat?e+2\" or \"/pat/s-2\".\n     * Skip this if pos.col is near MAXCOL (closed fold).\n     * This is not done for a line offset, because then we would not be vi\n     * compatible.\n     */\n    if (!spats[0].off.line && spats[0].off.off && pos.col < MAXCOL - 2) {\n      if (spats[0].off.off > 0) {\n        for (c = spats[0].off.off; c; --c)\n          if (decl(&pos) == -1)\n            break;\n        if (c) {                        /* at start of buffer */\n          pos.lnum = 0;                 /* allow lnum == 0 here */\n          pos.col = MAXCOL;\n        }\n      } else {\n        for (c = spats[0].off.off; c; ++c)\n          if (incl(&pos) == -1)\n            break;\n        if (c) {                        /* at end of buffer */\n          pos.lnum = curbuf->b_ml.ml_line_count + 1;\n          pos.col = 0;\n        }\n      }\n    }\n\n    c = searchit(curwin, curbuf, &pos, NULL, dirc == '/' ? FORWARD : BACKWARD,\n                 searchstr, count,\n                 (spats[0].off.end * SEARCH_END\n                  + (options\n                     & (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS + SEARCH_MSG\n                        + SEARCH_START\n                        + ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF)))),\n                 RE_LAST, sia);\n\n    if (dircp != NULL) {\n      *dircp = search_delim;  // restore second '/' or '?' for normal_cmd()\n    }\n\n    if (!shortmess(SHM_SEARCH)\n        && ((dirc == '/' && lt(pos, curwin->w_cursor))\n            || (dirc == '?' && lt(curwin->w_cursor, pos)))) {\n      show_top_bot_msg = true;\n    }\n\n    if (c == FAIL) {\n      retval = 0;\n      goto end_do_search;\n    }\n    if (spats[0].off.end && oap != NULL)\n      oap->inclusive = true;        /* 'e' includes last character */\n\n    retval = 1;                     /* pattern found */\n\n    /*\n     * Add character and/or line offset\n     */\n    if (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';')) {\n      pos_T org_pos = pos;\n\n      if (spats[0].off.line) {  // Add the offset to the line number.\n        c = pos.lnum + spats[0].off.off;\n        if (c < 1)\n          pos.lnum = 1;\n        else if (c > curbuf->b_ml.ml_line_count)\n          pos.lnum = curbuf->b_ml.ml_line_count;\n        else\n          pos.lnum = c;\n        pos.col = 0;\n\n        retval = 2;                 /* pattern found, line offset added */\n      } else if (pos.col < MAXCOL - 2) {      /* just in case */\n        /* to the right, check for end of file */\n        c = spats[0].off.off;\n        if (c > 0) {\n          while (c-- > 0)\n            if (incl(&pos) == -1)\n              break;\n        }\n        /* to the left, check for start of file */\n        else {\n          while (c++ < 0)\n            if (decl(&pos) == -1)\n              break;\n        }\n      }\n      if (!equalpos(pos, org_pos)) {\n        has_offset = true;\n      }\n    }\n\n    // Show [1/15] if 'S' is not in 'shortmess'.\n    if ((options & SEARCH_ECHO)\n        && messaging()\n        && !msg_silent\n        && c != FAIL\n        && !shortmess(SHM_SEARCHCOUNT)\n        && msgbuf != NULL) {\n      cmdline_search_stat(dirc, &pos, &curwin->w_cursor,\n                          show_top_bot_msg, msgbuf,\n                          (count != 1 || has_offset\n                           || (!(fdo_flags & FDO_SEARCH)\n                               && hasFolding(curwin->w_cursor.lnum, NULL,\n                                             NULL))),\n                          SEARCH_STAT_DEF_MAX_COUNT,\n                          SEARCH_STAT_DEF_TIMEOUT);\n    }\n\n    // The search command can be followed by a ';' to do another search.\n    // For example: \"/pat/;/foo/+3;?bar\"\n    // This is like doing another search command, except:\n    // - The remembered direction '/' or '?' is from the first search.\n    // - When an error happens the cursor isn't moved at all.\n    // Don't do this when called by get_address() (it handles ';' itself).\n    if (!(options & SEARCH_OPT) || pat == NULL || *pat != ';') {\n      break;\n    }\n\n    dirc = *++pat;\n    search_delim = dirc;\n    if (dirc != '?' && dirc != '/') {\n      retval = 0;\n      EMSG(_(\"E386: Expected '?' or '/'  after ';'\"));\n      goto end_do_search;\n    }\n    ++pat;\n  }\n\n  if (options & SEARCH_MARK)\n    setpcmark();\n  curwin->w_cursor = pos;\n  curwin->w_set_curswant = TRUE;\n\nend_do_search:\n  if ((options & SEARCH_KEEP) || cmdmod.keeppatterns)\n    spats[0].off = old_off;\n  xfree(msgbuf);\n\n  return retval;\n}\n\n/*\n * search_for_exact_line(buf, pos, dir, pat)\n *\n * Search for a line starting with the given pattern (ignoring leading\n * white-space), starting from pos and going in direction \"dir\". \"pos\" will\n * contain the position of the match found.    Blank lines match only if\n * ADDING is set.  If p_ic is set then the pattern must be in lowercase.\n * Return OK for success, or FAIL if no line found.\n */\nint search_for_exact_line(buf_T *buf, pos_T *pos, Direction dir, char_u *pat)\n{\n  linenr_T start = 0;\n  char_u      *ptr;\n  char_u      *p;\n\n  if (buf->b_ml.ml_line_count == 0)\n    return FAIL;\n  for (;; ) {\n    pos->lnum += dir;\n    if (pos->lnum < 1) {\n      if (p_ws) {\n        pos->lnum = buf->b_ml.ml_line_count;\n        if (!shortmess(SHM_SEARCH))\n          give_warning((char_u *)_(top_bot_msg), true);\n      } else {\n        pos->lnum = 1;\n        break;\n      }\n    } else if (pos->lnum > buf->b_ml.ml_line_count) {\n      if (p_ws) {\n        pos->lnum = 1;\n        if (!shortmess(SHM_SEARCH))\n          give_warning((char_u *)_(bot_top_msg), true);\n      } else {\n        pos->lnum = 1;\n        break;\n      }\n    }\n    if (pos->lnum == start)\n      break;\n    if (start == 0)\n      start = pos->lnum;\n    ptr = ml_get_buf(buf, pos->lnum, false);\n    p = skipwhite(ptr);\n    pos->col = (colnr_T) (p - ptr);\n\n    /* when adding lines the matching line may be empty but it is not\n     * ignored because we are interested in the next line -- Acevedo */\n    if ((compl_cont_status & CONT_ADDING)\n        && !(compl_cont_status & CONT_SOL)) {\n      if (mb_strcmp_ic((bool)p_ic, (const char *)p, (const char *)pat) == 0) {\n        return OK;\n      }\n    } else if (*p != NUL) {  // Ignore empty lines.\n      // Expanding lines or words.\n      assert(compl_length >= 0);\n      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)\n           : STRNCMP(p, pat, compl_length)) == 0)\n        return OK;\n    }\n  }\n  return FAIL;\n}\n\n/*\n * Character Searches\n */\n\n/*\n * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the\n * position of the character, otherwise move to just before the char.\n * Do this \"cap->count1\" times.\n * Return FAIL or OK.\n */\nint searchc(cmdarg_T *cap, int t_cmd)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int c = cap->nchar;                   // char to search for\n  int dir = cap->arg;                   // true for searching forward\n  long count = cap->count1;             // repeat count\n  int col;\n  char_u              *p;\n  int len;\n  bool stop = true;\n\n  if (c != NUL) {       /* normal search: remember args for repeat */\n    if (!KeyStuffed) {      /* don't remember when redoing */\n      *lastc = c;\n      set_csearch_direction(dir);\n      set_csearch_until(t_cmd);\n      lastc_bytelen = utf_char2bytes(c, lastc_bytes);\n      if (cap->ncharC1 != 0) {\n        lastc_bytelen += utf_char2bytes(cap->ncharC1,\n                                        lastc_bytes + lastc_bytelen);\n        if (cap->ncharC2 != 0) {\n          lastc_bytelen += utf_char2bytes(cap->ncharC2,\n                                          lastc_bytes + lastc_bytelen);\n        }\n      }\n    }\n  } else {            // repeat previous search\n    if (*lastc == NUL && lastc_bytelen == 1) {\n      return FAIL;\n    }\n    if (dir) {        // repeat in opposite direction\n      dir = -lastcdir;\n    } else {\n      dir = lastcdir;\n    }\n    t_cmd = last_t_cmd;\n    c = *lastc;\n    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */\n\n    /* Force a move of at least one char, so \";\" and \",\" will move the\n     * cursor, even if the cursor is right in front of char we are looking\n     * at. */\n    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd) {\n      stop = false;\n    }\n  }\n\n  if (dir == BACKWARD)\n    cap->oap->inclusive = false;\n  else\n    cap->oap->inclusive = true;\n\n  p = get_cursor_line_ptr();\n  col = curwin->w_cursor.col;\n  len = (int)STRLEN(p);\n\n  while (count--) {\n    for (;; ) {\n      if (dir > 0) {\n        col += utfc_ptr2len(p + col);\n        if (col >= len) {\n          return FAIL;\n        }\n      } else {\n        if (col == 0) {\n          return FAIL;\n        }\n        col -= utf_head_off(p, p + col - 1) + 1;\n      }\n      if (lastc_bytelen == 1) {\n        if (p[col] == c && stop) {\n          break;\n        }\n      } else if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0 && stop) {\n        break;\n      }\n      stop = true;\n    }\n  }\n\n  if (t_cmd) {\n    // Backup to before the character (possibly double-byte).\n    col -= dir;\n    if (dir < 0) {\n      // Landed on the search char which is lastc_bytelen long.\n      col += lastc_bytelen - 1;\n    } else {\n      // To previous char, which may be multi-byte.\n      col -= utf_head_off(p, p + col);\n    }\n  }\n  curwin->w_cursor.col = col;\n\n  return OK;\n}\n\n/*\n * \"Other\" Searches\n */\n\n/*\n * findmatch - find the matching paren or brace\n *\n * Improvement over vi: Braces inside quotes are ignored.\n */\npos_T *findmatch(oparg_T *oap, int initc)\n{\n  return findmatchlimit(oap, initc, 0, 0);\n}\n\n// Return true if the character before \"linep[col]\" equals \"ch\".\n// Return false if \"col\" is zero.\n// Update \"*prevcol\" to the column of the previous character, unless \"prevcol\"\n// is NULL.\n// Handles multibyte string correctly.\nstatic bool check_prevcol(char_u *linep, int col, int ch, int *prevcol)\n{\n  col--;\n  if (col > 0) {\n    col -= utf_head_off(linep, linep + col);\n  }\n  if (prevcol) {\n    *prevcol = col;\n  }\n  return col >= 0 && linep[col] == ch;\n}\n\n/*\n * Raw string start is found at linep[startpos.col - 1].\n * Return true if the matching end can be found between startpos and endpos.\n */\nstatic bool find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)\n{\n  char_u *p;\n  char_u *delim_copy;\n  size_t delim_len;\n  linenr_T lnum;\n\n  for (p = linep + startpos->col + 1; *p && *p != '('; p++) {}\n\n  delim_len = (p - linep) - startpos->col - 1;\n  delim_copy = vim_strnsave(linep + startpos->col + 1, delim_len);\n  bool found = false;\n  for (lnum = startpos->lnum; lnum <= endpos->lnum; lnum++) {\n    char_u *line = ml_get(lnum);\n\n    for (p = line + (lnum == startpos->lnum ? startpos->col + 1 : 0); *p; p++) {\n      if (lnum == endpos->lnum && (colnr_T)(p - line) >= endpos->col) {\n        break;\n      }\n      if (*p == ')'\n          && STRNCMP(delim_copy, p + 1, delim_len) == 0\n          && p[delim_len + 1] == '\"') {\n        found = true;\n        break;\n      }\n    }\n    if (found) {\n      break;\n    }\n  }\n  xfree(delim_copy);\n  return found;\n}\n\n/// Check matchpairs option for \"*initc\".\n/// If there is a match set \"*initc\" to the matching character and \"*findc\" to\n/// the opposite character.  Set \"*backwards\" to the direction.\n/// When \"switchit\" is true swap the direction.\nstatic void find_mps_values(int *initc, int *findc, bool *backwards,\n                            bool switchit)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *ptr = curbuf->b_p_mps;\n\n  while (*ptr != NUL) {\n    if (utf_ptr2char(ptr) == *initc) {\n      if (switchit) {\n        *findc = *initc;\n        *initc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);\n        *backwards = true;\n      } else {\n        *findc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);\n        *backwards = false;\n      }\n      return;\n    }\n    char_u *prev = ptr;\n    ptr += utfc_ptr2len(ptr) + 1;\n    if (utf_ptr2char(ptr) == *initc) {\n      if (switchit) {\n        *findc = *initc;\n        *initc = utf_ptr2char(prev);\n        *backwards = false;\n      } else {\n        *findc = utf_ptr2char(prev);\n        *backwards = true;\n      }\n      return;\n    }\n    ptr += utfc_ptr2len(ptr);\n    if (*ptr == ',') {\n      ptr++;\n    }\n  }\n}\n\n/*\n * findmatchlimit -- find the matching paren or brace, if it exists within\n * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling\n * off the edge of the file.\n *\n * \"initc\" is the character to find a match for.  NUL means to find the\n * character at or after the cursor. Special values:\n * '*'  look for C-style comment / *\n * '/'  look for C-style comment / *, ignoring comment-end\n * '#'  look for preprocessor directives\n * 'R'  look for raw string start: R\"delim(text)delim\" (only backwards)\n *\n * flags: FM_BACKWARD search backwards (when initc is '/', '*' or '#')\n *    FM_FORWARD  search forwards (when initc is '/', '*' or '#')\n *    FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)\n *    FM_SKIPCOMM skip comments (not implemented yet!)\n *\n * \"oap\" is only used to set oap->motion_type for a linewise motion, it can be\n * NULL\n */\n\npos_T *findmatchlimit(oparg_T *oap, int initc, int flags, int64_t maxtravel)\n{\n  static pos_T pos;                     // current search position\n  int findc = 0;                        // matching brace\n  int count = 0;                        // cumulative number of braces\n  bool backwards = false;               // init for gcc\n  bool raw_string = false;              // search for raw string\n  bool inquote = false;                 // true when inside quotes\n  char_u      *ptr;\n  int hash_dir = 0;                     // Direction searched for # things\n  int comment_dir = 0;                  // Direction searched for comments\n  int traveled = 0;                     // how far we've searched so far\n  bool ignore_cend = false;             // ignore comment end\n  int match_escaped = 0;                // search for escaped match\n  int dir;                              // Direction to search\n  int comment_col = MAXCOL;             // start of / / comment\n  bool lispcomm = false;                // inside of Lisp-style comment\n  bool lisp = curbuf->b_p_lisp;         // engage Lisp-specific hacks ;)\n\n  pos = curwin->w_cursor;\n  pos.coladd = 0;\n  char_u *linep = ml_get(pos.lnum);     // pointer to current line\n\n  // vi compatible matching\n  bool cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);\n  // don't recognize backslashes\n  bool cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);\n\n  /* Direction to search when initc is '/', '*' or '#' */\n  if (flags & FM_BACKWARD)\n    dir = BACKWARD;\n  else if (flags & FM_FORWARD)\n    dir = FORWARD;\n  else\n    dir = 0;\n\n  /*\n   * if initc given, look in the table for the matching character\n   * '/' and '*' are special cases: look for start or end of comment.\n   * When '/' is used, we ignore running backwards into a star-slash, for\n   * \"[*\" command, we just want to find any comment.\n   */\n  if (initc == '/' || initc == '*' || initc == 'R') {\n    comment_dir = dir;\n    if (initc == '/')\n      ignore_cend = true;\n    backwards = (dir == FORWARD) ? false : true;\n    raw_string = (initc == 'R');\n    initc = NUL;\n  } else if (initc != '#' && initc != NUL) {\n    find_mps_values(&initc, &findc, &backwards, true);\n    if (findc == NUL) {\n      return NULL;\n    }\n  } else {\n    /*\n     * Either initc is '#', or no initc was given and we need to look\n     * under the cursor.\n     */\n    if (initc == '#') {\n      hash_dir = dir;\n    } else {\n      /*\n       * initc was not given, must look for something to match under\n       * or near the cursor.\n       * Only check for special things when 'cpo' doesn't have '%'.\n       */\n      if (!cpo_match) {\n        /* Are we before or at #if, #else etc.? */\n        ptr = skipwhite(linep);\n        if (*ptr == '#' && pos.col <= (colnr_T)(ptr - linep)) {\n          ptr = skipwhite(ptr + 1);\n          if (   STRNCMP(ptr, \"if\", 2) == 0\n                 || STRNCMP(ptr, \"endif\", 5) == 0\n                 || STRNCMP(ptr, \"el\", 2) == 0)\n            hash_dir = 1;\n        }\n        /* Are we on a comment? */\n        else if (linep[pos.col] == '/') {\n          if (linep[pos.col + 1] == '*') {\n            comment_dir = FORWARD;\n            backwards = false;\n            pos.col++;\n          } else if (pos.col > 0 && linep[pos.col - 1] == '*') {\n            comment_dir = BACKWARD;\n            backwards = true;\n            pos.col--;\n          }\n        } else if (linep[pos.col] == '*') {\n          if (linep[pos.col + 1] == '/') {\n            comment_dir = BACKWARD;\n            backwards = true;\n          } else if (pos.col > 0 && linep[pos.col - 1] == '/') {\n            comment_dir = FORWARD;\n            backwards = false;\n          }\n        }\n      }\n\n      /*\n       * If we are not on a comment or the # at the start of a line, then\n       * look for brace anywhere on this line after the cursor.\n       */\n      if (!hash_dir && !comment_dir) {\n        /*\n         * Find the brace under or after the cursor.\n         * If beyond the end of the line, use the last character in\n         * the line.\n         */\n        if (linep[pos.col] == NUL && pos.col)\n          --pos.col;\n        for (;; ) {\n          initc = PTR2CHAR(linep + pos.col);\n          if (initc == NUL)\n            break;\n\n          find_mps_values(&initc, &findc, &backwards, false);\n          if (findc) {\n            break;\n          }\n          pos.col += utfc_ptr2len(linep + pos.col);\n        }\n        if (!findc) {\n          /* no brace in the line, maybe use \"  #if\" then */\n          if (!cpo_match && *skipwhite(linep) == '#')\n            hash_dir = 1;\n          else\n            return NULL;\n        } else if (!cpo_bsl) {\n          int col, bslcnt = 0;\n\n          /* Set \"match_escaped\" if there are an odd number of\n           * backslashes. */\n          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )\n            bslcnt++;\n          match_escaped = (bslcnt & 1);\n        }\n      }\n    }\n    if (hash_dir) {\n      /*\n       * Look for matching #if, #else, #elif, or #endif\n       */\n      if (oap != NULL) {\n        oap->motion_type = kMTLineWise;  // Linewise for this case only\n      }\n      if (initc != '#') {\n        ptr = skipwhite(skipwhite(linep) + 1);\n        if (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)\n          hash_dir = 1;\n        else if (STRNCMP(ptr, \"endif\", 5) == 0)\n          hash_dir = -1;\n        else\n          return NULL;\n      }\n      pos.col = 0;\n      while (!got_int) {\n        if (hash_dir > 0) {\n          if (pos.lnum == curbuf->b_ml.ml_line_count)\n            break;\n        } else if (pos.lnum == 1)\n          break;\n        pos.lnum += hash_dir;\n        linep = ml_get(pos.lnum);\n        line_breakcheck();              /* check for CTRL-C typed */\n        ptr = skipwhite(linep);\n        if (*ptr != '#')\n          continue;\n        pos.col = (colnr_T) (ptr - linep);\n        ptr = skipwhite(ptr + 1);\n        if (hash_dir > 0) {\n          if (STRNCMP(ptr, \"if\", 2) == 0)\n            count++;\n          else if (STRNCMP(ptr, \"el\", 2) == 0) {\n            if (count == 0)\n              return &pos;\n          } else if (STRNCMP(ptr, \"endif\", 5) == 0) {\n            if (count == 0)\n              return &pos;\n            count--;\n          }\n        } else {\n          if (STRNCMP(ptr, \"if\", 2) == 0) {\n            if (count == 0)\n              return &pos;\n            count--;\n          } else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0) {\n            if (count == 0)\n              return &pos;\n          } else if (STRNCMP(ptr, \"endif\", 5) == 0)\n            count++;\n        }\n      }\n      return NULL;\n    }\n  }\n\n  // This is just guessing: when 'rightleft' is set, search for a matching\n  // paren/brace in the other direction.\n  if (curwin->w_p_rl && vim_strchr((char_u *)\"()[]{}<>\", initc) != NULL) {\n    backwards = !backwards;\n  }\n\n  int do_quotes = -1;                 // check for quotes in current line\n  int at_start;                       // do_quotes value at start position\n  TriState start_in_quotes = kNone;   // start position is in quotes\n  pos_T match_pos;                    // Where last slash-star was found\n  clearpos(&match_pos);\n\n  /* backward search: Check if this line contains a single-line comment */\n  if ((backwards && comment_dir)\n      || lisp\n      )\n    comment_col = check_linecomment(linep);\n  if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col) {\n    lispcomm = true;        // find match inside this comment\n  }\n  while (!got_int) {\n    /*\n     * Go to the next position, forward or backward. We could use\n     * inc() and dec() here, but that is much slower\n     */\n    if (backwards) {\n      /* char to match is inside of comment, don't search outside */\n      if (lispcomm && pos.col < (colnr_T)comment_col)\n        break;\n      if (pos.col == 0) {               /* at start of line, go to prev. one */\n        if (pos.lnum == 1)              /* start of file */\n          break;\n        --pos.lnum;\n\n        if (maxtravel > 0 && ++traveled > maxtravel)\n          break;\n\n        linep = ml_get(pos.lnum);\n        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */\n        do_quotes = -1;\n        line_breakcheck();\n\n        /* Check if this line contains a single-line comment */\n        if (comment_dir\n            || lisp\n            )\n          comment_col = check_linecomment(linep);\n        /* skip comment */\n        if (lisp && comment_col != MAXCOL)\n          pos.col = comment_col;\n      } else {\n        pos.col--;\n        pos.col -= utf_head_off(linep, linep + pos.col);\n      }\n    } else {                          /* forward search */\n      if (linep[pos.col] == NUL\n          /* at end of line, go to next one */\n          /* don't search for match in comment */\n          || (lisp && comment_col != MAXCOL\n              && pos.col == (colnr_T)comment_col)\n          ) {\n        if (pos.lnum == curbuf->b_ml.ml_line_count          /* end of file */\n            /* line is exhausted and comment with it,\n             * don't search for match in code */\n            || lispcomm\n            )\n          break;\n        ++pos.lnum;\n\n        if (maxtravel && traveled++ > maxtravel)\n          break;\n\n        linep = ml_get(pos.lnum);\n        pos.col = 0;\n        do_quotes = -1;\n        line_breakcheck();\n        if (lisp)           /* find comment pos in new line */\n          comment_col = check_linecomment(linep);\n      } else {\n        pos.col += utfc_ptr2len(linep + pos.col);\n      }\n    }\n\n    // If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.\n    if (pos.col == 0 && (flags & FM_BLOCKSTOP)\n        && (linep[0] == '{' || linep[0] == '}')) {\n      if (linep[0] == findc && count == 0) {  // match!\n        return &pos;\n      }\n      break;  // out of scope\n    }\n\n    if (comment_dir) {\n      /* Note: comments do not nest, and we ignore quotes in them */\n      /* TODO: ignore comment brackets inside strings */\n      if (comment_dir == FORWARD) {\n        if (linep[pos.col] == '*' && linep[pos.col + 1] == '/') {\n          pos.col++;\n          return &pos;\n        }\n      } else {    /* Searching backwards */\n        /*\n         * A comment may contain / * or / /, it may also start or end\n         * with / * /. Ignore a / * after / / and after *.\n         */\n        if (pos.col == 0)\n          continue;\n        else if (raw_string)\n        {\n          if (linep[pos.col - 1] == 'R'\n              && linep[pos.col] == '\"'\n              && vim_strchr(linep + pos.col + 1, '(') != NULL)\n          {\n            /* Possible start of raw string. Now that we have the\n             * delimiter we can check if it ends before where we\n             * started searching, or before the previously found\n             * raw string start. */\n            if (!find_rawstring_end(linep, &pos,\n                  count > 0 ? &match_pos : &curwin->w_cursor))\n            {\n              count++;\n              match_pos = pos;\n              match_pos.col--;\n            }\n            linep = ml_get(pos.lnum); /* may have been released */\n          }\n        } else if (  linep[pos.col - 1] == '/'\n                   && linep[pos.col] == '*'\n                   && (pos.col == 1 || linep[pos.col - 2] != '*')\n                   && (int)pos.col < comment_col) {\n          count++;\n          match_pos = pos;\n          match_pos.col--;\n        } else if (linep[pos.col - 1] == '*' && linep[pos.col] == '/') {\n          if (count > 0)\n            pos = match_pos;\n          else if (pos.col > 1 && linep[pos.col - 2] == '/'\n                   && (int)pos.col <= comment_col)\n            pos.col -= 2;\n          else if (ignore_cend)\n            continue;\n          else\n            return NULL;\n          return &pos;\n        }\n      }\n      continue;\n    }\n\n    /*\n     * If smart matching ('cpoptions' does not contain '%'), braces inside\n     * of quotes are ignored, but only if there is an even number of\n     * quotes in the line.\n     */\n    if (cpo_match)\n      do_quotes = 0;\n    else if (do_quotes == -1) {\n      /*\n       * Count the number of quotes in the line, skipping \\\" and '\"'.\n       * Watch out for \"\\\\\".\n       */\n      at_start = do_quotes;\n      for (ptr = linep; *ptr; ++ptr) {\n        if (ptr == linep + pos.col + backwards)\n          at_start = (do_quotes & 1);\n        if (*ptr == '\"'\n            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))\n          ++do_quotes;\n        if (*ptr == '\\\\' && ptr[1] != NUL)\n          ++ptr;\n      }\n      do_quotes &= 1;               /* result is 1 with even number of quotes */\n\n      /*\n       * If we find an uneven count, check current line and previous\n       * one for a '\\' at the end.\n       */\n      if (!do_quotes) {\n        inquote = false;\n        if (ptr[-1] == '\\\\') {\n          do_quotes = 1;\n          if (start_in_quotes == kNone) {\n            // Do we need to use at_start here?\n            inquote = true;\n            start_in_quotes = kTrue;\n          } else if (backwards) {\n            inquote = true;\n          }\n        }\n        if (pos.lnum > 1) {\n          ptr = ml_get(pos.lnum - 1);\n          if (*ptr && *(ptr + STRLEN(ptr) - 1) == '\\\\') {\n            do_quotes = 1;\n            if (start_in_quotes == kNone) {\n              inquote = at_start;\n              if (inquote) {\n                start_in_quotes = kTrue;\n              }\n            } else if (!backwards) {\n              inquote = true;\n            }\n          }\n\n          /* ml_get() only keeps one line, need to get linep again */\n          linep = ml_get(pos.lnum);\n        }\n      }\n    }\n    if (start_in_quotes == kNone) {\n      start_in_quotes = kFalse;\n    }\n\n    /*\n     * If 'smartmatch' is set:\n     *   Things inside quotes are ignored by setting 'inquote'.  If we\n     *   find a quote without a preceding '\\' invert 'inquote'.  At the\n     *   end of a line not ending in '\\' we reset 'inquote'.\n     *\n     *   In lines with an uneven number of quotes (without preceding '\\')\n     *   we do not know which part to ignore. Therefore we only set\n     *   inquote if the number of quotes in a line is even, unless this\n     *   line or the previous one ends in a '\\'.  Complicated, isn't it?\n     */\n    const int c = PTR2CHAR(linep + pos.col);\n    switch (c) {\n    case NUL:\n      /* at end of line without trailing backslash, reset inquote */\n      if (pos.col == 0 || linep[pos.col - 1] != '\\\\') {\n        inquote = false;\n        start_in_quotes = kFalse;\n      }\n      break;\n\n    case '\"':\n      /* a quote that is preceded with an odd number of backslashes is\n       * ignored */\n      if (do_quotes) {\n        int col;\n\n        for (col = pos.col - 1; col >= 0; --col)\n          if (linep[col] != '\\\\')\n            break;\n        if ((((int)pos.col - 1 - col) & 1) == 0) {\n          inquote = !inquote;\n          start_in_quotes = kFalse;\n        }\n      }\n      break;\n\n    /*\n     * If smart matching ('cpoptions' does not contain '%'):\n     *   Skip things in single quotes: 'x' or '\\x'.  Be careful for single\n     *   single quotes, eg jon's.  Things like '\\233' or '\\x3f' are not\n     *   skipped, there is never a brace in them.\n     *   Ignore this when finding matches for `'.\n     */\n    case '\\'':\n      if (!cpo_match && initc != '\\'' && findc != '\\'') {\n        if (backwards) {\n          if (pos.col > 1) {\n            if (linep[pos.col - 2] == '\\'') {\n              pos.col -= 2;\n              break;\n            } else if (linep[pos.col - 2] == '\\\\'\n                       && pos.col > 2 && linep[pos.col - 3] == '\\'') {\n              pos.col -= 3;\n              break;\n            }\n          }\n        } else if (linep[pos.col + 1]) {  // forward search\n          if (linep[pos.col + 1] == '\\\\'\n              && linep[pos.col + 2] && linep[pos.col + 3] == '\\'') {\n            pos.col += 3;\n            break;\n          } else if (linep[pos.col + 2] == '\\'') {\n            pos.col += 2;\n            break;\n          }\n        }\n      }\n      FALLTHROUGH;\n\n    default:\n      /*\n       * For Lisp skip over backslashed (), {} and [].\n       * (actually, we skip #\\( et al)\n       */\n      if (curbuf->b_p_lisp\n          && vim_strchr((char_u *)\"(){}[]\", c) != NULL\n          && pos.col > 1\n          && check_prevcol(linep, pos.col, '\\\\', NULL)\n          && check_prevcol(linep, pos.col - 1, '#', NULL))\n        break;\n\n      /* Check for match outside of quotes, and inside of\n       * quotes when the start is also inside of quotes. */\n      if ((!inquote || start_in_quotes == kTrue)\n          && (c == initc || c == findc)) {\n        int col, bslcnt = 0;\n\n        if (!cpo_bsl) {\n          for (col = pos.col; check_prevcol(linep, col, '\\\\', &col); )\n            bslcnt++;\n        }\n        /* Only accept a match when 'M' is in 'cpo' or when escaping\n         * is what we expect. */\n        if (cpo_bsl || (bslcnt & 1) == match_escaped) {\n          if (c == initc)\n            count++;\n          else {\n            if (count == 0)\n              return &pos;\n            count--;\n          }\n        }\n      }\n    }\n  }\n\n  if (comment_dir == BACKWARD && count > 0) {\n    pos = match_pos;\n    return &pos;\n  }\n  return (pos_T *)NULL;         /* never found it */\n}\n\n/*\n * Check if line[] contains a / / comment.\n * Return MAXCOL if not, otherwise return the column.\n * TODO: skip strings.\n */\nstatic int check_linecomment(const char_u *line)\n{\n  const char_u *p = line;  // scan from start\n  // skip Lispish one-line comments\n  if (curbuf->b_p_lisp) {\n    if (vim_strchr(p, ';') != NULL) {   // there may be comments\n      bool in_str = false;       // inside of string\n\n      while ((p = vim_strpbrk(p, (char_u *)\"\\\";\")) != NULL) {\n        if (*p == '\"') {\n          if (in_str) {\n            if (*(p - 1) != '\\\\') {             // skip escaped quote\n              in_str = false;\n            }\n          } else if (p == line || ((p - line) >= 2\n                                   // skip #\\\" form\n                                   && *(p - 1) != '\\\\' && *(p - 2) != '#')) {\n            in_str = true;\n          }\n        } else if (!in_str && ((p - line) < 2\n                               || (*(p - 1) != '\\\\' && *(p - 2) != '#'))) {\n          break;                // found!\n        }\n        p++;\n      }\n    } else\n      p = NULL;\n  } else\n    while ((p = vim_strchr(p, '/')) != NULL) {\n      /* accept a double /, unless it's preceded with * and followed by *,\n       * because * / / * is an end and start of a C comment */\n      if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*'))\n        break;\n      ++p;\n    }\n\n  if (p == NULL)\n    return MAXCOL;\n  return (int)(p - line);\n}\n\n/*\n * Move cursor briefly to character matching the one under the cursor.\n * Used for Insert mode and \"r\" command.\n * Show the match only if it is visible on the screen.\n * If there isn't a match, then beep.\n */\nvoid\nshowmatch(\n    int c                      // char to show match for\n)\n{\n  pos_T       *lpos, save_cursor;\n  pos_T mpos;\n  colnr_T vcol;\n  long *so = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n  long *siso = curwin->w_p_siso >= 0 ? &curwin->w_p_siso : &p_siso;\n  long save_so;\n  long save_siso;\n  int save_state;\n  colnr_T save_dollar_vcol;\n  char_u      *p;\n\n  /*\n   * Only show match for chars in the 'matchpairs' option.\n   */\n  /* 'matchpairs' is \"x:y,x:y\" */\n  for (p = curbuf->b_p_mps; *p != NUL; ++p) {\n    if (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))\n      break;\n    p += utfc_ptr2len(p) + 1;\n    if (PTR2CHAR(p) == c && !(curwin->w_p_rl ^ p_ri)) {\n      break;\n    }\n    p += utfc_ptr2len(p);\n    if (*p == NUL) {\n      return;\n    }\n  }\n  if (*p == NUL) {\n    return;\n  }\n\n  if ((lpos = findmatch(NULL, NUL)) == NULL) {  // no match, so beep\n    vim_beep(BO_MATCH);\n  } else if (lpos->lnum >= curwin->w_topline\n      && lpos->lnum < curwin->w_botline) {\n    if (!curwin->w_p_wrap) {\n      getvcol(curwin, lpos, NULL, &vcol, NULL);\n    }\n    if (curwin->w_p_wrap\n        || (vcol >= curwin->w_leftcol\n            && vcol < curwin->w_leftcol + curwin->w_width_inner)) {\n      mpos = *lpos;  // save the pos, update_screen() may change it\n      save_cursor = curwin->w_cursor;\n      save_so = *so;\n      save_siso = *siso;\n      // Handle \"$\" in 'cpo': If the ')' is typed on top of the \"$\",\n      // stop displaying the \"$\".\n      if (dollar_vcol >= 0 && dollar_vcol == curwin->w_virtcol) {\n        dollar_vcol = -1;\n      }\n      curwin->w_virtcol++;              // do display ')' just before \"$\"\n      update_screen(VALID);             // show the new char first\n\n      save_dollar_vcol = dollar_vcol;\n      save_state = State;\n      State = SHOWMATCH;\n      ui_cursor_shape();                // may show different cursor shape\n      curwin->w_cursor = mpos;          // move to matching char\n      *so = 0;                          // don't use 'scrolloff' here\n      *siso = 0;                        // don't use 'sidescrolloff' here\n      showruler(false);\n      setcursor();\n      ui_flush();\n      /* Restore dollar_vcol(), because setcursor() may call curs_rows()\n       * which resets it if the matching position is in a previous line\n       * and has a higher column number. */\n      dollar_vcol = save_dollar_vcol;\n\n      /*\n       * brief pause, unless 'm' is present in 'cpo' and a character is\n       * available.\n       */\n      if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL) {\n        os_delay(p_mat * 100L + 8, true);\n      } else if (!char_avail()) {\n        os_delay(p_mat * 100L + 9, false);\n      }\n      curwin->w_cursor = save_cursor;           // restore cursor position\n      *so = save_so;\n      *siso = save_siso;\n      State = save_state;\n      ui_cursor_shape();                // may show different cursor shape\n    }\n  }\n}\n\n// Find the start of the next sentence, searching in the direction specified\n// by the \"dir\" argument.  The cursor is positioned on the start of the next\n// sentence when found.  If the next sentence is found, return OK.  Return FAIL\n// otherwise.  See \":h sentence\" for the precise definition of a \"sentence\"\n// text object.\nint findsent(Direction dir, long count)\n{\n  pos_T pos, tpos;\n  int c;\n  int         (*func)(pos_T *);\n  bool noskip = false;              // do not skip blanks\n\n  pos = curwin->w_cursor;\n  if (dir == FORWARD)\n    func = incl;\n  else\n    func = decl;\n\n  while (count--) {\n    const pos_T prev_pos = pos;\n\n    // if on an empty line, skip up to a non-empty line\n    if (gchar_pos(&pos) == NUL) {\n      do {\n        if ((*func)(&pos) == -1) {\n          break;\n        }\n      } while (gchar_pos(&pos) == NUL);\n      if (dir == FORWARD) {\n        goto found;\n      }\n    // if on the start of a paragraph or a section and searching forward,\n    // go to the next line\n    } else if (dir == FORWARD && pos.col == 0\n               && startPS(pos.lnum, NUL, false)) {\n      if (pos.lnum == curbuf->b_ml.ml_line_count) {\n        return FAIL;\n      }\n      pos.lnum++;\n      goto found;\n    } else if (dir == BACKWARD) {\n      decl(&pos);\n    }\n\n    // go back to the previous non-white non-punctuation character\n    bool found_dot = false;\n    while (c = gchar_pos(&pos), ascii_iswhite(c)\n           || vim_strchr((char_u *)\".!?)]\\\"'\", c) != NULL) {\n      tpos = pos;\n      if (decl(&tpos) == -1 || (LINEEMPTY(tpos.lnum) && dir == FORWARD)) {\n        break;\n      }\n      if (found_dot) {\n        break;\n      }\n      if (vim_strchr((char_u *) \".!?\", c) != NULL) {\n        found_dot = true;\n      }\n      if (vim_strchr((char_u *) \")]\\\"'\", c) != NULL\n          && vim_strchr((char_u *) \".!?)]\\\"'\", gchar_pos(&tpos)) == NULL) {\n        break;\n      }\n      decl(&pos);\n    }\n\n    // remember the line where the search started\n    const int startlnum = pos.lnum;\n    const bool cpo_J = vim_strchr(p_cpo, CPO_ENDOFSENT) != NULL;\n\n    for (;; ) {                 /* find end of sentence */\n      c = gchar_pos(&pos);\n      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {\n        if (dir == BACKWARD && pos.lnum != startlnum)\n          ++pos.lnum;\n        break;\n      }\n      if (c == '.' || c == '!' || c == '?') {\n        tpos = pos;\n        do\n          if ((c = inc(&tpos)) == -1)\n            break;\n        while (vim_strchr((char_u *)\")]\\\"'\", c = gchar_pos(&tpos))\n               != NULL);\n        if (c == -1  || (!cpo_J && (c == ' ' || c == '\\t')) || c == NUL\n            || (cpo_J && (c == ' ' && inc(&tpos) >= 0\n                          && gchar_pos(&tpos) == ' '))) {\n          pos = tpos;\n          if (gchar_pos(&pos) == NUL)           /* skip NUL at EOL */\n            inc(&pos);\n          break;\n        }\n      }\n      if ((*func)(&pos) == -1) {\n        if (count)\n          return FAIL;\n        noskip = true;\n        break;\n      }\n    }\nfound:\n    /* skip white space */\n    while (!noskip && ((c = gchar_pos(&pos)) == ' ' || c == '\\t'))\n      if (incl(&pos) == -1)\n        break;\n\n    if (equalpos(prev_pos, pos)) {\n      // didn't actually move, advance one character and try again\n      if ((*func)(&pos) == -1) {\n        if (count) {\n          return FAIL;\n        }\n        break;\n      }\n      count++;\n    }\n  }\n\n  setpcmark();\n  curwin->w_cursor = pos;\n  return OK;\n}\n\n/*\n * Find the next paragraph or section in direction 'dir'.\n * Paragraphs are currently supposed to be separated by empty lines.\n * If 'what' is NUL we go to the next paragraph.\n * If 'what' is '{' or '}' we go to the next section.\n * If 'both' is TRUE also stop at '}'.\n * Return TRUE if the next paragraph or section was found.\n */\nbool\nfindpar (\n    bool *pincl,        /* Return: true if last char is to be included */\n    int dir,\n    long count,\n    int what,\n    int both\n)\n{\n  linenr_T curr;\n  bool did_skip;            /* true after separating lines have been skipped */\n  bool first;               /* true on first line */\n  linenr_T fold_first;      /* first line of a closed fold */\n  linenr_T fold_last;       /* last line of a closed fold */\n  bool fold_skipped;        /* true if a closed fold was skipped this\n                               iteration */\n\n  curr = curwin->w_cursor.lnum;\n\n  while (count--) {\n    did_skip = false;\n    for (first = true;; first = false) {\n      if (*ml_get(curr) != NUL)\n        did_skip = true;\n\n      /* skip folded lines */\n      fold_skipped = false;\n      if (first && hasFolding(curr, &fold_first, &fold_last)) {\n        curr = ((dir > 0) ? fold_last : fold_first) + dir;\n        fold_skipped = true;\n      }\n\n      if (!first && did_skip && startPS(curr, what, both))\n        break;\n\n      if (fold_skipped)\n        curr -= dir;\n      if ((curr += dir) < 1 || curr > curbuf->b_ml.ml_line_count) {\n        if (count)\n          return false;\n        curr -= dir;\n        break;\n      }\n    }\n  }\n  setpcmark();\n  if (both && *ml_get(curr) == '}')     /* include line with '}' */\n    ++curr;\n  curwin->w_cursor.lnum = curr;\n  if (curr == curbuf->b_ml.ml_line_count && what != '}') {\n    char_u *line = ml_get(curr);\n\n    // Put the cursor on the last character in the last line and make the\n    // motion inclusive.\n    if ((curwin->w_cursor.col = (colnr_T)STRLEN(line)) != 0) {\n      curwin->w_cursor.col--;\n      curwin->w_cursor.col -= utf_head_off(line, line + curwin->w_cursor.col);\n      *pincl = true;\n    }\n  } else\n    curwin->w_cursor.col = 0;\n  return true;\n}\n\n/*\n * check if the string 's' is a nroff macro that is in option 'opt'\n */\nstatic int inmacro(char_u *opt, char_u *s)\n{\n  char_u      *macro;\n\n  for (macro = opt; macro[0]; ++macro) {\n    /* Accept two characters in the option being equal to two characters\n     * in the line.  A space in the option matches with a space in the\n     * line or the line having ended. */\n    if (       (macro[0] == s[0]\n                || (macro[0] == ' '\n                    && (s[0] == NUL || s[0] == ' ')))\n               && (macro[1] == s[1]\n                   || ((macro[1] == NUL || macro[1] == ' ')\n                       && (s[0] == NUL || s[1] == NUL || s[1] == ' '))))\n      break;\n    ++macro;\n    if (macro[0] == NUL)\n      break;\n  }\n  return macro[0] != NUL;\n}\n\n/*\n * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.\n * If 'para' is '{' or '}' only check for sections.\n * If 'both' is TRUE also stop at '}'\n */\nint startPS(linenr_T lnum, int para, int both)\n{\n  char_u      *s;\n\n  s = ml_get(lnum);\n  if (*s == para || *s == '\\f' || (both && *s == '}')) {\n    return true;\n  }\n  if (*s == '.' && (inmacro(p_sections, s + 1)\n                    || (!para && inmacro(p_para, s + 1)))) {\n    return true;\n  }\n  return false;\n}\n\n/*\n * The following routines do the word searches performed by the 'w', 'W',\n * 'b', 'B', 'e', and 'E' commands.\n */\n\n/*\n * To perform these searches, characters are placed into one of three\n * classes, and transitions between classes determine word boundaries.\n *\n * The classes are:\n *\n * 0 - white space\n * 1 - punctuation\n * 2 or higher - keyword characters (letters, digits and underscore)\n */\n\nstatic int cls_bigword;         /* TRUE for \"W\", \"B\" or \"E\" */\n\n/*\n * cls() - returns the class of character at curwin->w_cursor\n *\n * If a 'W', 'B', or 'E' motion is being done (cls_bigword == TRUE), chars\n * from class 2 and higher are reported as class 1 since only white space\n * boundaries are of interest.\n */\nstatic int cls(void)\n{\n  int c;\n\n  c = gchar_cursor();\n  if (c == ' ' || c == '\\t' || c == NUL) {\n    return 0;\n  }\n\n  c = utf_class(c);\n\n  // If cls_bigword is TRUE, report all non-blanks as class 1.\n  if (c != 0 && cls_bigword) {\n    return 1;\n  }\n  return c;\n}\n\n/*\n * fwd_word(count, type, eol) - move forward one word\n *\n * Returns FAIL if the cursor was already at the end of the file.\n * If eol is TRUE, last word stops at end of line (for operators).\n */\nint\nfwd_word(\n    long count,\n    int bigword,                /* \"W\", \"E\" or \"B\" */\n    int eol\n)\n{\n  int sclass;               /* starting class */\n  int i;\n  int last_line;\n\n  curwin->w_cursor.coladd = 0;\n  cls_bigword = bigword;\n  while (--count >= 0) {\n    /* When inside a range of folded lines, move to the last char of the\n     * last line. */\n    if (hasFolding(curwin->w_cursor.lnum, NULL, &curwin->w_cursor.lnum)) {\n      coladvance(MAXCOL);\n    }\n    sclass = cls();\n\n    /*\n     * We always move at least one character, unless on the last\n     * character in the buffer.\n     */\n    last_line = (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count);\n    i = inc_cursor();\n    if (i == -1 || (i >= 1 && last_line))     /* started at last char in file */\n      return FAIL;\n    if (i >= 1 && eol && count == 0)          /* started at last char in line */\n      return OK;\n\n    /*\n     * Go one char past end of current word (if any)\n     */\n    if (sclass != 0)\n      while (cls() == sclass) {\n        i = inc_cursor();\n        if (i == -1 || (i >= 1 && eol && count == 0))\n          return OK;\n      }\n\n    /*\n     * go to next non-white\n     */\n    while (cls() == 0) {\n      /*\n       * We'll stop if we land on a blank line\n       */\n      if (curwin->w_cursor.col == 0 && *get_cursor_line_ptr() == NUL)\n        break;\n\n      i = inc_cursor();\n      if (i == -1 || (i >= 1 && eol && count == 0))\n        return OK;\n    }\n  }\n  return OK;\n}\n\n/*\n * bck_word() - move backward 'count' words\n *\n * If stop is TRUE and we are already on the start of a word, move one less.\n *\n * Returns FAIL if top of the file was reached.\n */\nint bck_word(long count, int bigword, int stop)\n{\n  int sclass;               /* starting class */\n\n  curwin->w_cursor.coladd = 0;\n  cls_bigword = bigword;\n  while (--count >= 0) {\n    /* When inside a range of folded lines, move to the first char of the\n     * first line. */\n    if (hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL))\n      curwin->w_cursor.col = 0;\n    sclass = cls();\n    if (dec_cursor() == -1)             /* started at start of file */\n      return FAIL;\n\n    if (!stop || sclass == cls() || sclass == 0) {\n      /*\n       * Skip white space before the word.\n       * Stop on an empty line.\n       */\n      while (cls() == 0) {\n        if (curwin->w_cursor.col == 0\n            && LINEEMPTY(curwin->w_cursor.lnum)) {\n          goto finished;\n        }\n        if (dec_cursor() == -1) {       // hit start of file, stop here\n          return OK;\n        }\n      }\n\n      /*\n       * Move backward to start of this word.\n       */\n      if (skip_chars(cls(), BACKWARD))\n        return OK;\n    }\n\n    inc_cursor();                       /* overshot - forward one */\nfinished:\n    stop = FALSE;\n  }\n  return OK;\n}\n\n/*\n * end_word() - move to the end of the word\n *\n * There is an apparent bug in the 'e' motion of the real vi. At least on the\n * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'\n * motion crosses blank lines. When the real vi crosses a blank line in an\n * 'e' motion, the cursor is placed on the FIRST character of the next\n * non-blank line. The 'E' command, however, works correctly. Since this\n * appears to be a bug, I have not duplicated it here.\n *\n * Returns FAIL if end of the file was reached.\n *\n * If stop is TRUE and we are already on the end of a word, move one less.\n * If empty is TRUE stop on an empty line.\n */\nint end_word(long count, int bigword, int stop, int empty)\n{\n  int sclass;               /* starting class */\n\n  curwin->w_cursor.coladd = 0;\n  cls_bigword = bigword;\n  while (--count >= 0) {\n    /* When inside a range of folded lines, move to the last char of the\n     * last line. */\n    if (hasFolding(curwin->w_cursor.lnum, NULL, &curwin->w_cursor.lnum)) {\n      coladvance(MAXCOL);\n    }\n    sclass = cls();\n    if (inc_cursor() == -1)\n      return FAIL;\n\n    /*\n     * If we're in the middle of a word, we just have to move to the end\n     * of it.\n     */\n    if (cls() == sclass && sclass != 0) {\n      /*\n       * Move forward to end of the current word\n       */\n      if (skip_chars(sclass, FORWARD))\n        return FAIL;\n    } else if (!stop || sclass == 0) {\n      /*\n       * We were at the end of a word. Go to the end of the next word.\n       * First skip white space, if 'empty' is TRUE, stop at empty line.\n       */\n      while (cls() == 0) {\n        if (empty && curwin->w_cursor.col == 0\n            && LINEEMPTY(curwin->w_cursor.lnum)) {\n          goto finished;\n        }\n        if (inc_cursor() == -1) {           // hit end of file, stop here\n          return FAIL;\n        }\n      }\n\n      /*\n       * Move forward to the end of this word.\n       */\n      if (skip_chars(cls(), FORWARD))\n        return FAIL;\n    }\n    dec_cursor();                       /* overshot - one char backward */\nfinished:\n    stop = FALSE;                       /* we move only one word less */\n  }\n  return OK;\n}\n\n/// Move back to the end of the word.\n///\n/// @param bigword  TRUE for \"B\"\n/// @param eol      if true, then stop at end of line.\n///\n/// @return         FAIL if start of the file was reached.\nint bckend_word(long count, int bigword, bool eol)\n{\n  int sclass;               /* starting class */\n  int i;\n\n  curwin->w_cursor.coladd = 0;\n  cls_bigword = bigword;\n  while (--count >= 0) {\n    sclass = cls();\n    if ((i = dec_cursor()) == -1)\n      return FAIL;\n    if (eol && i == 1)\n      return OK;\n\n    /*\n     * Move backward to before the start of this word.\n     */\n    if (sclass != 0) {\n      while (cls() == sclass)\n        if ((i = dec_cursor()) == -1 || (eol && i == 1))\n          return OK;\n    }\n\n    /*\n     * Move backward to end of the previous word\n     */\n    while (cls() == 0) {\n      if (curwin->w_cursor.col == 0 && LINEEMPTY(curwin->w_cursor.lnum)) {\n        break;\n      }\n      if ((i = dec_cursor()) == -1 || (eol && i == 1)) {\n        return OK;\n      }\n    }\n  }\n  return OK;\n}\n\n/// Skip a row of characters of the same class.\n///\n/// @return  true when end-of-file reached, false otherwise.\nstatic bool skip_chars(int cclass, int dir)\n{\n  while (cls() == cclass) {\n    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*\n * Go back to the start of the word or the start of white space\n */\nstatic void back_in_line(void)\n{\n  int sclass;                       /* starting class */\n\n  sclass = cls();\n  for (;; ) {\n    if (curwin->w_cursor.col == 0)          /* stop at start of line */\n      break;\n    dec_cursor();\n    if (cls() != sclass) {                  /* stop at start of word */\n      inc_cursor();\n      break;\n    }\n  }\n}\n\nstatic void find_first_blank(pos_T *posp)\n{\n  int c;\n\n  while (decl(posp) != -1) {\n    c = gchar_pos(posp);\n    if (!ascii_iswhite(c)) {\n      incl(posp);\n      break;\n    }\n  }\n}\n\n/// Skip count/2 sentences and count/2 separating white spaces.\n///\n/// @param at_start_sent  cursor is at start of sentence\nstatic void findsent_forward(long count, bool at_start_sent)\n{\n  while (count--) {\n    findsent(FORWARD, 1L);\n    if (at_start_sent)\n      find_first_blank(&curwin->w_cursor);\n    if (count == 0 || at_start_sent)\n      decl(&curwin->w_cursor);\n    at_start_sent = !at_start_sent;\n  }\n}\n\n/*\n * Find word under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\nint\ncurrent_word(\n    oparg_T *oap,\n    long count,\n    int include,                    /* TRUE: include word and white space */\n    int bigword                    /* FALSE == word, TRUE == WORD */\n)\n{\n  pos_T start_pos;\n  pos_T pos;\n  bool inclusive = true;\n  int include_white = FALSE;\n\n  cls_bigword = bigword;\n  clearpos(&start_pos);\n\n  /* Correct cursor when 'selection' is exclusive */\n  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))\n    dec_cursor();\n\n  /*\n   * When Visual mode is not active, or when the VIsual area is only one\n   * character, select the word and/or white space under the cursor.\n   */\n  if (!VIsual_active || equalpos(curwin->w_cursor, VIsual)) {\n    /*\n     * Go to start of current word or white space.\n     */\n    back_in_line();\n    start_pos = curwin->w_cursor;\n\n    /*\n     * If the start is on white space, and white space should be included\n     * (\" word\"), or start is not on white space, and white space should\n     * not be included (\"word\"), find end of word.\n     */\n    if ((cls() == 0) == include) {\n      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)\n        return FAIL;\n    } else {\n      /*\n       * If the start is not on white space, and white space should be\n       * included (\"word   \"), or start is on white space and white\n       * space should not be included (\"   \"), find start of word.\n       * If we end up in the first column of the next line (single char\n       * word) back up to end of the line.\n       */\n      fwd_word(1L, bigword, TRUE);\n      if (curwin->w_cursor.col == 0)\n        decl(&curwin->w_cursor);\n      else\n        oneleft();\n\n      if (include)\n        include_white = TRUE;\n    }\n\n    if (VIsual_active) {\n      /* should do something when inclusive == false ! */\n      VIsual = start_pos;\n      redraw_curbuf_later(INVERTED);            /* update the inversion */\n    } else {\n      oap->start = start_pos;\n      oap->motion_type = kMTCharWise;\n    }\n    --count;\n  }\n\n  /*\n   * When count is still > 0, extend with more objects.\n   */\n  while (count > 0) {\n    inclusive = true;\n    if (VIsual_active && lt(curwin->w_cursor, VIsual)) {\n      /*\n       * In Visual mode, with cursor at start: move cursor back.\n       */\n      if (decl(&curwin->w_cursor) == -1)\n        return FAIL;\n      if (include != (cls() != 0)) {\n        if (bck_word(1L, bigword, TRUE) == FAIL)\n          return FAIL;\n      } else {\n        if (bckend_word(1L, bigword, true) == FAIL) {\n          return FAIL;\n        }\n        (void)incl(&curwin->w_cursor);\n      }\n    } else {\n      /*\n       * Move cursor forward one word and/or white area.\n       */\n      if (incl(&curwin->w_cursor) == -1)\n        return FAIL;\n      if (include != (cls() == 0)) {\n        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1)\n          return FAIL;\n        /*\n         * If end is just past a new-line, we don't want to include\n         * the first character on the line.\n         * Put cursor on last char of white.\n         */\n        if (oneleft() == FAIL)\n          inclusive = false;\n      } else {\n        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)\n          return FAIL;\n      }\n    }\n    --count;\n  }\n\n  if (include_white && (cls() != 0\n                        || (curwin->w_cursor.col == 0 && !inclusive))) {\n    /*\n     * If we don't include white space at the end, move the start\n     * to include some white space there. This makes \"daw\" work\n     * better on the last word in a sentence (and \"2daw\" on last-but-one\n     * word).  Also when \"2daw\" deletes \"word.\" at the end of the line\n     * (cursor is at start of next line).\n     * But don't delete white space at start of line (indent).\n     */\n    pos = curwin->w_cursor;     /* save cursor position */\n    curwin->w_cursor = start_pos;\n    if (oneleft() == OK) {\n      back_in_line();\n      if (cls() == 0 && curwin->w_cursor.col > 0) {\n        if (VIsual_active)\n          VIsual = curwin->w_cursor;\n        else\n          oap->start = curwin->w_cursor;\n      }\n    }\n    curwin->w_cursor = pos;     /* put cursor back at end */\n  }\n\n  if (VIsual_active) {\n    if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))\n      inc_cursor();\n    if (VIsual_mode == 'V') {\n      VIsual_mode = 'v';\n      redraw_cmdline = true;                    // show mode later\n    }\n  } else\n    oap->inclusive = inclusive;\n\n  return OK;\n}\n\n/*\n * Find sentence(s) under the cursor, cursor at end.\n * When Visual active, extend it by one or more sentences.\n */\nint current_sent(oparg_T *oap, long count, int include)\n{\n  pos_T start_pos;\n  pos_T pos;\n  bool start_blank;\n  int c;\n  bool at_start_sent;\n  long ncount;\n\n  start_pos = curwin->w_cursor;\n  pos = start_pos;\n  findsent(FORWARD, 1L);        /* Find start of next sentence. */\n\n  /*\n   * When the Visual area is bigger than one character: Extend it.\n   */\n  if (VIsual_active && !equalpos(start_pos, VIsual)) {\nextend:\n    if (lt(start_pos, VIsual)) {\n      /*\n       * Cursor at start of Visual area.\n       * Find out where we are:\n       * - in the white space before a sentence\n       * - in a sentence or just after it\n       * - at the start of a sentence\n       */\n      at_start_sent = true;\n      decl(&pos);\n      while (lt(pos, curwin->w_cursor)) {\n        c = gchar_pos(&pos);\n        if (!ascii_iswhite(c)) {\n          at_start_sent = false;\n          break;\n        }\n        incl(&pos);\n      }\n      if (!at_start_sent) {\n        findsent(BACKWARD, 1L);\n        if (equalpos(curwin->w_cursor, start_pos)) {\n          at_start_sent = true;            // exactly at start of sentence\n        } else {\n          // inside a sentence, go to its end (start of next)\n          findsent(FORWARD, 1L);\n        }\n      }\n      if (include)              /* \"as\" gets twice as much as \"is\" */\n        count *= 2;\n      while (count--) {\n        if (at_start_sent)\n          find_first_blank(&curwin->w_cursor);\n        c = gchar_cursor();\n        if (!at_start_sent || (!include && !ascii_iswhite(c)))\n          findsent(BACKWARD, 1L);\n        at_start_sent = !at_start_sent;\n      }\n    } else {\n      /*\n       * Cursor at end of Visual area.\n       * Find out where we are:\n       * - just before a sentence\n       * - just before or in the white space before a sentence\n       * - in a sentence\n       */\n      incl(&pos);\n      at_start_sent = true;\n      if (!equalpos(pos, curwin->w_cursor)) {     // not just before a sentence\n        at_start_sent = false;\n        while (lt(pos, curwin->w_cursor)) {\n          c = gchar_pos(&pos);\n          if (!ascii_iswhite(c)) {\n            at_start_sent = true;\n            break;\n          }\n          incl(&pos);\n        }\n        if (at_start_sent)              /* in the sentence */\n          findsent(BACKWARD, 1L);\n        else                    /* in/before white before a sentence */\n          curwin->w_cursor = start_pos;\n      }\n\n      if (include)              /* \"as\" gets twice as much as \"is\" */\n        count *= 2;\n      findsent_forward(count, at_start_sent);\n      if (*p_sel == 'e')\n        ++curwin->w_cursor.col;\n    }\n    return OK;\n  }\n\n  /*\n   * If the cursor started on a blank, check if it is just before the start\n   * of the next sentence.\n   */\n  while (c = gchar_pos(&pos), ascii_iswhite(c))\n    incl(&pos);\n  if (equalpos(pos, curwin->w_cursor)) {\n    start_blank = true;\n    find_first_blank(&start_pos);       // go back to first blank\n  } else {\n    start_blank = false;\n    findsent(BACKWARD, 1L);\n    start_pos = curwin->w_cursor;\n  }\n  if (include)\n    ncount = count * 2;\n  else {\n    ncount = count;\n    if (start_blank)\n      --ncount;\n  }\n  if (ncount > 0) {\n    findsent_forward(ncount, true);\n  } else {\n    decl(&curwin->w_cursor);\n  }\n\n  if (include) {\n    /*\n     * If the blank in front of the sentence is included, exclude the\n     * blanks at the end of the sentence, go back to the first blank.\n     * If there are no trailing blanks, try to include leading blanks.\n     */\n    if (start_blank) {\n      find_first_blank(&curwin->w_cursor);\n      c = gchar_pos(&curwin->w_cursor);\n      if (ascii_iswhite(c))\n        decl(&curwin->w_cursor);\n    } else if (c = gchar_cursor(), !ascii_iswhite(c))\n      find_first_blank(&start_pos);\n  }\n\n  if (VIsual_active) {\n    /* Avoid getting stuck with \"is\" on a single space before a sentence. */\n    if (equalpos(start_pos, curwin->w_cursor))\n      goto extend;\n    if (*p_sel == 'e')\n      ++curwin->w_cursor.col;\n    VIsual = start_pos;\n    VIsual_mode = 'v';\n    redraw_cmdline = true;    // show mode later\n    redraw_curbuf_later(INVERTED);      // update the inversion\n  } else {\n    /* include a newline after the sentence, if there is one */\n    if (incl(&curwin->w_cursor) == -1)\n      oap->inclusive = true;\n    else\n      oap->inclusive = false;\n    oap->start = start_pos;\n    oap->motion_type = kMTCharWise;\n  }\n  return OK;\n}\n\n/*\n * Find block under the cursor, cursor at end.\n * \"what\" and \"other\" are two matching parenthesis/brace/etc.\n */\nint\ncurrent_block(\n    oparg_T *oap,\n    long count,\n    int include,                    /* TRUE == include white space */\n    int what,                       /* '(', '{', etc. */\n    int other                      /* ')', '}', etc. */\n)\n{\n  pos_T old_pos;\n  pos_T       *pos = NULL;\n  pos_T start_pos;\n  pos_T       *end_pos;\n  pos_T old_start, old_end;\n  char_u      *save_cpo;\n  bool sol = false;                      // '{' at start of line\n\n  old_pos = curwin->w_cursor;\n  old_end = curwin->w_cursor;           /* remember where we started */\n  old_start = old_end;\n\n  /*\n   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.\n   */\n  if (!VIsual_active || equalpos(VIsual, curwin->w_cursor)) {\n    setpcmark();\n    if (what == '{')                    /* ignore indent */\n      while (inindent(1))\n        if (inc_cursor() != 0)\n          break;\n    if (gchar_cursor() == what)\n      /* cursor on '(' or '{', move cursor just after it */\n      ++curwin->w_cursor.col;\n  } else if (lt(VIsual, curwin->w_cursor)) {\n    old_start = VIsual;\n    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */\n  } else\n    old_end = VIsual;\n\n  // Search backwards for unclosed '(', '{', etc..\n  // Put this position in start_pos.\n  // Ignore quotes here.  Keep the \"M\" flag in 'cpo', as that is what the\n  // user wants.\n  save_cpo = p_cpo;\n  p_cpo = (char_u *)(vim_strchr(p_cpo, CPO_MATCHBSL) != NULL ? \"%M\" : \"%\");\n  while (count-- > 0) {\n    if ((pos = findmatch(NULL, what)) == NULL) {\n      break;\n    }\n    curwin->w_cursor = *pos;\n    start_pos = *pos;  // the findmatch for end_pos will overwrite *pos\n  }\n  p_cpo = save_cpo;\n\n  /*\n   * Search for matching ')', '}', etc.\n   * Put this position in curwin->w_cursor.\n   */\n  if (pos == NULL || (end_pos = findmatch(NULL, other)) == NULL) {\n    curwin->w_cursor = old_pos;\n    return FAIL;\n  }\n  curwin->w_cursor = *end_pos;\n\n  // Try to exclude the '(', '{', ')', '}', etc. when \"include\" is FALSE.\n  // If the ending '}', ')' or ']' is only preceded by indent, skip that\n  // indent. But only if the resulting area is not smaller than what we\n  // started with.\n  while (!include) {\n    incl(&start_pos);\n    sol = (curwin->w_cursor.col == 0);\n    decl(&curwin->w_cursor);\n    while (inindent(1)) {\n      sol = true;\n      if (decl(&curwin->w_cursor) != 0) {\n        break;\n      }\n    }\n\n    /*\n     * In Visual mode, when the resulting area is not bigger than what we\n     * started with, extend it to the next block, and then exclude again.\n     */\n    if (!lt(start_pos, old_start) && !lt(old_end, curwin->w_cursor)\n        && VIsual_active) {\n      curwin->w_cursor = old_start;\n      decl(&curwin->w_cursor);\n      if ((pos = findmatch(NULL, what)) == NULL) {\n        curwin->w_cursor = old_pos;\n        return FAIL;\n      }\n      start_pos = *pos;\n      curwin->w_cursor = *pos;\n      if ((end_pos = findmatch(NULL, other)) == NULL) {\n        curwin->w_cursor = old_pos;\n        return FAIL;\n      }\n      curwin->w_cursor = *end_pos;\n    } else\n      break;\n  }\n\n  if (VIsual_active) {\n    if (*p_sel == 'e') {\n      inc(&curwin->w_cursor);\n    }\n    if (sol && gchar_cursor() != NUL) {\n      inc(&curwin->w_cursor);  // include the line break\n    }\n    VIsual = start_pos;\n    VIsual_mode = 'v';\n    redraw_curbuf_later(INVERTED);      /* update the inversion */\n    showmode();\n  } else {\n    oap->start = start_pos;\n    oap->motion_type = kMTCharWise;\n    oap->inclusive = false;\n    if (sol)\n      incl(&curwin->w_cursor);\n    else if (ltoreq(start_pos, curwin->w_cursor))\n      /* Include the character under the cursor. */\n      oap->inclusive = true;\n    else\n      /* End is before the start (no text in between <>, [], etc.): don't\n       * operate on any text. */\n      curwin->w_cursor = start_pos;\n  }\n\n  return OK;\n}\n\n\n/// @param end_tag  when true, return true if the cursor is on \"</aaa>\".\n///\n/// @return         true if the cursor is on a \"<aaa>\" tag.  Ignore \"<aaa/>\".\nstatic bool in_html_tag(bool end_tag)\n{\n  char_u      *line = get_cursor_line_ptr();\n  char_u      *p;\n  int c;\n  int lc = NUL;\n  pos_T pos;\n\n  for (p = line + curwin->w_cursor.col; p > line; ) {\n    if (*p == '<') {           // find '<' under/before cursor\n      break;\n    }\n    MB_PTR_BACK(line, p);\n    if (*p == '>') {           // find '>' before cursor\n      break;\n    }\n  }\n  if (*p != '<') {\n    return false;\n  }\n\n  pos.lnum = curwin->w_cursor.lnum;\n  pos.col = (colnr_T)(p - line);\n\n  MB_PTR_ADV(p);\n  if (end_tag) {\n    // check that there is a '/' after the '<'\n    return *p == '/';\n  }\n\n  // check that there is no '/' after the '<'\n  if (*p == '/') {\n    return false;\n  }\n\n  /* check that the matching '>' is not preceded by '/' */\n  for (;; ) {\n    if (inc(&pos) < 0) {\n      return false;\n    }\n    c = *ml_get_pos(&pos);\n    if (c == '>')\n      break;\n    lc = c;\n  }\n  return lc != '/';\n}\n\n/*\n * Find tag block under the cursor, cursor at end.\n */\nint\ncurrent_tagblock(\n    oparg_T *oap,\n    long count_arg,\n    bool include                  // true == include white space\n)\n{\n  long count = count_arg;\n  pos_T old_pos;\n  pos_T start_pos;\n  pos_T end_pos;\n  pos_T old_start, old_end;\n  char_u      *p;\n  char_u      *cp;\n  int len;\n  bool do_include = include;\n  bool save_p_ws = p_ws;\n  int retval = FAIL;\n  int is_inclusive = true;\n\n  p_ws = false;\n\n  old_pos = curwin->w_cursor;\n  old_end = curwin->w_cursor;               /* remember where we started */\n  old_start = old_end;\n  if (!VIsual_active || *p_sel == 'e')\n    decl(&old_end);                         /* old_end is inclusive */\n\n  /*\n   * If we start on \"<aaa>\" select that block.\n   */\n  if (!VIsual_active || equalpos(VIsual, curwin->w_cursor)) {\n    setpcmark();\n\n    /* ignore indent */\n    while (inindent(1))\n      if (inc_cursor() != 0)\n        break;\n\n    if (in_html_tag(false)) {\n      // cursor on start tag, move to its '>'\n      while (*get_cursor_pos_ptr() != '>') {\n        if (inc_cursor() < 0) {\n          break;\n        }\n      }\n    } else if (in_html_tag(true)) {\n      // cursor on end tag, move to just before it\n      while (*get_cursor_pos_ptr() != '<') {\n        if (dec_cursor() < 0) {\n          break;\n        }\n      }\n      dec_cursor();\n      old_end = curwin->w_cursor;\n    }\n  } else if (lt(VIsual, curwin->w_cursor)) {\n    old_start = VIsual;\n    curwin->w_cursor = VIsual;              /* cursor at low end of Visual */\n  } else\n    old_end = VIsual;\n\nagain:\n  /*\n   * Search backwards for unclosed \"<aaa>\".\n   * Put this position in start_pos.\n   */\n  for (long n = 0; n < count; n++) {\n    if (do_searchpair(\n        \"<[^ \\t>/!]\\\\+\\\\%(\\\\_s\\\\_[^>]\\\\{-}[^/]>\\\\|$\\\\|\\\\_s\\\\=>\\\\)\",\n        \"\",\n        \"</[^>]*>\", BACKWARD, NULL, 0,\n        NULL, (linenr_T)0, 0L) <= 0) {\n      curwin->w_cursor = old_pos;\n      goto theend;\n    }\n  }\n  start_pos = curwin->w_cursor;\n\n  /*\n   * Search for matching \"</aaa>\".  First isolate the \"aaa\".\n   */\n  inc_cursor();\n  p = get_cursor_pos_ptr();\n  for (cp = p;\n       *cp != NUL && *cp != '>' && !ascii_iswhite(*cp);\n       MB_PTR_ADV(cp)) {\n  }\n  len = (int)(cp - p);\n  if (len == 0) {\n    curwin->w_cursor = old_pos;\n    goto theend;\n  }\n  const size_t spat_len = len + 39;\n  char *const spat = xmalloc(spat_len);\n  const size_t epat_len = len + 9;\n  char *const epat = xmalloc(epat_len);\n  snprintf(spat, spat_len,\n           \"<%.*s\\\\>\\\\%%(\\\\_s\\\\_[^>]\\\\{-}\\\\_[^/]>\\\\|\\\\_s\\\\?>\\\\)\\\\c\", len, p);\n  snprintf(epat, epat_len, \"</%.*s>\\\\c\", len, p);\n\n  const int r = do_searchpair(spat, \"\", epat, FORWARD, NULL,\n                              0, NULL, (linenr_T)0, 0L);\n\n  xfree(spat);\n  xfree(epat);\n\n  if (r < 1 || lt(curwin->w_cursor, old_end)) {\n    /* Can't find other end or it's before the previous end.  Could be a\n     * HTML tag that doesn't have a matching end.  Search backwards for\n     * another starting tag. */\n    count = 1;\n    curwin->w_cursor = start_pos;\n    goto again;\n  }\n\n  if (do_include) {\n    // Include up to the '>'.\n    while (*get_cursor_pos_ptr() != '>') {\n      if (inc_cursor() < 0) {\n        break;\n      }\n    }\n  } else {\n    char_u *c = get_cursor_pos_ptr();\n    // Exclude the '<' of the end tag.\n    // If the closing tag is on new line, do not decrement cursor, but make\n    // operation exclusive, so that the linefeed will be selected\n    if (*c == '<' && !VIsual_active && curwin->w_cursor.col == 0) {\n      // do not decrement cursor\n      is_inclusive = false;\n    } else if (*c == '<') {\n      dec_cursor();\n    }\n  }\n  end_pos = curwin->w_cursor;\n\n  if (!do_include) {\n    /* Exclude the start tag. */\n    curwin->w_cursor = start_pos;\n    while (inc_cursor() >= 0)\n      if (*get_cursor_pos_ptr() == '>') {\n        inc_cursor();\n        start_pos = curwin->w_cursor;\n        break;\n      }\n    curwin->w_cursor = end_pos;\n\n    // If we are in Visual mode and now have the same text as before set\n    // \"do_include\" and try again.\n    if (VIsual_active\n        && equalpos(start_pos, old_start)\n        && equalpos(end_pos, old_end)) {\n      do_include = true;\n      curwin->w_cursor = old_start;\n      count = count_arg;\n      goto again;\n    }\n  }\n\n  if (VIsual_active) {\n    /* If the end is before the start there is no text between tags, select\n     * the char under the cursor. */\n    if (lt(end_pos, start_pos)) {\n      curwin->w_cursor = start_pos;\n    } else if (*p_sel == 'e') {\n      inc_cursor();\n    }\n    VIsual = start_pos;\n    VIsual_mode = 'v';\n    redraw_curbuf_later(INVERTED);      /* update the inversion */\n    showmode();\n  } else {\n    oap->start = start_pos;\n    oap->motion_type = kMTCharWise;\n    if (lt(end_pos, start_pos)) {\n      /* End is before the start: there is no text between tags; operate\n       * on an empty area. */\n      curwin->w_cursor = start_pos;\n      oap->inclusive = false;\n    } else {\n      oap->inclusive = is_inclusive;\n    }\n  }\n  retval = OK;\n\ntheend:\n  p_ws = save_p_ws;\n  return retval;\n}\n\nint\ncurrent_par(\n    oparg_T *oap,\n    long count,\n    int include,                    /* TRUE == include white space */\n    int type                       /* 'p' for paragraph, 'S' for section */\n)\n{\n  linenr_T start_lnum;\n  linenr_T end_lnum;\n  int white_in_front;\n  int dir;\n  int start_is_white;\n  int prev_start_is_white;\n  int retval = OK;\n  int do_white = FALSE;\n  int t;\n  int i;\n\n  if (type == 'S')          /* not implemented yet */\n    return FAIL;\n\n  start_lnum = curwin->w_cursor.lnum;\n\n  /*\n   * When visual area is more than one line: extend it.\n   */\n  if (VIsual_active && start_lnum != VIsual.lnum) {\nextend:\n    if (start_lnum < VIsual.lnum)\n      dir = BACKWARD;\n    else\n      dir = FORWARD;\n    for (i = count; --i >= 0; ) {\n      if (start_lnum ==\n          (dir == BACKWARD ? 1 : curbuf->b_ml.ml_line_count)) {\n        retval = FAIL;\n        break;\n      }\n\n      prev_start_is_white = -1;\n      for (t = 0; t < 2; ++t) {\n        start_lnum += dir;\n        start_is_white = linewhite(start_lnum);\n        if (prev_start_is_white == start_is_white) {\n          start_lnum -= dir;\n          break;\n        }\n        for (;; ) {\n          if (start_lnum == (dir == BACKWARD\n                             ? 1 : curbuf->b_ml.ml_line_count))\n            break;\n          if (start_is_white != linewhite(start_lnum + dir)\n              || (!start_is_white\n                  && startPS(start_lnum + (dir > 0\n                                           ? 1 : 0), 0, 0)))\n            break;\n          start_lnum += dir;\n        }\n        if (!include)\n          break;\n        if (start_lnum == (dir == BACKWARD\n                           ? 1 : curbuf->b_ml.ml_line_count))\n          break;\n        prev_start_is_white = start_is_white;\n      }\n    }\n    curwin->w_cursor.lnum = start_lnum;\n    curwin->w_cursor.col = 0;\n    return retval;\n  }\n\n  /*\n   * First move back to the start_lnum of the paragraph or white lines\n   */\n  white_in_front = linewhite(start_lnum);\n  while (start_lnum > 1) {\n    if (white_in_front) {           /* stop at first white line */\n      if (!linewhite(start_lnum - 1))\n        break;\n    } else {          /* stop at first non-white line of start of paragraph */\n      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))\n        break;\n    }\n    --start_lnum;\n  }\n\n  /*\n   * Move past the end of any white lines.\n   */\n  end_lnum = start_lnum;\n  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum))\n    ++end_lnum;\n\n  --end_lnum;\n  i = count;\n  if (!include && white_in_front)\n    --i;\n  while (i--) {\n    if (end_lnum == curbuf->b_ml.ml_line_count)\n      return FAIL;\n\n    if (!include)\n      do_white = linewhite(end_lnum + 1);\n\n    if (include || !do_white) {\n      ++end_lnum;\n      /*\n       * skip to end of paragraph\n       */\n      while (end_lnum < curbuf->b_ml.ml_line_count\n             && !linewhite(end_lnum + 1)\n             && !startPS(end_lnum + 1, 0, 0))\n        ++end_lnum;\n    }\n\n    if (i == 0 && white_in_front && include)\n      break;\n\n    /*\n     * skip to end of white lines after paragraph\n     */\n    if (include || do_white)\n      while (end_lnum < curbuf->b_ml.ml_line_count\n             && linewhite(end_lnum + 1))\n        ++end_lnum;\n  }\n\n  /*\n   * If there are no empty lines at the end, try to find some empty lines at\n   * the start (unless that has been done already).\n   */\n  if (!white_in_front && !linewhite(end_lnum) && include)\n    while (start_lnum > 1 && linewhite(start_lnum - 1))\n      --start_lnum;\n\n  if (VIsual_active) {\n    // Problem: when doing \"Vipipip\" nothing happens in a single white\n    // line, we get stuck there.  Trap this here.\n    if (VIsual_mode == 'V' && start_lnum == curwin->w_cursor.lnum) {\n      goto extend;\n    }\n    if (VIsual.lnum != start_lnum) {\n        VIsual.lnum = start_lnum;\n        VIsual.col = 0;\n    }\n    VIsual_mode = 'V';\n    redraw_curbuf_later(INVERTED);      /* update the inversion */\n    showmode();\n  } else {\n    oap->start.lnum = start_lnum;\n    oap->start.col = 0;\n    oap->motion_type = kMTLineWise;\n  }\n  curwin->w_cursor.lnum = end_lnum;\n  curwin->w_cursor.col = 0;\n\n  return OK;\n}\n\n\n/*\n * Search quote char from string line[col].\n * Quote character escaped by one of the characters in \"escape\" is not counted\n * as a quote.\n * Returns column number of \"quotechar\" or -1 when not found.\n */\nstatic int\nfind_next_quote(\n    char_u *line,\n    int col,\n    int quotechar,\n    char_u *escape            /* escape characters, can be NULL */\n)\n{\n  int c;\n\n  for (;; ) {\n    c = line[col];\n    if (c == NUL) {\n      return -1;\n    } else if (escape != NULL && vim_strchr(escape, c)) {\n      col++;\n    } else if (c == quotechar) {\n      break;\n    }\n    col += mb_ptr2len(line + col);\n  }\n  return col;\n}\n\n/*\n * Search backwards in \"line\" from column \"col_start\" to find \"quotechar\".\n * Quote character escaped by one of the characters in \"escape\" is not counted\n * as a quote.\n * Return the found column or zero.\n */\nstatic int\nfind_prev_quote(\n    char_u *line,\n    int col_start,\n    int quotechar,\n    char_u *escape            /* escape characters, can be NULL */\n)\n{\n  int n;\n\n  while (col_start > 0) {\n    col_start--;\n    col_start -= utf_head_off(line, line + col_start);\n    n = 0;\n    if (escape != NULL)\n      while (col_start - n > 0 && vim_strchr(escape,\n                 line[col_start - n - 1]) != NULL)\n        ++n;\n    if (n & 1)\n      col_start -= n;           /* uneven number of escape chars, skip it */\n    else if (line[col_start] == quotechar)\n      break;\n  }\n  return col_start;\n}\n\n// Find quote under the cursor, cursor at end.\n// Returns true if found, else false.\nbool current_quote(\n    oparg_T *oap,\n    long count,\n    bool include,                 // true == include quote char\n    int quotechar                 // Quote character\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u      *line = get_cursor_line_ptr();\n  int col_end;\n  int col_start = curwin->w_cursor.col;\n  bool inclusive = false;\n  bool vis_empty = true;                // Visual selection <= 1 char\n  bool vis_bef_curs = false;            // Visual starts before cursor\n  bool did_exclusive_adj = false;       // adjusted pos for 'selection'\n  bool inside_quotes = false;           // Looks like \"i'\" done before\n  bool selected_quote = false;          // Has quote inside selection\n  int i;\n  bool restore_vis_bef = false;         // resotre VIsual on abort\n\n  // When 'selection' is \"exclusive\" move the cursor to where it would be\n  // with 'selection' \"inclusive\", so that the logic is the same for both.\n  // The cursor then is moved forward after adjusting the area.\n  if (VIsual_active) {\n    // this only works within one line\n    if (VIsual.lnum != curwin->w_cursor.lnum) {\n        return false;\n    }\n\n    vis_bef_curs = lt(VIsual, curwin->w_cursor);\n    vis_empty = equalpos(VIsual, curwin->w_cursor);\n    if (*p_sel == 'e') {\n      if (vis_bef_curs) {\n        dec_cursor();\n        did_exclusive_adj = true;\n      } else if (!vis_empty) {\n        dec(&VIsual);\n        did_exclusive_adj = true;\n      }\n      vis_empty = equalpos(VIsual, curwin->w_cursor);\n      if (!vis_bef_curs && !vis_empty) {\n        // VIsual needs to be start of Visual selection.\n        pos_T t = curwin->w_cursor;\n\n        curwin->w_cursor = VIsual;\n        VIsual = t;\n        vis_bef_curs = true;\n        restore_vis_bef = true;\n      }\n    }\n  }\n\n  if (!vis_empty) {\n    /* Check if the existing selection exactly spans the text inside\n     * quotes. */\n    if (vis_bef_curs) {\n      inside_quotes = VIsual.col > 0\n                      && line[VIsual.col - 1] == quotechar\n                      && line[curwin->w_cursor.col] != NUL\n                      && line[curwin->w_cursor.col + 1] == quotechar;\n      i = VIsual.col;\n      col_end = curwin->w_cursor.col;\n    } else {\n      inside_quotes = curwin->w_cursor.col > 0\n                      && line[curwin->w_cursor.col - 1] == quotechar\n                      && line[VIsual.col] != NUL\n                      && line[VIsual.col + 1] == quotechar;\n      i = curwin->w_cursor.col;\n      col_end = VIsual.col;\n    }\n\n    /* Find out if we have a quote in the selection. */\n    while (i <= col_end)\n      if (line[i++] == quotechar) {\n        selected_quote = true;\n        break;\n      }\n  }\n\n  if (!vis_empty && line[col_start] == quotechar) {\n    /* Already selecting something and on a quote character.  Find the\n     * next quoted string. */\n    if (vis_bef_curs) {\n      /* Assume we are on a closing quote: move to after the next\n       * opening quote. */\n      col_start = find_next_quote(line, col_start + 1, quotechar, NULL);\n      if (col_start < 0) {\n        goto abort_search;\n      }\n      col_end = find_next_quote(line, col_start + 1, quotechar,\n          curbuf->b_p_qe);\n      if (col_end < 0) {\n        /* We were on a starting quote perhaps? */\n        col_end = col_start;\n        col_start = curwin->w_cursor.col;\n      }\n    } else {\n      col_end = find_prev_quote(line, col_start, quotechar, NULL);\n      if (line[col_end] != quotechar) {\n        goto abort_search;\n      }\n      col_start = find_prev_quote(line, col_end, quotechar,\n          curbuf->b_p_qe);\n      if (line[col_start] != quotechar) {\n        /* We were on an ending quote perhaps? */\n        col_start = col_end;\n        col_end = curwin->w_cursor.col;\n      }\n    }\n  } else if (line[col_start] == quotechar\n             || !vis_empty\n             ) {\n    int first_col = col_start;\n\n    if (!vis_empty) {\n      if (vis_bef_curs)\n        first_col = find_next_quote(line, col_start, quotechar, NULL);\n      else\n        first_col = find_prev_quote(line, col_start, quotechar, NULL);\n    }\n    /* The cursor is on a quote, we don't know if it's the opening or\n     * closing quote.  Search from the start of the line to find out.\n     * Also do this when there is a Visual area, a' may leave the cursor\n     * in between two strings. */\n    col_start = 0;\n    for (;; ) {\n      /* Find open quote character. */\n      col_start = find_next_quote(line, col_start, quotechar, NULL);\n      if (col_start < 0 || col_start > first_col) {\n        goto abort_search;\n      }\n      // Find close quote character.\n      col_end = find_next_quote(line, col_start + 1, quotechar,\n          curbuf->b_p_qe);\n      if (col_end < 0) {\n        goto abort_search;\n      }\n      // If is cursor between start and end quote character, it is\n      // target text object.\n      if (col_start <= first_col && first_col <= col_end) {\n        break;\n      }\n      col_start = col_end + 1;\n    }\n  } else {\n    /* Search backward for a starting quote. */\n    col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);\n    if (line[col_start] != quotechar) {\n      /* No quote before the cursor, look after the cursor. */\n      col_start = find_next_quote(line, col_start, quotechar, NULL);\n      if (col_start < 0) {\n        goto abort_search;\n      }\n    }\n\n    /* Find close quote character. */\n    col_end = find_next_quote(line, col_start + 1, quotechar,\n                              curbuf->b_p_qe);\n    if (col_end < 0) {\n      goto abort_search;\n    }\n  }\n\n  // When \"include\" is true, include spaces after closing quote or before\n  // the starting quote.\n  if (include) {\n    if (ascii_iswhite(line[col_end + 1]))\n      while (ascii_iswhite(line[col_end + 1]))\n        ++col_end;\n    else\n      while (col_start > 0 && ascii_iswhite(line[col_start - 1]))\n        --col_start;\n  }\n\n  /* Set start position.  After vi\" another i\" must include the \".\n   * For v2i\" include the quotes. */\n  if (!include && count < 2\n      && (vis_empty || !inside_quotes)\n      )\n    ++col_start;\n  curwin->w_cursor.col = col_start;\n  if (VIsual_active) {\n    /* Set the start of the Visual area when the Visual area was empty, we\n     * were just inside quotes or the Visual area didn't start at a quote\n     * and didn't include a quote.\n     */\n    if (vis_empty\n        || (vis_bef_curs\n            && !selected_quote\n            && (inside_quotes\n                || (line[VIsual.col] != quotechar\n                    && (VIsual.col == 0\n                        || line[VIsual.col - 1] != quotechar))))) {\n      VIsual = curwin->w_cursor;\n      redraw_curbuf_later(INVERTED);\n    }\n  } else {\n    oap->start = curwin->w_cursor;\n    oap->motion_type = kMTCharWise;\n  }\n\n  /* Set end position. */\n  curwin->w_cursor.col = col_end;\n  if ((include || count > 1\n       /* After vi\" another i\" must include the \". */\n       || (!vis_empty && inside_quotes)\n       ) && inc_cursor() == 2)\n    inclusive = true;\n  if (VIsual_active) {\n    if (vis_empty || vis_bef_curs) {\n      // decrement cursor when 'selection' is not exclusive\n      if (*p_sel != 'e') {\n        dec_cursor();\n      }\n    } else {\n      /* Cursor is at start of Visual area.  Set the end of the Visual\n       * area when it was just inside quotes or it didn't end at a\n       * quote. */\n      if (inside_quotes\n          || (!selected_quote\n              && line[VIsual.col] != quotechar\n              && (line[VIsual.col] == NUL\n                  || line[VIsual.col + 1] != quotechar))) {\n        dec_cursor();\n        VIsual = curwin->w_cursor;\n      }\n      curwin->w_cursor.col = col_start;\n    }\n    if (VIsual_mode == 'V') {\n      VIsual_mode = 'v';\n      redraw_cmdline = true;                    // show mode later\n    }\n  } else {\n    /* Set inclusive and other oap's flags. */\n    oap->inclusive = inclusive;\n  }\n\n  return true;\n\nabort_search:\n  if (VIsual_active && *p_sel == 'e') {\n    if (did_exclusive_adj) {\n      inc_cursor();\n    }\n    if (restore_vis_bef) {\n       pos_T t = curwin->w_cursor;\n\n       curwin->w_cursor = VIsual;\n       VIsual = t;\n    }\n  }\n  return false;\n}\n\n\n\n/*\n * Find next search match under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\nint\ncurrent_search(\n    long count,\n    bool forward  // true for forward, false for backward\n)\n{\n  bool old_p_ws = p_ws;\n  pos_T save_VIsual = VIsual;\n\n  /* Correct cursor when 'selection' is exclusive */\n  if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))\n    dec_cursor();\n\n  pos_T end_pos;                // end position of the pattern match\n  pos_T orig_pos;               // position of the cursor at beginning\n  pos_T pos;                    // position after the pattern\n  int result;                   // result of various function calls\n\n  // When searching forward and the cursor is at the start of the Visual\n  // area, skip the first search backward, otherwise it doesn't move.\n  const bool skip_first_backward = forward && VIsual_active\n    && lt(curwin->w_cursor, VIsual);\n\n  orig_pos = pos = curwin->w_cursor;\n  if (VIsual_active) {\n    // Searching further will extend the match.\n    if (forward) {\n      incl(&pos);\n    } else {\n      decl(&pos);\n    }\n  }\n\n  // Is the pattern is zero-width?, this time, don't care about the direction\n  int zero_width = is_zero_width(spats[last_idx].pat, true, &curwin->w_cursor,\n                                 FORWARD);\n  if (zero_width == -1) {\n    return FAIL;  // pattern not found\n  }\n\n  // The trick is to first search backwards and then search forward again,\n  // so that a match at the current cursor position will be correctly\n  // captured.  When \"forward\" is false do it the other way around.\n  for (int i = 0; i < 2; i++) {\n    int dir;\n    if (forward) {\n      if (i == 0 && skip_first_backward) {\n        continue;\n      }\n      dir = i;\n    } else {\n      dir = !i;\n    }\n\n    int flags = 0;\n\n    if (!dir && !zero_width) {\n      flags = SEARCH_END;\n    }\n    end_pos = pos;\n\n    // wrapping should not occur in the first round\n    if (i == 0) {\n      p_ws = false;\n    }\n\n    result = searchit(curwin, curbuf, &pos, &end_pos,\n                      (dir ? FORWARD : BACKWARD),\n                      spats[last_idx].pat, i ? count : 1,\n                      SEARCH_KEEP | flags, RE_SEARCH, NULL);\n\n    p_ws = old_p_ws;\n\n    // First search may fail, but then start searching from the\n    // beginning of the file (cursor might be on the search match)\n    // except when Visual mode is active, so that extending the visual\n    // selection works.\n    if (i == 1 && !result) {  // not found, abort */\n      curwin->w_cursor = orig_pos;\n      if (VIsual_active)\n        VIsual = save_VIsual;\n      return FAIL;\n    } else if (i == 0 && !result) {\n      if (forward) {  // try again from start of buffer\n        clearpos(&pos);\n      } else {  // try again from end of buffer\n                // searching backwards, so set pos to last line and col\n        pos.lnum = curwin->w_buffer->b_ml.ml_line_count;\n        pos.col  = (colnr_T)STRLEN(\n            ml_get(curwin->w_buffer->b_ml.ml_line_count));\n      }\n    }\n  }\n\n  pos_T start_pos = pos;\n\n  if (!VIsual_active) {\n    VIsual = start_pos;\n  }\n\n  // put the cursor after the match\n  curwin->w_cursor = end_pos;\n  if (lt(VIsual, end_pos) && forward) {\n    if (skip_first_backward) {\n      // put the cursor on the start of the match\n      curwin->w_cursor = pos;\n    } else {\n      // put the cursor on last character of match\n      dec_cursor();\n    }\n  } else if (VIsual_active && lt(curwin->w_cursor, VIsual) && forward) {\n    curwin->w_cursor = pos;   // put the cursor on the start of the match\n  }\n  VIsual_active = true;\n  VIsual_mode = 'v';\n\n  if (*p_sel == 'e') {\n    // Correction for exclusive selection depends on the direction.\n    if (forward && ltoreq(VIsual, curwin->w_cursor)) {\n      inc_cursor();\n    } else if (!forward && ltoreq(curwin->w_cursor, VIsual)) {\n      inc(&VIsual);\n    }\n  }\n\n  if (fdo_flags & FDO_SEARCH && KeyTyped) {\n    foldOpenCursor();\n  }\n\n  may_start_select('c');\n  setmouse();\n  redraw_curbuf_later(INVERTED);\n  showmode();\n\n  return OK;\n}\n\n/// Check if the pattern is zero-width.\n/// If move is true, check from the beginning of the buffer,\n/// else from position \"cur\".\n/// \"direction\" is FORWARD or BACKWARD.\n/// Returns TRUE, FALSE or -1 for failure.\nstatic int\nis_zero_width(char_u *pattern, int move, pos_T *cur, Direction direction)\n{\n  regmmatch_T regmatch;\n  int nmatched = 0;\n  int result = -1;\n  pos_T pos;\n  int save_called_emsg = called_emsg;\n  int flag = 0;\n\n  if (pattern == NULL) {\n    pattern = spats[last_idx].pat;\n  }\n\n  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,\n          SEARCH_KEEP, &regmatch) == FAIL)\n    return -1;\n\n  // init startcol correctly\n  regmatch.startpos[0].col = -1;\n  // move to match\n  if (move) {\n    clearpos(&pos);\n  } else {\n    pos = *cur;\n    // accept a match at the cursor position\n    flag = SEARCH_START;\n  }\n  if (searchit(curwin, curbuf, &pos, NULL, direction, pattern, 1,\n               SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL) {\n    // Zero-width pattern should match somewhere, then we can check if\n    // start and end are in the same position.\n    called_emsg = false;\n    do {\n      regmatch.startpos[0].col++;\n      nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,\n                                   pos.lnum, regmatch.startpos[0].col,\n                                   NULL, NULL);\n      if (nmatched != 0) {\n        break;\n      }\n    } while (regmatch.regprog != NULL\n             && direction == FORWARD\n             ? regmatch.startpos[0].col < pos.col\n             : regmatch.startpos[0].col > pos.col);\n\n    if (!called_emsg) {\n      result = (nmatched != 0\n                && regmatch.startpos[0].lnum == regmatch.endpos[0].lnum\n                && regmatch.startpos[0].col == regmatch.endpos[0].col);\n    }\n  }\n\n  called_emsg |= save_called_emsg;\n  vim_regfree(regmatch.regprog);\n  return result;\n}\n\n/*\n * return TRUE if line 'lnum' is empty or has white chars only.\n */\nint linewhite(linenr_T lnum)\n{\n  char_u  *p;\n\n  p = skipwhite(ml_get(lnum));\n  return *p == NUL;\n}\n\n// Add the search count \"[3/19]\" to \"msgbuf\".\n// See update_search_stat() for other arguments.\nstatic void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos,\n                                bool show_top_bot_msg, char_u  *msgbuf,\n                                bool recompute, int maxcount, long timeout)\n{\n    searchstat_T stat;\n\n    update_search_stat(dirc, pos, cursor_pos, &stat, recompute, maxcount,\n                       timeout);\n    if (stat.cur > 0) {\n      char  t[SEARCH_STAT_BUF_LEN];\n\n      if (curwin->w_p_rl && *curwin->w_p_rlc == 's') {\n        if (stat.incomplete == 1) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n        } else if (stat.cnt > maxcount && stat.cur > maxcount) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n                       maxcount, maxcount);\n        } else if (stat.cnt > maxcount) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/%d]\",\n                       maxcount, stat.cur);\n        } else {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n                       stat.cnt, stat.cur);\n        }\n      } else {\n        if (stat.incomplete == 1) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n        } else if (stat.cnt > maxcount && stat.cur > maxcount) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n                       maxcount, maxcount);\n        } else if (stat.cnt > maxcount) {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/>%d]\",\n                       stat.cur, maxcount);\n        } else {\n          vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n                       stat.cur, stat.cnt);\n        }\n      }\n\n      size_t len = strlen(t);\n      if (show_top_bot_msg && len + 2 < SEARCH_STAT_BUF_LEN) {\n        memmove(t + 2, t, len);\n        t[0] = 'W';\n        t[1] = ' ';\n        len += 2;\n      }\n\n      memmove(msgbuf + STRLEN(msgbuf) - len, t, len);\n      if (dirc == '?' && stat.cur == maxcount + 1) {\n        stat.cur = -1;\n      }\n\n      // keep the message even after redraw, but don't put in history\n      msg_hist_off = true;\n      msg_ext_set_kind(\"search_count\");\n      give_warning(msgbuf, false);\n      msg_hist_off = false;\n    }\n}\n\n// Add the search count information to \"stat\".\n// \"stat\" must not be NULL.\n// When \"recompute\" is true always recompute the numbers.\n// dirc == 0: don't find the next/previous match (only set the result to \"stat\")\n// dirc == '/': find the next match\n// dirc == '?': find the previous match\nstatic void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos,\n                               searchstat_T *stat, bool recompute, int maxcount,\n                               long timeout)\n{\n    int             save_ws = p_ws;\n    bool             wraparound = false;\n    pos_T           p = (*pos);\n    static pos_T    lastpos = { 0, 0, 0 };\n    static int      cur = 0;\n    static int      cnt = 0;\n    static bool      exact_match = false;\n    static int      incomplete = 0;\n    static int      last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int      chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n    proftime_T      start;\n\n    memset(stat, 0, sizeof(searchstat_T));\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos)) {\n      stat->cur = cur;\n      stat->cnt = cnt;\n      stat->exact_match = exact_match;\n      stat->incomplete = incomplete;\n      stat->last_maxcount = last_maxcount;\n      return;\n    }\n    last_maxcount = maxcount;\n    wraparound = ((dirc == '?' && lt(lastpos, p))\n                  || (dirc == '/' && lt(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == buf_get_changedtick(curbuf)\n          && lastpat != NULL  // suppress clang/NULL passed as nonnull parameter\n          && STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n          && STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n          && equalpos(lastpos, *cursor_pos)\n          && lbuf == curbuf)\n        || wraparound || cur < 0 || (maxcount > 0 && cur > maxcount)\n        || recompute) {\n      cur = 0;\n      cnt = 0;\n      exact_match = false;\n      incomplete = 0;\n      clearpos(&lastpos);\n      lbuf = curbuf;\n    }\n\n    if (equalpos(lastpos, *cursor_pos) && !wraparound\n        && (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0)) {\n      cur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    } else {\n      bool done_search = false;\n      pos_T endpos = { 0, 0, 0 };\n      p_ws = false;\n      if (timeout > 0) {\n        start  = profile_setlimit(timeout);\n      }\n      while (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n                                  FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST,\n                                  NULL) != FAIL) {\n        done_search = true;\n        // Stop after passing the time limit.\n        if (timeout > 0 && profile_passed_limit(start)) {\n          incomplete = 1;\n          break;\n        }\n        cnt++;\n        if (ltoreq(lastpos, p)) {\n          cur = cnt;\n          if (lt(p, endpos)) {\n            exact_match = true;\n          }\n        }\n        fast_breakcheck();\n        if (maxcount > 0 && cnt > maxcount) {\n          incomplete = 2;    // max count exceeded\n          break;\n        }\n      }\n      if (got_int) {\n        cur = -1;  // abort\n      }\n      if (done_search) {\n        xfree(lastpat);\n        lastpat = vim_strsave(spats[last_idx].pat);\n        chgtick = buf_get_changedtick(curbuf);\n        lbuf = curbuf;\n        lastpos = p;\n      }\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n\n// \"searchcount()\" function\nvoid f_searchcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)\n{\n    pos_T   pos = curwin->w_cursor;\n    char_u    *pattern = NULL;\n    int     maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    long    timeout = SEARCH_STAT_DEF_TIMEOUT;\n    bool     recompute = true;\n    searchstat_T  stat;\n\n    tv_dict_alloc_ret(rettv);\n\n    if (shortmess(SHM_SEARCHCOUNT)) {  // 'shortmess' contains 'S' flag\n      recompute = true;\n    }\n\n    if (argvars[0].v_type != VAR_UNKNOWN) {\n      dict_T    *dict;\n      dictitem_T  *di;\n      listitem_T  *li;\n      bool error = false;\n\n      if (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL) {\n        EMSG(_(e_dictreq));\n        return;\n      }\n      dict = argvars[0].vval.v_dict;\n      di = tv_dict_find(dict, (const char *)\"timeout\", -1);\n      if (di != NULL) {\n        timeout = (long)tv_get_number_chk(&di->di_tv, &error);\n        if (error) {\n          return;\n        }\n      }\n      di = tv_dict_find(dict, (const char *)\"maxcount\", -1);\n      if (di != NULL) {\n        maxcount = (int)tv_get_number_chk(&di->di_tv, &error);\n        if (error) {\n          return;\n        }\n      }\n      di = tv_dict_find(dict, (const char *)\"recompute\", -1);\n      if (di != NULL) {\n        recompute = tv_get_number_chk(&di->di_tv, &error);\n        if (error) {\n          return;\n        }\n      }\n      di = tv_dict_find(dict, (const char *)\"pattern\", -1);\n      if (di != NULL) {\n        pattern = (char_u *)tv_get_string_chk(&di->di_tv);\n        if (pattern == NULL) {\n          return;\n        }\n      }\n      di = tv_dict_find(dict, (const char *)\"pos\", -1);\n      if (di != NULL) {\n        if (di->di_tv.v_type != VAR_LIST) {\n          EMSG2(_(e_invarg2), \"pos\");\n          return;\n        }\n        if (tv_list_len(di->di_tv.vval.v_list) != 3) {\n          EMSG2(_(e_invarg2), \"List format should be [lnum, col, off]\");\n          return;\n        }\n        li = tv_list_find(di->di_tv.vval.v_list, 0L);\n        if (li != NULL) {\n          pos.lnum = tv_get_number_chk(TV_LIST_ITEM_TV(li), &error);\n          if (error) {\n            return;\n          }\n        }\n        li = tv_list_find(di->di_tv.vval.v_list, 1L);\n        if (li != NULL) {\n          pos.col = tv_get_number_chk(TV_LIST_ITEM_TV(li), &error) - 1;\n          if (error) {\n            return;\n          }\n        }\n        li = tv_list_find(di->di_tv.vval.v_list, 2L);\n        if (li != NULL) {\n          pos.coladd = tv_get_number_chk(TV_LIST_ITEM_TV(li), &error);\n          if (error) {\n            return;\n          }\n        }\n      }\n    }\n\n    save_last_search_pattern();\n    if (pattern != NULL) {\n      if (*pattern == NUL) {\n        goto the_end;\n      }\n      xfree(spats[last_idx].pat);\n      spats[last_idx].pat = vim_strsave(pattern);\n    }\n    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL) {\n      goto the_end;  // the previous pattern was never defined\n    }\n\n    update_search_stat(0, &pos, &pos, &stat, recompute, maxcount, timeout);\n\n    tv_dict_add_nr(rettv->vval.v_dict, S_LEN(\"current\"), stat.cur);\n    tv_dict_add_nr(rettv->vval.v_dict, S_LEN(\"total\"), stat.cnt);\n    tv_dict_add_nr(rettv->vval.v_dict, S_LEN(\"exact_match\"), stat.exact_match);\n    tv_dict_add_nr(rettv->vval.v_dict, S_LEN(\"incomplete\"), stat.incomplete);\n    tv_dict_add_nr(rettv->vval.v_dict, S_LEN(\"maxcount\"), stat.last_maxcount);\n\nthe_end:\n    restore_last_search_pattern();\n}\n\n/*\n * Find identifiers or defines in included files.\n * If p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.\n */\nvoid\nfind_pattern_in_path(\n    char_u *ptr,            // pointer to search pattern\n    Direction dir,          // direction of expansion\n    size_t len,             // length of search pattern\n    bool whole,             // match whole words only\n    bool skip_comments,     // don't match inside comments\n    int type,               // Type of search; are we looking for a type?\n                            // a macro?\n    long count,\n    int action,             // What to do when we find it\n    linenr_T start_lnum,    // first line to start searching\n    linenr_T end_lnum       // last line for searching\n)\n{\n  SearchedFile *files;                  /* Stack of included files */\n  SearchedFile *bigger;                 /* When we need more space */\n  int max_path_depth = 50;\n  long match_count = 1;\n\n  char_u      *pat;\n  char_u      *new_fname;\n  char_u      *curr_fname = curbuf->b_fname;\n  char_u      *prev_fname = NULL;\n  linenr_T lnum;\n  int depth;\n  int depth_displayed;                  /* For type==CHECK_PATH */\n  int old_files;\n  int already_searched;\n  char_u      *file_line;\n  char_u      *line;\n  char_u      *p;\n  char_u save_char;\n  bool define_matched;\n  regmatch_T regmatch;\n  regmatch_T incl_regmatch;\n  regmatch_T def_regmatch;\n  bool matched = false;\n  bool did_show = false;\n  bool found = false;\n  int i;\n  char_u      *already = NULL;\n  char_u      *startp = NULL;\n  char_u      *inc_opt = NULL;\n  win_T       *curwin_save = NULL;\n  const int l_g_do_tagpreview = g_do_tagpreview;\n\n  regmatch.regprog = NULL;\n  incl_regmatch.regprog = NULL;\n  def_regmatch.regprog = NULL;\n\n  file_line = xmalloc(LSIZE);\n\n  if (type != CHECK_PATH && type != FIND_DEFINE\n      /* when CONT_SOL is set compare \"ptr\" with the beginning of the line\n       * is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo */\n      && !(compl_cont_status & CONT_SOL)\n      ) {\n    pat = xmalloc(len + 5);\n    assert(len <= INT_MAX);\n    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);\n    /* ignore case according to p_ic, p_scs and pat */\n    regmatch.rm_ic = ignorecase(pat);\n    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);\n    xfree(pat);\n    if (regmatch.regprog == NULL)\n      goto fpip_end;\n  }\n  inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n  if (*inc_opt != NUL) {\n    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);\n    if (incl_regmatch.regprog == NULL)\n      goto fpip_end;\n    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */\n  }\n  if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL)) {\n    def_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n        ? p_def : curbuf->b_p_def, p_magic ? RE_MAGIC : 0);\n    if (def_regmatch.regprog == NULL)\n      goto fpip_end;\n    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */\n  }\n  files = xcalloc(max_path_depth, sizeof(SearchedFile));\n  old_files = max_path_depth;\n  depth = depth_displayed = -1;\n\n  lnum = start_lnum;\n  if (end_lnum > curbuf->b_ml.ml_line_count)\n    end_lnum = curbuf->b_ml.ml_line_count;\n  if (lnum > end_lnum)                  /* do at least one line */\n    lnum = end_lnum;\n  line = ml_get(lnum);\n\n  for (;; ) {\n    if (incl_regmatch.regprog != NULL\n        && vim_regexec(&incl_regmatch, line, (colnr_T)0)) {\n      char_u *p_fname = (curr_fname == curbuf->b_fname)\n                        ? curbuf->b_ffname : curr_fname;\n\n      if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n        /* Use text from '\\zs' to '\\ze' (or end) of 'include'. */\n        new_fname = find_file_name_in_path(incl_regmatch.startp[0],\n                                           (size_t)(incl_regmatch.endp[0]\n                                                    - incl_regmatch.startp[0]),\n                                           FNAME_EXP|FNAME_INCL|FNAME_REL,\n                                           1L, p_fname);\n      else\n        /* Use text after match with 'include'. */\n        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n      already_searched = FALSE;\n      if (new_fname != NULL) {\n        // Check whether we have already searched in this file\n        for (i = 0;; i++) {\n          if (i == depth + 1) {\n            i = old_files;\n          }\n          if (i == max_path_depth) {\n            break;\n          }\n          if (path_full_compare(new_fname, files[i].name,\n                                true, true) & kEqualFiles) {\n            if (type != CHECK_PATH\n                && action == ACTION_SHOW_ALL && files[i].matched) {\n              msg_putchar('\\n');  // cursor below last one */\n              if (!got_int) {  // don't display if 'q' typed at \"--more--\"\n                               // message\n                msg_home_replace_hl(new_fname);\n                MSG_PUTS(_(\" (includes previously listed match)\"));\n                prev_fname = NULL;\n              }\n            }\n            XFREE_CLEAR(new_fname);\n            already_searched = true;\n            break;\n          }\n        }\n      }\n\n      if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n                                 || (new_fname == NULL && !already_searched))) {\n        if (did_show) {\n          msg_putchar('\\n');  // cursor below last one\n        } else {\n          gotocmdline(true);  // cursor at status line\n          MSG_PUTS_TITLE(_(\"--- Included files \"));\n          if (action != ACTION_SHOW_ALL) {\n            MSG_PUTS_TITLE(_(\"not found \"));\n          }\n          MSG_PUTS_TITLE(_(\"in path ---\\n\"));\n        }\n        did_show = true;\n        while (depth_displayed < depth && !got_int) {\n          ++depth_displayed;\n          for (i = 0; i < depth_displayed; i++)\n            MSG_PUTS(\"  \");\n          msg_home_replace(files[depth_displayed].name);\n          MSG_PUTS(\" -->\\n\");\n        }\n        if (!got_int) {                     /* don't display if 'q' typed\n                                               for \"--more--\" message */\n          for (i = 0; i <= depth_displayed; i++)\n            MSG_PUTS(\"  \");\n          if (new_fname != NULL) {\n            /* using \"new_fname\" is more reliable, e.g., when\n             * 'includeexpr' is set. */\n            msg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n          } else {\n            /*\n             * Isolate the file name.\n             * Include the surrounding \"\" or <> if present.\n             */\n            if (inc_opt != NULL\n                && strstr((char *)inc_opt, \"\\\\zs\") != NULL) {\n              /* pattern contains \\zs, use the match */\n              p = incl_regmatch.startp[0];\n              i = (int)(incl_regmatch.endp[0]\n                        - incl_regmatch.startp[0]);\n            } else {\n              /* find the file name after the end of the match */\n              for (p = incl_regmatch.endp[0];\n                   *p && !vim_isfilec(*p); p++)\n                ;\n              for (i = 0; vim_isfilec(p[i]); i++)\n                ;\n            }\n\n            if (i == 0) {\n              /* Nothing found, use the rest of the line. */\n              p = incl_regmatch.endp[0];\n              i = (int)STRLEN(p);\n            }\n            /* Avoid checking before the start of the line, can\n             * happen if \\zs appears in the regexp. */\n            else if (p > line) {\n              if (p[-1] == '\"' || p[-1] == '<') {\n                --p;\n                ++i;\n              }\n              if (p[i] == '\"' || p[i] == '>')\n                ++i;\n            }\n            save_char = p[i];\n            p[i] = NUL;\n            msg_outtrans_attr(p, HL_ATTR(HLF_D));\n            p[i] = save_char;\n          }\n\n          if (new_fname == NULL && action == ACTION_SHOW_ALL) {\n            if (already_searched)\n              MSG_PUTS(_(\"  (Already listed)\"));\n            else\n              MSG_PUTS(_(\"  NOT FOUND\"));\n          }\n        }\n        ui_flush();                /* output each line directly */\n      }\n\n      if (new_fname != NULL) {\n        /* Push the new file onto the file stack */\n        if (depth + 1 == old_files) {\n          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));\n          for (i = 0; i <= depth; i++)\n            bigger[i] = files[i];\n          for (i = depth + 1; i < old_files + max_path_depth; i++) {\n            bigger[i].fp = NULL;\n            bigger[i].name = NULL;\n            bigger[i].lnum = 0;\n            bigger[i].matched = FALSE;\n          }\n          for (i = old_files; i < max_path_depth; i++)\n            bigger[i + max_path_depth] = files[i];\n          old_files += max_path_depth;\n          max_path_depth *= 2;\n          xfree(files);\n          files = bigger;\n        }\n        if ((files[depth + 1].fp = os_fopen((char *)new_fname, \"r\")) == NULL) {\n          xfree(new_fname);\n        } else {\n          if (++depth == old_files) {\n            // Something wrong. We will forget one of our already visited files\n            // now.\n            xfree(files[old_files].name);\n            ++old_files;\n          }\n          files[depth].name = curr_fname = new_fname;\n          files[depth].lnum = 0;\n          files[depth].matched = FALSE;\n          if (action == ACTION_EXPAND) {\n            msg_hist_off = true;                // reset in msg_trunc_attr()\n            vim_snprintf((char *)IObuff, IOSIZE,\n                         _(\"Scanning included file: %s\"),\n                         (char *)new_fname);\n            msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));\n          } else if (p_verbose >= 5) {\n            verbose_enter();\n            smsg(_(\"Searching included file %s\"),\n                (char *)new_fname);\n            verbose_leave();\n          }\n\n        }\n      }\n    } else {\n      /*\n       * Check if the line is a define (type == FIND_DEFINE)\n       */\n      p = line;\nsearch_line:\n      define_matched = false;\n      if (def_regmatch.regprog != NULL\n          && vim_regexec(&def_regmatch, line, (colnr_T)0)) {\n        /*\n         * Pattern must be first identifier after 'define', so skip\n         * to that position before checking for match of pattern.  Also\n         * don't let it match beyond the end of this identifier.\n         */\n        p = def_regmatch.endp[0];\n        while (*p && !vim_iswordc(*p))\n          p++;\n        define_matched = true;\n      }\n\n      /*\n       * Look for a match.  Don't do this if we are looking for a\n       * define and this line didn't match define_prog above.\n       */\n      if (def_regmatch.regprog == NULL || define_matched) {\n        if (define_matched\n            || (compl_cont_status & CONT_SOL)\n            ) {\n          /* compare the first \"len\" chars from \"ptr\" */\n          startp = skipwhite(p);\n          if (p_ic) {\n            matched = !mb_strnicmp(startp, ptr, len);\n          }\n          else\n            matched = !STRNCMP(startp, ptr, len);\n          if (matched && define_matched && whole\n              && vim_iswordc(startp[len]))\n            matched = false;\n        } else if (regmatch.regprog != NULL\n                   && vim_regexec(&regmatch, line, (colnr_T)(p - line))) {\n          matched = true;\n          startp = regmatch.startp[0];\n          // Check if the line is not a comment line (unless we are\n          // looking for a define).  A line starting with \"# define\"\n          // is not considered to be a comment line.\n          if (skip_comments) {\n            if ((*line != '#'\n                 || STRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n                && get_leader_len(line, NULL, false, true)) {\n              matched = false;\n            }\n\n            /*\n             * Also check for a \"/ *\" or \"/ /\" before the match.\n             * Skips lines like \"int backwards;  / * normal index\n             * * /\" when looking for \"normal\".\n             * Note: Doesn't skip \"/ *\" in comments.\n             */\n            p = skipwhite(line);\n            if (matched\n                || (p[0] == '/' && p[1] == '*') || p[0] == '*')\n              for (p = line; *p && p < startp; ++p) {\n                if (matched\n                    && p[0] == '/'\n                    && (p[1] == '*' || p[1] == '/')) {\n                  matched = false;\n                  // After \"//\" all text is comment\n                  if (p[1] == '/') {\n                    break;\n                  }\n                  p++;\n                } else if (!matched && p[0] == '*' && p[1] == '/') {\n                  // Can find match after \"* /\".\n                  matched = true;\n                  p++;\n                }\n              }\n          }\n        }\n      }\n    }\n    if (matched) {\n      if (action == ACTION_EXPAND) {\n        bool cont_s_ipos = false;\n        char_u  *aux;\n\n        if (depth == -1 && lnum == curwin->w_cursor.lnum)\n          break;\n        found = true;\n        aux = p = startp;\n        if (compl_cont_status & CONT_ADDING) {\n          p += compl_length;\n          if (vim_iswordp(p))\n            goto exit_matched;\n          p = find_word_start(p);\n        }\n        p = find_word_end(p);\n        i = (int)(p - aux);\n\n        if ((compl_cont_status & CONT_ADDING) && i == compl_length) {\n          /* IOSIZE > compl_length, so the STRNCPY works */\n          STRNCPY(IObuff, aux, i);\n\n          /* Get the next line: when \"depth\" < 0  from the current\n           * buffer, otherwise from the included file.  Jump to\n           * exit_matched when past the last line. */\n          if (depth < 0) {\n            if (lnum >= end_lnum)\n              goto exit_matched;\n            line = ml_get(++lnum);\n          } else if (vim_fgets(line = file_line,\n                         LSIZE, files[depth].fp))\n            goto exit_matched;\n\n          /* we read a line, set \"already\" to check this \"line\" later\n           * if depth >= 0 we'll increase files[depth].lnum far\n           * bellow  -- Acevedo */\n          already = aux = p = skipwhite(line);\n          p = find_word_start(p);\n          p = find_word_end(p);\n          if (p > aux) {\n            if (*aux != ')' && IObuff[i-1] != TAB) {\n              if (IObuff[i-1] != ' ')\n                IObuff[i++] = ' ';\n              /* IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2*/\n              if (p_js\n                  && (IObuff[i-2] == '.'\n                      || IObuff[i-2] == '?'\n                      || IObuff[i-2] == '!')) {\n                IObuff[i++] = ' ';\n              }\n            }\n            /* copy as much as possible of the new word */\n            if (p - aux >= IOSIZE - i)\n              p = aux + IOSIZE - i - 1;\n            STRNCPY(IObuff + i, aux, p - aux);\n            i += (int)(p - aux);\n            cont_s_ipos = true;\n          }\n          IObuff[i] = NUL;\n          aux = IObuff;\n\n          if (i == compl_length)\n            goto exit_matched;\n        }\n\n        const int add_r = ins_compl_add_infercase(\n            aux, i, p_ic, curr_fname == curbuf->b_fname ? NULL : curr_fname,\n            dir, cont_s_ipos);\n        if (add_r == OK) {\n          // if dir was BACKWARD then honor it just once\n          dir = FORWARD;\n        } else if (add_r == FAIL) {\n          break;\n        }\n      } else if (action == ACTION_SHOW_ALL) {\n        found = true;\n        if (!did_show) {\n          gotocmdline(true);                    // cursor at status line\n        }\n        if (curr_fname != prev_fname) {\n          if (did_show)\n            msg_putchar('\\n');                  /* cursor below last one */\n          if (!got_int)                         /* don't display if 'q' typed\n                                                    at \"--more--\" message */\n            msg_home_replace_hl(curr_fname);\n          prev_fname = curr_fname;\n        }\n        did_show = true;\n        if (!got_int) {\n          show_pat_in_path(line, type, true, action,\n                           (depth == -1) ? NULL : files[depth].fp,\n                           (depth == -1) ? &lnum : &files[depth].lnum,\n                           match_count++);\n        }\n\n        /* Set matched flag for this file and all the ones that\n         * include it */\n        for (i = 0; i <= depth; ++i)\n          files[i].matched = TRUE;\n      } else if (--count <= 0) {\n        found = true;\n        if (depth == -1 && lnum == curwin->w_cursor.lnum\n            && l_g_do_tagpreview == 0) {\n          EMSG(_(\"E387: Match is on current line\"));\n        } else if (action == ACTION_SHOW) {\n          show_pat_in_path(line, type, did_show, action,\n                           (depth == -1) ? NULL : files[depth].fp,\n                           (depth == -1) ? &lnum : &files[depth].lnum, 1L);\n          did_show = true;\n        } else {\n          /* \":psearch\" uses the preview window */\n          if (l_g_do_tagpreview != 0) {\n            curwin_save = curwin;\n            prepare_tagpreview(true);\n          }\n          if (action == ACTION_SPLIT) {\n            if (win_split(0, 0) == FAIL)\n              break;\n            RESET_BINDING(curwin);\n          }\n          if (depth == -1) {\n            // match in current file\n            if (l_g_do_tagpreview != 0) {\n              if (!GETFILE_SUCCESS(getfile(curwin_save->w_buffer->b_fnum, NULL,\n                                           NULL, true, lnum, false))) {\n                break;    // failed to jump to file\n              }\n            } else {\n              setpcmark();\n            }\n            curwin->w_cursor.lnum = lnum;\n            check_cursor();\n          } else {\n            if (!GETFILE_SUCCESS(getfile(0, files[depth].name, NULL, true,\n                                         files[depth].lnum, false))) {\n              break;    // failed to jump to file\n            }\n            // autocommands may have changed the lnum, we don't\n            // want that here\n            curwin->w_cursor.lnum = files[depth].lnum;\n          }\n        }\n        if (action != ACTION_SHOW) {\n          curwin->w_cursor.col = (colnr_T)(startp - line);\n          curwin->w_set_curswant = TRUE;\n        }\n\n        if (l_g_do_tagpreview != 0\n            && curwin != curwin_save && win_valid(curwin_save)) {\n          /* Return cursor to where we were */\n          validate_cursor();\n          redraw_later(curwin, VALID);\n          win_enter(curwin_save, true);\n        }\n        break;\n      }\nexit_matched:\n      matched = false;\n      // look for other matches in the rest of the line if we\n      // are not at the end of it already\n      if (def_regmatch.regprog == NULL\n          && action == ACTION_EXPAND\n          && !(compl_cont_status & CONT_SOL)\n          && *startp != NUL\n          && *(p = startp + utfc_ptr2len(startp)) != NUL) {\n        goto search_line;\n      }\n    }\n    line_breakcheck();\n    if (action == ACTION_EXPAND)\n      ins_compl_check_keys(30, false);\n    if (got_int || compl_interrupted)\n      break;\n\n    /*\n     * Read the next line.  When reading an included file and encountering\n     * end-of-file, close the file and continue in the file that included\n     * it.\n     */\n    while (depth >= 0 && !already\n           && vim_fgets(line = file_line, LSIZE, files[depth].fp)) {\n      fclose(files[depth].fp);\n      --old_files;\n      files[old_files].name = files[depth].name;\n      files[old_files].matched = files[depth].matched;\n      --depth;\n      curr_fname = (depth == -1) ? curbuf->b_fname\n                   : files[depth].name;\n      if (depth < depth_displayed)\n        depth_displayed = depth;\n    }\n    if (depth >= 0) {           /* we could read the line */\n      files[depth].lnum++;\n      /* Remove any CR and LF from the line. */\n      i = (int)STRLEN(line);\n      if (i > 0 && line[i - 1] == '\\n')\n        line[--i] = NUL;\n      if (i > 0 && line[i - 1] == '\\r')\n        line[--i] = NUL;\n    } else if (!already) {\n      if (++lnum > end_lnum)\n        break;\n      line = ml_get(lnum);\n    }\n    already = NULL;\n  }\n  /* End of big for (;;) loop. */\n\n  /* Close any files that are still open. */\n  for (i = 0; i <= depth; i++) {\n    fclose(files[i].fp);\n    xfree(files[i].name);\n  }\n  for (i = old_files; i < max_path_depth; i++)\n    xfree(files[i].name);\n  xfree(files);\n\n  if (type == CHECK_PATH) {\n    if (!did_show) {\n      if (action != ACTION_SHOW_ALL)\n        MSG(_(\"All included files were found\"));\n      else\n        MSG(_(\"No included files\"));\n    }\n  } else if (!found\n             && action != ACTION_EXPAND\n             ) {\n    if (got_int || compl_interrupted)\n      EMSG(_(e_interr));\n    else if (type == FIND_DEFINE)\n      EMSG(_(\"E388: Couldn't find definition\"));\n    else\n      EMSG(_(\"E389: Couldn't find pattern\"));\n  }\n  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n    msg_end();\n\nfpip_end:\n  xfree(file_line);\n  vim_regfree(regmatch.regprog);\n  vim_regfree(incl_regmatch.regprog);\n  vim_regfree(def_regmatch.regprog);\n}\n\nstatic void show_pat_in_path(char_u *line, int type, bool did_show, int action,\n                             FILE *fp, linenr_T *lnum, long count)\n  FUNC_ATTR_NONNULL_ARG(1, 6)\n{\n  char_u  *p;\n\n  if (did_show) {\n    msg_putchar('\\n');          // cursor below last one\n  } else if (!msg_silent) {\n    gotocmdline(true);          // cursor at status line\n  }\n  if (got_int) {                // 'q' typed at \"--more--\" message\n    return;\n  }\n  for (;; ) {\n    p = line + STRLEN(line) - 1;\n    if (fp != NULL) {\n      /* We used fgets(), so get rid of newline at end */\n      if (p >= line && *p == '\\n')\n        --p;\n      if (p >= line && *p == '\\r')\n        --p;\n      *(p + 1) = NUL;\n    }\n    if (action == ACTION_SHOW_ALL) {\n      snprintf((char *)IObuff, IOSIZE, \"%3ld: \", count);  // Show match nr.\n      msg_puts((const char *)IObuff);\n      snprintf((char *)IObuff, IOSIZE, \"%4ld\", *lnum);  // Show line nr.\n      // Highlight line numbers.\n      msg_puts_attr((const char *)IObuff, HL_ATTR(HLF_N));\n      msg_puts(\" \");\n    }\n    msg_prt_line(line, FALSE);\n    ui_flush();                        /* show one line at a time */\n\n    /* Definition continues until line that doesn't end with '\\' */\n    if (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')\n      break;\n\n    if (fp != NULL) {\n      if (vim_fgets(line, LSIZE, fp))       /* end of file */\n        break;\n      ++*lnum;\n    } else {\n      if (++*lnum > curbuf->b_ml.ml_line_count)\n        break;\n      line = ml_get(*lnum);\n    }\n    msg_putchar('\\n');\n  }\n}\n\n/// Get last search pattern\nvoid get_search_pattern(SearchPattern *const pat)\n{\n  memcpy(pat, &(spats[0]), sizeof(spats[0]));\n}\n\n/// Get last substitute pattern\nvoid get_substitute_pattern(SearchPattern *const pat)\n{\n  memcpy(pat, &(spats[1]), sizeof(spats[1]));\n  memset(&(pat->off), 0, sizeof(pat->off));\n}\n\n/// Set last search pattern\nvoid set_search_pattern(const SearchPattern pat)\n{\n  free_spat(&spats[0]);\n  memcpy(&(spats[0]), &pat, sizeof(spats[0]));\n  set_vv_searchforward();\n}\n\n/// Set last substitute pattern\nvoid set_substitute_pattern(const SearchPattern pat)\n{\n  free_spat(&spats[1]);\n  memcpy(&(spats[1]), &pat, sizeof(spats[1]));\n  memset(&(spats[1].off), 0, sizeof(spats[1].off));\n}\n\n/// Set last used search pattern\n///\n/// @param[in]  is_substitute_pattern  If true set substitute pattern as last\n///                                    used. Otherwise sets search pattern.\nvoid set_last_used_pattern(const bool is_substitute_pattern)\n{\n  last_idx = (is_substitute_pattern ? 1 : 0);\n}\n\n/// Returns true if search pattern was the last used one\nbool search_was_last_used(void)\n{\n  return last_idx == 0;\n}\n"}}, "reports": [{"events": [{"location": {"col": 21, "file": 0, "line": 1753}, "message": "Assuming the condition is false"}, {"location": {"col": 19, "file": 0, "line": 1755}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1758}, "message": "Assuming the condition is false"}, {"location": {"col": 12, "file": 0, "line": 1760}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1771}, "message": "Assuming the condition is false"}, {"location": {"col": 23, "file": 0, "line": 1771}, "message": "Assuming the condition is false"}, {"location": {"col": 39, "file": 0, "line": 1771}, "message": "Assuming the condition is false"}, {"location": {"col": 14, "file": 0, "line": 1778}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1928}, "message": "Assuming field 'wo_rl' is 0"}, {"location": {"col": 10, "file": 0, "line": 1940}, "message": "Assuming 'lisp' is false"}, {"location": {"col": 10, "file": 0, "line": 1946}, "message": "Assuming 'got_int' is 0"}, {"location": {"col": 10, "file": 0, "line": 1946}, "message": "Entering loop body"}, {"location": {"col": 11, "file": 0, "line": 1981}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 2010}, "message": "Assuming field 'col' is not equal to 0"}, {"location": {"col": 25, "file": 0, "line": 2088}, "message": "Entering loop body"}, {"location": {"col": 13, "file": 0, "line": 2089}, "message": "Assuming the condition is false"}, {"location": {"col": 13, "file": 0, "line": 2091}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 2088}, "message": "Looping back to the head of the loop"}, {"location": {"col": 13, "file": 0, "line": 2115}, "message": "Assuming field 'lnum' is > 1"}, {"location": {"col": 15, "file": 0, "line": 2117}, "message": "Assuming the condition is true"}, {"location": {"col": 23, "file": 0, "line": 2117}, "message": "Assuming the condition is true"}, {"location": {"col": 25, "file": 0, "line": 2120}, "message": "Loss of sign in implicit conversion"}], "macros": [{"location": {"col": 3, "file": 0, "line": 1753}, "expansion": "_Bool", "name": "bool"}, {"location": {"col": 3, "file": 0, "line": 1755}, "expansion": "_Bool", "name": "bool"}], "notes": [], "path": "src/nvim/search.c", "reportHash": "fb76c2ed9450c60dc449d5a9b8b70755", "checkerName": "alpha.core.Conversion", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
