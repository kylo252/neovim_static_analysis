<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/ex_docmd.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// ex_docmd.c: functions for executing an Ex command line.\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/debugger.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/event/rstream.h\"\n#include \"nvim/event/wstream.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_cmds_defs.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/ex_session.h\"\n#include \"nvim/file_search.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/globals.h\"\n#include \"nvim/hardcopy.h\"\n#include \"nvim/if_cscope.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/lua/executor.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/menu.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/shada.h\"\n#include \"nvim/sign.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/spellfile.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/tag.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/version.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/window.h\"\n\nstatic int quitmore = 0;\nstatic bool ex_pressedreturn = false;\n\ntypedef struct ucmd {\n  char_u *uc_name;         // The command name\n  uint32_t uc_argt;             // The argument type\n  char_u *uc_rep;          // The command's replacement string\n  long uc_def;                  // The default value for a range/count\n  int uc_compl;                 // completion type\n  cmd_addr_T uc_addr_type;      // The command's address type\n  sctx_T uc_script_ctx;         // SCTX where the command was defined\n  char_u *uc_compl_arg;    // completion argument if any\n} ucmd_T;\n\n#define UC_BUFFER       1       // -buffer: local to current buffer\n\nstatic garray_T ucmds = { 0, 0, sizeof(ucmd_T), 4, NULL };\n\n#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])\n#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])\n\n// Whether a command index indicates a user command.\n# define IS_USER_CMDIDX(idx) ((int)(idx) < 0)\n\n// Struct for storing a line inside a while/for loop\ntypedef struct {\n  char_u *line;            // command line\n  linenr_T lnum;                // sourcing_lnum of the line\n} wcmd_T;\n\n#define FREE_WCMD(wcmd) xfree((wcmd)->line)\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie {\n  garray_T *lines_gap;               // growarray with line info\n  int current_line;                     // last read line from growarray\n  int repeating;                        // TRUE when looping a second time\n  // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n  char_u *(*getline)(int, void *, int, bool);\n  void *cookie;\n};\n\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff {\n  int trylevel;\n  int force_abort;\n  except_T *caught_stack;\n  char_u *vv_exception;\n  char_u *vv_throwpoint;\n  int did_emsg;\n  int got_int;\n  int need_rethrow;\n  int check_cstack;\n  except_T *current_exception;\n};\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"ex_docmd.c.generated.h\"\n#endif\n\n#ifndef HAVE_WORKING_LIBINTL\n# define ex_language            ex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"ex_cmds_defs.generated.h\"\n#endif\n\nstatic char_u dollar_command[2] = { '$', 0 };\n\nstatic void save_dbg_stuff(struct dbg_stuff *dsp)\n{\n  dsp->trylevel       = trylevel;             trylevel = 0;\n  dsp->force_abort    = force_abort;          force_abort = FALSE;\n  dsp->caught_stack   = caught_stack;         caught_stack = NULL;\n  dsp->vv_exception   = v_exception(NULL);\n  dsp->vv_throwpoint  = v_throwpoint(NULL);\n\n  // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\".\n  dsp->did_emsg       = did_emsg;             did_emsg     = false;\n  dsp->got_int        = got_int;              got_int      = false;\n  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;\n  dsp->check_cstack   = check_cstack;         check_cstack = false;\n  dsp->current_exception = current_exception; current_exception = NULL;\n}\n\nstatic void restore_dbg_stuff(struct dbg_stuff *dsp)\n{\n  suppress_errthrow = false;\n  trylevel = dsp->trylevel;\n  force_abort = dsp->force_abort;\n  caught_stack = dsp->caught_stack;\n  (void)v_exception(dsp->vv_exception);\n  (void)v_throwpoint(dsp->vv_throwpoint);\n  did_emsg = dsp->did_emsg;\n  got_int = dsp->got_int;\n  need_rethrow = dsp->need_rethrow;\n  check_cstack = dsp->check_cstack;\n  current_exception = dsp->current_exception;\n}\n\n/// Repeatedly get commands for Ex mode, until the \":vi\" command is given.\nvoid do_exmode(void)\n{\n  int save_msg_scroll;\n  int prev_msg_row;\n  linenr_T prev_line;\n  int changedtick;\n\n  exmode_active = true;\n  State = NORMAL;\n\n  /* When using \":global /pat/ visual\" and then \"Q\" we return to continue\n   * the :global command. */\n  if (global_busy) {\n    return;\n  }\n\n  save_msg_scroll = msg_scroll;\n  RedrawingDisabled++;  // don't redisplay the window\n  no_wait_return++;  // don't wait for return\n\n  MSG(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n  while (exmode_active) {\n    // Check for a \":normal\" command and no more characters left.\n    if (ex_normal_busy > 0 && typebuf.tb_len == 0) {\n      exmode_active = false;\n      break;\n    }\n    msg_scroll = true;\n    need_wait_return = false;\n    ex_pressedreturn = false;\n    ex_no_reprint = false;\n    changedtick = buf_get_changedtick(curbuf);\n    prev_msg_row = msg_row;\n    prev_line = curwin->w_cursor.lnum;\n    cmdline_row = msg_row;\n    do_cmdline(NULL, getexline, NULL, 0);\n    lines_left = Rows - 1;\n\n    if ((prev_line != curwin->w_cursor.lnum\n         || changedtick != buf_get_changedtick(curbuf)) && !ex_no_reprint) {\n      if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n        EMSG(_(e_emptybuf));\n      } else {\n        if (ex_pressedreturn) {\n          /* go up one line, to overwrite the \":<CR>\" line, so the\n           * output doesn't contain empty lines. */\n          msg_row = prev_msg_row;\n          if (prev_msg_row == Rows - 1) {\n            msg_row--;\n          }\n        }\n        msg_col = 0;\n        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n        msg_clr_eos();\n      }\n    } else if (ex_pressedreturn && !ex_no_reprint) {  // must be at EOF\n      if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n        EMSG(_(e_emptybuf));\n      } else {\n        EMSG(_(\"E501: At end-of-file\"));\n      }\n    }\n  }\n\n  RedrawingDisabled--;\n  no_wait_return--;\n  redraw_all_later(NOT_VALID);\n  update_screen(NOT_VALID);\n  need_wait_return = false;\n  msg_scroll = save_msg_scroll;\n}\n\n// Print the executed command for when 'verbose' is set.\n// When \"lnum\" is 0 only print the command.\nstatic void msg_verbose_cmd(linenr_T lnum, char_u *cmd)\n  FUNC_ATTR_NONNULL_ALL\n{\n  no_wait_return++;\n  verbose_enter_scroll();\n\n  if (lnum == 0) {\n    smsg(_(\"Executing: %s\"), cmd);\n  } else {\n    smsg(_(\"line %\" PRIdLINENR \": %s\"), lnum, cmd);\n  }\n  if (msg_silent == 0) {\n    msg_puts(\"\\n\");   // don't overwrite this\n  }\n\n  verbose_leave_scroll();\n  no_wait_return--;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\nint do_cmdline_cmd(const char *cmd)\n{\n  return do_cmdline((char_u *)cmd, NULL, NULL,\n                    DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/// do_cmdline(): execute one Ex command line\n///\n/// 1. Execute \"cmdline\" when it is not NULL.\n///    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n/// 2. Split up in parts separated with '|'.\n///\n/// This function can be called recursively!\n///\n/// flags:\n///   DOCMD_VERBOSE  - The command will be included in the error message.\n///   DOCMD_NOWAIT   - Don't call wait_return() and friends.\n///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n///   DOCMD_KEYTYPED - Don't reset KeyTyped.\n///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n///   DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n///\n/// @param cookie  argument for fgetline()\n///\n/// @return FAIL if cmdline could not be executed, OK otherwise\nint do_cmdline(char_u *cmdline, LineGetter fgetline, void *cookie, int flags)\n{\n  char_u *next_cmdline;            // next cmd to execute\n  char_u *cmdline_copy = NULL;     // copy of cmd line\n  bool used_getline = false;            // used \"fgetline\" to obtain command\n  static int recursive = 0;             // recursive depth\n  bool msg_didout_before_start = false;\n  int count = 0;                        // line number count\n  int did_inc = FALSE;                  // incremented RedrawingDisabled\n  int retval = OK;\n  cstack_T cstack = {                   // conditional stack\n    .cs_idx = -1,\n  };\n  garray_T lines_ga;                    // keep lines for \":while\"/\":for\"\n  int current_line = 0;                 // active line in lines_ga\n  char_u *fname = NULL;               // function or script name\n  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie\n  int *dbg_tick = NULL;            // ptr to dbg_tick field in cookie\n  struct dbg_stuff debug_saved;         // saved things for debug mode\n  int initial_trylevel;\n  struct msglist **saved_msg_list = NULL;\n  struct msglist *private_msg_list;\n\n  // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n  char_u *(*cmd_getline)(int, void *, int, bool);\n  void *cmd_cookie;\n  struct loop_cookie cmd_loop_cookie;\n  void *real_cookie;\n  int getline_is_func;\n  static int call_depth = 0;            // recursiveness\n\n  /* For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n   * location for storing error messages to be converted to an exception.\n   * This ensures that the do_errthrow() call in do_one_cmd() does not\n   * combine the messages stored by an earlier invocation of do_one_cmd()\n   * with the command name of the later one.  This would happen when\n   * BufWritePost autocommands are executed after a write error. */\n  saved_msg_list = msg_list;\n  msg_list = &private_msg_list;\n  private_msg_list = NULL;\n\n  // It's possible to create an endless loop with \":execute\", catch that\n  // here.  The value of 200 allows nested function calls, \":source\", etc.\n  // Allow 200 or 'maxfuncdepth', whatever is larger.\n  if (call_depth >= 200 && call_depth >= p_mfd) {\n    EMSG(_(\"E169: Command too recursive\"));\n    // When converting to an exception, we do not include the command name\n    // since this is not an error of the specific command.\n    do_errthrow((cstack_T *)NULL, (char_u *)NULL);\n    msg_list = saved_msg_list;\n    return FAIL;\n  }\n  call_depth++;\n  start_batch_changes();\n\n  ga_init(&lines_ga, (int)sizeof(wcmd_T), 10);\n\n  real_cookie = getline_cookie(fgetline, cookie);\n\n  // Inside a function use a higher nesting level.\n  getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n  if (getline_is_func && ex_nesting_level == func_level(real_cookie)) {\n    ++ex_nesting_level;\n  }\n\n  /* Get the function or script name and the address where the next breakpoint\n   * line and the debug tick for a function or script are stored. */\n  if (getline_is_func) {\n    fname = func_name(real_cookie);\n    breakpoint = func_breakpoint(real_cookie);\n    dbg_tick = func_dbg_tick(real_cookie);\n  } else if (getline_equal(fgetline, cookie, getsourceline)) {\n    fname = sourcing_name;\n    breakpoint = source_breakpoint(real_cookie);\n    dbg_tick = source_dbg_tick(real_cookie);\n  }\n\n  /*\n   * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n   */\n  if (!recursive) {\n    force_abort = false;\n    suppress_errthrow = false;\n  }\n\n  // If requested, store and reset the global values controlling the\n  // exception handling (used when debugging).  Otherwise clear it to avoid\n  // a bogus compiler warning when the optimizer uses inline functions...\n  if (flags & DOCMD_EXCRESET) {\n    save_dbg_stuff(&debug_saved);\n  } else {\n    memset(&debug_saved, 0, sizeof(debug_saved));\n  }\n\n  initial_trylevel = trylevel;\n\n  current_exception = NULL;\n  // \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n  // cancel the whole command line, and any if/endif or loop.\n  // If force_abort is set, we cancel everything.\n  did_emsg = false;\n\n  // KeyTyped is only set when calling vgetc().  Reset it here when not\n  // calling vgetc() (sourced command lines).\n  if (!(flags & DOCMD_KEYTYPED)\n      && !getline_equal(fgetline, cookie, getexline)) {\n    KeyTyped = false;\n  }\n\n  /*\n   * Continue executing command lines:\n   * - when inside an \":if\", \":while\" or \":for\"\n   * - for multiple commands on one line, separated with '|'\n   * - when repeating until there are no more lines (for \":source\")\n   */\n  next_cmdline = cmdline;\n  do {\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n\n    // stop skipping cmds for an error msg after all endif/while/for\n    if (next_cmdline == NULL\n        && !force_abort\n        && cstack.cs_idx < 0\n        && !(getline_is_func &&\n             func_has_abort(real_cookie))) {\n      did_emsg = FALSE;\n    }\n\n    /*\n     * 1. If repeating a line in a loop, get a line from lines_ga.\n     * 2. If no line given: Get an allocated line with fgetline().\n     * 3. If a line is given: Make a copy, so we can mess with it.\n     */\n\n    // 1. If repeating, get a previous line from lines_ga.\n    if (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len) {\n      /* Each '|' separated command is stored separately in lines_ga, to\n       * be able to jump to it.  Don't use next_cmdline now. */\n      XFREE_CLEAR(cmdline_copy);\n\n      /* Check if a function has returned or, unless it has an unclosed\n       * try conditional, aborted. */\n      if (getline_is_func) {\n        if (do_profiling == PROF_YES) {\n          func_line_end(real_cookie);\n        }\n        if (func_has_ended(real_cookie)) {\n          retval = FAIL;\n          break;\n        }\n      } else if (do_profiling == PROF_YES\n                 && getline_equal(fgetline, cookie, getsourceline)) {\n        script_line_end();\n      }\n\n      // Check if a sourced file hit a \":finish\" command.\n      if (source_finished(fgetline, cookie)) {\n        retval = FAIL;\n        break;\n      }\n\n      // If breakpoints have been added/deleted need to check for it.\n      if (breakpoint != NULL && dbg_tick != NULL\n          && *dbg_tick != debug_tick) {\n        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),\n                                          fname, sourcing_lnum);\n        *dbg_tick = debug_tick;\n      }\n\n      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n      sourcing_lnum = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n      // Did we encounter a breakpoint?\n      if (breakpoint != NULL && *breakpoint != 0\n          && *breakpoint <= sourcing_lnum) {\n        dbg_breakpoint(fname, sourcing_lnum);\n        // Find next breakpoint.\n        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),\n                                          fname, sourcing_lnum);\n        *dbg_tick = debug_tick;\n      }\n      if (do_profiling == PROF_YES) {\n        if (getline_is_func) {\n          func_line_start(real_cookie);\n        } else if (getline_equal(fgetline, cookie, getsourceline)) {\n          script_line_start();\n        }\n      }\n    }\n\n    if (cstack.cs_looplevel > 0) {\n      /* Inside a while/for loop we need to store the lines and use them\n       * again.  Pass a different \"fgetline\" function to do_one_cmd()\n       * below, so that it stores lines in or reads them from\n       * \"lines_ga\".  Makes it possible to define a function inside a\n       * while/for loop. */\n      cmd_getline = get_loop_line;\n      cmd_cookie = (void *)&cmd_loop_cookie;\n      cmd_loop_cookie.lines_gap = &lines_ga;\n      cmd_loop_cookie.current_line = current_line;\n      cmd_loop_cookie.getline = fgetline;\n      cmd_loop_cookie.cookie = cookie;\n      cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n    } else {\n      cmd_getline = fgetline;\n      cmd_cookie = cookie;\n    }\n\n    // 2. If no line given, get an allocated line with fgetline().\n    if (next_cmdline == NULL) {\n      /*\n       * Need to set msg_didout for the first line after an \":if\",\n       * otherwise the \":if\" will be overwritten.\n       */\n      if (count == 1 && getline_equal(fgetline, cookie, getexline)) {\n        msg_didout = true;\n      }\n      if (fgetline == NULL\n          || (next_cmdline = fgetline(':', cookie,\n                                      cstack.cs_idx <\n                                      0 ? 0 : (cstack.cs_idx + 1) * 2,\n                                      true)) == NULL) {\n        // Don't call wait_return for aborted command line.  The NULL\n        // returned for the end of a sourced file or executed function\n        // doesn't do this.\n        if (KeyTyped && !(flags & DOCMD_REPEAT)) {\n          need_wait_return = false;\n        }\n        retval = FAIL;\n        break;\n      }\n      used_getline = true;\n\n      /*\n       * Keep the first typed line.  Clear it when more lines are typed.\n       */\n      if (flags & DOCMD_KEEPLINE) {\n        xfree(repeat_cmdline);\n        if (count == 0) {\n          repeat_cmdline = vim_strsave(next_cmdline);\n        } else {\n          repeat_cmdline = NULL;\n        }\n      }\n    }\n    // 3. Make a copy of the command so we can mess with it.\n    else if (cmdline_copy == NULL) {\n      next_cmdline = vim_strsave(next_cmdline);\n    }\n    cmdline_copy = next_cmdline;\n\n    /*\n     * Save the current line when inside a \":while\" or \":for\", and when\n     * the command looks like a \":while\" or \":for\", because we may need it\n     * later.  When there is a '|' and another command, it is stored\n     * separately, because we need to be able to jump back to it from an\n     * :endwhile/:endfor.\n     */\n    if (current_line == lines_ga.ga_len\n        && (cstack.cs_looplevel || has_loop_cmd(next_cmdline))) {\n      store_loop_line(&lines_ga, next_cmdline);\n    }\n    did_endif = false;\n\n    if (count++ == 0) {\n      /*\n       * All output from the commands is put below each other, without\n       * waiting for a return. Don't do this when executing commands\n       * from a script or when being called recursive (e.g. for \":e\n       * +command file\").\n       */\n      if (!(flags & DOCMD_NOWAIT) && !recursive) {\n        msg_didout_before_start = msg_didout;\n        msg_didany = false;         // no output yet\n        msg_start();\n        msg_scroll = TRUE;          // put messages below each other\n        ++no_wait_return;           // don't wait for return until finished\n        ++RedrawingDisabled;\n        did_inc = TRUE;\n      }\n    }\n\n    if ((p_verbose >= 15 && sourcing_name != NULL) || p_verbose >= 16) {\n      msg_verbose_cmd(sourcing_lnum, cmdline_copy);\n    }\n\n    /*\n     * 2. Execute one '|' separated command.\n     *    do_one_cmd() will return NULL if there is no trailing '|'.\n     *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n     */\n    recursive++;\n    next_cmdline = do_one_cmd(&cmdline_copy, flags,\n                              &cstack,\n                              cmd_getline, cmd_cookie);\n    recursive--;\n\n    // Ignore trailing '|'-separated commands in preview-mode ('inccommand').\n    if (State & CMDPREVIEW) {\n      next_cmdline = NULL;\n    }\n\n    if (cmd_cookie == (void *)&cmd_loop_cookie) {\n      /* Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n       * incremented when defining a function. */\n      current_line = cmd_loop_cookie.current_line;\n    }\n\n    if (next_cmdline == NULL) {\n      XFREE_CLEAR(cmdline_copy);\n      //\n      // If the command was typed, remember it for the ':' register.\n      // Do this AFTER executing the command to make :@: work.\n      //\n      if (getline_equal(fgetline, cookie, getexline)\n          && new_last_cmdline != NULL) {\n        xfree(last_cmdline);\n        last_cmdline = new_last_cmdline;\n        new_last_cmdline = NULL;\n      }\n    } else {\n      /* need to copy the command after the '|' to cmdline_copy, for the\n       * next do_one_cmd() */\n      STRMOVE(cmdline_copy, next_cmdline);\n      next_cmdline = cmdline_copy;\n    }\n\n\n    // reset did_emsg for a function that is not aborted by an error\n    if (did_emsg && !force_abort\n        && getline_equal(fgetline, cookie, get_func_line)\n        && !func_has_abort(real_cookie)) {\n      did_emsg = FALSE;\n    }\n\n    if (cstack.cs_looplevel > 0) {\n      ++current_line;\n\n      /*\n       * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n       * If we were executing commands, jump back to the \":while\" or\n       * \":for\".\n       * If we were not executing commands, decrement cs_looplevel.\n       */\n      if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {\n        cstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n        /* Jump back to the matching \":while\" or \":for\".  Be careful\n         * not to use a cs_line[] from an entry that isn't a \":while\"\n         * or \":for\": It would make \"current_line\" invalid and can\n         * cause a crash. */\n        if (!did_emsg && !got_int && !current_exception\n            && cstack.cs_idx >= 0\n            && (cstack.cs_flags[cstack.cs_idx]\n                & (CSF_WHILE | CSF_FOR))\n            && cstack.cs_line[cstack.cs_idx] >= 0\n            && (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE)) {\n          current_line = cstack.cs_line[cstack.cs_idx];\n          // remember we jumped there\n          cstack.cs_lflags |= CSL_HAD_LOOP;\n          line_breakcheck();                    // check if CTRL-C typed\n\n          /* Check for the next breakpoint at or after the \":while\"\n           * or \":for\". */\n          if (breakpoint != NULL) {\n            *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),\n                                              fname,\n                                              ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n            *dbg_tick = debug_tick;\n          }\n        } else {\n          // can only get here with \":endwhile\" or \":endfor\"\n          if (cstack.cs_idx >= 0) {\n            rewind_conditionals(&cstack, cstack.cs_idx - 1,\n                                CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n          }\n        }\n      }\n      /*\n       * For a \":while\" or \":for\" we need to remember the line number.\n       */\n      else if (cstack.cs_lflags & CSL_HAD_LOOP) {\n        cstack.cs_lflags &= ~CSL_HAD_LOOP;\n        cstack.cs_line[cstack.cs_idx] = current_line - 1;\n      }\n    }\n\n    /*\n     * When not inside any \":while\" loop, clear remembered lines.\n     */\n    if (cstack.cs_looplevel == 0) {\n      if (!GA_EMPTY(&lines_ga)) {\n        sourcing_lnum = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n        GA_DEEP_CLEAR(&lines_ga, wcmd_T, FREE_WCMD);\n      }\n      current_line = 0;\n    }\n\n    /*\n     * A \":finally\" makes did_emsg, got_int and current_exception pending for\n     * being restored at the \":endtry\".  Reset them here and set the\n     * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n     * This includes the case where a missing \":endif\", \":endwhile\" or\n     * \":endfor\" was detected by the \":finally\" itself.\n     */\n    if (cstack.cs_lflags & CSL_HAD_FINA) {\n      cstack.cs_lflags &= ~CSL_HAD_FINA;\n      report_make_pending((cstack.cs_pending[cstack.cs_idx]\n                           & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),\n                          current_exception);\n      did_emsg = got_int = false;\n      current_exception = NULL;\n      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n    }\n\n    /* Update global \"trylevel\" for recursive calls to do_cmdline() from\n     * within this loop. */\n    trylevel = initial_trylevel + cstack.cs_trylevel;\n\n    // If the outermost try conditional (across function calls and sourced\n    // files) is aborted because of an error, an interrupt, or an uncaught\n    // exception, cancel everything.  If it is left normally, reset\n    // force_abort to get the non-EH compatible abortion behavior for\n    // the rest of the script.\n    if (trylevel == 0 && !did_emsg && !got_int && !current_exception) {\n      force_abort = false;\n    }\n\n    // Convert an interrupt to an exception if appropriate.\n    (void)do_intthrow(&cstack);\n  }\n  /*\n   * Continue executing command lines when:\n   * - no CTRL-C typed, no aborting error, no exception thrown or try\n   *   conditionals need to be checked for executing finally clauses or\n   *   catching an interrupt exception\n   * - didn't get an error message or lines are not typed\n   * - there is a command after '|', inside a :if, :while, :for or :try, or\n   *   looping for \":source\" command or function call.\n   */\n  while (!((got_int || (did_emsg && force_abort) || current_exception)\n           && cstack.cs_trylevel == 0)\n         && !(did_emsg\n              /* Keep going when inside try/catch, so that the error can be\n               * deal with, except when it is a syntax error, it may cause\n               * the :endtry to be missed. */\n              && (cstack.cs_trylevel == 0 || did_emsg_syntax)\n              && used_getline\n              && getline_equal(fgetline, cookie, getexline))\n         && (next_cmdline != NULL\n             || cstack.cs_idx >= 0\n             || (flags & DOCMD_REPEAT)));\n\n  xfree(cmdline_copy);\n  did_emsg_syntax = false;\n  GA_DEEP_CLEAR(&lines_ga, wcmd_T, FREE_WCMD);\n\n  if (cstack.cs_idx >= 0) {\n    /*\n     * If a sourced file or executed function ran to its end, report the\n     * unclosed conditional.\n     */\n    if (!got_int && !current_exception\n        && ((getline_equal(fgetline, cookie, getsourceline)\n             && !source_finished(fgetline, cookie))\n            || (getline_equal(fgetline, cookie, get_func_line)\n                && !func_has_ended(real_cookie)))) {\n      if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY) {\n        EMSG(_(e_endtry));\n      } else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE) {\n        EMSG(_(e_endwhile));\n      } else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR) {\n        EMSG(_(e_endfor));\n      } else {\n        EMSG(_(e_endif));\n      }\n    }\n\n    /*\n     * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n     * \":endtry\" in a sourced file or executed function.  If the try\n     * conditional is in its finally clause, ignore anything pending.\n     * If it is in a catch clause, finish the caught exception.\n     * Also cleanup any \"cs_forinfo\" structures.\n     */\n    do {\n      int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n      if (idx >= 0) {\n        --idx;              // remove try block not in its finally clause\n      }\n      rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n                          &cstack.cs_looplevel);\n    } while (cstack.cs_idx >= 0);\n    trylevel = initial_trylevel;\n  }\n\n  /* If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n   * lack was reported above and the error message is to be converted to an\n   * exception, do this now after rewinding the cstack. */\n  do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n      ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n  if (trylevel == 0) {\n    // When an exception is being thrown out of the outermost try\n    // conditional, discard the uncaught exception, disable the conversion\n    // of interrupts or errors to exceptions, and ensure that no more\n    // commands are executed.\n    if (current_exception) {\n      void *p = NULL;\n      char_u *saved_sourcing_name;\n      int saved_sourcing_lnum;\n      struct msglist *messages = NULL;\n      struct msglist *next;\n\n      /*\n       * If the uncaught exception is a user exception, report it as an\n       * error.  If it is an error exception, display the saved error\n       * message now.  For an interrupt exception, do nothing; the\n       * interrupt message is given elsewhere.\n       */\n      switch (current_exception->type) {\n      case ET_USER:\n        vim_snprintf((char *)IObuff, IOSIZE,\n                     _(\"E605: Exception not caught: %s\"),\n                     current_exception->value);\n        p = vim_strsave(IObuff);\n        break;\n      case ET_ERROR:\n        messages = current_exception->messages;\n        current_exception->messages = NULL;\n        break;\n      case ET_INTERRUPT:\n        break;\n      }\n\n      saved_sourcing_name = sourcing_name;\n      saved_sourcing_lnum = sourcing_lnum;\n      sourcing_name = current_exception->throw_name;\n      sourcing_lnum = current_exception->throw_lnum;\n      current_exception->throw_name = NULL;\n\n      discard_current_exception();              // uses IObuff if 'verbose'\n      suppress_errthrow = true;\n      force_abort = true;\n      msg_ext_set_kind(\"emsg\");  // kind=emsg for :throw, exceptions. #9993\n\n      if (messages != NULL) {\n        do {\n          next = messages->next;\n          emsg(messages->msg);\n          xfree(messages->msg);\n          xfree(messages);\n          messages = next;\n        } while (messages != NULL);\n      } else if (p != NULL) {\n        emsg(p);\n        xfree(p);\n      }\n      xfree(sourcing_name);\n      sourcing_name = saved_sourcing_name;\n      sourcing_lnum = saved_sourcing_lnum;\n    } else if (got_int || (did_emsg && force_abort)) {\n      // On an interrupt or an aborting error not converted to an exception,\n      // disable the conversion of errors to exceptions.  (Interrupts are not\n      // converted any more, here.) This enables also the interrupt message\n      // when force_abort is set and did_emsg unset in case of an interrupt\n      // from a finally clause after an error.\n      suppress_errthrow = true;\n    }\n  }\n\n  // The current cstack will be freed when do_cmdline() returns.  An uncaught\n  // exception will have to be rethrown in the previous cstack.  If a function\n  // has just returned or a script file was just finished and the previous\n  // cstack belongs to the same function or, respectively, script file, it\n  // will have to be checked for finally clauses to be executed due to the\n  // \":return\" or \":finish\".  This is done in do_one_cmd().\n  if (current_exception) {\n    need_rethrow = true;\n  }\n  if ((getline_equal(fgetline, cookie, getsourceline)\n       && ex_nesting_level > source_level(real_cookie))\n      || (getline_equal(fgetline, cookie, get_func_line)\n          && ex_nesting_level > func_level(real_cookie) + 1)) {\n    if (!current_exception) {\n      check_cstack = true;\n    }\n  } else {\n    // When leaving a function, reduce nesting level.\n    if (getline_equal(fgetline, cookie, get_func_line)) {\n      --ex_nesting_level;\n    }\n    /*\n     * Go to debug mode when returning from a function in which we are\n     * single-stepping.\n     */\n    if ((getline_equal(fgetline, cookie, getsourceline)\n         || getline_equal(fgetline, cookie, get_func_line))\n        && ex_nesting_level + 1 <= debug_break_level) {\n      do_debug(getline_equal(fgetline, cookie, getsourceline)\n          ? (char_u *)_(\"End of sourced file\")\n          : (char_u *)_(\"End of function\"));\n    }\n  }\n\n  /*\n   * Restore the exception environment (done after returning from the\n   * debugger).\n   */\n  if (flags & DOCMD_EXCRESET) {\n    restore_dbg_stuff(&debug_saved);\n  }\n\n  msg_list = saved_msg_list;\n\n  /*\n   * If there was too much output to fit on the command line, ask the user to\n   * hit return before redrawing the screen. With the \":global\" command we do\n   * this only once after the command is finished.\n   */\n  if (did_inc) {\n    --RedrawingDisabled;\n    --no_wait_return;\n    msg_scroll = FALSE;\n\n    /*\n     * When just finished an \":if\"-\":else\" which was typed, no need to\n     * wait for hit-return.  Also for an error situation.\n     */\n    if (retval == FAIL\n        || (did_endif && KeyTyped && !did_emsg)) {\n      need_wait_return = false;\n      msg_didany = false;               // don't wait when restarting edit\n    } else if (need_wait_return) {\n      /*\n       * The msg_start() above clears msg_didout. The wait_return we do\n       * here should not overwrite the command that may be shown before\n       * doing that.\n       */\n      msg_didout |= msg_didout_before_start;\n      wait_return(FALSE);\n    }\n  }\n\n  did_endif = false;    // in case do_cmdline used recursively\n\n  call_depth--;\n  end_batch_changes();\n  return retval;\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\nstatic char_u *get_loop_line(int c, void *cookie, int indent, bool do_concat)\n{\n  struct loop_cookie *cp = (struct loop_cookie *)cookie;\n  wcmd_T *wp;\n  char_u *line;\n\n  if (cp->current_line + 1 >= cp->lines_gap->ga_len) {\n    if (cp->repeating) {\n      return NULL;              // trying to read past \":endwhile\"/\":endfor\"\n    }\n    // First time inside the \":while\"/\":for\": get line normally.\n    if (cp->getline == NULL) {\n      line = getcmdline(c, 0L, indent, do_concat);\n    } else {\n      line = cp->getline(c, cp->cookie, indent, do_concat);\n    }\n    if (line != NULL) {\n      store_loop_line(cp->lines_gap, line);\n      ++cp->current_line;\n    }\n\n    return line;\n  }\n\n  KeyTyped = false;\n  cp->current_line++;\n  wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n  sourcing_lnum = wp->lnum;\n  return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\nstatic void store_loop_line(garray_T *gap, char_u *line)\n{\n  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);\n  p->line = vim_strsave(line);\n  p->lnum = sourcing_lnum;\n}\n\n/// If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n/// \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n///\n/// @param cookie  argument for fgetline()\nint getline_equal(LineGetter fgetline, void *cookie, LineGetter func)\n{\n  LineGetter gp;\n  struct loop_cookie *cp;\n\n  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n   * function that's originally used to obtain the lines.  This may be\n   * nested several levels. */\n  gp = fgetline;\n  cp = (struct loop_cookie *)cookie;\n  while (gp == get_loop_line) {\n    gp = cp->getline;\n    cp = cp->cookie;\n  }\n  return gp == func;\n}\n\n/// If \"fgetline\" is get_loop_line(), return the cookie used by the original\n/// getline function.  Otherwise return \"cookie\".\n///\n/// @param cookie  argument for fgetline()\nvoid * getline_cookie(LineGetter fgetline, void *cookie)\n{\n  LineGetter gp;\n  struct loop_cookie *cp;\n\n  /* When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n   * cookie that's originally used to obtain the lines.  This may be nested\n   * several levels. */\n  gp = fgetline;\n  cp = (struct loop_cookie *)cookie;\n  while (gp == get_loop_line) {\n    gp = cp->getline;\n    cp = cp->cookie;\n  }\n  return cp;\n}\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\nstatic int compute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n  buf_T *buf;\n  buf_T *nextbuf;\n  int count = offset;\n\n  buf = firstbuf;\n  while (buf->b_next != NULL && buf->b_fnum < lnum) {\n    buf = buf->b_next;\n  }\n  while (count != 0) {\n    count += (count < 0) ? 1 : -1;\n    nextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n    if (nextbuf == NULL) {\n      break;\n    }\n    buf = nextbuf;\n    if (addr_type == ADDR_LOADED_BUFFERS) {\n      // skip over unloaded buffers\n      while (buf->b_ml.ml_mfp == NULL) {\n        nextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n        if (nextbuf == NULL) {\n          break;\n        }\n        buf = nextbuf;\n      }\n    }\n  }\n  // we might have gone too far, last buffer is not loaded\n  if (addr_type == ADDR_LOADED_BUFFERS) {\n    while (buf->b_ml.ml_mfp == NULL) {\n      nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n      if (nextbuf == NULL) {\n        break;\n      }\n      buf = nextbuf;\n    }\n  }\n  return buf->b_fnum;\n}\n\n// Return the window number of \"win\".\n// When \"win\" is NULL return the number of windows.\nstatic int current_win_nr(const win_T *win)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int nr = 0;\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    ++nr;\n    if (wp == win) {\n      break;\n    }\n  }\n  return nr;\n}\n\nstatic int current_tab_nr(tabpage_T *tab)\n{\n  int nr = 0;\n\n  FOR_ALL_TABS(tp) {\n    ++nr;\n    if (tp == tab) {\n      break;\n    }\n  }\n  return nr;\n}\n\n#define CURRENT_WIN_NR current_win_nr(curwin)\n#define LAST_WIN_NR current_win_nr(NULL)\n#define CURRENT_TAB_NR current_tab_nr(curtab)\n#define LAST_TAB_NR current_tab_nr(NULL)\n\n\n/// Figure out the address type for \":wincmd\".\nstatic void get_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n  switch (*arg) {\n  case 'S':\n  case Ctrl_S:\n  case 's':\n  case Ctrl_N:\n  case 'n':\n  case 'j':\n  case Ctrl_J:\n  case 'k':\n  case Ctrl_K:\n  case 'T':\n  case Ctrl_R:\n  case 'r':\n  case 'R':\n  case 'K':\n  case 'J':\n  case '+':\n  case '-':\n  case Ctrl__:\n  case '_':\n  case '|':\n  case ']':\n  case Ctrl_RSB:\n  case 'g':\n  case Ctrl_G:\n  case Ctrl_V:\n  case 'v':\n  case 'h':\n  case Ctrl_H:\n  case 'l':\n  case Ctrl_L:\n  case 'H':\n  case 'L':\n  case '>':\n  case '<':\n  case '}':\n  case 'f':\n  case 'F':\n  case Ctrl_F:\n  case 'i':\n  case Ctrl_I:\n  case 'd':\n  case Ctrl_D:\n    // window size or any count\n    eap->addr_type = ADDR_OTHER;  // -V1037\n    break;\n\n  case Ctrl_HAT:\n  case '^':\n    // buffer number\n    eap->addr_type = ADDR_BUFFERS;\n    break;\n\n  case Ctrl_Q:\n  case 'q':\n  case Ctrl_C:\n  case 'c':\n  case Ctrl_O:\n  case 'o':\n  case Ctrl_W:\n  case 'w':\n  case 'W':\n  case 'x':\n  case Ctrl_X:\n    // window number\n    eap->addr_type = ADDR_WINDOWS;\n    break;\n\n  case Ctrl_Z:\n  case 'z':\n  case 'P':\n  case 't':\n  case Ctrl_T:\n  case 'b':\n  case Ctrl_B:\n  case 'p':\n  case Ctrl_P:\n  case '=':\n  case CAR:\n    // no count\n    eap->addr_type = ADDR_NONE;\n    break;\n  }\n}\n\n/// Skip colons and trailing whitespace, returning a pointer to the first\n/// non-colon, non-whitespace character.\n//\n/// @param skipleadingwhite Skip leading whitespace too\nstatic char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)\n{\n  if (skipleadingwhite) {\n    p = skipwhite(p);\n  }\n\n  while (*p == ':') {\n    p = skipwhite(p + 1);\n  }\n\n  return (char_u *)p;\n}\n\n/// Execute one Ex command.\n///\n/// If 'sourcing' is TRUE, the command will be included in the error message.\n///\n/// 1. skip comment lines and leading space\n/// 2. handle command modifiers\n/// 3. skip over the range to find the command\n/// 4. parse the range\n/// 5. parse the command\n/// 6. parse arguments\n/// 7. switch on command name\n///\n/// Note: \"fgetline\" can be NULL.\n///\n/// This function may be called recursively!\n///\n/// @param cookie  argument for fgetline()\nstatic char_u * do_one_cmd(char_u **cmdlinep, int flags, cstack_T *cstack, LineGetter fgetline,\n                           void *cookie)\n{\n  char_u *p;\n  linenr_T lnum;\n  long n;\n  char_u *errormsg = NULL;  // error message\n  char_u *after_modifier = NULL;\n  exarg_T ea;\n  const int save_msg_scroll = msg_scroll;\n  cmdmod_T save_cmdmod;\n  const int save_reg_executing = reg_executing;\n  char_u *cmd;\n\n  memset(&ea, 0, sizeof(ea));\n  ea.line1 = 1;\n  ea.line2 = 1;\n  ex_nesting_level++;\n\n  // When the last file has not been edited :q has to be typed twice.\n  if (quitmore\n      // avoid that a function call in 'statusline' does this\n      && !getline_equal(fgetline, cookie, get_func_line)\n      // avoid that an autocommand, e.g. QuitPre, does this\n      && !getline_equal(fgetline, cookie,\n                        getnextac)) {\n    --quitmore;\n  }\n\n  /*\n   * Reset browse, confirm, etc..  They are restored when returning, for\n   * recursive calls.\n   */\n  save_cmdmod = cmdmod;\n\n  // \"#!anything\" is handled like a comment.\n  if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!') {\n    goto doend;\n  }\n\n  // 1. Skip comment lines and leading white space and colons.\n  // 2. Handle command modifiers.\n\n  // The \"ea\" structure holds the arguments that can be used.\n  ea.cmd = *cmdlinep;\n  ea.cmdlinep = cmdlinep;\n  ea.getline = fgetline;\n  ea.cookie = cookie;\n  ea.cstack = cstack;\n\n  if (parse_command_modifiers(&ea, &errormsg, false) == FAIL) {\n    goto doend;\n  }\n\n  after_modifier = ea.cmd;\n\n  ea.skip = (did_emsg\n             || got_int\n             || current_exception\n             || (cstack->cs_idx >= 0\n                 && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)));\n\n  // 3. Skip over the range to find the command. Let \"p\" point to after it.\n  //\n  // We need the command to know what kind of range it uses.\n  cmd = ea.cmd;\n  ea.cmd = skip_range(ea.cmd, NULL);\n  if (*ea.cmd == '*') {\n    ea.cmd = skipwhite(ea.cmd + 1);\n  }\n  p = find_command(&ea, NULL);\n\n  // Count this line for profiling if skip is TRUE.\n  if (do_profiling == PROF_YES\n      && (!ea.skip || cstack->cs_idx == 0\n          || (cstack->cs_idx > 0\n              && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE)))) {\n    int skip = did_emsg || got_int || current_exception;\n\n    if (ea.cmdidx == CMD_catch) {\n      skip = !skip && !(cstack->cs_idx >= 0\n                        && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n                        && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n    } else if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif) {\n      skip = skip || !(cstack->cs_idx >= 0\n                       && !(cstack->cs_flags[cstack->cs_idx]\n                            & (CSF_ACTIVE | CSF_TRUE)));\n    } else if (ea.cmdidx == CMD_finally) {\n      skip = false;\n    } else if (ea.cmdidx != CMD_endif\n               && ea.cmdidx != CMD_endfor\n               && ea.cmdidx != CMD_endtry\n               && ea.cmdidx != CMD_endwhile) {\n      skip = ea.skip;\n    }\n\n    if (!skip) {\n      if (getline_equal(fgetline, cookie, get_func_line)) {\n        func_line_exec(getline_cookie(fgetline, cookie));\n      } else if (getline_equal(fgetline, cookie, getsourceline)) {\n        script_line_exec();\n      }\n    }\n  }\n\n  // May go to debug mode.  If this happens and the \">quit\" debug command is\n  // used, throw an interrupt exception and skip the next command.\n  dbg_check_breakpoint(&ea);\n  if (!ea.skip && got_int) {\n    ea.skip = TRUE;\n    (void)do_intthrow(cstack);\n  }\n\n  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..\n  //\n  // where 'addr' is:\n  //\n  // %          (entire file)\n  // $  [+-NUM]\n  // 'x [+-NUM] (where x denotes a currently defined mark)\n  // .  [+-NUM]\n  // [+-NUM]..\n  // NUM\n  //\n  // The ea.cmd pointer is updated to point to the first character following the\n  // range spec. If an initial address is found, but no second, the upper bound\n  // is equal to the lower.\n\n  // ea.addr_type for user commands is set by find_ucmd\n  if (!IS_USER_CMDIDX(ea.cmdidx)) {\n    if (ea.cmdidx != CMD_SIZE) {\n      ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n    } else {\n      ea.addr_type = ADDR_LINES;\n    }\n    // :wincmd range depends on the argument\n    if (ea.cmdidx == CMD_wincmd && p != NULL) {\n      get_wincmd_addr_type(skipwhite(p), &ea);\n    }\n    // :.cc in quickfix window uses line number\n    if ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf)) {\n      ea.addr_type = ADDR_OTHER;\n    }\n  }\n\n  ea.cmd = cmd;\n  if (parse_cmd_address(&ea, &errormsg, false) == FAIL) {\n    goto doend;\n  }\n\n  /*\n   * 5. Parse the command.\n   */\n\n  /*\n   * Skip ':' and any white space\n   */\n  ea.cmd = skip_colon_white(ea.cmd, true);\n\n  /*\n   * If we got a line, but no command, then go to the line.\n   * If we find a '|' or '\\n' we set ea.nextcmd.\n   */\n  if (*ea.cmd == NUL || *ea.cmd == '\"'\n      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {\n    // strange vi behaviour:\n    // \":3\"     jumps to line 3\n    // \":3|...\" prints line 3\n    // \":|\"     prints current line\n    if (ea.skip) {  // skip this if inside :if\n      goto doend;\n    }\n    if (*ea.cmd == '|' || (exmode_active && ea.line1 != ea.line2)) {\n      ea.cmdidx = CMD_print;\n      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;\n      if ((errormsg = invalid_range(&ea)) == NULL) {\n        correct_range(&ea);\n        ex_print(&ea);\n      }\n    } else if (ea.addr_count != 0) {\n      if (ea.line2 > curbuf->b_ml.ml_line_count) {\n        ea.line2 = curbuf->b_ml.ml_line_count;\n      }\n\n      if (ea.line2 < 0) {\n        errormsg = (char_u *)_(e_invrange);\n      } else {\n        if (ea.line2 == 0) {\n          curwin->w_cursor.lnum = 1;\n        } else {\n          curwin->w_cursor.lnum = ea.line2;\n        }\n        beginline(BL_SOL | BL_FIX);\n      }\n    }\n    goto doend;\n  }\n\n  // If this looks like an undefined user command and there are CmdUndefined\n  // autocommands defined, trigger the matching autocommands.\n  if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n      && ASCII_ISUPPER(*ea.cmd)\n      && has_event(EVENT_CMDUNDEFINED)) {\n    p = ea.cmd;\n    while (ASCII_ISALNUM(*p)) {\n      ++p;\n    }\n    p = vim_strnsave(ea.cmd, p - ea.cmd);\n    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, true, NULL);\n    xfree(p);\n    // If the autocommands did something and didn't cause an error, try\n    // finding the command again.\n    p = (ret && !aborting()) ? find_command(&ea, NULL) : ea.cmd;\n  }\n\n  if (p == NULL) {\n    if (!ea.skip) {\n      errormsg = (char_u *)_(\"E464: Ambiguous use of user-defined command\");\n    }\n    goto doend;\n  }\n  // Check for wrong commands.\n  if (ea.cmdidx == CMD_SIZE) {\n    if (!ea.skip) {\n      STRCPY(IObuff, _(\"E492: Not an editor command\"));\n      // If the modifier was parsed OK the error must be in the following\n      // command\n      char_u *cmdname = after_modifier ? after_modifier : *cmdlinep;\n      if (!(flags & DOCMD_VERBOSE)) {\n        append_command(cmdname);\n      }\n      errormsg = IObuff;\n      did_emsg_syntax = true;\n      verify_command(cmdname);\n    }\n    goto doend;\n  }\n\n  // set when Not Implemented\n  const int ni = !IS_USER_CMDIDX(ea.cmdidx)\n                 && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n                     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni);\n\n\n  // Forced commands.\n  if (*p == '!' && ea.cmdidx != CMD_substitute\n      && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic) {\n    p++;\n    ea.forceit = true;\n  } else {\n    ea.forceit = false;\n  }\n\n  // 6. Parse arguments.  Then check for errors.\n  if (!IS_USER_CMDIDX(ea.cmdidx)) {\n    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;\n  }\n\n  if (!ea.skip) {\n    if (sandbox != 0 && !(ea.argt & EX_SBOXOK)) {\n      // Command not allowed in sandbox.\n      errormsg = (char_u *)_(e_sandbox);\n      goto doend;\n    }\n    if (!MODIFIABLE(curbuf) && (ea.argt & EX_MODIFY)\n        // allow :put in terminals\n        && (!curbuf->terminal || ea.cmdidx != CMD_put)) {\n      // Command not allowed in non-'modifiable' buffer\n      errormsg = (char_u *)_(e_modifiable);\n      goto doend;\n    }\n\n    if (text_locked() && !(ea.argt & EX_CMDWIN)\n        && !IS_USER_CMDIDX(ea.cmdidx)) {\n      // Command not allowed when editing the command line.\n      errormsg = (char_u *)_(get_text_locked_msg());\n      goto doend;\n    }\n\n    // Disallow editing another buffer when \"curbuf->b_ro_locked\" is set.\n    // Do allow \":checktime\" (it is postponed).\n    // Do allow \":edit\" (check for an argument later).\n    // Do allow \":file\" with no arguments (check for an argument later).\n    if (!(ea.argt & EX_CMDWIN)\n        && ea.cmdidx != CMD_checktime\n        && ea.cmdidx != CMD_edit\n        && ea.cmdidx != CMD_file\n        && !IS_USER_CMDIDX(ea.cmdidx)\n        && curbuf_locked()) {\n      goto doend;\n    }\n\n    if (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0) {\n      // no range allowed\n      errormsg = (char_u *)_(e_norange);\n      goto doend;\n    }\n  }\n\n  if (!ni && !(ea.argt & EX_BANG) && ea.forceit) {  // no <!> allowed\n    errormsg = (char_u *)_(e_nobang);\n    goto doend;\n  }\n\n  /*\n   * Don't complain about the range if it is not used\n   * (could happen if line_count is accidentally set to 0).\n   */\n  if (!ea.skip && !ni && (ea.argt & EX_RANGE)) {\n    // If the range is backwards, ask for confirmation and, if given, swap\n    // ea.line1 & ea.line2 so it's forwards again.\n    // When global command is busy, don't ask, will fail below.\n    if (!global_busy && ea.line1 > ea.line2) {\n      if (msg_silent == 0) {\n        if ((flags & DOCMD_VERBOSE) || exmode_active) {\n          errormsg = (char_u *)_(\"E493: Backwards range given\");\n          goto doend;\n        }\n        if (ask_yesno(_(\"Backwards range given, OK to swap\"), false) != 'y') {\n          goto doend;\n        }\n      }\n      lnum = ea.line1;\n      ea.line1 = ea.line2;\n      ea.line2 = lnum;\n    }\n    if ((errormsg = invalid_range(&ea)) != NULL) {\n      goto doend;\n    }\n  }\n\n  if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0) {\n    // default is 1, not cursor\n    ea.line2 = 1;\n  }\n\n  correct_range(&ea);\n\n  if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n      && ea.addr_type == ADDR_LINES) {\n    // Put the first line at the start of a closed fold, put the last line\n    // at the end of a closed fold.\n    (void)hasFolding(ea.line1, &ea.line1, NULL);\n    (void)hasFolding(ea.line2, NULL, &ea.line2);\n  }\n\n  /*\n   * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n   * option here, so things like % get expanded.\n   */\n  p = replace_makeprg(&ea, p, cmdlinep);\n  if (p == NULL) {\n    goto doend;\n  }\n\n  /*\n   * Skip to start of argument.\n   * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n   */\n  if (ea.cmdidx == CMD_bang) {\n    ea.arg = p;\n  } else {\n    ea.arg = skipwhite(p);\n  }\n\n  // \":file\" cannot be run with an argument when \"curbuf->b_ro_locked\" is set\n  if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked()) {\n    goto doend;\n  }\n\n  /*\n   * Check for \"++opt=val\" argument.\n   * Must be first, allow \":w ++enc=utf8 !cmd\"\n   */\n  if (ea.argt & EX_ARGOPT) {\n    while (ea.arg[0] == '+' && ea.arg[1] == '+') {\n      if (getargopt(&ea) == FAIL && !ni) {\n        errormsg = (char_u *)_(e_invarg);\n        goto doend;\n      }\n    }\n  }\n\n  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {\n    if (*ea.arg == '>') {                       // append\n      if (*++ea.arg != '>') {                   // typed wrong\n        errormsg = (char_u *)_(\"E494: Use w or w>>\");\n        goto doend;\n      }\n      ea.arg = skipwhite(ea.arg + 1);\n      ea.append = TRUE;\n    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) {  // :w !filter\n      ++ea.arg;\n      ea.usefilter = TRUE;\n    }\n  }\n\n  if (ea.cmdidx == CMD_read) {\n    if (ea.forceit) {\n      ea.usefilter = TRUE;                      // :r! filter if ea.forceit\n      ea.forceit = FALSE;\n    } else if (*ea.arg == '!') {              // :r !filter\n      ++ea.arg;\n      ea.usefilter = TRUE;\n    }\n  }\n\n  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {\n    ea.amount = 1;\n    while (*ea.arg == *ea.cmd) {                // count number of '>' or '<'\n      ++ea.arg;\n      ++ea.amount;\n    }\n    ea.arg = skipwhite(ea.arg);\n  }\n\n  /*\n   * Check for \"+command\" argument, before checking for next command.\n   * Don't do this for \":read !cmd\" and \":write !cmd\".\n   */\n  if ((ea.argt & EX_CMDARG) && !ea.usefilter) {\n    ea.do_ecmd_cmd = getargcmd(&ea.arg);\n  }\n\n  /*\n   * Check for '|' to separate commands and '\"' to start comments.\n   * Don't do this for \":read !cmd\" and \":write !cmd\".\n   */\n  if ((ea.argt & EX_TRLBAR) && !ea.usefilter) {\n    separate_nextcmd(&ea);\n  } else if (ea.cmdidx == CMD_bang\n             || ea.cmdidx == CMD_terminal\n             || ea.cmdidx == CMD_global\n             || ea.cmdidx == CMD_vglobal\n             || ea.usefilter) {\n    // Check for <newline> to end a shell command.\n    // Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n    // Any others?\n    for (p = ea.arg; *p; p++) {\n      // Remove one backslash before a newline, so that it's possible to\n      // pass a newline to the shell and also a newline that is preceded\n      // with a backslash.  This makes it impossible to end a shell\n      // command in a backslash, but that doesn't appear useful.\n      // Halving the number of backslashes is incompatible with previous\n      // versions.\n      if (*p == '\\\\' && p[1] == '\\n') {\n        STRMOVE(p, p + 1);\n      } else if (*p == '\\n') {\n        ea.nextcmd = p + 1;\n        *p = NUL;\n        break;\n      }\n    }\n  }\n\n  if ((ea.argt & EX_DFLALL) && ea.addr_count == 0) {\n    buf_T *buf;\n\n    ea.line1 = 1;\n    switch (ea.addr_type) {\n    case ADDR_LINES:\n    case ADDR_OTHER:\n      ea.line2 = curbuf->b_ml.ml_line_count;\n      break;\n    case ADDR_LOADED_BUFFERS:\n      buf = firstbuf;\n      while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {\n        buf = buf->b_next;\n      }\n      ea.line1 = buf->b_fnum;\n      buf = lastbuf;\n      while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {\n        buf = buf->b_prev;\n      }\n      ea.line2 = buf->b_fnum;\n      break;\n    case ADDR_BUFFERS:\n      ea.line1 = firstbuf->b_fnum;\n      ea.line2 = lastbuf->b_fnum;\n      break;\n    case ADDR_WINDOWS:\n      ea.line2 = LAST_WIN_NR;\n      break;\n    case ADDR_TABS:\n      ea.line2 = LAST_TAB_NR;\n      break;\n    case ADDR_TABS_RELATIVE:\n      ea.line2 = 1;\n      break;\n    case ADDR_ARGUMENTS:\n      if (ARGCOUNT == 0) {\n        ea.line1 = ea.line2 = 0;\n      } else {\n        ea.line2 = ARGCOUNT;\n      }\n      break;\n    case ADDR_QUICKFIX_VALID:\n      ea.line2 = qf_get_valid_size(&ea);\n      if (ea.line2 == 0) {\n        ea.line2 = 1;\n      }\n      break;\n    case ADDR_NONE:\n    case ADDR_UNSIGNED:\n    case ADDR_QUICKFIX:\n      IEMSG(_(\"INTERNAL: Cannot use EX_DFLALL \"\n              \"with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\"));\n      break;\n    }\n  }\n\n  // accept numbered register only when no count allowed (:put)\n  if ((ea.argt & EX_REGSTR)\n      && *ea.arg != NUL\n      // Do not allow register = for user commands\n      && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n      && !((ea.argt & EX_COUNT) && ascii_isdigit(*ea.arg))) {\n    if (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n                                 && !IS_USER_CMDIDX(ea.cmdidx)))) {\n      ea.regname = *ea.arg++;\n      // for '=' register: accept the rest of the line as an expression\n      if (ea.arg[-1] == '=' && ea.arg[0] != NUL) {\n        set_expr_line(vim_strsave(ea.arg));\n        ea.arg += STRLEN(ea.arg);\n      }\n      ea.arg = skipwhite(ea.arg);\n    }\n  }\n\n  //\n  // Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n  // count, it's a buffer name.\n  ///\n  if ((ea.argt & EX_COUNT) && ascii_isdigit(*ea.arg)\n      && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n          || ascii_iswhite(*p))) {\n    n = getdigits_long(&ea.arg, false, -1);\n    ea.arg = skipwhite(ea.arg);\n    if (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0) {\n      errormsg = (char_u *)_(e_zerocount);\n      goto doend;\n    }\n    if (ea.addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3\n      ea.line2 = n;\n      if (ea.addr_count == 0) {\n        ea.addr_count = 1;\n      }\n    } else {\n      ea.line1 = ea.line2;\n      ea.line2 += n - 1;\n      ++ea.addr_count;\n      // Be vi compatible: no error message for out of range.\n      if (ea.line2 > curbuf->b_ml.ml_line_count) {\n        ea.line2 = curbuf->b_ml.ml_line_count;\n      }\n    }\n  }\n\n  /*\n   * Check for flags: 'l', 'p' and '#'.\n   */\n  if (ea.argt & EX_FLAGS) {\n    get_flags(&ea);\n  }\n  if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n      && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0)) {\n    // no arguments allowed but there is something\n    errormsg = (char_u *)_(e_trailing);\n    goto doend;\n  }\n\n  if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL) {\n    errormsg = (char_u *)_(e_argreq);\n    goto doend;\n  }\n\n  /*\n   * Skip the command when it's not going to be executed.\n   * The commands like :if, :endif, etc. always need to be executed.\n   * Also make an exception for commands that handle a trailing command\n   * themselves.\n   */\n  if (ea.skip) {\n    switch (ea.cmdidx) {\n    // commands that need evaluation\n    case CMD_while:\n    case CMD_endwhile:\n    case CMD_for:\n    case CMD_endfor:\n    case CMD_if:\n    case CMD_elseif:\n    case CMD_else:\n    case CMD_endif:\n    case CMD_try:\n    case CMD_catch:\n    case CMD_finally:\n    case CMD_endtry:\n    case CMD_function:\n      break;\n\n    // Commands that handle '|' themselves.  Check: A command should\n    // either have the EX_TRLBAR flag, appear in this list or appear in\n    // the list at \":help :bar\".\n    case CMD_aboveleft:\n    case CMD_and:\n    case CMD_belowright:\n    case CMD_botright:\n    case CMD_browse:\n    case CMD_call:\n    case CMD_confirm:\n    case CMD_const:\n    case CMD_delfunction:\n    case CMD_djump:\n    case CMD_dlist:\n    case CMD_dsearch:\n    case CMD_dsplit:\n    case CMD_echo:\n    case CMD_echoerr:\n    case CMD_echomsg:\n    case CMD_echon:\n    case CMD_eval:\n    case CMD_execute:\n    case CMD_filter:\n    case CMD_help:\n    case CMD_hide:\n    case CMD_ijump:\n    case CMD_ilist:\n    case CMD_isearch:\n    case CMD_isplit:\n    case CMD_keepalt:\n    case CMD_keepjumps:\n    case CMD_keepmarks:\n    case CMD_keeppatterns:\n    case CMD_leftabove:\n    case CMD_let:\n    case CMD_lockmarks:\n    case CMD_lockvar:\n    case CMD_lua:\n    case CMD_match:\n    case CMD_mzscheme:\n    case CMD_noautocmd:\n    case CMD_noswapfile:\n    case CMD_perl:\n    case CMD_psearch:\n    case CMD_python:\n    case CMD_py3:\n    case CMD_python3:\n    case CMD_pythonx:\n    case CMD_pyx:\n    case CMD_return:\n    case CMD_rightbelow:\n    case CMD_ruby:\n    case CMD_silent:\n    case CMD_smagic:\n    case CMD_snomagic:\n    case CMD_substitute:\n    case CMD_syntax:\n    case CMD_tab:\n    case CMD_tcl:\n    case CMD_throw:\n    case CMD_tilde:\n    case CMD_topleft:\n    case CMD_unlet:\n    case CMD_unlockvar:\n    case CMD_verbose:\n    case CMD_vertical:\n    case CMD_wincmd:\n      break;\n\n    default:\n      goto doend;\n    }\n  }\n\n  if (ea.argt & EX_XFILE) {\n    if (expand_filename(&ea, cmdlinep, &errormsg) == FAIL) {\n      goto doend;\n    }\n  }\n\n  /*\n   * Accept buffer name.  Cannot be used at the same time with a buffer\n   * number.  Don't do this for a user command.\n   */\n  if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n      && !IS_USER_CMDIDX(ea.cmdidx)) {\n    /*\n     * :bdelete, :bwipeout and :bunload take several arguments, separated\n     * by spaces: find next space (skipping over escaped characters).\n     * The others take one argument: ignore trailing spaces.\n     */\n    if (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n        || ea.cmdidx == CMD_bunload) {\n      p = skiptowhite_esc(ea.arg);\n    } else {\n      p = ea.arg + STRLEN(ea.arg);\n      while (p > ea.arg && ascii_iswhite(p[-1])) {\n        --p;\n      }\n    }\n    ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n                               false, false);\n    if (ea.line2 < 0) {  // failed\n      goto doend;\n    }\n    ea.addr_count = 1;\n    ea.arg = skipwhite(p);\n  }\n\n  // The :try command saves the emsg_silent flag, reset it here when\n  // \":silent! try\" was used, it should only apply to :try itself.\n  if (ea.cmdidx == CMD_try && ea.did_esilent > 0) {\n    emsg_silent -= ea.did_esilent;\n    if (emsg_silent < 0) {\n      emsg_silent = 0;\n    }\n    ea.did_esilent = 0;\n  }\n\n  // 7. Execute the command.\n  if (IS_USER_CMDIDX(ea.cmdidx)) {\n    /*\n     * Execute a user-defined command.\n     */\n    do_ucmd(&ea);\n  } else {\n    /*\n     * Call the function to execute the command.\n     */\n    ea.errmsg = NULL;\n    (cmdnames[ea.cmdidx].cmd_func)(&ea);\n    if (ea.errmsg != NULL) {\n      errormsg = (char_u *)_(ea.errmsg);\n    }\n  }\n\n  /*\n   * If the command just executed called do_cmdline(), any throw or \":return\"\n   * or \":finish\" encountered there must also check the cstack of the still\n   * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n   * exception, or reanimate a returned function or finished script file and\n   * return or finish it again.\n   */\n  if (need_rethrow) {\n    do_throw(cstack);\n  } else if (check_cstack) {\n    if (source_finished(fgetline, cookie)) {\n      do_finish(&ea, TRUE);\n    } else if (getline_equal(fgetline, cookie, get_func_line)\n               && current_func_returned()) {\n      do_return(&ea, TRUE, FALSE, NULL);\n    }\n  }\n  need_rethrow = check_cstack = FALSE;\n\ndoend:\n  // can happen with zero line number\n  if (curwin->w_cursor.lnum == 0) {\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n  }\n\n  if (errormsg != NULL && *errormsg != NUL && !did_emsg) {\n    if (flags & DOCMD_VERBOSE) {\n      if (errormsg != IObuff) {\n        STRCPY(IObuff, errormsg);\n        errormsg = IObuff;\n      }\n      append_command(*cmdlinep);\n    }\n    emsg(errormsg);\n  }\n  do_errthrow(cstack,\n              (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n      ? cmdnames[(int)ea.cmdidx].cmd_name\n      : (char_u *)NULL);\n\n  undo_cmdmod(&ea, save_msg_scroll);\n  cmdmod = save_cmdmod;\n  reg_executing = save_reg_executing;\n\n  if (ea.did_sandbox) {\n    sandbox--;\n  }\n\n  if (ea.nextcmd && *ea.nextcmd == NUL) {       // not really a next command\n    ea.nextcmd = NULL;\n  }\n\n  --ex_nesting_level;\n\n  return ea.nextcmd;\n}\n\n// Parse and skip over command modifiers:\n// - update eap->cmd\n// - store flags in \"cmdmod\".\n// - Set ex_pressedreturn for an empty command line.\n// - set msg_silent for \":silent\"\n// - set 'eventignore' to \"all\" for \":noautocmd\"\n// - set p_verbose for \":verbose\"\n// - Increment \"sandbox\" for \":sandbox\"\n// When \"skip_only\" is true the global variables are not changed, except for\n// \"cmdmod\".\n// Return FAIL when the command is not to be executed.\n// May set \"errormsg\" to an error message.\nint parse_command_modifiers(exarg_T *eap, char_u **errormsg, bool skip_only)\n{\n  char_u *p;\n\n  memset(&cmdmod, 0, sizeof(cmdmod));\n  eap->verbose_save = -1;\n  eap->save_msg_silent = -1;\n\n  // Repeat until no more command modifiers are found.\n  for (;; ) {\n    while (*eap->cmd == ' '\n           || *eap->cmd == '\\t'\n           || *eap->cmd == ':') {\n      eap->cmd++;\n    }\n\n    // in ex mode, an empty line works like :+\n    if (*eap->cmd == NUL && exmode_active\n        && getline_equal(eap->getline, eap->cookie, getexline)\n        && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {\n      eap->cmd = (char_u *)\"+\";\n      if (!skip_only) {\n        ex_pressedreturn = true;\n      }\n    }\n\n    // ignore comment and empty lines\n    if (*eap->cmd == '\"') {\n      return FAIL;\n    }\n    if (*eap->cmd == NUL) {\n      if (!skip_only) {\n        ex_pressedreturn = true;\n      }\n      return FAIL;\n    }\n\n    p = skip_range(eap->cmd, NULL);\n    switch (*p) {\n    // When adding an entry, also modify cmd_exists().\n    case 'a':\n      if (!checkforcmd(&eap->cmd, \"aboveleft\", 3)) {\n        break;\n      }\n      cmdmod.split |= WSP_ABOVE;\n      continue;\n\n    case 'b':\n      if (checkforcmd(&eap->cmd, \"belowright\", 3)) {\n        cmdmod.split |= WSP_BELOW;\n        continue;\n      }\n      if (checkforcmd(&eap->cmd, \"browse\", 3)) {\n        cmdmod.browse = true;\n        continue;\n      }\n      if (!checkforcmd(&eap->cmd, \"botright\", 2)) {\n        break;\n      }\n      cmdmod.split |= WSP_BOT;\n      continue;\n\n    case 'c':\n      if (!checkforcmd(&eap->cmd, \"confirm\", 4)) {\n        break;\n      }\n      cmdmod.confirm = true;\n      continue;\n\n    case 'k':\n      if (checkforcmd(&eap->cmd, \"keepmarks\", 3)) {\n        cmdmod.keepmarks = true;\n        continue;\n      }\n      if (checkforcmd(&eap->cmd, \"keepalt\", 5)) {\n        cmdmod.keepalt = true;\n        continue;\n      }\n      if (checkforcmd(&eap->cmd, \"keeppatterns\", 5)) {\n        cmdmod.keeppatterns = true;\n        continue;\n      }\n      if (!checkforcmd(&eap->cmd, \"keepjumps\", 5)) {\n        break;\n      }\n      cmdmod.keepjumps = true;\n      continue;\n\n    case 'f': {  // only accept \":filter {pat} cmd\"\n      char_u *reg_pat;\n\n      if (!checkforcmd(&p, \"filter\", 4) || *p == NUL || ends_excmd(*p)) {\n        break;\n      }\n      if (*p == '!') {\n        cmdmod.filter_force = true;\n        p = skipwhite(p + 1);\n        if (*p == NUL || ends_excmd(*p)) {\n          break;\n        }\n      }\n      if (skip_only) {\n        p = skip_vimgrep_pat(p, NULL, NULL);\n      } else {\n        // NOTE: This puts a NUL after the pattern.\n        p = skip_vimgrep_pat(p, &reg_pat, NULL);\n      }\n      if (p == NULL || *p == NUL) {\n        break;\n      }\n      if (!skip_only) {\n        cmdmod.filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);\n        if (cmdmod.filter_regmatch.regprog == NULL) {\n          break;\n        }\n      }\n      eap->cmd = p;\n      continue;\n    }\n\n    // \":hide\" and \":hide | cmd\" are not modifiers\n    case 'h':\n      if (p != eap->cmd || !checkforcmd(&p, \"hide\", 3)\n          || *p == NUL || ends_excmd(*p)) {\n        break;\n      }\n      eap->cmd = p;\n      cmdmod.hide = true;\n      continue;\n\n    case 'l':\n      if (checkforcmd(&eap->cmd, \"lockmarks\", 3)) {\n        cmdmod.lockmarks = true;\n        continue;\n      }\n\n      if (!checkforcmd(&eap->cmd, \"leftabove\", 5)) {\n        break;\n      }\n      cmdmod.split |= WSP_ABOVE;\n      continue;\n\n    case 'n':\n      if (checkforcmd(&eap->cmd, \"noautocmd\", 3)) {\n        if (cmdmod.save_ei == NULL && !skip_only) {\n          // Set 'eventignore' to \"all\". Restore the\n          // existing option value later.\n          cmdmod.save_ei = vim_strsave(p_ei);\n          set_string_option_direct(\"ei\", -1,\n                                   (char_u *)\"all\", OPT_FREE, SID_NONE);\n        }\n        continue;\n      }\n      if (!checkforcmd(&eap->cmd, \"noswapfile\", 3)) {\n        break;\n      }\n      cmdmod.noswapfile = true;\n      continue;\n\n    case 'r':\n      if (!checkforcmd(&eap->cmd, \"rightbelow\", 6)) {\n        break;\n      }\n      cmdmod.split |= WSP_BELOW;\n      continue;\n\n    case 's':\n      if (checkforcmd(&eap->cmd, \"sandbox\", 3)) {\n        if (!skip_only) {\n          if (!eap->did_sandbox) {\n            sandbox++;\n          }\n          eap->did_sandbox = true;\n        }\n        continue;\n      }\n      if (!checkforcmd(&eap->cmd, \"silent\", 3)) {\n        break;\n      }\n      if (!skip_only) {\n        if (eap->save_msg_silent == -1) {\n          eap->save_msg_silent = msg_silent;\n        }\n        msg_silent++;\n      }\n      if (*eap->cmd == '!' && !ascii_iswhite(eap->cmd[-1])) {\n        // \":silent!\", but not \"silent !cmd\"\n        eap->cmd = skipwhite(eap->cmd + 1);\n        if (!skip_only) {\n          emsg_silent++;\n          eap->did_esilent++;\n        }\n      }\n      continue;\n\n    case 't':\n      if (checkforcmd(&p, \"tab\", 3)) {\n        if (!skip_only) {\n          long tabnr = get_address(eap, &eap->cmd, ADDR_TABS, eap->skip, skip_only, false, 1);\n\n          if (tabnr == MAXLNUM) {\n            cmdmod.tab = tabpage_index(curtab) + 1;\n          } else {\n            if (tabnr < 0 || tabnr > LAST_TAB_NR) {\n              *errormsg = (char_u *)_(e_invrange);\n              return false;\n            }\n            cmdmod.tab = tabnr + 1;\n          }\n        }\n        eap->cmd = p;\n        continue;\n      }\n      if (!checkforcmd(&eap->cmd, \"topleft\", 2)) {\n        break;\n      }\n      cmdmod.split |= WSP_TOP;\n      continue;\n\n    case 'u':\n      if (!checkforcmd(&eap->cmd, \"unsilent\", 3)) {\n        break;\n      }\n      if (!skip_only) {\n        if (eap->save_msg_silent == -1) {\n          eap->save_msg_silent = msg_silent;\n        }\n        msg_silent = 0;\n      }\n      continue;\n\n    case 'v':\n      if (checkforcmd(&eap->cmd, \"vertical\", 4)) {\n        cmdmod.split |= WSP_VERT;\n        continue;\n      }\n      if (!checkforcmd(&p, \"verbose\", 4)) {\n        break;\n      }\n      if (!skip_only) {\n        if (eap->verbose_save < 0) {\n          eap->verbose_save = p_verbose;\n        }\n        if (ascii_isdigit(*eap->cmd)) {\n          p_verbose = atoi((char *)eap->cmd);\n        } else {\n          p_verbose = 1;\n        }\n      }\n      eap->cmd = p;\n      continue;\n    }\n    break;\n  }\n\n  return OK;\n}\n\n// Undo and free contents of \"cmdmod\".\nstatic void undo_cmdmod(const exarg_T *eap, int save_msg_scroll)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (eap->verbose_save >= 0) {\n    p_verbose = eap->verbose_save;\n  }\n\n  if (cmdmod.save_ei != NULL) {\n    // Restore 'eventignore' to the value before \":noautocmd\".\n    set_string_option_direct(\"ei\", -1, cmdmod.save_ei, OPT_FREE, SID_NONE);\n    free_string_option(cmdmod.save_ei);\n  }\n\n  vim_regfree(cmdmod.filter_regmatch.regprog);\n\n  if (eap->save_msg_silent != -1) {\n    // messages could be enabled for a serious error, need to check if the\n    // counters don't become negative\n    if (!did_emsg || msg_silent > eap->save_msg_silent) {\n      msg_silent = eap->save_msg_silent;\n    }\n    emsg_silent -= eap->did_esilent;\n    if (emsg_silent < 0) {\n      emsg_silent = 0;\n    }\n    // Restore msg_scroll, it's set by file I/O commands, even when no\n    // message is actually displayed.\n    msg_scroll = save_msg_scroll;\n\n    // \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n    // somewhere in the line.  Put it back in the first column.\n    if (redirecting()) {\n      msg_col = 0;\n    }\n  }\n}\n\n\n// Parse the address range, if any, in \"eap\".\n// May set the last search pattern, unless \"silent\" is true.\n// Return FAIL and set \"errormsg\" or return OK.\nint parse_cmd_address(exarg_T *eap, char_u **errormsg, bool silent)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int address_count = 1;\n  linenr_T lnum;\n\n  // Repeat for all ',' or ';' separated addresses.\n  for (;;) {\n    eap->line1 = eap->line2;\n    switch (eap->addr_type) {\n    case ADDR_LINES:\n    case ADDR_OTHER:\n      // default is current line number\n      eap->line2 = curwin->w_cursor.lnum;\n      break;\n    case ADDR_WINDOWS:\n      eap->line2 = CURRENT_WIN_NR;\n      break;\n    case ADDR_ARGUMENTS:\n      eap->line2 = curwin->w_arg_idx + 1;\n      if (eap->line2 > ARGCOUNT) {\n        eap->line2 = ARGCOUNT;\n      }\n      break;\n    case ADDR_LOADED_BUFFERS:\n    case ADDR_BUFFERS:\n      eap->line2 = curbuf->b_fnum;\n      break;\n    case ADDR_TABS:\n      eap->line2 = CURRENT_TAB_NR;\n      break;\n    case ADDR_TABS_RELATIVE:\n    case ADDR_UNSIGNED:\n      eap->line2 = 1;\n      break;\n    case ADDR_QUICKFIX:\n      eap->line2 = qf_get_cur_idx(eap);\n      break;\n    case ADDR_QUICKFIX_VALID:\n      eap->line2 = qf_get_cur_valid_idx(eap);\n      break;\n    case ADDR_NONE:\n      // Will give an error later if a range is found.\n      break;\n    }\n    eap->cmd = skipwhite(eap->cmd);\n    lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n                       eap->addr_count == 0, address_count++);\n    if (eap->cmd == NULL) {  // error detected\n      return FAIL;\n    }\n    if (lnum == MAXLNUM) {\n      if (*eap->cmd == '%') {  // '%' - all lines\n        eap->cmd++;\n        switch (eap->addr_type) {\n        case ADDR_LINES:\n        case ADDR_OTHER:\n          eap->line1 = 1;\n          eap->line2 = curbuf->b_ml.ml_line_count;\n          break;\n        case ADDR_LOADED_BUFFERS: {\n          buf_T *buf = firstbuf;\n\n          while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {\n            buf = buf->b_next;\n          }\n          eap->line1 = buf->b_fnum;\n          buf = lastbuf;\n          while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {\n            buf = buf->b_prev;\n          }\n          eap->line2 = buf->b_fnum;\n          break;\n        }\n        case ADDR_BUFFERS:\n          eap->line1 = firstbuf->b_fnum;\n          eap->line2 = lastbuf->b_fnum;\n          break;\n        case ADDR_WINDOWS:\n        case ADDR_TABS:\n          if (IS_USER_CMDIDX(eap->cmdidx)) {\n            eap->line1 = 1;\n            eap->line2 = eap->addr_type == ADDR_WINDOWS\n                ? LAST_WIN_NR : LAST_TAB_NR;\n          } else {\n            // there is no Vim command which uses '%' and\n            // ADDR_WINDOWS or ADDR_TABS\n            *errormsg = (char_u *)_(e_invrange);\n            return FAIL;\n          }\n          break;\n        case ADDR_TABS_RELATIVE:\n        case ADDR_UNSIGNED:\n        case ADDR_QUICKFIX:\n          *errormsg = (char_u *)_(e_invrange);\n          return FAIL;\n        case ADDR_ARGUMENTS:\n          if (ARGCOUNT == 0) {\n            eap->line1 = eap->line2 = 0;\n          } else {\n            eap->line1 = 1;\n            eap->line2 = ARGCOUNT;\n          }\n          break;\n        case ADDR_QUICKFIX_VALID:\n          eap->line1 = 1;\n          eap->line2 = qf_get_valid_size(eap);\n          if (eap->line2 == 0) {\n            eap->line2 = 1;\n          }\n          break;\n        case ADDR_NONE:\n          // Will give an error later if a range is found.\n          break;\n        }\n        eap->addr_count++;\n      } else if (*eap->cmd == '*') {\n        // '*' - visual area\n        if (eap->addr_type != ADDR_LINES) {\n          *errormsg = (char_u *)_(e_invrange);\n          return FAIL;\n        }\n\n        eap->cmd++;\n        if (!eap->skip) {\n          pos_T *fp = getmark('<', false);\n          if (check_mark(fp) == FAIL) {\n            return FAIL;\n          }\n          eap->line1 = fp->lnum;\n          fp = getmark('>', false);\n          if (check_mark(fp) == FAIL) {\n            return FAIL;\n          }\n          eap->line2 = fp->lnum;\n          eap->addr_count++;\n        }\n      }\n    } else {\n      eap->line2 = lnum;\n    }\n    eap->addr_count++;\n\n    if (*eap->cmd == ';') {\n      if (!eap->skip) {\n        curwin->w_cursor.lnum = eap->line2;\n        // Don't leave the cursor on an illegal line or column, but do\n        // accept zero as address, so 0;/PATTERN/ works correctly.\n        if (eap->line2 > 0) {\n          check_cursor();\n        }\n      }\n    } else if (*eap->cmd != ',') {\n      break;\n    }\n    eap->cmd++;\n  }\n\n  // One address given: set start and end lines.\n  if (eap->addr_count == 1) {\n    eap->line1 = eap->line2;\n    // ... but only implicit: really no address given\n    if (lnum == MAXLNUM) {\n      eap->addr_count = 0;\n    }\n  }\n  return OK;\n}\n\n/// Check for an Ex command with optional tail.\n/// If there is a match advance \"pp\" to the argument and return TRUE.\n///\n/// @param pp   start of command\n/// @param cmd  name of command\n/// @param len  required length\nint checkforcmd(char_u **pp, char *cmd, int len)\n{\n  int i;\n\n  for (i = 0; cmd[i] != NUL; ++i) {\n    if (((char_u *)cmd)[i] != (*pp)[i]) {\n      break;\n    }\n  }\n  if (i >= len && !isalpha((*pp)[i])) {\n    *pp = skipwhite(*pp + i);\n    return TRUE;\n  }\n  return FALSE;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\nstatic void append_command(char_u *cmd)\n{\n  char_u *s = cmd;\n  char_u *d;\n\n  STRCAT(IObuff, \": \");\n  d = IObuff + STRLEN(IObuff);\n  while (*s != NUL && d - IObuff < IOSIZE - 7) {\n    if (s[0] == 0xc2 && s[1] == 0xa0) {\n      s += 2;\n      STRCPY(d, \"<a0>\");\n      d += 4;\n    } else {\n      MB_COPY_CHAR(s, d);\n    }\n  }\n  *d = NUL;\n}\n\n// Find an Ex command by its name, either built-in or user.\n// Start of the name can be found at eap->cmd.\n// Sets eap->cmdidx and returns a pointer to char after the command name.\n// \"full\" is set to TRUE if the whole command name matched.\n// Returns NULL for an ambiguous user command.\nstatic char_u *find_command(exarg_T *eap, int *full)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  int len;\n  char_u *p;\n  int i;\n\n  /*\n   * Isolate the command and search for it in the command table.\n   * Exceptions:\n   * - the 'k' command can directly be followed by any character.\n   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n   *        but :sre[wind] is another command, as are :scr[iptnames],\n   *        :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n   * - the \"d\" command can directly be followed by 'l' or 'p' flag.\n   */\n  p = eap->cmd;\n  if (*p == 'k') {\n    eap->cmdidx = CMD_k;\n    ++p;\n  } else if (p[0] == 's'\n             && ((p[1] == 'c'\n                  && (p[2] == NUL\n                      || (p[2] != 's' && p[2] != 'r'\n                          && (p[3] == NUL\n                              || (p[3] != 'i' && p[4] != 'p')))))\n                 || p[1] == 'g'\n                 || (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n                 || p[1] == 'I'\n                 || (p[1] == 'r' && p[2] != 'e'))) {\n    eap->cmdidx = CMD_substitute;\n    ++p;\n  } else {\n    while (ASCII_ISALPHA(*p)) {\n      ++p;\n    }\n    // for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n    if (eap->cmd[0] == 'p' && eap->cmd[1] == 'y') {\n      while (ASCII_ISALNUM(*p)) {\n        ++p;\n      }\n    }\n\n    // check for non-alpha command\n    if (p == eap->cmd && vim_strchr((char_u *)\"@!=><&~#\", *p) != NULL) {\n      ++p;\n    }\n    len = (int)(p - eap->cmd);\n    if (*eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p')) {\n      /* Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n       * :delete with the 'l' flag.  Same for 'p'. */\n      for (i = 0; i < len; ++i) {\n        if (eap->cmd[i] != ((char_u *)\"delete\")[i]) {\n          break;\n        }\n      }\n      if (i == len - 1) {\n        --len;\n        if (p[-1] == 'l') {\n          eap->flags |= EXFLAG_LIST;\n        } else {\n          eap->flags |= EXFLAG_PRINT;\n        }\n      }\n    }\n\n    if (ASCII_ISLOWER(eap->cmd[0])) {\n      const int c1 = eap->cmd[0];\n      const int c2 = len == 1 ? NUL : eap->cmd[1];\n\n      if (command_count != CMD_SIZE) {\n        iemsg((char *)_(\"E943: Command table needs to be updated, run 'make'\"));\n        getout(1);\n      }\n\n      // Use a precomputed index for fast look-up in cmdnames[]\n      // taking into account the first 2 letters of eap->cmd.\n      eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n      if (ASCII_ISLOWER(c2)) {\n        eap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n      }\n    } else {\n      eap->cmdidx = CMD_bang;\n    }\n\n    for (; (int)eap->cmdidx < CMD_SIZE;\n         eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1)) {\n      if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n                  (size_t)len) == 0) {\n        if (full != NULL\n            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL) {\n          *full = TRUE;\n        }\n        break;\n      }\n    }\n\n    // Look for a user defined command as a last resort.\n    if ((eap->cmdidx == CMD_SIZE)\n        && *eap->cmd >= 'A' && *eap->cmd <= 'Z') {\n      // User defined commands may contain digits.\n      while (ASCII_ISALNUM(*p)) {\n        ++p;\n      }\n      p = find_ucmd(eap, p, full, NULL, NULL);\n    }\n    if (p == eap->cmd) {\n      eap->cmdidx = CMD_SIZE;\n    }\n  }\n\n  return p;\n}\n\n/// Search for a user command that matches \"eap->cmd\".\n/// Return cmdidx in \"eap->cmdidx\", flags in \"eap->argt\", idx in \"eap->useridx\".\n/// Return a pointer to just after the command.\n/// Return NULL if there is no matching command.\n///\n/// @param *p      end of the command (possibly including count)\n/// @param full    set to TRUE for a full match\n/// @param xp      used for completion, NULL otherwise\n/// @param complp  completion flags or NULL\nstatic char_u *find_ucmd(exarg_T *eap, char_u *p, int *full, expand_T *xp, int *complp)\n{\n  int len = (int)(p - eap->cmd);\n  int j, k, matchlen = 0;\n  ucmd_T *uc;\n  bool found = false;\n  bool possible = false;\n  char_u *cp, *np;             // Point into typed cmd and test name\n  garray_T *gap;\n  bool amb_local = false;            // Found ambiguous buffer-local command,\n                                     // only full match global is accepted.\n\n  /*\n   * Look for buffer-local user commands first, then global ones.\n   */\n  gap = &curbuf->b_ucmds;\n  for (;; ) {\n    for (j = 0; j < gap->ga_len; ++j) {\n      uc = USER_CMD_GA(gap, j);\n      cp = eap->cmd;\n      np = uc->uc_name;\n      k = 0;\n      while (k < len && *np != NUL && *cp++ == *np++) {\n        k++;\n      }\n      if (k == len || (*np == NUL && ascii_isdigit(eap->cmd[k]))) {\n        /* If finding a second match, the command is ambiguous.  But\n         * not if a buffer-local command wasn't a full match and a\n         * global command is a full match. */\n        if (k == len && found && *np != NUL) {\n          if (gap == &ucmds) {\n            return NULL;\n          }\n          amb_local = true;\n        }\n\n        if (!found || (k == len && *np == NUL)) {\n          /* If we matched up to a digit, then there could\n           * be another command including the digit that we\n           * should use instead.\n           */\n          if (k == len) {\n            found = true;\n          } else {\n            possible = true;\n          }\n\n          if (gap == &ucmds) {\n            eap->cmdidx = CMD_USER;\n          } else {\n            eap->cmdidx = CMD_USER_BUF;\n          }\n          eap->argt = uc->uc_argt;\n          eap->useridx = j;\n          eap->addr_type = uc->uc_addr_type;\n\n          if (complp != NULL) {\n            *complp = uc->uc_compl;\n          }\n          if (xp != NULL) {\n            xp->xp_arg = uc->uc_compl_arg;\n            xp->xp_script_ctx = uc->uc_script_ctx;\n            xp->xp_script_ctx.sc_lnum += sourcing_lnum;\n          }\n          /* Do not search for further abbreviations\n           * if this is an exact match. */\n          matchlen = k;\n          if (k == len && *np == NUL) {\n            if (full != NULL) {\n              *full = TRUE;\n            }\n            amb_local = false;\n            break;\n          }\n        }\n      }\n    }\n\n    // Stop if we found a full match or searched all.\n    if (j < gap->ga_len || gap == &ucmds) {\n      break;\n    }\n    gap = &ucmds;\n  }\n\n  // Only found ambiguous matches.\n  if (amb_local) {\n    if (xp != NULL) {\n      xp->xp_context = EXPAND_UNSUCCESSFUL;\n    }\n    return NULL;\n  }\n\n  /* The match we found may be followed immediately by a number.  Move \"p\"\n   * back to point to it. */\n  if (found || possible) {\n    return p + (matchlen - len);\n  }\n  return p;\n}\n\nstatic struct cmdmod {\n  char *name;\n  int minlen;\n  int has_count;            // :123verbose  :3tab\n} cmdmods[] = {\n  { \"aboveleft\", 3, false },\n  { \"belowright\", 3, false },\n  { \"botright\", 2, false },\n  { \"browse\", 3, false },\n  { \"confirm\", 4, false },\n  { \"filter\", 4, false },\n  { \"hide\", 3, false },\n  { \"keepalt\", 5, false },\n  { \"keepjumps\", 5, false },\n  { \"keepmarks\", 3, false },\n  { \"keeppatterns\", 5, false },\n  { \"leftabove\", 5, false },\n  { \"lockmarks\", 3, false },\n  { \"noautocmd\", 3, false },\n  { \"noswapfile\", 3, false },\n  { \"rightbelow\", 6, false },\n  { \"sandbox\", 3, false },\n  { \"silent\", 3, false },\n  { \"tab\", 3, true },\n  { \"topleft\", 2, false },\n  { \"unsilent\", 3, false },\n  { \"verbose\", 4, true },\n  { \"vertical\", 4, false },\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\nint modifier_len(char_u *cmd)\n{\n  char_u *p = cmd;\n\n  if (ascii_isdigit(*cmd)) {\n    p = skipwhite(skipdigits(cmd + 1));\n  }\n  for (int i = 0; i < (int)ARRAY_SIZE(cmdmods); i++) {\n    int j;\n    for (j = 0; p[j] != NUL; j++) {\n      if (p[j] != cmdmods[i].name[j]) {\n        break;\n      }\n    }\n    if (j >= cmdmods[i].minlen\n        && !ASCII_ISALPHA(p[j])\n        && (p == cmd || cmdmods[i].has_count)) {\n      return j + (int)(p - cmd);\n    }\n  }\n  return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\nint cmd_exists(const char *const name)\n{\n  exarg_T ea;\n  char_u *p;\n\n  // Check command modifiers.\n  for (int i = 0; i < (int)ARRAY_SIZE(cmdmods); i++) {\n    int j;\n    for (j = 0; name[j] != NUL; j++) {\n      if (name[j] != cmdmods[i].name[j]) {\n        break;\n      }\n    }\n    if (name[j] == NUL && j >= cmdmods[i].minlen) {\n      return cmdmods[i].name[j] == NUL ? 2 : 1;\n    }\n  }\n\n  /* Check built-in commands and user defined commands.\n   * For \":2match\" and \":3match\" we need to skip the number. */\n  ea.cmd = (char_u *)((*name == '2' || *name == '3') ? name + 1 : name);\n  ea.cmdidx = (cmdidx_T)0;\n  int full = false;\n  p = find_command(&ea, &full);\n  if (p == NULL) {\n    return 3;\n  }\n  if (ascii_isdigit(*name) && ea.cmdidx != CMD_match) {\n    return 0;\n  }\n  if (*skipwhite(p) != NUL) {\n    return 0;           // trailing garbage\n  }\n  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);\n}\n\n/// This is all pretty much copied from do_one_cmd(), with all the extra stuff\n/// we don't need/want deleted.  Maybe this could be done better if we didn't\n/// repeat all this stuff.  The only problem is that they may not stay\n/// perfectly compatible with each other, but then the command line syntax\n/// probably won't change that much -- webb.\n///\n/// @param buff  buffer for command string\nconst char * set_one_cmd_context(expand_T *xp, const char *buff)\n{\n  size_t len = 0;\n  exarg_T ea;\n  int context = EXPAND_NOTHING;\n  bool forceit = false;\n  bool usefilter = false;  // Filter instead of file name.\n\n  ExpandInit(xp);\n  xp->xp_pattern = (char_u *)buff;\n  xp->xp_context = EXPAND_COMMANDS;  // Default until we get past command\n  ea.argt = 0;\n\n  // 2. skip comment lines and leading space, colons or bars\n  const char *cmd;\n  for (cmd = buff; vim_strchr((const char_u *)\" \\t:|\", *cmd) != NULL; cmd++) {\n  }\n  xp->xp_pattern = (char_u *)cmd;\n\n  if (*cmd == NUL) {\n    return NULL;\n  }\n  if (*cmd == '\"') {        // ignore comment lines\n    xp->xp_context = EXPAND_NOTHING;\n    return NULL;\n  }\n\n  /*\n   * 3. parse a range specifier of the form: addr [,addr] [;addr] ..\n   */\n  cmd = (const char *)skip_range((const char_u *)cmd, &xp->xp_context);\n\n  /*\n   * 4. parse command\n   */\n  xp->xp_pattern = (char_u *)cmd;\n  if (*cmd == NUL) {\n    return NULL;\n  }\n  if (*cmd == '\"') {\n    xp->xp_context = EXPAND_NOTHING;\n    return NULL;\n  }\n\n  if (*cmd == '|' || *cmd == '\\n') {\n    return cmd + 1;                     // There's another command\n  }\n  /*\n   * Isolate the command and search for it in the command table.\n   * Exceptions:\n   * - the 'k' command can directly be followed by any character, but\n   *   do accept \"keepmarks\", \"keepalt\" and \"keepjumps\".\n   * - the 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n   */\n  const char *p;\n  if (*cmd == 'k' && cmd[1] != 'e') {\n    ea.cmdidx = CMD_k;\n    p = cmd + 1;\n  } else {\n    p = cmd;\n    while (ASCII_ISALPHA(*p) || *p == '*') {  // Allow * wild card\n      p++;\n    }\n    // a user command may contain digits\n    if (ASCII_ISUPPER(cmd[0])) {\n      while (ASCII_ISALNUM(*p) || *p == '*') {\n        p++;\n      }\n    }\n    // for python 3.x: \":py3*\" commands completion\n    if (cmd[0] == 'p' && cmd[1] == 'y' && p == cmd + 2 && *p == '3') {\n      p++;\n      while (ASCII_ISALPHA(*p) || *p == '*') {\n        p++;\n      }\n    }\n    // check for non-alpha command\n    if (p == cmd && vim_strchr((const char_u *)\"@*!=><&~#\", *p) != NULL) {\n      p++;\n    }\n    len = (size_t)(p - cmd);\n\n    if (len == 0) {\n      xp->xp_context = EXPAND_UNSUCCESSFUL;\n      return NULL;\n    }\n    for (ea.cmdidx = (cmdidx_T)0; (int)ea.cmdidx < CMD_SIZE;\n         ea.cmdidx = (cmdidx_T)((int)ea.cmdidx + 1)) {\n      if (STRNCMP(cmdnames[(int)ea.cmdidx].cmd_name, cmd, len) == 0) {\n        break;\n      }\n    }\n\n    if (cmd[0] >= 'A' && cmd[0] <= 'Z') {\n      while (ASCII_ISALNUM(*p) || *p == '*') {  // Allow * wild card\n        p++;\n      }\n    }\n  }\n\n  //\n  // If the cursor is touching the command, and it ends in an alphanumeric\n  // character, complete the command name.\n  //\n  if (*p == NUL && ASCII_ISALNUM(p[-1])) {\n    return NULL;\n  }\n\n  if (ea.cmdidx == CMD_SIZE) {\n    if (*cmd == 's' && vim_strchr((const char_u *)\"cgriI\", cmd[1]) != NULL) {\n      ea.cmdidx = CMD_substitute;\n      p = cmd + 1;\n    } else if (cmd[0] >= 'A' && cmd[0] <= 'Z') {\n      ea.cmd = (char_u *)cmd;\n      p = (const char *)find_ucmd(&ea, (char_u *)p, NULL, xp, &context);\n      if (p == NULL) {\n        ea.cmdidx = CMD_SIZE;  // Ambiguous user command.\n      }\n    }\n  }\n  if (ea.cmdidx == CMD_SIZE) {\n    // Not still touching the command and it was an illegal one\n    xp->xp_context = EXPAND_UNSUCCESSFUL;\n    return NULL;\n  }\n\n  xp->xp_context = EXPAND_NOTHING;   // Default now that we're past command\n\n  if (*p == '!') {                  // forced commands\n    forceit = true;\n    p++;\n  }\n\n  /*\n   * 5. parse arguments\n   */\n  if (!IS_USER_CMDIDX(ea.cmdidx)) {\n    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;\n  }\n\n  const char *arg = (const char *)skipwhite((const char_u *)p);\n\n  // Skip over ++argopt argument\n  if ((ea.argt & EX_ARGOPT) && *arg != NUL && strncmp(arg, \"++\", 2) == 0) {\n    p = arg;\n    while (*p && !ascii_isspace(*p)) {\n      MB_PTR_ADV(p);\n    }\n    arg = (const char *)skipwhite((const char_u *)p);\n  }\n\n  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {\n    if (*arg == '>') {  // Append.\n      if (*++arg == '>') {\n        arg++;\n      }\n      arg = (const char *)skipwhite((const char_u *)arg);\n    } else if (*arg == '!' && ea.cmdidx == CMD_write) {  // :w !filter\n      arg++;\n      usefilter = true;\n    }\n  }\n\n  if (ea.cmdidx == CMD_read) {\n    usefilter = forceit;                        // :r! filter if forced\n    if (*arg == '!') {                          // :r !filter\n      arg++;\n      usefilter = true;\n    }\n  }\n\n  if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {\n    while (*arg == *cmd) {  // allow any number of '>' or '<'\n      arg++;\n    }\n    arg = (const char *)skipwhite((const char_u *)arg);\n  }\n\n  // Does command allow \"+command\"?\n  if ((ea.argt & EX_CMDARG) && !usefilter && *arg == '+') {\n    // Check if we're in the +command\n    p = arg + 1;\n    arg = (const char *)skip_cmd_arg((char_u *)arg, false);\n\n    // Still touching the command after '+'?\n    if (*arg == NUL) {\n      return p;\n    }\n\n    // Skip space(s) after +command to get to the real argument.\n    arg = (const char *)skipwhite((const char_u *)arg);\n  }\n\n  /*\n   * Check for '|' to separate commands and '\"' to start comments.\n   * Don't do this for \":read !cmd\" and \":write !cmd\".\n   */\n  if ((ea.argt & EX_TRLBAR) && !usefilter) {\n    p = arg;\n    // \":redir @\" is not the start of a comment\n    if (ea.cmdidx == CMD_redir && p[0] == '@' && p[1] == '\"') {\n      p += 2;\n    }\n    while (*p) {\n      if (*p == Ctrl_V) {\n        if (p[1] != NUL) {\n          p++;\n        }\n      } else if ((*p == '\"' && !(ea.argt & EX_NOTRLCOM))\n                 || *p == '|'\n                 || *p == '\\n') {\n        if (*(p - 1) != '\\\\') {\n          if (*p == '|' || *p == '\\n') {\n            return p + 1;\n          }\n          return NULL;              // It's a comment\n        }\n      }\n      MB_PTR_ADV(p);\n    }\n  }\n\n  if (!(ea.argt & EX_EXTRA) && *arg != NUL && strchr(\"|\\\"\", *arg) == NULL) {\n    // no arguments allowed but there is something\n    return NULL;\n  }\n\n  // Find start of last argument (argument just before cursor):\n  p = buff;\n  xp->xp_pattern = (char_u *)p;\n  len = strlen(buff);\n  while (*p && p < buff + len) {\n    if (*p == ' ' || *p == TAB) {\n      // Argument starts after a space.\n      xp->xp_pattern = (char_u *)++p;\n    } else {\n      if (*p == '\\\\' && *(p + 1) != NUL) {\n        p++;        // skip over escaped character\n      }\n      MB_PTR_ADV(p);\n    }\n  }\n\n  if (ea.argt & EX_XFILE) {\n    int c;\n    int in_quote = false;\n    const char *bow = NULL;  // Beginning of word.\n\n    /*\n     * Allow spaces within back-quotes to count as part of the argument\n     * being expanded.\n     */\n    xp->xp_pattern = skipwhite((const char_u *)arg);\n    p = (const char *)xp->xp_pattern;\n    while (*p != NUL) {\n      c = utf_ptr2char((const char_u *)p);\n      if (c == '\\\\' && p[1] != NUL) {\n        p++;\n      } else if (c == '`') {\n        if (!in_quote) {\n          xp->xp_pattern = (char_u *)p;\n          bow = p + 1;\n        }\n        in_quote = !in_quote;\n      }\n      /* An argument can contain just about everything, except\n       * characters that end the command and white space. */\n      else if (c == '|'\n               || c == '\\n'\n               || c == '\"'\n               || ascii_iswhite(c)) {\n        len = 0;          // avoid getting stuck when space is in 'isfname'\n        while (*p != NUL) {\n          c = utf_ptr2char((const char_u *)p);\n          if (c == '`' || vim_isfilec_or_wc(c)) {\n            break;\n          }\n          len = (size_t)utfc_ptr2len((const char_u *)p);\n          MB_PTR_ADV(p);\n        }\n        if (in_quote) {\n          bow = p;\n        } else {\n          xp->xp_pattern = (char_u *)p;\n        }\n        p -= len;\n      }\n      MB_PTR_ADV(p);\n    }\n\n    /*\n     * If we are still inside the quotes, and we passed a space, just\n     * expand from there.\n     */\n    if (bow != NULL && in_quote) {\n      xp->xp_pattern = (char_u *)bow;\n    }\n    xp->xp_context = EXPAND_FILES;\n\n    // For a shell command more chars need to be escaped.\n    if (usefilter || ea.cmdidx == CMD_bang || ea.cmdidx == CMD_terminal) {\n#ifndef BACKSLASH_IN_FILENAME\n      xp->xp_shell = TRUE;\n#endif\n      // When still after the command name expand executables.\n      if (xp->xp_pattern == skipwhite((const char_u *)arg)) {\n        xp->xp_context = EXPAND_SHELLCMD;\n      }\n    }\n\n    // Check for environment variable.\n    if (*xp->xp_pattern == '$') {\n      for (p = (const char *)xp->xp_pattern + 1; *p != NUL; p++) {\n        if (!vim_isIDc((uint8_t)(*p))) {\n          break;\n        }\n      }\n      if (*p == NUL) {\n        xp->xp_context = EXPAND_ENV_VARS;\n        xp->xp_pattern++;\n        // Avoid that the assignment uses EXPAND_FILES again.\n        if (context != EXPAND_USER_DEFINED && context != EXPAND_USER_LIST) {\n          context = EXPAND_ENV_VARS;\n        }\n      }\n    }\n    // Check for user names.\n    if (*xp->xp_pattern == '~') {\n      for (p = (const char *)xp->xp_pattern + 1; *p != NUL && *p != '/'; p++) {\n      }\n      // Complete ~user only if it partially matches a user name.\n      // A full match ~user<Tab> will be replaced by user's home\n      // directory i.e. something like ~user<Tab> -> /home/user/\n      if (*p == NUL && p > (const char *)xp->xp_pattern + 1\n          && match_user(xp->xp_pattern + 1) >= 1) {\n        xp->xp_context = EXPAND_USER;\n        ++xp->xp_pattern;\n      }\n    }\n  }\n\n  /*\n   * 6. switch on command name\n   */\n  switch (ea.cmdidx) {\n  case CMD_find:\n  case CMD_sfind:\n  case CMD_tabfind:\n    if (xp->xp_context == EXPAND_FILES) {\n      xp->xp_context = EXPAND_FILES_IN_PATH;\n    }\n    break;\n  case CMD_cd:\n  case CMD_chdir:\n  case CMD_lcd:\n  case CMD_lchdir:\n  case CMD_tcd:\n  case CMD_tchdir:\n    if (xp->xp_context == EXPAND_FILES) {\n      xp->xp_context = EXPAND_DIRECTORIES;\n    }\n    break;\n  case CMD_help:\n    xp->xp_context = EXPAND_HELP;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  /* Command modifiers: return the argument.\n   * Also for commands with an argument that is a command. */\n  case CMD_aboveleft:\n  case CMD_argdo:\n  case CMD_belowright:\n  case CMD_botright:\n  case CMD_browse:\n  case CMD_bufdo:\n  case CMD_cdo:\n  case CMD_cfdo:\n  case CMD_confirm:\n  case CMD_debug:\n  case CMD_folddoclosed:\n  case CMD_folddoopen:\n  case CMD_hide:\n  case CMD_keepalt:\n  case CMD_keepjumps:\n  case CMD_keepmarks:\n  case CMD_keeppatterns:\n  case CMD_ldo:\n  case CMD_leftabove:\n  case CMD_lfdo:\n  case CMD_lockmarks:\n  case CMD_noautocmd:\n  case CMD_noswapfile:\n  case CMD_rightbelow:\n  case CMD_sandbox:\n  case CMD_silent:\n  case CMD_tab:\n  case CMD_tabdo:\n  case CMD_topleft:\n  case CMD_verbose:\n  case CMD_vertical:\n  case CMD_windo:\n    return arg;\n\n  case CMD_filter:\n    if (*arg != NUL) {\n      arg = (const char *)skip_vimgrep_pat((char_u *)arg, NULL, NULL);\n    }\n    if (arg == NULL || *arg == NUL) {\n      xp->xp_context = EXPAND_NOTHING;\n      return NULL;\n    }\n    return (const char *)skipwhite((const char_u *)arg);\n\n  case CMD_match:\n    if (*arg == NUL || !ends_excmd(*arg)) {\n      // also complete \"None\"\n      set_context_in_echohl_cmd(xp, arg);\n      arg = (const char *)skipwhite(skiptowhite((const char_u *)arg));\n      if (*arg != NUL) {\n        xp->xp_context = EXPAND_NOTHING;\n        arg = (const char *)skip_regexp((char_u *)arg + 1, (uint8_t)(*arg),\n                                        p_magic, NULL);\n      }\n    }\n    return (const char *)find_nextcmd((char_u *)arg);\n\n  /*\n   * All completion for the +cmdline_compl feature goes here.\n   */\n\n  case CMD_command:\n    // Check for attributes\n    while (*arg == '-') {\n      arg++;  // Skip \"-\".\n      p = (const char *)skiptowhite((const char_u *)arg);\n      if (*p == NUL) {\n        // Cursor is still in the attribute.\n        p = strchr(arg, '=');\n        if (p == NULL) {\n          // No \"=\", so complete attribute names.\n          xp->xp_context = EXPAND_USER_CMD_FLAGS;\n          xp->xp_pattern = (char_u *)arg;\n          return NULL;\n        }\n\n        // For the -complete, -nargs and -addr attributes, we complete\n        // their arguments as well.\n        if (STRNICMP(arg, \"complete\", p - arg) == 0) {\n          xp->xp_context = EXPAND_USER_COMPLETE;\n          xp->xp_pattern = (char_u *)p + 1;\n          return NULL;\n        } else if (STRNICMP(arg, \"nargs\", p - arg) == 0) {\n          xp->xp_context = EXPAND_USER_NARGS;\n          xp->xp_pattern = (char_u *)p + 1;\n          return NULL;\n        } else if (STRNICMP(arg, \"addr\", p - arg) == 0) {\n          xp->xp_context = EXPAND_USER_ADDR_TYPE;\n          xp->xp_pattern = (char_u *)p + 1;\n          return NULL;\n        }\n        return NULL;\n      }\n      arg = (const char *)skipwhite((char_u *)p);\n    }\n\n    // After the attributes comes the new command name.\n    p = (const char *)skiptowhite((const char_u *)arg);\n    if (*p == NUL) {\n      xp->xp_context = EXPAND_USER_COMMANDS;\n      xp->xp_pattern = (char_u *)arg;\n      break;\n    }\n\n    // And finally comes a normal command.\n    return (const char *)skipwhite((const char_u *)p);\n\n  case CMD_delcommand:\n    xp->xp_context = EXPAND_USER_COMMANDS;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_global:\n  case CMD_vglobal: {\n    const int delim = (uint8_t)(*arg);  // Get the delimiter.\n    if (delim) {\n      arg++;  // Skip delimiter if there is one.\n    }\n\n    while (arg[0] != NUL && (uint8_t)arg[0] != delim) {\n      if (arg[0] == '\\\\' && arg[1] != NUL) {\n        arg++;\n      }\n      arg++;\n    }\n    if (arg[0] != NUL) {\n      return arg + 1;\n    }\n    break;\n  }\n  case CMD_and:\n  case CMD_substitute: {\n    const int delim = (uint8_t)(*arg);\n    if (delim) {\n      // Skip \"from\" part.\n      arg++;\n      arg = (const char *)skip_regexp((char_u *)arg, delim, p_magic, NULL);\n    }\n    // Skip \"to\" part.\n    while (arg[0] != NUL && (uint8_t)arg[0] != delim) {\n      if (arg[0] == '\\\\' && arg[1] != NUL) {\n        arg++;\n      }\n      arg++;\n    }\n    if (arg[0] != NUL) {  // Skip delimiter.\n      arg++;\n    }\n    while (arg[0] && strchr(\"|\\\"#\", arg[0]) == NULL) {\n      arg++;\n    }\n    if (arg[0] != NUL) {\n      return arg;\n    }\n    break;\n  }\n  case CMD_isearch:\n  case CMD_dsearch:\n  case CMD_ilist:\n  case CMD_dlist:\n  case CMD_ijump:\n  case CMD_psearch:\n  case CMD_djump:\n  case CMD_isplit:\n  case CMD_dsplit:\n    // Skip count.\n    arg = (const char *)skipwhite(skipdigits((const char_u *)arg));\n    if (*arg == '/') {  // Match regexp, not just whole words.\n      for (++arg; *arg && *arg != '/'; arg++) {\n        if (*arg == '\\\\' && arg[1] != NUL) {\n          arg++;\n        }\n      }\n      if (*arg) {\n        arg = (const char *)skipwhite((const char_u *)arg + 1);\n\n        // Check for trailing illegal characters.\n        if (*arg && strchr(\"|\\\"\\n\", *arg) == NULL) {\n          xp->xp_context = EXPAND_NOTHING;\n        } else {\n          return arg;\n        }\n      }\n    }\n    break;\n  case CMD_autocmd:\n    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, false);\n\n  case CMD_doautocmd:\n  case CMD_doautoall:\n    return (const char *)set_context_in_autocmd(xp, (char_u *)arg, true);\n  case CMD_set:\n    set_context_in_set_cmd(xp, (char_u *)arg, 0);\n    break;\n  case CMD_setglobal:\n    set_context_in_set_cmd(xp, (char_u *)arg, OPT_GLOBAL);\n    break;\n  case CMD_setlocal:\n    set_context_in_set_cmd(xp, (char_u *)arg, OPT_LOCAL);\n    break;\n  case CMD_tag:\n  case CMD_stag:\n  case CMD_ptag:\n  case CMD_ltag:\n  case CMD_tselect:\n  case CMD_stselect:\n  case CMD_ptselect:\n  case CMD_tjump:\n  case CMD_stjump:\n  case CMD_ptjump:\n    if (wop_flags & WOP_TAGFILE) {\n      xp->xp_context = EXPAND_TAGS_LISTFILES;\n    } else {\n      xp->xp_context = EXPAND_TAGS;\n    }\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_augroup:\n    xp->xp_context = EXPAND_AUGROUP;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_syntax:\n    set_context_in_syntax_cmd(xp, arg);\n    break;\n  case CMD_const:\n  case CMD_let:\n  case CMD_if:\n  case CMD_elseif:\n  case CMD_while:\n  case CMD_for:\n  case CMD_echo:\n  case CMD_echon:\n  case CMD_execute:\n  case CMD_echomsg:\n  case CMD_echoerr:\n  case CMD_call:\n  case CMD_return:\n  case CMD_cexpr:\n  case CMD_caddexpr:\n  case CMD_cgetexpr:\n  case CMD_lexpr:\n  case CMD_laddexpr:\n  case CMD_lgetexpr:\n    set_context_for_expression(xp, (char_u *)arg, ea.cmdidx);\n    break;\n\n  case CMD_unlet:\n    while ((xp->xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {\n      arg = (const char *)xp->xp_pattern + 1;\n    }\n\n    xp->xp_context = EXPAND_USER_VARS;\n    xp->xp_pattern = (char_u *)arg;\n\n    if (*xp->xp_pattern == '$') {\n      xp->xp_context = EXPAND_ENV_VARS;\n      xp->xp_pattern++;\n    }\n\n    break;\n\n  case CMD_function:\n  case CMD_delfunction:\n    xp->xp_context = EXPAND_USER_FUNC;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_echohl:\n    set_context_in_echohl_cmd(xp, arg);\n    break;\n  case CMD_highlight:\n    set_context_in_highlight_cmd(xp, arg);\n    break;\n  case CMD_cscope:\n  case CMD_lcscope:\n  case CMD_scscope:\n    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);\n    break;\n  case CMD_sign:\n    set_context_in_sign_cmd(xp, (char_u *)arg);\n    break;\n  case CMD_bdelete:\n  case CMD_bwipeout:\n  case CMD_bunload:\n    while ((xp->xp_pattern = (char_u *)strchr(arg, ' ')) != NULL) {\n      arg = (const char *)xp->xp_pattern + 1;\n    }\n    FALLTHROUGH;\n  case CMD_buffer:\n  case CMD_sbuffer:\n  case CMD_checktime:\n    xp->xp_context = EXPAND_BUFFERS;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_diffget:\n  case CMD_diffput:\n    // If current buffer is in diff mode, complete buffer names\n    // which are in diff mode, and different than current buffer.\n    xp->xp_context = EXPAND_DIFF_BUFFERS;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_USER:\n  case CMD_USER_BUF:\n    if (context != EXPAND_NOTHING) {\n      // EX_XFILE: file names are handled above.\n      if (!(ea.argt & EX_XFILE)) {\n        if (context == EXPAND_MENUS) {\n          return (const char *)set_context_in_menu_cmd(xp, cmd,\n                                                       (char_u *)arg, forceit);\n        } else if (context == EXPAND_COMMANDS) {\n          return arg;\n        } else if (context == EXPAND_MAPPINGS) {\n          return (const char *)set_context_in_map_cmd(xp, (char_u *)\"map\", (char_u *)arg, forceit,\n                                                      false, false,\n                                                      CMD_map);\n        }\n        // Find start of last argument.\n        p = arg;\n        while (*p) {\n          if (*p == ' ') {\n            // argument starts after a space\n            arg = p + 1;\n          } else if (*p == '\\\\' && *(p + 1) != NUL) {\n            p++;                // skip over escaped character\n          }\n          MB_PTR_ADV(p);\n        }\n        xp->xp_pattern = (char_u *)arg;\n      }\n      xp->xp_context = context;\n    }\n    break;\n  case CMD_map:\n  case CMD_noremap:\n  case CMD_nmap:\n  case CMD_nnoremap:\n  case CMD_vmap:\n  case CMD_vnoremap:\n  case CMD_omap:\n  case CMD_onoremap:\n  case CMD_imap:\n  case CMD_inoremap:\n  case CMD_cmap:\n  case CMD_cnoremap:\n  case CMD_lmap:\n  case CMD_lnoremap:\n  case CMD_smap:\n  case CMD_snoremap:\n  case CMD_xmap:\n  case CMD_xnoremap:\n    return (const char *)set_context_in_map_cmd(xp, (char_u *)cmd, (char_u *)arg, forceit, false,\n                                                false, ea.cmdidx);\n  case CMD_unmap:\n  case CMD_nunmap:\n  case CMD_vunmap:\n  case CMD_ounmap:\n  case CMD_iunmap:\n  case CMD_cunmap:\n  case CMD_lunmap:\n  case CMD_sunmap:\n  case CMD_xunmap:\n    return (const char *)set_context_in_map_cmd(xp, (char_u *)cmd, (char_u *)arg, forceit, false,\n                                                true, ea.cmdidx);\n  case CMD_mapclear:\n  case CMD_nmapclear:\n  case CMD_vmapclear:\n  case CMD_omapclear:\n  case CMD_imapclear:\n  case CMD_cmapclear:\n  case CMD_lmapclear:\n  case CMD_smapclear:\n  case CMD_xmapclear:\n    xp->xp_context = EXPAND_MAPCLEAR;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_abbreviate:\n  case CMD_noreabbrev:\n  case CMD_cabbrev:\n  case CMD_cnoreabbrev:\n  case CMD_iabbrev:\n  case CMD_inoreabbrev:\n    return (const char *)set_context_in_map_cmd(xp, (char_u *)cmd, (char_u *)arg, forceit, true,\n                                                false, ea.cmdidx);\n  case CMD_unabbreviate:\n  case CMD_cunabbrev:\n  case CMD_iunabbrev:\n    return (const char *)set_context_in_map_cmd(xp, (char_u *)cmd, (char_u *)arg, forceit, true,\n                                                true, ea.cmdidx);\n  case CMD_menu:\n  case CMD_noremenu:\n  case CMD_unmenu:\n  case CMD_amenu:\n  case CMD_anoremenu:\n  case CMD_aunmenu:\n  case CMD_nmenu:\n  case CMD_nnoremenu:\n  case CMD_nunmenu:\n  case CMD_vmenu:\n  case CMD_vnoremenu:\n  case CMD_vunmenu:\n  case CMD_omenu:\n  case CMD_onoremenu:\n  case CMD_ounmenu:\n  case CMD_imenu:\n  case CMD_inoremenu:\n  case CMD_iunmenu:\n  case CMD_cmenu:\n  case CMD_cnoremenu:\n  case CMD_cunmenu:\n  case CMD_tmenu:\n  case CMD_tunmenu:\n  case CMD_popup:\n  case CMD_emenu:\n    return (const char *)set_context_in_menu_cmd(xp, cmd, (char_u *)arg, forceit);\n\n  case CMD_colorscheme:\n    xp->xp_context = EXPAND_COLORS;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_compiler:\n    xp->xp_context = EXPAND_COMPILER;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_ownsyntax:\n    xp->xp_context = EXPAND_OWNSYNTAX;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_setfiletype:\n    xp->xp_context = EXPAND_FILETYPE;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_packadd:\n    xp->xp_context = EXPAND_PACKADD;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n#ifdef HAVE_WORKING_LIBINTL\n  case CMD_language:\n    p = (const char *)skiptowhite((const char_u *)arg);\n    if (*p == NUL) {\n      xp->xp_context = EXPAND_LANGUAGE;\n      xp->xp_pattern = (char_u *)arg;\n    } else {\n      if (strncmp(arg, \"messages\", p - arg) == 0\n          || strncmp(arg, \"ctype\", p - arg) == 0\n          || strncmp(arg, \"time\", p - arg) == 0\n          || strncmp(arg, \"collate\", p - arg) == 0) {\n        xp->xp_context = EXPAND_LOCALES;\n        xp->xp_pattern = skipwhite((const char_u *)p);\n      } else {\n        xp->xp_context = EXPAND_NOTHING;\n      }\n    }\n    break;\n#endif\n  case CMD_profile:\n    set_context_in_profile_cmd(xp, arg);\n    break;\n  case CMD_checkhealth:\n    xp->xp_context = EXPAND_CHECKHEALTH;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_behave:\n    xp->xp_context = EXPAND_BEHAVE;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_messages:\n    xp->xp_context = EXPAND_MESSAGES;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_history:\n    xp->xp_context = EXPAND_HISTORY;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n  case CMD_syntime:\n    xp->xp_context = EXPAND_SYNTIME;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_argdelete:\n    while ((xp->xp_pattern = vim_strchr((const char_u *)arg, ' ')) != NULL) {\n      arg = (const char *)(xp->xp_pattern + 1);\n    }\n    xp->xp_context = EXPAND_ARGLIST;\n    xp->xp_pattern = (char_u *)arg;\n    break;\n\n  case CMD_lua:\n    xp->xp_context = EXPAND_LUA;\n    break;\n\n  default:\n    break;\n  }\n  return NULL;\n}\n\n/// Skip a range specifier of the form: addr [,addr] [;addr] ..\n///\n/// Backslashed delimiters after / or ? will be skipped, and commands will\n/// not be expanded between /'s and ?'s or after \"'\".\n///\n/// Also skip white space and \":\" characters.\n///\n/// @param ctx  pointer to xp_context or NULL\n///\n/// @return the \"cmd\" pointer advanced to beyond the range.\nchar_u *skip_range(const char_u *cmd, int *ctx)\n{\n  unsigned delim;\n\n  while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL) {\n    if (*cmd == '\\\\') {\n      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&') {\n        cmd++;\n      } else {\n        break;\n      }\n    } else if (*cmd == '\\'') {\n      if (*++cmd == NUL && ctx != NULL) {\n        *ctx = EXPAND_NOTHING;\n      }\n    } else if (*cmd == '/' || *cmd == '?') {\n      delim = *cmd++;\n      while (*cmd != NUL && *cmd != delim) {\n        if (*cmd++ == '\\\\' && *cmd != NUL) {\n          ++cmd;\n        }\n      }\n      if (*cmd == NUL && ctx != NULL) {\n        *ctx = EXPAND_NOTHING;\n      }\n    }\n    if (*cmd != NUL) {\n      ++cmd;\n    }\n  }\n\n  // Skip \":\" and white space.\n  cmd = skip_colon_white(cmd, false);\n\n  return (char_u *)cmd;\n}\n\nstatic void addr_error(cmd_addr_T addr_type)\n{\n  if (addr_type == ADDR_NONE) {\n    EMSG(_(e_norange));\n  } else {\n    EMSG(_(e_invrange));\n  }\n}\n\n/// Get a single EX address\n///\n/// Set ptr to the next character after the part that was interpreted.\n/// Set ptr to NULL when an error is encountered.\n/// This may set the last used search pattern.\n///\n/// @param skip           only skip the address, don't use it\n/// @param silent         no errors or side effects\n/// @param to_other_file  flag: may jump to other file\n/// @param address_count  1 for first, >1 after comma\n///\n/// @return               MAXLNUM when no Ex address was found.\nstatic linenr_T get_address(exarg_T *eap, char_u **ptr, cmd_addr_T addr_type, int skip, bool silent,\n                            int to_other_file, int address_count)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int c;\n  int i;\n  long n;\n  char_u *cmd;\n  pos_T pos;\n  pos_T *fp;\n  linenr_T lnum;\n  buf_T *buf;\n\n  cmd = skipwhite(*ptr);\n  lnum = MAXLNUM;\n  do {\n    switch (*cmd) {\n    case '.':                               // '.' - Cursor position\n      ++cmd;\n      switch (addr_type) {\n      case ADDR_LINES:\n      case ADDR_OTHER:\n        lnum = curwin->w_cursor.lnum;\n        break;\n      case ADDR_WINDOWS:\n        lnum = CURRENT_WIN_NR;\n        break;\n      case ADDR_ARGUMENTS:\n        lnum = curwin->w_arg_idx + 1;\n        break;\n      case ADDR_LOADED_BUFFERS:\n      case ADDR_BUFFERS:\n        lnum = curbuf->b_fnum;\n        break;\n      case ADDR_TABS:\n        lnum = CURRENT_TAB_NR;\n        break;\n      case ADDR_NONE:\n      case ADDR_TABS_RELATIVE:\n      case ADDR_UNSIGNED:\n        addr_error(addr_type);\n        cmd = NULL;\n        goto error;\n        break;\n      case ADDR_QUICKFIX:\n        lnum = qf_get_cur_idx(eap);\n        break;\n      case ADDR_QUICKFIX_VALID:\n        lnum = qf_get_cur_valid_idx(eap);\n        break;\n      }\n      break;\n\n    case '$':                               // '$' - last line\n      ++cmd;\n      switch (addr_type) {\n      case ADDR_LINES:\n      case ADDR_OTHER:\n        lnum = curbuf->b_ml.ml_line_count;\n        break;\n      case ADDR_WINDOWS:\n        lnum = LAST_WIN_NR;\n        break;\n      case ADDR_ARGUMENTS:\n        lnum = ARGCOUNT;\n        break;\n      case ADDR_LOADED_BUFFERS:\n        buf = lastbuf;\n        while (buf->b_ml.ml_mfp == NULL) {\n          if (buf->b_prev == NULL) {\n            break;\n          }\n          buf = buf->b_prev;\n        }\n        lnum = buf->b_fnum;\n        break;\n      case ADDR_BUFFERS:\n        lnum = lastbuf->b_fnum;\n        break;\n      case ADDR_TABS:\n        lnum = LAST_TAB_NR;\n        break;\n      case ADDR_NONE:\n      case ADDR_TABS_RELATIVE:\n      case ADDR_UNSIGNED:\n        addr_error(addr_type);\n        cmd = NULL;\n        goto error;\n        break;\n      case ADDR_QUICKFIX:\n        lnum = qf_get_size(eap);\n        if (lnum == 0) {\n          lnum = 1;\n        }\n        break;\n      case ADDR_QUICKFIX_VALID:\n        lnum = qf_get_valid_size(eap);\n        if (lnum == 0) {\n          lnum = 1;\n        }\n        break;\n      }\n      break;\n\n    case '\\'':                              // ''' - mark\n      if (*++cmd == NUL) {\n        cmd = NULL;\n        goto error;\n      }\n      if (addr_type != ADDR_LINES) {\n        addr_error(addr_type);\n        cmd = NULL;\n        goto error;\n      }\n      if (skip) {\n        ++cmd;\n      } else {\n        /* Only accept a mark in another file when it is\n         * used by itself: \":'M\". */\n        fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n        ++cmd;\n        if (fp == (pos_T *)-1) {\n          // Jumped to another file.\n          lnum = curwin->w_cursor.lnum;\n        } else {\n          if (check_mark(fp) == FAIL) {\n            cmd = NULL;\n            goto error;\n          }\n          lnum = fp->lnum;\n        }\n      }\n      break;\n\n    case '/':\n    case '?':                           // '/' or '?' - search\n      c = *cmd++;\n      if (addr_type != ADDR_LINES) {\n        addr_error(addr_type);\n        cmd = NULL;\n        goto error;\n      }\n      if (skip) {                       // skip \"/pat/\"\n        cmd = skip_regexp(cmd, c, p_magic, NULL);\n        if (*cmd == c) {\n          ++cmd;\n        }\n      } else {\n        int flags;\n\n        pos = curwin->w_cursor;  // save curwin->w_cursor\n\n        // When '/' or '?' follows another address, start from\n        // there.\n        if (lnum != MAXLNUM) {\n          curwin->w_cursor.lnum = lnum;\n        }\n\n        // Start a forward search at the end of the line (unless\n        // before the first line).\n        // Start a backward search at the start of the line.\n        // This makes sure we never match in the current\n        // line, and can match anywhere in the\n        // next/previous line.\n        if (c == '/' && curwin->w_cursor.lnum > 0) {\n          curwin->w_cursor.col = MAXCOL;\n        } else {\n          curwin->w_cursor.col = 0;\n        }\n        searchcmdlen = 0;\n        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n        if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) {\n          curwin->w_cursor = pos;\n          cmd = NULL;\n          goto error;\n        }\n        lnum = curwin->w_cursor.lnum;\n        curwin->w_cursor = pos;\n        // adjust command string pointer\n        cmd += searchcmdlen;\n      }\n      break;\n\n    case '\\\\':                      // \"\\?\", \"\\/\" or \"\\&\", repeat search\n      ++cmd;\n      if (addr_type != ADDR_LINES) {\n        addr_error(addr_type);\n        cmd = NULL;\n        goto error;\n      }\n      if (*cmd == '&') {\n        i = RE_SUBST;\n      } else if (*cmd == '?' || *cmd == '/') {\n        i = RE_SEARCH;\n      } else {\n        EMSG(_(e_backslash));\n        cmd = NULL;\n        goto error;\n      }\n\n      if (!skip) {\n        // When search follows another address, start from there.\n        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin->w_cursor.lnum;\n        // Start the search just like for the above do_search().\n        pos.col = (*cmd != '?') ? MAXCOL : 0;\n        pos.coladd = 0;\n        if (searchit(curwin, curbuf, &pos, NULL,\n                     *cmd == '?' ? BACKWARD : FORWARD,\n                     (char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL) {\n          lnum = pos.lnum;\n        } else {\n          cmd = NULL;\n          goto error;\n        }\n      }\n      ++cmd;\n      break;\n\n    default:\n      if (ascii_isdigit(*cmd)) {                // absolute line number\n        lnum = getdigits_long(&cmd, false, 0);\n      }\n    }\n\n    for (;; ) {\n      cmd = skipwhite(cmd);\n      if (*cmd != '-' && *cmd != '+' && !ascii_isdigit(*cmd)) {\n        break;\n      }\n\n      if (lnum == MAXLNUM) {\n        switch (addr_type) {\n        case ADDR_LINES:\n        case ADDR_OTHER:\n          // \"+1\" is same as \".+1\"\n          lnum = curwin->w_cursor.lnum;\n          break;\n        case ADDR_WINDOWS:\n          lnum = CURRENT_WIN_NR;\n          break;\n        case ADDR_ARGUMENTS:\n          lnum = curwin->w_arg_idx + 1;\n          break;\n        case ADDR_LOADED_BUFFERS:\n        case ADDR_BUFFERS:\n          lnum = curbuf->b_fnum;\n          break;\n        case ADDR_TABS:\n          lnum = CURRENT_TAB_NR;\n          break;\n        case ADDR_TABS_RELATIVE:\n          lnum = 1;\n          break;\n        case ADDR_QUICKFIX:\n          lnum = qf_get_cur_idx(eap);\n          break;\n        case ADDR_QUICKFIX_VALID:\n          lnum = qf_get_cur_valid_idx(eap);\n          break;\n        case ADDR_NONE:\n        case ADDR_UNSIGNED:\n          lnum = 0;\n          break;\n        }\n      }\n\n      if (ascii_isdigit(*cmd)) {\n        i = '+';                        // \"number\" is same as \"+number\"\n      } else {\n        i = *cmd++;\n      }\n      if (!ascii_isdigit(*cmd)) {       // '+' is '+1', but '+0' is not '+1'\n        n = 1;\n      } else {\n        n = getdigits(&cmd, true, 0);\n      }\n\n      if (addr_type == ADDR_TABS_RELATIVE) {\n        EMSG(_(e_invrange));\n        cmd = NULL;\n        goto error;\n      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {\n        lnum = compute_buffer_local_count(addr_type, lnum, (i == '-') ? -1 * n : n);\n      } else {\n        // Relative line addressing, need to adjust for folded lines\n        // now, but only do it after the first address.\n        if (addr_type == ADDR_LINES && (i == '-' || i == '+')\n            && address_count >= 2) {\n          (void)hasFolding(lnum, NULL, &lnum);\n        }\n        if (i == '-') {\n          lnum -= n;\n        } else {\n          lnum += n;\n        }\n      }\n    }\n  } while (*cmd == '/' || *cmd == '?');\n\nerror:\n  *ptr = cmd;\n  return lnum;\n}\n\n/*\n * Get flags from an Ex command argument.\n */\nstatic void get_flags(exarg_T *eap)\n{\n  while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL) {\n    if (*eap->arg == 'l') {\n      eap->flags |= EXFLAG_LIST;\n    } else if (*eap->arg == 'p') {\n      eap->flags |= EXFLAG_PRINT;\n    } else {\n      eap->flags |= EXFLAG_NR;\n    }\n    eap->arg = skipwhite(eap->arg + 1);\n  }\n}\n\n/// Stub function for command which is Not Implemented. NI!\nvoid ex_ni(exarg_T *eap)\n{\n  if (!eap->skip) {\n    eap->errmsg = (char_u *)N_(\"E319: The command is not available in this version\");\n  }\n}\n\n/// Stub function for script command which is Not Implemented. NI!\n/// Skips over \":perl <<EOF\" constructs.\nstatic void ex_script_ni(exarg_T *eap)\n{\n  if (!eap->skip) {\n    ex_ni(eap);\n  } else {\n    size_t len;\n    xfree(script_get(eap, &len));\n  }\n}\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\nstatic char_u *invalid_range(exarg_T *eap)\n{\n  buf_T *buf;\n  if (eap->line1 < 0 || eap->line2 < 0 || eap->line1 > eap->line2) {\n    return (char_u *)_(e_invrange);\n  }\n\n  if (eap->argt & EX_RANGE) {\n    switch (eap->addr_type) {\n    case ADDR_LINES:\n      if (eap->line2 > (curbuf->b_ml.ml_line_count\n                        + (eap->cmdidx == CMD_diffget))) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_ARGUMENTS:\n      // add 1 if ARGCOUNT is 0\n      if (eap->line2 > ARGCOUNT + (!ARGCOUNT)) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_BUFFERS:\n      if (eap->line1 < firstbuf->b_fnum\n          || eap->line2 > lastbuf->b_fnum) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_LOADED_BUFFERS:\n      buf = firstbuf;\n      while (buf->b_ml.ml_mfp == NULL) {\n        if (buf->b_next == NULL) {\n          return (char_u *)_(e_invrange);\n        }\n        buf = buf->b_next;\n      }\n      if (eap->line1 < buf->b_fnum) {\n        return (char_u *)_(e_invrange);\n      }\n      buf = lastbuf;\n      while (buf->b_ml.ml_mfp == NULL) {\n        if (buf->b_prev == NULL) {\n          return (char_u *)_(e_invrange);\n        }\n        buf = buf->b_prev;\n      }\n      if (eap->line2 > buf->b_fnum) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_WINDOWS:\n      if (eap->line2 > LAST_WIN_NR) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_TABS:\n      if (eap->line2 > LAST_TAB_NR) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_TABS_RELATIVE:\n    case ADDR_OTHER:\n      // Any range is OK.\n      break;\n    case ADDR_QUICKFIX:\n      assert(eap->line2 >= 0);\n      // No error for value that is too big, will use the last entry.\n      if (eap->line2 <= 0) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_QUICKFIX_VALID:\n      if ((eap->line2 != 1 && (size_t)eap->line2 > qf_get_valid_size(eap))\n          || eap->line2 < 0) {\n        return (char_u *)_(e_invrange);\n      }\n      break;\n    case ADDR_UNSIGNED:\n    case ADDR_NONE:\n      // Will give an error elsewhere.\n      break;\n    }\n  }\n  return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\nstatic void correct_range(exarg_T *eap)\n{\n  if (!(eap->argt & EX_ZEROR)) {  // zero in range not allowed\n    if (eap->line1 == 0) {\n      eap->line1 = 1;\n    }\n    if (eap->line2 == 0) {\n      eap->line2 = 1;\n    }\n  }\n}\n\n\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\nstatic char_u *skip_grep_pat(exarg_T *eap)\n{\n  char_u *p = eap->arg;\n\n  if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n                    || eap->cmdidx == CMD_vimgrepadd\n                    || eap->cmdidx == CMD_lvimgrepadd\n                    || grep_internal(eap->cmdidx))) {\n    p = skip_vimgrep_pat(p, NULL, NULL);\n    if (p == NULL) {\n      p = eap->arg;\n    }\n  }\n  return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\nstatic char_u *replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n  char_u *new_cmdline;\n  char_u *program;\n  char_u *pos;\n  char_u *ptr;\n  int len;\n  int i;\n\n  /*\n   * Don't do it when \":vimgrep\" is used for \":grep\".\n   */\n  if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n       || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n       || eap->cmdidx == CMD_grepadd\n       || eap->cmdidx == CMD_lgrepadd)\n      && !grep_internal(eap->cmdidx)) {\n    if (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n        || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd) {\n      if (*curbuf->b_p_gp == NUL) {\n        program = p_gp;\n      } else {\n        program = curbuf->b_p_gp;\n      }\n    } else {\n      if (*curbuf->b_p_mp == NUL) {\n        program = p_mp;\n      } else {\n        program = curbuf->b_p_mp;\n      }\n    }\n\n    p = skipwhite(p);\n\n    if ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL) {\n      // replace $* by given arguments\n      i = 1;\n      while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL) {\n        ++i;\n      }\n      len = (int)STRLEN(p);\n      new_cmdline = xmalloc(STRLEN(program) + i * (len - 2) + 1);\n      ptr = new_cmdline;\n      while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL) {\n        i = (int)(pos - program);\n        memcpy(ptr, program, i);\n        STRCPY(ptr += i, p);\n        ptr += len;\n        program = pos + 2;\n      }\n      STRCPY(ptr, program);\n    } else {\n      new_cmdline = xmalloc(STRLEN(program) + STRLEN(p) + 2);\n      STRCPY(new_cmdline, program);\n      STRCAT(new_cmdline, \" \");\n      STRCAT(new_cmdline, p);\n    }\n    msg_make(p);\n\n    // 'eap->cmd' is not set here, because it is not used at CMD_make\n    xfree(*cmdlinep);\n    *cmdlinep = new_cmdline;\n    p = new_cmdline;\n  }\n  return p;\n}\n\n// Expand file name in Ex command argument.\n// When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n// Return FAIL for failure, OK otherwise.\nint expand_filename(exarg_T *eap, char_u **cmdlinep, char_u **errormsgp)\n{\n  int has_wildcards;            // need to expand wildcards\n  char_u *repl;\n  size_t srclen;\n  char_u *p;\n  int escaped;\n\n  // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n  p = skip_grep_pat(eap);\n\n  /*\n   * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n   * the file name contains a wildcard it should not cause expanding.\n   * (it will be expanded anyway if there is a wildcard before replacing).\n   */\n  has_wildcards = path_has_wildcard(p);\n  while (*p != NUL) {\n    // Skip over `=expr`, wildcards in it are not expanded.\n    if (p[0] == '`' && p[1] == '=') {\n      p += 2;\n      (void)skip_expr(&p);\n      if (*p == '`') {\n        ++p;\n      }\n      continue;\n    }\n    /*\n     * Quick check if this cannot be the start of a special string.\n     * Also removes backslash before '%', '#' and '<'.\n     */\n    if (vim_strchr((char_u *)\"%#<\", *p) == NULL) {\n      ++p;\n      continue;\n    }\n\n    /*\n     * Try to find a match at this position.\n     */\n    repl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n                     errormsgp, &escaped);\n    if (*errormsgp != NULL) {           // error detected\n      return FAIL;\n    }\n    if (repl == NULL) {                 // no match found\n      p += srclen;\n      continue;\n    }\n\n    /* Wildcards won't be expanded below, the replacement is taken\n     * literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\". */\n    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {\n      char_u *l = repl;\n\n      repl = expand_env_save(repl);\n      xfree(l);\n    }\n\n    /* Need to escape white space et al. with a backslash.\n     * Don't do this for:\n     * - replacement that already has been escaped: \"##\"\n     * - shell commands (may have to use quotes instead).\n     */\n    if (!eap->usefilter\n        && !escaped\n        && eap->cmdidx != CMD_bang\n        && eap->cmdidx != CMD_grep\n        && eap->cmdidx != CMD_grepadd\n        && eap->cmdidx != CMD_hardcopy\n        && eap->cmdidx != CMD_lgrep\n        && eap->cmdidx != CMD_lgrepadd\n        && eap->cmdidx != CMD_lmake\n        && eap->cmdidx != CMD_make\n        && eap->cmdidx != CMD_terminal\n        && !(eap->argt & EX_NOSPC)) {\n      char_u *l;\n#ifdef BACKSLASH_IN_FILENAME\n      /* Don't escape a backslash here, because rem_backslash() doesn't\n       * remove it later. */\n      static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n      for (l = repl; *l; ++l) {\n        if (vim_strchr(ESCAPE_CHARS, *l) != NULL) {\n          l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n          xfree(repl);\n          repl = l;\n          break;\n        }\n      }\n    }\n\n    // For a shell command a '!' must be escaped.\n    if ((eap->usefilter\n         || eap->cmdidx == CMD_bang\n         || eap->cmdidx == CMD_terminal)\n        && vim_strpbrk(repl, (char_u *)\"!\") != NULL) {\n      char_u *l;\n\n      l = vim_strsave_escaped(repl, (char_u *)\"!\");\n      xfree(repl);\n      repl = l;\n    }\n\n    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n    xfree(repl);\n  }\n\n  /*\n   * One file argument: Expand wildcards.\n   * Don't do this with \":r !command\" or \":w !command\".\n   */\n  if ((eap->argt & EX_NOSPC) && !eap->usefilter) {\n    // Replace environment variables.\n    if (has_wildcards) {\n      /*\n       * May expand environment variables.  This\n       * can be done much faster with expand_env() than with\n       * something else (e.g., calling a shell).\n       * After expanding environment variables, check again\n       * if there are still wildcards present.\n       */\n      if (vim_strchr(eap->arg, '$') != NULL\n          || vim_strchr(eap->arg, '~') != NULL) {\n        expand_env_esc(eap->arg, NameBuff, MAXPATHL, true, true, NULL);\n        has_wildcards = path_has_wildcard(NameBuff);\n        p = NameBuff;\n      } else {\n        p = NULL;\n      }\n      if (p != NULL) {\n        (void)repl_cmdline(eap, eap->arg, STRLEN(eap->arg), p, cmdlinep);\n      }\n    }\n\n    /*\n     * Halve the number of backslashes (this is Vi compatible).\n     * For Unix, when wildcards are expanded, this is\n     * done by ExpandOne() below.\n     */\n#ifdef UNIX\n    if (!has_wildcards)\n#endif\n    backslash_halve(eap->arg);\n\n    if (has_wildcards) {\n      expand_T xpc;\n      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;\n\n      ExpandInit(&xpc);\n      xpc.xp_context = EXPAND_FILES;\n      if (p_wic) {\n        options += WILD_ICASE;\n      }\n      p = ExpandOne(&xpc, eap->arg, NULL, options, WILD_EXPAND_FREE);\n      if (p == NULL) {\n        return FAIL;\n      }\n      (void)repl_cmdline(eap, eap->arg, STRLEN(eap->arg), p, cmdlinep);\n      xfree(p);\n    }\n  }\n  return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n */\nstatic char_u *repl_cmdline(exarg_T *eap, char_u *src, size_t srclen, char_u *repl,\n                            char_u **cmdlinep)\n{\n  /*\n   * The new command line is build in new_cmdline[].\n   * First allocate it.\n   * Careful: a \"+cmd\" argument may have been NUL terminated.\n   */\n  size_t len = STRLEN(repl);\n  size_t i = (size_t)(src - *cmdlinep) + STRLEN(src + srclen) + len + 3;\n  if (eap->nextcmd != NULL) {\n    i += STRLEN(eap->nextcmd);    // add space for next command\n  }\n  char_u *new_cmdline = xmalloc(i);\n\n  /*\n   * Copy the stuff before the expanded part.\n   * Copy the expanded stuff.\n   * Copy what came after the expanded part.\n   * Copy the next commands, if there are any.\n   */\n  i = (size_t)(src - *cmdlinep);   // length of part before match\n  memmove(new_cmdline, *cmdlinep, i);\n\n  memmove(new_cmdline + i, repl, len);\n  i += len;                             // remember the end of the string\n  STRCPY(new_cmdline + i, src + srclen);\n  src = new_cmdline + i;                // remember where to continue\n\n  if (eap->nextcmd != NULL) {           // append next command\n    i = STRLEN(new_cmdline) + 1;\n    STRCPY(new_cmdline + i, eap->nextcmd);\n    eap->nextcmd = new_cmdline + i;\n  }\n  eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n  eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n  if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command) {\n    eap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n  }\n  xfree(*cmdlinep);\n  *cmdlinep = new_cmdline;\n\n  return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n */\nvoid separate_nextcmd(exarg_T *eap)\n{\n  char_u *p;\n\n  p = skip_grep_pat(eap);\n\n  for (; *p; MB_PTR_ADV(p)) {\n    if (*p == Ctrl_V) {\n      if (eap->argt & (EX_CTRLV | EX_XFILE)) {\n        p++;  // skip CTRL-V and next char\n      } else {\n        // remove CTRL-V and skip next char\n        STRMOVE(p, p + 1);\n      }\n      if (*p == NUL) {  // stop at NUL after CTRL-V\n        break;\n      }\n    } else if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE)) {\n      // Skip over `=expr` when wildcards are expanded.\n      p += 2;\n      (void)skip_expr(&p);\n      if (*p == NUL) {  // stop at NUL after CTRL-V\n        break;\n      }\n    } else if (\n               // Check for '\"': start of comment or '|': next command */\n               // :@\" does not start a comment!\n               // :redir @\" doesn't either.\n               (*p == '\"'\n                && !(eap->argt & EX_NOTRLCOM)\n                && (eap->cmdidx != CMD_at || p != eap->arg)\n                && (eap->cmdidx != CMD_redir\n                    || p != eap->arg + 1 || p[-1] != '@'))\n               || *p == '|'\n               || *p == '\\n') {\n      // We remove the '\\' before the '|', unless EX_CTRLV is used\n      // AND 'b' is present in 'cpoptions'.\n      if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n           || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\') {\n        STRMOVE(p - 1, p);  // remove the '\\'\n        p--;\n      } else {\n        eap->nextcmd = check_nextcmd(p);\n        *p = NUL;\n        break;\n      }\n    }\n  }\n\n  if (!(eap->argt & EX_NOTRLCOM)) {  // remove trailing spaces\n    del_trailing_spaces(eap->arg);\n  }\n}\n\n/*\n * get + command from ex argument\n */\nstatic char_u *getargcmd(char_u **argp)\n{\n  char_u *arg = *argp;\n  char_u *command = NULL;\n\n  if (*arg == '+') {        // +[command]\n    ++arg;\n    if (ascii_isspace(*arg) || *arg == '\\0') {\n      command = dollar_command;\n    } else {\n      command = arg;\n      arg = skip_cmd_arg(command, TRUE);\n      if (*arg != NUL) {\n        *arg++ = NUL;                   // terminate command with NUL\n      }\n    }\n\n    arg = skipwhite(arg);       // skip over spaces\n    *argp = arg;\n  }\n  return command;\n}\n\n/// Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n///\n/// @param rembs  TRUE to halve the number of backslashes\nstatic char_u *skip_cmd_arg(char_u *p, int rembs)\n{\n  while (*p && !ascii_isspace(*p)) {\n    if (*p == '\\\\' && p[1] != NUL) {\n      if (rembs) {\n        STRMOVE(p, p + 1);\n      } else {\n        ++p;\n      }\n    }\n    MB_PTR_ADV(p);\n  }\n  return p;\n}\n\nint get_bad_opt(const char_u *p, exarg_T *eap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (STRICMP(p, \"keep\") == 0) {\n    eap->bad_char = BAD_KEEP;\n  } else if (STRICMP(p, \"drop\") == 0) {\n    eap->bad_char = BAD_DROP;\n  } else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL) {\n    eap->bad_char = *p;\n  } else {\n    return FAIL;\n  }\n  return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\nstatic int getargopt(exarg_T *eap)\n{\n  char_u *arg = eap->arg + 2;\n  int *pp = NULL;\n  int bad_char_idx;\n  char_u *p;\n\n  // \":edit ++[no]bin[ary] file\"\n  if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0) {\n    if (*arg == 'n') {\n      arg += 2;\n      eap->force_bin = FORCE_NOBIN;\n    } else {\n      eap->force_bin = FORCE_BIN;\n    }\n    if (!checkforcmd(&arg, \"binary\", 3)) {\n      return FAIL;\n    }\n    eap->arg = skipwhite(arg);\n    return OK;\n  }\n\n  // \":read ++edit file\"\n  if (STRNCMP(arg, \"edit\", 4) == 0) {\n    eap->read_edit = TRUE;\n    eap->arg = skipwhite(arg + 4);\n    return OK;\n  }\n\n  if (STRNCMP(arg, \"ff\", 2) == 0) {\n    arg += 2;\n    pp = &eap->force_ff;\n  } else if (STRNCMP(arg, \"fileformat\", 10) == 0) {\n    arg += 10;\n    pp = &eap->force_ff;\n  } else if (STRNCMP(arg, \"enc\", 3) == 0) {\n    if (STRNCMP(arg, \"encoding\", 8) == 0) {\n      arg += 8;\n    } else {\n      arg += 3;\n    }\n    pp = &eap->force_enc;\n  } else if (STRNCMP(arg, \"bad\", 3) == 0) {\n    arg += 3;\n    pp = &bad_char_idx;\n  }\n\n  if (pp == NULL || *arg != '=') {\n    return FAIL;\n  }\n\n  ++arg;\n  *pp = (int)(arg - eap->cmd);\n  arg = skip_cmd_arg(arg, FALSE);\n  eap->arg = skipwhite(arg);\n  *arg = NUL;\n\n  if (pp == &eap->force_ff) {\n    if (check_ff_value(eap->cmd + eap->force_ff) == FAIL) {\n      return FAIL;\n    }\n    eap->force_ff = eap->cmd[eap->force_ff];\n  } else if (pp == &eap->force_enc) {\n    // Make 'fileencoding' lower case.\n    for (p = eap->cmd + eap->force_enc; *p != NUL; ++p) {\n      *p = TOLOWER_ASC(*p);\n    }\n  } else {\n    /* Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n     * \"drop\". */\n    if (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL) {\n      return FAIL;\n    }\n  }\n\n  return OK;\n}\n\n/// Handle the argument for a tabpage related ex command.\n/// Returns a tabpage number.\n/// When an error is encountered then eap->errmsg is set.\nstatic int get_tabpage_arg(exarg_T *eap)\n{\n  int tab_number = 0;\n  int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n  if (eap->arg && *eap->arg != NUL) {\n    char_u *p = eap->arg;\n    char_u *p_save;\n    int relative = 0;  // argument +N/-N means: go to N places to the\n                       // right/left relative to the current position.\n\n    if (*p == '-') {\n      relative = -1;\n      p++;\n    } else if (*p == '+') {\n      relative = 1;\n      p++;\n    }\n\n    p_save = p;\n    tab_number = getdigits(&p, false, tab_number);\n\n    if (relative == 0) {\n      if (STRCMP(p, \"$\") == 0) {\n        tab_number = LAST_TAB_NR;\n      } else if (STRCMP(p, \"#\") == 0) {\n        tab_number = tabpage_index(lastused_tabpage);\n      } else if (p == p_save || *p_save == '-' || *p != NUL\n                 || tab_number > LAST_TAB_NR) {\n        // No numbers as argument.\n        eap->errmsg = e_invarg;\n        goto theend;\n      }\n    } else {\n      if (*p_save == NUL) {\n        tab_number = 1;\n      } else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {\n        // No numbers as argument.\n        eap->errmsg = e_invarg;\n        goto theend;\n      }\n      tab_number = tab_number * relative + tabpage_index(curtab);\n      if (!unaccept_arg0 && relative == -1) {\n        --tab_number;\n      }\n    }\n    if (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR) {\n      eap->errmsg = e_invarg;\n    }\n  } else if (eap->addr_count > 0) {\n    if (unaccept_arg0 && eap->line2 == 0) {\n      eap->errmsg = e_invrange;\n      tab_number = 0;\n    } else {\n      tab_number = eap->line2;\n      if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-') {\n        tab_number--;\n        if (tab_number < unaccept_arg0) {\n          eap->errmsg = e_invarg;\n        }\n      }\n    }\n  } else {\n    switch (eap->cmdidx) {\n    case CMD_tabnext:\n      tab_number = tabpage_index(curtab) + 1;\n      if (tab_number > LAST_TAB_NR) {\n        tab_number = 1;\n      }\n      break;\n    case CMD_tabmove:\n      tab_number = LAST_TAB_NR;\n      break;\n    default:\n      tab_number = tabpage_index(curtab);\n    }\n  }\n\ntheend:\n  return tab_number;\n}\n\n/*\n * \":abbreviate\" and friends.\n */\nstatic void ex_abbreviate(exarg_T *eap)\n{\n  do_exmap(eap, TRUE);          // almost the same as mapping\n}\n\n/*\n * \":map\" and friends.\n */\nstatic void ex_map(exarg_T *eap)\n{\n  /*\n   * If we are sourcing .exrc or .vimrc in current directory we\n   * print the mappings for security reasons.\n   */\n  if (secure) {\n    secure = 2;\n    msg_outtrans(eap->cmd);\n    msg_putchar('\\n');\n  }\n  do_exmap(eap, FALSE);\n}\n\n/*\n * \":unmap\" and friends.\n */\nstatic void ex_unmap(exarg_T *eap)\n{\n  do_exmap(eap, FALSE);\n}\n\n/*\n * \":mapclear\" and friends.\n */\nstatic void ex_mapclear(exarg_T *eap)\n{\n  map_clear_mode(eap->cmd, eap->arg, eap->forceit, false);\n}\n\n/*\n * \":abclear\" and friends.\n */\nstatic void ex_abclear(exarg_T *eap)\n{\n  map_clear_mode(eap->cmd, eap->arg, true, true);\n}\n\nstatic void ex_autocmd(exarg_T *eap)\n{\n  // Disallow autocommands from .exrc and .vimrc in current\n  // directory for security reasons.\n  if (secure) {\n    secure = 2;\n    eap->errmsg = e_curdir;\n  } else if (eap->cmdidx == CMD_autocmd) {\n    do_autocmd(eap->arg, eap->forceit);\n  } else {\n    do_augroup(eap->arg, eap->forceit);\n  }\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\nstatic void ex_doautocmd(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  int call_do_modelines = check_nomodeline(&arg);\n  bool did_aucmd;\n\n  (void)do_doautocmd(arg, false, &did_aucmd);\n  // Only when there is no <nomodeline>.\n  if (call_do_modelines && did_aucmd) {\n    do_modelines(0);\n  }\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\nstatic void ex_bunload(exarg_T *eap)\n{\n  eap->errmsg = do_bufdel(eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n                                                     : eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n                                                                                   : DOBUF_UNLOAD,\n                          eap->arg,\n                          eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]       to buffer N\n * :[N]sbuffer [N]      to buffer N\n */\nstatic void ex_buffer(exarg_T *eap)\n{\n  if (*eap->arg) {\n    eap->errmsg = e_trailing;\n  } else {\n    if (eap->addr_count == 0) {  // default is current buffer\n      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n    } else {\n      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n    }\n    if (eap->do_ecmd_cmd != NULL) {\n      do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n    }\n  }\n}\n\n/*\n * :[N]bmodified [N]    to next mod. buffer\n * :[N]sbmodified [N]   to next mod. buffer\n */\nstatic void ex_bmodified(exarg_T *eap)\n{\n  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n  if (eap->do_ecmd_cmd != NULL) {\n    do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n  }\n}\n\n/*\n * :[N]bnext [N]        to next buffer\n * :[N]sbnext [N]       split and to next buffer\n */\nstatic void ex_bnext(exarg_T *eap)\n{\n  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n  if (eap->do_ecmd_cmd != NULL) {\n    do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n  }\n}\n\n/*\n * :[N]bNext [N]        to previous buffer\n * :[N]bprevious [N]    to previous buffer\n * :[N]sbNext [N]       split and to previous buffer\n * :[N]sbprevious [N]   split and to previous buffer\n */\nstatic void ex_bprevious(exarg_T *eap)\n{\n  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n  if (eap->do_ecmd_cmd != NULL) {\n    do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n  }\n}\n\n/*\n * :brewind             to first buffer\n * :bfirst              to first buffer\n * :sbrewind            split and to first buffer\n * :sbfirst             split and to first buffer\n */\nstatic void ex_brewind(exarg_T *eap)\n{\n  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n  if (eap->do_ecmd_cmd != NULL) {\n    do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n  }\n}\n\n/*\n * :blast               to last buffer\n * :sblast              split and to last buffer\n */\nstatic void ex_blast(exarg_T *eap)\n{\n  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n  if (eap->do_ecmd_cmd != NULL) {\n    do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n  }\n}\n\nint ends_excmd(int c) FUNC_ATTR_CONST\n{\n  return c == NUL || c == '|' || c == '\"' || c == '\\n';\n}\n\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\nchar_u *find_nextcmd(const char_u *p)\n{\n  while (*p != '|' && *p != '\\n') {\n    if (*p == NUL) {\n      return NULL;\n    }\n    p++;\n  }\n  return (char_u *)p + 1;\n}\n\n/// Check if *p is a separator between Ex commands, skipping over white space.\n/// Return NULL if it isn't, the following character if it is.\nchar_u *check_nextcmd(char_u *p)\n{\n  char_u *s = skipwhite(p);\n\n  if (*s == '|' || *s == '\\n') {\n    return (s + 1);\n  } else {\n    return NULL;\n  }\n}\n\n/// - if there are more files to edit\n/// - and this is the last window\n/// - and forceit not used\n/// - and not repeated twice on a row\n/// @return  FAIL and give error message if 'message' TRUE, return OK otherwise\n///\n/// @param   message  when FALSE check only, no messages\nstatic int check_more(int message, bool forceit)\n{\n  int n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n  if (!forceit && only_one_window()\n      && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0) {\n    if (message) {\n      if ((p_confirm || cmdmod.confirm) && curbuf->b_fname != NULL) {\n        char_u buff[DIALOG_MSG_SIZE];\n\n        if (n == 1) {\n          STRLCPY(buff, _(\"1 more file to edit.  Quit anyway?\"),\n                  DIALOG_MSG_SIZE);\n        } else {\n          vim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n                       _(\"%d more files to edit.  Quit anyway?\"), n);\n        }\n        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES) {\n          return OK;\n        }\n        return FAIL;\n      }\n      if (n == 1) {\n        EMSG(_(\"E173: 1 more file to edit\"));\n      } else {\n        EMSGN(_(\"E173: %\" PRId64 \" more files to edit\"), n);\n      }\n      quitmore = 2;                 // next try to quit is allowed\n    }\n    return FAIL;\n  }\n  return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\nchar_u *get_command_name(expand_T *xp, int idx)\n{\n  if (idx >= CMD_SIZE) {\n    return get_user_command_name(idx);\n  }\n  return cmdnames[idx].cmd_name;\n}\n\nstatic int uc_add_command(char_u *name, size_t name_len, char_u *rep, uint32_t argt, long def,\n                          int flags, int compl, char_u *compl_arg, cmd_addr_T addr_type, bool force)\n  FUNC_ATTR_NONNULL_ARG(1, 3)\n{\n  ucmd_T *cmd = NULL;\n  int i;\n  int cmp = 1;\n  char_u *rep_buf = NULL;\n  garray_T *gap;\n\n  replace_termcodes(rep, STRLEN(rep), &rep_buf, false, false, true,\n                    CPO_TO_CPO_FLAGS);\n  if (rep_buf == NULL) {\n    // Can't replace termcodes - try using the string as is\n    rep_buf = vim_strsave(rep);\n  }\n\n  // get address of growarray: global or in curbuf\n  if (flags & UC_BUFFER) {\n    gap = &curbuf->b_ucmds;\n    if (gap->ga_itemsize == 0) {\n      ga_init(gap, (int)sizeof(ucmd_T), 4);\n    }\n  } else {\n    gap = &ucmds;\n  }\n\n  // Search for the command in the already defined commands.\n  for (i = 0; i < gap->ga_len; ++i) {\n    size_t len;\n\n    cmd = USER_CMD_GA(gap, i);\n    len = STRLEN(cmd->uc_name);\n    cmp = STRNCMP(name, cmd->uc_name, name_len);\n    if (cmp == 0) {\n      if (name_len < len) {\n        cmp = -1;\n      } else if (name_len > len) {\n        cmp = 1;\n      }\n    }\n\n    if (cmp == 0) {\n      // Command can be replaced with \"command!\" and when sourcing the\n      // same script again, but only once.\n      if (!force\n          && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid\n              || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq)) {\n        EMSG2(_(\"E174: Command already exists: add ! to replace it: %s\"),\n              name);\n        goto fail;\n      }\n\n      XFREE_CLEAR(cmd->uc_rep);\n      XFREE_CLEAR(cmd->uc_compl_arg);\n      break;\n    }\n\n    // Stop as soon as we pass the name to add\n    if (cmp < 0) {\n      break;\n    }\n  }\n\n  // Extend the array unless we're replacing an existing command\n  if (cmp != 0) {\n    ga_grow(gap, 1);\n\n    char_u *const p = vim_strnsave(name, name_len);\n\n    cmd = USER_CMD_GA(gap, i);\n    memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));\n\n    ++gap->ga_len;\n\n    cmd->uc_name = p;\n  }\n\n  cmd->uc_rep = rep_buf;\n  cmd->uc_argt = argt;\n  cmd->uc_def = def;\n  cmd->uc_compl = compl;\n  cmd->uc_script_ctx = current_sctx;\n  cmd->uc_script_ctx.sc_lnum += sourcing_lnum;\n  cmd->uc_compl_arg = compl_arg;\n  cmd->uc_addr_type = addr_type;\n\n  return OK;\n\nfail:\n  xfree(rep_buf);\n  xfree(compl_arg);\n  return FAIL;\n}\n\n\nstatic struct {\n  cmd_addr_T expand;\n  char *name;\n  char *shortname;\n} addr_type_complete[] =\n{\n  { ADDR_ARGUMENTS, \"arguments\", \"arg\" },\n  { ADDR_LINES, \"lines\", \"line\" },\n  { ADDR_LOADED_BUFFERS, \"loaded_buffers\", \"load\" },\n  { ADDR_TABS, \"tabs\", \"tab\" },\n  { ADDR_BUFFERS, \"buffers\", \"buf\" },\n  { ADDR_WINDOWS, \"windows\", \"win\" },\n  { ADDR_QUICKFIX, \"quickfix\", \"qf\" },\n  { ADDR_OTHER, \"other\", \"?\" },\n  { ADDR_NONE, NULL, NULL }\n};\n\n/*\n * List of names for completion for \":command\" with the EXPAND_ flag.\n * Must be alphabetical for completion.\n */\nstatic const char *command_complete[] =\n{\n  [EXPAND_ARGLIST] = \"arglist\",\n  [EXPAND_AUGROUP] = \"augroup\",\n  [EXPAND_BEHAVE] = \"behave\",\n  [EXPAND_BUFFERS] = \"buffer\",\n  [EXPAND_CHECKHEALTH] = \"checkhealth\",\n  [EXPAND_COLORS] = \"color\",\n  [EXPAND_COMMANDS] = \"command\",\n  [EXPAND_COMPILER] = \"compiler\",\n  [EXPAND_CSCOPE] = \"cscope\",\n  [EXPAND_USER_DEFINED] = \"custom\",\n  [EXPAND_USER_LIST] = \"customlist\",\n  [EXPAND_DIFF_BUFFERS] = \"diff_buffer\",\n  [EXPAND_DIRECTORIES] = \"dir\",\n  [EXPAND_ENV_VARS] = \"environment\",\n  [EXPAND_EVENTS] = \"event\",\n  [EXPAND_EXPRESSION] = \"expression\",\n  [EXPAND_FILES] = \"file\",\n  [EXPAND_FILES_IN_PATH] = \"file_in_path\",\n  [EXPAND_FILETYPE] = \"filetype\",\n  [EXPAND_FUNCTIONS] = \"function\",\n  [EXPAND_HELP] = \"help\",\n  [EXPAND_HIGHLIGHT] = \"highlight\",\n  [EXPAND_HISTORY] = \"history\",\n#ifdef HAVE_WORKING_LIBINTL\n  [EXPAND_LOCALES] = \"locale\",\n#endif\n  [EXPAND_LUA] = \"lua\",\n  [EXPAND_MAPCLEAR] = \"mapclear\",\n  [EXPAND_MAPPINGS] = \"mapping\",\n  [EXPAND_MENUS] = \"menu\",\n  [EXPAND_MESSAGES] = \"messages\",\n  [EXPAND_OWNSYNTAX] = \"syntax\",\n  [EXPAND_SYNTIME] = \"syntime\",\n  [EXPAND_SETTINGS] = \"option\",\n  [EXPAND_PACKADD] = \"packadd\",\n  [EXPAND_SHELLCMD] = \"shellcmd\",\n  [EXPAND_SIGN] = \"sign\",\n  [EXPAND_TAGS] = \"tag\",\n  [EXPAND_TAGS_LISTFILES] = \"tag_listfiles\",\n  [EXPAND_USER] = \"user\",\n  [EXPAND_USER_VARS] = \"var\",\n};\n\nstatic char *get_command_complete(int arg)\n{\n  if (arg >= (int)(ARRAY_SIZE(command_complete))) {\n    return NULL;\n  } else {\n    return (char *)command_complete[arg];\n  }\n}\n\nstatic void uc_list(char_u *name, size_t name_len)\n{\n  int i, j;\n  bool found = false;\n  ucmd_T *cmd;\n  uint32_t a;\n\n  // In cmdwin, the alternative buffer should be used.\n  garray_T *gap = (cmdwin_type != 0 && get_cmdline_type() == NUL)\n    ? &prevwin->w_buffer->b_ucmds\n    : &curbuf->b_ucmds;\n  for (;; ) {\n    for (i = 0; i < gap->ga_len; ++i) {\n      cmd = USER_CMD_GA(gap, i);\n      a = cmd->uc_argt;\n\n      // Skip commands which don't match the requested prefix and\n      // commands filtered out.\n      if (STRNCMP(name, cmd->uc_name, name_len) != 0\n          || message_filtered(cmd->uc_name)) {\n        continue;\n      }\n\n      // Put out the title first time\n      if (!found) {\n        MSG_PUTS_TITLE(_(\"\\n    Name              Args Address \"\n                         \"Complete    Definition\"));\n      }\n      found = true;\n      msg_putchar('\\n');\n      if (got_int) {\n        break;\n      }\n\n      // Special cases\n      int len = 4;\n      if (a & EX_BANG) {\n        msg_putchar('!');\n        len--;\n      }\n      if (a & EX_REGSTR) {\n        msg_putchar('\"');\n        len--;\n      }\n      if (gap != &ucmds) {\n        msg_putchar('b');\n        len--;\n      }\n      if (a & EX_TRLBAR) {\n        msg_putchar('|');\n        len--;\n      }\n      while (len-- > 0) {\n        msg_putchar(' ');\n      }\n\n      msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n      len = (int)STRLEN(cmd->uc_name) + 4;\n\n      do {\n        msg_putchar(' ');\n        len++;\n      } while (len < 22);\n\n      // \"over\" is how much longer the name is than the column width for\n      // the name, we'll try to align what comes after.\n      const int over = len - 22;\n      len = 0;\n\n      // Arguments\n      switch (a & (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {\n      case 0:\n        IObuff[len++] = '0';\n        break;\n      case (EX_EXTRA):\n        IObuff[len++] = '*';\n        break;\n      case (EX_EXTRA | EX_NOSPC):\n        IObuff[len++] = '?';\n        break;\n      case (EX_EXTRA | EX_NEEDARG):\n        IObuff[len++] = '+';\n        break;\n      case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):\n        IObuff[len++] = '1';\n        break;\n      }\n\n      do {\n        IObuff[len++] = ' ';\n      } while (len < 5 - over);\n\n      // Address / Range\n      if (a & (EX_RANGE | EX_COUNT)) {\n        if (a & EX_COUNT) {\n          // -count=N\n          snprintf((char *)IObuff + len, IOSIZE, \"%\" PRId64 \"c\",\n                   (int64_t)cmd->uc_def);\n          len += (int)STRLEN(IObuff + len);\n        } else if (a & EX_DFLALL) {\n          IObuff[len++] = '%';\n        } else if (cmd->uc_def >= 0) {\n          // -range=N\n          snprintf((char *)IObuff + len, IOSIZE, \"%\" PRId64 \"\",\n                   (int64_t)cmd->uc_def);\n          len += (int)STRLEN(IObuff + len);\n        } else {\n          IObuff[len++] = '.';\n        }\n      }\n\n      do {\n        IObuff[len++] = ' ';\n      } while (len < 8 - over);\n\n      // Address Type\n      for (j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {\n        if (addr_type_complete[j].expand != ADDR_LINES\n            && addr_type_complete[j].expand == cmd->uc_addr_type) {\n          STRCPY(IObuff + len, addr_type_complete[j].shortname);\n          len += (int)STRLEN(IObuff + len);\n          break;\n        }\n      }\n\n      do {\n        IObuff[len++] = ' ';\n      } while (len < 13 - over);\n\n      // Completion\n      char *cmd_compl = get_command_complete(cmd->uc_compl);\n      if (cmd_compl != NULL) {\n        STRCPY(IObuff + len, get_command_complete(cmd->uc_compl));\n        len += (int)STRLEN(IObuff + len);\n      }\n\n      do {\n        IObuff[len++] = ' ';\n      } while (len < 25 - over);\n\n      IObuff[len] = '\\0';\n      msg_outtrans(IObuff);\n\n      msg_outtrans_special(cmd->uc_rep, false,\n                           name_len == 0 ? Columns - 47 : 0);\n      if (p_verbose > 0) {\n        last_set_msg(cmd->uc_script_ctx);\n      }\n      line_breakcheck();\n      if (got_int) {\n        break;\n      }\n    }\n    if (gap == &ucmds || i < gap->ga_len) {\n      break;\n    }\n    gap = &ucmds;\n  }\n\n  if (!found) {\n    MSG(_(\"No user-defined commands found\"));\n  }\n}\n\nstatic int uc_scan_attr(char_u *attr, size_t len, uint32_t *argt, long *def, int *flags,\n                        int *complp, char_u **compl_arg, cmd_addr_T *addr_type_arg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *p;\n\n  if (len == 0) {\n    EMSG(_(\"E175: No attribute specified\"));\n    return FAIL;\n  }\n\n  // First, try the simple attributes (no arguments)\n  if (STRNICMP(attr, \"bang\", len) == 0) {\n    *argt |= EX_BANG;\n  } else if (STRNICMP(attr, \"buffer\", len) == 0) {\n    *flags |= UC_BUFFER;\n  } else if (STRNICMP(attr, \"register\", len) == 0) {\n    *argt |= EX_REGSTR;\n  } else if (STRNICMP(attr, \"bar\", len) == 0) {\n    *argt |= EX_TRLBAR;\n  } else {\n    int i;\n    char_u *val = NULL;\n    size_t vallen = 0;\n    size_t attrlen = len;\n\n    // Look for the attribute name - which is the part before any '='\n    for (i = 0; i < (int)len; i++) {\n      if (attr[i] == '=') {\n        val = &attr[i + 1];\n        vallen = len - i - 1;\n        attrlen = i;\n        break;\n      }\n    }\n\n    if (STRNICMP(attr, \"nargs\", attrlen) == 0) {\n      if (vallen == 1) {\n        if (*val == '0') {\n          // Do nothing - this is the default;\n        } else if (*val == '1') {\n          *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);\n        } else if (*val == '*') {\n          *argt |= EX_EXTRA;\n        } else if (*val == '?') {\n          *argt |= (EX_EXTRA | EX_NOSPC);\n        } else if (*val == '+') {\n          *argt |= (EX_EXTRA | EX_NEEDARG);\n        } else {\n          goto wrong_nargs;\n        }\n      } else {\nwrong_nargs:\n        EMSG(_(\"E176: Invalid number of arguments\"));\n        return FAIL;\n      }\n    } else if (STRNICMP(attr, \"range\", attrlen) == 0) {\n      *argt |= EX_RANGE;\n      if (vallen == 1 && *val == '%') {\n        *argt |= EX_DFLALL;\n      } else if (val != NULL) {\n        p = val;\n        if (*def >= 0) {\ntwo_count:\n          EMSG(_(\"E177: Count cannot be specified twice\"));\n          return FAIL;\n        }\n\n        *def = getdigits_long(&p, true, 0);\n        *argt |= EX_ZEROR;\n\n        if (p != val + vallen || vallen == 0) {\ninvalid_count:\n          EMSG(_(\"E178: Invalid default value for count\"));\n          return FAIL;\n        }\n      }\n      // default for -range is using buffer lines\n      if (*addr_type_arg == ADDR_NONE) {\n        *addr_type_arg = ADDR_LINES;\n      }\n    } else if (STRNICMP(attr, \"count\", attrlen) == 0) {\n      *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);\n      // default for -count is using any number\n      if (*addr_type_arg == ADDR_NONE) {\n        *addr_type_arg = ADDR_OTHER;\n      }\n\n      if (val != NULL) {\n        p = val;\n        if (*def >= 0) {\n          goto two_count;\n        }\n\n        *def = getdigits_long(&p, true, 0);\n\n        if (p != val + vallen) {\n          goto invalid_count;\n        }\n      }\n\n      if (*def < 0) {\n        *def = 0;\n      }\n    } else if (STRNICMP(attr, \"complete\", attrlen) == 0) {\n      if (val == NULL) {\n        EMSG(_(\"E179: argument required for -complete\"));\n        return FAIL;\n      }\n\n      if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)\n          == FAIL) {\n        return FAIL;\n      }\n    } else if (STRNICMP(attr, \"addr\", attrlen) == 0) {\n      *argt |= EX_RANGE;\n      if (val == NULL) {\n        EMSG(_(\"E179: argument required for -addr\"));\n        return FAIL;\n      }\n      if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL) {\n        return FAIL;\n      }\n      if (*addr_type_arg != ADDR_LINES) {\n        *argt |= EX_ZEROR;\n      }\n    } else {\n      char_u ch = attr[len];\n      attr[len] = '\\0';\n      EMSG2(_(\"E181: Invalid attribute: %s\"), attr);\n      attr[len] = ch;\n      return FAIL;\n    }\n  }\n\n  return OK;\n}\n\nstatic char e_complete_used_without_nargs[] = N_(\"E1208: -complete used without -nargs\");\n\n/*\n * \":command ...\"\n */\nstatic void ex_command(exarg_T *eap)\n{\n  char_u *name;\n  char_u *end;\n  char_u *p;\n  uint32_t argt = 0;\n  long def = -1;\n  int flags = 0;\n  int     compl = EXPAND_NOTHING;\n  char_u *compl_arg = NULL;\n  cmd_addr_T addr_type_arg = ADDR_NONE;\n  int has_attr = (eap->arg[0] == '-');\n  int name_len;\n\n  p = eap->arg;\n\n  // Check for attributes\n  while (*p == '-') {\n    ++p;\n    end = skiptowhite(p);\n    if (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl, &compl_arg,\n                     &addr_type_arg) == FAIL) {\n      return;\n    }\n    p = skipwhite(end);\n  }\n\n  // Get the name (if any) and skip to the following argument.\n  name = p;\n  if (ASCII_ISALPHA(*p)) {\n    while (ASCII_ISALNUM(*p)) {\n      p++;\n    }\n  }\n  if (!ends_excmd(*p) && !ascii_iswhite(*p)) {\n    EMSG(_(\"E182: Invalid command name\"));\n    return;\n  }\n  end = p;\n  name_len = (int)(end - name);\n\n  // If there is nothing after the name, and no attributes were specified,\n  // we are listing commands\n  p = skipwhite(end);\n  if (!has_attr && ends_excmd(*p)) {\n    uc_list(name, end - name);\n  } else if (!ASCII_ISUPPER(*name)) {\n    EMSG(_(\"E183: User defined commands must start with an uppercase letter\"));\n  } else if (name_len <= 4 && STRNCMP(name, \"Next\", name_len) == 0) {\n    EMSG(_(\"E841: Reserved name, cannot be used for user defined command\"));\n  } else if (compl > 0 && (argt & EX_EXTRA) == 0) {\n    EMSG(_(e_complete_used_without_nargs));\n  } else {\n    uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,\n                   addr_type_arg, eap->forceit);\n  }\n}\n\n/*\n * \":comclear\"\n * Clear all user commands, global and for current buffer.\n */\nvoid ex_comclear(exarg_T *eap)\n{\n  uc_clear(&ucmds);\n  uc_clear(&curbuf->b_ucmds);\n}\n\nstatic void free_ucmd(ucmd_T * cmd) {\n  xfree(cmd->uc_name);\n  xfree(cmd->uc_rep);\n  xfree(cmd->uc_compl_arg);\n}\n\n/*\n * Clear all user commands for \"gap\".\n */\nvoid uc_clear(garray_T *gap)\n{\n  GA_DEEP_CLEAR(gap, ucmd_T, free_ucmd);\n}\n\nstatic void ex_delcommand(exarg_T *eap)\n{\n  int i = 0;\n  ucmd_T *cmd = NULL;\n  int cmp = -1;\n  garray_T *gap;\n\n  gap = &curbuf->b_ucmds;\n  for (;; ) {\n    for (i = 0; i < gap->ga_len; ++i) {\n      cmd = USER_CMD_GA(gap, i);\n      cmp = STRCMP(eap->arg, cmd->uc_name);\n      if (cmp <= 0) {\n        break;\n      }\n    }\n    if (gap == &ucmds || cmp == 0) {\n      break;\n    }\n    gap = &ucmds;\n  }\n\n  if (cmp != 0) {\n    EMSG2(_(\"E184: No such user-defined command: %s\"), eap->arg);\n    return;\n  }\n\n  xfree(cmd->uc_name);\n  xfree(cmd->uc_rep);\n  xfree(cmd->uc_compl_arg);\n\n  --gap->ga_len;\n\n  if (i < gap->ga_len) {\n    memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));\n  }\n}\n\n/*\n * split and quote args for <f-args>\n */\nstatic char_u *uc_split_args(char_u *arg, size_t *lenp)\n{\n  char_u *buf;\n  char_u *p;\n  char_u *q;\n  int len;\n\n  // Precalculate length\n  p = arg;\n  len = 2;   // Initial and final quotes\n\n  while (*p) {\n    if (p[0] == '\\\\' && p[1] == '\\\\') {\n      len += 2;\n      p += 2;\n    } else if (p[0] == '\\\\' && ascii_iswhite(p[1])) {\n      len += 1;\n      p += 2;\n    } else if (*p == '\\\\' || *p == '\"') {\n      len += 2;\n      p += 1;\n    } else if (ascii_iswhite(*p)) {\n      p = skipwhite(p);\n      if (*p == NUL) {\n        break;\n      }\n      len += 3;       // \",\"\n    } else {\n      const int charlen = utfc_ptr2len(p);\n\n      len += charlen;\n      p += charlen;\n    }\n  }\n\n  buf = xmalloc(len + 1);\n\n  p = arg;\n  q = buf;\n  *q++ = '\"';\n  while (*p) {\n    if (p[0] == '\\\\' && p[1] == '\\\\') {\n      *q++ = '\\\\';\n      *q++ = '\\\\';\n      p += 2;\n    } else if (p[0] == '\\\\' && ascii_iswhite(p[1])) {\n      *q++ = p[1];\n      p += 2;\n    } else if (*p == '\\\\' || *p == '\"') {\n      *q++ = '\\\\';\n      *q++ = *p++;\n    } else if (ascii_iswhite(*p)) {\n      p = skipwhite(p);\n      if (*p == NUL) {\n        break;\n      }\n      *q++ = '\"';\n      *q++ = ',';\n      *q++ = '\"';\n    } else {\n      MB_COPY_CHAR(p, q);\n    }\n  }\n  *q++ = '\"';\n  *q = 0;\n\n  *lenp = len;\n  return buf;\n}\n\nstatic size_t add_cmd_modifier(char_u *buf, char *mod_str, bool *multi_mods)\n{\n  size_t result = STRLEN(mod_str);\n  if (*multi_mods) {\n    result++;\n  }\n\n  if (buf != NULL) {\n    if (*multi_mods) {\n      STRCAT(buf, \" \");\n    }\n    STRCAT(buf, mod_str);\n  }\n\n  *multi_mods = true;\n  return result;\n}\n\n/// Check for a <> code in a user command.\n///\n/// @param code       points to the '<'.  \"len\" the length of the <> (inclusive).\n/// @param buf        is where the result is to be added.\n/// @param cmd        the user command we're expanding\n/// @param eap        ex arguments\n/// @param split_buf  points to a buffer used for splitting, caller should free it.\n/// @param split_len  is the length of what \"split_buf\" contains.\n///\n/// @return           the length of the replacement, which has been added to \"buf\".\n///                   Return -1 if there was no match, and only the \"<\" has been copied.\nstatic size_t uc_check_code(char_u *code, size_t len, char_u *buf, ucmd_T *cmd, exarg_T *eap,\n                            char_u **split_buf, size_t *split_len)\n{\n  size_t result = 0;\n  char_u *p = code + 1;\n  size_t l = len - 2;\n  int quote = 0;\n  enum {\n    ct_ARGS,\n    ct_BANG,\n    ct_COUNT,\n    ct_LINE1,\n    ct_LINE2,\n    ct_RANGE,\n    ct_MODS,\n    ct_REGISTER,\n    ct_LT,\n    ct_NONE\n  } type = ct_NONE;\n\n  if ((vim_strchr((char_u *)\"qQfF\", *p) != NULL) && p[1] == '-') {\n    quote = (*p == 'q' || *p == 'Q') ? 1 : 2;\n    p += 2;\n    l -= 2;\n  }\n\n  l++;\n  if (l <= 1) {\n    type = ct_NONE;\n  } else if (STRNICMP(p, \"args>\", l) == 0) {\n    type = ct_ARGS;\n  } else if (STRNICMP(p, \"bang>\", l) == 0) {\n    type = ct_BANG;\n  } else if (STRNICMP(p, \"count>\", l) == 0) {\n    type = ct_COUNT;\n  } else if (STRNICMP(p, \"line1>\", l) == 0) {\n    type = ct_LINE1;\n  } else if (STRNICMP(p, \"line2>\", l) == 0) {\n    type = ct_LINE2;\n  } else if (STRNICMP(p, \"range>\", l) == 0) {\n    type = ct_RANGE;\n  } else if (STRNICMP(p, \"lt>\", l) == 0) {\n    type = ct_LT;\n  } else if (STRNICMP(p, \"reg>\", l) == 0 || STRNICMP(p, \"register>\", l) == 0) {\n    type = ct_REGISTER;\n  } else if (STRNICMP(p, \"mods>\", l) == 0) {\n    type = ct_MODS;\n  }\n\n  switch (type) {\n  case ct_ARGS:\n    // Simple case first\n    if (*eap->arg == NUL) {\n      if (quote == 1) {\n        result = 2;\n        if (buf != NULL) {\n          STRCPY(buf, \"''\");\n        }\n      } else {\n        result = 0;\n      }\n      break;\n    }\n\n    /* When specified there is a single argument don't split it.\n     * Works for \":Cmd %\" when % is \"a b c\". */\n    if ((eap->argt & EX_NOSPC) && quote == 2) {\n      quote = 1;\n    }\n\n    switch (quote) {\n    case 0:     // No quoting, no splitting\n      result = STRLEN(eap->arg);\n      if (buf != NULL) {\n        STRCPY(buf, eap->arg);\n      }\n      break;\n    case 1:     // Quote, but don't split\n      result = STRLEN(eap->arg) + 2;\n      for (p = eap->arg; *p; p++) {\n        if (*p == '\\\\' || *p == '\"') {\n          result++;\n        }\n      }\n\n      if (buf != NULL) {\n        *buf++ = '\"';\n        for (p = eap->arg; *p; p++) {\n          if (*p == '\\\\' || *p == '\"') {\n            *buf++ = '\\\\';\n          }\n          *buf++ = *p;\n        }\n        *buf = '\"';\n      }\n\n      break;\n    case 2:     // Quote and split (<f-args>)\n      // This is hard, so only do it once, and cache the result\n      if (*split_buf == NULL) {\n        *split_buf = uc_split_args(eap->arg, split_len);\n      }\n\n      result = *split_len;\n      if (buf != NULL && result != 0) {\n        STRCPY(buf, *split_buf);\n      }\n\n      break;\n    }\n    break;\n\n  case ct_BANG:\n    result = eap->forceit ? 1 : 0;\n    if (quote) {\n      result += 2;\n    }\n    if (buf != NULL) {\n      if (quote) {\n        *buf++ = '\"';\n      }\n      if (eap->forceit) {\n        *buf++ = '!';\n      }\n      if (quote) {\n        *buf = '\"';\n      }\n    }\n    break;\n\n  case ct_LINE1:\n  case ct_LINE2:\n  case ct_RANGE:\n  case ct_COUNT: {\n    char num_buf[20];\n    long num = (type == ct_LINE1) ? eap->line1 :\n               (type == ct_LINE2) ? eap->line2 :\n               (type == ct_RANGE) ? eap->addr_count :\n               (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;\n    size_t num_len;\n\n    sprintf(num_buf, \"%\" PRId64, (int64_t)num);\n    num_len = STRLEN(num_buf);\n    result = num_len;\n\n    if (quote) {\n      result += 2;\n    }\n\n    if (buf != NULL) {\n      if (quote) {\n        *buf++ = '\"';\n      }\n      STRCPY(buf, num_buf);\n      buf += num_len;\n      if (quote) {\n        *buf = '\"';\n      }\n    }\n\n    break;\n  }\n\n  case ct_MODS: {\n    result = quote ? 2 : 0;\n    if (buf != NULL) {\n      if (quote) {\n        *buf++ = '\"';\n      }\n      *buf = '\\0';\n    }\n\n    bool multi_mods = false;\n\n    // :aboveleft and :leftabove\n    if (cmdmod.split & WSP_ABOVE) {\n      result += add_cmd_modifier(buf, \"aboveleft\", &multi_mods);\n    }\n    // :belowright and :rightbelow\n    if (cmdmod.split & WSP_BELOW) {\n      result += add_cmd_modifier(buf, \"belowright\", &multi_mods);\n    }\n    // :botright\n    if (cmdmod.split & WSP_BOT) {\n      result += add_cmd_modifier(buf, \"botright\", &multi_mods);\n    }\n\n    typedef struct {\n      bool *set;\n      char *name;\n    } mod_entry_T;\n    static mod_entry_T mod_entries[] = {\n      { &cmdmod.browse, \"browse\" },\n      { &cmdmod.confirm, \"confirm\" },\n      { &cmdmod.hide, \"hide\" },\n      { &cmdmod.keepalt, \"keepalt\" },\n      { &cmdmod.keepjumps, \"keepjumps\" },\n      { &cmdmod.keepmarks, \"keepmarks\" },\n      { &cmdmod.keeppatterns, \"keeppatterns\" },\n      { &cmdmod.lockmarks, \"lockmarks\" },\n      { &cmdmod.noswapfile, \"noswapfile\" }\n    };\n    // the modifiers that are simple flags\n    for (size_t i = 0; i < ARRAY_SIZE(mod_entries); i++) {\n      if (*mod_entries[i].set) {\n        result += add_cmd_modifier(buf, mod_entries[i].name, &multi_mods);\n      }\n    }\n\n    // TODO(vim): How to support :noautocmd?\n    // TODO(vim): How to support :sandbox?\n\n    // :silent\n    if (msg_silent > 0) {\n      result += add_cmd_modifier(buf, emsg_silent > 0 ? \"silent!\" : \"silent\",\n                                 &multi_mods);\n    }\n    // :tab\n    if (cmdmod.tab > 0) {\n      result += add_cmd_modifier(buf, \"tab\", &multi_mods);\n    }\n    // :topleft\n    if (cmdmod.split & WSP_TOP) {\n      result += add_cmd_modifier(buf, \"topleft\", &multi_mods);\n    }\n\n    // TODO(vim): How to support :unsilent?\n\n    // :verbose\n    if (p_verbose > 0) {\n      result += add_cmd_modifier(buf, \"verbose\", &multi_mods);\n    }\n    // :vertical\n    if (cmdmod.split & WSP_VERT) {\n      result += add_cmd_modifier(buf, \"vertical\", &multi_mods);\n    }\n    if (quote && buf != NULL) {\n      buf += result - 2;\n      *buf = '\"';\n    }\n    break;\n  }\n\n  case ct_REGISTER:\n    result = eap->regname ? 1 : 0;\n    if (quote) {\n      result += 2;\n    }\n    if (buf != NULL) {\n      if (quote) {\n        *buf++ = '\\'';\n      }\n      if (eap->regname) {\n        *buf++ = eap->regname;\n      }\n      if (quote) {\n        *buf = '\\'';\n      }\n    }\n    break;\n\n  case ct_LT:\n    result = 1;\n    if (buf != NULL) {\n      *buf = '<';\n    }\n    break;\n\n  default:\n    // Not recognized: just copy the '<' and return -1.\n    result = (size_t)-1;\n    if (buf != NULL) {\n      *buf = '<';\n    }\n    break;\n  }\n\n  return result;\n}\n\nstatic void do_ucmd(exarg_T *eap)\n{\n  char_u *buf;\n  char_u *p;\n  char_u *q;\n\n  char_u *start;\n  char_u *end = NULL;\n  char_u *ksp;\n  size_t len, totlen;\n\n  size_t split_len = 0;\n  char_u *split_buf = NULL;\n  ucmd_T *cmd;\n  const sctx_T save_current_sctx = current_sctx;\n\n  if (eap->cmdidx == CMD_USER) {\n    cmd = USER_CMD(eap->useridx);\n  } else {\n    cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);\n  }\n\n  /*\n   * Replace <> in the command by the arguments.\n   * First round: \"buf\" is NULL, compute length, allocate \"buf\".\n   * Second round: copy result into \"buf\".\n   */\n  buf = NULL;\n  for (;; ) {\n    p = cmd->uc_rep;        // source\n    q = buf;                // destination\n    totlen = 0;\n\n    for (;; ) {\n      start = vim_strchr(p, '<');\n      if (start != NULL) {\n        end = vim_strchr(start + 1, '>');\n      }\n      if (buf != NULL) {\n        for (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ksp++) {\n        }\n        if (*ksp == K_SPECIAL\n            && (start == NULL || ksp < start || end == NULL)\n            && (ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)) {\n          // K_SPECIAL has been put in the buffer as K_SPECIAL\n          // KS_SPECIAL KE_FILLER, like for mappings, but\n          // do_cmdline() doesn't handle that, so convert it back.\n          // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.\n          len = ksp - p;\n          if (len > 0) {\n            memmove(q, p, len);\n            q += len;\n          }\n          *q++ = K_SPECIAL;\n          p = ksp + 3;\n          continue;\n        }\n      }\n\n      // break if there no <item> is found\n      if (start == NULL || end == NULL) {\n        break;\n      }\n\n      // Include the '>'\n      ++end;\n\n      // Take everything up to the '<'\n      len = start - p;\n      if (buf == NULL) {\n        totlen += len;\n      } else {\n        memmove(q, p, len);\n        q += len;\n      }\n\n      len = uc_check_code(start, end - start, q, cmd, eap,\n                          &split_buf, &split_len);\n      if (len == (size_t)-1) {\n        // no match, continue after '<'\n        p = start + 1;\n        len = 1;\n      } else {\n        p = end;\n      }\n      if (buf == NULL) {\n        totlen += len;\n      } else {\n        q += len;\n      }\n    }\n    if (buf != NULL) {              // second time here, finished\n      STRCPY(q, p);\n      break;\n    }\n\n    totlen += STRLEN(p);            // Add on the trailing characters\n    buf = xmalloc(totlen + 1);\n  }\n\n  current_sctx.sc_sid = cmd->uc_script_ctx.sc_sid;\n  (void)do_cmdline(buf, eap->getline, eap->cookie,\n                   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n  current_sctx = save_current_sctx;\n  xfree(buf);\n  xfree(split_buf);\n}\n\nstatic char_u *get_user_command_name(int idx)\n{\n  return get_user_commands(NULL, idx - CMD_SIZE);\n}\n/*\n * Function given to ExpandGeneric() to obtain the list of user address type names.\n */\nchar_u *get_user_cmd_addr_type(expand_T *xp, int idx)\n{\n  return (char_u *)addr_type_complete[idx].name;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command names.\n */\nchar_u *get_user_commands(expand_T *xp FUNC_ATTR_UNUSED, int idx)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // In cmdwin, the alternative buffer should be used.\n  const buf_T *const buf = (cmdwin_type != 0 && get_cmdline_type() == NUL)\n    ? prevwin->w_buffer\n    : curbuf;\n\n  if (idx < buf->b_ucmds.ga_len) {\n    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n  }\n  idx -= buf->b_ucmds.ga_len;\n  if (idx < ucmds.ga_len) {\n    return USER_CMD(idx)->uc_name;\n  }\n  return NULL;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command\n * attributes.\n */\nchar_u *get_user_cmd_flags(expand_T *xp, int idx)\n{\n  static char *user_cmd_flags[] = { \"addr\",   \"bang\",     \"bar\",\n                                    \"buffer\", \"complete\", \"count\",\n                                    \"nargs\",  \"range\",    \"register\" };\n\n  if (idx >= (int)ARRAY_SIZE(user_cmd_flags)) {\n    return NULL;\n  }\n  return (char_u *)user_cmd_flags[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -nargs.\n */\nchar_u *get_user_cmd_nargs(expand_T *xp, int idx)\n{\n  static char *user_cmd_nargs[] = { \"0\", \"1\", \"*\", \"?\", \"+\" };\n\n  if (idx >= (int)ARRAY_SIZE(user_cmd_nargs)) {\n    return NULL;\n  }\n  return (char_u *)user_cmd_nargs[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -complete.\n */\nchar_u *get_user_cmd_complete(expand_T *xp, int idx)\n{\n  if (idx >= (int)ARRAY_SIZE(command_complete)) {\n    return NULL;\n  }\n  char *cmd_compl = get_command_complete(idx);\n  if (cmd_compl == NULL) {\n    return (char_u *)\"\";\n  } else {\n    return (char_u *)cmd_compl;\n  }\n}\n\n/*\n * Parse address type argument\n */\nint parse_addr_type_arg(char_u *value, int vallen, cmd_addr_T *addr_type_arg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int i, a, b;\n\n  for (i = 0; addr_type_complete[i].expand != ADDR_NONE; i++) {\n    a = (int)STRLEN(addr_type_complete[i].name) == vallen;\n    b = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;\n    if (a && b) {\n      *addr_type_arg = addr_type_complete[i].expand;\n      break;\n    }\n  }\n\n  if (addr_type_complete[i].expand == ADDR_NONE) {\n    char_u *err = value;\n\n    for (i = 0; err[i] != NUL && !ascii_iswhite(err[i]); i++) {}\n    err[i] = NUL;\n    EMSG2(_(\"E180: Invalid address type value: %s\"), err);\n    return FAIL;\n  }\n\n  return OK;\n}\n\n/*\n * Parse a completion argument \"value[vallen]\".\n * The detected completion goes in \"*complp\", argument type in \"*argt\".\n * When there is an argument, for function and user defined completion, it's\n * copied to allocated memory and stored in \"*compl_arg\".\n * Returns FAIL if something is wrong.\n */\nint parse_compl_arg(const char_u *value, int vallen, int *complp, uint32_t *argt,\n                    char_u **compl_arg)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char_u *arg = NULL;\n  size_t arglen = 0;\n  int i;\n  int valend = vallen;\n\n  // Look for any argument part - which is the part after any ','\n  for (i = 0; i < vallen; ++i) {\n    if (value[i] == ',') {\n      arg = &value[i + 1];\n      arglen = vallen - i - 1;\n      valend = i;\n      break;\n    }\n  }\n\n  for (i = 0; i < (int)ARRAY_SIZE(command_complete); i++) {\n    if (get_command_complete(i) == NULL) {\n      continue;\n    }\n    if ((int)STRLEN(command_complete[i]) == valend\n        && STRNCMP(value, command_complete[i], valend) == 0) {\n      *complp = i;\n      if (i == EXPAND_BUFFERS) {\n        *argt |= EX_BUFNAME;\n      } else if (i == EXPAND_DIRECTORIES || i == EXPAND_FILES) {\n        *argt |= EX_XFILE;\n      }\n      break;\n    }\n  }\n\n  if (i == (int)ARRAY_SIZE(command_complete)) {\n    EMSG2(_(\"E180: Invalid complete value: %s\"), value);\n    return FAIL;\n  }\n\n  if (*complp != EXPAND_USER_DEFINED && *complp != EXPAND_USER_LIST\n      && arg != NULL) {\n    EMSG(_(\"E468: Completion argument only allowed for custom completion\"));\n    return FAIL;\n  }\n\n  if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)\n      && arg == NULL) {\n    EMSG(_(\"E467: Custom completion requires a function argument\"));\n    return FAIL;\n  }\n\n  if (arg != NULL) {\n    *compl_arg = vim_strnsave(arg, arglen);\n  }\n  return OK;\n}\n\nint cmdcomplete_str_to_type(const char *complete_str)\n{\n  for (int i = 0; i < (int)(ARRAY_SIZE(command_complete)); i++) {\n    char *cmd_compl = get_command_complete(i);\n    if (cmd_compl == NULL) {\n      continue;\n    }\n    if (strcmp(complete_str, command_complete[i]) == 0) {\n      return i;\n    }\n  }\n\n  return EXPAND_NOTHING;\n}\n\nstatic void ex_colorscheme(exarg_T *eap)\n{\n  if (*eap->arg == NUL) {\n    char_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n    char_u *p = NULL;\n\n    emsg_off++;\n    p = eval_to_string(expr, NULL, false);\n    emsg_off--;\n    xfree(expr);\n\n    if (p != NULL) {\n      MSG(p);\n      xfree(p);\n    } else {\n      MSG(\"default\");\n    }\n  } else if (load_colors(eap->arg) == FAIL) {\n    EMSG2(_(\"E185: Cannot find color scheme '%s'\"), eap->arg);\n  }\n}\n\nstatic void ex_highlight(exarg_T *eap)\n{\n  if (*eap->arg == NUL && eap->cmd[2] == '!') {\n    MSG(_(\"Greetings, Vim user!\"));\n  }\n  do_highlight((const char *)eap->arg, eap->forceit, false);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\nvoid not_exiting(void)\n{\n  exiting = false;\n}\n\nbool before_quit_autocmds(win_T *wp, bool quit_all, bool forceit)\n{\n  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp->w_buffer);\n\n  // Bail out when autocommands closed the window.\n  // Refuse to quit when the buffer in the last window is being closed (can\n  // only happen in autocommands).\n  if (!win_valid(wp)\n      || curbuf_locked()\n      || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0)) {\n    return true;\n  }\n\n  if (quit_all\n      || (check_more(false, forceit) == OK && only_one_window())) {\n    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);\n    // Refuse to quit when locked or when the window was closed or the\n    // buffer in the last window is being closed (can only happen in\n    // autocommands).\n    if (!win_valid(wp)\n        || curbuf_locked()\n        || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// \":quit\": quit current window, quit Vim if the last window is closed.\n// \":{nr}quit\": quit window {nr}\nstatic void ex_quit(exarg_T *eap)\n{\n  if (cmdwin_type != 0) {\n    cmdwin_result = Ctrl_C;\n    return;\n  }\n  // Don't quit while editing the command line.\n  if (text_locked()) {\n    text_locked_msg();\n    return;\n  }\n\n  win_T *wp;\n\n  if (eap->addr_count > 0) {\n    int wnr = eap->line2;\n\n    for (wp = firstwin; wp->w_next != NULL; wp = wp->w_next) {\n      if (--wnr <= 0) {\n        break;\n      }\n    }\n  } else {\n    wp = curwin;\n  }\n\n  // Refuse to quit when locked.\n  if (curbuf_locked()) {\n    return;\n  }\n\n  // Trigger QuitPre and maybe ExitPre\n  if (before_quit_autocmds(wp, false, eap->forceit)) {\n    return;\n  }\n\n  // If there is only one relevant window we will exit.\n  if (check_more(false, eap->forceit) == OK && only_one_window()) {\n    exiting = true;\n  }\n  if ((!buf_hide(wp->w_buffer)\n       && check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n                        | (eap->forceit ? CCGD_FORCEIT : 0)\n                        | CCGD_EXCMD))\n      || check_more(true, eap->forceit) == FAIL\n      || (only_one_window() && check_changed_any(eap->forceit, true))) {\n    not_exiting();\n  } else {\n    // quit last window\n    // Note: only_one_window() returns true, even so a help window is\n    // still open. In that case only quit, if no address has been\n    // specified. Example:\n    // :h|wincmd w|1q     - don't quit\n    // :h|wincmd w|q      - quit\n    if (only_one_window() && (ONE_WINDOW || eap->addr_count == 0)) {\n      getout(0);\n    }\n    not_exiting();\n    // close window; may free buffer\n    win_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n  }\n}\n\n/// \":cquit\".\nstatic void ex_cquit(exarg_T *eap)\n{\n  // this does not always pass on the exit code to the Manx compiler. why?\n  getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/// \":qall\": try to quit all windows\nstatic void ex_quit_all(exarg_T *eap)\n{\n  if (cmdwin_type != 0) {\n    if (eap->forceit) {\n      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this\n    } else {\n      cmdwin_result = K_XF2;\n    }\n    return;\n  }\n\n  // Don't quit while editing the command line.\n  if (text_locked()) {\n    text_locked_msg();\n    return;\n  }\n\n  if (before_quit_autocmds(curwin, true, eap->forceit)) {\n    return;\n  }\n\n  exiting = true;\n  if (eap->forceit || !check_changed_any(false, false)) {\n    getout(0);\n  }\n  not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\nstatic void ex_close(exarg_T *eap)\n{\n  win_T *win = NULL;\n  int winnr = 0;\n  if (cmdwin_type != 0) {\n    cmdwin_result = Ctrl_C;\n  } else if (!text_locked() && !curbuf_locked()) {\n    if (eap->addr_count == 0) {\n      ex_win_close(eap->forceit, curwin, NULL);\n    } else {\n      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n        winnr++;\n        if (winnr == eap->line2) {\n          win = wp;\n          break;\n        }\n      }\n      if (win == NULL) {\n        win = lastwin;\n      }\n      ex_win_close(eap->forceit, win, NULL);\n    }\n  }\n}\n\n/*\n * \":pclose\": Close any preview window.\n */\nstatic void ex_pclose(exarg_T *eap)\n{\n  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n    if (win->w_p_pvw) {\n      ex_win_close(eap->forceit, win, NULL);\n      break;\n    }\n  }\n}\n\n/// Close window \"win\" and take care of handling closing the last window for a\n/// modified buffer.\n///\n/// @param tp  NULL or the tab page \"win\" is in\nvoid ex_win_close(int forceit, win_T *win, tabpage_T *tp)\n{\n  int need_hide;\n  buf_T *buf = win->w_buffer;\n\n  // Never close the autocommand window.\n  if (win == aucmd_win) {\n    EMSG(_(e_autocmd_close));\n    return;\n  }\n\n  need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n  if (need_hide && !buf_hide(buf) && !forceit) {\n    if ((p_confirm || cmdmod.confirm) && p_write) {\n      bufref_T bufref;\n      set_bufref(&bufref, buf);\n      dialog_changed(buf, false);\n      if (bufref_valid(&bufref) && bufIsChanged(buf)) {\n        return;\n      }\n      need_hide = false;\n    } else {\n      no_write_message();\n      return;\n    }\n  }\n\n\n  // free buffer when not hiding it or when it's a scratch buffer\n  if (tp == NULL) {\n    win_close(win, !need_hide && !buf_hide(buf));\n  } else {\n    win_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n  }\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\nstatic void ex_tabclose(exarg_T *eap)\n{\n  tabpage_T *tp;\n\n  if (cmdwin_type != 0) {\n    cmdwin_result = K_IGNORE;\n  } else if (first_tabpage->tp_next == NULL) {\n    EMSG(_(\"E784: Cannot close last tab page\"));\n  } else {\n    int tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL) {\n      tp = find_tabpage(tab_number);\n      if (tp == NULL) {\n        beep_flush();\n        return;\n      }\n      if (tp != curtab) {\n        tabpage_close_other(tp, eap->forceit);\n        return;\n      } else if (!text_locked() && !curbuf_locked()) {\n        tabpage_close(eap->forceit);\n      }\n    }\n  }\n}\n\n/// \":tabonly\": close all tab pages except the current one\nstatic void ex_tabonly(exarg_T *eap)\n{\n  if (cmdwin_type != 0) {\n    cmdwin_result = K_IGNORE;\n  } else if (first_tabpage->tp_next == NULL) {\n    MSG(_(\"Already only one tab page\"));\n  } else {\n    int tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL) {\n      goto_tabpage(tab_number);\n      // Repeat this up to a 1000 times, because autocommands may\n      // mess up the lists.\n      for (int done = 0; done < 1000; done++) {\n        FOR_ALL_TABS(tp) {\n          if (tp->tp_topframe != topframe) {\n            tabpage_close_other(tp, eap->forceit);\n            // if we failed to close it quit\n            if (valid_tabpage(tp)) {\n              done = 1000;\n            }\n            // start over, \"tp\" is now invalid\n            break;\n          }\n        }\n        assert(first_tabpage);\n        if (first_tabpage->tp_next == NULL) {\n          break;\n        }\n      }\n    }\n  }\n}\n\n/*\n * Close the current tab page.\n */\nvoid tabpage_close(int forceit)\n{\n  // First close all the windows but the current one.  If that worked then\n  // close the last window in this tab, that will close it.\n  while (curwin->w_floating) {\n    ex_win_close(forceit, curwin, NULL);\n  }\n  if (!ONE_WINDOW) {\n    close_others(true, forceit);\n  }\n  if (ONE_WINDOW) {\n    ex_win_close(forceit, curwin, NULL);\n  }\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\nvoid tabpage_close_other(tabpage_T *tp, int forceit)\n{\n  int done = 0;\n  win_T *wp;\n  int h = tabline_height();\n  char_u prev_idx[NUMBUFLEN];\n\n  /* Limit to 1000 windows, autocommands may add a window while we close\n   * one.  OK, so I'm paranoid... */\n  while (++done < 1000) {\n    snprintf((char *)prev_idx, sizeof(prev_idx), \"%i\", tabpage_index(tp));\n    wp = tp->tp_lastwin;\n    ex_win_close(forceit, wp, tp);\n\n    /* Autocommands may delete the tab page under our fingers and we may\n     * fail to close a window with a modified buffer. */\n    if (!valid_tabpage(tp) || tp->tp_firstwin == wp) {\n      break;\n    }\n  }\n\n  redraw_tabline = true;\n  if (h != tabline_height()) {\n    shell_new_rows();\n  }\n}\n\n/*\n * \":only\".\n */\nstatic void ex_only(exarg_T *eap)\n{\n  win_T *wp;\n  int wnr;\n\n  if (eap->addr_count > 0) {\n    wnr = eap->line2;\n    for (wp = firstwin; --wnr > 0;) {\n      if (wp->w_next == NULL) {\n        break;\n      } else {\n        wp = wp->w_next;\n      }\n    }\n  } else {\n    wp = curwin;\n  }\n  if (wp != curwin) {\n    win_goto(wp);\n  }\n  close_others(TRUE, eap->forceit);\n}\n\n/*\n * \":all\" and \":sall\".\n * Also used for \":tab drop file ...\" after setting the argument list.\n */\nvoid ex_all(exarg_T *eap)\n{\n  if (eap->addr_count == 0) {\n    eap->line2 = 9999;\n  }\n  do_arg_all((int)eap->line2, eap->forceit, eap->cmdidx == CMD_drop);\n}\n\nstatic void ex_hide(exarg_T *eap)\n{\n  // \":hide\" or \":hide | cmd\": hide current window\n  if (!eap->skip) {\n    if (eap->addr_count == 0) {\n      win_close(curwin, false);  // don't free buffer\n    } else {\n      int winnr = 0;\n      win_T *win = NULL;\n\n      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n        winnr++;\n        if (winnr == eap->line2) {\n          win = wp;\n          break;\n        }\n      }\n      if (win == NULL) {\n        win = lastwin;\n      }\n      win_close(win, false);\n    }\n  }\n}\n\n/// \":stop\" and \":suspend\": Suspend Vim.\nstatic void ex_stop(exarg_T *eap)\n{\n  if (!eap->forceit) {\n    autowrite_all();\n  }\n  apply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, false, NULL);\n\n  // TODO(bfredl): the TUI should do this on suspend\n  ui_cursor_goto(Rows - 1, 0);\n  ui_call_grid_scroll(1, 0, Rows, 0, Columns, 1, 0);\n  ui_flush();\n  ui_call_suspend();  // call machine specific function\n\n  ui_flush();\n  maketitle();\n  resettitle();  // force updating the title\n  ui_refresh();  // may have resized window\n  apply_autocmds(EVENT_VIMRESUME, NULL, NULL, false, NULL);\n}\n\n// \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\nstatic void ex_exit(exarg_T *eap)\n{\n  if (cmdwin_type != 0) {\n    cmdwin_result = Ctrl_C;\n    return;\n  }\n  // Don't quit while editing the command line.\n  if (text_locked()) {\n    text_locked_msg();\n    return;\n  }\n\n  // we plan to exit if there is only one relevant window\n  if (check_more(false, eap->forceit) == OK && only_one_window()) {\n    exiting = true;\n  }\n  // Write the buffer for \":wq\" or when it was changed.\n  // Trigger QuitPre and ExitPre.\n  // Check if we can exit now, after autocommands have changed things.\n  if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n      || before_quit_autocmds(curwin, false, eap->forceit)\n      || check_more(true, eap->forceit) == FAIL\n      || (only_one_window() && check_changed_any(eap->forceit, false))) {\n    not_exiting();\n  } else {\n    if (only_one_window()) {\n      // quit last window, exit Vim\n      getout(0);\n    }\n    not_exiting();\n    // Quit current window, may free the buffer.\n    win_close(curwin, !buf_hide(curwin->w_buffer));\n  }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\nstatic void ex_print(exarg_T *eap)\n{\n  if (curbuf->b_ml.ml_flags & ML_EMPTY) {\n    EMSG(_(e_emptybuf));\n  } else {\n    for (; !got_int; os_breakcheck()) {\n      print_line(eap->line1,\n                 (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n                  || (eap->flags & EXFLAG_NR)),\n                 eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n      if (++eap->line1 > eap->line2) {\n        break;\n      }\n      ui_flush();                  // show one line at a time\n    }\n    setpcmark();\n    // put cursor at last line\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n  }\n\n  ex_no_reprint = true;\n}\n\nstatic void ex_goto(exarg_T *eap)\n{\n  goto_byte(eap->line2);\n}\n\n/*\n * Clear an argument list: free all file names and reset it to zero entries.\n */\nvoid alist_clear(alist_T *al)\n{\n# define FREE_AENTRY_FNAME(arg) xfree(arg->ae_fname)\n  GA_DEEP_CLEAR(&al->al_ga, aentry_T, FREE_AENTRY_FNAME);\n}\n\n/*\n * Init an argument list.\n */\nvoid alist_init(alist_T *al)\n{\n  ga_init(&al->al_ga, (int)sizeof(aentry_T), 5);\n}\n\n\n/*\n * Remove a reference from an argument list.\n * Ignored when the argument list is the global one.\n * If the argument list is no longer used by any window, free it.\n */\nvoid alist_unlink(alist_T *al)\n{\n  if (al != &global_alist && --al->al_refcount <= 0) {\n    alist_clear(al);\n    xfree(al);\n  }\n}\n\n/*\n * Create a new argument list and use it for the current window.\n */\nvoid alist_new(void)\n{\n  curwin->w_alist = xmalloc(sizeof(*curwin->w_alist));\n  curwin->w_alist->al_refcount = 1;\n  curwin->w_alist->id = ++max_alist_id;\n  alist_init(curwin->w_alist);\n}\n\n#if !defined(UNIX)\n/*\n * Expand the file names in the global argument list.\n * If \"fnum_list\" is not NULL, use \"fnum_list[fnum_len]\" as a list of buffer\n * numbers to be re-used.\n */\nvoid alist_expand(int *fnum_list, int fnum_len)\n{\n  char_u **old_arg_files;\n  int old_arg_count;\n  char_u **new_arg_files;\n  int new_arg_file_count;\n  char_u *save_p_su = p_su;\n  int i;\n\n  /* Don't use 'suffixes' here.  This should work like the shell did the\n   * expansion.  Also, the vimrc file isn't read yet, thus the user\n   * can't set the options. */\n  p_su = empty_option;\n  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);\n  for (i = 0; i < GARGCOUNT; ++i) {\n    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);\n  }\n  old_arg_count = GARGCOUNT;\n  if (expand_wildcards(old_arg_count, old_arg_files,\n                       &new_arg_file_count, &new_arg_files,\n                       EW_FILE|EW_NOTFOUND|EW_ADDSLASH|EW_NOERROR) == OK\n      && new_arg_file_count > 0) {\n    alist_set(&global_alist, new_arg_file_count, new_arg_files,\n              TRUE, fnum_list, fnum_len);\n    FreeWild(old_arg_count, old_arg_files);\n  }\n  p_su = save_p_su;\n}\n#endif\n\n/*\n * Set the argument list for the current window.\n * Takes over the allocated files[] and the allocated fnames in it.\n */\nvoid alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len)\n{\n  int i;\n  static int recursive = 0;\n\n  if (recursive) {\n    EMSG(_(e_au_recursive));\n    return;\n  }\n  recursive++;\n\n  alist_clear(al);\n  ga_grow(&al->al_ga, count);\n  {\n    for (i = 0; i < count; ++i) {\n      if (got_int) {\n        /* When adding many buffers this can take a long time.  Allow\n         * interrupting here. */\n        while (i < count) {\n          xfree(files[i++]);\n        }\n        break;\n      }\n\n      /* May set buffer name of a buffer previously used for the\n       * argument list, so that it's re-used by alist_add. */\n      if (fnum_list != NULL && i < fnum_len) {\n        buf_set_name(fnum_list[i], files[i]);\n      }\n\n      alist_add(al, files[i], use_curbuf ? 2 : 1);\n      os_breakcheck();\n    }\n    xfree(files);\n  }\n\n  if (al == &global_alist) {\n    arg_had_last = false;\n  }\n  recursive--;\n}\n\n/// Add file \"fname\" to argument list \"al\".\n/// \"fname\" must have been allocated and \"al\" must have been checked for room.\n///\n/// @param set_fnum  1: set buffer number; 2: re-use curbuf\nvoid alist_add(alist_T *al, char_u *fname, int set_fnum)\n{\n  if (fname == NULL) {          // don't add NULL file names\n    return;\n  }\n#ifdef BACKSLASH_IN_FILENAME\n  slash_adjust(fname);\n#endif\n  AARGLIST(al)[al->al_ga.ga_len].ae_fname = fname;\n  if (set_fnum > 0) {\n    AARGLIST(al)[al->al_ga.ga_len].ae_fnum =\n      buflist_add(fname, BLN_LISTED | (set_fnum == 2 ? BLN_CURBUF : 0));\n  }\n  ++al->al_ga.ga_len;\n}\n\n#if defined(BACKSLASH_IN_FILENAME)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\nvoid alist_slash_adjust(void)\n{\n  for (int i = 0; i < GARGCOUNT; ++i) {\n    if (GARGLIST[i].ae_fname != NULL) {\n      slash_adjust(GARGLIST[i].ae_fname);\n    }\n  }\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_alist != &global_alist) {\n      for (int i = 0; i < WARGCOUNT(wp); ++i) {\n        if (WARGLIST(wp)[i].ae_fname != NULL) {\n          slash_adjust(WARGLIST(wp)[i].ae_fname);\n        }\n      }\n    }\n  }\n}\n\n#endif\n\n/// \":preserve\".\nstatic void ex_preserve(exarg_T *eap)\n{\n  curbuf->b_flags |= BF_PRESERVED;\n  ml_preserve(curbuf, true, true);\n}\n\n/// \":recover\".\nstatic void ex_recover(exarg_T *eap)\n{\n  // Set recoverymode right away to avoid the ATTENTION prompt.\n  recoverymode = true;\n  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n                     | CCGD_MULTWIN\n                     | (eap->forceit ? CCGD_FORCEIT : 0)\n                     | CCGD_EXCMD)\n\n      && (*eap->arg == NUL\n          || setfname(curbuf, eap->arg, NULL, true) == OK)) {\n    ml_recover(true);\n  }\n  recoverymode = false;\n}\n\n/*\n * Command modifier used in a wrong way.\n */\nstatic void ex_wrongmodifier(exarg_T *eap)\n{\n  eap->errmsg = e_invcmd;\n}\n\n/*\n * :sview [+command] file       split window with new file, read-only\n * :split [[+command] file]     split window with current or new file\n * :vsplit [[+command] file]    split window vertically with current or new file\n * :new [[+command] file]       split window with no or new file\n * :vnew [[+command] file]      split vertically window with no or new file\n * :sfind [+command] file       split window with file in 'path'\n *\n * :tabedit                     open new Tab page with empty window\n * :tabedit [+command] file     open new Tab page and edit \"file\"\n * :tabnew [[+command] file]    just like :tabedit\n * :tabfind [+command] file     open new Tab page and find \"file\"\n */\nvoid ex_splitview(exarg_T *eap)\n{\n  win_T *old_curwin = curwin;\n  char_u *fname = NULL;\n  const bool use_tab = eap->cmdidx == CMD_tabedit\n                       || eap->cmdidx == CMD_tabfind\n                       || eap->cmdidx == CMD_tabnew;\n\n  /* A \":split\" in the quickfix window works like \":new\".  Don't want two\n   * quickfix windows.  But it's OK when doing \":tab split\". */\n  if (bt_quickfix(curbuf) && cmdmod.tab == 0) {\n    if (eap->cmdidx == CMD_split) {\n      eap->cmdidx = CMD_new;\n    }\n    if (eap->cmdidx == CMD_vsplit) {\n      eap->cmdidx = CMD_vnew;\n    }\n  }\n\n  if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind) {\n    fname = find_file_in_path(eap->arg, STRLEN(eap->arg),\n                              FNAME_MESS, TRUE, curbuf->b_ffname);\n    if (fname == NULL) {\n      goto theend;\n    }\n    eap->arg = fname;\n  }\n\n  /*\n   * Either open new tab page or split the window.\n   */\n  if (use_tab) {\n    if (win_new_tabpage(cmdmod.tab != 0 ? cmdmod.tab : eap->addr_count == 0\n                        ? 0 : (int)eap->line2 + 1, eap->arg) != FAIL) {\n      do_exedit(eap, old_curwin);\n      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);\n\n      // set the alternate buffer for the window we came from\n      if (curwin != old_curwin\n          && win_valid(old_curwin)\n          && old_curwin->w_buffer != curbuf\n          && !cmdmod.keepalt) {\n        old_curwin->w_alt_fnum = curbuf->b_fnum;\n      }\n    }\n  } else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n                       *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL) {\n    /* Reset 'scrollbind' when editing another file, but keep it when\n     * doing \":split\" without arguments. */\n    if (*eap->arg != NUL\n        ) {\n      RESET_BINDING(curwin);\n    } else {\n      do_check_scrollbind(false);\n    }\n    do_exedit(eap, old_curwin);\n  }\n\n\ntheend:\n  xfree(fname);\n}\n\n/*\n * Open a new tab page.\n */\nvoid tabpage_new(void)\n{\n  exarg_T ea;\n\n  memset(&ea, 0, sizeof(ea));\n  ea.cmdidx = CMD_tabnew;\n  ea.cmd = (char_u *)\"tabn\";\n  ea.arg = (char_u *)\"\";\n  ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\nstatic void ex_tabnext(exarg_T *eap)\n{\n  int tab_number;\n\n  switch (eap->cmdidx) {\n  case CMD_tabfirst:\n  case CMD_tabrewind:\n    goto_tabpage(1);\n    break;\n  case CMD_tablast:\n    goto_tabpage(9999);\n    break;\n  case CMD_tabprevious:\n  case CMD_tabNext:\n    if (eap->arg && *eap->arg != NUL) {\n      char_u *p = eap->arg;\n      char_u *p_save = p;\n      tab_number = getdigits(&p, false, 0);\n      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL\n          || tab_number == 0) {\n        // No numbers as argument.\n        eap->errmsg = e_invarg;\n        return;\n      }\n    } else {\n      if (eap->addr_count == 0) {\n        tab_number = 1;\n      } else {\n        tab_number = eap->line2;\n        if (tab_number < 1) {\n          eap->errmsg = e_invrange;\n          return;\n        }\n      }\n    }\n    goto_tabpage(-tab_number);\n    break;\n  default:       // CMD_tabnext\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL) {\n      goto_tabpage(tab_number);\n    }\n    break;\n  }\n}\n\n/*\n * :tabmove command\n */\nstatic void ex_tabmove(exarg_T *eap)\n{\n  int tab_number = get_tabpage_arg(eap);\n  if (eap->errmsg == NULL) {\n    tabpage_move(tab_number);\n  }\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\nstatic void ex_tabs(exarg_T *eap)\n{\n  int tabcount = 1;\n\n  msg_start();\n  msg_scroll = TRUE;\n\n  win_T *lastused_win = valid_tabpage(lastused_tabpage)\n    ? lastused_tabpage->tp_curwin\n    : NULL;\n\n  FOR_ALL_TABS(tp) {\n    if (got_int) {\n      break;\n    }\n\n    msg_putchar('\\n');\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n    msg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n    ui_flush();            // output one line at a time\n    os_breakcheck();\n\n    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n      if (got_int) {\n        break;\n      }\n\n      msg_putchar('\\n');\n      msg_putchar(wp == curwin ? '>' : wp == lastused_win ? '#' : ' ');\n      msg_putchar(' ');\n      msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n      msg_putchar(' ');\n      if (buf_spname(wp->w_buffer) != NULL) {\n        STRLCPY(IObuff, buf_spname(wp->w_buffer), IOSIZE);\n      } else {\n        home_replace(wp->w_buffer, wp->w_buffer->b_fname, IObuff, IOSIZE, true);\n      }\n      msg_outtrans(IObuff);\n      ui_flush();                  // output one line at a time\n      os_breakcheck();\n    }\n  }\n}\n\n\n/*\n * \":mode\":\n * If no argument given, get the screen size and redraw.\n */\nstatic void ex_mode(exarg_T *eap)\n{\n  if (*eap->arg == NUL) {\n    must_redraw = CLEAR;\n    ex_redraw(eap);\n  } else {\n    EMSG(_(e_screenmode));\n  }\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\nstatic void ex_resize(exarg_T *eap)\n{\n  int n;\n  win_T *wp = curwin;\n\n  if (eap->addr_count > 0) {\n    n = eap->line2;\n    for (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next) {\n      ;\n    }\n  }\n\n  n = atol((char *)eap->arg);\n  if (cmdmod.split & WSP_VERT) {\n    if (*eap->arg == '-' || *eap->arg == '+') {\n      n += wp->w_width;\n    } else if (n == 0 && eap->arg[0] == NUL) {  // default is very wide\n      n = Columns;\n    }\n    win_setwidth_win(n, wp);\n  } else {\n    if (*eap->arg == '-' || *eap->arg == '+') {\n      n += wp->w_height;\n    } else if (n == 0 && eap->arg[0] == NUL) {  // default is very high\n      n = Rows-1;\n    }\n    win_setheight_win(n, wp);\n  }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\nstatic void ex_find(exarg_T *eap)\n{\n  char_u *fname;\n  int count;\n\n  fname = find_file_in_path(eap->arg, STRLEN(eap->arg),\n                            FNAME_MESS, TRUE, curbuf->b_ffname);\n  if (eap->addr_count > 0) {\n    /* Repeat finding the file \"count\" times.  This matters when it\n     * appears several times in the path. */\n    count = eap->line2;\n    while (fname != NULL && --count > 0) {\n      xfree(fname);\n      fname = find_file_in_path(NULL, 0, FNAME_MESS, FALSE, curbuf->b_ffname);\n    }\n  }\n\n  if (fname != NULL) {\n    eap->arg = fname;\n    do_exedit(eap, NULL);\n    xfree(fname);\n  }\n}\n\n/// \":edit\", \":badd\", \":balt\", \":visual\".\nstatic void ex_edit(exarg_T *eap)\n{\n  do_exedit(eap, NULL);\n}\n\n/// \":edit <file>\" command and alikes.\n///\n/// @param old_curwin  curwin before doing a split or NULL\nvoid do_exedit(exarg_T *eap, win_T *old_curwin)\n{\n  int n;\n  int need_hide;\n\n  /*\n   * \":vi\" command ends Ex mode.\n   */\n  if (exmode_active && (eap->cmdidx == CMD_visual\n                        || eap->cmdidx == CMD_view)) {\n    exmode_active = false;\n    ex_pressedreturn = false;\n    if (*eap->arg == NUL) {\n      // Special case:  \":global/pat/visual\\NLvi-commands\"\n      if (global_busy) {\n        int rd = RedrawingDisabled;\n        int nwr = no_wait_return;\n        int ms = msg_scroll;\n\n        if (eap->nextcmd != NULL) {\n          stuffReadbuff((const char *)eap->nextcmd);\n          eap->nextcmd = NULL;\n        }\n\n        RedrawingDisabled = 0;\n        no_wait_return = 0;\n        need_wait_return = false;\n        msg_scroll = 0;\n        redraw_all_later(NOT_VALID);\n\n        normal_enter(false, true);\n\n        RedrawingDisabled = rd;\n        no_wait_return = nwr;\n        msg_scroll = ms;\n      }\n      return;\n    }\n  }\n\n  if ((eap->cmdidx == CMD_new\n       || eap->cmdidx == CMD_tabnew\n       || eap->cmdidx == CMD_tabedit\n       || eap->cmdidx == CMD_vnew\n       ) && *eap->arg == NUL) {\n    // \":new\" or \":tabnew\" without argument: edit an new empty buffer\n    setpcmark();\n    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n                  ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n                  old_curwin == NULL ? curwin : NULL);\n  } else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n             || *eap->arg != NUL) {\n    // Can't edit another file when \"curbuf->b_ro_lockec\" is set.  Only \":edit\"\n    // can bring us here, others are stopped earlier.\n    if (*eap->arg != NUL && curbuf_locked()) {\n      return;\n    }\n    n = readonlymode;\n    if (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview) {\n      readonlymode = true;\n    } else if (eap->cmdidx == CMD_enew) {\n      readonlymode = false;  // 'readonly' doesn't make sense\n                             // in an empty buffer\n    }\n    if (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd) {\n      setpcmark();\n    }\n    if (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n                NULL, eap, eap->do_ecmd_lnum,\n                (buf_hide(curbuf) ? ECMD_HIDE : 0)\n                + (eap->forceit ? ECMD_FORCEIT : 0)\n                // After a split we can use an existing buffer.\n                + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n                + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n                + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n                , old_curwin == NULL ? curwin : NULL) == FAIL) {\n      // Editing the file failed.  If the window was split, close it.\n      if (old_curwin != NULL) {\n        need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n        if (!need_hide || buf_hide(curbuf)) {\n          cleanup_T cs;\n\n          /* Reset the error/interrupt/exception state here so that\n           * aborting() returns FALSE when closing a window. */\n          enter_cleanup(&cs);\n          win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n          /* Restore the error/interrupt/exception state if not\n           * discarded by a new aborting error, interrupt, or\n           * uncaught exception. */\n          leave_cleanup(&cs);\n        }\n      }\n    } else if (readonlymode && curbuf->b_nwindows == 1) {\n      /* When editing an already visited buffer, 'readonly' won't be set\n       * but the previous value is kept.  With \":view\" and \":sview\" we\n       * want the  file to be readonly, except when another window is\n       * editing the same buffer. */\n      curbuf->b_p_ro = TRUE;\n    }\n    readonlymode = n;\n  } else {\n    if (eap->do_ecmd_cmd != NULL) {\n      do_cmdline_cmd((char *)eap->do_ecmd_cmd);\n    }\n    n = curwin->w_arg_idx_invalid;\n    check_arg_idx(curwin);\n    if (n != curwin->w_arg_idx_invalid) {\n      maketitle();\n    }\n  }\n\n  /*\n   * if \":split file\" worked, set alternate file name in old window to new\n   * file\n   */\n  if (old_curwin != NULL\n      && *eap->arg != NUL\n      && curwin != old_curwin\n      && win_valid(old_curwin)\n      && old_curwin->w_buffer != curbuf\n      && !cmdmod.keepalt) {\n    old_curwin->w_alt_fnum = curbuf->b_fnum;\n  }\n\n  ex_no_reprint = true;\n}\n\n/// \":gui\" and \":gvim\" when there is no GUI.\nstatic void ex_nogui(exarg_T *eap)\n{\n  eap->errmsg = (char_u *)N_(\"E25: Nvim does not have a built-in GUI\");\n}\n\n\n\nstatic void ex_swapname(exarg_T *eap)\n{\n  if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL) {\n    MSG(_(\"No swap file\"));\n  } else {\n    msg(curbuf->b_ml.ml_mfp->mf_fname);\n  }\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\nstatic void ex_syncbind(exarg_T *eap)\n{\n  win_T *save_curwin = curwin;\n  buf_T *save_curbuf = curbuf;\n  long topline;\n  long y;\n  linenr_T old_linenr = curwin->w_cursor.lnum;\n\n  setpcmark();\n\n  /*\n   * determine max topline\n   */\n  if (curwin->w_p_scb) {\n    topline = curwin->w_topline;\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_p_scb && wp->w_buffer) {\n        y = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value(curwin);\n        if (topline > y) {\n          topline = y;\n        }\n      }\n    }\n    if (topline < 1) {\n      topline = 1;\n    }\n  } else {\n    topline = 1;\n  }\n\n\n  /*\n   * Set all scrollbind windows to the same topline.\n   */\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    curwin = wp;\n    if (curwin->w_p_scb) {\n      curbuf = curwin->w_buffer;\n      y = topline - curwin->w_topline;\n      if (y > 0) {\n        scrollup(y, TRUE);\n      } else {\n        scrolldown(-y, TRUE);\n      }\n      curwin->w_scbind_pos = topline;\n      redraw_later(curwin, VALID);\n      cursor_correct();\n      curwin->w_redr_status = TRUE;\n    }\n  }\n  curwin = save_curwin;\n  curbuf = save_curbuf;\n  if (curwin->w_p_scb) {\n    did_syncbind = true;\n    checkpcmark();\n    if (old_linenr != curwin->w_cursor.lnum) {\n      char_u ctrl_o[2];\n\n      ctrl_o[0] = Ctrl_O;\n      ctrl_o[1] = 0;\n      ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);\n    }\n  }\n}\n\n\nstatic void ex_read(exarg_T *eap)\n{\n  int i;\n  int empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n  linenr_T lnum;\n\n  if (eap->usefilter) {  // :r!cmd\n    do_bang(1, eap, false, false, true);\n  } else {\n    if (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL) {\n      return;\n    }\n\n    if (*eap->arg == NUL) {\n      if (check_fname() == FAIL) {       // check for no file name\n        return;\n      }\n      i = readfile(curbuf->b_ffname, curbuf->b_fname,\n                   eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n    } else {\n      if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL) {\n        (void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n      }\n      i = readfile(eap->arg, NULL,\n                   eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n    }\n    if (i != OK) {\n      if (!aborting()) {\n        EMSG2(_(e_notopen), eap->arg);\n      }\n    } else {\n      if (empty && exmode_active) {\n        /* Delete the empty line that remains.  Historically ex does\n         * this but vi doesn't. */\n        if (eap->line2 == 0) {\n          lnum = curbuf->b_ml.ml_line_count;\n        } else {\n          lnum = 1;\n        }\n        if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK) {\n          ml_delete(lnum, false);\n          if (curwin->w_cursor.lnum > 1\n              && curwin->w_cursor.lnum >= lnum) {\n            curwin->w_cursor.lnum--;\n          }\n          deleted_lines_mark(lnum, 1L);\n        }\n      }\n      redraw_curbuf_later(VALID);\n    }\n  }\n}\n\nstatic char_u *prev_dir = NULL;\n\n#if defined(EXITFREE)\nvoid free_cd_dir(void)\n{\n  XFREE_CLEAR(prev_dir);\n  XFREE_CLEAR(globaldir);\n}\n\n#endif\n\n/// Deal with the side effects of changing the current directory.\n///\n/// @param scope  Scope of the function call (global, tab or window).\nvoid post_chdir(CdScope scope, bool trigger_dirchanged)\n{\n  // Always overwrite the window-local CWD.\n  XFREE_CLEAR(curwin->w_localdir);\n\n  // Overwrite the tab-local CWD for :cd, :tcd.\n  if (scope >= kCdScopeTab) {\n    XFREE_CLEAR(curtab->tp_localdir);\n  }\n\n  if (scope < kCdScopeGlobal) {\n    // If still in global directory, set CWD as the global directory.\n    if (globaldir == NULL && prev_dir != NULL) {\n      globaldir = vim_strsave(prev_dir);\n    }\n  }\n\n  char cwd[MAXPATHL];\n  if (os_dirname((char_u *)cwd, MAXPATHL) != OK) {\n    return;\n  }\n  switch (scope) {\n  case kCdScopeGlobal:\n    // We are now in the global directory, no need to remember its name.\n    XFREE_CLEAR(globaldir);\n    break;\n  case kCdScopeTab:\n    curtab->tp_localdir = (char_u *)xstrdup(cwd);\n    break;\n  case kCdScopeWindow:\n    curwin->w_localdir = (char_u *)xstrdup(cwd);\n    break;\n  case kCdScopeInvalid:\n    abort();\n  }\n\n  shorten_fnames(true);\n\n  if (trigger_dirchanged) {\n    do_autocmd_dirchanged(cwd, scope, false);\n  }\n}\n\n/// `:cd`, `:tcd`, `:lcd`, `:chdir`, `:tchdir` and `:lchdir`.\nvoid ex_cd(exarg_T *eap)\n{\n  char_u *new_dir;\n  char_u *tofree;\n\n  new_dir = eap->arg;\n#if !defined(UNIX)\n  // for non-UNIX \":cd\" means: print current directory\n  if (*new_dir == NUL) {\n    ex_pwd(NULL);\n  } else\n#endif\n  {\n    if (allbuf_locked()) {\n      return;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0) {\n      if (prev_dir == NULL) {\n        EMSG(_(\"E186: No previous directory\"));\n        return;\n      }\n      new_dir = prev_dir;\n    }\n\n    // Save current directory for next \":cd -\"\n    tofree = prev_dir;\n    if (os_dirname(NameBuff, MAXPATHL) == OK) {\n      prev_dir = vim_strsave(NameBuff);\n    } else {\n      prev_dir = NULL;\n    }\n\n#if defined(UNIX)\n    // On Unix \":cd\" means: go to home directory.\n    if (*new_dir == NUL) {\n      // Use NameBuff for home directory name.\n      expand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n      new_dir = NameBuff;\n    }\n#endif\n    CdScope scope = kCdScopeGlobal;  // Depends on command invoked\n\n    switch (eap->cmdidx) {\n    case CMD_tcd:\n    case CMD_tchdir:\n      scope = kCdScopeTab;\n      break;\n    case CMD_lcd:\n    case CMD_lchdir:\n      scope = kCdScopeWindow;\n      break;\n    default:\n      break;\n    }\n\n    if (vim_chdir(new_dir)) {\n      EMSG(_(e_failed));\n    } else {\n      post_chdir(scope, true);\n      // Echo the new current directory if the command was typed.\n      if (KeyTyped || p_verbose >= 5) {\n        ex_pwd(eap);\n      }\n    }\n\n    xfree(tofree);\n  }\n}\n\n/*\n * \":pwd\".\n */\nstatic void ex_pwd(exarg_T *eap)\n{\n  if (os_dirname(NameBuff, MAXPATHL) == OK) {\n#ifdef BACKSLASH_IN_FILENAME\n    slash_adjust(NameBuff);\n#endif\n    msg(NameBuff);\n  } else {\n    EMSG(_(\"E187: Unknown\"));\n  }\n}\n\n/*\n * \":=\".\n */\nstatic void ex_equal(exarg_T *eap)\n{\n  smsg(\"%\" PRId64, (int64_t)eap->line2);\n  ex_may_print(eap);\n}\n\nstatic void ex_sleep(exarg_T *eap)\n{\n  int n;\n  long len;\n\n  if (cursor_valid()) {\n    n = curwin->w_winrow + curwin->w_wrow - msg_scrolled;\n    if (n >= 0) {\n      ui_cursor_goto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n  }\n\n  len = eap->line2;\n  switch (*eap->arg) {\n  case 'm':\n    break;\n  case NUL:\n    len *= 1000L; break;\n  default:\n    EMSG2(_(e_invarg2), eap->arg); return;\n  }\n  do_sleep(len);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n */\nvoid do_sleep(long msec)\n{\n  ui_flush();  // flush before waiting\n  for (long left = msec; !got_int && left > 0; left -= 1000L) {\n    int next = left > 1000l ? 1000 : (int)left;\n    LOOP_PROCESS_EVENTS_UNTIL(&main_loop, main_loop.events, (int)next, got_int);\n    os_breakcheck();\n  }\n\n  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n  // input buffer, otherwise a following call to input() fails.\n  if (got_int) {\n    (void)vpeekc();\n  }\n}\n\nstatic void do_exmap(exarg_T *eap, int isabbrev)\n{\n  int mode;\n  char_u *cmdp;\n\n  cmdp = eap->cmd;\n  mode = get_map_mode(&cmdp, eap->forceit || isabbrev);\n\n  switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),\n                 eap->arg, mode, isabbrev)) {\n  case 1:\n    EMSG(_(e_invarg));\n    break;\n  case 2:\n    EMSG(isabbrev ? _(e_noabbr) : _(e_nomap));\n    break;\n  }\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\nstatic void ex_winsize(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n\n  if (!ascii_isdigit(*arg)) {\n    EMSG2(_(e_invarg2), arg);\n    return;\n  }\n  int w = getdigits_int(&arg, false, 10);\n  arg = skipwhite(arg);\n  char_u *p = arg;\n  int h = getdigits_int(&arg, false, 10);\n  if (*p != NUL && *arg == NUL) {\n    screen_resize(w, h);\n  } else {\n    EMSG(_(\"E465: :winsize requires two number arguments\"));\n  }\n}\n\nstatic void ex_wincmd(exarg_T *eap)\n{\n  int xchar = NUL;\n  char_u *p;\n\n  if (*eap->arg == 'g' || *eap->arg == Ctrl_G) {\n    // CTRL-W g and CTRL-W CTRL-G  have an extra command character\n    if (eap->arg[1] == NUL) {\n      EMSG(_(e_invarg));\n      return;\n    }\n    xchar = eap->arg[1];\n    p = eap->arg + 2;\n  } else {\n    p = eap->arg + 1;\n  }\n\n  eap->nextcmd = check_nextcmd(p);\n  p = skipwhite(p);\n  if (*p != NUL && *p != '\"' && eap->nextcmd == NULL) {\n    EMSG(_(e_invarg));\n  } else if (!eap->skip) {\n    // Pass flags on for \":vertical wincmd ]\".\n    postponed_split_flags = cmdmod.split;\n    postponed_split_tab = cmdmod.tab;\n    do_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n  }\n}\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\nstatic void ex_operators(exarg_T *eap)\n{\n  oparg_T oa;\n\n  clear_oparg(&oa);\n  oa.regname = eap->regname;\n  oa.start.lnum = eap->line1;\n  oa.end.lnum = eap->line2;\n  oa.line_count = eap->line2 - eap->line1 + 1;\n  oa.motion_type = kMTLineWise;\n  virtual_op = kFalse;\n  if (eap->cmdidx != CMD_yank) {  // position cursor for undo\n    setpcmark();\n    curwin->w_cursor.lnum = eap->line1;\n    beginline(BL_SOL | BL_FIX);\n  }\n\n  if (VIsual_active) {\n    end_visual_mode();\n  }\n\n  switch (eap->cmdidx) {\n  case CMD_delete:\n    oa.op_type = OP_DELETE;\n    op_delete(&oa);\n    break;\n\n  case CMD_yank:\n    oa.op_type = OP_YANK;\n    (void)op_yank(&oa, true, false);\n    break;\n\n  default:          // CMD_rshift or CMD_lshift\n    if (\n        (eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n        ) {\n      oa.op_type = OP_RSHIFT;\n    } else {\n      oa.op_type = OP_LSHIFT;\n    }\n    op_shift(&oa, FALSE, eap->amount);\n    break;\n  }\n  virtual_op = kNone;\n  ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\nstatic void ex_put(exarg_T *eap)\n{\n  // \":0put\" works like \":1put!\".\n  if (eap->line2 == 0) {\n    eap->line2 = 1;\n    eap->forceit = TRUE;\n  }\n  curwin->w_cursor.lnum = eap->line2;\n  do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1,\n         PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\nstatic void ex_copymove(exarg_T *eap)\n{\n  long n = get_address(eap, &eap->arg, eap->addr_type, false, false, false, 1);\n  if (eap->arg == NULL) {  // error detected\n    eap->nextcmd = NULL;\n    return;\n  }\n  get_flags(eap);\n\n  /*\n   * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n   */\n  if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count) {\n    EMSG(_(e_invrange));\n    return;\n  }\n\n  if (eap->cmdidx == CMD_move) {\n    if (do_move(eap->line1, eap->line2, n) == FAIL) {\n      return;\n    }\n  } else {\n    ex_copy(eap->line1, eap->line2, n);\n  }\n  u_clearline();\n  beginline(BL_SOL | BL_FIX);\n  ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\nvoid ex_may_print(exarg_T *eap)\n{\n  if (eap->flags != 0) {\n    print_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n               (eap->flags & EXFLAG_LIST));\n    ex_no_reprint = true;\n  }\n}\n\n/// \":smagic\" and \":snomagic\".\nstatic void ex_submagic(exarg_T *eap)\n{\n  int magic_save = p_magic;\n\n  p_magic = (eap->cmdidx == CMD_smagic);\n  ex_substitute(eap);\n  p_magic = magic_save;\n}\n\n/*\n * \":join\".\n */\nstatic void ex_join(exarg_T *eap)\n{\n  curwin->w_cursor.lnum = eap->line1;\n  if (eap->line1 == eap->line2) {\n    if (eap->addr_count >= 2) {     // :2,2join does nothing\n      return;\n    }\n    if (eap->line2 == curbuf->b_ml.ml_line_count) {\n      beep_flush();\n      return;\n    }\n    ++eap->line2;\n  }\n  do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, true);\n  beginline(BL_WHITE | BL_FIX);\n  ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\": execute register\n */\nstatic void ex_at(exarg_T *eap)\n{\n  int prev_len = typebuf.tb_len;\n\n  curwin->w_cursor.lnum = eap->line2;\n  check_cursor_col();\n\n  // Get the register name. No name means use the previous one.\n  int c = *eap->arg;\n  if (c == NUL) {\n    c = '@';\n  }\n\n  // Put the register in the typeahead buffer with the \"silent\" flag.\n  if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n      == FAIL) {\n    beep_flush();\n  } else {\n    bool save_efr = exec_from_reg;\n\n    exec_from_reg = true;\n\n    /*\n     * Execute from the typeahead buffer.\n     * Continue until the stuff buffer is empty and all added characters\n     * have been consumed.\n     */\n    while (!stuff_empty() || typebuf.tb_len > prev_len) {\n      (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n    }\n\n    exec_from_reg = save_efr;\n  }\n}\n\n/*\n * \":!\".\n */\nstatic void ex_bang(exarg_T *eap)\n{\n  do_bang(eap->addr_count, eap, eap->forceit, true, true);\n}\n\n/*\n * \":undo\".\n */\nstatic void ex_undo(exarg_T *eap)\n{\n  if (eap->addr_count == 1) {       // :undo 123\n    undo_time(eap->line2, false, false, true);\n  } else {\n    u_undo(1);\n  }\n}\n\nstatic void ex_wundo(exarg_T *eap)\n{\n  char_u hash[UNDO_HASH_SIZE];\n\n  u_compute_hash(curbuf, hash);\n  u_write_undo((char *)eap->arg, eap->forceit, curbuf, hash);\n}\n\nstatic void ex_rundo(exarg_T *eap)\n{\n  char_u hash[UNDO_HASH_SIZE];\n\n  u_compute_hash(curbuf, hash);\n  u_read_undo((char *)eap->arg, hash, NULL);\n}\n\n/// \":redo\".\nstatic void ex_redo(exarg_T *eap)\n{\n  u_redo(1);\n}\n\n/// \":earlier\" and \":later\".\nstatic void ex_later(exarg_T *eap)\n{\n  long count = 0;\n  bool sec = false;\n  bool file = false;\n  char_u *p = eap->arg;\n\n  if (*p == NUL) {\n    count = 1;\n  } else if (isdigit(*p)) {\n    count = getdigits_long(&p, false, 0);\n    switch (*p) {\n    case 's':\n      ++p; sec = true; break;\n    case 'm':\n      ++p; sec = true; count *= 60; break;\n    case 'h':\n      ++p; sec = true; count *= 60 * 60; break;\n    case 'd':\n      ++p; sec = true; count *= 24 * 60 * 60; break;\n    case 'f':\n      ++p; file = true; break;\n    }\n  }\n\n  if (*p != NUL) {\n    EMSG2(_(e_invarg2), eap->arg);\n  } else {\n    undo_time(eap->cmdidx == CMD_earlier ? -count : count,\n              sec, file, false);\n  }\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\nstatic void ex_redir(exarg_T *eap)\n{\n  char *mode;\n  char_u *fname;\n  char_u *arg = eap->arg;\n\n  if (STRICMP(eap->arg, \"END\") == 0) {\n    close_redir();\n  } else {\n    if (*arg == '>') {\n      ++arg;\n      if (*arg == '>') {\n        ++arg;\n        mode = \"a\";\n      } else {\n        mode = \"w\";\n      }\n      arg = skipwhite(arg);\n\n      close_redir();\n\n      // Expand environment variables and \"~/\".\n      fname = expand_env_save(arg);\n      if (fname == NULL) {\n        return;\n      }\n\n      redir_fd = open_exfile(fname, eap->forceit, mode);\n      xfree(fname);\n    } else if (*arg == '@') {\n      // redirect to a register a-z (resp. A-Z for appending)\n      close_redir();\n      ++arg;\n      if (valid_yank_reg(*arg, true) && *arg != '_') {\n        redir_reg = *arg++;\n        if (*arg == '>' && arg[1] == '>') {        // append\n          arg += 2;\n        } else {\n          // Can use both \"@a\" and \"@a>\".\n          if (*arg == '>') {\n            arg++;\n          }\n          // Make register empty when not using @A-@Z and the\n          // command is valid.\n          if (*arg == NUL && !isupper(redir_reg)) {\n            write_reg_contents(redir_reg, (char_u *)\"\", 0, false);\n          }\n        }\n      }\n      if (*arg != NUL) {\n        redir_reg = 0;\n        EMSG2(_(e_invarg2), eap->arg);\n      }\n    } else if (*arg == '=' && arg[1] == '>') {\n      int append;\n\n      // redirect to a variable\n      close_redir();\n      arg += 2;\n\n      if (*arg == '>') {\n        ++arg;\n        append = TRUE;\n      } else {\n        append = FALSE;\n      }\n\n      if (var_redir_start(skipwhite(arg), append) == OK) {\n        redir_vname = 1;\n      }\n    }\n    // TODO: redirect to a buffer\n    else {\n      EMSG2(_(e_invarg2), eap->arg);\n    }\n  }\n\n  /* Make sure redirection is not off.  Can happen for cmdline completion\n   * that indirectly invokes a command to catch its output. */\n  if (redir_fd != NULL\n      || redir_reg || redir_vname) {\n    redir_off = false;\n  }\n}\n\n/// \":redraw\": force redraw\nstatic void ex_redraw(exarg_T *eap)\n{\n  if (State & CMDPREVIEW) {\n    return;  // Ignore :redraw during 'inccommand' preview. #9777\n  }\n  int r = RedrawingDisabled;\n  int p = p_lz;\n\n  RedrawingDisabled = 0;\n  p_lz = FALSE;\n  validate_cursor();\n  update_topline(curwin);\n  if (eap->forceit) {\n    redraw_all_later(NOT_VALID);\n  }\n  update_screen(eap->forceit ? NOT_VALID\n                             : VIsual_active ? INVERTED : 0);\n  if (need_maketitle) {\n    maketitle();\n  }\n  RedrawingDisabled = r;\n  p_lz = p;\n\n  // Reset msg_didout, so that a message that's there is overwritten.\n  msg_didout = false;\n  msg_col = 0;\n\n  // No need to wait after an intentional redraw.\n  need_wait_return = false;\n\n  ui_flush();\n}\n\n/// \":redrawstatus\": force redraw of status line(s)\nstatic void ex_redrawstatus(exarg_T *eap)\n{\n  if (State & CMDPREVIEW) {\n    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777\n  }\n  int r = RedrawingDisabled;\n  int p = p_lz;\n\n  RedrawingDisabled = 0;\n  p_lz = FALSE;\n  if (eap->forceit) {\n    status_redraw_all();\n  } else {\n    status_redraw_curbuf();\n  }\n  update_screen(VIsual_active ? INVERTED :\n                0);\n  RedrawingDisabled = r;\n  p_lz = p;\n  ui_flush();\n}\n\n// \":redrawtabline\": force redraw of the tabline\nstatic void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)\n{\n  const int r = RedrawingDisabled;\n  const int p = p_lz;\n\n  RedrawingDisabled = 0;\n  p_lz = false;\n\n  draw_tabline();\n\n  RedrawingDisabled = r;\n  p_lz = p;\n  ui_flush();\n}\n\nstatic void close_redir(void)\n{\n  if (redir_fd != NULL) {\n    fclose(redir_fd);\n    redir_fd = NULL;\n  }\n  redir_reg = 0;\n  if (redir_vname) {\n    var_redir_stop();\n    redir_vname = 0;\n  }\n}\n\n/// Try creating a directory, give error message on failure\n///\n/// @param[in]  name  Directory to create.\n/// @param[in]  prot  Directory permissions.\n///\n/// @return OK in case of success, FAIL otherwise.\nint vim_mkdir_emsg(const char *const name, const int prot)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int ret;\n  if ((ret = os_mkdir(name, prot)) != 0) {\n    EMSG3(_(e_mkdir), name, os_strerror(ret));\n    return FAIL;\n  }\n  return OK;\n}\n\n/// Open a file for writing for an Ex command, with some checks.\n///\n/// @param mode  \"w\" for create new file or \"a\" for append\n///\n/// @return  file descriptor, or NULL on failure.\nFILE *open_exfile(char_u *fname, int forceit, char *mode)\n{\n  FILE *fd;\n\n#ifdef UNIX\n  // with Unix it is possible to open a directory\n  if (os_isdir(fname)) {\n    EMSG2(_(e_isadir2), fname);\n    return NULL;\n  }\n#endif\n  if (!forceit && *mode != 'a' && os_path_exists(fname)) {\n    EMSG2(_(\"E189: \\\"%s\\\" exists (add ! to override)\"), fname);\n    return NULL;\n  }\n\n  if ((fd = os_fopen((char *)fname, mode)) == NULL) {\n    EMSG2(_(\"E190: Cannot open \\\"%s\\\" for writing\"), fname);\n  }\n\n  return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\nstatic void ex_mark(exarg_T *eap)\n{\n  pos_T pos;\n\n  if (*eap->arg == NUL) {               // No argument?\n    EMSG(_(e_argreq));\n  } else if (eap->arg[1] != NUL) {         // more than one character?\n    EMSG(_(e_trailing));\n  } else {\n    pos = curwin->w_cursor;             // save curwin->w_cursor\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_WHITE | BL_FIX);\n    if (setmark(*eap->arg) == FAIL) {   // set mark\n      EMSG(_(\"E191: Argument must be a letter or forward/backward quote\"));\n    }\n    curwin->w_cursor = pos;             // restore curwin->w_cursor\n  }\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\nvoid update_topline_cursor(void)\n{\n  check_cursor();               // put cursor on valid line\n  update_topline(curwin);\n  if (!curwin->w_p_wrap) {\n    validate_cursor();\n  }\n  update_curswant();\n}\n\n// Save the current State and go to Normal mode.\n// Return true if the typeahead could be saved.\nbool save_current_state(save_state_T *sst)\n  FUNC_ATTR_NONNULL_ALL\n{\n  sst->save_msg_scroll = msg_scroll;\n  sst->save_restart_edit = restart_edit;\n  sst->save_msg_didout = msg_didout;\n  sst->save_State = State;\n  sst->save_insertmode = p_im;\n  sst->save_finish_op = finish_op;\n  sst->save_opcount = opcount;\n  sst->save_reg_executing = reg_executing;\n\n  msg_scroll = false;   // no msg scrolling in Normal mode\n  restart_edit = 0;     // don't go to Insert mode\n  p_im = false;         // don't use 'insertmode\n\n  // Save the current typeahead.  This is required to allow using \":normal\"\n  // from an event handler and makes sure we don't hang when the argument\n  // ends with half a command.\n  save_typeahead(&sst->tabuf);\n  return sst->tabuf.typebuf_valid;\n}\n\nvoid restore_current_state(save_state_T *sst)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Restore the previous typeahead.\n  restore_typeahead(&sst->tabuf);\n\n  msg_scroll = sst->save_msg_scroll;\n  if (force_restart_edit) {\n    force_restart_edit = false;\n  } else {\n    // Some function (terminal_enter()) was aware of ex_normal and decided to\n    // override the value of restart_edit anyway.\n    restart_edit = sst->save_restart_edit;\n  }\n  p_im = sst->save_insertmode;\n  finish_op = sst->save_finish_op;\n  opcount = sst->save_opcount;\n  reg_executing = sst->save_reg_executing;\n\n  // don't reset msg_didout now\n  msg_didout |= sst->save_msg_didout;\n\n  // Restore the state (needed when called from a function executed for\n  // 'indentexpr'). Update the mouse and cursor, they may have changed.\n  State = sst->save_State;\n  ui_cursor_shape();  // may show different cursor shape\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\nstatic void ex_normal(exarg_T *eap)\n{\n  if (curbuf->terminal && State & TERM_FOCUS) {\n    EMSG(\"Can't re-enter normal mode from terminal mode\");\n    return;\n  }\n  save_state_T save_state;\n  char_u *arg = NULL;\n  int l;\n  char_u *p;\n\n  if (ex_normal_lock > 0) {\n    EMSG(_(e_secure));\n    return;\n  }\n  if (ex_normal_busy >= p_mmd) {\n    EMSG(_(\"E192: Recursive use of :normal too deep\"));\n    return;\n  }\n\n  // vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n  // this for the K_SPECIAL leading byte, otherwise special keys will not\n  // work.\n  {\n    int len = 0;\n\n    // Count the number of characters to be escaped.\n    for (p = eap->arg; *p != NUL; ++p) {\n      for (l = (*mb_ptr2len)(p) - 1; l > 0; --l) {\n        if (*++p == K_SPECIAL             // trailbyte K_SPECIAL or CSI\n            ) {\n          len += 2;\n        }\n      }\n    }\n    if (len > 0) {\n      arg = xmalloc(STRLEN(eap->arg) + len + 1);\n      len = 0;\n      for (p = eap->arg; *p != NUL; ++p) {\n        arg[len++] = *p;\n        for (l = (*mb_ptr2len)(p) - 1; l > 0; --l) {\n          arg[len++] = *++p;\n          if (*p == K_SPECIAL) {\n            arg[len++] = KS_SPECIAL;\n            arg[len++] = KE_FILLER;\n          }\n        }\n        arg[len] = NUL;\n      }\n    }\n  }\n\n  ex_normal_busy++;\n  if (save_current_state(&save_state)) {\n    // Repeat the :normal command for each line in the range.  When no\n    // range given, execute it just once, without positioning the cursor\n    // first.\n    do {\n      if (eap->addr_count != 0) {\n        curwin->w_cursor.lnum = eap->line1++;\n        curwin->w_cursor.col = 0;\n        check_cursor_moved(curwin);\n      }\n\n      exec_normal_cmd(arg != NULL ? arg : eap->arg,\n                      eap->forceit ? REMAP_NONE : REMAP_YES, false);\n    } while (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n  }\n\n  // Might not return to the main loop when in an event handler.\n  update_topline_cursor();\n\n  restore_current_state(&save_state);\n\n  ex_normal_busy--;\n\n  setmouse();\n  ui_cursor_shape();  // may show different cursor shape\n  xfree(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\nstatic void ex_startinsert(exarg_T *eap)\n{\n  if (eap->forceit) {\n    // cursor line can be zero on startup\n    if (!curwin->w_cursor.lnum) {\n      curwin->w_cursor.lnum = 1;\n    }\n    set_cursor_for_append_to_line();\n  }\n\n  // Ignore the command when already in Insert mode.  Inserting an\n  // expression register that invokes a function can do this.\n  if (State & INSERT) {\n    return;\n  }\n\n  if (eap->cmdidx == CMD_startinsert) {\n    restart_edit = 'a';\n  } else if (eap->cmdidx == CMD_startreplace) {\n    restart_edit = 'R';\n  } else {\n    restart_edit = 'V';\n  }\n\n  if (!eap->forceit) {\n    if (eap->cmdidx == CMD_startinsert) {\n      restart_edit = 'i';\n    }\n    curwin->w_curswant = 0;  // avoid MAXCOL\n  }\n\n  if (VIsual_active) {\n    showmode();\n  }\n}\n\n/*\n * \":stopinsert\"\n */\nstatic void ex_stopinsert(exarg_T *eap)\n{\n  restart_edit = 0;\n  stop_insert_mode = true;\n  clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\nvoid exec_normal_cmd(char_u *cmd, int remap, bool silent)\n{\n  // Stuff the argument into the typeahead buffer.\n  ins_typebuf(cmd, remap, 0, true, silent);\n  exec_normal(false);\n}\n\n/// Execute normal_cmd() until there is no typeahead left.\n///\n/// @param was_typed whether or not something was typed\nvoid exec_normal(bool was_typed)\n{\n  oparg_T oa;\n\n  clear_oparg(&oa);\n  finish_op = false;\n  while ((!stuff_empty()\n          || ((was_typed || !typebuf_typed())\n              && typebuf.tb_len > 0))\n         && !got_int) {\n    update_topline_cursor();\n    normal_cmd(&oa, true);      // execute a Normal mode cmd\n  }\n}\n\nstatic void ex_checkpath(exarg_T *eap)\n{\n  find_pattern_in_path(NULL, 0, 0, false, false, CHECK_PATH, 1L,\n                       eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n                       (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n/*\n * \":psearch\"\n */\nstatic void ex_psearch(exarg_T *eap)\n{\n  g_do_tagpreview = p_pvh;\n  ex_findpat(eap);\n  g_do_tagpreview = 0;\n}\n\nstatic void ex_findpat(exarg_T *eap)\n{\n  bool whole = true;\n  long n;\n  char_u *p;\n  int action;\n\n  switch (cmdnames[eap->cmdidx].cmd_name[2]) {\n  case 'e':             // \":psearch\", \":isearch\" and \":dsearch\"\n    if (cmdnames[eap->cmdidx].cmd_name[0] == 'p') {\n      action = ACTION_GOTO;\n    } else {\n      action = ACTION_SHOW;\n    }\n    break;\n  case 'i':             // \":ilist\" and \":dlist\"\n    action = ACTION_SHOW_ALL;\n    break;\n  case 'u':             // \":ijump\" and \":djump\"\n    action = ACTION_GOTO;\n    break;\n  default:              // \":isplit\" and \":dsplit\"\n    action = ACTION_SPLIT;\n    break;\n  }\n\n  n = 1;\n  if (ascii_isdigit(*eap->arg)) {  // get count\n    n = getdigits_long(&eap->arg, false, 0);\n    eap->arg = skipwhite(eap->arg);\n  }\n  if (*eap->arg == '/') {   // Match regexp, not just whole words\n    whole = false;\n    eap->arg++;\n    p = skip_regexp(eap->arg, '/', p_magic, NULL);\n    if (*p) {\n      *p++ = NUL;\n      p = skipwhite(p);\n\n      // Check for trailing illegal characters.\n      if (!ends_excmd(*p)) {\n        eap->errmsg = e_trailing;\n      } else {\n        eap->nextcmd = check_nextcmd(p);\n      }\n    }\n  }\n  if (!eap->skip) {\n    find_pattern_in_path(eap->arg, 0, STRLEN(eap->arg), whole, !eap->forceit,\n                         *eap->cmd == 'd' ?  FIND_DEFINE : FIND_ANY,\n                         n, action, eap->line1, eap->line2);\n  }\n}\n\n\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\nstatic void ex_ptag(exarg_T *eap)\n{\n  g_do_tagpreview = p_pvh;    // will be reset to 0 in ex_tag_cmd()\n  ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\nstatic void ex_pedit(exarg_T *eap)\n{\n  win_T *curwin_save = curwin;\n\n  // Open the preview window or popup and make it the current window.\n  g_do_tagpreview = p_pvh;\n  prepare_tagpreview(true);\n\n  // Edit the file.\n  do_exedit(eap, NULL);\n\n  if (curwin != curwin_save && win_valid(curwin_save)) {\n    // Return cursor to where we were\n    validate_cursor();\n    redraw_later(curwin, VALID);\n    win_enter(curwin_save, true);\n  }\n  g_do_tagpreview = 0;\n}\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\nstatic void ex_stag(exarg_T *eap)\n{\n  postponed_split = -1;\n  postponed_split_flags = cmdmod.split;\n  postponed_split_tab = cmdmod.tab;\n  ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n  postponed_split_flags = 0;\n  postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\nstatic void ex_tag(exarg_T *eap)\n{\n  ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\nstatic void ex_tag_cmd(exarg_T *eap, char_u *name)\n{\n  int cmd;\n\n  switch (name[1]) {\n  case 'j':\n    cmd = DT_JUMP;              // \":tjump\"\n    break;\n  case 's':\n    cmd = DT_SELECT;            // \":tselect\"\n    break;\n  case 'p':                             // \":tprevious\"\n  case 'N':\n    cmd = DT_PREV;              // \":tNext\"\n    break;\n  case 'n':\n    cmd = DT_NEXT;              // \":tnext\"\n    break;\n  case 'o':\n    cmd = DT_POP;               // \":pop\"\n    break;\n  case 'f':                             // \":tfirst\"\n  case 'r':\n    cmd = DT_FIRST;             // \":trewind\"\n    break;\n  case 'l':\n    cmd = DT_LAST;              // \":tlast\"\n    break;\n  default:                              // \":tag\"\n    if (p_cst && *eap->arg != NUL) {\n      ex_cstag(eap);\n      return;\n    }\n    cmd = DT_TAG;\n    break;\n  }\n\n  if (name[0] == 'l') {\n    cmd = DT_LTAG;\n  }\n\n  do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n         eap->forceit, TRUE);\n}\n\nenum {\n  SPEC_PERC = 0,\n  SPEC_HASH,\n  SPEC_CWORD,\n  SPEC_CCWORD,\n  SPEC_CEXPR,\n  SPEC_CFILE,\n  SPEC_SFILE,\n  SPEC_SLNUM,\n  SPEC_STACK,\n  SPEC_AFILE,\n  SPEC_ABUF,\n  SPEC_AMATCH,\n  SPEC_SFLNUM,\n  SPEC_SID,\n  // SPEC_CLIENT,\n};\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\nssize_t find_cmdline_var(const char_u *src, size_t *usedlen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  size_t len;\n  static char *(spec_str[]) = {\n    [SPEC_PERC] = \"%\",\n    [SPEC_HASH] = \"#\",\n    [SPEC_CWORD] = \"<cword>\",           // cursor word\n    [SPEC_CCWORD] = \"<cWORD>\",          // cursor WORD\n    [SPEC_CEXPR] = \"<cexpr>\",           // expr under cursor\n    [SPEC_CFILE] = \"<cfile>\",           // cursor path name\n    [SPEC_SFILE] = \"<sfile>\",           // \":so\" file name\n    [SPEC_SLNUM] = \"<slnum>\",           // \":so\" file line number\n    [SPEC_STACK] = \"<stack>\",           // call stack\n    [SPEC_AFILE] = \"<afile>\",           // autocommand file name\n    [SPEC_ABUF] = \"<abuf>\",             // autocommand buffer number\n    [SPEC_AMATCH] = \"<amatch>\",         // autocommand match name\n    [SPEC_SFLNUM] = \"<sflnum>\",         // script file line number\n    [SPEC_SID] = \"<SID>\",               // script ID: <SNR>123_\n    // [SPEC_CLIENT] = \"<client>\",\n  };\n\n  for (size_t i = 0; i < ARRAY_SIZE(spec_str); ++i) {\n    len = STRLEN(spec_str[i]);\n    if (STRNCMP(src, spec_str[i], len) == 0) {\n      *usedlen = len;\n      assert(i <= SSIZE_MAX);\n      return (ssize_t)i;\n    }\n  }\n  return -1;\n}\n\n/// Evaluate cmdline variables.\n///\n/// change '%'       to curbuf->b_ffname\n///        '#'       to curwin->w_alt_fnum\n///        '<cword>' to word under the cursor\n///        '<cWORD>' to WORD under the cursor\n///        '<cexpr>' to C-expression under the cursor\n///        '<cfile>' to path name under the cursor\n///        '<sfile>' to sourced file name\n///        '<slnum>' to sourced file line number\n///        '<afile>' to file name for autocommand\n///        '<abuf>'  to buffer number for autocommand\n///        '<amatch>' to matching name for autocommand\n///\n/// When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n/// \"\" for error without a message) and NULL is returned.\n///\n/// @param src       pointer into commandline\n/// @param srcstart  beginning of valid memory for src\n/// @param usedlen   characters after src that are used\n/// @param lnump     line number for :e command, or NULL\n/// @param errormsg  pointer to error message\n/// @param escaped   return value has escaped white space (can be NULL)\n///\n/// @return          an allocated string if a valid match was found.\n///                  Returns NULL if no match was found.  \"usedlen\" then still contains the\n///                  number of characters to skip.\nchar_u *eval_vars(char_u *src, char_u *srcstart, size_t *usedlen, linenr_T *lnump,\n                  char_u **errormsg, int *escaped)\n{\n  int i;\n  char_u *s;\n  char_u *result;\n  char_u *resultbuf = NULL;\n  size_t resultlen;\n  buf_T *buf;\n  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.\n  bool tilde_file = false;\n  bool skip_mod = false;\n  char strbuf[30];\n\n  *errormsg = NULL;\n  if (escaped != NULL) {\n    *escaped = FALSE;\n  }\n\n  /*\n   * Check if there is something to do.\n   */\n  ssize_t spec_idx = find_cmdline_var(src, usedlen);\n  if (spec_idx < 0) {   // no match\n    *usedlen = 1;\n    return NULL;\n  }\n\n  /*\n   * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n   * Note: In \"\\\\%\" the % is also not recognized!\n   */\n  if (src > srcstart && src[-1] == '\\\\') {\n    *usedlen = 0;\n    STRMOVE(src - 1, src);      // remove backslash\n    return NULL;\n  }\n\n  /*\n   * word or WORD under cursor\n   */\n  if (spec_idx == SPEC_CWORD\n      || spec_idx == SPEC_CCWORD\n      || spec_idx == SPEC_CEXPR) {\n    resultlen = find_ident_under_cursor(&result,\n                                        spec_idx == SPEC_CWORD\n        ? (FIND_IDENT | FIND_STRING)\n        : (spec_idx == SPEC_CEXPR\n           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n           : FIND_STRING));\n    if (resultlen == 0) {\n      *errormsg = (char_u *)\"\";\n      return NULL;\n    }\n    //\n    // '#': Alternate file name\n    // '%': Current file name\n    //        File name under the cursor\n    //        File name for autocommand\n    //    and following modifiers\n    //\n  } else {\n    switch (spec_idx) {\n    case SPEC_PERC:             // '%': current file\n      if (curbuf->b_fname == NULL) {\n        result = (char_u *)\"\";\n        valid = 0;                  // Must have \":p:h\" to be valid\n      } else {\n        result = curbuf->b_fname;\n        tilde_file = STRCMP(result, \"~\") == 0;\n      }\n      break;\n\n    case SPEC_HASH:             // '#' or \"#99\": alternate file\n      if (src[1] == '#') {          // \"##\": the argument list\n        result = arg_all();\n        resultbuf = result;\n        *usedlen = 2;\n        if (escaped != NULL) {\n          *escaped = TRUE;\n        }\n        skip_mod = true;\n        break;\n      }\n      s = src + 1;\n      if (*s == '<') {                  // \"#<99\" uses v:oldfiles.\n        s++;\n      }\n      i = getdigits_int(&s, false, 0);\n      if (s == src + 2 && src[1] == '-') {\n        // just a minus sign, don't skip over it\n        s--;\n      }\n      *usedlen = (size_t)(s - src);           // length of what we expand\n\n      if (src[1] == '<' && i != 0) {\n        if (*usedlen < 2) {\n          // Should we give an error message for #<text?\n          *usedlen = 1;\n          return NULL;\n        }\n        result = (char_u *)tv_list_find_str(get_vim_var_list(VV_OLDFILES),\n                                            i - 1);\n        if (result == NULL) {\n          *errormsg = (char_u *)\"\";\n          return NULL;\n        }\n      } else {\n        if (i == 0 && src[1] == '<' && *usedlen > 1) {\n          *usedlen = 1;\n        }\n        buf = buflist_findnr(i);\n        if (buf == NULL) {\n          *errormsg = (char_u *)_(\"E194: No alternate file name to substitute for '#'\");\n          return NULL;\n        }\n        if (lnump != NULL) {\n          *lnump = ECMD_LAST;\n        }\n        if (buf->b_fname == NULL) {\n          result = (char_u *)\"\";\n          valid = 0;                        // Must have \":p:h\" to be valid\n        } else {\n          result = buf->b_fname;\n          tilde_file = STRCMP(result, \"~\") == 0;\n        }\n      }\n      break;\n\n    case SPEC_CFILE:            // file name under cursor\n      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n      if (result == NULL) {\n        *errormsg = (char_u *)\"\";\n        return NULL;\n      }\n      resultbuf = result;                   // remember allocated string\n      break;\n\n    case SPEC_AFILE:  // file name for autocommand\n      if (autocmd_fname != NULL\n          && !path_is_absolute(autocmd_fname)\n          // For CmdlineEnter and related events, <afile> is not a path! #9348\n          && !strequal(\"/\", (char *)autocmd_fname)) {\n        // Still need to turn the fname into a full path.  It was\n        // postponed to avoid a delay when <afile> is not used.\n        result = (char_u *)FullName_save((char *)autocmd_fname, false);\n        // Copy into `autocmd_fname`, don't reassign it. #8165\n        xstrlcpy((char *)autocmd_fname, (char *)result, MAXPATHL);\n        xfree(result);\n      }\n      result = autocmd_fname;\n      if (result == NULL) {\n        *errormsg = (char_u *)_(\"E495: no autocommand file name to substitute for \\\"<afile>\\\"\");\n        return NULL;\n      }\n      result = path_try_shorten_fname(result);\n      break;\n\n    case SPEC_ABUF:             // buffer number for autocommand\n      if (autocmd_bufnr <= 0) {\n        *errormsg = (char_u *)_(\"E496: no autocommand buffer number to substitute for \\\"<abuf>\\\"\");\n        return NULL;\n      }\n      snprintf(strbuf, sizeof(strbuf), \"%d\", autocmd_bufnr);\n      result = (char_u *)strbuf;\n      break;\n\n    case SPEC_AMATCH:           // match name for autocommand\n      result = autocmd_match;\n      if (result == NULL) {\n        *errormsg = (char_u *)_(\"E497: no autocommand match name to substitute for \\\"<amatch>\\\"\");\n        return NULL;\n      }\n      break;\n\n    case SPEC_SFILE:            // file name for \":so\" command\n      result = sourcing_name;\n      if (result == NULL) {\n        *errormsg = (char_u *)_(\"E498: no :source file name to substitute for \\\"<sfile>\\\"\");\n        return NULL;\n      }\n      break;\n\n    case SPEC_SLNUM:            // line in file for \":so\" command\n      if (sourcing_name == NULL || sourcing_lnum == 0) {\n        *errormsg = (char_u *)_(\"E842: no line number to use for \\\"<slnum>\\\"\");\n        return NULL;\n      }\n      snprintf(strbuf, sizeof(strbuf), \"%\" PRIdLINENR, sourcing_lnum);\n      result = (char_u *)strbuf;\n      break;\n\n    case SPEC_SFLNUM:  // line in script file\n      if (current_sctx.sc_lnum + sourcing_lnum == 0) {\n        *errormsg = (char_u *)_(\"E961: no line number to use for \\\"<sflnum>\\\"\");\n        return NULL;\n      }\n      snprintf((char *)strbuf, sizeof(strbuf), \"%\" PRIdLINENR,\n               current_sctx.sc_lnum + sourcing_lnum);\n      result = (char_u *)strbuf;\n      break;\n\n    case SPEC_SID:\n      if (current_sctx.sc_sid <= 0) {\n        *errormsg = (char_u *)_(e_usingsid);\n        return NULL;\n      }\n      snprintf(strbuf, sizeof(strbuf), \"<SNR>%\" PRIdSCID \"_\",\n               current_sctx.sc_sid);\n      result = (char_u *)strbuf;\n      break;\n\n    default:\n      // should not happen\n      *errormsg = (char_u *)\"\";\n      result = (char_u *)\"\";    // avoid gcc warning\n      break;\n    }\n\n    // Length of new string.\n    resultlen = STRLEN(result);\n    // Remove the file name extension.\n    if (src[*usedlen] == '<') {\n      (*usedlen)++;\n      if ((s = STRRCHR(result, '.')) != NULL && s >= path_tail(result)) {\n        resultlen = (size_t)(s - result);\n      }\n    } else if (!skip_mod) {\n      valid |= modify_fname(src, tilde_file, usedlen, &result,\n                            &resultbuf, &resultlen);\n      if (result == NULL) {\n        *errormsg = (char_u *)\"\";\n        return NULL;\n      }\n    }\n  }\n\n  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {\n    if (valid != VALID_HEAD + VALID_PATH) {\n      // xgettext:no-c-format\n      *errormsg = (char_u *)_(\"E499: Empty file name for '%' or '#', only works with \\\":p:h\\\"\");\n    } else {\n      *errormsg = (char_u *)_(\"E500: Evaluates to an empty string\");\n    }\n    result = NULL;\n  } else {\n    result = vim_strnsave(result, resultlen);\n  }\n  xfree(resultbuf);\n  return result;\n}\n\n/*\n * Concatenate all files in the argument list, separated by spaces, and return\n * it in one allocated string.\n * Spaces and backslashes in the file names are escaped with a backslash.\n */\nstatic char_u *arg_all(void)\n{\n  int len;\n  int idx;\n  char_u *retval = NULL;\n  char_u *p;\n\n  /*\n   * Do this loop two times:\n   * first time: compute the total length\n   * second time: concatenate the names\n   */\n  for (;; ) {\n    len = 0;\n    for (idx = 0; idx < ARGCOUNT; ++idx) {\n      p = alist_name(&ARGLIST[idx]);\n      if (p == NULL) {\n        continue;\n      }\n      if (len > 0) {\n        // insert a space in between names\n        if (retval != NULL) {\n          retval[len] = ' ';\n        }\n        ++len;\n      }\n      for (; *p != NUL; p++) {\n        if (*p == ' '\n#ifndef BACKSLASH_IN_FILENAME\n            || *p == '\\\\'\n#endif\n            || *p == '`') {\n          // insert a backslash\n          if (retval != NULL) {\n            retval[len] = '\\\\';\n          }\n          len++;\n        }\n        if (retval != NULL) {\n          retval[len] = *p;\n        }\n        len++;\n      }\n    }\n\n    // second time: break here\n    if (retval != NULL) {\n      retval[len] = NUL;\n      break;\n    }\n\n    // allocate memory\n    retval = xmalloc(len + 1);\n  }\n\n  return retval;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\nchar_u *expand_sfile(char_u *arg)\n{\n  char_u *errormsg;\n  size_t len;\n  char_u *result;\n  char_u *newres;\n  char_u *repl;\n  size_t srclen;\n  char_u *p;\n\n  result = vim_strsave(arg);\n\n  for (p = result; *p; ) {\n    if (STRNCMP(p, \"<sfile>\", 7) != 0) {\n      ++p;\n    } else {\n      // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n      repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL);\n      if (errormsg != NULL) {\n        if (*errormsg) {\n          emsg(errormsg);\n        }\n        xfree(result);\n        return NULL;\n      }\n      if (repl == NULL) {               // no match (cannot happen)\n        p += srclen;\n        continue;\n      }\n      len = STRLEN(result) - srclen + STRLEN(repl) + 1;\n      newres = xmalloc(len);\n      memmove(newres, result, (size_t)(p - result));\n      STRCPY(newres + (p - result), repl);\n      len = STRLEN(newres);\n      STRCAT(newres, p + srclen);\n      xfree(repl);\n      xfree(result);\n      result = newres;\n      p = newres + len;                 // continue after the match\n    }\n  }\n\n  return result;\n}\n\n/*\n * \":rshada\" and \":wshada\".\n */\nstatic void ex_shada(exarg_T *eap)\n{\n  char_u *save_shada;\n\n  save_shada = p_shada;\n  if (*p_shada == NUL) {\n    p_shada = (char_u *)\"'100\";\n  }\n  if (eap->cmdidx == CMD_rviminfo || eap->cmdidx == CMD_rshada) {\n    (void)shada_read_everything((char *)eap->arg, eap->forceit, false);\n  } else {\n    shada_write_file((char *)eap->arg, eap->forceit);\n  }\n  p_shada = save_shada;\n}\n\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\nvoid dialog_msg(char_u *buff, char *format, char_u *fname)\n{\n  if (fname == NULL) {\n    fname = (char_u *)_(\"Untitled\");\n  }\n  vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n\n/*\n * \":behave {mswin,xterm}\"\n */\nstatic void ex_behave(exarg_T *eap)\n{\n  if (STRCMP(eap->arg, \"mswin\") == 0) {\n    set_option_value(\"selection\", 0L, \"exclusive\", 0);\n    set_option_value(\"selectmode\", 0L, \"mouse,key\", 0);\n    set_option_value(\"mousemodel\", 0L, \"popup\", 0);\n    set_option_value(\"keymodel\", 0L, \"startsel,stopsel\", 0);\n  } else if (STRCMP(eap->arg, \"xterm\") == 0) {\n    set_option_value(\"selection\", 0L, \"inclusive\", 0);\n    set_option_value(\"selectmode\", 0L, \"\", 0);\n    set_option_value(\"mousemodel\", 0L, \"extend\", 0);\n    set_option_value(\"keymodel\", 0L, \"\", 0);\n  } else {\n    EMSG2(_(e_invarg2), eap->arg);\n  }\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the possible arguments of the\n * \":behave {mswin,xterm}\" command.\n */\nchar_u *get_behave_arg(expand_T *xp, int idx)\n{\n  if (idx == 0) {\n    return (char_u *)\"mswin\";\n  }\n  if (idx == 1) {\n    return (char_u *)\"xterm\";\n  }\n  return NULL;\n}\n\n// Function given to ExpandGeneric() to obtain the possible arguments of the\n// \":messages {clear}\" command.\nchar_u *get_messages_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)\n{\n  if (idx == 0) {\n    return (char_u *)\"clear\";\n  }\n  return NULL;\n}\n\nchar_u *get_mapclear_arg(expand_T *xp FUNC_ATTR_UNUSED, int idx)\n{\n  if (idx == 0) {\n    return (char_u *)\"<buffer>\";\n  }\n  return NULL;\n}\n\nstatic TriState filetype_detect = kNone;\nstatic TriState filetype_plugin = kNone;\nstatic TriState filetype_indent = kNone;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\nstatic void ex_filetype(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  bool plugin = false;\n  bool indent = false;\n\n  if (*eap->arg == NUL) {\n    // Print current status.\n    smsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n         filetype_detect == kTrue ? \"ON\" : \"OFF\",\n         filetype_plugin == kTrue ? (filetype_detect == kTrue ? \"ON\" : \"(on)\") : \"OFF\",   // NOLINT(whitespace/line_length)\n         filetype_indent == kTrue ? (filetype_detect == kTrue ? \"ON\" : \"(on)\") : \"OFF\");  // NOLINT(whitespace/line_length)\n    return;\n  }\n\n  // Accept \"plugin\" and \"indent\" in any order.\n  for (;; ) {\n    if (STRNCMP(arg, \"plugin\", 6) == 0) {\n      plugin = true;\n      arg = skipwhite(arg + 6);\n      continue;\n    }\n    if (STRNCMP(arg, \"indent\", 6) == 0) {\n      indent = true;\n      arg = skipwhite(arg + 6);\n      continue;\n    }\n    break;\n  }\n  if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0) {\n    if (*arg == 'o' || !filetype_detect) {\n      source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n      filetype_detect = kTrue;\n      if (plugin) {\n        source_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n        filetype_plugin = kTrue;\n      }\n      if (indent) {\n        source_runtime((char_u *)INDENT_FILE, DIP_ALL);\n        filetype_indent = kTrue;\n      }\n    }\n    if (*arg == 'd') {\n      (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", true, NULL);\n      do_modelines(0);\n    }\n  } else if (STRCMP(arg, \"off\") == 0) {\n    if (plugin || indent) {\n      if (plugin) {\n        source_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n        filetype_plugin = kFalse;\n      }\n      if (indent) {\n        source_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n        filetype_indent = kFalse;\n      }\n    } else {\n      source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n      filetype_detect = kFalse;\n    }\n  } else {\n    EMSG2(_(e_invarg2), arg);\n  }\n}\n\n/// Set all :filetype options ON if user did not explicitly set any to OFF.\nvoid filetype_maybe_enable(void)\n{\n  if (filetype_detect == kNone) {\n    source_runtime((char_u *)FILETYPE_FILE, true);\n    filetype_detect = kTrue;\n  }\n  if (filetype_plugin == kNone) {\n    source_runtime((char_u *)FTPLUGIN_FILE, true);\n    filetype_plugin = kTrue;\n  }\n  if (filetype_indent == kNone) {\n    source_runtime((char_u *)INDENT_FILE, true);\n    filetype_indent = kTrue;\n  }\n}\n\n/// \":setfiletype [FALLBACK] {name}\"\nstatic void ex_setfiletype(exarg_T *eap)\n{\n  if (!did_filetype) {\n    char_u *arg = eap->arg;\n\n    if (STRNCMP(arg, \"FALLBACK \", 9) == 0) {\n      arg += 9;\n    }\n\n    set_option_value(\"filetype\", 0L, (char *)arg, OPT_LOCAL);\n    if (arg != eap->arg) {\n      did_filetype = false;\n    }\n  }\n}\n\nstatic void ex_digraphs(exarg_T *eap)\n{\n  if (*eap->arg != NUL) {\n    putdigraph(eap->arg);\n  } else {\n    listdigraphs(eap->forceit);\n  }\n}\n\nstatic void ex_set(exarg_T *eap)\n{\n  int flags = 0;\n\n  if (eap->cmdidx == CMD_setlocal) {\n    flags = OPT_LOCAL;\n  } else if (eap->cmdidx == CMD_setglobal) {\n    flags = OPT_GLOBAL;\n  }\n  (void)do_set(eap->arg, flags);\n}\n\nvoid set_no_hlsearch(bool flag)\n{\n  no_hlsearch = flag;\n  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n}\n\n/*\n * \":nohlsearch\"\n */\nstatic void ex_nohlsearch(exarg_T *eap)\n{\n  set_no_hlsearch(true);\n  redraw_all_later(SOME_VALID);\n}\n\n// \":[N]match {group} {pattern}\"\n// Sets nextcmd to the start of the next command, if any.  Also called when\n// skipping commands to find the next command.\nstatic void ex_match(exarg_T *eap)\n{\n  char_u *p;\n  char_u *g = NULL;\n  char_u *end;\n  int c;\n  int id;\n\n  if (eap->line2 <= 3) {\n    id = eap->line2;\n  } else {\n    EMSG(e_invcmd);\n    return;\n  }\n\n  // First clear any old pattern.\n  if (!eap->skip) {\n    match_delete(curwin, id, false);\n  }\n\n  if (ends_excmd(*eap->arg)) {\n    end = eap->arg;\n  } else if ((STRNICMP(eap->arg, \"none\", 4) == 0\n              && (ascii_iswhite(eap->arg[4]) || ends_excmd(eap->arg[4])))) {\n    end = eap->arg + 4;\n  } else {\n    p = skiptowhite(eap->arg);\n    if (!eap->skip) {\n      g = vim_strnsave(eap->arg, p - eap->arg);\n    }\n    p = skipwhite(p);\n    if (*p == NUL) {\n      // There must be two arguments.\n      xfree(g);\n      EMSG2(_(e_invarg2), eap->arg);\n      return;\n    }\n    end = skip_regexp(p + 1, *p, true, NULL);\n    if (!eap->skip) {\n      if (*end != NUL && !ends_excmd(*skipwhite(end + 1))) {\n        xfree(g);\n        eap->errmsg = e_trailing;\n        return;\n      }\n      if (*end != *p) {\n        xfree(g);\n        EMSG2(_(e_invarg2), p);\n        return;\n      }\n\n      c = *end;\n      *end = NUL;\n      match_add(curwin, (const char *)g, (const char *)p + 1, 10, id,\n                NULL, NULL);\n      xfree(g);\n      *end = c;\n    }\n  }\n  eap->nextcmd = find_nextcmd(end);\n}\n\nstatic void ex_fold(exarg_T *eap)\n{\n  if (foldManualAllowed(true)) {\n    pos_T start = { eap->line1, 1, 0 };\n    pos_T end = { eap->line2, 1, 0 };\n    foldCreate(curwin, start, end);\n  }\n}\n\nstatic void ex_foldopen(exarg_T *eap)\n{\n  pos_T start = { eap->line1, 1, 0 };\n  pos_T end = { eap->line2, 1, 0 };\n  opFoldRange(start, end, eap->cmdidx == CMD_foldopen, eap->forceit, false);\n}\n\nstatic void ex_folddo(exarg_T *eap)\n{\n  // First set the marks for all lines closed/open.\n  for (linenr_T lnum = eap->line1; lnum <= eap->line2; ++lnum) {\n    if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed)) {\n      ml_setmarked(lnum);\n    }\n  }\n\n  global_exe(eap->arg);  // Execute the command on the marked lines.\n  ml_clearmarked();      // clear rest of the marks\n}\n\n// Returns true if the supplied Ex cmdidx is for a location list command\n// instead of a quickfix command.\nbool is_loclist_cmd(int cmdidx)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (cmdidx < 0 || cmdidx >= CMD_SIZE) {\n    return false;\n  }\n  return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n\nbool get_pressedreturn(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return ex_pressedreturn;\n}\n\nvoid set_pressedreturn(bool val)\n{\n  ex_pressedreturn = val;\n}\n\nstatic void ex_terminal(exarg_T *eap)\n{\n  char ex_cmd[1024];\n\n  if (*eap->arg != NUL) {  // Run {cmd} in 'shell'.\n    char *name = (char *)vim_strsave_escaped(eap->arg, (char_u *)\"\\\"\\\\\");\n    snprintf(ex_cmd, sizeof(ex_cmd),\n             \":enew%s | call termopen(\\\"%s\\\")\",\n             eap->forceit ? \"!\" : \"\", name);\n    xfree(name);\n  } else {  // No {cmd}: run the job with tokenized 'shell'.\n    if (*p_sh == NUL) {\n      EMSG(_(e_shellempty));\n      return;\n    }\n\n    char **argv = shell_build_argv(NULL, NULL);\n    char **p = argv;\n    char tempstring[512];\n    char shell_argv[512] = { 0 };\n\n    while (*p != NULL) {\n      snprintf(tempstring, sizeof(tempstring), \",\\\"%s\\\"\", *p);\n      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));\n      p++;\n    }\n    shell_free_argv(argv);\n\n    snprintf(ex_cmd, sizeof(ex_cmd),\n             \":enew%s | call termopen([%s])\",\n             eap->forceit ? \"!\" : \"\", shell_argv + 1);\n  }\n\n  do_cmdline_cmd(ex_cmd);\n}\n\n/// Checks if `cmd` is \"previewable\" (i.e. supported by 'inccommand').\n///\n/// @param[in] cmd Commandline to check. May start with a range or modifier.\n///\n/// @return true if `cmd` is previewable\nbool cmd_can_preview(char_u *cmd)\n{\n  if (cmd == NULL) {\n    return false;\n  }\n\n  // Ignore additional colons at the start...\n  cmd = skip_colon_white(cmd, true);\n\n  // Ignore any leading modifiers (:keeppatterns, :verbose, etc.)\n  for (int len = modifier_len(cmd); len != 0; len = modifier_len(cmd)) {\n    cmd += len;\n    cmd = skip_colon_white(cmd, true);\n  }\n\n  exarg_T ea;\n  memset(&ea, 0, sizeof(ea));\n  // parse the command line\n  ea.cmd = skip_range(cmd, NULL);\n  if (*ea.cmd == '*') {\n    ea.cmd = skipwhite(ea.cmd + 1);\n  }\n  char_u *end = find_command(&ea, NULL);\n\n  switch (ea.cmdidx) {\n  case CMD_substitute:\n  case CMD_smagic:\n  case CMD_snomagic:\n    // Only preview once the pattern delimiter has been typed\n    if (*end && !ASCII_ISALNUM(*end)) {\n      return true;\n    }\n    break;\n  default:\n    break;\n  }\n\n  return false;\n}\n\n/// Gets a map of maps describing user-commands defined for buffer `buf` or\n/// defined globally if `buf` is NULL.\n///\n/// @param buf  Buffer to inspect, or NULL to get global commands.\n///\n/// @return Map of maps describing commands\nDictionary commands_array(buf_T *buf)\n{\n  Dictionary rv = ARRAY_DICT_INIT;\n  char str[20];\n  garray_T *gap = (buf == NULL) ? &ucmds : &buf->b_ucmds;\n\n  for (int i = 0; i < gap->ga_len; i++) {\n    char arg[2] = { 0, 0 };\n    Dictionary d = ARRAY_DICT_INIT;\n    ucmd_T *cmd = USER_CMD_GA(gap, i);\n\n    PUT(d, \"name\", STRING_OBJ(cstr_to_string((char *)cmd->uc_name)));\n    PUT(d, \"definition\", STRING_OBJ(cstr_to_string((char *)cmd->uc_rep)));\n    PUT(d, \"script_id\", INTEGER_OBJ(cmd->uc_script_ctx.sc_sid));\n    PUT(d, \"bang\", BOOLEAN_OBJ(!!(cmd->uc_argt & EX_BANG)));\n    PUT(d, \"bar\", BOOLEAN_OBJ(!!(cmd->uc_argt & EX_TRLBAR)));\n    PUT(d, \"register\", BOOLEAN_OBJ(!!(cmd->uc_argt & EX_REGSTR)));\n\n    switch (cmd->uc_argt & (EX_EXTRA | EX_NOSPC | EX_NEEDARG)) {\n    case 0:\n      arg[0] = '0'; break;\n    case (EX_EXTRA):\n      arg[0] = '*'; break;\n    case (EX_EXTRA | EX_NOSPC):\n      arg[0] = '?'; break;\n    case (EX_EXTRA | EX_NEEDARG):\n      arg[0] = '+'; break;\n    case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):\n      arg[0] = '1'; break;\n    }\n    PUT(d, \"nargs\", STRING_OBJ(cstr_to_string(arg)));\n\n    char *cmd_compl = get_command_complete(cmd->uc_compl);\n    PUT(d, \"complete\", (cmd_compl == NULL\n                        ? NIL : STRING_OBJ(cstr_to_string(cmd_compl))));\n    PUT(d, \"complete_arg\", cmd->uc_compl_arg == NULL\n        ? NIL : STRING_OBJ(cstr_to_string((char *)cmd->uc_compl_arg)));\n\n    Object obj = NIL;\n    if (cmd->uc_argt & EX_COUNT) {\n      if (cmd->uc_def >= 0) {\n        snprintf(str, sizeof(str), \"%\" PRId64, (int64_t)cmd->uc_def);\n        obj = STRING_OBJ(cstr_to_string(str));    // -count=N\n      } else {\n        obj = STRING_OBJ(cstr_to_string(\"0\"));    // -count\n      }\n    }\n    PUT(d, \"count\", obj);\n\n    obj = NIL;\n    if (cmd->uc_argt & EX_RANGE) {\n      if (cmd->uc_argt & EX_DFLALL) {\n        obj = STRING_OBJ(cstr_to_string(\"%\"));    // -range=%\n      } else if (cmd->uc_def >= 0) {\n        snprintf(str, sizeof(str), \"%\" PRId64, (int64_t)cmd->uc_def);\n        obj = STRING_OBJ(cstr_to_string(str));    // -range=N\n      } else {\n        obj = STRING_OBJ(cstr_to_string(\".\"));    // -range\n      }\n    }\n    PUT(d, \"range\", obj);\n\n    obj = NIL;\n    for (int j = 0; addr_type_complete[j].expand != ADDR_NONE; j++) {\n      if (addr_type_complete[j].expand != ADDR_LINES\n          && addr_type_complete[j].expand == cmd->uc_addr_type) {\n        obj = STRING_OBJ(cstr_to_string(addr_type_complete[j].name));\n        break;\n      }\n    }\n    PUT(d, \"addr\", obj);\n\n    PUT(rv, (char *)cmd->uc_name, DICTIONARY_OBJ(d));\n  }\n  return rv;\n}\n\nvoid verify_command(char_u *cmd)\n{\n  if (strcmp(\"smile\", (char *)cmd)) {\n    return;  // acceptable non-existing command\n  }\n  MSG(\" #xxn`          #xnxx`        ,+x@##@Mz;`        .xxx\"\n      \"xxxxxxnz+,      znnnnnnnnnnnnnnnn.\");\n  MSG(\" n###z          x####`      :x##########W+`      ,###\"\n      \"##########M;    W################.\");\n  MSG(\" n####;         x####`    `z##############W:     ,###\"\n      \"#############   W################.\");\n  MSG(\" n####W.        x####`   ,W#################+    ,###\"\n      \"##############  W################.\");\n  MSG(\" n#####n        x####`   @###################    ,###\"\n      \"##############i W################.\");\n  MSG(\" n######i       x####`  .#########@W@########*   ,###\"\n      \"##############W`W################.\");\n  MSG(\" n######@.      x####`  x######W*.  `;n#######:  ,###\"\n      \"#x,,,,:*M######iW###@:,,,,,,,,,,,`\");\n  MSG(\" n#######n      x####` *######+`       :M#####M  ,###\"\n      \"#n      `x#####xW###@`\");\n  MSG(\" n########*     x####``@####@;          `x#####i ,###\"\n      \"#n       ,#####@W###@`\");\n  MSG(\" n########@     x####`*#####i            `M####M ,###\"\n      \"#n        x#########@`\");\n  MSG(\" n#########     x####`M####z              :#####:,###\"\n      \"#n        z#########@`\");\n  MSG(\" n#########*    x####,#####.               n####+,###\"\n      \"#n        n#########@`\");\n  MSG(\" n####@####@,   x####i####x                ;####x,###\"\n      \"#n       `W#####@####+++++++++++i\");\n  MSG(\" n####*#####M`  x#########*                `####@,###\"\n      \"#n       i#####MW###############W\");\n  MSG(\" n####.######+  x####z####;                 W####,###\"\n      \"#n      i@######W###############W\");\n  MSG(\" n####.`W#####: x####n####:                 M####:###\"\n      \"#@nnnnnW#######,W###############W\");\n  MSG(\" n####. :#####M`x####z####;                 W####,###\"\n      \"##############z W###############W\");\n  MSG(\" n####.  #######x#########*                `####W,###\"\n      \"#############W` W###############W\");\n  MSG(\" n####.  `M#####W####i####x                ;####x,###\"\n      \"############W,  W####+**********i\");\n  MSG(\" n####.   ,##########,#####.               n####+,###\"\n      \"###########n.   W###@`\");\n  MSG(\" n####.    ##########`M####z              :#####:,###\"\n      \"########Wz:     W###@`\");\n  MSG(\" n####.    x#########`*#####i            `M####M ,###\"\n      \"#x.....`        W###@`\");\n  MSG(\" n####.    ,@########``@####@;          `x#####i ,###\"\n      \"#n              W###@`\");\n  MSG(\" n####.     *########` *#####@+`       ,M#####M  ,###\"\n      \"#n              W###@`\");\n  MSG(\" n####.      x#######`  x######W*.  `;n######@:  ,###\"\n      \"#n              W###@,,,,,,,,,,,,`\");\n  MSG(\" n####.      .@######`  .#########@W@########*   ,###\"\n      \"#n              W################,\");\n  MSG(\" n####.       i######`   @###################    ,###\"\n      \"#n              W################,\");\n  MSG(\" n####.        n#####`   ,W#################+    ,###\"\n      \"#n              W################,\");\n  MSG(\" n####.        .@####`    .n##############W;     ,###\"\n      \"#n              W################,\");\n  MSG(\" n####.         i####`      :x##########W+`      ,###\"\n      \"#n              W################,\");\n  MSG(\" +nnnn`          +nnn`        ,+x@##@Mz;`        .nnn\"\n      \"n+              zxxxxxxxxxxxxxxxx.\");\n  MSG(\" \");\n  MSG(\"                                                     \"\n      \"                              ,+M@#Mi\");\n  MSG(\"                                 \"\n      \"                                                .z########\");\n  MSG(\"                                 \"\n      \"                                               i@#########i\");\n  MSG(\"                                 \"\n      \"                                             `############W`\");\n  MSG(\"                                 \"\n      \"                                            `n#############i\");\n  MSG(\"                                 \"\n      \"                                           `n##############n\");\n  MSG(\"     ``                          \"\n      \"                                           z###############@`\");\n  MSG(\"    `W@z,                        \"\n      \"                                          ##################,\");\n  MSG(\"    *#####`                      \"\n      \"                                         i############@x@###i\");\n  MSG(\"    ######M.                     \"\n      \"                                        :#############n`,W##+\");\n  MSG(\"    +######@:                    \"\n      \"                                       .W#########M@##+  *##z\");\n  MSG(\"    :#######@:                   \"\n      \"                                      `x########@#x###*  ,##n\");\n  MSG(\"    `@#######@;                  \"\n      \"                                      z#########M*@nW#i  .##x\");\n  MSG(\"     z########@i                 \"\n      \"                                     *###########WM#@#,  `##x\");\n  MSG(\"     i##########+                \"\n      \"                                    ;###########*n###@   `##x\");\n  MSG(\"     `@#MM#######x,              \"\n      \"                                   ,@#########zM,`z##M   `@#x\");\n  MSG(\"      n##M#W#######n.            \"\n      \"   `.:i*+#zzzz##+i:.`             ,W#########Wii,`n@#@` n@##n\");\n  MSG(\"      ;###@#x#######n         `,i\"\n      \"#nW@#####@@WWW@@####@Mzi.        ,W##########@z.. ;zM#+i####z\");\n  MSG(\"       x####nz########    .;#x@##\"\n      \"@Wn#*;,.`      ``,:*#x@##M+,    ;@########xz@WM+#` `n@#######\");\n  MSG(\"       ,@####M########xi#@##@Mzi,\"\n      \"`                     .+x###Mi:n##########Mz```.:i  *@######*\");\n  MSG(\"        *#####W#########ix+:`    \"\n      \"                         :n#############z:       `*.`M######i\");\n  MSG(\"        i#W##nW@+@##@#M@;        \"\n      \"                           ;W@@##########W,        i`x@#####,\");\n  MSG(\"        `@@n@Wn#@iMW*#*:         \"\n      \"                            `iz#z@######x.           M######`\");\n  MSG(\"         z##zM###x`*, .`         \"\n      \"                                 `iW#####W;:`        +#####M\");\n  MSG(\"         ,###nn##n`              \"\n      \"                                  ,#####x;`        ,;@######\");\n  MSG(\"          x###xz#.               \"\n      \"                                    in###+        `:######@.\");\n  MSG(\"          ;####n+                \"\n      \"                                    `Mnx##xi`   , zM#######\");\n  MSG(\"          `W####+                \"\n      \"i.                                   `.+x###@#. :n,z######:\");\n  MSG(\"           z####@`              ;\"\n      \"#:                                     .ii@###@;.*M*z####@`\");\n  MSG(\"           i####M         `   `i@\"\n      \"#,           ::                           +#n##@+@##W####n\");\n  MSG(\"           :####x    ,i. ##xzM###\"\n      \"@`     i.   .@@,                           .z####x#######*\");\n  MSG(\"           ,###W;   i##Wz########\"\n      \"#     :##   z##n                           ,@########x###:\");\n  MSG(\"            n##n   `W###########M\"\n      \"`;n,  i#x  ,###@i                           *W########W#@`\");\n  MSG(\"           .@##+  `x###########@.\"\n      \" z#+ .M#W``x#####n`                         `;#######@z#x\");\n  MSG(\"           n###z :W############@ \"\n      \" z#*  @##xM#######@n;                        `########nW+\");\n  MSG(\"          ;####nW##############W \"\n      \":@#* `@#############*                        :########z@i`\");\n  MSG(\"          M##################### \"\n      \"M##:  @#############@:                       *W########M#\");\n  MSG(\"         ;#####################i.\"\n      \"##x`  W#############W,                       :n########zx\");\n  MSG(\"         x####################@.`\"\n      \"x;    @#############z.                       .@########W#\");\n  MSG(\"        ,######################` \"\n      \"      W###############x*,`                    W######zM#i\");\n  MSG(\"        #######################: \"\n      \"      z##################@x+*#zzi            `@#########.\");\n  MSG(\"        W########W#z#M#########; \"\n      \"      *##########################z            :@#######@`\");\n  MSG(\"       `@#######x`;#z ,x#######; \"\n      \"      z###########M###xnM@########*            :M######@\");\n  MSG(\"       i########, x#@`  z######; \"\n      \"      *##########i *#@`  `+########+`            n######.\");\n  MSG(\"       n#######@` M##,  `W#####. \"\n      \"      *#########z  ###;    z########M:           :W####n\");\n  MSG(\"       M#######M  n##.   x####x  \"\n      \"      `x########:  z##+    M#########@;           .n###+\");\n  MSG(\"       W#######@` :#W   `@####:  \"\n      \"       `@######W   i###   ;###########@.            n##n\");\n  MSG(\"       W########z` ,,  .x####z   \"\n      \"        @######@`  `W#;  `W############*            *###;\");\n  MSG(\"      `@#########Mi,:*n@####W`   \"\n      \"        W#######*   ..  `n#############i            i###x\");\n  MSG(\"      .#####################z    \"\n      \"       `@#######@*`    .x############n:`            ;####.\");\n  MSG(\"      :####################x`,,` \"\n      \"       `W#########@x#+#@#############i              ,####:\");\n  MSG(\"      ;###################x#@###x\"\n      \"i`      *############################:              `####i\");\n  MSG(\"      i##################+#######\"\n      \"#M,      x##########################@`               W###i\");\n  MSG(\"      *################@; @######\"\n      \"##@,     .W#########################@                x###:\");\n  MSG(\"      .+M#############z.  M######\"\n      \"###x      ,W########################@`               ####.\");\n  MSG(\"      *M*;z@########x:    :W#####\"\n      \"##i        .M########################i               i###:\");\n  MSG(\"      *##@z;#@####x:        :z###\"\n      \"@i          `########################x               .###;\");\n  MSG(\"      *#####n;#@##            ;##\"\n      \"*             ,x#####################@`               W##*\");\n  MSG(\"      *#######n;*            :M##\"\n      \"W*,             *W####################`               n##z\");\n  MSG(\"      i########@.         ,*n####\"\n      \"###M*`           `###################M                *##M\");\n  MSG(\"      i########n        `z#####@@\"\n      \"#####Wi            ,M################;                ,##@`\");\n  MSG(\"      ;WMWW@###*       .x##@ni.``\"\n      \".:+zW##z`           `n##############z                  @##,\");\n  MSG(\"      .*++*i;;;.      .M#@+`     \"\n      \"     .##n            `x############x`                  n##i\");\n  MSG(\"      :########*      x#W,       \"\n      \"       *#+            *###########M`                   +##+\");\n  MSG(\"      ,#########     :#@:        \"\n      \"        ##:           #nzzzzzzzzzz.                    :##x\");\n  MSG(\"      .#####Wz+`     ##+         \"\n      \"        `MM`          .znnnnnnnnn.                     `@#@`\");\n  MSG(\"      `@@ni;*nMz`    @W`         \"\n      \"         :#+           .x#######n                       x##,\");\n  MSG(\"       i;z@#####,   .#*          \"\n      \"          z#:           ;;;*zW##;                       ###i\");\n  MSG(\"       z########:   :#;          \"\n      \"          `Wx          +###Wni;n.                       ;##z\");\n  MSG(\"       n########W:  .#*          \"\n      \"           ,#,        ;#######@+                        `@#M\");\n  MSG(\"      .###########n;.MM          \"\n      \"            n*        ;iM#######*                        x#@`\");\n  MSG(\"      :#############@;;          \"\n      \"            .n`      ,#W*iW#####W`                       +##,\");\n  MSG(\"      ,##############.           \"\n      \"             ix.    `x###M;#######                       ,##i\");\n  MSG(\"      .#############@`           \"\n      \"              x@n**#W######z;M###@.                       W##\");\n  MSG(\"      .##############W:          \"\n      \"              .x############@*;zW#;                       z#x\");\n  MSG(\"      ,###############@;         \"\n      \"               `##############@n*;.                       i#@\");\n  MSG(\"      ,#################i        \"\n      \"                 :n##############W`                       .##,\");\n  MSG(\"      ,###################`      \"\n      \"                   .+W##########W,                        `##i\");\n  MSG(\"      :###################@zi,`  \"\n      \"                      ;zM@@@WMn*`                          @#z\");\n  MSG(\"      :#######################@x+\"\n      \"*i;;:i#M,                 ``                               M#W\");\n  MSG(\"      ;##########################\"\n      \"######@x.                                                  n##,\");\n  MSG(\"      i#####################@W@@@\"\n      \"@Wxz*:`                                                    *##+\");\n  MSG(\"      *######################+```\"\n      \"                                                           :##M\");\n  MSG(\"      ########################M; \"\n      \"                                                           `@##,\");\n  MSG(\"      z#########################x\"\n      \",                                                           z###\");\n  MSG(\"      n##########################\"\n      \"#n:                                                         ;##W`\");\n  MSG(\"      x##########################\"\n      \"###Mz#++##*                                                 `W##i\");\n  MSG(\"      M##########################\"\n      \"##########@`                                                 ###x\");\n  MSG(\"      W##########################\"\n      \"###########`                                                 .###,\");\n  MSG(\"      @##########################\"\n      \"##########M                                                   n##z\");\n  MSG(\"      @##################z*i@WMMM\"\n      \"x#x@#####,.                                                   :##@.\");\n  MSG(\"     `#####################@xi`  \"\n      \"   `::,*                                                       x##+\");\n  MSG(\"     .#####################@#M.  \"\n      \"                                                               ;##@`\");\n  MSG(\"     ,#####################:.    \"\n      \"                                                                M##i\");\n  MSG(\"     ;###################ni`     \"\n      \"                                                                i##M\");\n  MSG(\"     *#################W#`       \"\n      \"                                                                `W##,\");\n  MSG(\"     z#################@Wx+.     \"\n      \"                                                                 +###\");\n  MSG(\"     x######################z.   \"\n      \"                                                                 .@#@`\");\n  MSG(\"    `@#######################@;  \"\n      \"                                                                  z##;\");\n  MSG(\"    :##########################: \"\n      \"                                                                  :##z\");\n  MSG(\"    +#########################W# \"\n      \"                                                                   M#W\");\n  MSG(\"    W################@n+*i;:,`                                \"\n      \"                                      +##,\");\n  MSG(\"   :##################WMxz+,                                  \"\n      \"                                      ,##i\");\n  MSG(\"   n#######################W..,                               \"\n      \"                                       W##\");\n  MSG(\"  +#########################WW@+. .:.                         \"\n      \"                                       z#x\");\n  MSG(\" `@#############################@@###:                        \"\n      \"                                       *#W\");\n  MSG(\" #################################Wz:                         \"\n      \"                                       :#@\");\n  MSG(\",@###############################i                            \"\n      \"                                       .##\");\n  MSG(\"n@@@@@@@#########################+                            \"\n      \"                                       `##\");\n  MSG(\"`      `.:.`.,:iii;;;;;;;;iii;;;:`       `.``                 \"\n      \"                                       `nW\");\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}, "2": {"id": 2, "path": "src/nvim/event/loop.h", "content": "#ifndef NVIM_EVENT_LOOP_H\n#define NVIM_EVENT_LOOP_H\n\n#include <stdint.h>\n\n#include <uv.h>\n\n#include \"nvim/lib/klist.h\"\n#include \"nvim/os/time.h\"\n#include \"nvim/event/multiqueue.h\"\n\ntypedef void * WatcherPtr;\n\n#define _noop(x)\nKLIST_INIT(WatcherPtr, WatcherPtr, _noop)\n\ntypedef struct loop {\n  uv_loop_t uv;\n  MultiQueue *events;\n  MultiQueue *thread_events;\n  // Immediate events:\n  //    \"Processed after exiting uv_run() (to avoid recursion), but before\n  //    returning from loop_poll_events().\" 502aee690c98\n  // Practical consequence (for main_loop): these events are processed by\n  //    state_enter()..os_inchar()\n  // whereas \"regular\" events (main_loop.events) are processed by\n  //    state_enter()..VimState.execute()\n  // But state_enter()..os_inchar() can be \"too early\" if you want the event\n  // to trigger UI updates and other user-activity-related side-effects.\n  MultiQueue *fast_events;\n\n  // used by process/job-control subsystem\n  klist_t(WatcherPtr) *children;\n  uv_signal_t children_watcher;\n  uv_timer_t children_kill_timer;\n\n  // generic timer, used by loop_poll_events()\n  uv_timer_t poll_timer;\n\n  uv_async_t async;\n  uv_mutex_t mutex;\n  int recursive;\n} Loop;\n\n#define CREATE_EVENT(multiqueue, handler, argc, ...) \\\n  do { \\\n    if (multiqueue) { \\\n      multiqueue_put((multiqueue), (handler), argc, __VA_ARGS__); \\\n    } else { \\\n      void *argv[argc] = { __VA_ARGS__ }; \\\n      (handler)(argv); \\\n    } \\\n  } while (0)\n\n// -V:LOOP_PROCESS_EVENTS_UNTIL:547\n\n// Poll for events until a condition or timeout\n#define LOOP_PROCESS_EVENTS_UNTIL(loop, multiqueue, timeout, condition) \\\n  do { \\\n    int remaining = timeout; \\\n    uint64_t before = (remaining > 0) ? os_hrtime() : 0; \\\n    while (!(condition)) { \\\n      LOOP_PROCESS_EVENTS(loop, multiqueue, remaining); \\\n      if (remaining == 0) { \\\n        break; \\\n      } else if (remaining > 0) { \\\n        uint64_t now = os_hrtime(); \\\n        remaining -= (int) ((now - before) / 1000000); \\\n        before = now; \\\n        if (remaining <= 0) { \\\n          break; \\\n        } \\\n      } \\\n    } \\\n  } while (0)\n\n#define LOOP_PROCESS_EVENTS(loop, multiqueue, timeout) \\\n  do { \\\n    if (multiqueue && !multiqueue_empty(multiqueue)) { \\\n      multiqueue_process_events(multiqueue); \\\n    } else { \\\n      loop_poll_events(loop, timeout); \\\n    } \\\n  } while (0)\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"event/loop.h.generated.h\"\n#endif\n\n#endif  // NVIM_EVENT_LOOP_H\n"}}, "reports": [{"events": [{"location": {"col": 13, "file": 0, "line": 6133}, "message": "example recursive call chain, starting from function 'do_ucmd'"}, {"location": {"col": 9, "file": 0, "line": 6234}, "message": "Frame #1: function 'do_ucmd' calls function 'do_cmdline' here:"}, {"location": {"col": 20, "file": 0, "line": 603}, "message": "Frame #2: function 'do_cmdline' calls function 'do_one_cmd' here:"}, {"location": {"col": 5, "file": 0, "line": 1976}, "message": "Frame #3: function 'do_one_cmd' calls function 'do_ucmd' here:"}, {"location": {"col": 5, "file": 0, "line": 1976}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 5, "file": 0, "line": 311}, "message": "function 'do_cmdline' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8ebfa7f4c6f3e45bc80772cf99729033", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1131}, "message": "const (fixit)"}, {"location": {"col": 42, "file": 0, "line": 1131}, "message": "pointer parameter 'arg' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "acf5b7980f86ec5f4569bd30cf6b606c", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 1252}, "message": "function 'do_one_cmd' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "c6ce7a27fca67e15284c8621b0cfa025", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1476}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "7d486aa6a93c8daa96360b285c261c0c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1919}, "message": "last of these clones ends here"}, {"location": {"col": 5, "file": 0, "line": 1837}, "message": "switch has 2 consecutive identical branches"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "db51b3910d7fd287df7a686d3fc50b98", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 2017}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 2017}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "101eca1a72770c5bfd89caf54713a9e8", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2533}, "message": "const (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2533}, "message": "pointer parameter 'cmd' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "90f679b02aa4d6e49b392fa59872fd46", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 3, "file": 0, "line": 2559}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 3, "file": 0, "line": 2559}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "097a2c4a2b0938ab2b83b4d4b11ff869", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2564}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 2564}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "30233952166926da45c5e55ae1072129", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 0, "line": 2649}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "08a98c9e355821b09da8442f8354318b", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2704}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "4b38c0a1c0aabd923821016275bf3af7", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2708}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "557727476ace2f5e9143a7f57f9178d7", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 0, "line": 2846}, "message": "comparison between 'signed char' and 'unsigned char'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "6bd1b56a278ea1071e9b7e339e379b5e", "checkerName": "bugprone-signed-char-misuse", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 0, "line": 3358}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "46add37c54d55de4e6537cac669042f8", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 0, "line": 3585}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8a3da6d7cf9a3644ac6aafb7342e209e", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 3969}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "dba634e832253d9c3afe3c1c2d31b679", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 4364}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 4364}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "15373c93b60ff9d84da77d15a441c37f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 4368}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 4368}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "a4dea57d78fbd492a039b4d93fe31296", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 4371}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 4371}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "895e6bc21ce0fd7fbfdf93219c946646", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 4372}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 4372}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "37dc5b2d57119ca48802f6888c0459b6", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 4373}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 4373}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "2a61d7f29ca88684df567d9b0aaff7d7", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4532}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4532}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "369f632c8ebd4989920345f594c6b2ff", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4532}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4532}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "083de3fc3dd387ae4b326cb222e7c2c4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 4532}, "message": "did you mean this line to be inside this 'if'"}, {"location": {"col": 5, "file": 0, "line": 4536}, "message": "misleading indentation: statement is indented too deeply"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "02d7dc107e343693e735b32f1f2388ff", "checkerName": "readability-misleading-indentation", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 4589}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 4589}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "313f17ed599f7c0dc2b7fef69695e60f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 4594}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 4594}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "dad934cb033e844dd68ad80d2d6c2e8c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5096}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "14a34d8cedcf55a99c0bafb106d6d328", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5319}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "14a34d8cedcf55a99c0bafb106d6d328", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5326}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "0a027d8f5ac3fec22baab139e7ae1962", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5443}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5443}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "c7412cc6ac5623da19f968f6488e696e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5456}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5456}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "d25d8a72983ee9b132afff6f1900dc8f", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 5833}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 5833}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "9c47fb344743ee3c55b11c2b4a935152", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 5835}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 5835}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "2a81978e1ecca458762ad6ca4082acaa", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5861}, "message": "kCtArgs (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5861}, "message": "invalid case style for enum constant 'ct_ARGS'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "b6a243e8c35104180a8953c94fa6e1ae", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5862}, "message": "kCtBang (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5862}, "message": "invalid case style for enum constant 'ct_BANG'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "4e4a5673596453e48b7977540879a185", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5863}, "message": "kCtCount (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5863}, "message": "invalid case style for enum constant 'ct_COUNT'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "5d72eb63fe3d0cb1e974c83a94e96f71", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5864}, "message": "kCtLinE1 (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5864}, "message": "invalid case style for enum constant 'ct_LINE1'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "fcff3a043375e4c6088102b50ad5cfbe", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5865}, "message": "kCtLinE2 (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5865}, "message": "invalid case style for enum constant 'ct_LINE2'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "d8376474426c6d0610fc49f2a2f7dbb1", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5866}, "message": "kCtRange (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5866}, "message": "invalid case style for enum constant 'ct_RANGE'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "f3e72c293263db23f97753f5a78b4878", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5867}, "message": "kCtMods (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5867}, "message": "invalid case style for enum constant 'ct_MODS'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8121bd32a433682b960328cea1fb6a1a", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5868}, "message": "kCtRegister (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5868}, "message": "invalid case style for enum constant 'ct_REGISTER'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "cef2db2ee6e67a92daf5da807985f108", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5869}, "message": "kCtLt (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5869}, "message": "invalid case style for enum constant 'ct_LT'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8eb1f0a0191ba7b535cf2674c6a09a82", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5870}, "message": "kCtNone (fixit)"}, {"location": {"col": 5, "file": 0, "line": 5870}, "message": "invalid case style for enum constant 'ct_NONE'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "29b4d5ba9c2a0f930bcea926b6293ff5", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5909}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 5909}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "cd1ca7fb957ed9f0b47562d3f5e77826", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5927}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5927}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "20edee31d7f7b6195b45143d85d31803", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5958}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 5958}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8aa3fafb6a644d16483a29ebd342c358", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6006}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6006}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "03df8ece8b007c9601bb56cd98637913", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 6133}, "message": "function 'do_ucmd' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "4f90e9da1bf7635e666e54b0147adbeb", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 6142}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "6c297ac846fee6d8f69bd08d1941cdc6", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6225}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6225}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "0eb65331492a36ab7f7fd3604bc15948", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 6314}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "14a34d8cedcf55a99c0bafb106d6d328", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 6325}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "69ab2e895d9a642334ec25a8e2a8623b", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 6702}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "f594635979d15ed3e5930db6f92d983a", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 6807}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "4d23f54f266a3dbf6b921548cae21de3", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 6951}, "message": "(  ) (fixit)"}, {"location": {"col": 39, "file": 0, "line": 6951}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "5bd73b31424b289b7056e475c4f0ad0c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 0, "line": 7882}, "message": "L (fixit)"}, {"location": {"col": 23, "file": 0, "line": 7882}, "message": "integer literal has suffix 'l', which is not uppercase"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "47c53dba0ba6f23ace4733ea73165410", "checkerName": "readability-uppercase-literal-suffix", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 2, "line": 66}, "message": "expanded from macro 'LOOP_PROCESS_EVENTS_UNTIL'"}, {"location": {"col": 5, "file": 0, "line": 7883}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "8124d22bc12f104261a8bf5c58d1a740", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8294}, "message": "// TODO(khgh): redirect to a buffer (fixit)"}, {"location": {"col": 5, "file": 0, "line": 8294}, "message": "missing username/bug in TODO"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "a42c4cf39d9d5c744680e99b3deed923", "checkerName": "google-readability-todo", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 8814}, "message": "const (fixit)"}, {"location": {"col": 46, "file": 0, "line": 8814}, "message": "pointer parameter 'name' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "bbc6b9846850acf9fcb46280aa64469a", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8860}, "message": "kSpecPerc (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8860}, "message": "invalid case style for enum constant 'SPEC_PERC'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "3b9234c23742b6f3521ca58432acb6cd", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8861}, "message": "kSpecHash (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8861}, "message": "invalid case style for enum constant 'SPEC_HASH'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "9a274ccb335d640ff7224c438e34669c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8862}, "message": "kSpecCword (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8862}, "message": "invalid case style for enum constant 'SPEC_CWORD'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "c464aefadd0a7e4164c93f86b8a15fc0", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8863}, "message": "kSpecCcword (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8863}, "message": "invalid case style for enum constant 'SPEC_CCWORD'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "21f5e127e67ba0d76507bd948f870f4f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8864}, "message": "kSpecCexpr (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8864}, "message": "invalid case style for enum constant 'SPEC_CEXPR'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "90ba0d0888231dc2e5a198867856b77f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8865}, "message": "kSpecCfile (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8865}, "message": "invalid case style for enum constant 'SPEC_CFILE'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "5a9386663605830802f592cc8d220168", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8866}, "message": "kSpecSfile (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8866}, "message": "invalid case style for enum constant 'SPEC_SFILE'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "7b504c250297ed5fdbe42330f63a76cf", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8867}, "message": "kSpecSlnum (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8867}, "message": "invalid case style for enum constant 'SPEC_SLNUM'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "f342b34b8e3abbdc89d9fd0fa66db0fc", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8868}, "message": "kSpecStack (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8868}, "message": "invalid case style for enum constant 'SPEC_STACK'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "da43fdd640a67ac95e0998ffeb73b348", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8869}, "message": "kSpecAfile (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8869}, "message": "invalid case style for enum constant 'SPEC_AFILE'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "cf096a06e90a547a80163e5d5870b3d1", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8870}, "message": "kSpecAbuf (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8870}, "message": "invalid case style for enum constant 'SPEC_ABUF'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "44647afbce53a2cc54b8acdd983fc30b", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8871}, "message": "kSpecAmatch (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8871}, "message": "invalid case style for enum constant 'SPEC_AMATCH'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "2c8c504006d63bd2afb95291a7435ba3", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8872}, "message": "kSpecSflnum (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8872}, "message": "invalid case style for enum constant 'SPEC_SFLNUM'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "9fb2484182e40b8d2365a8481ab39d47", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 8873}, "message": "kSpecSid (fixit)"}, {"location": {"col": 3, "file": 0, "line": 8873}, "message": "invalid case style for enum constant 'SPEC_SID'"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "7248b37e592c78b899b67dfe688b630f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 8942}, "message": "const (fixit)"}, {"location": {"col": 40, "file": 0, "line": 8942}, "message": "pointer parameter 'srcstart' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "863cd07e6b8d9b8227280473c1f4eb7e", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 9294}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 9294}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "da642bcd36ccac090da5d28f2a6c6042", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 9296}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 9296}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "06456388db9025a0dadb2bbec0b0c6f9", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 0, "line": 9820}, "message": "!= 0 (fixit)"}, {"location": {"col": 7, "file": 0, "line": 9820}, "message": "function 'strcmp' is called without explicitly comparing result"}], "macros": [], "notes": [], "path": "src/nvim/ex_docmd.c", "reportHash": "c5c8193b947af828638709a311d38261", "checkerName": "bugprone-suspicious-string-compare", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
