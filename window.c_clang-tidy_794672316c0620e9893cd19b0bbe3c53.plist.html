<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"29": {"id": 29, "path": "src/nvim/window.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n\n#include \"nvim/api/private/helpers.h\"\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/window.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/main.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/file_search.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/state.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/terminal.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/ui_compositor.h\"\n#include \"nvim/os/os.h\"\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"window.c.generated.h\"\n#endif\n\n\n\n\n#define NOWIN           (win_T *)-1     /* non-existing window */\n\n# define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n/*\n * all CTRL-W window commands are handled here, called from normal_cmd().\n */\nvoid\ndo_window(\n    int nchar,\n    long Prenum,\n    int xchar                  /* extra char from \":wincmd gx\" or NUL */\n)\n{\n  long Prenum1;\n  win_T       *wp;\n  char_u      *ptr;\n  linenr_T lnum = -1;\n  int type = FIND_DEFINE;\n  size_t len;\n  char cbuf[40];\n\n  Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n# define CHECK_CMDWIN \\\n  do { \\\n    if (cmdwin_type != 0) { \\\n      EMSG(_(e_cmdwin)); \\\n      return; \\\n    } \\\n  } while (0)\n\n  switch (nchar) {\n  /* split current window in two parts, horizontally */\n  case 'S':\n  case Ctrl_S:\n  case 's':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    // When splitting the quickfix window open a new buffer in it,\n    // don't replicate the quickfix buffer.\n    if (bt_quickfix(curbuf)) {\n      goto newwindow;\n    }\n    (void)win_split((int)Prenum, 0);\n    break;\n\n  /* split current window in two parts, vertically */\n  case Ctrl_V:\n  case 'v':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    // When splitting the quickfix window open a new buffer in it,\n    // don't replicate the quickfix buffer.\n    if (bt_quickfix(curbuf)) {\n      goto newwindow;\n    }\n    (void)win_split((int)Prenum, WSP_VERT);\n    break;\n\n  /* split current window and edit alternate file */\n  case Ctrl_HAT:\n  case '^':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n\n    if (buflist_findnr(Prenum == 0 ? curwin->w_alt_fnum : Prenum) == NULL) {\n      if (Prenum == 0) {\n        EMSG(_(e_noalt));\n      } else {\n        EMSGN(_(\"E92: Buffer %\" PRId64 \" not found\"), Prenum);\n      }\n      break;\n    }\n\n    if (!curbuf_locked() && win_split(0, 0) == OK) {\n      (void)buflist_getfile(Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n                            (linenr_T)0, GETF_ALT, false);\n    }\n    break;\n\n  /* open new window */\n  case Ctrl_N:\n  case 'n':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\nnewwindow:\n    if (Prenum)\n      /* window height */\n      vim_snprintf(cbuf, sizeof(cbuf) - 5, \"%\" PRId64, (int64_t)Prenum);\n    else\n      cbuf[0] = NUL;\n    if (nchar == 'v' || nchar == Ctrl_V) {\n      xstrlcat(cbuf, \"v\", sizeof(cbuf));\n    }\n    xstrlcat(cbuf, \"new\", sizeof(cbuf));\n    do_cmdline_cmd(cbuf);\n    break;\n\n  /* quit current window */\n  case Ctrl_Q:\n  case 'q':\n    reset_VIsual_and_resel();                   /* stop Visual mode */\n    cmd_with_count(\"quit\", (char_u *)cbuf, sizeof(cbuf), Prenum);\n    do_cmdline_cmd(cbuf);\n    break;\n\n  /* close current window */\n  case Ctrl_C:\n  case 'c':\n    reset_VIsual_and_resel();                   /* stop Visual mode */\n    cmd_with_count(\"close\", (char_u *)cbuf, sizeof(cbuf), Prenum);\n    do_cmdline_cmd(cbuf);\n    break;\n\n  /* close preview window */\n  case Ctrl_Z:\n  case 'z':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    do_cmdline_cmd(\"pclose\");\n    break;\n\n  /* cursor to preview window */\n  case 'P':\n    wp = NULL;\n    FOR_ALL_WINDOWS_IN_TAB(wp2, curtab) {\n      if (wp2->w_p_pvw) {\n        wp = wp2;\n        break;\n      }\n    }\n    if (wp == NULL) {\n      EMSG(_(\"E441: There is no preview window\"));\n    } else {\n      win_goto(wp);\n    }\n    break;\n\n  /* close all but current window */\n  case Ctrl_O:\n  case 'o':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    cmd_with_count(\"only\", (char_u *)cbuf, sizeof(cbuf), Prenum);\n    do_cmdline_cmd(cbuf);\n    break;\n\n  /* cursor to next window with wrap around */\n  case Ctrl_W:\n  case 'w':\n  /* cursor to previous window with wrap around */\n  case 'W':\n    CHECK_CMDWIN;\n    if (ONE_WINDOW && Prenum != 1) {  // just one window\n      beep_flush();\n    } else {\n      if (Prenum) {  // go to specified window\n        for (wp = firstwin; --Prenum > 0; ) {\n          if (wp->w_next == NULL)\n            break;\n          else\n            wp = wp->w_next;\n        }\n      } else {\n        if (nchar == 'W') {  // go to previous window\n          wp = curwin->w_prev;\n          if (wp == NULL) {\n            wp = lastwin;  // wrap around\n          }\n          while (wp != NULL && wp->w_floating\n                 && !wp->w_float_config.focusable) {\n            wp = wp->w_prev;\n          }\n        } else {  // go to next window\n          wp = curwin->w_next;\n          while (wp != NULL && wp->w_floating\n                 && !wp->w_float_config.focusable) {\n            wp = wp->w_next;\n          }\n          if (wp == NULL) {\n            wp = firstwin;  // wrap around\n          }\n        }\n      }\n      win_goto(wp);\n    }\n    break;\n\n  /* cursor to window below */\n  case 'j':\n  case K_DOWN:\n  case Ctrl_J:\n    CHECK_CMDWIN;\n    win_goto_ver(false, Prenum1);\n    break;\n\n  /* cursor to window above */\n  case 'k':\n  case K_UP:\n  case Ctrl_K:\n    CHECK_CMDWIN;\n    win_goto_ver(true, Prenum1);\n    break;\n\n  /* cursor to left window */\n  case 'h':\n  case K_LEFT:\n  case Ctrl_H:\n  case K_BS:\n    CHECK_CMDWIN;\n    win_goto_hor(true, Prenum1);\n    break;\n\n  /* cursor to right window */\n  case 'l':\n  case K_RIGHT:\n  case Ctrl_L:\n    CHECK_CMDWIN;\n    win_goto_hor(false, Prenum1);\n    break;\n\n  /* move window to new tab page */\n  case 'T':\n    if (one_window())\n      MSG(_(m_onlyone));\n    else {\n      tabpage_T   *oldtab = curtab;\n      tabpage_T   *newtab;\n\n      /* First create a new tab with the window, then go back to\n       * the old tab and close the window there. */\n      wp = curwin;\n      if (win_new_tabpage((int)Prenum, NULL) == OK\n          && valid_tabpage(oldtab)) {\n        newtab = curtab;\n        goto_tabpage_tp(oldtab, true, true);\n        if (curwin == wp) {\n          win_close(curwin, false);\n        }\n        if (valid_tabpage(newtab)) {\n          goto_tabpage_tp(newtab, true, true);\n          apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);\n        }\n      }\n    }\n    break;\n\n  /* cursor to top-left window */\n  case 't':\n  case Ctrl_T:\n    win_goto(firstwin);\n    break;\n\n  /* cursor to bottom-right window */\n  case 'b':\n  case Ctrl_B:\n    win_goto(lastwin_nofloating());\n    break;\n\n  /* cursor to last accessed (previous) window */\n  case 'p':\n  case Ctrl_P:\n    if (!win_valid(prevwin)) {\n      beep_flush();\n    } else {\n      win_goto(prevwin);\n    }\n    break;\n\n  /* exchange current and next window */\n  case 'x':\n  case Ctrl_X:\n    CHECK_CMDWIN;\n    win_exchange(Prenum);\n    break;\n\n  /* rotate windows downwards */\n  case Ctrl_R:\n  case 'r':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    win_rotate(false, (int)Prenum1);  // downwards\n    break;\n\n  /* rotate windows upwards */\n  case 'R':\n    CHECK_CMDWIN;\n    reset_VIsual_and_resel();  // stop Visual mode\n    win_rotate(true, (int)Prenum1);  // upwards\n    break;\n\n  /* move window to the very top/bottom/left/right */\n  case 'K':\n  case 'J':\n  case 'H':\n  case 'L':\n    CHECK_CMDWIN;\n    win_totop((int)Prenum,\n              ((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n              | ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n    break;\n\n  /* make all windows the same height */\n  case '=':\n    win_equal(NULL, false, 'b');\n    break;\n\n  /* increase current window height */\n  case '+':\n    win_setheight(curwin->w_height + (int)Prenum1);\n    break;\n\n  /* decrease current window height */\n  case '-':\n    win_setheight(curwin->w_height - (int)Prenum1);\n    break;\n\n  /* set current window height */\n  case Ctrl__:\n  case '_':\n    win_setheight(Prenum ? (int)Prenum : Rows-1);\n    break;\n\n  /* increase current window width */\n  case '>':\n    win_setwidth(curwin->w_width + (int)Prenum1);\n    break;\n\n  /* decrease current window width */\n  case '<':\n    win_setwidth(curwin->w_width - (int)Prenum1);\n    break;\n\n  /* set current window width */\n  case '|':\n    win_setwidth(Prenum != 0 ? (int)Prenum : Columns);\n    break;\n\n  /* jump to tag and split window if tag exists (in preview window) */\n  case '}':\n    CHECK_CMDWIN;\n    if (Prenum) {\n      g_do_tagpreview = Prenum;\n    } else {\n      g_do_tagpreview = p_pvh;\n    }\n    FALLTHROUGH;\n  case ']':\n  case Ctrl_RSB:\n    CHECK_CMDWIN;\n    // Keep visual mode, can select words to use as a tag.\n    if (Prenum)\n      postponed_split = Prenum;\n    else\n      postponed_split = -1;\n\n    if (nchar != '}') {\n      g_do_tagpreview = 0;\n    }\n\n    // Execute the command right here, required when\n    // \"wincmd ]\" was used in a function.\n    do_nv_ident(Ctrl_RSB, NUL);\n    break;\n\n  /* edit file name under cursor in a new window */\n  case 'f':\n  case 'F':\n  case Ctrl_F:\nwingotofile:\n    CHECK_CMDWIN;\n\n    ptr = grab_file_name(Prenum1, &lnum);\n    if (ptr != NULL) {\n      tabpage_T *oldtab = curtab;\n      win_T *oldwin = curwin;\n      setpcmark();\n      if (win_split(0, 0) == OK) {\n        RESET_BINDING(curwin);\n        if (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, ECMD_HIDE, NULL) == FAIL) {\n          // Failed to open the file, close the window opened for it.\n          win_close(curwin, false);\n          goto_tabpage_win(oldtab, oldwin);\n        } else if (nchar == 'F' && lnum >= 0) {\n          curwin->w_cursor.lnum = lnum;\n          check_cursor_lnum();\n          beginline(BL_SOL | BL_FIX);\n        }\n      }\n      xfree(ptr);\n    }\n    break;\n\n  /* Go to the first occurrence of the identifier under cursor along path in a\n   * new window -- webb\n   */\n  case 'i':                         /* Go to any match */\n  case Ctrl_I:\n    type = FIND_ANY;\n    FALLTHROUGH;\n  case 'd':                         // Go to definition, using 'define'\n  case Ctrl_D:\n    CHECK_CMDWIN;\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0) {\n      break;\n    }\n    find_pattern_in_path(ptr, 0, len, true, Prenum == 0,\n                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);\n    curwin->w_set_curswant = TRUE;\n    break;\n\n  // Quickfix window only: view the result under the cursor in a new split.\n  case K_KENTER:\n  case CAR:\n    if (bt_quickfix(curbuf)) {\n      qf_view_result(true);\n    }\n    break;\n\n\n  /* CTRL-W g  extended commands */\n  case 'g':\n  case Ctrl_G:\n    CHECK_CMDWIN;\n    no_mapping++;\n    if (xchar == NUL) {\n      xchar = plain_vgetc();\n    }\n    LANGMAP_ADJUST(xchar, true);\n    no_mapping--;\n    (void)add_to_showcmd(xchar);\n    switch (xchar) {\n    case '}':\n      xchar = Ctrl_RSB;\n      if (Prenum)\n        g_do_tagpreview = Prenum;\n      else\n        g_do_tagpreview = p_pvh;\n      FALLTHROUGH;\n    case ']':\n    case Ctrl_RSB:\n      // Keep visual mode, can select words to use as a tag.\n      if (Prenum)\n        postponed_split = Prenum;\n      else\n        postponed_split = -1;\n\n      /* Execute the command right here, required when\n       * \"wincmd g}\" was used in a function. */\n      do_nv_ident('g', xchar);\n      break;\n\n    case TAB:\n      goto_tabpage_lastused();\n      break;\n\n    case 'f':                       /* CTRL-W gf: \"gf\" in a new tab page */\n    case 'F':                       /* CTRL-W gF: \"gF\" in a new tab page */\n      cmdmod.tab = tabpage_index(curtab) + 1;\n      nchar = xchar;\n      goto wingotofile;\n    case 't':                       // CTRL-W gt: go to next tab page\n      goto_tabpage((int)Prenum);\n      break;\n\n    case 'T':                       // CTRL-W gT: go to previous tab page\n      goto_tabpage(-(int)Prenum1);\n      break;\n\n    case 'e':\n      if (curwin->w_floating || !ui_has(kUIMultigrid)) {\n        beep_flush();\n        break;\n      }\n      FloatConfig config = FLOAT_CONFIG_INIT;\n      config.width = curwin->w_width;\n      config.height = curwin->w_height;\n      config.external = true;\n      Error err = ERROR_INIT;\n      if (!win_new_float(curwin, config, &err)) {\n        EMSG(err.msg);\n        api_clear_error(&err);\n        beep_flush();\n      }\n      break;\n    default:\n      beep_flush();\n      break;\n    }\n    break;\n\n  default:    beep_flush();\n    break;\n  }\n}\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize,\n                           int64_t Prenum)\n{\n  size_t len = xstrlcpy((char *)bufp, cmd, bufsize);\n\n  if (Prenum > 0 && len < bufsize) {\n    vim_snprintf((char *)bufp + len, bufsize - len, \"%\" PRId64, Prenum);\n  }\n}\n\nvoid win_set_buf(Window window, Buffer buffer, bool noautocmd, Error *err)\n{\n  win_T *win = find_window_by_handle(window, err), *save_curwin = curwin;\n  buf_T *buf = find_buffer_by_handle(buffer, err);\n  tabpage_T *tab = win_find_tabpage(win), *save_curtab = curtab;\n\n  if (!win || !buf) {\n    return;\n  }\n\n  if (noautocmd) {\n    block_autocmds();\n  }\n  if (switch_win_noblock(&save_curwin, &save_curtab, win, tab, false) == FAIL) {\n    api_set_error(err,\n                  kErrorTypeException,\n                  \"Failed to switch to window %d\",\n                  window);\n  }\n\n  try_start();\n  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf->b_fnum, 0);\n  if (!try_end(err) && result == FAIL) {\n    api_set_error(err,\n                  kErrorTypeException,\n                  \"Failed to set buffer %d\",\n                  buffer);\n  }\n\n  // If window is not current, state logic will not validate its cursor.\n  // So do it now.\n  validate_cursor();\n\n  restore_win_noblock(save_curwin, save_curtab, false);\n  if (noautocmd) {\n    unblock_autocmds();\n  }\n}\n\n/// Create a new float.\n///\n/// if wp == NULL allocate a new window, otherwise turn existing window into a\n/// float. It must then already belong to the current tabpage!\n///\n/// config must already have been validated!\nwin_T *win_new_float(win_T *wp, FloatConfig fconfig, Error *err)\n{\n  if (wp == NULL) {\n    wp = win_alloc(lastwin_nofloating(), false);\n    win_init(wp, curwin, 0);\n  } else {\n    assert(!wp->w_floating);\n    if (firstwin == wp && lastwin_nofloating() == wp) {\n      // last non-float\n      api_set_error(err, kErrorTypeException,\n                    \"Cannot change last window into float\");\n      return NULL;\n    } else if (!win_valid(wp)) {\n      api_set_error(err, kErrorTypeException,\n                    \"Cannot change window from different tabpage into float\");\n      return NULL;\n    }\n    int dir;\n    winframe_remove(wp, &dir, NULL);\n    XFREE_CLEAR(wp->w_frame);\n    (void)win_comp_pos();  // recompute window positions\n    win_remove(wp, NULL);\n    win_append(lastwin_nofloating(), wp);\n  }\n  wp->w_floating = 1;\n  wp->w_status_height = 0;\n  wp->w_vsep_width = 0;\n\n  win_config_float(wp, fconfig);\n  win_set_inner_size(wp);\n  wp->w_pos_changed = true;\n  redraw_later(wp, VALID);\n  return wp;\n}\n\nvoid win_set_minimal_style(win_T *wp)\n{\n  wp->w_p_nu = false;\n  wp->w_p_rnu = false;\n  wp->w_p_cul = false;\n  wp->w_p_cuc = false;\n  wp->w_p_spell = false;\n  wp->w_p_list = false;\n\n  // Hide EOB region: use \" \" fillchar and cleared highlighting\n  if (wp->w_p_fcs_chars.eob != ' ') {\n    char_u *old = wp->w_p_fcs;\n    wp->w_p_fcs = ((*old == NUL)\n                   ? (char_u *)xstrdup(\"eob: \")\n                   : concat_str(old, (char_u *)\",eob: \"));\n    xfree(old);\n  }\n  if (wp->w_hl_ids[HLF_EOB] != -1) {\n    char_u *old = wp->w_p_winhl;\n    wp->w_p_winhl = ((*old == NUL)\n                     ? (char_u *)xstrdup(\"EndOfBuffer:\")\n                     : concat_str(old, (char_u *)\",EndOfBuffer:\"));\n    xfree(old);\n  }\n\n  // signcolumn: use 'auto'\n  if (wp->w_p_scl[0] != 'a' || STRLEN(wp->w_p_scl) >= 8) {\n    xfree(wp->w_p_scl);\n    wp->w_p_scl = (char_u *)xstrdup(\"auto\");\n  }\n\n  // foldcolumn: use '0'\n  if (wp->w_p_fdc[0] != '0') {\n    xfree(wp->w_p_fdc);\n    wp->w_p_fdc = (char_u *)xstrdup(\"0\");\n  }\n\n  // colorcolumn: cleared\n  if (wp->w_p_cc != NULL && *wp->w_p_cc != NUL) {\n    xfree(wp->w_p_cc);\n    wp->w_p_cc = (char_u *)xstrdup(\"\");\n  }\n}\n\nvoid win_config_float(win_T *wp, FloatConfig fconfig)\n{\n  wp->w_width = MAX(fconfig.width, 1);\n  wp->w_height = MAX(fconfig.height, 1);\n\n  if (fconfig.relative == kFloatRelativeCursor) {\n    fconfig.relative = kFloatRelativeWindow;\n    fconfig.row += curwin->w_wrow;\n    fconfig.col += curwin->w_wcol;\n    fconfig.window = curwin->handle;\n  }\n\n  bool change_external = fconfig.external != wp->w_float_config.external;\n  bool change_border = (fconfig.border != wp->w_float_config.border\n                        || memcmp(fconfig.border_hl_ids,\n                                  wp->w_float_config.border_hl_ids,\n                                  sizeof fconfig.border_hl_ids));\n\n\n  wp->w_float_config = fconfig;\n\n  bool has_border = wp->w_floating && wp->w_float_config.border;\n  for (int i = 0; i < 4; i++) {\n    wp->w_border_adj[i] =\n      has_border && wp->w_float_config.border_chars[2 * i+1][0];\n  }\n\n  if (!ui_has(kUIMultigrid)) {\n    wp->w_height = MIN(wp->w_height,\n                       Rows - 1 - (wp->w_border_adj[0] + wp->w_border_adj[2]));\n    wp->w_width = MIN(wp->w_width,\n                      Columns - (wp->w_border_adj[1] + wp->w_border_adj[3]));\n  }\n\n  win_set_inner_size(wp);\n  must_redraw = MAX(must_redraw, VALID);\n\n  wp->w_pos_changed = true;\n  if (change_external || change_border) {\n    wp->w_hl_needs_update = true;\n    redraw_later(wp, NOT_VALID);\n  }\n\n  // changing border style while keeping border only requires redrawing border\n  if (fconfig.border) {\n    wp->w_redr_border = true;\n    redraw_later(wp, VALID);\n  }\n}\n\nvoid win_check_anchored_floats(win_T *win)\n{\n  for (win_T *wp = lastwin; wp && wp->w_floating; wp = wp->w_prev) {\n    // float might be anchored to moved window\n    if (wp->w_float_config.relative == kFloatRelativeWindow\n        && wp->w_float_config.window == win->handle) {\n      wp->w_pos_changed = true;\n    }\n  }\n}\n\n/// Return the number of fold columns to display\nint win_fdccol_count(win_T *wp)\n{\n  const char *fdc = (const char *)wp->w_p_fdc;\n\n  // auto:<NUM>\n  if (strncmp(fdc, \"auto\", 4) == 0) {\n    const int fdccol = fdc[4] == ':' ? fdc[5] - '0' : 1;\n    int needed_fdccols = getDeepestNesting(wp);\n    return MIN(fdccol, needed_fdccols);\n  } else {\n    return fdc[0] - '0';\n  }\n}\n\n\nvoid ui_ext_win_position(win_T *wp)\n{\n  if (!wp->w_floating) {\n    ui_call_win_pos(wp->w_grid_alloc.handle, wp->handle, wp->w_winrow,\n                    wp->w_wincol, wp->w_width, wp->w_height);\n    return;\n  }\n\n  FloatConfig c = wp->w_float_config;\n  if (!c.external) {\n    ScreenGrid *grid = &default_grid;\n    float row = c.row, col = c.col;\n    if (c.relative == kFloatRelativeWindow) {\n      Error dummy = ERROR_INIT;\n      win_T *win = find_window_by_handle(c.window, &dummy);\n      if (win) {\n        grid = &win->w_grid;\n        int row_off = 0, col_off = 0;\n        screen_adjust_grid(&grid, &row_off, &col_off);\n        row += row_off;\n        col += col_off;\n        if (c.bufpos.lnum >= 0) {\n          pos_T pos = { c.bufpos.lnum+1, c.bufpos.col, 0 };\n          int trow, tcol, tcolc, tcole;\n          textpos2screenpos(win, &pos, &trow, &tcol, &tcolc, &tcole, true);\n          row += trow-1;\n          col += tcol-1;\n        }\n      }\n      api_clear_error(&dummy);\n    }\n\n    wp->w_grid_alloc.zindex = wp->w_float_config.zindex;\n    if (ui_has(kUIMultigrid)) {\n      String anchor = cstr_to_string(float_anchor_str[c.anchor]);\n      ui_call_win_float_pos(wp->w_grid_alloc.handle, wp->handle, anchor,\n                            grid->handle, row, col, c.focusable,\n                            wp->w_grid_alloc.zindex);\n    } else {\n      // TODO(bfredl): ideally, compositor should work like any multigrid UI\n      // and use standard win_pos events.\n      bool east = c.anchor & kFloatAnchorEast;\n      bool south = c.anchor & kFloatAnchorSouth;\n\n      int comp_row = (int)row - (south ? wp->w_height : 0);\n      int comp_col = (int)col - (east ? wp->w_width : 0);\n      comp_row = MAX(MIN(comp_row, Rows-wp->w_height_outer-1), 0);\n      comp_col = MAX(MIN(comp_col, Columns-wp->w_width_outer), 0);\n      wp->w_winrow = comp_row;\n      wp->w_wincol = comp_col;\n      bool valid = (wp->w_redr_type == 0);\n      ui_comp_put_grid(&wp->w_grid_alloc, comp_row, comp_col,\n                       wp->w_height_outer, wp->w_width_outer, valid, false);\n      ui_check_cursor_grid(wp->w_grid_alloc.handle);\n      wp->w_grid_alloc.focusable = wp->w_float_config.focusable;\n      if (!valid) {\n        wp->w_grid_alloc.valid = false;\n        redraw_later(wp, NOT_VALID);\n      }\n    }\n  } else {\n    ui_call_win_external_pos(wp->w_grid_alloc.handle, wp->handle);\n  }\n\n}\n\nvoid ui_ext_win_viewport(win_T *wp)\n{\n  if ((wp == curwin || ui_has(kUIMultigrid)) && wp->w_viewport_invalid) {\n    int botline = wp->w_botline;\n    if (botline == wp->w_buffer->b_ml.ml_line_count+1\n        && wp->w_empty_rows == 0) {\n      // TODO(bfredl): The might be more cases to consider, like how does this\n      // interact with incomplete final line? Diff filler lines?\n      botline = wp->w_buffer->b_ml.ml_line_count;\n    }\n    ui_call_win_viewport(wp->w_grid_alloc.handle, wp->handle, wp->w_topline-1,\n                         botline, wp->w_cursor.lnum-1, wp->w_cursor.col);\n    wp->w_viewport_invalid = false;\n  }\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\nint win_split(int size, int flags)\n{\n  /* When the \":tab\" modifier was used open a new tab page instead. */\n  if (may_open_tabpage() == OK)\n    return OK;\n\n  /* Add flags from \":vertical\", \":topleft\" and \":botright\". */\n  flags |= cmdmod.split;\n  if ((flags & WSP_TOP) && (flags & WSP_BOT)) {\n    EMSG(_(\"E442: Can't split topleft and botright at the same time\"));\n    return FAIL;\n  }\n\n  /* When creating the help window make a snapshot of the window layout.\n   * Otherwise clear the snapshot, it's now invalid. */\n  if (flags & WSP_HELP)\n    make_snapshot(SNAP_HELP_IDX);\n  else\n    clear_snapshot(curtab, SNAP_HELP_IDX);\n\n  return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\nint win_split_ins(int size, int flags, win_T *new_wp, int dir)\n{\n  win_T       *wp = new_wp;\n  win_T       *oldwin;\n  int new_size = size;\n  int i;\n  int need_status = 0;\n  bool do_equal = false;\n  int needed;\n  int available;\n  int oldwin_height = 0;\n  int layout;\n  frame_T   *frp, *curfrp, *frp2, *prevfrp;\n  int before;\n  int minheight;\n  int wmh1;\n  bool did_set_fraction = false;\n\n  if (flags & WSP_TOP) {\n    oldwin = firstwin;\n  } else if (flags & WSP_BOT || curwin->w_floating) {\n    // can't split float, use last nonfloating window instead\n    oldwin = lastwin_nofloating();\n  } else {\n    oldwin = curwin;\n  }\n\n  bool new_in_layout = (new_wp == NULL || new_wp->w_floating);\n\n  // add a status line when p_ls == 1 and splitting the first window\n  if (one_nonfloat() && p_ls == 1 && oldwin->w_status_height == 0) {\n    if (oldwin->w_height <= p_wmh && new_in_layout) {\n      EMSG(_(e_noroom));\n      return FAIL;\n    }\n    need_status = STATUS_HEIGHT;\n  }\n\n\n  if (flags & WSP_VERT) {\n    int wmw1;\n    int minwidth;\n\n    layout = FR_ROW;\n\n    /*\n     * Check if we are able to split the current window and compute its\n     * width.\n     */\n    // Current window requires at least 1 space.\n    wmw1 = (p_wmw == 0 ? 1 : p_wmw);\n    needed = wmw1 + 1;\n    if (flags & WSP_ROOM) {\n      needed += p_wiw - wmw1;\n    }\n    if (flags & (WSP_BOT | WSP_TOP)) {\n      minwidth = frame_minwidth(topframe, NOWIN);\n      available = topframe->fr_width;\n      needed += minwidth;\n    } else if (p_ea) {\n      minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n      prevfrp = oldwin->w_frame;\n      for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n           frp = frp->fr_parent) {\n        if (frp->fr_layout == FR_ROW) {\n          FOR_ALL_FRAMES(frp2, frp->fr_child) {\n            if (frp2 != prevfrp) {\n              minwidth += frame_minwidth(frp2, NOWIN);\n            }\n          }\n        }\n        prevfrp = frp;\n      }\n      available = topframe->fr_width;\n      needed += minwidth;\n    } else {\n      minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n      available = oldwin->w_frame->fr_width;\n      needed += minwidth;\n    }\n    if (available < needed && new_in_layout) {\n      EMSG(_(e_noroom));\n      return FAIL;\n    }\n    if (new_size == 0)\n      new_size = oldwin->w_width / 2;\n    if (new_size > available - minwidth - 1) {\n      new_size = available - minwidth - 1;\n    }\n    if (new_size < wmw1) {\n      new_size = wmw1;\n    }\n\n    // if it doesn't fit in the current window, need win_equal()\n    if (oldwin->w_width - new_size - 1 < p_wmw) {\n      do_equal = true;\n    }\n\n    // We don't like to take lines for the new window from a\n    // 'winfixwidth' window.  Take them from a window to the left or right\n    // instead, if possible. Add one for the separator.\n    if (oldwin->w_p_wfw) {\n      win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n    }\n\n    /* Only make all windows the same width if one of them (except oldwin)\n     * is wider than one of the split windows. */\n    if (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n        && oldwin->w_frame->fr_parent != NULL) {\n      frp = oldwin->w_frame->fr_parent->fr_child;\n      while (frp != NULL) {\n        if (frp->fr_win != oldwin && frp->fr_win != NULL\n            && (frp->fr_win->w_width > new_size\n                || frp->fr_win->w_width > (oldwin->w_width\n                                           - new_size - 1))) {\n          do_equal = true;\n          break;\n        }\n        frp = frp->fr_next;\n      }\n    }\n  } else {\n    layout = FR_COL;\n\n    /*\n     * Check if we are able to split the current window and compute its\n     * height.\n     */\n    // Current window requires at least 1 space.\n    wmh1 = p_wmh == 0 ? 1 : p_wmh;\n    needed = wmh1 + STATUS_HEIGHT;\n    if (flags & WSP_ROOM) {\n      needed += p_wh - wmh1;\n    }\n    if (flags & (WSP_BOT | WSP_TOP)) {\n      minheight = frame_minheight(topframe, NOWIN) + need_status;\n      available = topframe->fr_height;\n      needed += minheight;\n    } else if (p_ea) {\n      minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n      prevfrp = oldwin->w_frame;\n      for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n           frp = frp->fr_parent) {\n        if (frp->fr_layout == FR_COL) {\n          FOR_ALL_FRAMES(frp2, frp->fr_child) {\n            if (frp2 != prevfrp) {\n              minheight += frame_minheight(frp2, NOWIN);\n            }\n          }\n        }\n        prevfrp = frp;\n      }\n      available = topframe->fr_height;\n      needed += minheight;\n    } else {\n      minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n      available = oldwin->w_frame->fr_height;\n      needed += minheight;\n    }\n    if (available < needed && new_in_layout) {\n      EMSG(_(e_noroom));\n      return FAIL;\n    }\n    oldwin_height = oldwin->w_height;\n    if (need_status) {\n      oldwin->w_status_height = STATUS_HEIGHT;\n      oldwin_height -= STATUS_HEIGHT;\n    }\n    if (new_size == 0)\n      new_size = oldwin_height / 2;\n\n    if (new_size > available - minheight - STATUS_HEIGHT) {\n      new_size = available - minheight - STATUS_HEIGHT;\n    }\n    if (new_size < wmh1) {\n      new_size = wmh1;\n    }\n\n    // if it doesn't fit in the current window, need win_equal()\n    if (oldwin_height - new_size - STATUS_HEIGHT < p_wmh) {\n      do_equal = true;\n    }\n\n    /* We don't like to take lines for the new window from a\n     * 'winfixheight' window.  Take them from a window above or below\n     * instead, if possible. */\n    if (oldwin->w_p_wfh) {\n      // Set w_fraction now so that the cursor keeps the same relative\n      // vertical position using the old height.\n      set_fraction(oldwin);\n      did_set_fraction = true;\n\n      win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n          oldwin);\n      oldwin_height = oldwin->w_height;\n      if (need_status)\n        oldwin_height -= STATUS_HEIGHT;\n    }\n\n    /* Only make all windows the same height if one of them (except oldwin)\n     * is higher than one of the split windows. */\n    if (!do_equal && p_ea && size == 0\n        && *p_ead != 'h'\n        && oldwin->w_frame->fr_parent != NULL) {\n      frp = oldwin->w_frame->fr_parent->fr_child;\n      while (frp != NULL) {\n        if (frp->fr_win != oldwin && frp->fr_win != NULL\n            && (frp->fr_win->w_height > new_size\n                || frp->fr_win->w_height > oldwin_height - new_size\n                - STATUS_HEIGHT)) {\n          do_equal = true;\n          break;\n        }\n        frp = frp->fr_next;\n      }\n    }\n  }\n\n  /*\n   * allocate new window structure and link it in the window list\n   */\n  if ((flags & WSP_TOP) == 0\n      && ((flags & WSP_BOT)\n          || (flags & WSP_BELOW)\n          || (!(flags & WSP_ABOVE)\n              && ((flags & WSP_VERT) ? p_spr : p_sb)))) {\n    // new window below/right of current one\n    if (new_wp == NULL) {\n      wp = win_alloc(oldwin, false);\n    } else {\n      win_append(oldwin, wp);\n    }\n  } else {\n    if (new_wp == NULL) {\n      wp = win_alloc(oldwin->w_prev, false);\n    } else {\n      win_append(oldwin->w_prev, wp);\n    }\n  }\n\n  if (new_wp == NULL) {\n    if (wp == NULL)\n      return FAIL;\n\n    new_frame(wp);\n\n    /* make the contents of the new window the same as the current one */\n    win_init(wp, curwin, flags);\n  } else if (wp->w_floating) {\n    new_frame(wp);\n    wp->w_floating = false;\n    // non-floating window doesn't store float config.\n    wp->w_float_config = FLOAT_CONFIG_INIT;\n  }\n\n  /*\n   * Reorganise the tree of frames to insert the new window.\n   */\n  if (flags & (WSP_TOP | WSP_BOT)) {\n    if ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n        || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0)) {\n      curfrp = topframe->fr_child;\n      if (flags & WSP_BOT)\n        while (curfrp->fr_next != NULL)\n          curfrp = curfrp->fr_next;\n    } else\n      curfrp = topframe;\n    before = (flags & WSP_TOP);\n  } else {\n    curfrp = oldwin->w_frame;\n    if (flags & WSP_BELOW)\n      before = FALSE;\n    else if (flags & WSP_ABOVE)\n      before = TRUE;\n    else if (flags & WSP_VERT)\n      before = !p_spr;\n    else\n      before = !p_sb;\n  }\n  if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout) {\n    /* Need to create a new frame in the tree to make a branch. */\n    frp = xcalloc(1, sizeof(frame_T));\n    *frp = *curfrp;\n    curfrp->fr_layout = layout;\n    frp->fr_parent = curfrp;\n    frp->fr_next = NULL;\n    frp->fr_prev = NULL;\n    curfrp->fr_child = frp;\n    curfrp->fr_win = NULL;\n    curfrp = frp;\n    if (frp->fr_win != NULL) {\n      oldwin->w_frame = frp;\n    } else {\n      FOR_ALL_FRAMES(frp, frp->fr_child) {\n        frp->fr_parent = curfrp;\n      }\n    }\n  }\n\n  if (new_wp == NULL)\n    frp = wp->w_frame;\n  else\n    frp = new_wp->w_frame;\n  frp->fr_parent = curfrp->fr_parent;\n\n  /* Insert the new frame at the right place in the frame list. */\n  if (before)\n    frame_insert(curfrp, frp);\n  else\n    frame_append(curfrp, frp);\n\n  /* Set w_fraction now so that the cursor keeps the same relative\n   * vertical position. */\n  if (!did_set_fraction) {\n    set_fraction(oldwin);\n  }\n  wp->w_fraction = oldwin->w_fraction;\n\n  if (flags & WSP_VERT) {\n    wp->w_p_scr = curwin->w_p_scr;\n\n    if (need_status) {\n      win_new_height(oldwin, oldwin->w_height - 1);\n      oldwin->w_status_height = need_status;\n    }\n    if (flags & (WSP_TOP | WSP_BOT)) {\n      /* set height and row of new window to full height */\n      wp->w_winrow = tabline_height();\n      win_new_height(wp, curfrp->fr_height - (p_ls > 0));\n      wp->w_status_height = (p_ls > 0);\n    } else {\n      /* height and row of new window is same as current window */\n      wp->w_winrow = oldwin->w_winrow;\n      win_new_height(wp, oldwin->w_height);\n      wp->w_status_height = oldwin->w_status_height;\n    }\n    frp->fr_height = curfrp->fr_height;\n\n    /* \"new_size\" of the current window goes to the new window, use\n     * one column for the vertical separator */\n    win_new_width(wp, new_size);\n    if (before)\n      wp->w_vsep_width = 1;\n    else {\n      wp->w_vsep_width = oldwin->w_vsep_width;\n      oldwin->w_vsep_width = 1;\n    }\n    if (flags & (WSP_TOP | WSP_BOT)) {\n      if (flags & WSP_BOT)\n        frame_add_vsep(curfrp);\n      /* Set width of neighbor frame */\n      frame_new_width(curfrp, curfrp->fr_width\n                      - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n                      false);\n    } else {\n      win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n    }\n    if (before) {       // new window left of current one\n      wp->w_wincol = oldwin->w_wincol;\n      oldwin->w_wincol += new_size + 1;\n    } else              /* new window right of current one */\n      wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n    frame_fix_width(oldwin);\n    frame_fix_width(wp);\n  } else {\n    /* width and column of new window is same as current window */\n    if (flags & (WSP_TOP | WSP_BOT)) {\n      wp->w_wincol = 0;\n      win_new_width(wp, Columns);\n      wp->w_vsep_width = 0;\n    } else {\n      wp->w_wincol = oldwin->w_wincol;\n      win_new_width(wp, oldwin->w_width);\n      wp->w_vsep_width = oldwin->w_vsep_width;\n    }\n    frp->fr_width = curfrp->fr_width;\n\n    /* \"new_size\" of the current window goes to the new window, use\n     * one row for the status line */\n    win_new_height(wp, new_size);\n    if (flags & (WSP_TOP | WSP_BOT)) {\n      int new_fr_height = curfrp->fr_height - new_size;\n\n      if (!((flags & WSP_BOT) && p_ls == 0)) {\n        new_fr_height -= STATUS_HEIGHT;\n      }\n      frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, false);\n    } else {\n      win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n    }\n    if (before) {       // new window above current one\n      wp->w_winrow = oldwin->w_winrow;\n      wp->w_status_height = STATUS_HEIGHT;\n      oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n    } else {            // new window below current one\n      wp->w_winrow = oldwin->w_winrow + oldwin->w_height + STATUS_HEIGHT;\n      wp->w_status_height = oldwin->w_status_height;\n      if (!(flags & WSP_BOT)) {\n        oldwin->w_status_height = STATUS_HEIGHT;\n      }\n    }\n    if (flags & WSP_BOT)\n      frame_add_statusline(curfrp);\n    frame_fix_height(wp);\n    frame_fix_height(oldwin);\n  }\n\n  if (flags & (WSP_TOP | WSP_BOT))\n    (void)win_comp_pos();\n\n  // Both windows need redrawing.  Update all status lines, in case they\n  // show something related to the window count or position.\n  redraw_later(wp, NOT_VALID);\n  redraw_later(oldwin, NOT_VALID);\n  status_redraw_all();\n\n  if (need_status) {\n    msg_row = Rows - 1;\n    msg_col = sc_col;\n    msg_clr_eos_force();        /* Old command/ruler may still be there */\n    comp_col();\n    msg_row = Rows - 1;\n    msg_col = 0;        /* put position back at start of line */\n  }\n\n  /*\n   * equalize the window sizes.\n   */\n  if (do_equal || dir != 0)\n    win_equal(wp, true,\n        (flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n        : dir == 'h' ? 'b' :\n        'v');\n\n  /* Don't change the window height/width to 'winheight' / 'winwidth' if a\n   * size was given. */\n  if (flags & WSP_VERT) {\n    i = p_wiw;\n    if (size != 0)\n      p_wiw = size;\n\n  } else {\n    i = p_wh;\n    if (size != 0)\n      p_wh = size;\n  }\n\n  // Keep same changelist position in new window.\n  wp->w_changelistidx = oldwin->w_changelistidx;\n\n  /*\n   * make the new window the current window\n   */\n  win_enter_ext(wp, false, false, true, true, true);\n  if (flags & WSP_VERT) {\n    p_wiw = i;\n  } else {\n    p_wh = i;\n  }\n\n  if (!win_valid(oldwin)) {\n    return FAIL;\n  }\n\n  // Send the window positions to the UI\n  oldwin->w_pos_changed = true;\n\n  return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\nstatic void win_init(win_T *newp, win_T *oldp, int flags)\n{\n  int i;\n\n  newp->w_buffer = oldp->w_buffer;\n  newp->w_s = &(oldp->w_buffer->b_s);\n  oldp->w_buffer->b_nwindows++;\n  newp->w_cursor = oldp->w_cursor;\n  newp->w_valid = 0;\n  newp->w_curswant = oldp->w_curswant;\n  newp->w_set_curswant = oldp->w_set_curswant;\n  newp->w_topline = oldp->w_topline;\n  newp->w_topfill = oldp->w_topfill;\n  newp->w_leftcol = oldp->w_leftcol;\n  newp->w_pcmark = oldp->w_pcmark;\n  newp->w_prev_pcmark = oldp->w_prev_pcmark;\n  newp->w_alt_fnum = oldp->w_alt_fnum;\n  newp->w_wrow = oldp->w_wrow;\n  newp->w_fraction = oldp->w_fraction;\n  newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n  copy_jumplist(oldp, newp);\n  if (flags & WSP_NEWLOC) {\n    /* Don't copy the location list.  */\n    newp->w_llist = NULL;\n    newp->w_llist_ref = NULL;\n  } else {\n    copy_loclist_stack(oldp, newp);\n  }\n  newp->w_localdir = (oldp->w_localdir == NULL)\n                     ? NULL : vim_strsave(oldp->w_localdir);\n\n  /* copy tagstack and folds */\n  for (i = 0; i < oldp->w_tagstacklen; i++) {\n    taggy_T *tag = &newp->w_tagstack[i];\n    *tag = oldp->w_tagstack[i];\n    if (tag->tagname != NULL) {\n      tag->tagname = vim_strsave(tag->tagname);\n    }\n    if (tag->user_data != NULL) {\n      tag->user_data = vim_strsave(tag->user_data);\n    }\n  }\n  newp->w_tagstackidx = oldp->w_tagstackidx;\n  newp->w_tagstacklen = oldp->w_tagstacklen;\n  copyFoldingState(oldp, newp);\n\n  win_init_some(newp, oldp);\n\n  didset_window_options(newp);\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\nstatic void win_init_some(win_T *newp, win_T *oldp)\n{\n  /* Use the same argument list. */\n  newp->w_alist = oldp->w_alist;\n  ++newp->w_alist->al_refcount;\n  newp->w_arg_idx = oldp->w_arg_idx;\n\n  /* copy options from existing window */\n  win_copy_options(oldp, newp);\n}\n\n/// Return true if \"win\" is floating window in the current tab page.\n///\n/// @param  win  window to check\nbool win_valid_floating(const win_T *win)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (win == NULL) {\n    return false;\n  }\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp == win) {\n      return wp->w_floating;\n    }\n  }\n  return false;\n}\n\n/// Check if \"win\" is a pointer to an existing window in the current tabpage.\n///\n/// @param  win  window to check\nbool win_valid(const win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (win == NULL) {\n    return false;\n  }\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp == win) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find window \"handle\" in the current tab page.\n// Return NULL if not found.\nwin_T *win_find_by_handle(handle_T handle)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->handle == handle) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n/// Check if \"win\" is a pointer to an existing window in any tabpage.\n///\n/// @param  win  window to check\nbool win_valid_any_tab(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (win == NULL) {\n    return false;\n  }\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp == win) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*\n * Return the number of windows.\n */\nint win_count(void)\n{\n  int count = 0;\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    ++count;\n  }\n  return count;\n}\n\n/// Make \"count\" windows on the screen.\n/// Must be called when there is just one window, filling the whole screen\n/// (excluding the command line).\n///\n/// @param vertical  split windows vertically if true\n///\n/// @return actual number of windows on the screen.\nint make_windows(int count, bool vertical)\n{\n  int maxcount;\n  int todo;\n\n  if (vertical) {\n    /* Each windows needs at least 'winminwidth' lines and a separator\n     * column. */\n    maxcount = (curwin->w_width + curwin->w_vsep_width\n                - (p_wiw - p_wmw)) / (p_wmw + 1);\n  } else {\n    // Each window needs at least 'winminheight' lines and a status line.\n    maxcount = (curwin->w_height\n                + curwin->w_status_height\n                - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n  }\n\n  if (maxcount < 2)\n    maxcount = 2;\n  if (count > maxcount)\n    count = maxcount;\n\n  /*\n   * add status line now, otherwise first window will be too big\n   */\n  if (count > 1) {\n    last_status(true);\n  }\n\n  /*\n   * Don't execute autocommands while creating the windows.  Must do that\n   * when putting the buffers in the windows.\n   */\n  block_autocmds();\n\n  /* todo is number of windows left to create */\n  for (todo = count - 1; todo > 0; --todo)\n    if (vertical) {\n      if (win_split(curwin->w_width - (curwin->w_width - todo)\n              / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n        break;\n    } else {\n      if (win_split(curwin->w_height - (curwin->w_height - todo\n                                        * STATUS_HEIGHT) / (todo + 1)\n              - STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n        break;\n    }\n\n  unblock_autocmds();\n\n  /* return actual number of windows */\n  return count - todo;\n}\n\n/*\n * Exchange current and next window\n */\nstatic void win_exchange(long Prenum)\n{\n  frame_T     *frp;\n  frame_T     *frp2;\n  win_T       *wp;\n  win_T       *wp2;\n  int temp;\n\n  if (curwin->w_floating) {\n    EMSG(e_floatexchange);\n    return;\n  }\n\n  if (firstwin == curwin && lastwin_nofloating() == curwin) {\n    // just one window\n    beep_flush();\n    return;\n  }\n\n\n  /*\n   * find window to exchange with\n   */\n  if (Prenum) {\n    frp = curwin->w_frame->fr_parent->fr_child;\n    while (frp != NULL && --Prenum > 0)\n      frp = frp->fr_next;\n  } else if (curwin->w_frame->fr_next != NULL)  /* Swap with next */\n    frp = curwin->w_frame->fr_next;\n  else      /* Swap last window in row/col with previous */\n    frp = curwin->w_frame->fr_prev;\n\n  /* We can only exchange a window with another window, not with a frame\n   * containing windows. */\n  if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n    return;\n  wp = frp->fr_win;\n\n  /*\n   * 1. remove curwin from the list. Remember after which window it was in wp2\n   * 2. insert curwin before wp in the list\n   * if wp != wp2\n   *    3. remove wp from the list\n   *    4. insert wp after wp2\n   * 5. exchange the status line height and vsep width.\n   */\n  wp2 = curwin->w_prev;\n  frp2 = curwin->w_frame->fr_prev;\n  if (wp->w_prev != curwin) {\n    win_remove(curwin, NULL);\n    frame_remove(curwin->w_frame);\n    win_append(wp->w_prev, curwin);\n    frame_insert(frp, curwin->w_frame);\n  }\n  if (wp != wp2) {\n    win_remove(wp, NULL);\n    frame_remove(wp->w_frame);\n    win_append(wp2, wp);\n    if (frp2 == NULL)\n      frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n    else\n      frame_append(frp2, wp->w_frame);\n  }\n  temp = curwin->w_status_height;\n  curwin->w_status_height = wp->w_status_height;\n  wp->w_status_height = temp;\n  temp = curwin->w_vsep_width;\n  curwin->w_vsep_width = wp->w_vsep_width;\n  wp->w_vsep_width = temp;\n\n  /* If the windows are not in the same frame, exchange the sizes to avoid\n   * messing up the window layout.  Otherwise fix the frame sizes. */\n  if (curwin->w_frame->fr_parent != wp->w_frame->fr_parent) {\n    temp = curwin->w_height;\n    curwin->w_height = wp->w_height;\n    wp->w_height = temp;\n    temp = curwin->w_width;\n    curwin->w_width = wp->w_width;\n    wp->w_width = temp;\n  } else {\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n  }\n\n  (void)win_comp_pos();                 /* recompute window positions */\n\n  win_enter(wp, true);\n  redraw_later(curwin, NOT_VALID);\n  redraw_later(wp, NOT_VALID);\n}\n\n// rotate windows: if upwards true the second window becomes the first one\n//                 if upwards false the first window becomes the second one\nstatic void win_rotate(bool upwards, int count)\n{\n  win_T       *wp1;\n  win_T       *wp2;\n  frame_T     *frp;\n  int n;\n\n  if (curwin->w_floating) {\n    EMSG(e_floatexchange);\n    return;\n  }\n\n  if (count <= 0 || (firstwin == curwin && lastwin_nofloating() == curwin)) {\n    // nothing to do\n    beep_flush();\n    return;\n  }\n\n  // Check if all frames in this row/col have one window.\n  FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child) {\n    if (frp->fr_win == NULL) {\n      EMSG(_(\"E443: Cannot rotate when another window is split\"));\n      return;\n    }\n  }\n\n  while (count--) {\n    if (upwards) {              /* first window becomes last window */\n      /* remove first window/frame from the list */\n      frp = curwin->w_frame->fr_parent->fr_child;\n      assert(frp != NULL);\n      wp1 = frp->fr_win;\n      win_remove(wp1, NULL);\n      frame_remove(frp);\n      assert(frp->fr_parent->fr_child);\n\n      /* find last frame and append removed window/frame after it */\n      for (; frp->fr_next != NULL; frp = frp->fr_next)\n        ;\n      win_append(frp->fr_win, wp1);\n      frame_append(frp, wp1->w_frame);\n\n      wp2 = frp->fr_win;                /* previously last window */\n    } else {                  /* last window becomes first window */\n      /* find last window/frame in the list and remove it */\n      for (frp = curwin->w_frame; frp->fr_next != NULL;\n           frp = frp->fr_next)\n        ;\n      wp1 = frp->fr_win;\n      wp2 = wp1->w_prev;                    /* will become last window */\n      win_remove(wp1, NULL);\n      frame_remove(frp);\n      assert(frp->fr_parent->fr_child);\n\n      /* append the removed window/frame before the first in the list */\n      win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n      frame_insert(frp->fr_parent->fr_child, frp);\n    }\n\n    /* exchange status height and vsep width of old and new last window */\n    n = wp2->w_status_height;\n    wp2->w_status_height = wp1->w_status_height;\n    wp1->w_status_height = n;\n    frame_fix_height(wp1);\n    frame_fix_height(wp2);\n    n = wp2->w_vsep_width;\n    wp2->w_vsep_width = wp1->w_vsep_width;\n    wp1->w_vsep_width = n;\n    frame_fix_width(wp1);\n    frame_fix_width(wp2);\n\n    /* recompute w_winrow and w_wincol for all windows */\n    (void)win_comp_pos();\n  }\n\n  wp1->w_pos_changed = true;\n  wp2->w_pos_changed = true;\n\n  redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\nstatic void win_totop(int size, int flags)\n{\n  int dir = 0;\n  int height = curwin->w_height;\n\n  if (firstwin == curwin && lastwin_nofloating() == curwin) {\n    beep_flush();\n    return;\n  }\n\n  if (curwin->w_floating) {\n    ui_comp_remove_grid(&curwin->w_grid_alloc);\n    if (ui_has(kUIMultigrid)) {\n      curwin->w_pos_changed = true;\n    } else {\n      // No longer a float, a non-multigrid UI shouldn't draw it as such\n      ui_call_win_hide(curwin->w_grid_alloc.handle);\n      win_free_grid(curwin, false);\n    }\n  } else {\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n  }\n  win_remove(curwin, NULL);\n  last_status(false);       // may need to remove last status line\n  (void)win_comp_pos();     // recompute window positions\n\n  /* Split a window on the desired side and put the window there. */\n  (void)win_split_ins(size, flags, curwin, dir);\n  if (!(flags & WSP_VERT)) {\n    win_setheight(height);\n    if (p_ea)\n      win_equal(curwin, true, 'v');\n  }\n\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\nvoid win_move_after(win_T *win1, win_T *win2)\n{\n  int height;\n\n  /* check if the arguments are reasonable */\n  if (win1 == win2)\n    return;\n\n  /* check if there is something to do */\n  if (win2->w_next != win1) {\n    /* may need move the status line/vertical separator of the last window\n     * */\n    if (win1 == lastwin) {\n      height = win1->w_prev->w_status_height;\n      win1->w_prev->w_status_height = win1->w_status_height;\n      win1->w_status_height = height;\n      if (win1->w_prev->w_vsep_width == 1) {\n        /* Remove the vertical separator from the last-but-one window,\n         * add it to the last window.  Adjust the frame widths. */\n        win1->w_prev->w_vsep_width = 0;\n        win1->w_prev->w_frame->fr_width -= 1;\n        win1->w_vsep_width = 1;\n        win1->w_frame->fr_width += 1;\n      }\n    } else if (win2 == lastwin) {\n      height = win1->w_status_height;\n      win1->w_status_height = win2->w_status_height;\n      win2->w_status_height = height;\n      if (win1->w_vsep_width == 1) {\n        /* Remove the vertical separator from win1, add it to the last\n         * window, win2.  Adjust the frame widths. */\n        win2->w_vsep_width = 1;\n        win2->w_frame->fr_width += 1;\n        win1->w_vsep_width = 0;\n        win1->w_frame->fr_width -= 1;\n      }\n    }\n    win_remove(win1, NULL);\n    frame_remove(win1->w_frame);\n    win_append(win2, win1);\n    frame_append(win2->w_frame, win1->w_frame);\n\n    (void)win_comp_pos();  // recompute w_winrow for all windows\n    redraw_later(curwin, NOT_VALID);\n  }\n  win_enter(win1, false);\n\n  win1->w_pos_changed = true;\n  win2->w_pos_changed = true;\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\nvoid win_equal(\n    win_T *next_curwin,            // pointer to current window to be or NULL\n    bool current,                  // do only frame with current window\n    int dir                        // 'v' for vertically, 'h' for horizontally,\n                                   // 'b' for both, 0 for using p_ead\n)\n{\n  if (dir == 0)\n    dir = *p_ead;\n  win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n                topframe, dir, 0, tabline_height(),\n                Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\nstatic void win_equal_rec(\n    win_T *next_curwin,       /* pointer to current window to be or NULL */\n    bool current,                    /* do only frame with current window */\n    frame_T *topfr,             /* frame to set size off */\n    int dir,                        /* 'v', 'h' or 'b', see win_equal() */\n    int col,                        /* horizontal position for frame */\n    int row,                        /* vertical position for frame */\n    int width,                      /* new width of frame */\n    int height                     /* new height of frame */\n)\n{\n  int n, m;\n  int extra_sep = 0;\n  int wincount, totwincount = 0;\n  frame_T     *fr;\n  int next_curwin_size = 0;\n  int room = 0;\n  int new_size;\n  int has_next_curwin = 0;\n  bool hnc;\n\n  if (topfr->fr_layout == FR_LEAF) {\n    /* Set the width/height of this frame.\n     * Redraw when size or position changes */\n    if (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n        || topfr->fr_width != width || topfr->fr_win->w_wincol != col\n        ) {\n      topfr->fr_win->w_winrow = row;\n      frame_new_height(topfr, height, false, false);\n      topfr->fr_win->w_wincol = col;\n      frame_new_width(topfr, width, false, false);\n      redraw_all_later(NOT_VALID);\n    }\n  } else if (topfr->fr_layout == FR_ROW) {\n    topfr->fr_width = width;\n    topfr->fr_height = height;\n\n    if (dir != 'v') {                   /* equalize frame widths */\n      /* Compute the maximum number of windows horizontally in this\n       * frame. */\n      n = frame_minwidth(topfr, NOWIN);\n      /* add one for the rightmost window, it doesn't have a separator */\n      if (col + width == Columns)\n        extra_sep = 1;\n      else\n        extra_sep = 0;\n      totwincount = (n + extra_sep) / (p_wmw + 1);\n      has_next_curwin = frame_has_win(topfr, next_curwin);\n\n      /*\n       * Compute width for \"next_curwin\" window and room available for\n       * other windows.\n       * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n       */\n      m = frame_minwidth(topfr, next_curwin);\n      room = width - m;\n      if (room < 0) {\n        next_curwin_size = p_wiw + room;\n        room = 0;\n      } else {\n        next_curwin_size = -1;\n        FOR_ALL_FRAMES(fr, topfr->fr_child) {\n          // If 'winfixwidth' set keep the window width if\n          // possible.\n          // Watch out for this window being the next_curwin.\n          if (!frame_fixed_width(fr)) {\n            continue;\n          }\n          n = frame_minwidth(fr, NOWIN);\n          new_size = fr->fr_width;\n          if (frame_has_win(fr, next_curwin)) {\n            room += p_wiw - p_wmw;\n            next_curwin_size = 0;\n            if (new_size < p_wiw)\n              new_size = p_wiw;\n          } else\n            /* These windows don't use up room. */\n            totwincount -= (n + (fr->fr_next == NULL\n                                 ? extra_sep : 0)) / (p_wmw + 1);\n          room -= new_size - n;\n          if (room < 0) {\n            new_size += room;\n            room = 0;\n          }\n          fr->fr_newwidth = new_size;\n        }\n        if (next_curwin_size == -1) {\n          if (!has_next_curwin)\n            next_curwin_size = 0;\n          else if (totwincount > 1\n                   && (room + (totwincount - 2))\n                   / (totwincount - 1) > p_wiw) {\n            /* Can make all windows wider than 'winwidth', spread\n             * the room equally. */\n            next_curwin_size = (room + p_wiw\n                                + (totwincount - 1) * p_wmw\n                                + (totwincount - 1)) / totwincount;\n            room -= next_curwin_size - p_wiw;\n          } else\n            next_curwin_size = p_wiw;\n        }\n      }\n\n      if (has_next_curwin)\n        --totwincount;                  /* don't count curwin */\n    }\n\n    FOR_ALL_FRAMES(fr, topfr->fr_child) {\n      wincount = 1;\n      if (fr->fr_next == NULL)\n        /* last frame gets all that remains (avoid roundoff error) */\n        new_size = width;\n      else if (dir == 'v')\n        new_size = fr->fr_width;\n      else if (frame_fixed_width(fr)) {\n        new_size = fr->fr_newwidth;\n        wincount = 0;               /* doesn't count as a sizeable window */\n      } else {\n        /* Compute the maximum number of windows horiz. in \"fr\". */\n        n = frame_minwidth(fr, NOWIN);\n        wincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n                   / (p_wmw + 1);\n        m = frame_minwidth(fr, next_curwin);\n        if (has_next_curwin) {\n          hnc = frame_has_win(fr, next_curwin);\n        } else {\n          hnc = false;\n        }\n        if (hnc) {                    // don't count next_curwin\n          wincount--;\n        }\n        if (totwincount == 0) {\n          new_size = room;\n        } else {\n          new_size = (wincount * room + (totwincount / 2)) / totwincount;\n        }\n        if (hnc) {                  // add next_curwin size\n          next_curwin_size -= p_wiw - (m - n);\n          new_size += next_curwin_size;\n          room -= new_size - next_curwin_size;\n        } else\n          room -= new_size;\n        new_size += n;\n      }\n\n      /* Skip frame that is full width when splitting or closing a\n       * window, unless equalizing all frames. */\n      if (!current || dir != 'v' || topfr->fr_parent != NULL\n          || (new_size != fr->fr_width)\n          || frame_has_win(fr, next_curwin))\n        win_equal_rec(next_curwin, current, fr, dir, col, row,\n            new_size, height);\n      col += new_size;\n      width -= new_size;\n      totwincount -= wincount;\n    }\n  } else { /* topfr->fr_layout == FR_COL */\n    topfr->fr_width = width;\n    topfr->fr_height = height;\n\n    if (dir != 'h') {                   /* equalize frame heights */\n      /* Compute maximum number of windows vertically in this frame. */\n      n = frame_minheight(topfr, NOWIN);\n      /* add one for the bottom window if it doesn't have a statusline */\n      if (row + height == cmdline_row && p_ls == 0)\n        extra_sep = 1;\n      else\n        extra_sep = 0;\n      totwincount = (n + extra_sep) / (p_wmh + 1);\n      has_next_curwin = frame_has_win(topfr, next_curwin);\n\n      /*\n       * Compute height for \"next_curwin\" window and room available for\n       * other windows.\n       * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n       */\n      m = frame_minheight(topfr, next_curwin);\n      room = height - m;\n      if (room < 0) {\n        /* The room is less then 'winheight', use all space for the\n         * current window. */\n        next_curwin_size = p_wh + room;\n        room = 0;\n      } else {\n        next_curwin_size = -1;\n        FOR_ALL_FRAMES(fr, topfr->fr_child) {\n          // If 'winfixheight' set keep the window height if\n          // possible.\n          // Watch out for this window being the next_curwin.\n          if (!frame_fixed_height(fr)) {\n            continue;\n          }\n          n = frame_minheight(fr, NOWIN);\n          new_size = fr->fr_height;\n          if (frame_has_win(fr, next_curwin)) {\n            room += p_wh - p_wmh;\n            next_curwin_size = 0;\n            if (new_size < p_wh)\n              new_size = p_wh;\n          } else\n            /* These windows don't use up room. */\n            totwincount -= (n + (fr->fr_next == NULL\n                                 ? extra_sep : 0)) / (p_wmh + 1);\n          room -= new_size - n;\n          if (room < 0) {\n            new_size += room;\n            room = 0;\n          }\n          fr->fr_newheight = new_size;\n        }\n        if (next_curwin_size == -1) {\n          if (!has_next_curwin)\n            next_curwin_size = 0;\n          else if (totwincount > 1\n                   && (room + (totwincount - 2))\n                   / (totwincount - 1) > p_wh) {\n            /* can make all windows higher than 'winheight',\n             * spread the room equally. */\n            next_curwin_size = (room + p_wh\n                                + (totwincount - 1) * p_wmh\n                                + (totwincount - 1)) / totwincount;\n            room -= next_curwin_size - p_wh;\n          } else\n            next_curwin_size = p_wh;\n        }\n      }\n\n      if (has_next_curwin)\n        --totwincount;                  /* don't count curwin */\n    }\n\n    FOR_ALL_FRAMES(fr, topfr->fr_child) {\n      wincount = 1;\n      if (fr->fr_next == NULL)\n        /* last frame gets all that remains (avoid roundoff error) */\n        new_size = height;\n      else if (dir == 'h')\n        new_size = fr->fr_height;\n      else if (frame_fixed_height(fr)) {\n        new_size = fr->fr_newheight;\n        wincount = 0;               /* doesn't count as a sizeable window */\n      } else {\n        /* Compute the maximum number of windows vert. in \"fr\". */\n        n = frame_minheight(fr, NOWIN);\n        wincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n                   / (p_wmh + 1);\n        m = frame_minheight(fr, next_curwin);\n        if (has_next_curwin) {\n          hnc = frame_has_win(fr, next_curwin);\n        } else {\n          hnc = false;\n        }\n        if (hnc) {                    // don't count next_curwin\n          wincount--;\n        }\n        if (totwincount == 0) {\n          new_size = room;\n        } else {\n          new_size = (wincount * room + (totwincount / 2)) / totwincount;\n        }\n        if (hnc) {                  // add next_curwin size\n          next_curwin_size -= p_wh - (m - n);\n          new_size += next_curwin_size;\n          room -= new_size - next_curwin_size;\n        } else\n          room -= new_size;\n        new_size += n;\n      }\n      /* Skip frame that is full width when splitting or closing a\n       * window, unless equalizing all frames. */\n      if (!current || dir != 'h' || topfr->fr_parent != NULL\n          || (new_size != fr->fr_height)\n          || frame_has_win(fr, next_curwin))\n        win_equal_rec(next_curwin, current, fr, dir, col, row,\n            width, new_size);\n      row += new_size;\n      height -= new_size;\n      totwincount -= wincount;\n    }\n  }\n}\n\n/// Closes all windows for buffer `buf`.\n///\n/// @param keep_curwin don't close `curwin`\nvoid close_windows(buf_T *buf, int keep_curwin)\n{\n  tabpage_T   *tp, *nexttp;\n  int h = tabline_height();\n\n  ++RedrawingDisabled;\n\n  for (win_T *wp = firstwin; wp != NULL && !ONE_WINDOW; ) {\n    if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n        && !(wp->w_closing || wp->w_buffer->b_locked > 0)) {\n      if (win_close(wp, false) == FAIL) {\n        // If closing the window fails give up, to avoid looping forever.\n        break;\n      }\n\n      /* Start all over, autocommands may change the window layout. */\n      wp = firstwin;\n    } else\n      wp = wp->w_next;\n  }\n\n  /* Also check windows in other tab pages. */\n  for (tp = first_tabpage; tp != NULL; tp = nexttp) {\n    nexttp = tp->tp_next;\n    if (tp != curtab) {\n      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n        if (wp->w_buffer == buf\n            && !(wp->w_closing || wp->w_buffer->b_locked > 0)) {\n          win_close_othertab(wp, false, tp);\n\n          /* Start all over, the tab page may be closed and\n           * autocommands may change the window layout. */\n          nexttp = first_tabpage;\n          break;\n        }\n      }\n    }\n  }\n\n  --RedrawingDisabled;\n\n  redraw_tabline = true;\n  if (h != tabline_height()) {\n    shell_new_rows();\n  }\n}\n\n/// Check that current window is the last one.\n///\n/// @return true if the current window is the only window that exists, false if\n///         there is another, possibly in another tab page.\nstatic bool last_window(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return one_window() && first_tabpage->tp_next == NULL;\n}\n\n/// Check that current tab page contains no more then one window other than\n/// \"aucmd_win\". Only counts floating window if it is current.\nbool one_window(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  bool seen_one = false;\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp != aucmd_win && (!wp->w_floating || wp == curwin)) {\n      if (seen_one) {\n        return false;\n      }\n      seen_one = true;\n    }\n  }\n  return true;\n}\n\n/// Like ONE_WINDOW but only considers non-floating windows\nbool one_nonfloat(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return firstwin->w_next == NULL || firstwin->w_next->w_floating;\n}\n\n/// if wp is the last non-floating window\n///\n/// always false for a floating window\nbool last_nonfloat(win_T *wp) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return wp != NULL && firstwin == wp && !(wp->w_next && !wp->w_floating);\n}\n\n/// Close the possibly last window in a tab page.\n///\n/// @param  win          window to close\n/// @param  free_buf     whether to free the window's current buffer\n/// @param  prev_curtab  previous tabpage that will be closed if \"win\" is the\n///                      last window in the tabpage\n///\n/// @return true when the window was closed already.\nstatic bool close_last_window_tabpage(win_T *win, bool free_buf,\n                                      tabpage_T *prev_curtab)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (!ONE_WINDOW) {\n    return false;\n  }\n  buf_T   *old_curbuf = curbuf;\n\n  Terminal *term = win->w_buffer ? win->w_buffer->terminal : NULL;\n  if (term) {\n    // Don't free terminal buffers\n    free_buf = false;\n  }\n\n  /*\n   * Closing the last window in a tab page.  First go to another tab\n   * page and then close the window and the tab page.  This avoids that\n   * curwin and curtab are invalid while we are freeing memory, they may\n   * be used in GUI events.\n   * Don't trigger autocommands yet, they may use wrong values, so do\n   * that below.\n   */\n  goto_tabpage_tp(alt_tabpage(), false, true);\n  redraw_tabline = true;\n\n  // save index for tabclosed event\n  char_u prev_idx[NUMBUFLEN];\n  sprintf((char *)prev_idx, \"%i\", tabpage_index(prev_curtab));\n\n  /* Safety check: Autocommands may have closed the window when jumping\n   * to the other tab page. */\n  if (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win) {\n    int h = tabline_height();\n\n    win_close_othertab(win, free_buf, prev_curtab);\n    if (h != tabline_height())\n      shell_new_rows();\n  }\n\n  // Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n  // that now.\n  apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);\n  apply_autocmds(EVENT_TABENTER, NULL, NULL, false, curbuf);\n  if (old_curbuf != curbuf) {\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);\n  }\n  return true;\n}\n\n// Close window \"win\".  Only works for the current tab page.\n// If \"free_buf\" is true related buffer may be unloaded.\n//\n// Called by :quit, :close, :xit, :wq and findtag().\n// Returns FAIL when the window was not closed.\nint win_close(win_T *win, bool free_buf)\n{\n  win_T       *wp;\n  bool other_buffer = false;\n  bool close_curwin = false;\n  int dir;\n  bool help_window = false;\n  tabpage_T   *prev_curtab = curtab;\n  frame_T *win_frame = win->w_floating ? NULL : win->w_frame->fr_parent;\n  const bool had_diffmode = win->w_p_diff;\n\n  if (last_window() && !win->w_floating) {\n    EMSG(_(\"E444: Cannot close last window\"));\n    return FAIL;\n  }\n\n  if (win->w_closing\n      || (win->w_buffer != NULL && win->w_buffer->b_locked > 0)) {\n    return FAIL;     // window is already being closed\n  }\n  if (win == aucmd_win) {\n    EMSG(_(e_autocmd_close));\n    return FAIL;\n  }\n  if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window()) {\n    EMSG(_(\"E814: Cannot close window, only autocmd window would remain\"));\n    return FAIL;\n  }\n  if ((firstwin == win && lastwin_nofloating() == win)\n      && lastwin->w_floating) {\n    // TODO(bfredl): we might close the float also instead\n    EMSG(e_floatonly);\n    return FAIL;\n  }\n\n  /* When closing the last window in a tab page first go to another tab page\n   * and then close the window and the tab page to avoid that curwin and\n   * curtab are invalid while we are freeing memory. */\n  if (close_last_window_tabpage(win, free_buf, prev_curtab))\n    return FAIL;\n\n  /* When closing the help window, try restoring a snapshot after closing\n   * the window.  Otherwise clear the snapshot, it's now invalid. */\n  if (bt_help(win->w_buffer)) {\n    help_window = true;\n  } else {\n    clear_snapshot(curtab, SNAP_HELP_IDX);\n  }\n\n  if (win == curwin) {\n    /*\n     * Guess which window is going to be the new current window.\n     * This may change because of the autocommands (sigh).\n     */\n    if (!win->w_floating) {\n      wp = frame2win(win_altframe(win, NULL));\n    } else {\n      if (win_valid(prevwin) && prevwin != win) {\n        wp = prevwin;\n      } else {\n        wp = firstwin;\n      }\n    }\n\n    /*\n     * Be careful: If autocommands delete the window or cause this window\n     * to be the last one left, return now.\n     */\n    if (wp->w_buffer != curbuf) {\n      other_buffer = true;\n      win->w_closing = true;\n      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n      if (!win_valid(win))\n        return FAIL;\n      win->w_closing = false;\n      if (last_window())\n        return FAIL;\n    }\n    win->w_closing = true;\n    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, false, curbuf);\n    if (!win_valid(win)) {\n      return FAIL;\n    }\n    win->w_closing = false;\n    if (last_window())\n      return FAIL;\n    /* autocmds may abort script processing */\n    if (aborting())\n      return FAIL;\n  }\n\n  bool was_floating = win->w_floating;\n  if (ui_has(kUIMultigrid)) {\n    ui_call_win_close(win->w_grid_alloc.handle);\n  }\n\n  if (win->w_floating) {\n    ui_comp_remove_grid(&win->w_grid_alloc);\n    if (win->w_float_config.external) {\n      for (tabpage_T *tp = first_tabpage; tp != NULL; tp = tp->tp_next) {\n        if (tp == curtab) {\n          continue;\n        }\n        if (tp->tp_curwin == win) {\n          // NB: an autocmd can still abort the closing of this window,\n          // bur carring out this change anyway shouldn't be a catastrophe.\n          tp->tp_curwin = tp->tp_firstwin;\n        }\n      }\n    }\n  }\n\n  // Fire WinClosed just before starting to free window-related resources.\n  do_autocmd_winclosed(win);\n  // autocmd may have freed the window already.\n  if (!win_valid_any_tab(win)) {\n    return OK;\n  }\n\n  // Free independent synblock before the buffer is freed.\n  if (win->w_buffer != NULL) {\n    reset_synblock(win);\n  }\n\n  /*\n   * Close the link to the buffer.\n   */\n  if (win->w_buffer != NULL) {\n    bufref_T bufref;\n    set_bufref(&bufref, curbuf);\n    win->w_closing = true;\n    close_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, true);\n    if (win_valid_any_tab(win)) {\n      win->w_closing = false;\n    }\n\n    // Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n    // \"wipe\".\n    if (!bufref_valid(&bufref)) {\n      curbuf = firstbuf;\n    }\n  }\n\n  if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n      && (last_window() || curtab != prev_curtab\n          || close_last_window_tabpage(win, free_buf, prev_curtab))\n      && !win->w_floating) {\n    // Autocommands have closed all windows, quit now.  Restore\n    // curwin->w_buffer, otherwise writing ShaDa file may fail.\n    if (curwin->w_buffer == NULL) {\n      curwin->w_buffer = curbuf;\n    }\n    getout(0);\n  }\n  // Autocommands may have moved to another tab page.\n  if (curtab != prev_curtab && win_valid_any_tab(win)\n      && win->w_buffer == NULL) {\n    // Need to close the window anyway, since the buffer is NULL.\n    win_close_othertab(win, false, prev_curtab);\n    return FAIL;\n  }\n\n  // Autocommands may have closed the window already, or closed the only\n  // other window or moved to another tab page.\n  if (!win_valid(win) || (!win->w_floating && last_window())\n      || close_last_window_tabpage(win, free_buf, prev_curtab)) {\n    return FAIL;\n  }\n\n  // let terminal buffers know that this window dimensions may be ignored\n  win->w_closing = true;\n\n  // Free the memory used for the window and get the window that received\n  // the screen space.\n  wp = win_free_mem(win, &dir, NULL);\n\n  if (help_window) {\n    // Closing the help window moves the cursor back to the original window.\n    win_T *tmpwp = get_snapshot_focus(SNAP_HELP_IDX);\n    if (tmpwp != NULL) {\n      wp = tmpwp;\n    }\n  }\n\n  /* Make sure curwin isn't invalid.  It can cause severe trouble when\n   * printing an error message.  For win_equal() curbuf needs to be valid\n   * too. */\n  if (win == curwin) {\n    curwin = wp;\n    if (wp->w_p_pvw || bt_quickfix(wp->w_buffer)) {\n      /*\n       * If the cursor goes to the preview or the quickfix window, try\n       * finding another window to go to.\n       */\n      for (;; ) {\n        if (wp->w_next == NULL)\n          wp = firstwin;\n        else\n          wp = wp->w_next;\n        if (wp == curwin)\n          break;\n        if (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer)) {\n          curwin = wp;\n          break;\n        }\n      }\n    }\n    curbuf = curwin->w_buffer;\n    close_curwin = true;\n\n    // The cursor position may be invalid if the buffer changed after last\n    // using the window.\n    check_cursor();\n  }\n\n  if (!was_floating) {\n    if (!curwin->w_floating && p_ea && (*p_ead == 'b' || *p_ead == dir)) {\n      // If the frame of the closed window contains the new current window,\n      // only resize that frame.  Otherwise resize all windows.\n      win_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    } else {\n      (void)win_comp_pos();\n    }\n  }\n\n  if (close_curwin) {\n    win_enter_ext(wp, false, true, false, true, true);\n    if (other_buffer) {\n      // careful: after this wp and win may be invalid!\n      apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);\n    }\n  }\n\n  /*\n   * If last window has a status line now and we don't want one,\n   * remove the status line.\n   */\n  last_status(false);\n\n  /* After closing the help window, try restoring the window layout from\n   * before it was opened. */\n  if (help_window)\n    restore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n  // If the window had 'diff' set and now there is only one window left in\n  // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n  // execute \":diffoff!\".\n  if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab) {\n    int diffcount = 0;\n\n    FOR_ALL_WINDOWS_IN_TAB(dwin, curtab) {\n      if (dwin->w_p_diff) {\n        diffcount++;\n      }\n    }\n    if (diffcount == 1) {\n      do_cmdline_cmd(\"diffoff!\");\n    }\n  }\n\n  curwin->w_pos_changed = true;\n  redraw_all_later(NOT_VALID);\n  return OK;\n}\n\nstatic void do_autocmd_winclosed(win_T *win)\n  FUNC_ATTR_NONNULL_ALL\n{\n  static bool recursive = false;\n  if (recursive || !has_event(EVENT_WINCLOSED)) {\n    return;\n  }\n  recursive = true;\n  char_u winid[NUMBUFLEN];\n  vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->handle);\n  apply_autocmds(EVENT_WINCLOSED, winid, winid, false, win->w_buffer);\n  recursive = false;\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\nvoid win_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n  int dir;\n  tabpage_T   *ptp = NULL;\n  bool free_tp = false;\n\n  // Get here with win->w_buffer == NULL when win_close() detects the tab page\n  // changed.\n  if (win->w_closing\n      || (win->w_buffer != NULL && win->w_buffer->b_locked > 0)) {\n    return;  // window is already being closed\n  }\n\n  // Fire WinClosed just before starting to free window-related resources.\n  do_autocmd_winclosed(win);\n  // autocmd may have freed the window already.\n  if (!win_valid_any_tab(win)) {\n    return;\n  }\n\n  if (win->w_buffer != NULL) {\n    // Close the link to the buffer.\n    close_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0, false);\n  }\n\n  /* Careful: Autocommands may have closed the tab page or made it the\n   * current tab page.  */\n  for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n    ;\n  if (ptp == NULL || tp == curtab)\n    return;\n\n  /* Autocommands may have closed the window already. */\n  {\n    bool found_window = false;\n    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n      if (wp == win) {\n         found_window = true;\n         break;\n      }\n    }\n    if (!found_window) {\n       return;\n    }\n  }\n\n  /* When closing the last window in a tab page remove the tab page. */\n  if (tp->tp_firstwin == tp->tp_lastwin) {\n    char_u prev_idx[NUMBUFLEN];\n    if (has_event(EVENT_TABCLOSED)) {\n      vim_snprintf((char *)prev_idx, NUMBUFLEN, \"%i\", tabpage_index(tp));\n    }\n\n    if (tp == first_tabpage) {\n      first_tabpage = tp->tp_next;\n    } else {\n      for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n           ptp = ptp->tp_next) {\n        // loop\n      }\n      if (ptp == NULL) {\n        internal_error(\"win_close_othertab()\");\n        return;\n      }\n      ptp->tp_next = tp->tp_next;\n    }\n    free_tp = true;\n\n    if (has_event(EVENT_TABCLOSED)) {\n      apply_autocmds(EVENT_TABCLOSED, prev_idx, prev_idx, false, win->w_buffer);\n    }\n  }\n\n  /* Free the memory used for the window. */\n  win_free_mem(win, &dir, tp);\n\n  if (free_tp)\n    free_tabpage(tp);\n}\n\n// Free the memory used for a window.\n// Returns a pointer to the window that got the freed up space.\nstatic win_T *win_free_mem(\n    win_T *win,\n    int *dirp,              // set to 'v' or 'h' for direction if 'ea'\n    tabpage_T *tp           // tab page \"win\" is in, NULL for current\n)\n{\n  frame_T     *frp;\n  win_T       *wp;\n\n  if (!win->w_floating) {\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    xfree(frp);\n  } else {\n    *dirp = 'h';  // Dummy value.\n    if (win_valid(prevwin) && prevwin != win) {\n      wp = prevwin;\n    } else {\n      wp = firstwin;\n    }\n  }\n  win_free(win, tp);\n\n  // When deleting the current window of another tab page select a new\n  // current window.\n  if (tp != NULL && win == tp->tp_curwin) {\n    if (win_valid(tp->tp_prevwin) && tp->tp_prevwin != win) {\n      tp->tp_curwin = tp->tp_prevwin;\n    } else {\n      tp->tp_curwin = tp->tp_firstwin;\n    }\n  }\n\n  return wp;\n}\n\n#if defined(EXITFREE)\nvoid win_free_all(void)\n{\n  int dummy;\n\n  while (first_tabpage->tp_next != NULL)\n    tabpage_close(TRUE);\n\n  while (lastwin != NULL && lastwin->w_floating) {\n    win_T *wp = lastwin;\n    win_remove(lastwin, NULL);\n    (void)win_free_mem(wp, &dummy, NULL);\n    if (wp == aucmd_win) {\n      aucmd_win = NULL;\n    }\n  }\n\n  if (aucmd_win != NULL) {\n    (void)win_free_mem(aucmd_win, &dummy, NULL);\n    aucmd_win = NULL;\n  }\n\n  while (firstwin != NULL)\n    (void)win_free_mem(firstwin, &dummy, NULL);\n\n  // No window should be used after this. Set curwin to NULL to crash\n  // instead of using freed memory.\n  curwin = NULL;\n}\n\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\nwin_T *\nwinframe_remove (\n    win_T *win,\n    int *dirp,       /* set to 'v' or 'h' for direction if 'ea' */\n    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */\n)\n{\n  frame_T     *frp, *frp2, *frp3;\n  frame_T     *frp_close = win->w_frame;\n  win_T       *wp;\n\n  /*\n   * If there is only one window there is nothing to remove.\n   */\n  if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n    return NULL;\n\n  /*\n   * Remove the window from its frame.\n   */\n  frp2 = win_altframe(win, tp);\n  wp = frame2win(frp2);\n\n  /* Remove this frame from the list of frames. */\n  frame_remove(frp_close);\n\n  if (frp_close->fr_parent->fr_layout == FR_COL) {\n    /* When 'winfixheight' is set, try to find another frame in the column\n     * (as close to the closed frame as possible) to distribute the height\n     * to. */\n    if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh) {\n      frp = frp_close->fr_prev;\n      frp3 = frp_close->fr_next;\n      while (frp != NULL || frp3 != NULL) {\n        if (frp != NULL) {\n          if (!frame_fixed_height(frp)) {\n            frp2 = frp;\n            wp = frame2win(frp2);\n            break;\n          }\n          frp = frp->fr_prev;\n        }\n        if (frp3 != NULL) {\n          if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh) {\n            frp2 = frp3;\n            wp = frp3->fr_win;\n            break;\n          }\n          frp3 = frp3->fr_next;\n        }\n      }\n    }\n    frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n                     frp2 == frp_close->fr_next, false);\n    *dirp = 'v';\n  } else {\n    /* When 'winfixwidth' is set, try to find another frame in the column\n     * (as close to the closed frame as possible) to distribute the width\n     * to. */\n    if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw) {\n      frp = frp_close->fr_prev;\n      frp3 = frp_close->fr_next;\n      while (frp != NULL || frp3 != NULL) {\n        if (frp != NULL) {\n          if (!frame_fixed_width(frp)) {\n            frp2 = frp;\n            wp = frame2win(frp2);\n            break;\n          }\n          frp = frp->fr_prev;\n        }\n        if (frp3 != NULL) {\n          if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw) {\n            frp2 = frp3;\n            wp = frp3->fr_win;\n            break;\n          }\n          frp3 = frp3->fr_next;\n        }\n      }\n    }\n    frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n                    frp2 == frp_close->fr_next, false);\n    *dirp = 'h';\n  }\n\n  /* If rows/columns go to a window below/right its positions need to be\n   * updated.  Can only be done after the sizes have been updated. */\n  if (frp2 == frp_close->fr_next) {\n    int row = win->w_winrow;\n    int col = win->w_wincol;\n\n    frame_comp_pos(frp2, &row, &col);\n  }\n\n  if (frp2->fr_next == NULL && frp2->fr_prev == NULL) {\n    /* There is no other frame in this list, move its info to the parent\n     * and remove it. */\n    frp2->fr_parent->fr_layout = frp2->fr_layout;\n    frp2->fr_parent->fr_child = frp2->fr_child;\n    FOR_ALL_FRAMES(frp, frp2->fr_child) {\n      frp->fr_parent = frp2->fr_parent;\n    }\n    frp2->fr_parent->fr_win = frp2->fr_win;\n    if (frp2->fr_win != NULL)\n      frp2->fr_win->w_frame = frp2->fr_parent;\n    frp = frp2->fr_parent;\n    if (topframe->fr_child == frp2) {\n      topframe->fr_child = frp;\n    }\n    xfree(frp2);\n\n    frp2 = frp->fr_parent;\n    if (frp2 != NULL && frp2->fr_layout == frp->fr_layout) {\n      /* The frame above the parent has the same layout, have to merge\n       * the frames into this list. */\n      if (frp2->fr_child == frp)\n        frp2->fr_child = frp->fr_child;\n      assert(frp->fr_child);\n      frp->fr_child->fr_prev = frp->fr_prev;\n      if (frp->fr_prev != NULL)\n        frp->fr_prev->fr_next = frp->fr_child;\n      for (frp3 = frp->fr_child;; frp3 = frp3->fr_next) {\n        frp3->fr_parent = frp2;\n        if (frp3->fr_next == NULL) {\n          frp3->fr_next = frp->fr_next;\n          if (frp->fr_next != NULL)\n            frp->fr_next->fr_prev = frp3;\n          break;\n        }\n      }\n      if (topframe->fr_child == frp) {\n        topframe->fr_child = frp2;\n      }\n      xfree(frp);\n    }\n  }\n\n  return wp;\n}\n\n// Return a pointer to the frame that will receive the empty screen space that\n// is left over after \"win\" is closed.\n//\n// If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n// by default.  Otherwise, the free space goes below or to the right.  The\n// result is that opening a window and then immediately closing it will\n// preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n// respected when possible.\nstatic frame_T *\nwin_altframe (\n    win_T *win,\n    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */\n)\n{\n  frame_T     *frp;\n\n  if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin) {\n    return alt_tabpage()->tp_curwin->w_frame;\n  }\n\n  frp = win->w_frame;\n\n  if (frp->fr_prev == NULL) {\n    return frp->fr_next;\n  }\n  if (frp->fr_next == NULL) {\n    return frp->fr_prev;\n  }\n\n  frame_T *target_fr = frp->fr_next;\n  frame_T *other_fr  = frp->fr_prev;\n  if (p_spr || p_sb) {\n    target_fr = frp->fr_prev;\n    other_fr  = frp->fr_next;\n  }\n\n  // If 'wfh' or 'wfw' is set for the target and not for the alternate\n  // window, reverse the selection.\n  if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW) {\n    if (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr)) {\n      target_fr = other_fr;\n    }\n  } else {\n    if (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr)) {\n      target_fr = other_fr;\n    }\n  }\n\n  return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\nstatic tabpage_T *alt_tabpage(void)\n{\n  tabpage_T   *tp;\n\n  /* Use the next tab page if possible. */\n  if (curtab->tp_next != NULL)\n    return curtab->tp_next;\n\n  /* Find the last but one tab page. */\n  for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n    ;\n  return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\nstatic win_T *frame2win(frame_T *frp)\n{\n  while (frp->fr_win == NULL)\n    frp = frp->fr_child;\n  return frp->fr_win;\n}\n\n/// Check that the frame \"frp\" contains the window \"wp\".\n///\n/// @param  frp  frame\n/// @param  wp   window\nstatic bool frame_has_win(const frame_T *frp, const win_T *wp)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (frp->fr_layout == FR_LEAF) {\n    return frp->fr_win == wp;\n  }\n  const frame_T *p;\n  FOR_ALL_FRAMES(p, frp->fr_child) {\n    if (frame_has_win(p, wp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Set a new height for a frame.  Recursively sets the height for contained\n/// frames and windows.  Caller must take care of positions.\n///\n/// @param topfirst  resize topmost contained frame first.\n/// @param wfh       obey 'winfixheight' when there is a choice;\n///                  may cause the height not to be set.\nstatic void frame_new_height(frame_T *topfrp, int height, bool topfirst,\n                             bool wfh)\n  FUNC_ATTR_NONNULL_ALL\n{\n  frame_T     *frp;\n  int extra_lines;\n  int h;\n\n  if (topfrp->fr_win != NULL) {\n    // Simple case: just one window.\n    win_new_height(topfrp->fr_win,\n                   height - topfrp->fr_win->w_status_height);\n  } else if (topfrp->fr_layout == FR_ROW) {\n    do {\n      // All frames in this row get the same new height.\n      FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n        frame_new_height(frp, height, topfirst, wfh);\n        if (frp->fr_height > height) {\n          /* Could not fit the windows, make the whole row higher. */\n          height = frp->fr_height;\n          break;\n        }\n      }\n    } while (frp != NULL);\n  } else { /* fr_layout == FR_COL */\n    /* Complicated case: Resize a column of frames.  Resize the bottom\n     * frame first, frames above that when needed. */\n\n    frp = topfrp->fr_child;\n    if (wfh)\n      /* Advance past frames with one window with 'wfh' set. */\n      while (frame_fixed_height(frp)) {\n        frp = frp->fr_next;\n        if (frp == NULL)\n          return;                   /* no frame without 'wfh', give up */\n      }\n    if (!topfirst) {\n      /* Find the bottom frame of this column */\n      while (frp->fr_next != NULL)\n        frp = frp->fr_next;\n      if (wfh)\n        /* Advance back for frames with one window with 'wfh' set. */\n        while (frame_fixed_height(frp))\n          frp = frp->fr_prev;\n    }\n\n    extra_lines = height - topfrp->fr_height;\n    if (extra_lines < 0) {\n      /* reduce height of contained frames, bottom or top frame first */\n      while (frp != NULL) {\n        h = frame_minheight(frp, NULL);\n        if (frp->fr_height + extra_lines < h) {\n          extra_lines += frp->fr_height - h;\n          frame_new_height(frp, h, topfirst, wfh);\n        } else {\n          frame_new_height(frp, frp->fr_height + extra_lines,\n              topfirst, wfh);\n          break;\n        }\n        if (topfirst) {\n          do\n            frp = frp->fr_next;\n          while (wfh && frp != NULL && frame_fixed_height(frp));\n        } else {\n          do\n            frp = frp->fr_prev;\n          while (wfh && frp != NULL && frame_fixed_height(frp));\n        }\n        /* Increase \"height\" if we could not reduce enough frames. */\n        if (frp == NULL)\n          height -= extra_lines;\n      }\n    } else if (extra_lines > 0) {\n      /* increase height of bottom or top frame */\n      frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n    }\n  }\n  topfrp->fr_height = height;\n}\n\n/// Return true if height of frame \"frp\" should not be changed because of\n/// the 'winfixheight' option.\n///\n/// @param  frp  frame\n///\n/// @return true if the frame has a fixed height\nstatic bool frame_fixed_height(frame_T *frp)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  // frame with one window: fixed height if 'winfixheight' set.\n  if (frp->fr_win != NULL) {\n    return frp->fr_win->w_p_wfh;\n  }\n  if (frp->fr_layout == FR_ROW) {\n    // The frame is fixed height if one of the frames in the row is fixed\n    // height.\n    FOR_ALL_FRAMES(frp, frp->fr_child) {\n      if (frame_fixed_height(frp)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n  // frames in the row are fixed height.\n  FOR_ALL_FRAMES(frp, frp->fr_child) {\n    if (!frame_fixed_height(frp)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Return true if width of frame \"frp\" should not be changed because of\n/// the 'winfixwidth' option.\n///\n/// @param  frp  frame\n///\n/// @return true if the frame has a fixed width\nstatic bool frame_fixed_width(frame_T *frp)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  // frame with one window: fixed width if 'winfixwidth' set.\n  if (frp->fr_win != NULL) {\n    return frp->fr_win->w_p_wfw;\n  }\n  if (frp->fr_layout == FR_COL) {\n    // The frame is fixed width if one of the frames in the row is fixed\n    // width.\n    FOR_ALL_FRAMES(frp, frp->fr_child) {\n      if (frame_fixed_width(frp)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n  // frames in the row are fixed width.\n  FOR_ALL_FRAMES(frp, frp->fr_child) {\n    if (!frame_fixed_width(frp)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\nstatic void frame_add_statusline(frame_T *frp)\n{\n  win_T       *wp;\n\n  if (frp->fr_layout == FR_LEAF) {\n    wp = frp->fr_win;\n    if (wp->w_status_height == 0) {\n      if (wp->w_height > 0)             /* don't make it negative */\n        --wp->w_height;\n      wp->w_status_height = STATUS_HEIGHT;\n    }\n  } else if (frp->fr_layout == FR_ROW) {\n    // Handle all the frames in the row.\n    FOR_ALL_FRAMES(frp, frp->fr_child) {\n      frame_add_statusline(frp);\n    }\n  } else {\n    assert(frp->fr_layout == FR_COL);\n    // Only need to handle the last frame in the column.\n    for (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next) {\n    }\n    frame_add_statusline(frp);\n  }\n}\n\n/// Set width of a frame.  Handles recursively going through contained frames.\n/// May remove separator line for windows at the right side (for win_close()).\n///\n/// @param leftfirst  resize leftmost contained frame first.\n/// @param wfw        obey 'winfixwidth' when there is a choice;\n///                   may cause the width not to be set.\nstatic void frame_new_width(frame_T *topfrp, int width, bool leftfirst,\n                            bool wfw)\n{\n  frame_T     *frp;\n  int extra_cols;\n  int w;\n  win_T       *wp;\n\n  if (topfrp->fr_layout == FR_LEAF) {\n    /* Simple case: just one window. */\n    wp = topfrp->fr_win;\n    /* Find out if there are any windows right of this one. */\n    for (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n      if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n        break;\n    if (frp->fr_parent == NULL)\n      wp->w_vsep_width = 0;\n    win_new_width(wp, width - wp->w_vsep_width);\n  } else if (topfrp->fr_layout == FR_COL) {\n    do {\n      // All frames in this column get the same new width.\n      FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n        frame_new_width(frp, width, leftfirst, wfw);\n        if (frp->fr_width > width) {\n          /* Could not fit the windows, make whole column wider. */\n          width = frp->fr_width;\n          break;\n        }\n      }\n    } while (frp != NULL);\n  } else { /* fr_layout == FR_ROW */\n    /* Complicated case: Resize a row of frames.  Resize the rightmost\n     * frame first, frames left of it when needed. */\n\n    frp = topfrp->fr_child;\n    if (wfw)\n      /* Advance past frames with one window with 'wfw' set. */\n      while (frame_fixed_width(frp)) {\n        frp = frp->fr_next;\n        if (frp == NULL)\n          return;                   /* no frame without 'wfw', give up */\n      }\n    if (!leftfirst) {\n      /* Find the rightmost frame of this row */\n      while (frp->fr_next != NULL)\n        frp = frp->fr_next;\n      if (wfw)\n        /* Advance back for frames with one window with 'wfw' set. */\n        while (frame_fixed_width(frp))\n          frp = frp->fr_prev;\n    }\n\n    extra_cols = width - topfrp->fr_width;\n    if (extra_cols < 0) {\n      /* reduce frame width, rightmost frame first */\n      while (frp != NULL) {\n        w = frame_minwidth(frp, NULL);\n        if (frp->fr_width + extra_cols < w) {\n          extra_cols += frp->fr_width - w;\n          frame_new_width(frp, w, leftfirst, wfw);\n        } else {\n          frame_new_width(frp, frp->fr_width + extra_cols,\n              leftfirst, wfw);\n          break;\n        }\n        if (leftfirst) {\n          do\n            frp = frp->fr_next;\n          while (wfw && frp != NULL && frame_fixed_width(frp));\n        } else {\n          do\n            frp = frp->fr_prev;\n          while (wfw && frp != NULL && frame_fixed_width(frp));\n        }\n        /* Increase \"width\" if we could not reduce enough frames. */\n        if (frp == NULL)\n          width -= extra_cols;\n      }\n    } else if (extra_cols > 0) {\n      /* increase width of rightmost frame */\n      frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n    }\n  }\n  topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\nstatic void frame_add_vsep(const frame_T *frp)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  win_T       *wp;\n\n  if (frp->fr_layout == FR_LEAF) {\n    wp = frp->fr_win;\n    if (wp->w_vsep_width == 0) {\n      if (wp->w_width > 0)              /* don't make it negative */\n        --wp->w_width;\n      wp->w_vsep_width = 1;\n    }\n  } else if (frp->fr_layout == FR_COL) {\n    // Handle all the frames in the column.\n    FOR_ALL_FRAMES(frp, frp->fr_child) {\n      frame_add_vsep(frp);\n    }\n  } else {\n    assert(frp->fr_layout == FR_ROW);\n    // Only need to handle the last frame in the row.\n    frp = frp->fr_child;\n    while (frp->fr_next != NULL)\n      frp = frp->fr_next;\n    frame_add_vsep(frp);\n  }\n}\n\n/*\n * Set frame width from the window it contains.\n */\nstatic void frame_fix_width(win_T *wp)\n{\n  wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\nstatic void frame_fix_height(win_T *wp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  wp->w_frame->fr_height = wp->w_height + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n  frame_T     *frp;\n  int m;\n  int n;\n\n  if (topfrp->fr_win != NULL) {\n    if (topfrp->fr_win == next_curwin) {\n      m = p_wh + topfrp->fr_win->w_status_height;\n    } else {\n      // window: minimal height of the window plus status line\n      m = p_wmh + topfrp->fr_win->w_status_height;\n      if (topfrp->fr_win == curwin && next_curwin == NULL) {\n        // Current window is minimal one line high.\n        if (p_wmh == 0) {\n          m++;\n        }\n      }\n    }\n  } else if (topfrp->fr_layout == FR_ROW) {\n    /* get the minimal height from each frame in this row */\n    m = 0;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      n = frame_minheight(frp, next_curwin);\n      if (n > m)\n        m = n;\n    }\n  } else {\n    /* Add up the minimal heights for all frames in this column. */\n    m = 0;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      m += frame_minheight(frp, next_curwin);\n    }\n  }\n\n  return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\nstatic int \nframe_minwidth (\n    frame_T *topfrp,\n    win_T *next_curwin       /* use p_wh and p_wiw for next_curwin */\n)\n{\n  frame_T     *frp;\n  int m, n;\n\n  if (topfrp->fr_win != NULL) {\n    if (topfrp->fr_win == next_curwin)\n      m = p_wiw + topfrp->fr_win->w_vsep_width;\n    else {\n      /* window: minimal width of the window plus separator column */\n      m = p_wmw + topfrp->fr_win->w_vsep_width;\n      /* Current window is minimal one column wide */\n      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n        ++m;\n    }\n  } else if (topfrp->fr_layout == FR_COL) {\n    /* get the minimal width from each frame in this column */\n    m = 0;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      n = frame_minwidth(frp, next_curwin);\n      if (n > m)\n        m = n;\n    }\n  } else {\n    /* Add up the minimal widths for all frames in this row. */\n    m = 0;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      m += frame_minwidth(frp, next_curwin);\n    }\n  }\n\n  return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\nvoid \nclose_others (\n    int message,\n    int forceit                        /* always hide all other windows */\n)\n{\n  win_T       *wp;\n  win_T       *nextwp;\n  int r;\n\n  if (curwin->w_floating) {\n    if (message && !autocmd_busy) {\n      EMSG(e_floatonly);\n    }\n    return;\n  }\n\n  if (one_window() && !lastwin->w_floating) {\n    if (message\n        && !autocmd_busy\n        ) {\n      MSG(_(m_onlyone));\n    }\n    return;\n  }\n\n  /* Be very careful here: autocommands may change the window layout. */\n  for (wp = firstwin; win_valid(wp); wp = nextwp) {\n    nextwp = wp->w_next;\n    if (wp == curwin) {                 /* don't close current window */\n      continue;\n    }\n\n    /* Check if it's allowed to abandon this window */\n    r = can_abandon(wp->w_buffer, forceit);\n    if (!win_valid(wp)) {             /* autocommands messed wp up */\n      nextwp = firstwin;\n      continue;\n    }\n    if (!r) {\n      if (message && (p_confirm || cmdmod.confirm) && p_write) {\n        dialog_changed(wp->w_buffer, false);\n        if (!win_valid(wp)) {                 // autocommands messed wp up\n          nextwp = firstwin;\n          continue;\n        }\n      }\n      if (bufIsChanged(wp->w_buffer))\n        continue;\n    }\n    win_close(wp, !buf_hide(wp->w_buffer) && !bufIsChanged(wp->w_buffer));\n  }\n\n  if (message && !ONE_WINDOW)\n    EMSG(_(\"E445: Other window contains changes\"));\n}\n\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\nvoid curwin_init(void)\n{\n  win_init_empty(curwin);\n}\n\nvoid win_init_empty(win_T *wp)\n{\n  redraw_later(wp, NOT_VALID);\n  wp->w_lines_valid = 0;\n  wp->w_cursor.lnum = 1;\n  wp->w_curswant = wp->w_cursor.col = 0;\n  wp->w_cursor.coladd = 0;\n  wp->w_pcmark.lnum = 1;        /* pcmark not cleared but set to line 1 */\n  wp->w_pcmark.col = 0;\n  wp->w_prev_pcmark.lnum = 0;\n  wp->w_prev_pcmark.col = 0;\n  wp->w_topline = 1;\n  wp->w_topfill = 0;\n  wp->w_botline = 2;\n  wp->w_s = &wp->w_buffer->b_s;\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n *\n * Return FAIL when something goes wrong.\n */\nint win_alloc_first(void)\n{\n  if (win_alloc_firstwin(NULL) == FAIL)\n    return FAIL;\n\n  first_tabpage = alloc_tabpage();\n  first_tabpage->tp_topframe = topframe;\n  curtab = first_tabpage;\n  curtab->tp_firstwin = firstwin;\n  curtab->tp_lastwin = lastwin;\n  curtab->tp_curwin = curwin;\n\n  return OK;\n}\n\n// Init `aucmd_win`. This can only be done after the first window\n// is fully initialized, thus it can't be in win_alloc_first().\nvoid win_alloc_aucmd_win(void)\n{\n  Error err = ERROR_INIT;\n  FloatConfig fconfig = FLOAT_CONFIG_INIT;\n  fconfig.width = Columns;\n  fconfig.height = 5;\n  fconfig.focusable = false;\n  aucmd_win = win_new_float(NULL, fconfig, &err);\n  aucmd_win->w_buffer->b_nwindows--;\n  RESET_BINDING(aucmd_win);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\nstatic int win_alloc_firstwin(win_T *oldwin)\n{\n  curwin = win_alloc(NULL, false);\n  if (oldwin == NULL) {\n    /* Very first window, need to create an empty buffer for it and\n     * initialize from scratch. */\n    curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n    if (curbuf == NULL) {\n      return FAIL;\n    }\n    curwin->w_buffer = curbuf;\n    curwin->w_s = &(curbuf->b_s);\n    curbuf->b_nwindows = 1;     /* there is one window */\n    curwin->w_alist = &global_alist;\n    curwin_init();              /* init current window */\n  } else {\n    /* First window in new tab page, initialize it from \"oldwin\". */\n    win_init(curwin, oldwin, 0);\n\n    /* We don't want cursor- and scroll-binding in the first window. */\n    RESET_BINDING(curwin);\n  }\n\n  new_frame(curwin);\n  topframe = curwin->w_frame;\n  topframe->fr_width = Columns;\n  topframe->fr_height = Rows - p_ch;\n\n  return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\nstatic void new_frame(win_T *wp)\n{\n  frame_T *frp = xcalloc(1, sizeof(frame_T));\n\n  wp->w_frame = frp;\n  frp->fr_layout = FR_LEAF;\n  frp->fr_win = wp;\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\nvoid win_init_size(void)\n{\n  firstwin->w_height = ROWS_AVAIL;\n  firstwin->w_height_inner = firstwin->w_height;\n  firstwin->w_height_outer = firstwin->w_height;\n  topframe->fr_height = ROWS_AVAIL;\n  firstwin->w_width = Columns;\n  firstwin->w_width_inner = firstwin->w_width;\n  firstwin->w_width_outer = firstwin->w_width;\n  topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n */\nstatic tabpage_T *alloc_tabpage(void)\n{\n  static int last_tp_handle = 0;\n  tabpage_T *tp = xcalloc(1, sizeof(tabpage_T));\n  tp->handle = ++last_tp_handle;\n  pmap_put(handle_T)(&tabpage_handles, tp->handle, tp);\n\n  // Init t: variables.\n  tp->tp_vars = tv_dict_alloc();\n  init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n  tp->tp_diff_invalid = TRUE;\n  tp->tp_ch_used = p_ch;\n\n  return tp;\n}\n\nvoid free_tabpage(tabpage_T *tp)\n{\n  int idx;\n\n  pmap_del(handle_T)(&tabpage_handles, tp->handle);\n  diff_clear(tp);\n  for (idx = 0; idx < SNAP_COUNT; ++idx)\n    clear_snapshot(tp, idx);\n  vars_clear(&tp->tp_vars->dv_hashtab);         /* free all t: variables */\n  hash_init(&tp->tp_vars->dv_hashtab);\n  unref_var_dict(tp->tp_vars);\n\n  if (tp == lastused_tabpage) {\n    lastused_tabpage = NULL;\n  }\n\n  xfree(tp->tp_localdir);\n  xfree(tp);\n}\n\n/// Create a new tabpage with one window.\n///\n/// It will edit the current buffer, like after :split.\n///\n/// @param after Put new tabpage after tabpage \"after\", or after the current\n///              tabpage in case of 0.\n/// @param filename Will be passed to apply_autocmds().\n/// @return Was the new tabpage created successfully? FAIL or OK.\nint win_new_tabpage(int after, char_u *filename)\n{\n  tabpage_T   *old_curtab = curtab;\n  tabpage_T   *newtp;\n  int n;\n\n  newtp = alloc_tabpage();\n\n  // Remember the current windows in this Tab page.\n  if (leave_tabpage(curbuf, true) == FAIL) {\n    xfree(newtp);\n    return FAIL;\n  }\n\n  newtp->tp_localdir = old_curtab->tp_localdir\n    ? vim_strsave(old_curtab->tp_localdir) : NULL;\n\n  curtab = newtp;\n\n  // Create a new empty window.\n  if (win_alloc_firstwin(old_curtab->tp_curwin) == OK) {\n    // Make the new Tab page the new topframe.\n    if (after == 1) {\n      // New tab page becomes the first one.\n      newtp->tp_next = first_tabpage;\n      first_tabpage = newtp;\n    } else {\n      tabpage_T   *tp = old_curtab;\n\n      if (after > 0) {\n        // Put new tab page before tab page \"after\".\n        n = 2;\n        for (tp = first_tabpage; tp->tp_next != NULL\n             && n < after; tp = tp->tp_next)\n          ++n;\n      }\n      newtp->tp_next = tp->tp_next;\n      tp->tp_next = newtp;\n    }\n    newtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n    win_init_size();\n    firstwin->w_winrow = tabline_height();\n    win_comp_scroll(curwin);\n\n    newtp->tp_topframe = topframe;\n    last_status(false);\n\n    redraw_all_later(NOT_VALID);\n\n    tabpage_check_windows(old_curtab);\n\n    lastused_tabpage = old_curtab;\n\n    apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf);\n    apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);\n    apply_autocmds(EVENT_TABNEW, filename, filename, false, curbuf);\n    apply_autocmds(EVENT_TABENTER, NULL, NULL, false, curbuf);\n\n    return OK;\n  }\n\n  // Failed, get back the previous Tab page\n  enter_tabpage(curtab, curbuf, true, true);\n  return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\nint may_open_tabpage(void)\n{\n  int n = (cmdmod.tab == 0) ? postponed_split_tab : cmdmod.tab;\n\n  if (n != 0) {\n    cmdmod.tab = 0;         /* reset it to avoid doing it twice */\n    postponed_split_tab = 0;\n    return win_new_tabpage(n, NULL);\n  }\n  return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\nint make_tabpages(int maxcount)\n{\n  int count = maxcount;\n  int todo;\n\n  /* Limit to 'tabpagemax' tabs. */\n  if (count > p_tpm)\n    count = p_tpm;\n\n  /*\n   * Don't execute autocommands while creating the tab pages.  Must do that\n   * when putting the buffers in the windows.\n   */\n  block_autocmds();\n\n  for (todo = count - 1; todo > 0; --todo) {\n    if (win_new_tabpage(0, NULL) == FAIL) {\n      break;\n    }\n  }\n\n  unblock_autocmds();\n\n  /* return actual number of tab pages */\n  return count - todo;\n}\n\n/// Check that tpc points to a valid tab page.\n///\n/// @param[in]  tpc  Tabpage to check.\nbool valid_tabpage(tabpage_T *tpc) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_TABS(tp) {\n    if (tp == tpc) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Returns true when `tpc` is valid and at least one window is valid.\nint valid_tabpage_win(tabpage_T *tpc)\n{\n  FOR_ALL_TABS(tp) {\n    if (tp == tpc) {\n      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n        if (win_valid_any_tab(wp)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  // shouldn't happen\n  return false;\n}\n\n/// Close tabpage `tab`, assuming it has no windows in it.\n/// There must be another tabpage or this will crash.\nvoid close_tabpage(tabpage_T *tab)\n{\n  tabpage_T *ptp;\n\n  if (tab == first_tabpage) {\n    first_tabpage = tab->tp_next;\n    ptp = first_tabpage;\n  } else {\n    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n         ptp = ptp->tp_next) {\n      // do nothing\n    }\n    assert(ptp != NULL);\n    ptp->tp_next = tab->tp_next;\n  }\n\n  goto_tabpage_tp(ptp, false, false);\n  free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\ntabpage_T *find_tabpage(int n)\n{\n  tabpage_T   *tp;\n  int i = 1;\n\n  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n    ++i;\n  return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\nint tabpage_index(tabpage_T *ftp)\n{\n  int i = 1;\n  tabpage_T   *tp;\n\n  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n    ++i;\n  return i;\n}\n\n/// Prepare for leaving the current tab page.\n/// When autocommands change \"curtab\" we don't leave the tab page and return\n/// FAIL.\n/// Careful: When OK is returned need to get a new tab page very very soon!\n///\n/// @param new_curbuf              what is going to be the new curbuf,\n///                                NULL if unknown.\n/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.\nstatic int leave_tabpage(buf_T *new_curbuf, bool trigger_leave_autocmds)\n{\n  tabpage_T   *tp = curtab;\n\n  reset_VIsual_and_resel();     /* stop Visual mode */\n  if (trigger_leave_autocmds) {\n    if (new_curbuf != curbuf) {\n      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n      if (curtab != tp)\n        return FAIL;\n    }\n    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n    if (curtab != tp)\n      return FAIL;\n    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n    if (curtab != tp)\n      return FAIL;\n  }\n  tp->tp_curwin = curwin;\n  tp->tp_prevwin = prevwin;\n  tp->tp_firstwin = firstwin;\n  tp->tp_lastwin = lastwin;\n  tp->tp_old_Rows = Rows;\n  tp->tp_old_Columns = Columns;\n  firstwin = NULL;\n  lastwin = NULL;\n  return OK;\n}\n\n/// Start using tab page \"tp\".\n/// Only to be used after leave_tabpage() or freeing the current tab page.\n///\n/// @param trigger_enter_autocmds  when true trigger *Enter autocommands.\n/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf,\n                          bool trigger_enter_autocmds,\n                          bool trigger_leave_autocmds)\n{\n  int old_off = tp->tp_firstwin->w_winrow;\n  win_T       *next_prevwin = tp->tp_prevwin;\n\n  tabpage_T *old_curtab = curtab;\n  curtab = tp;\n  firstwin = tp->tp_firstwin;\n  lastwin = tp->tp_lastwin;\n  topframe = tp->tp_topframe;\n\n  if (old_curtab != curtab) {\n     tabpage_check_windows(old_curtab);\n  }\n\n  /* We would like doing the TabEnter event first, but we don't have a\n   * valid current window yet, which may break some commands.\n   * This triggers autocommands, thus may make \"tp\" invalid. */\n  win_enter_ext(tp->tp_curwin, false, true, false,\n                trigger_enter_autocmds, trigger_leave_autocmds);\n  prevwin = next_prevwin;\n\n  last_status(false);  // status line may appear or disappear\n  const int row = win_comp_pos();  // recompute w_winrow for all windows\n  diff_need_scrollbind = true;\n\n  /* The tabpage line may have appeared or disappeared, may need to resize\n   * the frames for that.  When the Vim window was resized need to update\n   * frame sizes too.  Use the stored value of p_ch, so that it can be\n   * different for each tab page. */\n  if (p_ch != curtab->tp_ch_used) {\n    clear_cmdline = true;\n  }\n  p_ch = curtab->tp_ch_used;\n\n  // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n  // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n  // check cmdline_row.\n  if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch)) {\n    clear_cmdline = true;\n  }\n\n  if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow)) {\n    shell_new_rows();\n  }\n  if (curtab->tp_old_Columns != Columns && starting == 0) {\n    shell_new_columns();  // update window widths\n  }\n\n  lastused_tabpage = old_curtab;\n\n  /* Apply autocommands after updating the display, when 'rows' and\n   * 'columns' have been set correctly. */\n  if (trigger_enter_autocmds) {\n    apply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n    if (old_curbuf != curbuf)\n      apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n  }\n\n  redraw_all_later(NOT_VALID);\n}\n\n/// tells external UI that windows and inline floats in old_curtab are invisible\n/// and that floats in curtab is now visible.\n///\n/// External floats are considered independent of tabpages. This is\n/// implemented by always moving them to curtab.\nstatic void tabpage_check_windows(tabpage_T *old_curtab)\n{\n  win_T *next_wp;\n  for (win_T *wp = old_curtab->tp_firstwin; wp; wp = next_wp) {\n    next_wp = wp->w_next;\n    if (wp->w_floating) {\n      if (wp->w_float_config.external) {\n        win_remove(wp, old_curtab);\n        win_append(lastwin_nofloating(), wp);\n      } else {\n        ui_comp_remove_grid(&wp->w_grid_alloc);\n      }\n    }\n    wp->w_pos_changed = true;\n  }\n\n  for (win_T *wp = firstwin; wp; wp = wp->w_next) {\n    if (wp->w_floating && !wp->w_float_config.external) {\n      win_config_float(wp, wp->w_float_config);\n    }\n    wp->w_pos_changed = true;\n  }\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\nvoid goto_tabpage(int n)\n{\n  tabpage_T   *tp = NULL;  // shut up compiler\n  tabpage_T   *ttp;\n  int i;\n\n  if (text_locked()) {\n    // Not allowed when editing the command line.\n    text_locked_msg();\n    return;\n  }\n\n  /* If there is only one it can't work. */\n  if (first_tabpage->tp_next == NULL) {\n    if (n > 1)\n      beep_flush();\n    return;\n  }\n\n  if (n == 0) {\n    /* No count, go to next tab page, wrap around end. */\n    if (curtab->tp_next == NULL)\n      tp = first_tabpage;\n    else\n      tp = curtab->tp_next;\n  } else if (n < 0) {\n    /* \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n     * this N times. */\n    ttp = curtab;\n    for (i = n; i < 0; ++i) {\n      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n           tp = tp->tp_next)\n        ;\n      ttp = tp;\n    }\n  } else if (n == 9999) {\n    /* Go to last tab page. */\n    for (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n      ;\n  } else {\n    /* Go to tab page \"n\". */\n    tp = find_tabpage(n);\n    if (tp == NULL) {\n      beep_flush();\n      return;\n    }\n  }\n\n  goto_tabpage_tp(tp, true, true);\n}\n\n/// Go to tabpage \"tp\".\n/// Note: doesn't update the GUI tab.\n///\n/// @param trigger_enter_autocmds  when true trigger *Enter autocommands.\n/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.\nvoid goto_tabpage_tp(tabpage_T *tp, bool trigger_enter_autocmds,\n                     bool trigger_leave_autocmds)\n{\n  /* Don't repeat a message in another tab page. */\n  set_keep_msg(NULL, 0);\n\n  if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n          trigger_leave_autocmds) == OK) {\n    if (valid_tabpage(tp))\n      enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n          trigger_leave_autocmds);\n    else\n      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n          trigger_leave_autocmds);\n  }\n}\n\n// Go to the last accessed tab page, if there is one.\nvoid goto_tabpage_lastused(void)\n{\n  int index = tabpage_index(lastused_tabpage);\n  if (index < tabpage_index(NULL)) {\n    goto_tabpage(index);\n  }\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\nvoid goto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n  goto_tabpage_tp(tp, true, true);\n  if (curtab == tp && win_valid(wp)) {\n    win_enter(wp, true);\n  }\n}\n\n// Move the current tab page to after tab page \"nr\".\nvoid tabpage_move(int nr)\n{\n  int n = 1;\n  tabpage_T *tp;\n  tabpage_T *tp_dst;\n\n  assert(curtab != NULL);\n\n  if (first_tabpage->tp_next == NULL) {\n    return;\n  }\n\n  for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next) {\n    ++n;\n  }\n\n  if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n                       && tp->tp_next == curtab)) {\n    return;\n  }\n\n  tp_dst = tp;\n\n  // Remove the current tab page from the list of tab pages.\n  if (curtab == first_tabpage) {\n    first_tabpage = curtab->tp_next;\n  } else {\n    tp = NULL;\n    FOR_ALL_TABS(tp2) {\n      if (tp2->tp_next == curtab) {\n        tp = tp2;\n        break;\n      }\n    }\n    if (tp == NULL) {   // \"cannot happen\"\n      return;\n    }\n    tp->tp_next = curtab->tp_next;\n  }\n\n  // Re-insert it at the specified position.\n  if (nr <= 0) {\n    curtab->tp_next = first_tabpage;\n    first_tabpage = curtab;\n  } else {\n    curtab->tp_next = tp_dst->tp_next;\n    tp_dst->tp_next = curtab;\n  }\n\n  // Need to redraw the tabline.  Tab page contents doesn't change.\n  redraw_tabline = true;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\nvoid win_goto(win_T *wp)\n{\n  win_T       *owp = curwin;\n\n  if (text_locked()) {\n    beep_flush();\n    text_locked_msg();\n    return;\n  }\n  if (curbuf_locked())\n    return;\n\n  if (wp->w_buffer != curbuf)\n    reset_VIsual_and_resel();\n  else if (VIsual_active)\n    wp->w_cursor = curwin->w_cursor;\n\n  win_enter(wp, true);\n\n  // Conceal cursor line in previous window, unconceal in current window.\n  if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled) {\n    redrawWinline(owp, owp->w_cursor.lnum);\n  }\n  if (curwin->w_p_cole > 0 && !msg_scrolled) {\n    redrawWinline(curwin, curwin->w_cursor.lnum);\n  }\n}\n\n\n/*\n * Find the tabpage for window \"win\".\n */\ntabpage_T *win_find_tabpage(win_T *win)\n{\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp == win) {\n      return tp;\n    }\n  }\n  return NULL;\n}\n\n/// Get the above or below neighbor window of the specified window.\n///\n/// Returns the specified window if the neighbor is not found.\n/// Returns the previous window if the specifiecied window is a floating window.\n///\n/// @param up     true for the above neighbor\n/// @param count  nth neighbor window\n///\n/// @return       found window\nwin_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, bool up, long count)\n{\n  frame_T     *fr;\n  frame_T     *nfr;\n  frame_T     *foundfr;\n\n  foundfr = wp->w_frame;\n\n  if (wp->w_floating) {\n    return win_valid(prevwin) && !prevwin->w_floating ? prevwin : firstwin;\n  }\n\n  while (count--) {\n    /*\n     * First go upwards in the tree of frames until we find an upwards or\n     * downwards neighbor.\n     */\n    fr = foundfr;\n    for (;; ) {\n      if (fr == tp->tp_topframe) {\n        goto end;\n      }\n      if (up) {\n        nfr = fr->fr_prev;\n      } else {\n        nfr = fr->fr_next;\n      }\n      if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL) {\n        break;\n      }\n      fr = fr->fr_parent;\n    }\n\n    /*\n     * Now go downwards to find the bottom or top frame in it.\n     */\n    for (;; ) {\n      if (nfr->fr_layout == FR_LEAF) {\n        foundfr = nfr;\n        break;\n      }\n      fr = nfr->fr_child;\n      if (nfr->fr_layout == FR_ROW) {\n        // Find the frame at the cursor row.\n        while (fr->fr_next != NULL\n               && frame2win(fr)->w_wincol + fr->fr_width\n               <= wp->w_wincol + wp->w_wcol) {\n          fr = fr->fr_next;\n        }\n      }\n      if (nfr->fr_layout == FR_COL && up)\n        while (fr->fr_next != NULL)\n          fr = fr->fr_next;\n      nfr = fr;\n    }\n  }\nend:\n  return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/// Move to window above or below \"count\" times.\n///\n/// @param up     true to go to win above\n/// @param count  go count times into direction\nstatic void win_goto_ver(bool up, long count)\n{\n  win_T *win = win_vert_neighbor(curtab, curwin, up, count);\n  if (win != NULL) {\n    win_goto(win);\n  }\n}\n\n/// Get the left or right neighbor window of the specified window.\n///\n/// Returns the specified window if the neighbor is not found.\n/// Returns the previous window if the specifiecied window is a floating window.\n///\n/// @param left  true for the left neighbor\n/// @param count nth neighbor window\n///\n/// @return      found window\nwin_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, bool left, long count)\n{\n  frame_T     *fr;\n  frame_T     *nfr;\n  frame_T     *foundfr;\n\n  foundfr = wp->w_frame;\n\n  if (wp->w_floating) {\n    return win_valid(prevwin) && !prevwin->w_floating ? prevwin : firstwin;\n  }\n\n  while (count--) {\n    /*\n     * First go upwards in the tree of frames until we find a left or\n     * right neighbor.\n     */\n    fr = foundfr;\n    for (;; ) {\n      if (fr == tp->tp_topframe) {\n        goto end;\n      }\n      if (left) {\n        nfr = fr->fr_prev;\n      } else {\n        nfr = fr->fr_next;\n      }\n      if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL) {\n        break;\n      }\n      fr = fr->fr_parent;\n    }\n\n    /*\n     * Now go downwards to find the leftmost or rightmost frame in it.\n     */\n    for (;; ) {\n      if (nfr->fr_layout == FR_LEAF) {\n        foundfr = nfr;\n        break;\n      }\n      fr = nfr->fr_child;\n      if (nfr->fr_layout == FR_COL) {\n        /* Find the frame at the cursor row. */\n        while (fr->fr_next != NULL\n               && frame2win(fr)->w_winrow + fr->fr_height\n               <= wp->w_winrow + wp->w_wrow)\n          fr = fr->fr_next;\n      }\n      if (nfr->fr_layout == FR_ROW && left)\n        while (fr->fr_next != NULL)\n          fr = fr->fr_next;\n      nfr = fr;\n    }\n  }\nend:\n  return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/// Move to left or right window.\n///\n/// @param left   true to go to left window\n/// @param count  go count times into direction\nstatic void win_goto_hor(bool left, long count)\n{\n  win_T *win = win_horz_neighbor(curtab, curwin, left, count);\n  if (win != NULL) {\n    win_goto(win);\n  }\n}\n\n/// Make window `wp` the current window.\n///\n/// @warning Autocmds may close the window immediately, so caller must check\n///          win_valid(wp).\nvoid win_enter(win_T *wp, bool undo_sync)\n{\n  win_enter_ext(wp, undo_sync, false, false, true, true);\n}\n\n/// Make window wp the current window.\n///\n/// @param curwin_invalid  curwin has just been closed and\n///                        isn't valid when true.\nstatic void win_enter_ext(win_T *wp, bool undo_sync, bool curwin_invalid,\n                          bool trigger_new_autocmds,\n                          bool trigger_enter_autocmds,\n                          bool trigger_leave_autocmds)\n{\n  int other_buffer = FALSE;\n\n  if (wp == curwin && !curwin_invalid)          /* nothing to do */\n    return;\n\n  if (!curwin_invalid && trigger_leave_autocmds) {\n    /*\n     * Be careful: If autocommands delete the window, return now.\n     */\n    if (wp->w_buffer != curbuf) {\n      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n      other_buffer = TRUE;\n      if (!win_valid(wp))\n        return;\n    }\n    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n    if (!win_valid(wp))\n      return;\n    /* autocmds may abort script processing */\n    if (aborting())\n      return;\n  }\n\n  // sync undo before leaving the current buffer\n  if (undo_sync && curbuf != wp->w_buffer) {\n    u_sync(false);\n  }\n\n  // Might need to scroll the old window before switching, e.g., when the\n  // cursor was moved.\n  update_topline(curwin);\n\n  // may have to copy the buffer options when 'cpo' contains 'S'\n  if (wp->w_buffer != curbuf) {\n    buf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n  }\n  if (!curwin_invalid) {\n    prevwin = curwin;           /* remember for CTRL-W p */\n    curwin->w_redr_status = TRUE;\n  }\n  curwin = wp;\n  curbuf = wp->w_buffer;\n\n  check_cursor();\n  if (!virtual_active())\n    curwin->w_cursor.coladd = 0;\n  changed_line_abv_curs();      /* assume cursor position needs updating */\n\n  // New directory is either the local directory of the window, tab or NULL.\n  char *new_dir = (char *)(curwin->w_localdir\n                           ? curwin->w_localdir : curtab->tp_localdir);\n\n  char cwd[MAXPATHL];\n  if (os_dirname((char_u *)cwd, MAXPATHL) != OK) {\n    cwd[0] = NUL;\n  }\n\n  if (new_dir) {\n    // Window/tab has a local directory: Save current directory as global\n    // (unless that was done already) and change to the local directory.\n    if (globaldir == NULL) {\n      if (cwd[0] != NUL) {\n        globaldir = (char_u *)xstrdup(cwd);\n      }\n    }\n    if (os_chdir(new_dir) == 0) {\n      if (!p_acd && !strequal(new_dir, cwd)) {\n        do_autocmd_dirchanged(new_dir, curwin->w_localdir\n                              ? kCdScopeWindow : kCdScopeTab, true);\n      }\n      shorten_fnames(true);\n    }\n  } else if (globaldir != NULL) {\n    // Window doesn't have a local directory and we are not in the global\n    // directory: Change to the global directory.\n    if (os_chdir((char *)globaldir) == 0) {\n      if (!p_acd && !strequal((char *)globaldir, cwd)) {\n        do_autocmd_dirchanged((char *)globaldir, kCdScopeGlobal, true);\n      }\n    }\n    XFREE_CLEAR(globaldir);\n    shorten_fnames(true);\n  }\n\n  if (trigger_new_autocmds) {\n    apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf);\n  }\n  if (trigger_enter_autocmds) {\n    apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);\n    if (other_buffer) {\n      apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);\n    }\n    apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, false, curbuf);\n    curwin->w_last_cursormoved = curwin->w_cursor;\n  }\n\n  maketitle();\n  curwin->w_redr_status = true;\n  redraw_tabline = true;\n  if (restart_edit) {\n    redraw_later(curwin, VALID);  // causes status line redraw\n  }\n\n  if (HL_ATTR(HLF_INACTIVE)\n      || (prevwin && prevwin->w_hl_ids[HLF_INACTIVE])\n      || curwin->w_hl_ids[HLF_INACTIVE]) {\n    redraw_all_later(NOT_VALID);\n  }\n\n  // set window height to desired minimal value\n  if (curwin->w_height < p_wh && !curwin->w_p_wfh && !curwin->w_floating) {\n    win_setheight((int)p_wh);\n  } else if (curwin->w_height == 0) {\n    win_setheight(1);\n  }\n\n  // set window width to desired minimal value\n  if (curwin->w_width < p_wiw && !curwin->w_p_wfw && !wp->w_floating) {\n    win_setwidth((int)p_wiw);\n  }\n\n  setmouse();                   /* in case jumped to/from help buffer */\n\n  /* Change directories when the 'acd' option is set. */\n  do_autochdir();\n}\n\n\n/// Jump to the first open window that contains buffer \"buf\", if one exists.\n/// Returns a pointer to the window found, otherwise NULL.\nwin_T *buf_jump_open_win(buf_T *buf)\n{\n  if (curwin->w_buffer == buf) {\n    win_enter(curwin, false);\n    return curwin;\n  } else {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_buffer == buf) {\n        win_enter(wp, false);\n        return wp;\n      }\n    }\n  }\n\n  return NULL;\n}\n\n/// Jump to the first open window in any tab page that contains buffer \"buf\",\n/// if one exists.\n/// @return the found window, or NULL.\nwin_T *buf_jump_open_tab(buf_T *buf)\n{\n\n  // First try the current tab page.\n  {\n    win_T *wp = buf_jump_open_win(buf);\n    if (wp != NULL)\n      return wp;\n  }\n\n  FOR_ALL_TABS(tp) {\n    // Skip the current tab since we already checked it.\n    if (tp == curtab) {\n      continue;\n    }\n    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n      if (wp->w_buffer == buf) {\n        goto_tabpage_win(tp, wp);\n\n        // If we the current window didn't switch,\n        // something went wrong.\n        if (curwin != wp) {\n          wp = NULL;\n        }\n\n        // Return the window we switched to.\n        return wp;\n      }\n    }\n  }\n\n  // If we made it this far, we didn't find the buffer.\n  return NULL;\n}\n\n/// @param hidden  allocate a window structure and link it in the window if\n//                 false.\nstatic win_T *win_alloc(win_T *after, bool hidden)\n{\n  static int last_win_id = LOWEST_WIN_ID - 1;\n\n  // allocate window structure and linesizes arrays\n  win_T *new_wp = xcalloc(1, sizeof(win_T));\n\n  new_wp->handle = ++last_win_id;\n  pmap_put(handle_T)(&window_handles, new_wp->handle, new_wp);\n\n  grid_assign_handle(&new_wp->w_grid_alloc);\n\n  // Init w: variables.\n  new_wp->w_vars = tv_dict_alloc();\n  init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n\n  /* Don't execute autocommands while the window is not properly\n   * initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n   * event. */\n  block_autocmds();\n  /*\n   * link the window in the window list\n   */\n  if (!hidden)\n    win_append(after, new_wp);\n\n  new_wp->w_wincol = 0;\n  new_wp->w_width = Columns;\n\n  /* position the display and the cursor at the top of the file. */\n  new_wp->w_topline = 1;\n  new_wp->w_topfill = 0;\n  new_wp->w_botline = 2;\n  new_wp->w_cursor.lnum = 1;\n  new_wp->w_scbind_pos = 1;\n  new_wp->w_floating = 0;\n  new_wp->w_float_config = FLOAT_CONFIG_INIT;\n  new_wp->w_viewport_invalid = true;\n\n  // use global option for global-local options\n  new_wp->w_p_so = -1;\n  new_wp->w_p_siso = -1;\n\n  /* We won't calculate w_fraction until resizing the window */\n  new_wp->w_fraction = 0;\n  new_wp->w_prev_fraction_row = -1;\n\n  foldInitWin(new_wp);\n  unblock_autocmds();\n  new_wp->w_match_head = NULL;\n  new_wp->w_next_match_id = 4;\n  return new_wp;\n}\n\n\n// Free one wininfo_T.\nvoid\nfree_wininfo(wininfo_T *wip, buf_T *bp)\n{\n  if (wip->wi_optset) {\n    clear_winopt(&wip->wi_opt);\n    deleteFoldRecurse(bp, &wip->wi_folds);\n  }\n  xfree(wip);\n}\n\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\nstatic void \nwin_free (\n    win_T *wp,\n    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */\n)\n{\n  int i;\n  wininfo_T   *wip;\n\n  pmap_del(handle_T)(&window_handles, wp->handle);\n  clearFolding(wp);\n\n  /* reduce the reference count to the argument list. */\n  alist_unlink(wp->w_alist);\n\n  /* Don't execute autocommands while the window is halfway being deleted.\n   * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */\n  block_autocmds();\n\n  clear_winopt(&wp->w_onebuf_opt);\n  clear_winopt(&wp->w_allbuf_opt);\n\n  vars_clear(&wp->w_vars->dv_hashtab);          /* free all w: variables */\n  hash_init(&wp->w_vars->dv_hashtab);\n  unref_var_dict(wp->w_vars);\n\n  if (prevwin == wp) {\n    prevwin = NULL;\n  }\n  FOR_ALL_TABS(ttp) {\n    if (ttp->tp_prevwin == wp) {\n      ttp->tp_prevwin = NULL;\n    }\n  }\n\n  xfree(wp->w_lines);\n\n  for (i = 0; i < wp->w_tagstacklen; i++) {\n    xfree(wp->w_tagstack[i].tagname);\n    xfree(wp->w_tagstack[i].user_data);\n  }\n\n  xfree(wp->w_localdir);\n\n  /* Remove the window from the b_wininfo lists, it may happen that the\n   * freed memory is re-used for another window. */\n  FOR_ALL_BUFFERS(buf) {\n    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {\n      if (wip->wi_win == wp) {\n        wininfo_T *wip2;\n\n        // If there already is an entry with \"wi_win\" set to NULL it\n        // must be removed, it would never be used.\n        // Skip \"wip\" itself, otherwise Coverity complains.\n        for (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next) {\n          // `wip2 != wip` to satisfy Coverity. #14884\n          if (wip2 != wip && wip2->wi_win == NULL) {\n            if (wip2->wi_next != NULL) {\n              wip2->wi_next->wi_prev = wip2->wi_prev;\n            }\n            if (wip2->wi_prev == NULL) {\n              buf->b_wininfo = wip2->wi_next;\n            } else {\n              wip2->wi_prev->wi_next = wip2->wi_next;\n            }\n            free_wininfo(wip2, buf);\n            break;\n          }\n        }\n\n        wip->wi_win = NULL;\n      }\n    }\n  }\n\n  clear_matches(wp);\n\n  free_jumplist(wp);\n\n  qf_free_all(wp);\n\n  xfree(wp->w_p_cc_cols);\n\n  win_free_grid(wp, false);\n\n  if (wp != aucmd_win)\n    win_remove(wp, tp);\n  if (autocmd_busy) {\n    wp->w_next = au_pending_free_win;\n    au_pending_free_win = wp;\n  } else {\n    xfree(wp);\n  }\n\n  unblock_autocmds();\n}\n\nvoid win_free_grid(win_T *wp, bool reinit)\n{\n  if (wp->w_grid_alloc.handle != 0 && ui_has(kUIMultigrid)) {\n    ui_call_grid_destroy(wp->w_grid_alloc.handle);\n  }\n  grid_free(&wp->w_grid_alloc);\n  if (reinit) {\n    // if a float is turned into a split and back into a float, the grid\n    // data structure will be reused\n    memset(&wp->w_grid_alloc, 0, sizeof(wp->w_grid_alloc));\n  }\n}\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\nvoid win_append(win_T *after, win_T *wp)\n{\n  win_T       *before;\n\n  if (after == NULL)        /* after NULL is in front of the first */\n    before = firstwin;\n  else\n    before = after->w_next;\n\n  wp->w_next = before;\n  wp->w_prev = after;\n  if (after == NULL)\n    firstwin = wp;\n  else\n    after->w_next = wp;\n  if (before == NULL)\n    lastwin = wp;\n  else\n    before->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\nvoid \nwin_remove (\n    win_T *wp,\n    tabpage_T *tp                /* tab page \"win\" is in, NULL for current */\n)\n{\n  if (wp->w_prev != NULL) {\n    wp->w_prev->w_next = wp->w_next;\n  } else if (tp == NULL) {\n    firstwin = curtab->tp_firstwin = wp->w_next;\n  } else {\n    tp->tp_firstwin = wp->w_next;\n  }\n  if (wp->w_next != NULL) {\n    wp->w_next->w_prev = wp->w_prev;\n  } else if (tp == NULL) {\n    lastwin = curtab->tp_lastwin = wp->w_prev;\n  } else {\n    tp->tp_lastwin = wp->w_prev;\n  }\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\nstatic void frame_append(frame_T *after, frame_T *frp)\n{\n  frp->fr_next = after->fr_next;\n  after->fr_next = frp;\n  if (frp->fr_next != NULL)\n    frp->fr_next->fr_prev = frp;\n  frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\nstatic void frame_insert(frame_T *before, frame_T *frp)\n{\n  frp->fr_next = before;\n  frp->fr_prev = before->fr_prev;\n  before->fr_prev = frp;\n  if (frp->fr_prev != NULL)\n    frp->fr_prev->fr_next = frp;\n  else\n    frp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\nstatic void frame_remove(frame_T *frp)\n{\n  if (frp->fr_prev != NULL) {\n    frp->fr_prev->fr_next = frp->fr_next;\n  } else {\n    frp->fr_parent->fr_child = frp->fr_next;\n    // special case: topframe->fr_child == frp\n    if (topframe->fr_child == frp) {\n      topframe->fr_child = frp->fr_next;\n    }\n  }\n  if (frp->fr_next != NULL) {\n    frp->fr_next->fr_prev = frp->fr_prev;\n  }\n}\n\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\nvoid shell_new_rows(void)\n{\n  int h = (int)ROWS_AVAIL;\n\n  if (firstwin == NULL)         /* not initialized yet */\n    return;\n  if (h < frame_minheight(topframe, NULL))\n    h = frame_minheight(topframe, NULL);\n\n  /* First try setting the heights of windows with 'winfixheight'.  If\n   * that doesn't result in the right height, forget about that option. */\n  frame_new_height(topframe, h, false, true);\n  if (!frame_check_height(topframe, h)) {\n    frame_new_height(topframe, h, false, false);\n  }\n\n  (void)win_comp_pos();  // recompute w_winrow and w_wincol\n  win_reconfig_floats();  // The size of floats might change\n  compute_cmdrow();\n  curtab->tp_ch_used = p_ch;\n\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\nvoid shell_new_columns(void)\n{\n  if (firstwin == NULL)         /* not initialized yet */\n    return;\n\n  /* First try setting the widths of windows with 'winfixwidth'.  If that\n   * doesn't result in the right width, forget about that option. */\n  frame_new_width(topframe, Columns, false, true);\n  if (!frame_check_width(topframe, Columns)) {\n    frame_new_width(topframe, Columns, false, false);\n  }\n\n  (void)win_comp_pos();  // recompute w_winrow and w_wincol\n  win_reconfig_floats();  // The size of floats might change\n}\n\n/// Check if \"wp\" has scrolled since last time it was checked\n/// @param wp the window to check\nbool win_did_scroll(win_T *wp)\n{\n  return (curwin->w_last_topline != curwin->w_topline\n          || curwin->w_last_leftcol != curwin->w_leftcol\n          || curwin->w_last_width != curwin->w_width\n          || curwin->w_last_height != curwin->w_height);\n}\n\n/// Trigger WinScrolled autocmd\nvoid do_autocmd_winscrolled(win_T *wp)\n{\n  apply_autocmds(EVENT_WINSCROLLED, NULL, NULL, false, curbuf);\n\n  wp->w_last_topline = wp->w_topline;\n  wp->w_last_leftcol = wp->w_leftcol;\n  wp->w_last_width = wp->w_width;\n  wp->w_last_height = wp->w_height;\n}\n\n/*\n * Save the size of all windows in \"gap\".\n */\nvoid win_size_save(garray_T *gap)\n\n{\n  ga_init(gap, (int)sizeof(int), 1);\n  ga_grow(gap, win_count() * 2 + 1);\n  // first entry is value of 'lines'\n  ((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    ((int *)gap->ga_data)[gap->ga_len++] =\n      wp->w_width + wp->w_vsep_width;\n    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n  }\n}\n\n// Restore window sizes, but only if the number of windows is still the same\n// and 'lines' didn't change.\n// Does not free the growarray.\nvoid win_size_restore(garray_T *gap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (win_count() * 2 + 1 == gap->ga_len\n      && ((int *)gap->ga_data)[0] == Rows) {\n    // The order matters, because frames contain other frames, but it's\n    // difficult to get right. The easy way out is to do it twice.\n    for (int j = 0; j < 2; j++) {\n      int i = 1;\n      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n        int width = ((int *)gap->ga_data)[i++];\n        int height = ((int *)gap->ga_data)[i++];\n        if (!wp->w_floating) {\n          frame_setwidth(wp->w_frame, width);\n          win_setheight_win(height, wp);\n        }\n      }\n    }\n    /* recompute the window positions */\n    (void)win_comp_pos();\n  }\n}\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\nint win_comp_pos(void)\n{\n  int row = tabline_height();\n  int col = 0;\n\n  frame_comp_pos(topframe, &row, &col);\n\n  for (win_T *wp = lastwin; wp && wp->w_floating; wp = wp->w_prev) {\n    // float might be anchored to moved window\n    if (wp->w_float_config.relative == kFloatRelativeWindow) {\n      wp->w_pos_changed = true;\n    }\n  }\n\n  return row;\n}\n\nvoid win_reconfig_floats(void)\n{\n  for (win_T *wp = lastwin; wp && wp->w_floating; wp = wp->w_prev) {\n    win_config_float(wp, wp->w_float_config);\n  }\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n  win_T       *wp;\n  frame_T     *frp;\n  int startcol;\n  int startrow;\n\n  wp = topfrp->fr_win;\n  if (wp != NULL) {\n    if (wp->w_winrow != *row\n        || wp->w_wincol != *col\n        ) {\n      /* position changed, redraw */\n      wp->w_winrow = *row;\n      wp->w_wincol = *col;\n      redraw_later(wp, NOT_VALID);\n      wp->w_redr_status = true;\n      wp->w_pos_changed = true;\n    }\n    const int h = wp->w_height + wp->w_status_height;\n    *row += h > topfrp->fr_height ? topfrp->fr_height : h;\n    *col += wp->w_width + wp->w_vsep_width;\n  } else {\n    startrow = *row;\n    startcol = *col;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      if (topfrp->fr_layout == FR_ROW) {\n        *row = startrow;  // all frames are at the same row\n      } else {\n        *col = startcol;  // all frames are at the same col\n      }\n      frame_comp_pos(frp, row, col);\n    }\n  }\n}\n\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\nvoid win_setheight(int height)\n{\n  win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\nvoid win_setheight_win(int height, win_T *win)\n{\n  if (win == curwin) {\n    // Always keep current window at least one line high, even when\n    // 'winminheight' is zero.\n    if (height < p_wmh) {\n      height = p_wmh;\n    }\n    if (height == 0) {\n      height = 1;\n    }\n  }\n\n  if (win->w_floating) {\n    win->w_float_config.height = height;\n    win_config_float(win, win->w_float_config);\n    redraw_later(win, NOT_VALID);\n  } else {\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    int row = win_comp_pos();\n\n    // If there is extra space created between the last window and the command\n    // line, clear it.\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row) {\n      grid_fill(&default_grid, row, cmdline_row, 0, Columns, ' ', ' ', 0);\n    }\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n    redraw_all_later(NOT_VALID);\n  }\n\n}\n\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\nstatic void frame_setheight(frame_T *curfrp, int height)\n{\n  int room;                     /* total number of lines available */\n  int take;                     /* number of lines taken from other windows */\n  int room_cmdline;             /* lines available from cmdline */\n  int run;\n  frame_T     *frp;\n  int h;\n  int room_reserved;\n\n  /* If the height already is the desired value, nothing to do. */\n  if (curfrp->fr_height == height)\n    return;\n\n  if (curfrp->fr_parent == NULL) {\n    /* topframe: can only change the command line */\n    if (height > ROWS_AVAIL)\n      height = ROWS_AVAIL;\n    if (height > 0) {\n      frame_new_height(curfrp, height, false, false);\n    }\n  } else if (curfrp->fr_parent->fr_layout == FR_ROW) {\n    /* Row of frames: Also need to resize frames left and right of this\n     * one.  First check for the minimal height of these. */\n    h = frame_minheight(curfrp->fr_parent, NULL);\n    if (height < h)\n      height = h;\n    frame_setheight(curfrp->fr_parent, height);\n  } else {\n    /*\n     * Column of frames: try to change only frames in this column.\n     */\n    /*\n     * Do this twice:\n     * 1: compute room available, if it's not enough try resizing the\n     *    containing frame.\n     * 2: compute the room available and adjust the height to it.\n     * Try not to reduce the height of a window with 'winfixheight' set.\n     */\n    for (run = 1; run <= 2; ++run) {\n      room = 0;\n      room_reserved = 0;\n      FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child) {\n        if (frp != curfrp\n            && frp->fr_win != NULL\n            && frp->fr_win->w_p_wfh) {\n          room_reserved += frp->fr_height;\n        }\n        room += frp->fr_height;\n        if (frp != curfrp) {\n          room -= frame_minheight(frp, NULL);\n        }\n      }\n      if (curfrp->fr_width != Columns) {\n        room_cmdline = 0;\n      } else {\n        win_T *wp = lastwin_nofloating();\n        room_cmdline = Rows - p_ch\n          - (wp->w_winrow + wp->w_height + wp->w_status_height);\n        if (room_cmdline < 0) {\n          room_cmdline = 0;\n        }\n      }\n\n      if (height <= room + room_cmdline) {\n        break;\n      }\n      if (run == 2 || curfrp->fr_width == Columns) {\n        height = room + room_cmdline;\n        break;\n      }\n      frame_setheight(curfrp->fr_parent, height\n          + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n      /*NOTREACHED*/\n    }\n\n    /*\n     * Compute the number of lines we will take from others frames (can be\n     * negative!).\n     */\n    take = height - curfrp->fr_height;\n\n    /* If there is not enough room, also reduce the height of a window\n     * with 'winfixheight' set. */\n    if (height > room + room_cmdline - room_reserved)\n      room_reserved = room + room_cmdline - height;\n    /* If there is only a 'winfixheight' window and making the\n    * window smaller, need to make the other window taller. */\n    if (take < 0 && room - curfrp->fr_height < room_reserved)\n      room_reserved = 0;\n\n    if (take > 0 && room_cmdline > 0) {\n      /* use lines from cmdline first */\n      if (take < room_cmdline)\n        room_cmdline = take;\n      take -= room_cmdline;\n      topframe->fr_height += room_cmdline;\n    }\n\n    /*\n     * set the current frame to the new height\n     */\n    frame_new_height(curfrp, height, false, false);\n\n    /*\n     * First take lines from the frames after the current frame.  If\n     * that is not enough, takes lines from frames above the current\n     * frame.\n     */\n    for (run = 0; run < 2; ++run) {\n      if (run == 0)\n        frp = curfrp->fr_next;          /* 1st run: start with next window */\n      else\n        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */\n      while (frp != NULL && take != 0) {\n        h = frame_minheight(frp, NULL);\n        if (room_reserved > 0\n            && frp->fr_win != NULL\n            && frp->fr_win->w_p_wfh) {\n          if (room_reserved >= frp->fr_height)\n            room_reserved -= frp->fr_height;\n          else {\n            if (frp->fr_height - room_reserved > take)\n              room_reserved = frp->fr_height - take;\n            take -= frp->fr_height - room_reserved;\n            frame_new_height(frp, room_reserved, false, false);\n            room_reserved = 0;\n          }\n        } else {\n          if (frp->fr_height - take < h) {\n            take -= frp->fr_height - h;\n            frame_new_height(frp, h, false, false);\n          } else {\n            frame_new_height(frp, frp->fr_height - take, false, false);\n            take = 0;\n          }\n        }\n        if (run == 0)\n          frp = frp->fr_next;\n        else\n          frp = frp->fr_prev;\n      }\n    }\n  }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\nvoid win_setwidth(int width)\n{\n  win_setwidth_win(width, curwin);\n}\n\nvoid win_setwidth_win(int width, win_T *wp)\n{\n  /* Always keep current window at least one column wide, even when\n   * 'winminwidth' is zero. */\n  if (wp == curwin) {\n    if (width < p_wmw)\n      width = p_wmw;\n    if (width == 0)\n      width = 1;\n  } else if (width < 0) {\n    width = 0;\n  }\n  if (wp->w_floating) {\n    wp->w_float_config.width = width;\n    win_config_float(wp, wp->w_float_config);\n    redraw_later(wp, NOT_VALID);\n  } else {\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n  }\n\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\nstatic void frame_setwidth(frame_T *curfrp, int width)\n{\n  int room;                     /* total number of lines available */\n  int take;                     /* number of lines taken from other windows */\n  int run;\n  frame_T     *frp;\n  int w;\n  int room_reserved;\n\n  /* If the width already is the desired value, nothing to do. */\n  if (curfrp->fr_width == width)\n    return;\n\n  if (curfrp->fr_parent == NULL)\n    /* topframe: can't change width */\n    return;\n\n  if (curfrp->fr_parent->fr_layout == FR_COL) {\n    /* Column of frames: Also need to resize frames above and below of\n     * this one.  First check for the minimal width of these. */\n    w = frame_minwidth(curfrp->fr_parent, NULL);\n    if (width < w)\n      width = w;\n    frame_setwidth(curfrp->fr_parent, width);\n  } else {\n    /*\n     * Row of frames: try to change only frames in this row.\n     *\n     * Do this twice:\n     * 1: compute room available, if it's not enough try resizing the\n     *    containing frame.\n     * 2: compute the room available and adjust the width to it.\n     */\n    for (run = 1; run <= 2; ++run) {\n      room = 0;\n      room_reserved = 0;\n      FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child) {\n        if (frp != curfrp\n            && frp->fr_win != NULL\n            && frp->fr_win->w_p_wfw) {\n          room_reserved += frp->fr_width;\n        }\n        room += frp->fr_width;\n        if (frp != curfrp) {\n          room -= frame_minwidth(frp, NULL);\n        }\n      }\n\n      if (width <= room)\n        break;\n      if (run == 2 || curfrp->fr_height >= ROWS_AVAIL) {\n        width = room;\n        break;\n      }\n      frame_setwidth(curfrp->fr_parent, width\n          + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n    }\n\n    /*\n     * Compute the number of lines we will take from others frames (can be\n     * negative!).\n     */\n    take = width - curfrp->fr_width;\n\n    /* If there is not enough room, also reduce the width of a window\n     * with 'winfixwidth' set. */\n    if (width > room - room_reserved)\n      room_reserved = room - width;\n    /* If there is only a 'winfixwidth' window and making the\n     * window smaller, need to make the other window narrower. */\n    if (take < 0 && room - curfrp->fr_width < room_reserved)\n      room_reserved = 0;\n\n    /*\n     * set the current frame to the new width\n     */\n    frame_new_width(curfrp, width, false, false);\n\n    /*\n     * First take lines from the frames right of the current frame.  If\n     * that is not enough, takes lines from frames left of the current\n     * frame.\n     */\n    for (run = 0; run < 2; ++run) {\n      if (run == 0)\n        frp = curfrp->fr_next;          /* 1st run: start with next window */\n      else\n        frp = curfrp->fr_prev;          /* 2nd run: start with prev window */\n      while (frp != NULL && take != 0) {\n        w = frame_minwidth(frp, NULL);\n        if (room_reserved > 0\n            && frp->fr_win != NULL\n            && frp->fr_win->w_p_wfw) {\n          if (room_reserved >= frp->fr_width)\n            room_reserved -= frp->fr_width;\n          else {\n            if (frp->fr_width - room_reserved > take)\n              room_reserved = frp->fr_width - take;\n            take -= frp->fr_width - room_reserved;\n            frame_new_width(frp, room_reserved, false, false);\n            room_reserved = 0;\n          }\n        } else {\n          if (frp->fr_width - take < w) {\n            take -= frp->fr_width - w;\n            frame_new_width(frp, w, false, false);\n          } else {\n            frame_new_width(frp, frp->fr_width - take, false, false);\n            take = 0;\n          }\n        }\n        if (run == 0)\n          frp = frp->fr_next;\n        else\n          frp = frp->fr_prev;\n      }\n    }\n  }\n}\n\n// Check 'winminheight' for a valid value and reduce it if needed.\nvoid win_setminheight(void)\n{\n  bool first = true;\n\n  // loop until there is a 'winminheight' that is possible\n  while (p_wmh > 0) {\n    const int room = Rows - p_ch;\n    const int needed = min_rows() - 1;  // 1 was added for the cmdline\n    if (room >= needed) {\n      break;\n    }\n    p_wmh--;\n    if (first) {\n      EMSG(_(e_noroom));\n      first = false;\n    }\n  }\n}\n\n// Check 'winminwidth' for a valid value and reduce it if needed.\nvoid win_setminwidth(void)\n{\n  bool first = true;\n\n  // loop until there is a 'winminheight' that is possible\n  while (p_wmw > 0) {\n    const int room = Columns;\n    const int needed = frame_minwidth(topframe, NULL);\n    if (room >= needed) {\n      break;\n    }\n    p_wmw--;\n    if (first) {\n      EMSG(_(e_noroom));\n      first = false;\n    }\n  }\n}\n\n/// Status line of dragwin is dragged \"offset\" lines down (negative is up).\nvoid win_drag_status_line(win_T *dragwin, int offset)\n{\n  frame_T     *curfr;\n  frame_T     *fr;\n  int room;\n  int row;\n  bool up;                      // if true, drag status line up, otherwise down\n  int n;\n\n  fr = dragwin->w_frame;\n  curfr = fr;\n  if (fr != topframe) {         /* more than one window */\n    fr = fr->fr_parent;\n    /* When the parent frame is not a column of frames, its parent should\n     * be. */\n    if (fr->fr_layout != FR_COL) {\n      curfr = fr;\n      if (fr != topframe)       /* only a row of windows, may drag statusline */\n        fr = fr->fr_parent;\n    }\n  }\n\n  /* If this is the last frame in a column, may want to resize the parent\n   * frame instead (go two up to skip a row of frames). */\n  while (curfr != topframe && curfr->fr_next == NULL) {\n    if (fr != topframe)\n      fr = fr->fr_parent;\n    curfr = fr;\n    if (fr != topframe)\n      fr = fr->fr_parent;\n  }\n\n  if (offset < 0) {  // drag up\n    up = true;\n    offset = -offset;\n    /* sum up the room of the current frame and above it */\n    if (fr == curfr) {\n      /* only one window */\n      room = fr->fr_height - frame_minheight(fr, NULL);\n    } else {\n      room = 0;\n      for (fr = fr->fr_child;; fr = fr->fr_next) {\n        room += fr->fr_height - frame_minheight(fr, NULL);\n        if (fr == curfr)\n          break;\n      }\n    }\n    fr = curfr->fr_next;                // put fr at frame that grows\n  } else {  // drag down\n    up = false;\n    // Only dragging the last status line can reduce p_ch.\n    room = Rows - cmdline_row;\n    if (curfr->fr_next == NULL)\n      room -= 1;\n    else\n      room -= p_ch;\n    if (room < 0)\n      room = 0;\n    // sum up the room of frames below of the current one\n    FOR_ALL_FRAMES(fr, curfr->fr_next) {\n      room += fr->fr_height - frame_minheight(fr, NULL);\n    }\n    fr = curfr;  // put fr at window that grows\n  }\n\n  if (room < offset)            /* Not enough room */\n    offset = room;              /* Move as far as we can */\n  if (offset <= 0)\n    return;\n\n  /*\n   * Grow frame fr by \"offset\" lines.\n   * Doesn't happen when dragging the last status line up.\n   */\n  if (fr != NULL) {\n    frame_new_height(fr, fr->fr_height + offset, up, false);\n  }\n\n  if (up)\n    fr = curfr;                 /* current frame gets smaller */\n  else\n    fr = curfr->fr_next;        /* next frame gets smaller */\n\n  /*\n   * Now make the other frames smaller.\n   */\n  while (fr != NULL && offset > 0) {\n    n = frame_minheight(fr, NULL);\n    if (fr->fr_height - offset <= n) {\n      offset -= fr->fr_height - n;\n      frame_new_height(fr, n, !up, false);\n    } else {\n      frame_new_height(fr, fr->fr_height - offset, !up, false);\n      break;\n    }\n    if (up)\n      fr = fr->fr_prev;\n    else\n      fr = fr->fr_next;\n  }\n  row = win_comp_pos();\n  grid_fill(&default_grid, row, cmdline_row, 0, Columns, ' ', ' ', 0);\n  if (msg_grid.chars) {\n    clear_cmdline = true;\n  }\n  cmdline_row = row;\n  p_ch = Rows - cmdline_row;\n  if (p_ch < 1)\n    p_ch = 1;\n  curtab->tp_ch_used = p_ch;\n  redraw_all_later(SOME_VALID);\n  showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\nvoid win_drag_vsep_line(win_T *dragwin, int offset)\n{\n  frame_T     *curfr;\n  frame_T     *fr;\n  int room;\n  bool left;             // if true, drag separator line left, otherwise right\n  int n;\n\n  fr = dragwin->w_frame;\n  if (fr == topframe)           /* only one window (cannot happen?) */\n    return;\n  curfr = fr;\n  fr = fr->fr_parent;\n  /* When the parent frame is not a row of frames, its parent should be. */\n  if (fr->fr_layout != FR_ROW) {\n    if (fr == topframe)         /* only a column of windows (cannot happen?) */\n      return;\n    curfr = fr;\n    fr = fr->fr_parent;\n  }\n\n  /* If this is the last frame in a row, may want to resize a parent\n   * frame instead. */\n  while (curfr->fr_next == NULL) {\n    if (fr == topframe)\n      break;\n    curfr = fr;\n    fr = fr->fr_parent;\n    if (fr != topframe) {\n      curfr = fr;\n      fr = fr->fr_parent;\n    }\n  }\n\n  if (offset < 0) {  // drag left\n    left = true;\n    offset = -offset;\n    /* sum up the room of the current frame and left of it */\n    room = 0;\n    for (fr = fr->fr_child;; fr = fr->fr_next) {\n      room += fr->fr_width - frame_minwidth(fr, NULL);\n      if (fr == curfr)\n        break;\n    }\n    fr = curfr->fr_next;                // put fr at frame that grows\n  } else {  // drag right\n    left = false;\n    // sum up the room of frames right of the current one\n    room = 0;\n    FOR_ALL_FRAMES(fr, curfr->fr_next) {\n      room += fr->fr_width - frame_minwidth(fr, NULL);\n    }\n    fr = curfr;  // put fr at window that grows\n  }\n  assert(fr);\n\n  // Not enough room\n  if (room < offset) {\n    offset = room;  // Move as far as we can\n  }\n\n  // No room at all, quit.\n  if (offset <= 0) {\n    return;\n  }\n\n  if (fr == NULL) {\n    return;  // Safety check, should not happen.\n  }\n\n  // grow frame fr by offset lines\n  frame_new_width(fr, fr->fr_width + offset, left, false);\n\n  /* shrink other frames: current and at the left or at the right */\n  if (left)\n    fr = curfr;                 /* current frame gets smaller */\n  else\n    fr = curfr->fr_next;        /* next frame gets smaller */\n\n  while (fr != NULL && offset > 0) {\n    n = frame_minwidth(fr, NULL);\n    if (fr->fr_width - offset <= n) {\n      offset -= fr->fr_width - n;\n      frame_new_width(fr, n, !left, false);\n    } else {\n      frame_new_width(fr, fr->fr_width - offset, !left, false);\n      break;\n    }\n    if (left)\n      fr = fr->fr_prev;\n    else\n      fr = fr->fr_next;\n  }\n  (void)win_comp_pos();\n  redraw_all_later(NOT_VALID);\n}\n\n\n#define FRACTION_MULT   16384L\n\n// Set wp->w_fraction for the current w_wrow and w_height.\n// Has no effect when the window is less than two lines.\nvoid set_fraction(win_T *wp)\n{\n  if (wp->w_height_inner > 1) {\n    // When cursor is in the first line the percentage is computed as if\n    // it's halfway that line.  Thus with two lines it is 25%, with three\n    // lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n    wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT + FRACTION_MULT / 2)\n                   / (long)wp->w_height_inner;\n  }\n}\n\n// Set the height of a window.\n// \"height\" excludes any window toolbar.\n// This takes care of the things inside the window, not what happens to the\n// window position, the frame or to other windows.\nvoid win_new_height(win_T *wp, int height)\n{\n  // Don't want a negative height.  Happens when splitting a tiny window.\n  // Will equalize heights soon to fix it.\n  if (height < 0) {\n    height = 0;\n  }\n  if (wp->w_height == height) {\n    return;  // nothing to do\n  }\n\n  wp->w_height = height;\n  wp->w_pos_changed = true;\n  win_set_inner_size(wp);\n}\n\nvoid scroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T lnum;\n    int sline, line_size;\n    int height = wp->w_height_inner;\n\n  // Don't change w_topline in any of these cases:\n  // - window height is 0\n  // - 'scrollbind' is set and this isn't the current window\n  // - window height is sufficient to display the whole buffer and first line\n  //   is visible.\n  if (height > 0\n      && (!wp->w_p_scb || wp == curwin)\n      && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1)\n      ) {\n    /*\n     * Find a value for w_topline that shows the cursor at the same\n     * relative position in the window as before (more or less).\n     */\n    lnum = wp->w_cursor.lnum;\n    if (lnum < 1)               /* can happen when starting up */\n      lnum = 1;\n    wp->w_wrow = ((long)wp->w_fraction * (long)height - 1L) / FRACTION_MULT;\n    line_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n    sline = wp->w_wrow - line_size;\n\n    if (sline >= 0) {\n      // Make sure the whole cursor line is visible, if possible.\n      const int rows = plines_win(wp, lnum, false);\n\n      if (sline > wp->w_height_inner - rows) {\n        sline = wp->w_height_inner - rows;\n        wp->w_wrow -= rows - line_size;\n      }\n    }\n\n    if (sline < 0) {\n      /*\n       * Cursor line would go off top of screen if w_wrow was this high.\n       * Make cursor line the first line in the window.  If not enough\n       * room use w_skipcol;\n       */\n      wp->w_wrow = line_size;\n      if (wp->w_wrow >= wp->w_height_inner\n          && (wp->w_width_inner - win_col_off(wp)) > 0) {\n        wp->w_skipcol += wp->w_width_inner - win_col_off(wp);\n        wp->w_wrow--;\n        while (wp->w_wrow >= wp->w_height_inner) {\n          wp->w_skipcol += wp->w_width_inner - win_col_off(wp)\n                           + win_col_off2(wp);\n          wp->w_wrow--;\n        }\n      }\n    } else if (sline > 0) {\n      while (sline > 0 && lnum > 1) {\n        (void)hasFoldingWin(wp, lnum, &lnum, NULL, true, NULL);\n        if (lnum == 1) {\n          /* first line in buffer is folded */\n          line_size = 1;\n          --sline;\n          break;\n        }\n        lnum--;\n        if (lnum == wp->w_topline) {\n          line_size = plines_win_nofill(wp, lnum, true)\n                      + wp->w_topfill;\n        } else {\n          line_size = plines_win(wp, lnum, true);\n        }\n        sline -= line_size;\n      }\n\n      if (sline < 0) {\n        /*\n         * Line we want at top would go off top of screen.  Use next\n         * line instead.\n         */\n        (void)hasFoldingWin(wp, lnum, NULL, &lnum, true, NULL);\n        lnum++;\n        wp->w_wrow -= line_size + sline;\n      } else if (sline > 0) {\n        // First line of file reached, use that as topline.\n        lnum = 1;\n        wp->w_wrow -= sline;\n      }\n    }\n    set_topline(wp, lnum);\n  }\n\n  if (wp == curwin) {\n    if (get_scrolloff_value(wp)) {\n      update_topline(wp);\n    }\n    curs_columns(wp, false);        // validate w_wrow\n  }\n  if (prev_height > 0) {\n    wp->w_prev_fraction_row = wp->w_wrow;\n  }\n\n  win_comp_scroll(wp);\n  redraw_later(wp, SOME_VALID);\n  wp->w_redr_status = true;\n  invalidate_botline_win(wp);\n}\n\nvoid win_set_inner_size(win_T *wp)\n{\n  int width = wp->w_width_request;\n  if (width == 0) {\n    width = wp->w_width;\n  }\n\n  int prev_height = wp->w_height_inner;\n  int height = wp->w_height_request;\n  if (height == 0) {\n    height = wp->w_height;\n  }\n\n  if (height != prev_height) {\n    if (height > 0) {\n      if (wp == curwin) {\n        // w_wrow needs to be valid. When setting 'laststatus' this may\n        // call win_new_height() recursively.\n        validate_cursor();\n      }\n      if (wp->w_height_inner != prev_height) {  // -V547\n        return;  // Recursive call already changed the size, bail out.\n      }\n      if (wp->w_wrow != wp->w_prev_fraction_row) {\n        set_fraction(wp);\n      }\n    }\n    wp->w_height_inner = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting) {\n      scroll_to_fraction(wp, prev_height);\n    }\n    redraw_later(wp, NOT_VALID);  // SOME_VALID??\n  }\n\n  if (width != wp->w_width_inner) {\n    wp->w_width_inner = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin) {\n      update_topline(wp);\n      curs_columns(wp, true);  // validate w_wrow\n    }\n    redraw_later(wp, NOT_VALID);\n  }\n\n  if (wp->w_buffer->terminal) {\n    terminal_check_size(wp->w_buffer->terminal);\n  }\n\n  wp->w_height_outer = (wp->w_height_inner\n                        + wp->w_border_adj[0] + wp->w_border_adj[2]);\n  wp->w_width_outer = (wp->w_width_inner\n                       + wp->w_border_adj[1] + wp->w_border_adj[3]);\n}\n\n/// Set the width of a window.\nvoid win_new_width(win_T *wp, int width)\n{\n  wp->w_width = width;\n  win_set_inner_size(wp);\n\n  wp->w_redr_status = true;\n  wp->w_pos_changed = true;\n}\n\nvoid win_comp_scroll(win_T *wp)\n{\n  const long old_w_p_scr = wp->w_p_scr;\n\n  wp->w_p_scr = wp->w_height / 2;\n  if (wp->w_p_scr == 0) {\n    wp->w_p_scr = 1;\n  }\n  if (wp->w_p_scr != old_w_p_scr) {\n    // Used by \"verbose set scroll\".\n    wp->w_p_script_ctx[WV_SCROLL].script_ctx.sc_sid = SID_WINLAYOUT;\n    wp->w_p_script_ctx[WV_SCROLL].script_ctx.sc_lnum = 0;\n  }\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\nvoid command_height(void)\n{\n  int h;\n  frame_T     *frp;\n  int old_p_ch = curtab->tp_ch_used;\n\n  /* Use the value of p_ch that we remembered.  This is needed for when the\n   * GUI starts up, we can't be sure in what order things happen.  And when\n   * p_ch was changed in another tab page. */\n  curtab->tp_ch_used = p_ch;\n\n  // Find bottom frame with width of screen.\n  frp = lastwin_nofloating()->w_frame;\n  while (frp->fr_width != Columns && frp->fr_parent != NULL) {\n    frp = frp->fr_parent;\n  }\n\n  /* Avoid changing the height of a window with 'winfixheight' set. */\n  while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n         && frp->fr_win->w_p_wfh)\n    frp = frp->fr_prev;\n\n  if (starting != NO_SCREEN) {\n    cmdline_row = Rows - p_ch;\n\n    if (p_ch > old_p_ch) {                  /* p_ch got bigger */\n      while (p_ch > old_p_ch) {\n        if (frp == NULL) {\n          EMSG(_(e_noroom));\n          p_ch = old_p_ch;\n          curtab->tp_ch_used = p_ch;\n          cmdline_row = Rows - p_ch;\n          break;\n        }\n        h = frp->fr_height - frame_minheight(frp, NULL);\n        if (h > p_ch - old_p_ch)\n          h = p_ch - old_p_ch;\n        old_p_ch += h;\n        frame_add_height(frp, -h);\n        frp = frp->fr_prev;\n      }\n\n      /* Recompute window positions. */\n      (void)win_comp_pos();\n\n      // clear the lines added to cmdline\n      if (full_screen) {\n        grid_fill(&default_grid, cmdline_row, Rows, 0, Columns, ' ', ' ', 0);\n      }\n      msg_row = cmdline_row;\n      redraw_cmdline = true;\n      return;\n    }\n\n    if (msg_row < cmdline_row)\n      msg_row = cmdline_row;\n    redraw_cmdline = true;\n  }\n  frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n  /* Recompute window positions. */\n  if (frp != lastwin->w_frame)\n    (void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\nstatic void frame_add_height(frame_T *frp, int n)\n{\n  frame_new_height(frp, frp->fr_height + n, false, false);\n  for (;; ) {\n    frp = frp->fr_parent;\n    if (frp == NULL)\n      break;\n    frp->fr_height += n;\n  }\n}\n\n/*\n * Get the file name at the cursor.\n * If Visual mode is active, use the selected text if it's in one line.\n * Returns the name in allocated memory, NULL for failure.\n */\nchar_u *grab_file_name(long count, linenr_T *file_lnum)\n{\n  int options = FNAME_MESS | FNAME_EXP | FNAME_REL | FNAME_UNESC;\n  if (VIsual_active) {\n    size_t len;\n    char_u  *ptr;\n    if (get_visual_text(NULL, &ptr, &len) == FAIL)\n      return NULL;\n    // Only recognize \":123\" here\n    if (file_lnum != NULL && ptr[len] == ':' && isdigit(ptr[len + 1])) {\n      char_u *p = ptr + len + 1;\n\n      *file_lnum = getdigits_long(&p, false, 0);\n    }\n    return find_file_name_in_path(ptr, len, options, count, curbuf->b_ffname);\n  }\n  return file_name_at_cursor(options | FNAME_HYP, count, file_lnum);\n}\n\n/*\n * Return the file name under or after the cursor.\n *\n * The 'path' option is searched if the file name is not absolute.\n * The string returned has been alloc'ed and should be freed by the caller.\n * NULL is returned if the file name or file is not found.\n *\n * options:\n * FNAME_MESS\t    give error messages\n * FNAME_EXP\t    expand to path\n * FNAME_HYP\t    check for hypertext link\n * FNAME_INCL\t    apply \"includeexpr\"\n */\nchar_u *file_name_at_cursor(int options, long count, linenr_T *file_lnum)\n{\n  return file_name_in_line(get_cursor_line_ptr(),\n      curwin->w_cursor.col, options, count, curbuf->b_ffname,\n      file_lnum);\n}\n\n/*\n * Return the name of the file under or after ptr[col].\n * Otherwise like file_name_at_cursor().\n */\nchar_u *\nfile_name_in_line (\n    char_u *line,\n    int col,\n    int options,\n    long count,\n    char_u *rel_fname,         /* file we are searching relative to */\n    linenr_T *file_lnum         /* line number after the file name */\n)\n{\n  char_u      *ptr;\n  size_t len;\n  bool in_type = true;\n  bool is_url = false;\n\n  /*\n   * search forward for what could be the start of a file name\n   */\n  ptr = line + col;\n  while (*ptr != NUL && !vim_isfilec(*ptr)) {\n    MB_PTR_ADV(ptr);\n  }\n  if (*ptr == NUL) {            // nothing found\n    if (options & FNAME_MESS) {\n      EMSG(_(\"E446: No file name under cursor\"));\n    }\n    return NULL;\n  }\n\n  /*\n   * Search backward for first char of the file name.\n   * Go one char back to \":\" before \"//\" even when ':' is not in 'isfname'.\n   */\n  while (ptr > line) {\n    if ((len = (size_t)(utf_head_off(line, ptr - 1))) > 0) {\n      ptr -= len + 1;\n    } else if (vim_isfilec(ptr[-1])\n               || ((options & FNAME_HYP) && path_is_url((char *)ptr - 1))) {\n      ptr--;\n    } else {\n      break;\n    }\n  }\n\n  /*\n   * Search forward for the last char of the file name.\n   * Also allow \"://\" when ':' is not in 'isfname'.\n   */\n  len = 0;\n  while (vim_isfilec(ptr[len]) || (ptr[len] == '\\\\' && ptr[len + 1] == ' ')\n         || ((options & FNAME_HYP) && path_is_url((char *)ptr + len))\n         || (is_url && vim_strchr((char_u *)\":?&=\", ptr[len]) != NULL)) {\n    // After type:// we also include :, ?, & and = as valid characters, so that\n    // http://google.com:8080?q=this&that=ok works.\n    if ((ptr[len] >= 'A' && ptr[len] <= 'Z')\n        || (ptr[len] >= 'a' && ptr[len] <= 'z')) {\n      if (in_type && path_is_url((char *)ptr + len + 1)) {\n        is_url = true;\n      }\n    } else {\n      in_type = false;\n    }\n\n    if (ptr[len] == '\\\\' && ptr[len + 1] == ' ') {\n      // Skip over the \"\\\" in \"\\ \".\n      ++len;\n    }\n    len += (size_t)(utfc_ptr2len(ptr + len));\n  }\n\n  /*\n   * If there is trailing punctuation, remove it.\n   * But don't remove \"..\", could be a directory name.\n   */\n  if (len > 2 && vim_strchr((char_u *)\".,:;!\", ptr[len - 1]) != NULL\n      && ptr[len - 2] != '.')\n    --len;\n\n  if (file_lnum != NULL) {\n    char_u *p;\n    const char *line_english = \" line \";\n    const char *line_transl = _(line_msg);\n\n    // Get the number after the file name and a separator character.\n    // Also accept \" line 999\" with and without the same translation as\n    // used in last_set_msg().\n    p = ptr + len;\n    if (STRNCMP(p, line_english, STRLEN(line_english)) == 0) {\n      p += STRLEN(line_english);\n    } else if (STRNCMP(p, line_transl, STRLEN(line_transl)) == 0) {\n      p += STRLEN(line_transl);\n    } else {\n      p = skipwhite(p);\n    }\n    if (*p != NUL) {\n      if (!isdigit(*p)) {\n        p++;                        // skip the separator\n      }\n      p = skipwhite(p);\n      if (isdigit(*p)) {\n        *file_lnum = getdigits_long(&p, false, 0);\n      }\n    }\n  }\n\n  return find_file_name_in_path(ptr, len, options, count, rel_fname);\n}\n\n/// Add or remove a status line for the bottom window(s), according to the\n/// value of 'laststatus'.\n///\n/// @param morewin  pretend there are two or more windows if true.\nvoid last_status(bool morewin)\n{\n  /* Don't make a difference between horizontal or vertical split. */\n  last_status_rec(topframe, (p_ls == 2\n                             || (p_ls == 1 && (morewin || !one_window()))));\n}\n\nstatic void last_status_rec(frame_T *fr, bool statusline)\n{\n  frame_T     *fp;\n  win_T       *wp;\n\n  if (fr->fr_layout == FR_LEAF) {\n    wp = fr->fr_win;\n    if (wp->w_status_height != 0 && !statusline) {\n      /* remove status line */\n      win_new_height(wp, wp->w_height + 1);\n      wp->w_status_height = 0;\n      comp_col();\n    } else if (wp->w_status_height == 0 && statusline) {\n      /* Find a frame to take a line from. */\n      fp = fr;\n      while (fp->fr_height <= frame_minheight(fp, NULL)) {\n        if (fp == topframe) {\n          EMSG(_(e_noroom));\n          return;\n        }\n        /* In a column of frames: go to frame above.  If already at\n         * the top or in a row of frames: go to parent. */\n        if (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n          fp = fp->fr_prev;\n        else\n          fp = fp->fr_parent;\n      }\n      wp->w_status_height = 1;\n      if (fp != fr) {\n        frame_new_height(fp, fp->fr_height - 1, false, false);\n        frame_fix_height(wp);\n        (void)win_comp_pos();\n      } else\n        win_new_height(wp, wp->w_height - 1);\n      comp_col();\n      redraw_all_later(SOME_VALID);\n    }\n  } else if (fr->fr_layout == FR_ROW) {\n    // vertically split windows, set status line for each one\n    FOR_ALL_FRAMES(fp, fr->fr_child) {\n      last_status_rec(fp, statusline);\n    }\n  } else {\n    /* horizontally split window, set status line for last one */\n    for (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n      ;\n    last_status_rec(fp, statusline);\n  }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\nint tabline_height(void)\n{\n  if (ui_has(kUITabline)) {\n    return 0;\n  }\n  assert(first_tabpage);\n  switch (p_stal) {\n  case 0: return 0;\n  case 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n  }\n  return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\nint min_rows(void)\n{\n  if (firstwin == NULL)         /* not initialized yet */\n    return MIN_LINES;\n\n  int total = 0;\n  FOR_ALL_TABS(tp) {\n    int n = frame_minheight(tp->tp_topframe, NULL);\n    if (total < n) {\n      total = n;\n    }\n  }\n  total += tabline_height();\n  total += 1;           /* count the room for the command line */\n  return total;\n}\n\n/// Check that there is only one window (and only one tab page), not counting a\n/// help or preview window, unless it is the current window. Does not count\n/// \"aucmd_win\". Does not count floats unless it is current.\nbool only_one_window(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // If there is another tab page there always is another window.\n  if (first_tabpage->tp_next != NULL) {\n    return false;\n  }\n\n  int count = 0;\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_buffer != NULL\n        && (!((bt_help(wp->w_buffer) && !bt_help(curbuf)) || wp->w_floating\n              || wp->w_p_pvw) || wp == curwin) && wp != aucmd_win) {\n      count++;\n    }\n  }\n  return count <= 1;\n}\n\n/// Correct the cursor line number in other windows.  Used after changing the\n/// current buffer, and before applying autocommands.\n///\n/// @param do_curwin  when true, also check current window.\nvoid check_lnums(bool do_curwin)\n{\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if ((do_curwin || wp != curwin) && wp->w_buffer == curbuf) {\n      // save the original cursor position and topline\n      wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n      wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n      if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count) {\n        wp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n      }\n      if (wp->w_topline > curbuf->b_ml.ml_line_count) {\n        wp->w_topline = curbuf->b_ml.ml_line_count;\n      }\n\n      // save the corrected cursor position and topline\n      wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n      wp->w_save_cursor.w_topline_corr = wp->w_topline;\n    }\n  }\n}\n\n/// Reset cursor and topline to its stored values from check_lnums().\n/// check_lnums() must have been called first!\nvoid reset_lnums(void)\n{\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_buffer == curbuf) {\n      // Restore the value if the autocommand didn't change it.\n      if (equalpos(wp->w_save_cursor.w_cursor_corr, wp->w_cursor)) {\n        wp->w_cursor = wp->w_save_cursor.w_cursor_save;\n      }\n      if (wp->w_save_cursor.w_topline_corr == wp->w_topline) {\n        wp->w_topline = wp->w_save_cursor.w_topline_save;\n      }\n    }\n  }\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\nvoid make_snapshot(int idx)\n{\n  clear_snapshot(curtab, idx);\n  make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n  *frp = xcalloc(1, sizeof(frame_T));\n  (*frp)->fr_layout = fr->fr_layout;\n  (*frp)->fr_width = fr->fr_width;\n  (*frp)->fr_height = fr->fr_height;\n  if (fr->fr_next != NULL)\n    make_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n  if (fr->fr_child != NULL)\n    make_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n  if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n    (*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\nstatic void clear_snapshot(tabpage_T *tp, int idx)\n{\n  clear_snapshot_rec(tp->tp_snapshot[idx]);\n  tp->tp_snapshot[idx] = NULL;\n}\n\nstatic void clear_snapshot_rec(frame_T *fr)\n{\n  if (fr != NULL) {\n    clear_snapshot_rec(fr->fr_next);\n    clear_snapshot_rec(fr->fr_child);\n    xfree(fr);\n  }\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\nvoid \nrestore_snapshot (\n    int idx,\n    int close_curwin                   /* closing current window */\n)\n{\n  win_T       *wp;\n\n  if (curtab->tp_snapshot[idx] != NULL\n      && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n      && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n      && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK) {\n    wp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n    (void)win_comp_pos();\n    if (wp != NULL && close_curwin) {\n      win_goto(wp);\n    }\n    redraw_all_later(NOT_VALID);\n  }\n  clear_snapshot(curtab, idx);\n}\n\n/// Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n/// and same children.  And the window pointer is valid.\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n  if (sn->fr_layout != fr->fr_layout\n      || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n      || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n      || (sn->fr_next != NULL\n          && check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n      || (sn->fr_child != NULL\n          && check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n      || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n    return FAIL;\n  return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n  win_T       *wp = NULL;\n  win_T       *wp2;\n\n  fr->fr_height = sn->fr_height;\n  fr->fr_width = sn->fr_width;\n  if (fr->fr_layout == FR_LEAF) {\n    frame_new_height(fr, fr->fr_height, false, false);\n    frame_new_width(fr, fr->fr_width, false, false);\n    wp = sn->fr_win;\n  }\n  if (sn->fr_next != NULL) {\n    wp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n    if (wp2 != NULL)\n      wp = wp2;\n  }\n  if (sn->fr_child != NULL) {\n    wp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n    if (wp2 != NULL)\n      wp = wp2;\n  }\n  return wp;\n}\n\n/// Gets the focused window (the one holding the cursor) of the snapshot.\nstatic win_T *get_snapshot_focus(int idx)\n{\n  if (curtab->tp_snapshot[idx] == NULL) {\n    return NULL;\n  }\n\n  frame_T *sn = curtab->tp_snapshot[idx];\n  // This should be equivalent to the recursive algorithm found in\n  // restore_snapshot as far as traveling nodes go.\n  while (sn->fr_child != NULL || sn->fr_next != NULL) {\n    while (sn->fr_child != NULL) {\n      sn = sn->fr_child;\n    }\n    if (sn->fr_next != NULL) {\n      sn = sn->fr_next;\n    }\n  }\n\n  return win_valid(sn->fr_win) ? sn->fr_win : NULL;\n}\n\n/// Set \"win\" to be the curwin and \"tp\" to be the current tab page.\n/// restore_win() MUST be called to undo, also when FAIL is returned.\n/// No autocommands will be executed until restore_win() is called.\n///\n/// @param no_display  if true the display won't be affected, no redraw is\n///                    triggered, another tabpage access is limited.\n///\n/// @return FAIL if switching to \"win\" failed.\nint switch_win(win_T **save_curwin, tabpage_T **save_curtab, win_T *win,\n               tabpage_T *tp, bool no_display)\n{\n  block_autocmds();\n  return switch_win_noblock(save_curwin, save_curtab, win, tp, no_display);\n}\n\n// As switch_win() but without blocking autocommands.\nint switch_win_noblock(win_T **save_curwin, tabpage_T **save_curtab,\n                       win_T *win, tabpage_T *tp, bool no_display)\n{\n  *save_curwin = curwin;\n  if (tp != NULL) {\n    *save_curtab = curtab;\n    if (no_display) {\n      curtab->tp_firstwin = firstwin;\n      curtab->tp_lastwin = lastwin;\n      curtab = tp;\n      firstwin = curtab->tp_firstwin;\n      lastwin = curtab->tp_lastwin;\n    } else {\n      goto_tabpage_tp(tp, false, false);\n    }\n  }\n  if (!win_valid(win)) {\n    return FAIL;\n  }\n  curwin = win;\n  curbuf = curwin->w_buffer;\n  return OK;\n}\n\n// Restore current tabpage and window saved by switch_win(), if still valid.\n// When \"no_display\" is true the display won't be affected, no redraw is\n// triggered.\nvoid restore_win(win_T *save_curwin, tabpage_T *save_curtab, bool no_display)\n{\n  restore_win_noblock(save_curwin, save_curtab, no_display);\n  unblock_autocmds();\n}\n\n// As restore_win() but without unblocking autocommands.\nvoid restore_win_noblock(win_T *save_curwin, tabpage_T *save_curtab,\n                         bool no_display)\n{\n  if (save_curtab != NULL && valid_tabpage(save_curtab)) {\n    if (no_display) {\n      curtab->tp_firstwin = firstwin;\n      curtab->tp_lastwin = lastwin;\n      curtab = save_curtab;\n      firstwin = curtab->tp_firstwin;\n      lastwin = curtab->tp_lastwin;\n    } else {\n      goto_tabpage_tp(save_curtab, false, false);\n    }\n  }\n  if (win_valid(save_curwin)) {\n    curwin = save_curwin;\n    curbuf = curwin->w_buffer;\n  }\n}\n\n/// Make \"buf\" the current buffer.\n///\n/// restore_buffer() MUST be called to undo.\n/// No autocommands will be executed. Use aucmd_prepbuf() if there are any.\nvoid switch_buffer(bufref_T *save_curbuf, buf_T *buf)\n{\n  block_autocmds();\n  set_bufref(save_curbuf, curbuf);\n  curbuf->b_nwindows--;\n  curbuf = buf;\n  curwin->w_buffer = buf;\n  curbuf->b_nwindows++;\n}\n\n/// Restore the current buffer after using switch_buffer().\nvoid restore_buffer(bufref_T *save_curbuf)\n{\n  unblock_autocmds();\n  // Check for valid buffer, just in case.\n  if (bufref_valid(save_curbuf)) {\n    curbuf->b_nwindows--;\n    curwin->w_buffer = save_curbuf->br_buf;\n    curbuf = save_curbuf->br_buf;\n    curbuf->b_nwindows++;\n  }\n}\n\n\n/// Add match to the match list of window 'wp'.  The pattern 'pat' will be\n/// highlighted with the group 'grp' with priority 'prio'.\n/// Optionally, a desired ID 'id' can be specified (greater than or equal to 1).\n///\n/// @param[in] id a desired ID 'id' can be specified\n///               (greater than or equal to 1). -1 must be specified if no\n///               particular ID is desired\n/// @param[in] conceal_char pointer to conceal replacement char\n/// @return ID of added match, -1 on failure.\nint match_add(win_T *wp, const char *const grp, const char *const pat,\n              int prio, int id, list_T *pos_list,\n              const char *const conceal_char)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  matchitem_T *cur;\n  matchitem_T *prev;\n  matchitem_T *m;\n  int hlg_id;\n  regprog_T   *regprog = NULL;\n  int rtype = SOME_VALID;\n\n  if (*grp == NUL || (pat != NULL && *pat == NUL)) {\n    return -1;\n  }\n  if (id < -1 || id == 0) {\n    EMSGN(_(\"E799: Invalid ID: %\" PRId64\n            \" (must be greater than or equal to 1)\"),\n          id);\n    return -1;\n  }\n  if (id != -1) {\n    cur = wp->w_match_head;\n    while (cur != NULL) {\n      if (cur->id == id) {\n        EMSGN(_(\"E801: ID already taken: %\" PRId64), id);\n        return -1;\n      }\n      cur = cur->next;\n    }\n  }\n  if ((hlg_id = syn_check_group((const char_u *)grp, strlen(grp))) == 0) {\n    return -1;\n  }\n  if (pat != NULL && (regprog = vim_regcomp((char_u *)pat, RE_MAGIC)) == NULL) {\n    EMSG2(_(e_invarg2), pat);\n    return -1;\n  }\n\n  // Find available match ID.\n  while (id == -1) {\n    cur = wp->w_match_head;\n    while (cur != NULL && cur->id != wp->w_next_match_id)\n      cur = cur->next;\n    if (cur == NULL)\n      id = wp->w_next_match_id;\n    wp->w_next_match_id++;\n  }\n\n  // Build new match.\n  m = xcalloc(1, sizeof(matchitem_T));\n  m->id = id;\n  m->priority = prio;\n  m->pattern = pat == NULL ? NULL: (char_u *)xstrdup(pat);\n  m->hlg_id = hlg_id;\n  m->match.regprog = regprog;\n  m->match.rmm_ic = FALSE;\n  m->match.rmm_maxcol = 0;\n  m->conceal_char = 0;\n  if (conceal_char != NULL) {\n    m->conceal_char = utf_ptr2char((const char_u *)conceal_char);\n  }\n\n  // Set up position matches\n  if (pos_list != NULL) {\n    linenr_T toplnum = 0;\n    linenr_T botlnum = 0;\n\n    int i = 0;\n    TV_LIST_ITER(pos_list, li, {\n      linenr_T lnum = 0;\n      colnr_T col = 0;\n      int len = 1;\n      bool error = false;\n\n      if (TV_LIST_ITEM_TV(li)->v_type == VAR_LIST) {\n        const list_T *const subl = TV_LIST_ITEM_TV(li)->vval.v_list;\n        const listitem_T *subli = tv_list_first(subl);\n        if (subli == NULL) {\n          emsgf(_(\"E5030: Empty list at position %d\"),\n                (int)tv_list_idx_of_item(pos_list, li));\n          goto fail;\n        }\n        lnum = tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);\n        if (error) {\n          goto fail;\n        }\n        if (lnum <= 0) {\n          continue;\n        }\n        m->pos.pos[i].lnum = lnum;\n        subli = TV_LIST_ITEM_NEXT(subl, subli);\n        if (subli != NULL) {\n          col = tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);\n          if (error) {\n            goto fail;\n          }\n          if (col < 0) {\n            continue;\n          }\n          subli = TV_LIST_ITEM_NEXT(subl, subli);\n          if (subli != NULL) {\n            len = tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);\n            if (len < 0) {\n              continue;\n            }\n            if (error) {\n              goto fail;\n            }\n          }\n        }\n        m->pos.pos[i].col = col;\n        m->pos.pos[i].len = len;\n      } else if (TV_LIST_ITEM_TV(li)->v_type == VAR_NUMBER) {\n        if (TV_LIST_ITEM_TV(li)->vval.v_number <= 0) {\n          continue;\n        }\n        m->pos.pos[i].lnum = TV_LIST_ITEM_TV(li)->vval.v_number;\n        m->pos.pos[i].col = 0;\n        m->pos.pos[i].len = 0;\n      } else {\n        emsgf(_(\"E5031: List or number required at position %d\"),\n              (int)tv_list_idx_of_item(pos_list, li));\n        goto fail;\n      }\n      if (toplnum == 0 || lnum < toplnum) {\n        toplnum = lnum;\n      }\n      if (botlnum == 0 || lnum >= botlnum) {\n        botlnum = lnum + 1;\n      }\n      i++;\n      if (i >= MAXPOSMATCH) {\n        break;\n      }\n    });\n\n    // Calculate top and bottom lines for redrawing area \n    if (toplnum != 0){\n      if (wp->w_buffer->b_mod_set) {\n        if (wp->w_buffer->b_mod_top > toplnum) {\n          wp->w_buffer->b_mod_top = toplnum;\n        }\n        if (wp->w_buffer->b_mod_bot < botlnum) {\n          wp->w_buffer->b_mod_bot = botlnum;\n        }\n      } else {\n        wp->w_buffer->b_mod_set = true;\n        wp->w_buffer->b_mod_top = toplnum;\n        wp->w_buffer->b_mod_bot = botlnum;\n        wp->w_buffer->b_mod_xlines = 0;\n      }\n      m->pos.toplnum = toplnum;\n      m->pos.botlnum = botlnum;\n      rtype = VALID;\n    }\n  }\n\n  // Insert new match.  The match list is in ascending order with regard to\n  // the match priorities.\n  cur = wp->w_match_head;\n  prev = cur;\n  while (cur != NULL && prio >= cur->priority) {\n    prev = cur;\n    cur = cur->next;\n  }\n  if (cur == prev)\n    wp->w_match_head = m;\n  else\n    prev->next = m;\n  m->next = cur;\n\n  redraw_later(wp, rtype);\n  return id;\n\nfail:\n  xfree(m);\n  return -1;\n}\n\n\n/// Delete match with ID 'id' in the match list of window 'wp'.\n///\n/// @param perr  print error messages if true.\nint match_delete(win_T *wp, int id, bool perr)\n{\n  matchitem_T *cur = wp->w_match_head;\n  matchitem_T *prev = cur;\n  int rtype = SOME_VALID;\n\n  if (id < 1) {\n    if (perr) {\n      EMSGN(_(\"E802: Invalid ID: %\" PRId64\n              \" (must be greater than or equal to 1)\"),\n            id);\n    }\n    return -1;\n  }\n  while (cur != NULL && cur->id != id) {\n    prev = cur;\n    cur = cur->next;\n  }\n  if (cur == NULL) {\n    if (perr) {\n      EMSGN(_(\"E803: ID not found: %\" PRId64), id);\n    }\n    return -1;\n  }\n  if (cur == prev)\n    wp->w_match_head = cur->next;\n  else\n    prev->next = cur->next;\n  vim_regfree(cur->match.regprog);\n  xfree(cur->pattern);\n  if (cur->pos.toplnum != 0) {\n    if (wp->w_buffer->b_mod_set) {\n      if (wp->w_buffer->b_mod_top > cur->pos.toplnum) {\n        wp->w_buffer->b_mod_top = cur->pos.toplnum;\n      }\n      if (wp->w_buffer->b_mod_bot < cur->pos.botlnum) {\n        wp->w_buffer->b_mod_bot = cur->pos.botlnum;\n      }\n    } else {\n      wp->w_buffer->b_mod_set = true;\n      wp->w_buffer->b_mod_top = cur->pos.toplnum;\n      wp->w_buffer->b_mod_bot = cur->pos.botlnum;\n      wp->w_buffer->b_mod_xlines = 0;\n    }\n    rtype = VALID;\n  }\n  xfree(cur);\n  redraw_later(wp, rtype);\n  return 0;\n}\n\n/*\n * Delete all matches in the match list of window 'wp'.\n */\nvoid clear_matches(win_T *wp)\n{\n  matchitem_T *m;\n\n  while (wp->w_match_head != NULL) {\n    m = wp->w_match_head->next;\n    vim_regfree(wp->w_match_head->match.regprog);\n    xfree(wp->w_match_head->pattern);\n    xfree(wp->w_match_head);\n    wp->w_match_head = m;\n  }\n  redraw_later(wp, SOME_VALID);\n}\n\n/*\n * Get match from ID 'id' in window 'wp'.\n * Return NULL if match not found.\n */\nmatchitem_T *get_match(win_T *wp, int id)\n{\n  matchitem_T *cur = wp->w_match_head;\n\n  while (cur != NULL && cur->id != id)\n    cur = cur->next;\n  return cur;\n}\n\n\n/// Check that \"topfrp\" and its children are at the right height.\n///\n/// @param  topfrp  top frame pointer\n/// @param  height  expected height\nstatic bool frame_check_height(const frame_T *topfrp, int height)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (topfrp->fr_height != height) {\n    return false;\n  }\n  if (topfrp->fr_layout == FR_ROW) {\n    const frame_T *frp;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      if (frp->fr_height != height) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/// Check that \"topfrp\" and its children are at the right width.\n///\n/// @param  topfrp  top frame pointer\n/// @param  width   expected width\nstatic bool frame_check_width(const frame_T *topfrp, int width)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (topfrp->fr_width != width) {\n    return false;\n  }\n  if (topfrp->fr_layout == FR_COL) {\n    const frame_T *frp;\n    FOR_ALL_FRAMES(frp, topfrp->fr_child) {\n      if (frp->fr_width != width) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint win_getid(typval_T *argvars)\n{\n  if (argvars[0].v_type == VAR_UNKNOWN) {\n    return curwin->handle;\n  }\n  int winnr = tv_get_number(&argvars[0]);\n  win_T *wp;\n  if (winnr > 0) {\n    if (argvars[1].v_type == VAR_UNKNOWN) {\n      wp = firstwin;\n    } else {\n      tabpage_T *tp = NULL;\n      int tabnr = tv_get_number(&argvars[1]);\n      FOR_ALL_TABS(tp2) {\n        if (--tabnr == 0) {\n          tp = tp2;\n          break;\n        }\n      }\n      if (tp == NULL) {\n        return -1;\n      }\n      if (tp == curtab) {\n        wp = firstwin;\n      } else {\n        wp = tp->tp_firstwin;\n      }\n    }\n    for ( ; wp != NULL; wp = wp->w_next) {\n      if (--winnr == 0) {\n        return wp->handle;\n      }\n    }\n  }\n  return 0;\n}\n\nint win_gotoid(typval_T *argvars)\n{\n  int id = tv_get_number(&argvars[0]);\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->handle == id) {\n      goto_tabpage_win(tp, wp);\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid win_get_tabwin(handle_T id, int *tabnr, int *winnr)\n{\n  *tabnr = 0;\n  *winnr = 0;\n\n  int tnum = 1, wnum = 1;\n  FOR_ALL_TABS(tp) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n      if (wp->handle == id) {\n        *winnr = wnum;\n        *tabnr = tnum;\n        return;\n      }\n      wnum++;\n    }\n    tnum++;\n    wnum = 1;\n  }\n}\n\nvoid win_id2tabwin(typval_T *const argvars, typval_T *const rettv)\n{\n  int winnr = 1;\n  int tabnr = 1;\n  handle_T id = (handle_T)tv_get_number(&argvars[0]);\n\n  win_get_tabwin(id, &tabnr, &winnr);\n\n  list_T *const list = tv_list_alloc_ret(rettv, 2);\n  tv_list_append_number(list, tabnr);\n  tv_list_append_number(list, winnr);\n}\n\nwin_T * win_id2wp(typval_T *argvars)\n{\n  return win_id2wp_tp(argvars, NULL);\n}\n\n// Return the window and tab pointer of window \"id\".\nwin_T * win_id2wp_tp(typval_T *argvars, tabpage_T **tpp)\n{\n  int id = tv_get_number(&argvars[0]);\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->handle == id) {\n      if (tpp != NULL) {\n        *tpp = tp;\n      }\n      return wp;\n    }\n  }\n\n  return NULL;\n}\n\nint win_id2win(typval_T *argvars)\n{\n  int nr = 1;\n  int id = tv_get_number(&argvars[0]);\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->handle == id) {\n      return nr;\n    }\n    nr++;\n  }\n  return 0;\n}\n\nvoid win_findbuf(typval_T *argvars, list_T *list)\n{\n  int bufnr = tv_get_number(&argvars[0]);\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (!wp->w_closing && wp->w_buffer->b_fnum == bufnr) {\n      tv_list_append_number(list, wp->handle);\n    }\n  }\n}\n\n// Get the layout of the given tab page for winlayout().\nvoid get_framelayout(const frame_T *fr, list_T *l, bool outer)\n{\n  list_T *fr_list;\n\n  if (fr == NULL) {\n    return;\n  }\n\n  if (outer) {\n    // outermost call from f_winlayout()\n    fr_list = l;\n  } else {\n    fr_list = tv_list_alloc(2);\n    tv_list_append_list(l, fr_list);\n  }\n\n  if (fr->fr_layout == FR_LEAF) {\n    if (fr->fr_win != NULL) {\n      tv_list_append_string(fr_list, \"leaf\", -1);\n      tv_list_append_number(fr_list, fr->fr_win->handle);\n    }\n  } else {\n    tv_list_append_string(fr_list, fr->fr_layout == FR_ROW ? \"row\" : \"col\", -1);\n\n    list_T *const win_list = tv_list_alloc(kListLenUnknown);\n    tv_list_append_list(fr_list, win_list);\n    const frame_T *child = fr->fr_child;\n    while (child != NULL) {\n      get_framelayout(child, win_list, false);\n      child = child->fr_next;\n    }\n  }\n}\n\nvoid win_ui_flush(void)\n{\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_pos_changed && wp->w_grid_alloc.chars != NULL) {\n      if (tp == curtab) {\n        ui_ext_win_position(wp);\n      } else {\n        ui_call_win_hide(wp->w_grid_alloc.handle);\n      }\n      wp->w_pos_changed = false;\n    }\n    if (tp == curtab) {\n      ui_ext_win_viewport(wp);\n    }\n  }\n}\n\nwin_T *lastwin_nofloating(void) {\n  win_T *res = lastwin;\n  while (res->w_floating) {\n    res = res->w_prev;\n  }\n  return res;\n}\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "(          ) (fixit)"}, {"location": {"col": 34, "file": 29, "line": 63}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "ae7ecfabecab9a9bbbf55ee7d4e04877", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 29, "line": 132}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "a2e938f22b047c4b7edbfab13355c8b3", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 59, "file": 29, "line": 132}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "454cd5767f2ac7f9348b7fdbce4a22d0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 43, "file": 29, "line": 142}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "c96a208dbe75a53ec3cbde4c8e7d8a17", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 29, "line": 142}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "861dc97ef45f9f720a57bebe220be2f0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 409}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "516a08eb358fc5a0c07269e8381ffccc", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 411}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "6e38bc6c28ade80b1f39c189ce457d50", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 419}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "5f81de68572d3de28b005c5e72a5f631", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 29, "line": 502}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "52d44b2c204f4c64494c59f8db0a448a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 29, "line": 504}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "39126c4999bff4d8ab4097ddd0a75bd0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 29, "line": 510}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "81ed836cb4e33ec5a295c6b0d15107a4", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 29, "line": 711}, "message": "function 'memcmp' is called without explicitly comparing result"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "9ab88c2f1d92ed95b3a21b13013b7833", "checkerName": "bugprone-suspicious-string-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 29, "line": 785}, "message": "narrowing conversion from 'double' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "94c5cfce522431092b2e8b686754b43d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 29, "line": 785}, "message": "narrowing conversion from 'double' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "437b06f7a47660d14cdbf8dd550713d3", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 793}, "message": "narrowing conversion from 'int' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "75ab843c024d6d7e347c9cd4f44e24fe", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 794}, "message": "narrowing conversion from 'int' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "a1eb8314edb5e9373473058b03e010d6", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 29, "line": 799}, "message": "narrowing conversion from 'int' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b5d3cede7b8667a803e55d002142b54b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 29, "line": 800}, "message": "narrowing conversion from 'int' to 'float'"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b2fba29e52b0daccad3796d22a962b9d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 29, "line": 843}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "80636c17f2fa72b27b4f8b7a37fe5642", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 29, "line": 848}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "62ee874adf624aedf7a24a59e1f8fdef", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 29, "line": 950}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "c21cdc66802d67406a7f8f866710d740", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 29, "line": 953}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "421d92b68c6cb52b9350d18f848a55e1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 43, "file": 29, "line": 956}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "4c2bf1bd98b71556638768b85785cc99", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 50, "file": 29, "line": 960}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "d510b5e703a02481799adcf6561970a1", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 48, "file": 29, "line": 967}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "7678137cfc539c1e0dc0b6aa4b8fc0db", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 50, "file": 29, "line": 976}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "d510b5e703a02481799adcf6561970a1", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 29, "line": 1029}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "d1a487be472a45163f3baa86fb1c7f2e", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 29, "line": 1032}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "ef54a9b80f414c6405e7d9463d4c4db9", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 45, "file": 29, "line": 1035}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "c0c54f9be761413a3bfa7d8c3e3894b6", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 52, "file": 29, "line": 1039}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "c102af3b9171e6c68dbbd540fd734940", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 50, "file": 29, "line": 1046}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "94327f4fa25fb1d289b1aea1d0573b56", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 52, "file": 29, "line": 1055}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "c102af3b9171e6c68dbbd540fd734940", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 29, "line": 1183}, "message": "narrowing conversion from 'int' to signed type 'char' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "6cad5bae9197ebd1a79463fda3a501be", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 29, "line": 1337}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "e7a69e21ee7aae31942419a0bdadda02", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 29, "line": 1342}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "2ed205030101f6b11955607c092f98d4", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1537}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "2565da843a298ea01e80bd98e58ed1dd", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 1541}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "6c47b87ce3c6e772336983c39e11fd78", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 33, "file": 29, "line": 1922}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "6d0dac090dd3514086e4e4ddef733e6b", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 1928}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "7569c78409f7f394dec8e5ed0c082b65", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 29, "line": 1939}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b8a267942b323c9eb076f3fdada6274d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 34, "file": 29, "line": 1950}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "5314d41f291dd0f9141cf63d591dbbf9", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 1953}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "335619e7ccd30f5d99ce449df3d010bf", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 29, "line": 1956}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "a59e1fa3f3bd1736e70cd7b5b0be97cf", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 29, "line": 1959}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "57d4dad6f53cb61c01d1352d9b4683ec", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 29, "line": 1976}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "caaebce7225865b7ef0265398c183cd5", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 29, "line": 1979}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "3a1d01de07c12f4f803b4bc9f7ffbfec", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 29, "line": 1981}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "3faf7a9e30812f03a3ecad3976252071", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 32, "file": 29, "line": 2001}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "281bd3ccc966b09e510382dc0fbbb334", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 29, "line": 2002}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "4cf6f3ae7e910315b252942e33b41b0c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 29, "line": 2019}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b0b6d428326093413c4f1f993c82ea10", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 34, "file": 29, "line": 2044}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "52fe36c9e4c8e649b71de10925e272db", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 2050}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "0a5093256c614f6bbd3b409d22906b00", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 29, "line": 2063}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "a593b0b15e65ae03b774bb4e4afa7d36", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 35, "file": 29, "line": 2074}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "f6920b491aac2e3e49d8a123cb4b19d5", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 29, "line": 2077}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "3f1aa56ff5de72e38ab00f2f6f0f06b5", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 29, "line": 2080}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "96cb3c107b03299ea28dcd5b648b6a81", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 29, "line": 2083}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "57d4dad6f53cb61c01d1352d9b4683ec", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 29, "line": 2100}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "efacd00c6187a2c11aab710c40e15259", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 29, "line": 2103}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "3c31e5910b412ae7ca6dae282a5eda45", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 29, "line": 2105}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "78d44e71ebf76e2e35cef282464fcd40", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 33, "file": 29, "line": 2125}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "ed6b9d282e5ea5bfeee0cecc308c8e20", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 29, "line": 2126}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "4cf6f3ae7e910315b252942e33b41b0c", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 29, "line": 2143}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "9646a42d1b38df7b026ef4b96251a6b4", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 29, "line": 3334}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "bbf1abcfed725e9024ee55e4da7afe0b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 29, "line": 3337}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "173a43dc7838c927457a012889348bf6", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 29, "line": 3381}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "f073c7ec3cca568391e36a1c860f864d", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 29, "line": 3384}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "74993a701aa08449ec11bb63867a672e", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 3567}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "a6323751d964b0baed4c1e3399f5c30a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 29, "line": 3741}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "e0bf94a543fe923bc45a395b07a5f3c2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 29, "line": 5020}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "080dbcee40867456d87cb4aef135eb65", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 29, "line": 5121}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "33cc622c11276386a49a90eea268f667", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 48, "file": 29, "line": 5136}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "f4478de44e6233294e9f8778a9021f0d", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 15, "file": 29, "line": 5225}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b4dc01232e76dd487a506aedea494ed2", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 63}, "message": "expanded from macro 'NOWIN'"}, {"location": {"col": 47, "file": 29, "line": 5307}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "5f331ad87c63c5cc8bbdf8f0af68288d", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 29, "line": 5379}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "8dc8e332ab33d452d719d11179453c3b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 29, "line": 5468}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "6c057dc5d521c863182c087f32742d8b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 29, "line": 5638}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "e9541bd115de8c04bc72c675bf2cfc3a", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 29, "line": 5685}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "1dba7f4216c1cd7f5e9d69c348ab78c1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 29, "line": 5860}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "98896f116f4d8449354cd1994b5bca6b", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 29, "line": 5879}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "3fb3357aaec99aa23e76619e66e3719f", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 29, "line": 5887}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "9a25341c6c6f55e60196e6354f43b813", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 29, "line": 5892}, "message": "narrowing conversion from 'long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "e56b77f13577fa237dc06ce0b9bac005", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 42, "file": 29, "line": 6221}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "8e7951e5c727441ca427cc09e9d9e6b0", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 42, "file": 29, "line": 6232}, "message": "narrowing conversion from 'linenr_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "d702ed0dd1e237a676b996de4067bb33", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 54, "file": 29, "line": 6540}, "message": "narrowing conversion from 'unsigned long' to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "4b49fc9c292319c88205e57204cdf0e1", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 29, "line": 6822}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "61201d983af3e5d7b5973ec1de53fddc", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 29, "line": 6829}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "0425dda281a0e3a4192323f02214f194", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 29, "line": 6856}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b5da7f2390b28aa0a6f8bd39d56e7b26", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 29, "line": 6908}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b5da7f2390b28aa0a6f8bd39d56e7b26", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 29, "line": 6925}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "b5da7f2390b28aa0a6f8bd39d56e7b26", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 29, "line": 6938}, "message": "narrowing conversion from 'varnumber_T' (aka 'long') to signed type 'int' is implementation-defined"}], "macros": [], "notes": [], "path": "src/nvim/window.c", "reportHash": "863867100d034e45f96565368b459274", "checkerName": "bugprone-narrowing-conversions", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
