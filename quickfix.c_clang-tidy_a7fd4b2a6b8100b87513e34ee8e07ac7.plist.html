<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/quickfix.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// quickfix.c: functions for quickfix mode, using a file with error messages\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_eval.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/move.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/api/private/helpers.h\"\n\n\nstruct dir_stack_T {\n  struct dir_stack_T  *next;\n  char_u              *dirname;\n};\n\n// For each error the next struct is allocated and linked in a list.\ntypedef struct qfline_S qfline_T;\nstruct qfline_S {\n  qfline_T *qf_next;      ///< pointer to next error in the list\n  qfline_T *qf_prev;      ///< pointer to previous error in the list\n  linenr_T qf_lnum;       ///< line number where the error occurred\n  linenr_T qf_end_lnum;   ///< line number when the error has range or zero\n\n  int qf_fnum;            ///< file number for the line\n  int qf_col;             ///< column where the error occurred\n  int qf_end_col;         ///< column when the error has range or zero\n  int qf_nr;              ///< error number\n  char_u *qf_module;      ///< module name for this error\n  char_u *qf_pattern;     ///< search pattern for the error\n  char_u *qf_text;        ///< description of the error\n  char_u qf_viscol;       ///< set to TRUE if qf_col and qf_end_col is\n                          //   screen column\n  char_u qf_cleared;      ///< set to TRUE if line has been deleted\n  char_u qf_type;         ///< type of the error (mostly 'E'); 1 for :helpgrep\n  char_u qf_valid;        ///< valid error message detected\n};\n\n// There is a stack of error lists.\n#define LISTCOUNT   10\n#define INVALID_QFIDX (-1)\n\n/// Quickfix list type.\ntypedef enum\n{\n  QFLT_QUICKFIX,  ///< Quickfix list - global list\n  QFLT_LOCATION,  ///< Location list - per window list\n  QFLT_INTERNAL   ///< Internal - Temporary list used by\n                  //   getqflist()/getloclist()\n} qfltype_T;\n\n/// Quickfix/Location list definition\n///\n/// Usually the list contains one or more entries. But an empty list can be\n/// created using setqflist()/setloclist() with a title and/or user context\n/// information and entries can be added later using setqflist()/setloclist().\ntypedef struct qf_list_S {\n  unsigned qf_id;               ///< Unique identifier for this list\n  qfltype_T   qfl_type;\n  qfline_T    *qf_start;        ///< pointer to the first error\n  qfline_T    *qf_last;         ///< pointer to the last error\n  qfline_T    *qf_ptr;          ///< pointer to the current error\n  int qf_count;                 ///< number of errors (0 means empty list)\n  int qf_index;                 ///< current index in the error list\n  int qf_nonevalid;             ///< TRUE if not a single valid entry found\n  char_u      *qf_title;        ///< title derived from the command that created\n                                ///< the error list or set by setqflist\n  typval_T    *qf_ctx;          ///< context set by setqflist/setloclist\n  Callback  qftf_cb;            ///< 'quickfixtextfunc' callback function\n\n  struct dir_stack_T *qf_dir_stack;\n  char_u *qf_directory;\n  struct dir_stack_T *qf_file_stack;\n  char_u *qf_currfile;\n  bool qf_multiline;\n  bool qf_multiignore;\n  bool qf_multiscan;\n  long qf_changedtick;\n} qf_list_T;\n\n/// Quickfix/Location list stack definition\n/// Contains a list of quickfix/location lists (qf_list_T)\nstruct qf_info_S {\n  // Count of references to this list. Used only for location lists.\n  // When a location list window reference this list, qf_refcount\n  // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount\n  // reaches 0, the list is freed.\n  int qf_refcount;\n  int qf_listcount;                 // current number of lists\n  int qf_curlist;                   // current error list\n  qf_list_T qf_lists[LISTCOUNT];\n  qfltype_T qfl_type;  // type of list\n};\n\nstatic qf_info_T ql_info;         // global quickfix list\nstatic unsigned last_qf_id = 0;   // Last Used quickfix list id\n\n#define FMT_PATTERNS 11           // maximum number of % recognized\n\n// Structure used to hold the info of one part of 'errorformat'\ntypedef struct efm_S efm_T;\nstruct efm_S {\n  regprog_T       *prog;        // pre-formatted part of 'errorformat'\n  efm_T           *next;        // pointer to next (NULL if last)\n  char_u addr[FMT_PATTERNS];    // indices of used % patterns\n  char_u prefix;                // prefix of this format line:\n                                // 'D' enter directory\n                                // 'X' leave directory\n                                // 'A' start of multi-line message\n                                // 'E' error message\n                                // 'W' warning message\n                                // 'I' informational message\n                                // 'N' note message\n                                // 'C' continuation line\n                                // 'Z' end of multi-line message\n                                // 'G' general, unspecific message\n                                // 'P' push file (partial) message\n                                // 'Q' pop/quit file (partial) message\n                                // 'O' overread (partial) message\n  char_u flags;                 // additional flags given in prefix\n                                // '-' do not include this line\n                                // '+' include whole line in message\n  int conthere;                 // %> used\n};\n\n/// List of location lists to be deleted.\n/// Used to delay the deletion of locations lists by autocmds.\ntypedef struct qf_delq_S {\n  struct qf_delq_S *next;\n  qf_info_T *qi;\n} qf_delq_T;\n\nenum {\n  QF_FAIL = 0,\n  QF_OK = 1,\n  QF_END_OF_INPUT = 2,\n  QF_NOMEM = 3,\n  QF_IGNORE_LINE = 4,\n  QF_MULTISCAN = 5,\n};\n\n/// State information used to parse lines and add entries to a quickfix/location\n/// list.\ntypedef struct {\n  char_u *linebuf;\n  size_t linelen;\n  char_u *growbuf;\n  size_t growbufsiz;\n  FILE   *fd;\n  typval_T   *tv;\n  char_u     *p_str;\n  list_T     *p_list;\n  listitem_T *p_li;\n  buf_T      *buf;\n  linenr_T buflnum;\n  linenr_T lnumlast;\n  vimconv_T vc;\n} qfstate_T;\n\ntypedef struct {\n  char_u *namebuf;\n  char_u *module;\n  char_u *errmsg;\n  size_t errmsglen;\n  long lnum;\n  long end_lnum;\n  int  col;\n  int end_col;\n  bool use_viscol;\n  char_u *pattern;\n  int    enr;\n  char_u type;\n  bool   valid;\n} qffields_T;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"quickfix.c.generated.h\"\n#endif\n\nstatic char_u *e_no_more_items = (char_u *)N_(\"E553: No more items\");\n\n// Quickfix window check helper macro\n#define IS_QF_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref == NULL)\n// Location list window check helper macro\n#define IS_LL_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref != NULL)\n\n// Quickfix and location list stack check helper macros\n#define IS_QF_STACK(qi)       (qi->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_STACK(qi)       (qi->qfl_type == QFLT_LOCATION)\n#define IS_QF_LIST(qfl)       (qfl->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_LIST(qfl)       (qfl->qfl_type == QFLT_LOCATION)\n\n//\n// Return location list for window 'wp'\n// For location list window, return the referenced location list\n//\n#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? wp->w_llist_ref : wp->w_llist)\n\n// Macro to loop through all the items in a quickfix list\n// Quickfix item index starts from 1, so i below starts at 1\n#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \\\n  for (i = 1, qfp = qfl->qf_start; /* NOLINT(readability/braces) */ \\\n       !got_int && i <= qfl->qf_count && qfp != NULL; \\\n       i++, qfp = qfp->qf_next)\n\n\n// Looking up a buffer can be slow if there are many.  Remember the last one\n// to make this a lot faster if there are multiple matches in the same file.\nstatic char_u *qf_last_bufname = NULL;\nstatic bufref_T  qf_last_bufref = { NULL, 0, 0 };\n\nstatic char *e_current_quickfix_list_was_changed =\n  N_(\"E925: Current quickfix list was changed\");\nstatic char *e_current_location_list_was_changed =\n  N_(\"E926: Current location list was changed\");\n\n// Counter to prevent autocmds from freeing up location lists when they are\n// still being used.\nstatic int quickfix_busy = 0;\nstatic qf_delq_T *qf_delq_head = NULL;\n\n/// Process the next line from a file/buffer/list/string and add it\n/// to the quickfix list 'qfl'.\nstatic int qf_init_process_nextline(qf_list_T *qfl,\n                                    efm_T *fmt_first,\n                                    qfstate_T *state,\n                                    qffields_T *fields)\n{\n  int status;\n\n  // Get the next line from a file/buffer/list/string\n  status = qf_get_nextline(state);\n  if (status != QF_OK) {\n    return status;\n  }\n\n  status = qf_parse_line(qfl, state->linebuf, state->linelen,\n                         fmt_first, fields);\n  if (status != QF_OK) {\n    return status;\n  }\n\n  return qf_add_entry(qfl,\n                      qfl->qf_directory,\n                      (*fields->namebuf || qfl->qf_directory != NULL)\n                      ? fields->namebuf\n                      : ((qfl->qf_currfile != NULL && fields->valid)\n                         ? qfl->qf_currfile : (char_u *)NULL),\n                      fields->module,\n                      0,\n                      fields->errmsg,\n                      fields->lnum,\n                      fields->end_lnum,\n                      fields->col,\n                      fields->end_col,\n                      fields->use_viscol,\n                      fields->pattern,\n                      fields->enr,\n                      fields->type,\n                      fields->valid);\n}\n\n/// Read the errorfile \"efile\" into memory, line by line, building the error\n/// list. Set the error list's title to qf_title.\n///\n/// @params  wp  If non-NULL, make a location list\n/// @params  efile  If non-NULL, errorfile to parse\n/// @params  errorformat  'errorformat' string used to parse the error lines\n/// @params  newlist  If true, create a new error list\n/// @params  qf_title  If non-NULL, title of the error list\n/// @params  enc  If non-NULL, encoding used to parse errors\n///\n/// @returns -1 for error, number of errors for success.\nint qf_init(win_T *wp, const char_u *restrict efile,\n            char_u *restrict errorformat, int newlist,\n            const char_u *restrict qf_title, char_u *restrict enc)\n{\n  qf_info_T       *qi = &ql_info;\n\n  if (wp != NULL) {\n    qi = ll_get_or_alloc_list(wp);\n  }\n\n  return qf_init_ext(qi, qi->qf_curlist, efile, curbuf, NULL, errorformat,\n                     newlist, (linenr_T)0, (linenr_T)0, qf_title, enc);\n}\n\n// Maximum number of bytes allowed per line while reading an errorfile.\nstatic const size_t LINE_MAXLEN = 4096;\n\nstatic struct fmtpattern\n{\n  char_u convchar;\n  char *pattern;\n} fmt_pat[FMT_PATTERNS] =\n{\n  { 'f', \".\\\\+\" },  // only used when at end\n  { 'n', \"\\\\d\\\\+\" },\n  { 'l', \"\\\\d\\\\+\" },\n  { 'c', \"\\\\d\\\\+\" },\n  { 't', \".\" },\n  { 'm', \".\\\\+\" },\n  { 'r', \".*\" },\n  { 'p', \"[- \t.]*\" },  // NOLINT(whitespace/tab)\n  { 'v', \"\\\\d\\\\+\" },\n  { 's', \".\\\\+\" },\n  { 'o', \".\\\\+\" }\n};\n\n/// Convert an errorformat pattern to a regular expression pattern.\n/// See fmt_pat definition above for the list of supported patterns.  The\n/// pattern specifier is supplied in \"efmpat\".  The converted pattern is stored\n/// in \"regpat\".  Returns a pointer to the location after the pattern.\nstatic char_u * efmpat_to_regpat(\n    const char_u *efmpat,\n    char_u *regpat,\n    efm_T *efminfo,\n    int idx,\n    int round,\n    char_u *errmsg,\n    size_t errmsglen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (efminfo->addr[idx]) {\n    // Each errorformat pattern can occur only once\n    snprintf((char *)errmsg, errmsglen,\n             _(\"E372: Too many %%%c in format string\"), *efmpat);\n    EMSG(errmsg);\n    return NULL;\n  }\n  if ((idx && idx < 6\n       && vim_strchr((char_u *)\"DXOPQ\", efminfo->prefix) != NULL)\n      || (idx == 6\n          && vim_strchr((char_u *)\"OPQ\", efminfo->prefix) == NULL)) {\n    snprintf((char *)errmsg, errmsglen,\n             _(\"E373: Unexpected %%%c in format string\"), *efmpat);\n    EMSG(errmsg);\n    return NULL;\n  }\n  efminfo->addr[idx] = (char_u)++round;\n  *regpat++ = '\\\\';\n  *regpat++ = '(';\n#ifdef BACKSLASH_IN_FILENAME\n  if (*efmpat == 'f') {\n    // Also match \"c:\" in the file name, even when\n    // checking for a colon next: \"%f:\".\n    // \"\\%(\\a:\\)\\=\"\n    STRCPY(regpat, \"\\\\%(\\\\a:\\\\)\\\\=\");\n    regpat += 10;\n  }\n#endif\n  if (*efmpat == 'f' && efmpat[1] != NUL) {\n    if (efmpat[1] != '\\\\' && efmpat[1] != '%') {\n      // A file name may contain spaces, but this isn't\n      // in \"\\f\".  For \"%f:%l:%m\" there may be a \":\" in\n      // the file name.  Use \".\\{-1,}x\" instead (x is\n      // the next character), the requirement that :999:\n      // follows should work.\n      STRCPY(regpat, \".\\\\{-1,}\");\n      regpat += 7;\n    } else {\n      // File name followed by '\\\\' or '%': include as\n      // many file name chars as possible.\n      STRCPY(regpat, \"\\\\f\\\\+\");\n      regpat += 4;\n    }\n  } else {\n    char_u *srcptr = (char_u *)fmt_pat[idx].pattern;\n    while ((*regpat = *srcptr++) != NUL) {\n      regpat++;\n    }\n  }\n  *regpat++ = '\\\\';\n  *regpat++ = ')';\n\n  return regpat;\n}\n\n/// Convert a scanf like format in 'errorformat' to a regular expression.\n/// Returns a pointer to the location after the pattern.\nstatic char_u * scanf_fmt_to_regpat(\n    const char_u **pefmp,\n    const char_u *efm,\n    int len,\n    char_u *regpat,\n    char_u *errmsg,\n    size_t errmsglen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char_u *efmp = *pefmp;\n\n  if (*efmp == '[' || *efmp == '\\\\') {\n    if ((*regpat++ = *efmp) == '[') {  // %*[^a-z0-9] etc.\n      if (efmp[1] == '^') {\n        *regpat++ = *++efmp;\n      }\n      if (efmp < efm + len) {\n        *regpat++ = *++efmp;  // could be ']'\n        while (efmp < efm + len && (*regpat++ = *++efmp) != ']') {\n        }\n        if (efmp == efm + len) {\n          EMSG(_(\"E374: Missing ] in format string\"));\n          return NULL;\n        }\n      }\n    } else if (efmp < efm + len) {  // %*\\D, %*\\s etc.\n      *regpat++ = *++efmp;\n    }\n    *regpat++ = '\\\\';\n    *regpat++ = '+';\n  } else {\n    // TODO(vim): scanf()-like: %*ud, %*3c, %*f, ... ?\n    snprintf((char *)errmsg, errmsglen,\n             _(\"E375: Unsupported %%%c in format string\"), *efmp);\n    EMSG(errmsg);\n    return NULL;\n  }\n\n  *pefmp = efmp;\n\n  return regpat;\n}\n\n/// Analyze/parse an errorformat prefix.\nstatic const char_u *efm_analyze_prefix(const char_u *efmp, efm_T *efminfo,\n                                        char_u *errmsg, size_t errmsglen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (vim_strchr((char_u *)\"+-\", *efmp) != NULL) {\n    efminfo->flags = *efmp++;\n  }\n  if (vim_strchr((char_u *)\"DXAEWINCZGOPQ\", *efmp) != NULL) {\n    efminfo->prefix = *efmp;\n  } else {\n    snprintf((char *)errmsg, errmsglen,\n             _(\"E376: Invalid %%%c in format string prefix\"), *efmp);\n    EMSG(errmsg);\n    return NULL;\n  }\n\n  return efmp;\n}\n\n\n// Converts a 'errorformat' string to regular expression pattern\nstatic int efm_to_regpat(const char_u *efm, int len, efm_T *fmt_ptr,\n                         char_u *regpat, char_u *errmsg, size_t errmsglen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Build regexp pattern from current 'errorformat' option\n  char_u *ptr = regpat;\n  *ptr++ = '^';\n  int round = 0;\n  for (const char_u *efmp = efm; efmp < efm + len; efmp++) {\n    if (*efmp == '%') {\n      efmp++;\n      int idx;\n      for (idx = 0; idx < FMT_PATTERNS; idx++) {\n        if (fmt_pat[idx].convchar == *efmp) {\n          break;\n        }\n      }\n      if (idx < FMT_PATTERNS) {\n        ptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round, errmsg,\n                               errmsglen);\n        if (ptr == NULL) {\n          return FAIL;\n        }\n        round++;\n      } else if (*efmp == '*') {\n        efmp++;\n        ptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr, errmsg, errmsglen);\n        if (ptr == NULL) {\n          return FAIL;\n        }\n      } else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL) {\n        *ptr++ = *efmp;  // regexp magic characters\n      } else if (*efmp == '#') {\n        *ptr++ = '*';\n      } else if (*efmp == '>') {\n        fmt_ptr->conthere = true;\n      } else if (efmp == efm + 1) {             // analyse prefix\n        // prefix is allowed only at the beginning of the errorformat\n        // option part\n        efmp = efm_analyze_prefix(efmp, fmt_ptr, errmsg, errmsglen);\n        if (efmp == NULL) {\n          return FAIL;\n        }\n      } else {\n        snprintf((char *)errmsg, CMDBUFFSIZE + 1,\n                 _(\"E377: Invalid %%%c in format string\"), *efmp);\n        EMSG(errmsg);\n        return FAIL;\n      }\n    } else {                    // copy normal character\n      if (*efmp == '\\\\' && efmp + 1 < efm + len) {\n        efmp++;\n      } else if (vim_strchr((char_u *)\".*^$~[\", *efmp) != NULL) {\n        *ptr++ = '\\\\';  // escape regexp atoms\n      }\n      if (*efmp) {\n        *ptr++ = *efmp;\n      }\n    }\n  }\n  *ptr++ = '$';\n  *ptr = NUL;\n\n  return OK;\n}\n\nstatic efm_T *fmt_start = NULL;  // cached across qf_parse_line() calls\n\n// callback function for 'quickfixtextfunc'\nstatic Callback qftf_cb;\n\nstatic void free_efm_list(efm_T **efm_first)\n{\n  for (efm_T *efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first) {\n    *efm_first = efm_ptr->next;\n    vim_regfree(efm_ptr->prog);\n    xfree(efm_ptr);\n  }\n\n  fmt_start = NULL;\n}\n\n/// Compute the size of the buffer used to convert a 'errorformat' pattern into\n/// a regular expression pattern.\nstatic size_t efm_regpat_bufsz(char_u *efm)\n{\n  size_t sz;\n\n  sz = (FMT_PATTERNS * 3) + (STRLEN(efm) << 2);\n  for (int i = FMT_PATTERNS - 1; i >= 0; ) {\n    sz += STRLEN(fmt_pat[i--].pattern);\n  }\n#ifdef BACKSLASH_IN_FILENAME\n  sz += 12;  // \"%f\" can become twelve chars longer (see efm_to_regpat)\n#else\n  sz += 2;  // \"%f\" can become two chars longer\n#endif\n\n  return sz;\n}\n\n/// Return the length of a 'errorformat' option part (separated by \",\").\nstatic int efm_option_part_len(char_u *efm)\n{\n  int len;\n\n  for (len = 0; efm[len] != NUL && efm[len] != ','; len++) {\n    if (efm[len] == '\\\\' && efm[len + 1] != NUL) {\n      len++;\n    }\n  }\n\n  return len;\n}\n\n/// Parse the 'errorformat' option. Multiple parts in the 'errorformat' option\n/// are parsed and converted to regular expressions. Returns information about\n/// the parsed 'errorformat' option.\nstatic efm_T * parse_efm_option(char_u *efm)\n{\n  efm_T *fmt_ptr = NULL;\n  efm_T *fmt_first = NULL;\n  efm_T *fmt_last = NULL;\n  int len;\n\n  size_t errmsglen = CMDBUFFSIZE + 1;\n  char_u *errmsg = xmalloc(errmsglen);\n\n  // Get some space to modify the format string into.\n  size_t sz = efm_regpat_bufsz(efm);\n  char_u *fmtstr = xmalloc(sz);\n\n  while (efm[0] != NUL) {\n    // Allocate a new eformat structure and put it at the end of the list\n    fmt_ptr = (efm_T *)xcalloc(1, sizeof(efm_T));\n    if (fmt_first == NULL) {        // first one\n      fmt_first = fmt_ptr;\n    } else {\n      fmt_last->next = fmt_ptr;\n    }\n    fmt_last = fmt_ptr;\n\n    // Isolate one part in the 'errorformat' option\n    len = efm_option_part_len(efm);\n\n    if (efm_to_regpat(efm, len, fmt_ptr, fmtstr, errmsg, errmsglen) == FAIL) {\n      goto parse_efm_error;\n    }\n    if ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL) {\n      goto parse_efm_error;\n    }\n    // Advance to next part\n    efm = skip_to_option_part(efm + len);       // skip comma and spaces\n  }\n\n  if (fmt_first == NULL) {      // nothing found\n    EMSG(_(\"E378: 'errorformat' contains no pattern\"));\n  }\n\n  goto parse_efm_end;\n\nparse_efm_error:\n  free_efm_list(&fmt_first);\n\nparse_efm_end:\n  xfree(fmtstr);\n  xfree(errmsg);\n\n  return fmt_first;\n}\n\n/// Allocate more memory for the line buffer used for parsing lines.\nstatic char_u *qf_grow_linebuf(qfstate_T *state, size_t newsz)\n{\n  // If the line exceeds LINE_MAXLEN exclude the last\n  // byte since it's not a NL character.\n  state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;\n  if (state->growbuf == NULL) {\n    state->growbuf = xmalloc(state->linelen + 1);\n    state->growbufsiz = state->linelen;\n  } else if (state->linelen > state->growbufsiz) {\n    state->growbuf = xrealloc(state->growbuf, state->linelen + 1);\n    state->growbufsiz = state->linelen;\n  }\n  return state->growbuf;\n}\n\n/// Get the next string (separated by newline) from state->p_str.\nstatic int qf_get_next_str_line(qfstate_T *state)\n{\n  // Get the next line from the supplied string\n  char_u *p_str = state->p_str;\n  char_u *p;\n  size_t len;\n\n  if (*p_str == NUL) {  // Reached the end of the string\n    return QF_END_OF_INPUT;\n  }\n\n  p = vim_strchr(p_str, '\\n');\n  if (p != NULL) {\n    len = (size_t)(p - p_str) + 1;\n  } else {\n    len = STRLEN(p_str);\n  }\n\n  if (len > IOSIZE - 2) {\n    state->linebuf = qf_grow_linebuf(state, len);\n  } else {\n    state->linebuf = IObuff;\n    state->linelen = len;\n  }\n  STRLCPY(state->linebuf, p_str, state->linelen + 1);\n\n  // Increment using len in order to discard the rest of the line if it\n  // exceeds LINE_MAXLEN.\n  p_str += len;\n  state->p_str = p_str;\n\n  return QF_OK;\n}\n\n/// Get the next string from state->p_Li.\nstatic int qf_get_next_list_line(qfstate_T *state)\n{\n  listitem_T *p_li = state->p_li;\n  size_t len;\n\n  // Get the next line from the supplied list\n  while (p_li != NULL\n         && (TV_LIST_ITEM_TV(p_li)->v_type != VAR_STRING\n             || TV_LIST_ITEM_TV(p_li)->vval.v_string == NULL)) {\n    p_li = TV_LIST_ITEM_NEXT(state->p_list, p_li);  // Skip non-string items.\n  }\n\n  if (p_li == NULL) {  // End of the list.\n    state->p_li = NULL;\n    return QF_END_OF_INPUT;\n  }\n\n  len = STRLEN(TV_LIST_ITEM_TV(p_li)->vval.v_string);\n  if (len > IOSIZE - 2) {\n    state->linebuf = qf_grow_linebuf(state, len);\n  } else {\n    state->linebuf = IObuff;\n    state->linelen = len;\n  }\n\n  STRLCPY(state->linebuf, TV_LIST_ITEM_TV(p_li)->vval.v_string,\n          state->linelen + 1);\n\n  state->p_li = TV_LIST_ITEM_NEXT(state->p_list, p_li);\n  return QF_OK;\n}\n\n/// Get the next string from state->buf.\nstatic int qf_get_next_buf_line(qfstate_T *state)\n{\n  char_u *p_buf = NULL;\n  size_t len;\n\n  // Get the next line from the supplied buffer\n  if (state->buflnum > state->lnumlast) {\n    return QF_END_OF_INPUT;\n  }\n  p_buf = ml_get_buf(state->buf, state->buflnum, false);\n  state->buflnum += 1;\n\n  len = STRLEN(p_buf);\n  if (len > IOSIZE - 2) {\n    state->linebuf = qf_grow_linebuf(state, len);\n  } else {\n    state->linebuf = IObuff;\n    state->linelen = len;\n  }\n  STRLCPY(state->linebuf, p_buf, state->linelen + 1);\n\n  return QF_OK;\n}\n\n/// Get the next string from file state->fd.\nstatic int qf_get_next_file_line(qfstate_T *state)\n{\n  size_t growbuflen;\n\nretry:\n  errno = 0;\n  if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL) {\n    if (errno == EINTR) {\n        goto retry;\n    }\n    return QF_END_OF_INPUT;\n  }\n\n  bool discard = false;\n  state->linelen = STRLEN(IObuff);\n  if (state->linelen == IOSIZE - 1\n      && !(IObuff[state->linelen - 1] == '\\n')) {\n    // The current line exceeds IObuff, continue reading using growbuf\n    // until EOL or LINE_MAXLEN bytes is read.\n    if (state->growbuf == NULL) {\n      state->growbufsiz = 2 * (IOSIZE - 1);\n      state->growbuf = xmalloc(state->growbufsiz);\n    }\n\n    // Copy the read part of the line, excluding null-terminator\n    memcpy(state->growbuf, IObuff, IOSIZE - 1);\n    growbuflen = state->linelen;\n\n    for (;;) {\n      errno = 0;\n      if (fgets((char *)state->growbuf + growbuflen,\n                (int)(state->growbufsiz - growbuflen), state->fd) == NULL) {\n        if (errno == EINTR) {\n          continue;\n        }\n        break;\n      }\n      state->linelen = STRLEN(state->growbuf + growbuflen);\n      growbuflen += state->linelen;\n      if (state->growbuf[growbuflen - 1] == '\\n') {\n        break;\n      }\n      if (state->growbufsiz == LINE_MAXLEN) {\n        discard = true;\n        break;\n      }\n\n      state->growbufsiz = (2 * state->growbufsiz < LINE_MAXLEN)\n        ? 2 * state->growbufsiz : LINE_MAXLEN;\n      state->growbuf = xrealloc(state->growbuf, state->growbufsiz);\n    }\n\n    while (discard) {\n      // The current line is longer than LINE_MAXLEN, continue reading but\n      // discard everything until EOL or EOF is reached.\n      errno = 0;\n      if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL) {\n        if (errno == EINTR) {\n          continue;\n        }\n        break;\n      }\n      if (STRLEN(IObuff) < IOSIZE - 1 || IObuff[IOSIZE - 2] == '\\n') {\n        break;\n      }\n    }\n\n    state->linebuf = state->growbuf;\n    state->linelen = growbuflen;\n  } else {\n    state->linebuf = IObuff;\n  }\n\n  // Convert a line if it contains a non-ASCII character\n  if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf)) {\n    char_u *line = string_convert(&state->vc, state->linebuf, &state->linelen);\n    if (line != NULL) {\n      if (state->linelen < IOSIZE) {\n        STRLCPY(state->linebuf, line, state->linelen + 1);\n        xfree(line);\n      } else {\n        xfree(state->growbuf);\n        state->linebuf = state->growbuf = line;\n        state->growbufsiz = state->linelen < LINE_MAXLEN\n          ? state->linelen : LINE_MAXLEN;\n      }\n    }\n  }\n  return QF_OK;\n}\n\n/// Get the next string from a file/buffer/list/string.\nstatic int qf_get_nextline(qfstate_T *state)\n{\n  int status = QF_FAIL;\n\n  if (state->fd == NULL) {\n    if (state->tv != NULL) {\n      if (state->tv->v_type == VAR_STRING) {\n        // Get the next line from the supplied string\n        status = qf_get_next_str_line(state);\n      } else if (state->tv->v_type == VAR_LIST) {\n        // Get the next line from the supplied list\n        status = qf_get_next_list_line(state);\n      }\n    } else {\n      // Get the next line from the supplied buffer\n      status = qf_get_next_buf_line(state);\n    }\n  } else {\n    // Get the next line from the supplied file\n    status = qf_get_next_file_line(state);\n  }\n\n  if (status != QF_OK) {\n    return status;\n  }\n\n  if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\\n') {\n    state->linebuf[state->linelen - 1] = NUL;\n#ifdef USE_CRNL\n    if (state->linelen > 1 && state->linebuf[state->linelen - 2] == '\\r') {\n      state->linebuf[state->linelen - 2] = NUL;\n    }\n#endif\n  }\n\n  remove_bom(state->linebuf);\n\n  return QF_OK;\n}\n\n/// Returns true if the specified quickfix/location stack is empty\nstatic bool qf_stack_empty(const qf_info_T *qi)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return qi == NULL || qi->qf_listcount <= 0;\n}\n\n/// Returns true if the specified quickfix/location list is empty.\nstatic bool qf_list_empty(qf_list_T *qfl)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  return qfl == NULL || qfl->qf_count <= 0;\n}\n\n/// Returns true if the specified quickfix/location list is not empty and\n/// has valid entries.\nstatic bool qf_list_has_valid_entries(qf_list_T *qfl)\n{\n  return !qf_list_empty(qfl) && !qfl->qf_nonevalid;\n}\n\n/// Return a pointer to a list in the specified quickfix stack\nstatic qf_list_T * qf_get_list(qf_info_T *qi, int idx)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return &qi->qf_lists[idx];\n}\n\n/// Parse a line and get the quickfix fields.\n/// Return the QF_ status.\nstatic int qf_parse_line(qf_list_T *qfl, char_u *linebuf,\n                         size_t linelen, efm_T *fmt_first, qffields_T *fields)\n{\n  efm_T *fmt_ptr;\n  int    idx = 0;\n  char_u *tail = NULL;\n  int status;\n\nrestofline:\n  // If there was no %> item start at the first pattern\n  if (fmt_start == NULL) {\n    fmt_ptr = fmt_first;\n  } else {\n    // Otherwise start from the last used pattern.\n    fmt_ptr = fmt_start;\n    fmt_start = NULL;\n  }\n\n  // Try to match each part of 'errorformat' until we find a complete\n  // match or no match.\n  fields->valid = true;\n  for (; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next) {\n    idx = fmt_ptr->prefix;\n    status = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,\n                                 qfl->qf_multiline, qfl->qf_multiscan,\n                                 &tail);\n    if (status == QF_NOMEM) {\n      return status;\n    }\n    if (status == QF_OK) {\n      break;\n    }\n  }\n  qfl->qf_multiscan = false;\n\n  if (fmt_ptr == NULL || idx == 'D' || idx == 'X') {\n    if (fmt_ptr != NULL) {\n      // 'D' and 'X' directory specifiers.\n      status = qf_parse_dir_pfx(idx, fields, qfl);\n      if (status != QF_OK) {\n        return status;\n      }\n    }\n    status = qf_parse_line_nomatch(linebuf, linelen, fields);\n    if (status != QF_OK) {\n      return status;\n    }\n    if (fmt_ptr == NULL) {\n      qfl->qf_multiline = qfl->qf_multiignore = false;\n    }\n  } else {\n    // honor %> item\n    if (fmt_ptr->conthere) {\n      fmt_start = fmt_ptr;\n    }\n\n    if (vim_strchr((char_u *)\"AEWIN\", idx) != NULL) {\n      qfl->qf_multiline = true;     // start of a multi-line message\n      qfl->qf_multiignore = false;  // reset continuation\n    } else if (vim_strchr((char_u *)\"CZ\", idx) != NULL) {\n      // continuation of multi-line msg\n      status = qf_parse_multiline_pfx(idx, qfl, fields);\n      if (status != QF_OK) {\n        return status;\n      }\n    } else if (vim_strchr((char_u *)\"OPQ\", idx) != NULL) {\n      // global file names\n      status = qf_parse_file_pfx(idx, fields, qfl, tail);\n      if (status == QF_MULTISCAN) {\n        goto restofline;\n      }\n    }\n    if (fmt_ptr->flags == '-') {  // generally exclude this line\n      if (qfl->qf_multiline) {\n        // also exclude continuation lines\n        qfl->qf_multiignore = true;\n      }\n      return QF_IGNORE_LINE;\n    }\n  }\n\n  return QF_OK;\n}\n\n// Allocate the fields used for parsing lines and populating a quickfix list.\nstatic void qf_alloc_fields(qffields_T *pfields)\n  FUNC_ATTR_NONNULL_ALL\n{\n  pfields->namebuf = xmalloc(CMDBUFFSIZE + 1);\n  pfields->module = xmalloc(CMDBUFFSIZE + 1);\n  pfields->errmsglen = CMDBUFFSIZE + 1;\n  pfields->errmsg = xmalloc(pfields->errmsglen);\n  pfields->pattern = xmalloc(CMDBUFFSIZE + 1);\n}\n\n// Free the fields used for parsing lines and populating a quickfix list.\nstatic void qf_free_fields(qffields_T *pfields)\n  FUNC_ATTR_NONNULL_ALL\n{\n  xfree(pfields->namebuf);\n  xfree(pfields->module);\n  xfree(pfields->errmsg);\n  xfree(pfields->pattern);\n}\n\n// Setup the state information used for parsing lines and populating a\n// quickfix list.\nstatic int qf_setup_state(\n    qfstate_T *pstate,\n    char_u *restrict enc,\n    const char_u *restrict efile,\n    typval_T *tv,\n    buf_T *buf,\n    linenr_T lnumfirst,\n    linenr_T lnumlast)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  pstate->vc.vc_type = CONV_NONE;\n  if (enc != NULL && *enc != NUL) {\n    convert_setup(&pstate->vc, enc, p_enc);\n  }\n\n  if (efile != NULL\n      && (pstate->fd = os_fopen((const char *)efile, \"r\")) == NULL) {\n    EMSG2(_(e_openerrf), efile);\n    return FAIL;\n  }\n\n  if (tv != NULL) {\n    if (tv->v_type == VAR_STRING) {\n      pstate->p_str = tv->vval.v_string;\n    } else if (tv->v_type == VAR_LIST) {\n      pstate->p_li = tv_list_first(tv->vval.v_list);\n    }\n    pstate->tv = tv;\n  }\n  pstate->buf = buf;\n  pstate->buflnum = lnumfirst;\n  pstate->lnumlast = lnumlast;\n\n  return OK;\n}\n\n// Cleanup the state information used for parsing lines and populating a\n// quickfix list.\nstatic void qf_cleanup_state(qfstate_T *pstate)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (pstate->fd != NULL) {\n    fclose(pstate->fd);\n  }\n  xfree(pstate->growbuf);\n  if (pstate->vc.vc_type != CONV_NONE) {\n    convert_setup(&pstate->vc, NULL, NULL);\n  }\n}\n\n// Read the errorfile \"efile\" into memory, line by line, building the error\n// list.\n// Alternative: when \"efile\" is NULL read errors from buffer \"buf\".\n// Alternative: when \"tv\" is not NULL get errors from the string or list.\n// Always use 'errorformat' from \"buf\" if there is a local value.\n// Then \"lnumfirst\" and \"lnumlast\" specify the range of lines to use.\n// Set the title of the list to \"qf_title\".\n// Return -1 for error, number of errors for success.\nstatic int\nqf_init_ext(\n    qf_info_T *qi,\n    int qf_idx,\n    const char_u *restrict efile,\n    buf_T *buf,\n    typval_T *tv,\n    char_u *restrict errorformat,\n    bool newlist,                           // true: start a new error list\n    linenr_T lnumfirst,                     // first line number to use\n    linenr_T lnumlast,                      // last line number to use\n    const char_u *restrict qf_title,\n    char_u *restrict enc\n)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  qf_list_T *qfl;\n  qfstate_T state = { 0 };\n  qffields_T fields = { 0 };\n  qfline_T        *old_last = NULL;\n  bool adding = false;\n  static efm_T    *fmt_first = NULL;\n  char_u          *efm;\n  static char_u   *last_efm = NULL;\n  int retval = -1;                      // default: return error flag\n  int status;\n\n  // Do not used the cached buffer, it may have been wiped out.\n  XFREE_CLEAR(qf_last_bufname);\n\n  qf_alloc_fields(&fields);\n  if (qf_setup_state(&state, enc, efile, tv, buf,\n                     lnumfirst, lnumlast) == FAIL) {\n    goto qf_init_end;\n  }\n\n  if (newlist || qf_idx == qi->qf_listcount) {\n    // make place for a new list\n    qf_new_list(qi, qf_title);\n    qf_idx = qi->qf_curlist;\n    qfl = qf_get_list(qi, qf_idx);\n  } else {\n    // Adding to existing list, use last entry.\n    adding = true;\n    qfl = qf_get_list(qi, qf_idx);\n    if (!qf_list_empty(qfl)) {\n      old_last = qfl->qf_last;\n    }\n  }\n\n\n  // Use the local value of 'errorformat' if it's set.\n  if (errorformat == p_efm && tv == NULL && buf && *buf->b_p_efm != NUL) {\n    efm = buf->b_p_efm;\n  } else {\n    efm = errorformat;\n  }\n\n  // If the errorformat didn't change between calls, then reuse the previously\n  // parsed values.\n  if (last_efm == NULL || (STRCMP(last_efm, efm) != 0)) {\n    // free the previously parsed data\n    XFREE_CLEAR(last_efm);\n    free_efm_list(&fmt_first);\n\n    // parse the current 'efm'\n    fmt_first = parse_efm_option(efm);\n    if (fmt_first != NULL) {\n      last_efm = vim_strsave(efm);\n    }\n  }\n\n  if (fmt_first == NULL) {      // nothing found\n    goto error2;\n  }\n\n  // got_int is reset here, because it was probably set when killing the\n  // \":make\" command, but we still want to read the errorfile then.\n  got_int = false;\n\n  // Read the lines in the error file one by one.\n  // Try to recognize one of the error formats in each line.\n  while (!got_int) {\n    status = qf_init_process_nextline(qfl, fmt_first, &state, &fields);\n    if (status == QF_END_OF_INPUT) {  // end of input\n      break;\n    }\n    if (status == QF_FAIL) {\n      goto error2;\n    }\n\n    line_breakcheck();\n  }\n  if (state.fd == NULL || !ferror(state.fd)) {\n    if (qfl->qf_index == 0) {\n      // no valid entry found\n      qfl->qf_ptr = qfl->qf_start;\n      qfl->qf_index = 1;\n      qfl->qf_nonevalid = true;\n    } else {\n      qfl->qf_nonevalid = false;\n      if (qfl->qf_ptr == NULL) {\n        qfl->qf_ptr = qfl->qf_start;\n      }\n    }\n    // return number of matches\n    retval = qfl->qf_count;\n    goto qf_init_end;\n  }\n  EMSG(_(e_readerrf));\nerror2:\n  if (!adding) {\n    // Error when creating a new list. Free the new list\n    qf_free(qfl);\n    qi->qf_listcount--;\n    if (qi->qf_curlist > 0) {\n      qi->qf_curlist--;\n    }\n  }\nqf_init_end:\n  if (qf_idx == qi->qf_curlist) {\n    qf_update_buffer(qi, old_last);\n  }\n  qf_cleanup_state(&state);\n  qf_free_fields(&fields);\n\n  return retval;\n}\n\n/// Set the title of the specified quickfix list. Frees the previous title.\n/// Prepends ':' to the title.\nstatic void qf_store_title(qf_list_T *qfl, const char_u *title)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  XFREE_CLEAR(qfl->qf_title);\n\n  if (title != NULL) {\n    size_t len = STRLEN(title) + 1;\n    char_u *p = xmallocz(len);\n\n    qfl->qf_title = p;\n    xstrlcpy((char *)p, (const char *)title, len + 1);\n  }\n}\n\n/// The title of a quickfix/location list is set, by default, to the command\n/// that created the quickfix list with the \":\" prefix.\n/// Create a quickfix list title string by prepending \":\" to a user command.\n/// Returns a pointer to a static buffer with the title.\nstatic char_u * qf_cmdtitle(char_u *cmd)\n{\n  static char_u qftitle_str[IOSIZE];\n\n  snprintf((char *)qftitle_str, IOSIZE, \":%s\", (char *)cmd);\n\n  return qftitle_str;\n}\n\n/// Return a pointer to the current list in the specified quickfix stack\nstatic qf_list_T * qf_get_curlist(qf_info_T *qi)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return qf_get_list(qi, qi->qf_curlist);\n}\n\n/// Prepare for adding a new quickfix list. If the current list is in the\n/// middle of the stack, then all the following lists are freed and then\n/// the new list is added.\nstatic void qf_new_list(qf_info_T *qi, const char_u *qf_title)\n{\n  int i;\n  qf_list_T *qfl;\n\n  // If the current entry is not the last entry, delete entries beyond\n  // the current entry.  This makes it possible to browse in a tree-like\n  // way with \":grep'.\n  while (qi->qf_listcount > qi->qf_curlist + 1) {\n    qf_free(&qi->qf_lists[--qi->qf_listcount]);\n  }\n\n  // When the stack is full, remove to oldest entry\n  // Otherwise, add a new entry.\n  if (qi->qf_listcount == LISTCOUNT) {\n    qf_free(&qi->qf_lists[0]);\n    for (i = 1; i < LISTCOUNT; i++) {\n      qi->qf_lists[i - 1] = qi->qf_lists[i];\n    }\n    qi->qf_curlist = LISTCOUNT - 1;\n  } else\n    qi->qf_curlist = qi->qf_listcount++;\n  qfl = qf_get_curlist(qi);\n  memset(qfl, 0, sizeof(qf_list_T));\n  qf_store_title(qfl, qf_title);\n  qfl->qfl_type = qi->qfl_type;\n  qfl->qf_id = ++last_qf_id;\n}\n\n/// Parse the match for filename ('%f') pattern in regmatch.\n/// Return the matched value in \"fields->namebuf\".\nstatic int qf_parse_fmt_f(regmatch_T *rmp,\n                          int midx,\n                          qffields_T *fields,\n                          int prefix)\n{\n  char_u c;\n\n  if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL) {\n    return QF_FAIL;\n  }\n\n  // Expand ~/file and $HOME/file to full path.\n  c = *rmp->endp[midx];\n  *rmp->endp[midx] = NUL;\n  expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);\n  *rmp->endp[midx] = c;\n\n  // For separate filename patterns (%O, %P and %Q), the specified file\n  // should exist.\n  if (vim_strchr((char_u *)\"OPQ\", prefix) != NULL\n      && !os_path_exists(fields->namebuf)) {\n    return QF_FAIL;\n  }\n\n  return QF_OK;\n}\n\n/// Parse the match for error number ('%n') pattern in regmatch.\n/// Return the matched value in \"fields->enr\".\nstatic int qf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->enr = (int)atol((char *)rmp->startp[midx]);\n  return QF_OK;\n}\n\n/// Parse the match for line number (%l') pattern in regmatch.\n/// Return the matched value in \"fields->lnum\".\nstatic int qf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->lnum = atol((char *)rmp->startp[midx]);\n  return QF_OK;\n}\n\n/// Parse the match for column number ('%c') pattern in regmatch.\n/// Return the matched value in \"fields->col\".\nstatic int qf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->col = (int)atol((char *)rmp->startp[midx]);\n  return QF_OK;\n}\n\n/// Parse the match for error type ('%t') pattern in regmatch.\n/// Return the matched value in \"fields->type\".\nstatic int qf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->type = *rmp->startp[midx];\n  return QF_OK;\n}\n\n/// Parse the match for '%+' format pattern. The whole matching line is included\n/// in the error string.  Return the matched line in \"fields->errmsg\".\nstatic void qf_parse_fmt_plus(const char_u *linebuf,\n                              size_t linelen,\n                              qffields_T *fields)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (linelen >= fields->errmsglen) {\n    // linelen + null terminator\n    fields->errmsg = xrealloc(fields->errmsg, linelen + 1);\n    fields->errmsglen = linelen + 1;\n  }\n  STRLCPY(fields->errmsg, linebuf, linelen + 1);\n}\n\n/// Parse the match for error message ('%m') pattern in regmatch.\n/// Return the matched value in \"fields->errmsg\".\nstatic int qf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  size_t len;\n\n  if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  len = (size_t)(rmp->endp[midx] - rmp->startp[midx]);\n  if (len >= fields->errmsglen) {\n    // len + null terminator\n    fields->errmsg = xrealloc(fields->errmsg, len + 1);\n    fields->errmsglen = len + 1;\n  }\n  STRLCPY(fields->errmsg, rmp->startp[midx], len + 1);\n  return QF_OK;\n}\n\n/// Parse the match for rest of a single-line file message ('%r') pattern.\n/// Return the matched value in \"tail\".\nstatic int qf_parse_fmt_r(regmatch_T *rmp, int midx, char_u **tail)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  *tail = rmp->startp[midx];\n  return QF_OK;\n}\n\n/// Parse the match for the pointer line ('%p') pattern in regmatch.\n/// Return the matched value in \"fields->col\".\nstatic int qf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  char_u *match_ptr;\n\n  if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->col = 0;\n  for (match_ptr = rmp->startp[midx]; match_ptr != rmp->endp[midx];\n       match_ptr++) {\n    fields->col++;\n    if (*match_ptr == TAB) {\n      fields->col += 7;\n      fields->col -= fields->col % 8;\n    }\n  }\n  fields->col++;\n  fields->use_viscol = true;\n  return QF_OK;\n}\n\n/// Parse the match for the virtual column number ('%v') pattern in regmatch.\n/// Return the matched value in \"fields->col\".\nstatic int qf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  if (rmp->startp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  fields->col = (int)atol((char *)rmp->startp[midx]);\n  fields->use_viscol = true;\n  return QF_OK;\n}\n\n/// Parse the match for the search text ('%s') pattern in regmatch.\n/// Return the matched value in \"fields->pattern\".\nstatic int qf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  size_t len;\n\n  if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  len = (size_t)(rmp->endp[midx] - rmp->startp[midx]);\n  if (len > CMDBUFFSIZE - 5) {\n    len = CMDBUFFSIZE - 5;\n  }\n  STRCPY(fields->pattern, \"^\\\\V\");\n  xstrlcat((char *)fields->pattern, (char *)rmp->startp[midx], len + 4);\n  fields->pattern[len + 3] = '\\\\';\n  fields->pattern[len + 4] = '$';\n  fields->pattern[len + 5] = NUL;\n  return QF_OK;\n}\n\n/// Parse the match for the module ('%o') pattern in regmatch.\n/// Return the matched value in \"fields->module\".\nstatic int qf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n  size_t len;\n  size_t dsize;\n\n  if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL) {\n    return QF_FAIL;\n  }\n  len = (size_t)(rmp->endp[midx] - rmp->startp[midx]);\n  dsize = STRLEN(fields->module) + len + 1;\n  if (dsize > CMDBUFFSIZE) {\n    dsize = CMDBUFFSIZE;\n  }\n  xstrlcat((char *)fields->module, (char *)rmp->startp[midx], dsize);\n  return QF_OK;\n}\n\n/// 'errorformat' format pattern parser functions.\n/// The '%f' and '%r' formats are parsed differently from other formats.\n/// See qf_parse_match() for details.\nstatic int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) = {\n  NULL,\n  qf_parse_fmt_n,\n  qf_parse_fmt_l,\n  qf_parse_fmt_c,\n  qf_parse_fmt_t,\n  qf_parse_fmt_m,\n  NULL,\n  qf_parse_fmt_p,\n  qf_parse_fmt_v,\n  qf_parse_fmt_s,\n  qf_parse_fmt_o\n};\n\n/// Parse the error format matches in 'regmatch' and set the values in 'fields'.\n/// fmt_ptr contains the 'efm' format specifiers/prefixes that have a match.\n/// Returns QF_OK if all the matches are successfully parsed. On failure,\n/// returns QF_FAIL or QF_NOMEM.\nstatic int qf_parse_match(char_u *linebuf, size_t linelen, efm_T *fmt_ptr,\n                          regmatch_T *regmatch, qffields_T *fields,\n                          int qf_multiline, int qf_multiscan, char_u **tail)\n{\n  char_u idx = fmt_ptr->prefix;\n  int i;\n  int midx;\n  int status;\n\n  if ((idx == 'C' || idx == 'Z') && !qf_multiline) {\n    return QF_FAIL;\n  }\n  if (vim_strchr((char_u *)\"EWIN\", idx) != NULL) {\n    fields->type = idx;\n  } else {\n    fields->type = 0;\n  }\n\n  // Extract error message data from matched line.\n  // We check for an actual submatch, because \"\\[\" and \"\\]\" in\n  // the 'errorformat' may cause the wrong submatch to be used.\n  for (i = 0; i < FMT_PATTERNS; i++) {\n    status = QF_OK;\n    midx = (int)fmt_ptr->addr[i];\n    if (i == 0 && midx > 0) {  // %f\n      status = qf_parse_fmt_f(regmatch, midx, fields, idx);\n    } else if (i == 5) {\n      if (fmt_ptr->flags == '+' && !qf_multiscan) {  // %+\n        qf_parse_fmt_plus(linebuf, linelen, fields);\n      } else if (midx > 0) {  // %m\n        status = qf_parse_fmt_m(regmatch, midx, fields);\n      }\n    } else if (i == 6 && midx > 0) {  // %r\n      status = qf_parse_fmt_r(regmatch, midx, tail);\n    } else if (midx > 0) {  // others\n      status = (qf_parse_fmt[i])(regmatch, midx, fields);\n    }\n\n    if (status != QF_OK) {\n      return status;\n    }\n  }\n\n  return QF_OK;\n}\n\n/// Parse an error line in 'linebuf' using a single error format string in\n/// 'fmt_ptr->prog' and return the matching values in 'fields'.\n/// Returns QF_OK if the efm format matches completely and the fields are\n/// successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\nstatic int qf_parse_get_fields(char_u *linebuf, size_t linelen, efm_T *fmt_ptr,\n                               qffields_T *fields, int qf_multiline,\n                               int qf_multiscan, char_u **tail)\n{\n  regmatch_T regmatch;\n  int status = QF_FAIL;\n  int r;\n\n  if (qf_multiscan && vim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL) {\n    return QF_FAIL;\n  }\n\n  fields->namebuf[0] = NUL;\n  fields->module[0] = NUL;\n  fields->pattern[0] = NUL;\n  if (!qf_multiscan) {\n    fields->errmsg[0] = NUL;\n  }\n  fields->lnum = 0;\n  fields->end_lnum = 0;\n  fields->col = 0;\n  fields->end_col = 0;\n  fields->use_viscol = false;\n  fields->enr = -1;\n  fields->type = 0;\n  *tail = NULL;\n\n  // Always ignore case when looking for a matching error.\n  regmatch.rm_ic = true;\n  regmatch.regprog = fmt_ptr->prog;\n  r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n  fmt_ptr->prog = regmatch.regprog;\n  if (r) {\n    status = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch, fields,\n                            qf_multiline, qf_multiscan, tail);\n  }\n\n  return status;\n}\n\n/// Parse directory error format prefixes (%D and %X).\n/// Push and pop directories from the directory stack when scanning directory\n/// names.\nstatic int qf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)\n{\n  if (idx == 'D') {  // enter directory\n    if (*fields->namebuf == NUL) {\n      EMSG(_(\"E379: Missing or empty directory name\"));\n      return QF_FAIL;\n    }\n    qfl->qf_directory = qf_push_dir(fields->namebuf, &qfl->qf_dir_stack, false);\n    if (qfl->qf_directory == NULL) {\n      return QF_FAIL;\n    }\n  } else if (idx == 'X') {  // leave directory\n    qfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);\n  }\n\n  return QF_OK;\n}\n\n/// Parse global file name error format prefixes (%O, %P and %Q).\nstatic int qf_parse_file_pfx(int idx, qffields_T *fields, qf_list_T *qfl,\n                             char_u *tail)\n{\n  fields->valid = false;\n  if (*fields->namebuf == NUL || os_path_exists(fields->namebuf)) {\n    if (*fields->namebuf && idx == 'P') {\n      qfl->qf_currfile = qf_push_dir(fields->namebuf, &qfl->qf_file_stack,\n                                     true);\n    } else if (idx == 'Q') {\n      qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n    }\n    *fields->namebuf = NUL;\n    if (tail && *tail) {\n      STRMOVE(IObuff, skipwhite(tail));\n      qfl->qf_multiscan = true;\n      return QF_MULTISCAN;\n    }\n  }\n\n  return QF_OK;\n}\n\n/// Parse a non-error line (a line which doesn't match any of the error\n/// format in 'efm').\nstatic int qf_parse_line_nomatch(char_u *linebuf, size_t linelen,\n                                 qffields_T *fields)\n{\n  fields->namebuf[0] = NUL;   // no match found, remove file name\n  fields->lnum = 0;           // don't jump to this line\n  fields->valid = false;\n  if (linelen >= fields->errmsglen) {\n    // linelen + null terminator\n    fields->errmsg = xrealloc(fields->errmsg, linelen + 1);\n    fields->errmsglen = linelen + 1;\n  }\n  // copy whole line to error message\n  STRLCPY(fields->errmsg, linebuf, linelen + 1);\n\n  return QF_OK;\n}\n\n/// Parse multi-line error format prefixes (%C and %Z)\nstatic int qf_parse_multiline_pfx(int idx, qf_list_T *qfl, qffields_T *fields)\n{\n  if (!qfl->qf_multiignore) {\n    qfline_T *qfprev = qfl->qf_last;\n\n    if (qfprev == NULL) {\n      return QF_FAIL;\n    }\n    if (*fields->errmsg) {\n      size_t textlen = strlen((char *)qfprev->qf_text);\n      size_t errlen  = strlen((char *)fields->errmsg);\n      qfprev->qf_text = xrealloc(qfprev->qf_text, textlen + errlen + 2);\n      qfprev->qf_text[textlen] = '\\n';\n      STRCPY(qfprev->qf_text + textlen + 1, fields->errmsg);\n    }\n    if (qfprev->qf_nr == -1) {\n      qfprev->qf_nr = fields->enr;\n    }\n    if (vim_isprintc(fields->type) && !qfprev->qf_type) {\n      // only printable chars allowed\n      qfprev->qf_type = fields->type;\n    }\n\n    if (!qfprev->qf_lnum) {\n      qfprev->qf_lnum = fields->lnum;\n    }\n    if (!qfprev->qf_col) {\n      qfprev->qf_col = fields->col;\n      qfprev->qf_viscol = fields->use_viscol;\n    }\n    if (!qfprev->qf_fnum) {\n      qfprev->qf_fnum = qf_get_fnum(qfl, qfl->qf_directory,\n                                    *fields->namebuf || qfl->qf_directory\n                                    ? fields->namebuf\n                                    : qfl->qf_currfile && fields->valid\n                                    ? qfl->qf_currfile : 0);\n    }\n  }\n  if (idx == 'Z') {\n    qfl->qf_multiline = qfl->qf_multiignore = false;\n  }\n  line_breakcheck();\n\n  return QF_IGNORE_LINE;\n}\n\n/// Queue location list stack delete request.\nstatic void locstack_queue_delreq(qf_info_T *qi)\n{\n  qf_delq_T *q;\n\n  q = xmalloc(sizeof(qf_delq_T));\n  q->qi = qi;\n  q->next = qf_delq_head;\n  qf_delq_head = q;\n}\n\n/// Free a location list stack\nstatic void ll_free_all(qf_info_T **pqi)\n{\n  int i;\n  qf_info_T   *qi;\n\n  qi = *pqi;\n  if (qi == NULL)\n    return;\n  *pqi = NULL;          // Remove reference to this list\n\n  qi->qf_refcount--;\n  if (qi->qf_refcount < 1) {\n    // No references to this location list.\n    // If the location list is still in use, then queue the delete request\n    // to be processed later.\n    if (quickfix_busy > 0) {\n      locstack_queue_delreq(qi);\n    } else {\n      for (i = 0; i < qi->qf_listcount; i++) {\n        qf_free(qf_get_list(qi, i));\n      }\n      xfree(qi);\n    }\n  }\n}\n\n/// Free all the quickfix/location lists in the stack.\nvoid qf_free_all(win_T *wp)\n{\n  int i;\n  qf_info_T   *qi = &ql_info;\n\n  if (wp != NULL) {\n    // location list\n    ll_free_all(&wp->w_llist);\n    ll_free_all(&wp->w_llist_ref);\n  } else {\n    // quickfix list\n    for (i = 0; i < qi->qf_listcount; i++) {\n      qf_free(qf_get_list(qi, i));\n    }\n  }\n}\n\n/// Delay freeing of location list stacks when the quickfix code is running.\n/// Used to avoid problems with autocmds freeing location list stacks when the\n/// quickfix code is still referencing the stack.\n/// Must always call decr_quickfix_busy() exactly once after this.\nstatic void incr_quickfix_busy(void)\n{\n    quickfix_busy++;\n}\n\n/// Safe to free location list stacks. Process any delayed delete requests.\nstatic void decr_quickfix_busy(void)\n{\n  quickfix_busy--;\n  if (quickfix_busy == 0) {\n    // No longer referencing the location lists. Process all the pending\n    // delete requests.\n    while (qf_delq_head != NULL) {\n      qf_delq_T *q = qf_delq_head;\n\n      qf_delq_head = q->next;\n      ll_free_all(&q->qi);\n      xfree(q);\n    }\n  }\n#ifdef ABORT_ON_INTERNAL_ERROR\n  if (quickfix_busy < 0) {\n    EMSG(\"quickfix_busy has become negative\");\n    abort();\n  }\n#endif\n}\n\n#if defined(EXITFREE)\nvoid check_quickfix_busy(void)\n{\n  if (quickfix_busy != 0) {\n    EMSGN(\"quickfix_busy not zero on exit: %\" PRId64, (int64_t)quickfix_busy);\n# ifdef ABORT_ON_INTERNAL_ERROR\n    abort();\n# endif\n  }\n}\n#endif\n\n/// Add an entry to the end of the list of errors.\n///\n/// @param  qfl      quickfix list entry\n/// @param  dir      optional directory name\n/// @param  fname    file name or NULL\n/// @param  module   module name or NULL\n/// @param  bufnum   buffer number or zero\n/// @param  mesg     message\n/// @param  lnum     line number\n/// @param  end_lnum  line number for end\n/// @param  col      column\n/// @param  end_col  column for end\n/// @param  vis_col  using visual column\n/// @param  pattern  search pattern\n/// @param  nr       error number\n/// @param  type     type character\n/// @param  valid    valid entry\n///\n/// @returns QF_OK or QF_FAIL.\nstatic int qf_add_entry(qf_list_T *qfl, char_u *dir, char_u *fname,\n                        char_u *module, int bufnum, char_u *mesg,\n                        long lnum, long end_lnum, int col, int end_col,\n                        char_u vis_col, char_u *pattern, int nr,\n                        char_u type, char_u valid)\n{\n  qfline_T *qfp = xmalloc(sizeof(qfline_T));\n  qfline_T **lastp;  // pointer to qf_last or NULL\n\n  if (bufnum != 0) {\n    buf_T *buf = buflist_findnr(bufnum);\n\n    qfp->qf_fnum = bufnum;\n    if (buf != NULL) {\n      buf->b_has_qf_entry |=\n        IS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    }\n  } else {\n    qfp->qf_fnum = qf_get_fnum(qfl, dir, fname);\n  }\n  qfp->qf_text = vim_strsave(mesg);\n  qfp->qf_lnum = lnum;\n  qfp->qf_end_lnum = end_lnum;\n  qfp->qf_col = col;\n  qfp->qf_end_col = end_col;\n  qfp->qf_viscol = vis_col;\n  if (pattern == NULL || *pattern == NUL) {\n    qfp->qf_pattern = NULL;\n  } else {\n    qfp->qf_pattern = vim_strsave(pattern);\n  }\n  if (module == NULL || *module == NUL) {\n    qfp->qf_module = NULL;\n  } else {\n    qfp->qf_module = vim_strsave(module);\n  }\n  qfp->qf_nr = nr;\n  if (type != 1 && !vim_isprintc(type)) {  // only printable chars allowed\n    type = 0;\n  }\n  qfp->qf_type = (char_u)type;\n  qfp->qf_valid = valid;\n\n  lastp = &qfl->qf_last;\n  if (qf_list_empty(qfl)) {\n    // first element in the list\n    qfl->qf_start = qfp;\n    qfl->qf_ptr = qfp;\n    qfl->qf_index = 0;\n    qfp->qf_prev = NULL;\n  } else {\n    assert(*lastp);\n    qfp->qf_prev = *lastp;\n    (*lastp)->qf_next = qfp;\n  }\n  qfp->qf_next = NULL;\n  qfp->qf_cleared = false;\n  *lastp = qfp;\n  qfl->qf_count++;\n  if (qfl->qf_index == 0 && qfp->qf_valid) {\n    // first valid entry\n    qfl->qf_index = qfl->qf_count;\n    qfl->qf_ptr = qfp;\n  }\n\n  return QF_OK;\n}\n\n/// Allocate a new quickfix/location list stack\nstatic qf_info_T *qf_alloc_stack(qfltype_T qfltype)\n  FUNC_ATTR_NONNULL_RET\n{\n  qf_info_T *qi = xcalloc(1, sizeof(qf_info_T));\n  qi->qf_refcount++;\n  qi->qfl_type = qfltype;\n\n  return qi;\n}\n\n/// Return the location list stack for window 'wp'.\n/// If not present, allocate a location list stack\nstatic qf_info_T *ll_get_or_alloc_list(win_T *wp)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  if (IS_LL_WINDOW(wp)) {\n    // For a location list window, use the referenced location list\n    return wp->w_llist_ref;\n  }\n\n  // For a non-location list window, w_llist_ref should not point to a\n  // location list.\n  ll_free_all(&wp->w_llist_ref);\n\n  if (wp->w_llist == NULL) {\n    wp->w_llist = qf_alloc_stack(QFLT_LOCATION);  // new location list\n  }\n  return wp->w_llist;\n}\n\n/// Get the quickfix/location list stack to use for the specified Ex command.\n/// For a location list command, returns the stack for the current window.  If\n/// the location list is not found, then returns NULL and prints an error\n/// message if 'print_emsg' is TRUE.\nstatic qf_info_T * qf_cmd_get_stack(exarg_T *eap, int print_emsg)\n{\n  qf_info_T *qi = &ql_info;\n\n  if (is_loclist_cmd(eap->cmdidx)) {\n    qi = GET_LOC_LIST(curwin);\n    if (qi == NULL) {\n      if (print_emsg) {\n        EMSG(_(e_loclist));\n      }\n      return NULL;\n    }\n  }\n\n  return qi;\n}\n\n/// Get the quickfix/location list stack to use for the specified Ex command.\n/// For a location list command, returns the stack for the current window.\n/// If the location list is not present, then allocates a new one.\n/// For a location list command, sets 'pwinp' to curwin.\nstatic qf_info_T *qf_cmd_get_or_alloc_stack(const exarg_T *eap, win_T **pwinp)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  qf_info_T *qi = &ql_info;\n\n  if (is_loclist_cmd(eap->cmdidx)) {\n    qi = ll_get_or_alloc_list(curwin);\n    *pwinp = curwin;\n  }\n\n  return qi;\n}\n\n/// Copy location list entries from 'from_qfl' to 'to_qfl'.\nstatic int copy_loclist_entries(const qf_list_T *from_qfl, qf_list_T *to_qfl)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int i;\n  qfline_T *from_qfp;\n\n  // copy all the location entries in this list\n  FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i) {\n    if (qf_add_entry(to_qfl,\n                     NULL,\n                     NULL,\n                     from_qfp->qf_module,\n                     0,\n                     from_qfp->qf_text,\n                     from_qfp->qf_lnum,\n                     from_qfp->qf_end_lnum,\n                     from_qfp->qf_col,\n                     from_qfp->qf_end_col,\n                     from_qfp->qf_viscol,\n                     from_qfp->qf_pattern,\n                     from_qfp->qf_nr,\n                     0,\n                     from_qfp->qf_valid) == QF_FAIL) {\n      return FAIL;\n    }\n\n    // qf_add_entry() will not set the qf_num field, as the\n    // directory and file names are not supplied. So the qf_fnum\n    // field is copied here.\n    qfline_T *const prevp = to_qfl->qf_last;\n    prevp->qf_fnum = from_qfp->qf_fnum;  // file number\n    prevp->qf_type = from_qfp->qf_type;  // error type\n    if (from_qfl->qf_ptr == from_qfp) {\n      to_qfl->qf_ptr = prevp;  // current location\n    }\n  }\n\n  return OK;\n}\n\n/// Copy the specified location list 'from_qfl' to 'to_qfl'.\nstatic int copy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Some of the fields are populated by qf_add_entry()\n  to_qfl->qfl_type = from_qfl->qfl_type;\n  to_qfl->qf_nonevalid = from_qfl->qf_nonevalid;\n  to_qfl->qf_count = 0;\n  to_qfl->qf_index = 0;\n  to_qfl->qf_start = NULL;\n  to_qfl->qf_last = NULL;\n  to_qfl->qf_ptr = NULL;\n  if (from_qfl->qf_title != NULL) {\n    to_qfl->qf_title = vim_strsave(from_qfl->qf_title);\n  } else {\n    to_qfl->qf_title = NULL;\n  }\n  if (from_qfl->qf_ctx != NULL) {\n    to_qfl->qf_ctx = xcalloc(1, sizeof(*to_qfl->qf_ctx));\n    tv_copy(from_qfl->qf_ctx, to_qfl->qf_ctx);\n  } else {\n    to_qfl->qf_ctx = NULL;\n  }\n  callback_copy(&to_qfl->qftf_cb, &from_qfl->qftf_cb);\n\n  if (from_qfl->qf_count) {\n    if (copy_loclist_entries(from_qfl, to_qfl) == FAIL) {\n      return FAIL;\n    }\n  }\n\n  to_qfl->qf_index = from_qfl->qf_index;  // current index in the list\n\n  // Assign a new ID for the location list\n  to_qfl->qf_id = ++last_qf_id;\n  to_qfl->qf_changedtick = 0L;\n\n  // When no valid entries are present in the list, qf_ptr points to\n  // the first item in the list\n  if (to_qfl->qf_nonevalid) {\n    to_qfl->qf_ptr = to_qfl->qf_start;\n    to_qfl->qf_index = 1;\n  }\n\n  return OK;\n}\n\n// Copy the location list stack 'from' window to 'to' window.\nvoid copy_loclist_stack(win_T *from, win_T *to)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_info_T *qi;\n\n  // When copying from a location list window, copy the referenced\n  // location list. For other windows, copy the location list for\n  // that window.\n  if (IS_LL_WINDOW(from)) {\n    qi = from->w_llist_ref;\n  } else {\n    qi = from->w_llist;\n  }\n\n  if (qi == NULL) {                 // no location list to copy\n    return;\n  }\n\n  // allocate a new location list\n  to->w_llist = qf_alloc_stack(QFLT_LOCATION);\n\n  to->w_llist->qf_listcount = qi->qf_listcount;\n\n  // Copy the location lists one at a time\n  for (int idx = 0; idx < qi->qf_listcount; idx++) {\n    to->w_llist->qf_curlist = idx;\n\n    if (copy_loclist(qf_get_list(qi, idx),\n                     qf_get_list(to->w_llist, idx)) == FAIL) {\n      qf_free_all(to);\n      return;\n    }\n  }\n\n  to->w_llist->qf_curlist = qi->qf_curlist;  // current list\n}\n\n/// Get buffer number for file \"directory/fname\".\n/// Also sets the b_has_qf_entry flag.\nstatic int qf_get_fnum(qf_list_T *qfl, char_u *directory, char_u *fname )\n{\n  char_u *ptr = NULL;\n  char_u *bufname;\n  buf_T *buf;\n  if (fname == NULL || *fname == NUL) {         // no file name\n    return 0;\n  }\n\n#ifdef BACKSLASH_IN_FILENAME\n  if (directory != NULL) {\n    slash_adjust(directory);\n  }\n  slash_adjust(fname);\n#endif\n  if (directory != NULL && !vim_isAbsName(fname)) {\n    ptr = (char_u *)concat_fnames((char *)directory, (char *)fname, true);\n    // Here we check if the file really exists.\n    // This should normally be true, but if make works without\n    // \"leaving directory\"-messages we might have missed a\n    // directory change.\n    if (!os_path_exists(ptr)) {\n      xfree(ptr);\n      directory = qf_guess_filepath(qfl, fname);\n      if (directory) {\n        ptr = (char_u *)concat_fnames((char *)directory, (char *)fname, true);\n      } else {\n        ptr = vim_strsave(fname);\n      }\n    }\n    // Use concatenated directory name and file name.\n    bufname = ptr;\n  } else {\n    bufname = fname;\n  }\n\n  if (qf_last_bufname != NULL\n      && STRCMP(bufname, qf_last_bufname) == 0\n      && bufref_valid(&qf_last_bufref)) {\n    buf = qf_last_bufref.br_buf;\n    xfree(ptr);\n  } else {\n    xfree(qf_last_bufname);\n    buf = buflist_new(bufname, NULL, (linenr_T)0, BLN_NOOPT);\n    qf_last_bufname = (bufname == ptr) ? bufname : vim_strsave(bufname);\n    set_bufref(&qf_last_bufref, buf);\n  }\n  if (buf == NULL) {\n    return 0;\n  }\n  buf->b_has_qf_entry =\n    IS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n  return buf->b_fnum;\n}\n\n// Push dirbuf onto the directory stack and return pointer to actual dir or\n// NULL on error.\nstatic char_u *qf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr,\n                           bool is_file_stack)\n{\n  struct dir_stack_T  *ds_ptr;\n\n  // allocate new stack element and hook it in\n  struct dir_stack_T *ds_new = xmalloc(sizeof(struct dir_stack_T));\n\n  ds_new->next = *stackptr;\n  *stackptr = ds_new;\n\n  // store directory on the stack\n  if (vim_isAbsName(dirbuf)\n      || (*stackptr)->next == NULL\n      || (*stackptr && is_file_stack)) {\n    (*stackptr)->dirname = vim_strsave(dirbuf);\n  } else {\n    // Okay we don't have an absolute path.\n    // dirbuf must be a subdir of one of the directories on the stack.\n    // Let's search...\n    ds_new = (*stackptr)->next;\n    (*stackptr)->dirname = NULL;\n    while (ds_new) {\n      xfree((*stackptr)->dirname);\n      (*stackptr)->dirname = (char_u *)concat_fnames((char *)ds_new->dirname,\n          (char *)dirbuf, TRUE);\n      if (os_isdir((*stackptr)->dirname))\n        break;\n\n      ds_new = ds_new->next;\n    }\n\n    // clean up all dirs we already left\n    while ((*stackptr)->next != ds_new) {\n      ds_ptr = (*stackptr)->next;\n      (*stackptr)->next = (*stackptr)->next->next;\n      xfree(ds_ptr->dirname);\n      xfree(ds_ptr);\n    }\n\n    // Nothing found -> it must be on top level\n    if (ds_new == NULL) {\n      xfree((*stackptr)->dirname);\n      (*stackptr)->dirname = vim_strsave(dirbuf);\n    }\n  }\n\n  if ((*stackptr)->dirname != NULL)\n    return (*stackptr)->dirname;\n  else {\n    ds_ptr = *stackptr;\n    *stackptr = (*stackptr)->next;\n    xfree(ds_ptr);\n    return NULL;\n  }\n}\n\n\n// pop dirbuf from the directory stack and return previous directory or NULL if\n// stack is empty\nstatic char_u *qf_pop_dir(struct dir_stack_T **stackptr)\n{\n  struct dir_stack_T  *ds_ptr;\n\n  // TODO(vim): Should we check if dirbuf is the directory on top of the stack?\n  // What to do if it isn't?\n\n  // pop top element and free it\n  if (*stackptr != NULL) {\n    ds_ptr = *stackptr;\n    *stackptr = (*stackptr)->next;\n    xfree(ds_ptr->dirname);\n    xfree(ds_ptr);\n  }\n\n  // return NEW top element as current dir or NULL if stack is empty\n  return *stackptr ? (*stackptr)->dirname : NULL;\n}\n\n// clean up directory stack\nstatic void qf_clean_dir_stack(struct dir_stack_T **stackptr)\n{\n  struct dir_stack_T  *ds_ptr;\n\n  while ((ds_ptr = *stackptr) != NULL) {\n    *stackptr = (*stackptr)->next;\n    xfree(ds_ptr->dirname);\n    xfree(ds_ptr);\n  }\n}\n\n/// Check in which directory of the directory stack the given file can be\n/// found.\n/// Returns a pointer to the directory name or NULL if not found.\n/// Cleans up intermediate directory entries.\n///\n/// TODO(vim): How to solve the following problem?\n/// If we have this directory tree:\n///     ./\n///     ./aa\n///     ./aa/bb\n///     ./bb\n///     ./bb/x.c\n/// and make says:\n///     making all in aa\n///     making all in bb\n///     x.c:9: Error\n/// Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.\n/// qf_guess_filepath will return NULL.\nstatic char_u *qf_guess_filepath(qf_list_T *qfl, char_u *filename)\n{\n  struct dir_stack_T     *ds_ptr;\n  struct dir_stack_T     *ds_tmp;\n  char_u                 *fullname;\n\n  // no dirs on the stack - there's nothing we can do\n  if (qfl->qf_dir_stack == NULL) {\n    return NULL;\n  }\n\n  ds_ptr = qfl->qf_dir_stack->next;\n  fullname = NULL;\n  while (ds_ptr) {\n    xfree(fullname);\n    fullname = (char_u *)concat_fnames((char *)ds_ptr->dirname, (char *)filename, TRUE);\n\n    if (os_path_exists(fullname)) {\n      break;\n    }\n\n    ds_ptr = ds_ptr->next;\n  }\n\n  xfree(fullname);\n\n  // clean up all dirs we already left\n  while (qfl->qf_dir_stack->next != ds_ptr) {\n    ds_tmp = qfl->qf_dir_stack->next;\n    qfl->qf_dir_stack->next = qfl->qf_dir_stack->next->next;\n    xfree(ds_tmp->dirname);\n    xfree(ds_tmp);\n  }\n\n  return ds_ptr == NULL ? NULL : ds_ptr->dirname;\n}\n\n/// Returns true, if a quickfix/location list with the given identifier exists.\nstatic bool qflist_valid(win_T *wp, unsigned int qf_id)\n{\n  qf_info_T *qi = &ql_info;\n\n  if (wp) {\n    qi = GET_LOC_LIST(wp);\n    if (!qi) {\n      return false;\n    }\n  }\n\n  for (int i = 0; i < qi->qf_listcount; i++) {\n    if (qi->qf_lists[i].qf_id == qf_id) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// When loading a file from the quickfix, the autocommands may modify it.\n/// This may invalidate the current quickfix entry.  This function checks\n/// whether an entry is still present in the quickfix list.\n/// Similar to location list.\nstatic bool is_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)\n{\n  qfline_T *qfp;\n  int i;\n\n  // Search for the entry in the current list\n  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n    if (qfp == qf_ptr) {\n      break;\n    }\n  }\n\n  if (i > qfl->qf_count) {  // Entry is not found\n    return false;\n  }\n\n  return true;\n}\n\n/// Get the next valid entry in the current quickfix/location list. The search\n/// starts from the current entry. Returns NULL on failure.\nstatic qfline_T *get_next_valid_entry(qf_list_T *qfl, qfline_T *qf_ptr,\n                                      int *qf_index, int dir)\n{\n  int idx = *qf_index;\n  int old_qf_fnum = qf_ptr->qf_fnum;\n\n  do {\n    if (idx == qfl->qf_count || qf_ptr->qf_next == NULL) {\n      return NULL;\n    }\n    idx++;\n    qf_ptr = qf_ptr->qf_next;\n  } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n           || (dir == FORWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n  *qf_index = idx;\n  return qf_ptr;\n}\n\n/// Get the previous valid entry in the current quickfix/location list. The\n/// search starts from the current entry. Returns NULL on failure.\nstatic qfline_T *get_prev_valid_entry(qf_list_T *qfl, qfline_T *qf_ptr,\n                                      int *qf_index, int dir)\n{\n  int idx = *qf_index;\n  int old_qf_fnum = qf_ptr->qf_fnum;\n\n  do {\n    if (idx == 1 || qf_ptr->qf_prev == NULL) {\n      return NULL;\n    }\n    idx--;\n    qf_ptr = qf_ptr->qf_prev;\n  } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n           || (dir == BACKWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n  *qf_index = idx;\n  return qf_ptr;\n}\n\n/// Get the n'th (errornr) previous/next valid entry from the current entry in\n/// the quickfix list.\n///   dir == FORWARD or FORWARD_FILE: next valid entry\n///   dir == BACKWARD or BACKWARD_FILE: previous valid entry\nstatic qfline_T *get_nth_valid_entry(qf_list_T *qfl, int errornr,\n                                     int dir, int *new_qfidx)\n{\n  qfline_T *qf_ptr = qfl->qf_ptr;\n  int qf_idx = qfl->qf_index;\n  qfline_T *prev_qf_ptr;\n  int prev_index;\n  char_u *err = e_no_more_items;\n\n  while (errornr--) {\n    prev_qf_ptr = qf_ptr;\n    prev_index = qf_idx;\n\n    if (dir == FORWARD || dir == FORWARD_FILE) {\n      qf_ptr = get_next_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n    } else {\n      qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n    }\n\n    if (qf_ptr == NULL) {\n      qf_ptr = prev_qf_ptr;\n      qf_idx = prev_index;\n      if (err != NULL) {\n        EMSG(_(err));\n        return NULL;\n      }\n      break;\n    }\n\n    err = NULL;\n  }\n\n  *new_qfidx = qf_idx;\n  return qf_ptr;\n}\n\n/// Get n'th (errornr) quickfix entry from the current entry in the quickfix\n/// list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'\nstatic qfline_T *get_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)\n{\n  qfline_T *qf_ptr = qfl->qf_ptr;\n  int qf_idx = qfl->qf_index;;\n\n  // New error number is less than the current error number\n  while (errornr < qf_idx && qf_idx > 1 && qf_ptr->qf_prev != NULL) {\n    qf_idx--;\n    qf_ptr = qf_ptr->qf_prev;\n  }\n\n  // New error number is greater than the current error number\n  while (errornr > qf_idx\n         && qf_idx < qfl->qf_count\n         && qf_ptr->qf_next != NULL) {\n    qf_idx++;\n    qf_ptr = qf_ptr->qf_next;\n  }\n\n  *new_qfidx = qf_idx;\n  return qf_ptr;\n}\n\n/// Get a entry specified by 'errornr' and 'dir' from the current\n/// quickfix/location list. 'errornr' specifies the index of the entry and 'dir'\n/// specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).\n/// Returns a pointer to the entry and the index of the new entry is stored in\n/// 'new_qfidx'.\nstatic qfline_T * qf_get_entry(qf_list_T *qfl, int errornr,\n                               int dir, int *new_qfidx)\n{\n    qfline_T *qf_ptr = qfl->qf_ptr;\n    int qfidx = qfl->qf_index;\n\n    if (dir != 0) {  // next/prev valid entry\n      qf_ptr = get_nth_valid_entry(qfl, errornr, dir, &qfidx);\n    } else if (errornr != 0) {  // go to specified number\n      qf_ptr = get_nth_entry(qfl, errornr, &qfidx);\n    }\n\n    *new_qfidx = qfidx;\n     return qf_ptr;\n}\n\n// Find a window displaying a Vim help file.\nstatic win_T *qf_find_help_win(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (bt_help(wp->w_buffer)) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n/// Set the location list for the specified window to 'qi'.\nstatic void win_set_loclist(win_T *wp, qf_info_T *qi)\n{\n  wp->w_llist = qi;\n  qi->qf_refcount++;\n}\n\n/// Find a help window or open one. If 'newwin' is true, then open a new help\n/// window.\nstatic int jump_to_help_window(qf_info_T *qi, bool newwin, int *opened_window)\n{\n  win_T *wp = NULL;\n\n  if (cmdmod.tab != 0 || newwin) {\n    wp = NULL;\n  } else {\n    wp = qf_find_help_win();\n  }\n\n  if (wp != NULL && wp->w_buffer->b_nwindows > 0) {\n    win_enter(wp, true);\n  } else {\n    // Split off help window; put it at far top if no position\n    // specified, the current window is vertically split and narrow.\n    int flags = WSP_HELP;\n    if (cmdmod.split == 0\n        && curwin->w_width != Columns\n        && curwin->w_width < 80) {\n      flags |= WSP_TOP;\n    }\n\n    // If the user asks to open a new window, then copy the location list.\n    // Otherwise, don't copy the location list.\n    if (IS_LL_STACK(qi) && !newwin) {\n      flags |= WSP_NEWLOC;\n    }\n\n    if (win_split(0, flags) == FAIL) {\n      return FAIL;\n    }\n\n    *opened_window = true;\n\n    if (curwin->w_height < p_hh) {\n      win_setheight((int)p_hh);\n    }\n\n    // When using location list, the new window should use the supplied\n    // location list. If the user asks to open a new window, then the new\n    // window will get a copy of the location list.\n    if (IS_LL_STACK(qi) && !newwin) {\n      win_set_loclist(curwin, qi);\n    }\n  }\n\n  if (!p_im) {\n    restart_edit = 0;  // don't want insert mode in help file\n  }\n\n  return OK;\n}\n\n// Find a non-quickfix window using the given location list.\n// Returns NULL if a matching window is not found.\nstatic win_T *qf_find_win_with_loclist(const qf_info_T *ll)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (wp->w_llist == ll && !bt_quickfix(wp->w_buffer)) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n// Find a window containing a normal buffer\nstatic win_T *qf_find_win_with_normal_buf(void)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if (bt_normal(wp->w_buffer)) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n// Go to a window in any tabpage containing the specified file.  Returns true\n// if successfully jumped to the window. Otherwise returns FALSE.\nstatic bool qf_goto_tabwin_with_file(int fnum)\n{\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_buffer->b_fnum == fnum) {\n      goto_tabpage_win(tp, wp);\n      return true;\n    }\n  }\n  return false;\n}\n\n// Create a new window to show a file above the quickfix window. Called when\n// only the quickfix window is present.\nstatic int qf_open_new_file_win(qf_info_T *ll_ref)\n{\n  int flags = WSP_ABOVE;\n  if (ll_ref != NULL) {\n    flags |= WSP_NEWLOC;\n  }\n  if (win_split(0, flags) == FAIL) {\n    return FAIL;  // not enough room for window\n  }\n  p_swb = empty_option;  // don't split again\n  swb_flags = 0;\n  RESET_BINDING(curwin);\n  if (ll_ref != NULL) {\n    // The new window should use the location list from the\n    // location list window\n    win_set_loclist(curwin, ll_ref);\n  }\n  return OK;\n}\n\n// Go to a window that shows the right buffer. If the window is not found, go\n// to the window just above the location list window. This is used for opening\n// a file from a location window and not from a quickfix window. If some usable\n// window is previously found, then it is supplied in 'use_win'.\nstatic void qf_goto_win_with_ll_file(win_T *use_win, int qf_fnum,\n                                     qf_info_T *ll_ref)\n{\n  win_T *win = use_win;\n\n  if (win == NULL) {\n    // Find the window showing the selected file\n    FOR_ALL_WINDOWS_IN_TAB(win2, curtab) {\n      if (win2->w_buffer->b_fnum == qf_fnum) {\n        win = win2;\n        break;\n      }\n    }\n    if (win == NULL) {\n      // Find a previous usable window\n      win = curwin;\n      do {\n        if (bt_normal(win->w_buffer)) {\n          break;\n        }\n        if (win->w_prev == NULL) {\n          win = lastwin;      // wrap around the top\n        } else {\n          win = win->w_prev;  // go to previous window\n        }\n      } while (win != curwin);\n    }\n  }\n  win_goto(win);\n\n  // If the location list for the window is not set, then set it\n  // to the location list from the location window\n  if (win->w_llist == NULL && ll_ref != NULL) {\n    // The new window should use the location list from the\n    // location list window\n    win_set_loclist(win, ll_ref);\n  }\n}\n\n// Go to a window that shows the specified file. If a window is not found, go\n// to the window just above the quickfix window. This is used for opening a\n// file from a quickfix window and not from a location window.\nstatic void qf_goto_win_with_qfl_file(int qf_fnum)\n{\n  win_T *win = curwin;\n  win_T *altwin = NULL;\n  for (;;) {\n    if (win->w_buffer->b_fnum == qf_fnum) {\n      break;\n    }\n    if (win->w_prev == NULL) {\n      win = lastwin;      // wrap around the top\n    } else {\n      win = win->w_prev;  // go to previous window\n    }\n\n    if (IS_QF_WINDOW(win)) {\n      // Didn't find it, go to the window before the quickfix\n      // window, unless 'switchbuf' contains 'uselast': in this case we\n      // try to jump to the previously used window first.\n      if ((swb_flags & SWB_USELAST) && win_valid(prevwin)) {\n        win = prevwin;\n      } else if (altwin != NULL) {\n        win = altwin;\n      } else if (curwin->w_prev != NULL) {\n        win = curwin->w_prev;\n      } else {\n        win = curwin->w_next;\n      }\n      break;\n    }\n\n    // Remember a usable window.\n    if (altwin == NULL\n        && !win->w_p_pvw\n        && bt_normal(win->w_buffer)) {\n      altwin = win;\n    }\n  }\n\n  win_goto(win);\n}\n\n// Find a suitable window for opening a file (qf_fnum) from the\n// quickfix/location list and jump to it.  If the file is already opened in a\n// window, jump to it. Otherwise open a new window to display the file. If\n// 'newwin' is true, then always open a new window. This is called from either\n// a quickfix or a location list window.\nstatic int qf_jump_to_usable_window(int qf_fnum, bool newwin,\n                                    int *opened_window)\n{\n  win_T *usable_wp = NULL;\n  bool usable_win = false;\n\n  // If opening a new window, then don't use the location list referred by\n  // the current window.  Otherwise two windows will refer to the same\n  // location list.\n  qf_info_T *ll_ref = newwin ? NULL : curwin->w_llist_ref;\n  if (ll_ref != NULL) {\n    // Find a non-quickfix window with this location list\n    usable_wp = qf_find_win_with_loclist(ll_ref);\n    if (usable_wp != NULL) {\n      usable_win = true;\n    }\n  }\n\n  if (!usable_win) {\n    // Locate a window showing a normal buffer\n    win_T *win = qf_find_win_with_normal_buf();\n    if (win != NULL) {\n      usable_win = true;\n    }\n  }\n\n  // If no usable window is found and 'switchbuf' contains \"usetab\"\n  // then search in other tabs.\n  if (!usable_win && (swb_flags & SWB_USETAB)) {\n    usable_win = qf_goto_tabwin_with_file(qf_fnum);\n  }\n\n  // If there is only one window and it is the quickfix window, create a\n  // new one above the quickfix window.\n  if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win || newwin) {\n    if (qf_open_new_file_win(ll_ref) != OK) {\n      return FAIL;\n    }\n    *opened_window = true;  // close it when fail\n  } else {\n    if (curwin->w_llist_ref != NULL) {  // In a location window\n      qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);\n    } else {  // In a quickfix window\n      qf_goto_win_with_qfl_file(qf_fnum);\n    }\n  }\n\n  return OK;\n}\n\n/// Edit the selected file or help file.\nstatic int qf_jump_edit_buffer(qf_info_T *qi, qfline_T *qf_ptr, int forceit,\n                               win_T *oldwin, int *opened_window)\n{\n  qf_list_T *qfl = qf_get_curlist(qi);\n  long old_changetick = qfl->qf_changedtick;\n  int old_qf_curlist = qi->qf_curlist;\n  qfltype_T qfl_type = qfl->qfl_type;\n  int retval = OK;\n  unsigned save_qfid = qfl->qf_id;\n\n  if (qf_ptr->qf_type == 1) {\n    // Open help file (do_ecmd() will set b_help flag, readfile() will\n    // set b_p_ro flag).\n    if (!can_abandon(curbuf, forceit)) {\n      no_write_message();\n      return FAIL;\n    } else {\n      retval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,\n                       ECMD_HIDE + ECMD_SET_HELP,\n                       oldwin == curwin ? curwin : NULL);\n    }\n  } else {\n    retval = buflist_getfile(qf_ptr->qf_fnum, (linenr_T)1,\n                             GETF_SETMARK | GETF_SWITCH, forceit);\n  }\n  // If a location list, check whether the associated window is still\n  // present.\n  if (qfl_type == QFLT_LOCATION && !win_valid_any_tab(oldwin)) {\n    EMSG(_(\"E924: Current window was closed\"));\n    *opened_window = false;\n    return NOTDONE;\n  }\n\n  if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid)) {\n    EMSG(_(e_current_quickfix_list_was_changed));\n    return NOTDONE;\n  }\n\n  if (old_qf_curlist != qi->qf_curlist\n      || old_changetick != qfl->qf_changedtick\n      || !is_qf_entry_present(qfl, qf_ptr)) {\n    if (qfl_type == QFLT_QUICKFIX) {\n      EMSG(_(e_current_quickfix_list_was_changed));\n    } else {\n      EMSG(_(e_current_location_list_was_changed));\n    }\n    return NOTDONE;\n  }\n\n  return retval;\n}\n\n/// Go to the error line in the current file using either line/column number or\n/// a search pattern.\nstatic void qf_jump_goto_line(linenr_T qf_lnum, int qf_col, char_u qf_viscol,\n                              char_u *qf_pattern)\n{\n  linenr_T i;\n\n  if (qf_pattern == NULL) {\n    // Go to line with error, unless qf_lnum is 0.\n    i = qf_lnum;\n    if (i > 0) {\n      if (i > curbuf->b_ml.ml_line_count) {\n        i = curbuf->b_ml.ml_line_count;\n      }\n      curwin->w_cursor.lnum = i;\n    }\n    if (qf_col > 0) {\n      curwin->w_cursor.coladd = 0;\n      if (qf_viscol == true) {\n        coladvance(qf_col - 1);\n      } else {\n        curwin->w_cursor.col = qf_col - 1;\n      }\n      curwin->w_set_curswant = true;\n      check_cursor();\n    } else {\n      beginline(BL_WHITE | BL_FIX);\n    }\n  } else {\n    // Move the cursor to the first line in the buffer\n    pos_T save_cursor = curwin->w_cursor;\n    curwin->w_cursor.lnum = 0;\n    if (!do_search(NULL, '/', '/', qf_pattern, (long)1, SEARCH_KEEP, NULL)) {\n      curwin->w_cursor = save_cursor;\n    }\n  }\n}\n\n/// Display quickfix list index and size message\nstatic void qf_jump_print_msg(qf_info_T *qi, int qf_index, qfline_T *qf_ptr,\n                              buf_T *old_curbuf, linenr_T old_lnum)\n{\n  // Update the screen before showing the message, unless the screen\n  // scrolled up.\n  if (!msg_scrolled) {\n    update_topline_redraw();\n  }\n  snprintf((char *)IObuff, IOSIZE, _(\"(%d of %d)%s%s: \"), qf_index,\n           qf_get_curlist(qi)->qf_count,\n           qf_ptr->qf_cleared ? _(\" (line deleted)\") : \"\",\n           (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));\n  // Add the message, skipping leading whitespace and newlines.\n  int len = (int)STRLEN(IObuff);\n  qf_fmt_text(skipwhite(qf_ptr->qf_text), IObuff + len, IOSIZE - len);\n\n  // Output the message.  Overwrite to avoid scrolling when the 'O'\n  // flag is present in 'shortmess'; But when not jumping, print the\n  // whole message.\n  linenr_T i = msg_scroll;\n  if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum) {\n    msg_scroll = true;\n  } else if (!msg_scrolled && shortmess(SHM_OVERALL)) {\n    msg_scroll = false;\n  }\n  msg_ext_set_kind(\"quickfix\");\n  msg_attr_keep(IObuff, 0, true, false);\n  msg_scroll = (int)i;\n}\n\n/// Find a usable window for opening a file from the quickfix/location list. If\n/// a window is not found then open a new window. If 'newwin' is true, then open\n/// a new window.\n/// Returns OK if successfully jumped or opened a window. Returns FAIL if not\n/// able to jump/open a window.  Returns NOTDONE if a file is not associated\n/// with the entry.\nstatic int qf_jump_open_window(qf_info_T *qi, qfline_T *qf_ptr, bool newwin,\n                               int *opened_window)\n{\n  qf_list_T *qfl = qf_get_curlist(qi);\n  long old_changetick = qfl->qf_changedtick;\n  int old_qf_curlist = qi->qf_curlist;\n  qfltype_T qfl_type = qfl->qfl_type;\n\n    // For \":helpgrep\" find a help window or open one.\n  if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer) || cmdmod.tab != 0)) {\n    if (jump_to_help_window(qi, newwin, opened_window) == FAIL) {\n      return FAIL;\n    }\n  }\n  if (old_qf_curlist != qi->qf_curlist\n      || old_changetick != qfl->qf_changedtick\n      || !is_qf_entry_present(qfl, qf_ptr)) {\n    if (qfl_type == QFLT_QUICKFIX) {\n      EMSG(_(e_current_quickfix_list_was_changed));\n    } else {\n      EMSG(_(e_current_location_list_was_changed));\n    }\n    return FAIL;\n  }\n\n  // If currently in the quickfix window, find another window to show the\n  // file in.\n  if (bt_quickfix(curbuf) && !*opened_window) {\n    // If there is no file specified, we don't know where to go.\n    // But do advance, otherwise \":cn\" gets stuck.\n    if (qf_ptr->qf_fnum == 0) {\n      return NOTDONE;\n    }\n\n    if (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin, opened_window)\n        == FAIL) {\n      return FAIL;\n    }\n  }\n  if (old_qf_curlist != qi->qf_curlist\n      || old_changetick != qfl->qf_changedtick\n      || !is_qf_entry_present(qfl, qf_ptr)) {\n    if (qfl_type == QFLT_QUICKFIX) {\n      EMSG(_(e_current_quickfix_list_was_changed));\n    } else {\n      EMSG(_(e_current_location_list_was_changed));\n    }\n    return FAIL;\n  }\n\n  return OK;\n}\n\n/// Edit a selected file from the quickfix/location list and jump to a\n/// particular line/column, adjust the folds and display a message about the\n/// jump.\n/// Returns OK on success and FAIL on failing to open the file/buffer.  Returns\n/// NOTDONE if the quickfix/location list is freed by an autocmd when opening\n/// the file.\nstatic int qf_jump_to_buffer(qf_info_T *qi, int qf_index, qfline_T *qf_ptr,\n                             int forceit, win_T *oldwin, int *opened_window,\n                             int openfold, int print_message)\n{\n  buf_T *old_curbuf;\n  linenr_T old_lnum;\n  int retval = OK;\n\n  // If there is a file name, read the wanted file if needed, and check\n  // autowrite etc.\n  old_curbuf = curbuf;\n  old_lnum = curwin->w_cursor.lnum;\n\n  if (qf_ptr->qf_fnum != 0) {\n    retval = qf_jump_edit_buffer(qi, qf_ptr, forceit, oldwin,\n                                 opened_window);\n    if (retval != OK) {\n      return retval;\n    }\n  }\n\n  // When not switched to another buffer, still need to set pc mark\n  if (curbuf == old_curbuf) {\n    setpcmark();\n  }\n\n  qf_jump_goto_line(qf_ptr->qf_lnum, qf_ptr->qf_col, qf_ptr->qf_viscol,\n                    qf_ptr->qf_pattern);\n\n  if ((fdo_flags & FDO_QUICKFIX) && openfold) {\n    foldOpenCursor();\n  }\n  if (print_message) {\n    qf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);\n  }\n\n  return retval;\n}\n\n/// Jump to a quickfix line and try to use an existing window.\nvoid qf_jump(qf_info_T *qi, int dir, int errornr, int forceit)\n{\n  qf_jump_newwin(qi, dir, errornr, forceit, false);\n}\n\n// Jump to a quickfix line.\n// If dir == 0 go to entry \"errornr\".\n// If dir == FORWARD go \"errornr\" valid entries forward.\n// If dir == BACKWARD go \"errornr\" valid entries backward.\n// If dir == FORWARD_FILE go \"errornr\" valid entries files backward.\n// If dir == BACKWARD_FILE go \"errornr\" valid entries files backward\n// else if \"errornr\" is zero, redisplay the same line\n// If 'forceit' is true, then can discard changes to the current buffer.\n// If 'newwin' is true, then open the file in a new window.\nstatic void qf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit,\n                           bool newwin)\n{\n  qf_list_T *qfl;\n  qfline_T *qf_ptr;\n  qfline_T *old_qf_ptr;\n  int qf_index;\n  int old_qf_index;\n  char_u *old_swb = p_swb;\n  unsigned old_swb_flags = swb_flags;\n  int opened_window = false;\n  win_T *oldwin = curwin;\n  int print_message = true;\n  const bool old_KeyTyped = KeyTyped;           // getting file may reset it\n  int retval = OK;\n\n  if (qi == NULL)\n    qi = &ql_info;\n\n  if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi))) {\n    EMSG(_(e_quickfix));\n    return;\n  }\n\n  qfl = qf_get_curlist(qi);\n\n  qf_ptr = qfl->qf_ptr;\n  old_qf_ptr = qf_ptr;\n  qf_index = qfl->qf_index;\n  old_qf_index = qf_index;\n\n  qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n  if (qf_ptr == NULL) {\n    qf_ptr = old_qf_ptr;\n    qf_index = old_qf_index;\n    goto theend;\n  }\n\n  qfl->qf_index = qf_index;\n  qfl->qf_ptr = qf_ptr;\n  if (qf_win_pos_update(qi, old_qf_index)) {\n    // No need to print the error message if it's visible in the error\n    // window\n    print_message = false;\n  }\n\n  retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n  if (retval == FAIL) {\n    goto failed;\n  }\n  if (retval == NOTDONE) {\n    goto theend;\n  }\n\n  retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, oldwin,\n                             &opened_window, old_KeyTyped, print_message);\n  if (retval == NOTDONE) {\n    // Quickfix/location list is freed by an autocmd\n    qi = NULL;\n    qf_ptr = NULL;\n  }\n\n  if (retval != OK) {\n    if (opened_window) {\n      win_close(curwin, true);          // Close opened window\n    }\n    if (qf_ptr != NULL && qf_ptr->qf_fnum != 0) {\n       // Couldn't open file, so put index back where it was.  This could\n       // happen if the file was readonly and we changed something.\nfailed:\n      qf_ptr = old_qf_ptr;\n      qf_index = old_qf_index;\n    }\n  }\ntheend:\n  if (qi != NULL) {\n    qfl->qf_ptr = qf_ptr;\n    qfl->qf_index = qf_index;\n  }\n  if (p_swb != old_swb && p_swb == empty_option && opened_window) {\n    // Restore old 'switchbuf' value, but not when an autocommand or\n    // modeline has changed the value.\n    p_swb = old_swb;\n    swb_flags = old_swb_flags;\n  }\n}\n\n\n// Highlight attributes used for displaying entries from the quickfix list.\nstatic int qfFileAttr;\nstatic int qfSepAttr;\nstatic int qfLineAttr;\n\n/// Display information about a single entry from the quickfix/location list.\n/// Used by \":clist/:llist\" commands.\n/// 'cursel' will be set to true for the currently selected entry in the\n/// quickfix list.\nstatic void qf_list_entry(qfline_T *qfp, int qf_idx, bool cursel)\n{\n  char_u *fname;\n  buf_T *buf;\n\n  fname = NULL;\n  if (qfp->qf_module != NULL && *qfp->qf_module != NUL) {\n    vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\", qf_idx,\n                 (char *)qfp->qf_module);\n  } else {\n    if (qfp->qf_fnum != 0\n        && (buf = buflist_findnr(qfp->qf_fnum)) != NULL) {\n      fname = buf->b_fname;\n      if (qfp->qf_type == 1) {  // :helpgrep\n        fname = path_tail(fname);\n      }\n    }\n    if (fname == NULL) {\n      snprintf((char *)IObuff, IOSIZE, \"%2d\", qf_idx);\n    } else {\n      vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\",\n                   qf_idx, (char *)fname);\n    }\n  }\n\n  // Support for filtering entries using :filter /pat/ clist\n  // Match against the module name, file name, search pattern and\n  // text of the entry.\n  bool filter_entry = true;\n  if (qfp->qf_module != NULL && *qfp->qf_module != NUL) {\n    filter_entry &= message_filtered(qfp->qf_module);\n  }\n  if (filter_entry && fname != NULL) {\n    filter_entry &= message_filtered(fname);\n  }\n  if (filter_entry && qfp->qf_pattern != NULL) {\n    filter_entry &= message_filtered(qfp->qf_pattern);\n  }\n  if (filter_entry) {\n    filter_entry &= message_filtered(qfp->qf_text);\n  }\n  if (filter_entry) {\n    return;\n  }\n\n  msg_putchar('\\n');\n  msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);\n\n  if (qfp->qf_lnum != 0) {\n    msg_puts_attr(\":\", qfSepAttr);\n  }\n  if (qfp->qf_lnum == 0) {\n    IObuff[0] = NUL;\n  } else {\n    qf_range_text(qfp, IObuff, IOSIZE);\n  }\n  vim_snprintf((char *)IObuff + STRLEN(IObuff), IOSIZE, \"%s\",\n               (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n  msg_puts_attr((const char *)IObuff, qfLineAttr);\n  msg_puts_attr(\":\", qfSepAttr);\n  if (qfp->qf_pattern != NULL) {\n    qf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);\n    msg_puts((const char *)IObuff);\n    msg_puts_attr(\":\", qfSepAttr);\n  }\n  msg_puts(\" \");\n\n  // Remove newlines and leading whitespace from the text.  For an\n  // unrecognized line keep the indent, the compiler may mark a word\n  // with ^^^^. */\n  qf_fmt_text((fname != NULL || qfp->qf_lnum != 0)\n              ? skipwhite(qfp->qf_text) : qfp->qf_text,\n              IObuff, IOSIZE);\n  msg_prt_line(IObuff, false);\n  ui_flush();  // show one line at a time\n}\n\n// \":clist\": list all errors\n// \":llist\": list all locations\nvoid qf_list(exarg_T *eap)\n{\n  qf_list_T *qfl;\n  qfline_T *qfp;\n  int i;\n  int idx1 = 1;\n  int idx2 = -1;\n  char_u      *arg = eap->arg;\n  int         all = eap->forceit;     // if not :cl!, only show\n                                      // recognised errors\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi))) {\n    EMSG(_(e_quickfix));\n    return;\n  }\n\n  bool plus = false;\n  if (*arg == '+') {\n    arg++;\n    plus = true;\n  }\n  if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL) {\n    EMSG(_(e_trailing));\n    return;\n  }\n  qfl = qf_get_curlist(qi);\n  if (plus) {\n    i = qfl->qf_index;\n    idx2 = i + idx1;\n    idx1 = i;\n  } else {\n    i = qfl->qf_count;\n    if (idx1 < 0) {\n      idx1 = (-idx1 > i) ? 0 : idx1 + i + 1;\n    }\n    if (idx2 < 0) {\n      idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;\n    }\n  }\n\n  // Shorten all the file names, so that it is easy to read.\n  shorten_fnames(false);\n\n  // Get the attributes for the different quickfix highlight items.  Note\n  // that this depends on syntax items defined in the qf.vim syntax file\n  qfFileAttr = syn_name2attr((char_u *)\"qfFileName\");\n  if (qfFileAttr == 0) {\n     qfFileAttr = HL_ATTR(HLF_D);\n  }\n  qfSepAttr = syn_name2attr((char_u *)\"qfSeparator\");\n  if (qfSepAttr == 0) {\n      qfSepAttr = HL_ATTR(HLF_D);\n  }\n  qfLineAttr = syn_name2attr((char_u *)\"qfLineNr\");\n  if (qfLineAttr == 0) {\n      qfLineAttr = HL_ATTR(HLF_N);\n  }\n\n  if (qfl->qf_nonevalid) {\n    all = true;\n  }\n  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n    if ((qfp->qf_valid || all) && idx1 <= i && i <= idx2) {\n      qf_list_entry(qfp, i, i == qfl->qf_index);\n    }\n    os_breakcheck();\n  }\n}\n\n// Remove newlines and leading whitespace from an error message.\n// Put the result in \"buf[bufsize]\".\nstatic void qf_fmt_text(const char_u *restrict text, char_u *restrict buf,\n                        int bufsize)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int i;\n  const char_u *p = text;\n\n  for (i = 0; *p != NUL && i < bufsize - 1; ++i) {\n    if (*p == '\\n') {\n      buf[i] = ' ';\n      while (*++p != NUL)\n        if (!ascii_iswhite(*p) && *p != '\\n')\n          break;\n    } else\n      buf[i] = *p++;\n  }\n  buf[i] = NUL;\n}\n\n// Range information from lnum, col, end_lnum, and end_col.\n// Put the result in \"buf[bufsize]\".\nstatic void qf_range_text(const qfline_T *qfp, char_u *buf, int bufsize)\n{\n  vim_snprintf((char *)buf, (size_t)bufsize, \"%\" PRIdLINENR, qfp->qf_lnum);\n  int len = (int)STRLEN(buf);\n\n  if (qfp->qf_end_lnum > 0 && qfp->qf_lnum != qfp->qf_end_lnum) {\n    vim_snprintf((char *)buf + len, (size_t)(bufsize - len),\n                 \"-%\" PRIdLINENR, qfp->qf_end_lnum);\n    len += (int)STRLEN(buf + len);\n  }\n  if (qfp->qf_col > 0) {\n    vim_snprintf((char *)buf + len, (size_t)(bufsize - len),\n                 \" col %d\", qfp->qf_col);\n    len += (int)STRLEN(buf + len);\n    if (qfp->qf_end_col > 0 && qfp->qf_col != qfp->qf_end_col) {\n      vim_snprintf((char *)buf + len, (size_t)(bufsize - len),\n                   \"-%d\", qfp->qf_end_col);\n      len += (int)STRLEN(buf + len);\n    }\n  }\n  buf[len] = NUL;\n}\n\n\n/// Display information (list number, list size and the title) about a\n/// quickfix/location list.\nstatic void qf_msg(qf_info_T *qi, int which, char *lead)\n{\n  char *title = (char *)qi->qf_lists[which].qf_title;\n  int count = qi->qf_lists[which].qf_count;\n  char_u buf[IOSIZE];\n\n  vim_snprintf((char *)buf, IOSIZE, _(\"%serror list %d of %d; %d errors \"),\n               lead,\n               which + 1,\n               qi->qf_listcount,\n               count);\n\n  if (title != NULL) {\n    size_t len = STRLEN(buf);\n\n    if (len < 34) {\n       memset(buf + len, ' ', 34 - len);\n       buf[34] = NUL;\n    }\n    xstrlcat((char *)buf, title, IOSIZE);\n  }\n  trunc_string(buf, buf, Columns - 1, IOSIZE);\n  msg(buf);\n}\n\n/// \":colder [count]\": Up in the quickfix stack.\n/// \":cnewer [count]\": Down in the quickfix stack.\n/// \":lolder [count]\": Up in the location list stack.\n/// \":lnewer [count]\": Down in the location list stack.\nvoid qf_age(exarg_T *eap)\n{\n  qf_info_T *qi;\n  int count;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  if (eap->addr_count != 0) {\n    assert(eap->line2 <= INT_MAX);\n    count = (int)eap->line2;\n  } else {\n    count = 1;\n  }\n  while (count--) {\n    if (eap->cmdidx == CMD_colder || eap->cmdidx == CMD_lolder) {\n      if (qi->qf_curlist == 0) {\n        EMSG(_(\"E380: At bottom of quickfix stack\"));\n        break;\n      }\n      --qi->qf_curlist;\n    } else {\n      if (qi->qf_curlist >= qi->qf_listcount - 1) {\n        EMSG(_(\"E381: At top of quickfix stack\"));\n        break;\n      }\n      ++qi->qf_curlist;\n    }\n  }\n  qf_msg(qi, qi->qf_curlist, \"\");\n  qf_update_buffer(qi, NULL);\n}\n\n/// Display the information about all the quickfix/location lists in the stack.\nvoid qf_history(exarg_T *eap)\n{\n  qf_info_T *qi = qf_cmd_get_stack(eap, false);\n  int i;\n\n  if (eap->addr_count > 0) {\n    if (qi == NULL) {\n      EMSG(_(e_loclist));\n      return;\n    }\n\n    // Jump to the specified quickfix list\n    if (eap->line2 > 0 && eap->line2 <= qi->qf_listcount) {\n      qi->qf_curlist = (int)(eap->line2 - 1);\n      qf_msg(qi, qi->qf_curlist, \"\");\n      qf_update_buffer(qi, NULL);\n    } else {\n      EMSG(_(e_invrange));\n    }\n\n    return;\n  }\n\n  if (qf_stack_empty(qi)) {\n    MSG(_(\"No entries\"));\n  } else {\n    for (i = 0; i < qi->qf_listcount; i++) {\n      qf_msg(qi, i, i == qi->qf_curlist ? \"> \" : \"  \");\n    }\n  }\n}\n\n/// Free all the entries in the error list \"idx\". Note that other information\n/// associated with the list like context and title are not freed.\nstatic void qf_free_items(qf_list_T *qfl)\n{\n  qfline_T    *qfp;\n  qfline_T    *qfpnext;\n  bool stop = false;\n\n  while (qfl->qf_count && qfl->qf_start != NULL) {\n    qfp = qfl->qf_start;\n    qfpnext = qfp->qf_next;\n    if (!stop) {\n      xfree(qfp->qf_module);\n      xfree(qfp->qf_text);\n      xfree(qfp->qf_pattern);\n      stop = (qfp == qfpnext);\n      xfree(qfp);\n      if (stop) {\n        // Somehow qf_count may have an incorrect value, set it to 1\n        // to avoid crashing when it's wrong.\n        // TODO(vim): Avoid qf_count being incorrect.\n        qfl->qf_count = 1;\n      }\n    }\n    qfl->qf_start = qfpnext;\n    qfl->qf_count--;\n  }\n\n  qfl->qf_start = NULL;\n  qfl->qf_ptr = NULL;\n  qfl->qf_index = 0;\n  qfl->qf_start = NULL;\n  qfl->qf_last = NULL;\n  qfl->qf_ptr = NULL;\n  qfl->qf_nonevalid = true;\n\n  qf_clean_dir_stack(&qfl->qf_dir_stack);\n  qfl->qf_directory = NULL;\n  qf_clean_dir_stack(&qfl->qf_file_stack);\n  qfl->qf_currfile = NULL;\n  qfl->qf_multiline = false;\n  qfl->qf_multiignore = false;\n  qfl->qf_multiscan = false;\n}\n\n/// Free error list \"idx\". Frees all the entries in the quickfix list,\n/// associated context information and the title.\nstatic void qf_free(qf_list_T *qfl)\n{\n  qf_free_items(qfl);\n\n  XFREE_CLEAR(qfl->qf_title);\n  tv_free(qfl->qf_ctx);\n  qfl->qf_ctx = NULL;\n  callback_free(&qfl->qftf_cb);\n  qfl->qf_id = 0;\n  qfl->qf_changedtick = 0L;\n}\n\n// qf_mark_adjust: adjust marks\nbool qf_mark_adjust(win_T *wp, linenr_T line1, linenr_T line2, long amount,\n                    long amount_after)\n{\n  int i;\n  qfline_T    *qfp;\n  int idx;\n  qf_info_T   *qi = &ql_info;\n  bool found_one = false;\n  int buf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n\n  if (!(curbuf->b_has_qf_entry & buf_has_flag)) {\n    return false;\n  }\n  if (wp != NULL) {\n    if (wp->w_llist == NULL) {\n      return false;\n    }\n    qi = wp->w_llist;\n  }\n\n  for (idx = 0; idx < qi->qf_listcount; idx++) {\n    qf_list_T *qfl = qf_get_list(qi, idx);\n    if (!qf_list_empty(qfl)) {\n      FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n        if (qfp->qf_fnum == curbuf->b_fnum) {\n          found_one = true;\n          if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2) {\n            if (amount == MAXLNUM)\n              qfp->qf_cleared = TRUE;\n            else\n              qfp->qf_lnum += amount;\n          } else if (amount_after && qfp->qf_lnum > line2)\n            qfp->qf_lnum += amount_after;\n        }\n      }\n    }\n  }\n\n  return found_one;\n}\n\n// Make a nice message out of the error character and the error number:\n//  char    number  message\n//  e or E    0     \" error\"\n//  w or W    0     \" warning\"\n//  i or I    0     \" info\"\n//  n or N    0     \" note\"\n//  0         0     \"\"\n//  other     0     \" c\"\n//  e or E    n     \" error n\"\n//  w or W    n     \" warning n\"\n//  i or I    n     \" info n\"\n//  n or N    n     \" note n\"\n//  0         n     \" error n\"\n//  other     n     \" c n\"\n//  1         x     \"\"          :helpgrep\nstatic char_u *qf_types(int c, int nr)\n{\n  static char_u buf[20];\n  static char_u cc[3];\n  char_u              *p;\n\n  if (c == 'W' || c == 'w') {\n    p = (char_u *)\" warning\";\n  } else if (c == 'I' || c == 'i') {\n    p = (char_u *)\" info\";\n  } else if (c == 'N' || c == 'n') {\n    p = (char_u *)\" note\";\n  } else if (c == 'E' || c == 'e' || (c == 0 && nr > 0)) {\n    p = (char_u *)\" error\";\n  } else if (c == 0 || c == 1) {\n    p = (char_u *)\"\";\n  } else {\n    cc[0] = ' ';\n    cc[1] = (char_u)c;\n    cc[2] = NUL;\n    p = cc;\n  }\n\n  if (nr <= 0)\n    return p;\n\n  sprintf((char *)buf, \"%s %3d\", (char *)p, nr);\n  return buf;\n}\n\n// When \"split\" is false: Open the entry/result under the cursor.\n// When \"split\" is true: Open the entry/result under the cursor in a new window.\nvoid qf_view_result(bool split)\n{\n  qf_info_T   *qi = &ql_info;\n\n  if (!bt_quickfix(curbuf)) {\n    return;\n  }\n  if (IS_LL_WINDOW(curwin)) {\n    qi = GET_LOC_LIST(curwin);\n  }\n  if (qf_list_empty(qf_get_curlist(qi))) {\n    EMSG(_(e_quickfix));\n    return;\n  }\n\n  if (split) {\n    // Open the selected entry in a new window\n    qf_jump_newwin(qi, 0, (int)curwin->w_cursor.lnum, false, true);\n    do_cmdline_cmd(\"clearjumps\");\n    return;\n  }\n\n  do_cmdline_cmd((IS_LL_WINDOW(curwin) ? \".ll\" : \".cc\"));\n}\n\n// \":cwindow\": open the quickfix window if we have errors to display,\n//             close it if not.\n// \":lwindow\": open the location list window if we have locations to display,\n//             close it if not.\nvoid ex_cwindow(exarg_T *eap)\n{\n  qf_info_T   *qi;\n  qf_list_T   *qfl;\n  win_T       *win;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  qfl = qf_get_curlist(qi);\n\n  // Look for an existing quickfix window.\n  win = qf_find_win(qi);\n\n  // If a quickfix window is open but we have no errors to display,\n  // close the window.  If a quickfix window is not open, then open\n  // it if we have errors; otherwise, leave it closed.\n  if (qf_stack_empty(qi)\n      || qfl->qf_nonevalid\n      || qf_list_empty(qfl)) {\n    if (win != NULL) {\n      ex_cclose(eap);\n    }\n  } else if (win == NULL) {\n    ex_copen(eap);\n  }\n}\n\n// \":cclose\": close the window showing the list of errors.\n// \":lclose\": close the window showing the location list\nvoid ex_cclose(exarg_T *eap)\n{\n  win_T *win = NULL;\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {\n    return;\n  }\n\n  // Find existing quickfix window and close it.\n  win = qf_find_win(qi);\n  if (win != NULL) {\n    win_close(win, false);\n  }\n}\n\n// Goto a quickfix or location list window (if present).\n// Returns OK if the window is found, FAIL otherwise.\nstatic int qf_goto_cwindow(const qf_info_T *qi, bool resize, int sz,\n                           bool vertsplit)\n{\n  win_T *const win = qf_find_win(qi);\n  if (win == NULL) {\n    return FAIL;\n  }\n\n  win_goto(win);\n  if (resize) {\n    if (vertsplit) {\n      if (sz != win->w_width) {\n        win_setwidth(sz);\n      }\n    } else if (sz != win->w_height\n               && (win->w_height + win->w_status_height + tabline_height()\n                   < cmdline_row)) {\n      win_setheight(sz);\n    }\n  }\n\n  return OK;\n}\n\n// Set options for the buffer in the quickfix or location list window.\nstatic void qf_set_cwindow_options(void)\n{\n  // switch off 'swapfile'\n  set_option_value(\"swf\", 0L, NULL, OPT_LOCAL);\n  set_option_value(\"bt\", 0L, \"quickfix\", OPT_LOCAL);\n  set_option_value(\"bh\", 0L, \"wipe\", OPT_LOCAL);\n  RESET_BINDING(curwin);\n  curwin->w_p_diff = false;\n  set_option_value(\"fdm\", 0L, \"manual\", OPT_LOCAL);\n}\n\n// Open a new quickfix or location list window, load the quickfix buffer and\n// set the appropriate options for the window.\n// Returns FAIL if the window could not be opened.\nstatic int qf_open_new_cwindow(qf_info_T *qi, int height)\n  FUNC_ATTR_NONNULL_ALL\n{\n  win_T *oldwin = curwin;\n  const tabpage_T *const prevtab = curtab;\n  int flags = 0;\n\n  const buf_T *const qf_buf = qf_find_buf(qi);\n\n  // The current window becomes the previous window afterwards.\n  win_T *const win = curwin;\n\n  if (IS_QF_STACK(qi) && cmdmod.split == 0) {\n    // Create the new quickfix window at the very bottom, except when\n    // :belowright or :aboveleft is used.\n    win_goto(lastwin);\n  }\n  // Default is to open the window below the current window\n  if (cmdmod.split == 0) {\n    flags = WSP_BELOW;\n  }\n  flags |= WSP_NEWLOC;\n  if (win_split(height, flags) == FAIL) {\n    return FAIL;  // not enough room for window\n  }\n\n  // User autocommands may have invalidated the previous window after calling\n  // win_split, so add a check to ensure that the win is still here\n  if (IS_LL_STACK(qi) && !win_valid(win)) {\n    // close the window that was supposed to be for the loclist\n    win_close(curwin, false);\n    return FAIL;\n  }\n\n  RESET_BINDING(curwin);\n\n  if (IS_LL_STACK(qi)) {\n    // For the location list window, create a reference to the\n    // location list from the window 'win'.\n    curwin->w_llist_ref = win->w_llist;\n    win->w_llist->qf_refcount++;\n  }\n\n  if (oldwin != curwin) {\n    oldwin = NULL;  // don't store info when in another window\n  }\n  if (qf_buf != NULL) {\n    // Use the existing quickfix buffer\n    if (do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,\n                ECMD_HIDE + ECMD_OLDBUF, oldwin) == FAIL) {\n      return FAIL;\n    }\n  } else {\n    // Create a new quickfix buffer\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, oldwin) == FAIL) {\n      return FAIL;\n    }\n  }\n\n  // Set the options for the quickfix buffer/window (if not already done)\n  // Do this even if the quickfix buffer was already present, as an autocmd\n  // might have previously deleted (:bdelete) the quickfix buffer.\n  if (!bt_quickfix(curbuf)) {\n    qf_set_cwindow_options();\n  }\n\n  // Only set the height when still in the same tab page and there is no\n  // window to the side.\n  if (curtab == prevtab && curwin->w_width == Columns) {\n    win_setheight(height);\n  }\n  curwin->w_p_wfh = true;  // set 'winfixheight'\n  if (win_valid(win)) {\n    prevwin = win;\n  }\n  return OK;\n}\n\n/// Set \"w:quickfix_title\" if \"qi\" has a title.\nstatic void qf_set_title_var(qf_list_T *qfl)\n{\n  if (qfl->qf_title != NULL) {\n    set_internal_string_var(\"w:quickfix_title\", qfl->qf_title);\n  }\n}\n\n/// \":copen\": open a window that shows the list of errors.\n/// \":lopen\": open a window that shows the location list.\nvoid ex_copen(exarg_T *eap)\n{\n  qf_info_T   *qi;\n  qf_list_T   *qfl;\n  int height;\n  int status = FAIL;\n  int lnum;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  incr_quickfix_busy();\n\n  if (eap->addr_count != 0) {\n    assert(eap->line2 <= INT_MAX);\n    height = (int)eap->line2;\n  } else {\n    height = QF_WINHEIGHT;\n  }\n  reset_VIsual_and_resel();  // stop Visual mode\n\n  // Find an existing quickfix window, or open a new one.\n  if (cmdmod.tab == 0) {\n    status = qf_goto_cwindow(qi, eap->addr_count != 0, height,\n                             cmdmod.split & WSP_VERT);\n  }\n  if (status == FAIL) {\n    if (qf_open_new_cwindow(qi, height) == FAIL) {\n      decr_quickfix_busy();\n      return;\n    }\n  }\n\n  qfl = qf_get_curlist(qi);\n  qf_set_title_var(qfl);\n  // Save the current index here, as updating the quickfix buffer may free\n  // the quickfix list\n  lnum = qfl->qf_index;\n\n  // Fill the buffer with the quickfix list.\n  qf_fill_buffer(qfl, curbuf, NULL, curwin->handle);\n\n  decr_quickfix_busy();\n\n  curwin->w_cursor.lnum = lnum;\n  curwin->w_cursor.col = 0;\n  check_cursor();\n  update_topline(curwin);             // scroll to show the line\n}\n\n// Move the cursor in the quickfix window to \"lnum\".\nstatic void qf_win_goto(win_T *win, linenr_T lnum)\n{\n  win_T *old_curwin = curwin;\n\n  curwin = win;\n  curbuf = win->w_buffer;\n  curwin->w_cursor.lnum = lnum;\n  curwin->w_cursor.col = 0;\n  curwin->w_cursor.coladd = 0;\n  curwin->w_curswant = 0;\n  update_topline(curwin);              // scroll to show the line\n  redraw_later(curwin, VALID);\n  curwin->w_redr_status = true;  // update ruler\n  curwin = old_curwin;\n  curbuf = curwin->w_buffer;\n}\n\n/// :cbottom/:lbottom command.\nvoid ex_cbottom(exarg_T *eap)\n{\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  win_T *win = qf_find_win(qi);\n\n  if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count) {\n    qf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n  }\n}\n\n// Return the number of the current entry (line number in the quickfix\n// window).\nlinenr_T qf_current_entry(win_T *wp)\n{\n  qf_info_T   *qi = &ql_info;\n\n  if (IS_LL_WINDOW(wp)) {\n    // In the location list window, use the referenced location list\n    qi = wp->w_llist_ref;\n  }\n\n  return qf_get_curlist(qi)->qf_index;\n}\n\n// Update the cursor position in the quickfix window to the current error.\n// Return TRUE if there is a quickfix window.\nstatic int qf_win_pos_update(\n    qf_info_T *qi,\n    int old_qf_index               // previous qf_index or zero\n)\n{\n  win_T       *win;\n  int qf_index = qf_get_curlist(qi)->qf_index;\n\n  // Put the cursor on the current error in the quickfix window, so that\n  // it's viewable.\n  win = qf_find_win(qi);\n  if (win != NULL\n      && qf_index <= win->w_buffer->b_ml.ml_line_count\n      && old_qf_index != qf_index) {\n    if (qf_index > old_qf_index) {\n      win->w_redraw_top = old_qf_index;\n      win->w_redraw_bot = qf_index;\n    } else {\n      win->w_redraw_top = qf_index;\n      win->w_redraw_bot = old_qf_index;\n    }\n    qf_win_goto(win, qf_index);\n  }\n  return win != NULL;\n}\n\n/// Checks whether the given window is displaying the specified\n/// quickfix/location stack.\nstatic int is_qf_win(const win_T *win, const qf_info_T *qi)\n  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  //\n  // A window displaying the quickfix buffer will have the w_llist_ref field\n  // set to NULL.\n  // A window displaying a location list buffer will have the w_llist_ref\n  // pointing to the location list.\n  //\n  if (bt_quickfix(win->w_buffer)) {\n    if ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)\n        || (IS_LL_STACK(qi) && win->w_llist_ref == qi)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Find a window displaying the quickfix/location stack 'qi'\n/// Only searches in the current tabpage.\nstatic win_T *qf_find_win(const qf_info_T *qi)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n    if (is_qf_win(win, qi)) {\n      return win;\n    }\n  }\n\n  return NULL;\n}\n\n// Find a quickfix buffer.\n// Searches in windows opened in all the tabs.\nstatic buf_T *qf_find_buf(qf_info_T *qi)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_TAB_WINDOWS(tp, win) {\n    if (is_qf_win(win, qi)) {\n      return win->w_buffer;\n    }\n  }\n\n  return NULL;\n}\n\n// Process the 'quickfixtextfunc' option value.\nbool qf_process_qftf_option(void)\n{\n  typval_T *tv;\n  Callback cb;\n\n  if (p_qftf == NULL || *p_qftf == NUL) {\n    callback_free(&qftf_cb);\n    return true;\n  }\n\n  if (*p_qftf == '{') {\n    // Lambda expression\n    tv = eval_expr(p_qftf);\n    if (tv == NULL) {\n      return false;\n    }\n  } else {\n    // treat everything else as a function name string\n    tv = xcalloc(1, sizeof(*tv));\n    tv->v_type = VAR_STRING;\n    tv->vval.v_string = vim_strsave(p_qftf);\n  }\n\n  if (!callback_from_typval(&cb, tv)) {\n    tv_free(tv);\n    return false;\n  }\n\n  callback_free(&qftf_cb);\n  qftf_cb = cb;\n  tv_free(tv);\n  return true;\n}\n\n/// Update the w:quickfix_title variable in the quickfix/location list window in\n/// all the tab pages.\nstatic void qf_update_win_titlevar(qf_info_T *qi)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_list_T *const qfl = qf_get_curlist(qi);\n  win_T *const save_curwin = curwin;\n\n  FOR_ALL_TAB_WINDOWS(tp, win) {\n    if (is_qf_win(win, qi)) {\n      curwin = win;\n      qf_set_title_var(qfl);\n    }\n  }\n  curwin = save_curwin;\n}\n\n// Find the quickfix buffer.  If it exists, update the contents.\nstatic void qf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n  buf_T       *buf;\n  win_T       *win;\n  aco_save_T aco;\n\n  // Check if a buffer for the quickfix list exists.  Update it.\n  buf = qf_find_buf(qi);\n  if (buf != NULL) {\n    linenr_T old_line_count = buf->b_ml.ml_line_count;\n    int qf_winid = 0;\n\n    if (IS_LL_STACK(qi)) {\n      if (curwin->w_llist == qi) {\n        win = curwin;\n      } else {\n        win = qf_find_win_with_loclist(qi);\n        if (win == NULL) {\n          return;\n        }\n      }\n      qf_winid = (int)win->handle;\n    }\n\n    if (old_last == NULL) {\n      // set curwin/curbuf to buf and save a few things\n      aucmd_prepbuf(&aco, buf);\n    }\n\n    qf_update_win_titlevar(qi);\n\n    qf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n    buf_inc_changedtick(buf);\n\n    if (old_last == NULL) {\n      (void)qf_win_pos_update(qi, 0);\n\n      // restore curwin/curbuf and a few other things\n      aucmd_restbuf(&aco);\n    }\n\n    // Only redraw when added lines are visible.  This avoids flickering when\n    // the added lines are not visible.\n    if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline) {\n      redraw_buf_later(buf, NOT_VALID);\n    }\n  }\n}\n\n// Add an error line to the quickfix buffer.\nstatic int qf_buf_add_line(qf_list_T *qfl, buf_T *buf, linenr_T lnum,\n                           const qfline_T *qfp, char_u *dirname,\n                           char_u *qftf_str, bool first_bufline)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 4, 5)\n{\n  int len;\n  buf_T *errbuf;\n\n  // If the 'quickfixtextfunc' function returned an non-empty custom string\n  // for this entry, then use it.\n  if (qftf_str != NULL && *qftf_str != NUL) {\n    STRLCPY(IObuff, qftf_str, IOSIZE);\n  } else {\n    if (qfp->qf_module != NULL) {\n      STRLCPY(IObuff, qfp->qf_module, IOSIZE);\n      len = (int)STRLEN(IObuff);\n    } else if (qfp->qf_fnum != 0\n               && (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL\n               && errbuf->b_fname != NULL) {\n      if (qfp->qf_type == 1) {  // :helpgrep\n        STRLCPY(IObuff, path_tail(errbuf->b_fname), IOSIZE);\n      } else {\n        // Shorten the file name if not done already.\n        // For optimization, do this only for the first entry in a\n        // buffer.\n        if (first_bufline\n            && (errbuf->b_sfname == NULL\n                || path_is_absolute(errbuf->b_sfname))) {\n          if (*dirname == NUL) {\n            os_dirname(dirname, MAXPATHL);\n          }\n          shorten_buf_fname(errbuf, dirname, false);\n        }\n        STRLCPY(IObuff, errbuf->b_fname, IOSIZE);\n      }\n      len = (int)STRLEN(IObuff);\n    } else {\n      len = 0;\n    }\n    if (len < IOSIZE - 1) {\n      IObuff[len++] = '|';\n    }\n    if (qfp->qf_lnum > 0) {\n      qf_range_text(qfp, IObuff + len, IOSIZE - len);\n      len += (int)STRLEN(IObuff + len);\n\n      snprintf((char *)IObuff + len, (size_t)(IOSIZE - len), \"%s\",\n               (char *)qf_types(qfp->qf_type, qfp->qf_nr));\n      len += (int)STRLEN(IObuff + len);\n    } else if (qfp->qf_pattern != NULL) {\n      qf_fmt_text(qfp->qf_pattern, IObuff + len, IOSIZE - len);\n      len += (int)STRLEN(IObuff + len);\n    }\n    if (len < IOSIZE - 2) {\n      IObuff[len++] = '|';\n      IObuff[len++] = ' ';\n    }\n\n    // Remove newlines and leading whitespace from the text.\n    // For an unrecognized line keep the indent, the compiler may\n    // mark a word with ^^^^.\n    qf_fmt_text(len > 3 ? skipwhite(qfp->qf_text) : qfp->qf_text,\n                IObuff + len, IOSIZE - len);\n  }\n\n  if (ml_append_buf(buf, lnum, IObuff,\n                    (colnr_T)STRLEN(IObuff) + 1, false) == FAIL) {\n    return FAIL;\n  }\n  return OK;\n}\n\n// Call the 'quickfixtextfunc' function to get the list of lines to display in\n// the quickfix window for the entries 'start_idx' to 'end_idx'.\nstatic list_T *call_qftf_func(qf_list_T *qfl,\n                              int qf_winid,\n                              long start_idx,\n                              long end_idx)\n{\n  Callback *cb = &qftf_cb;\n  list_T *qftf_list = NULL;\n\n  // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n  // the text to display. Use the local value of 'quickfixtextfunc' if it is\n  // set.\n  if (qfl->qftf_cb.type != kCallbackNone) {\n    cb = &qfl->qftf_cb;\n  }\n  if (cb != NULL && cb->type != kCallbackNone) {\n    typval_T args[1];\n    typval_T rettv;\n\n    // create the dict argument\n    dict_T *const dict = tv_dict_alloc_lock(VAR_FIXED);\n\n    tv_dict_add_nr(dict, S_LEN(\"quickfix\"), IS_QF_LIST(qfl));\n    tv_dict_add_nr(dict, S_LEN(\"winid\"), qf_winid);\n    tv_dict_add_nr(dict, S_LEN(\"id\"), qfl->qf_id);\n    tv_dict_add_nr(dict, S_LEN(\"start_idx\"), start_idx);\n    tv_dict_add_nr(dict, S_LEN(\"end_idx\"), end_idx);\n    dict->dv_refcount++;\n    args[0].v_type = VAR_DICT;\n    args[0].vval.v_dict = dict;\n\n    qftf_list = NULL;\n\n    if (callback_call(cb, 1, args, &rettv)) {\n      if (rettv.v_type == VAR_LIST) {\n        qftf_list = rettv.vval.v_list;\n        tv_list_ref(qftf_list);\n      }\n      tv_clear(&rettv);\n    }\n    tv_dict_unref(dict);\n  }\n\n  return qftf_list;\n}\n\n/// Fill current buffer with quickfix errors, replacing any previous contents.\n/// curbuf must be the quickfix buffer!\n/// If \"old_last\" is not NULL append the items after this one.\n/// When \"old_last\" is NULL then \"buf\" must equal \"curbuf\"!  Because ml_delete()\n/// is used and autocommands will be triggered.\nstatic void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last,\n                           int qf_winid)\n  FUNC_ATTR_NONNULL_ARG(2)\n{\n  linenr_T lnum;\n  qfline_T    *qfp;\n  const bool old_KeyTyped = KeyTyped;\n  list_T *qftf_list = NULL;\n  listitem_T *qftf_li = NULL;\n\n  if (old_last == NULL) {\n    if (buf != curbuf) {\n      internal_error(\"qf_fill_buffer()\");\n      return;\n    }\n\n    // delete all existing lines\n    while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0) {\n      (void)ml_delete((linenr_T)1, false);\n    }\n  }\n\n  // Check if there is anything to display\n  if (qfl != NULL) {\n     char_u dirname[MAXPATHL];\n     int prev_bufnr = -1;\n     bool invalid_val = false;\n\n     *dirname = NUL;\n\n    // Add one line for each error\n    if (old_last == NULL) {\n      qfp = qfl->qf_start;\n      lnum = 0;\n    } else {\n      if (old_last->qf_next != NULL) {\n        qfp = old_last->qf_next;\n      } else {\n        qfp = old_last;\n      }\n      lnum = buf->b_ml.ml_line_count;\n    }\n\n    qftf_list = call_qftf_func(qfl, qf_winid, lnum + 1, (long)qfl->qf_count);\n    qftf_li = tv_list_first(qftf_list);\n\n    while (lnum < qfl->qf_count) {\n      char_u *qftf_str = NULL;\n\n      // Use the text supplied by the user defined function (if any).\n      // If the returned value is not string, then ignore the rest\n      // of the returned values and use the default.\n      if (qftf_li != NULL && !invalid_val) {\n        qftf_str = (char_u *)tv_get_string_chk(TV_LIST_ITEM_TV(qftf_li));\n        if (qftf_str == NULL) {\n          invalid_val = true;\n        }\n      }\n\n      if (qf_buf_add_line(qfl, buf, lnum, qfp, dirname, qftf_str,\n                          prev_bufnr != qfp->qf_fnum) == FAIL) {\n        break;\n      }\n      prev_bufnr = qfp->qf_fnum;\n      lnum++;\n      qfp = qfp->qf_next;\n      if (qfp == NULL) {\n        break;\n      }\n\n      if (qftf_li != NULL) {\n        qftf_li = TV_LIST_ITEM_NEXT(qftf_list, qftf_li);\n      }\n    }\n    if (old_last == NULL) {\n      // Delete the empty line which is now at the end\n      (void)ml_delete(lnum + 1, false);\n    }\n  }\n\n  // Correct cursor position.\n  check_lnums(true);\n\n  if (old_last == NULL) {\n    // Set the 'filetype' to \"qf\" each time after filling the buffer.  This\n    // resembles reading a file into a buffer, it's more logical when using\n    // autocommands.\n    curbuf->b_ro_locked++;\n    set_option_value(\"ft\", 0L, \"qf\", OPT_LOCAL);\n    curbuf->b_p_ma = false;\n\n    keep_filetype = true;                 // don't detect 'filetype'\n    apply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n                   false, curbuf);\n    apply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n                   false, curbuf);\n    keep_filetype = false;\n    curbuf->b_ro_locked--;\n\n    // make sure it will be redrawn\n    redraw_curbuf_later(NOT_VALID);\n  }\n\n  // Restore KeyTyped, setting 'filetype' may reset it.\n  KeyTyped = old_KeyTyped;\n}\n\nstatic void qf_list_changed(qf_list_T *qfl)\n{\n    qfl->qf_changedtick++;\n}\n\n/// Return the quickfix/location list number with the given identifier.\n///\n/// @returns -1 if list is not found.\nstatic int qf_id2nr(const qf_info_T *const qi, const unsigned qfid)\n{\n  for (int qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++) {\n    if (qi->qf_lists[qf_idx].qf_id == qfid) {\n      return qf_idx;\n    }\n  }\n  return INVALID_QFIDX;\n}\n\n/// If the current list is not \"save_qfid\" and we can find the list with that ID\n/// then make it the current list.\n/// This is used when autocommands may have changed the current list.\n/// Returns OK if successfully restored the list. Returns FAIL if the list with\n/// the specified identifier (save_qfid) is not found in the stack.\nstatic int qf_restore_list(qf_info_T *qi, unsigned save_qfid)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (qf_get_curlist(qi)->qf_id != save_qfid) {\n    const int curlist = qf_id2nr(qi, save_qfid);\n    if (curlist < 0) {\n      // list is not present\n      return FAIL;\n    }\n    qi->qf_curlist = curlist;\n  }\n  return OK;\n}\n\n// Jump to the first entry if there is one.\nstatic void qf_jump_first(qf_info_T *qi, unsigned save_qfid, int forceit)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (qf_restore_list(qi, save_qfid) == FAIL) {\n    return;\n  }\n  // Autocommands might have cleared the list, check for that\n  if (!qf_list_empty(qf_get_curlist(qi))) {\n    qf_jump(qi, 0, 0, forceit);\n  }\n}\n\n// Return TRUE when using \":vimgrep\" for \":grep\".\nint grep_internal(cmdidx_T cmdidx)\n{\n  return (cmdidx == CMD_grep\n          || cmdidx == CMD_lgrep\n          || cmdidx == CMD_grepadd\n          || cmdidx == CMD_lgrepadd)\n         && STRCMP(\"internal\",\n      *curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0;\n}\n\n// Return the make/grep autocmd name.\nstatic char_u *make_get_auname(cmdidx_T cmdidx)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  switch (cmdidx) {\n    case CMD_make:\n      return (char_u *)\"make\";\n    case CMD_lmake:\n      return (char_u *)\"lmake\";\n    case CMD_grep:\n      return (char_u *)\"grep\";\n    case CMD_lgrep:\n      return (char_u *)\"lgrep\";\n    case CMD_grepadd:\n      return (char_u *)\"grepadd\";\n    case CMD_lgrepadd:\n      return (char_u *)\"lgrepadd\";\n    default:\n      return NULL;\n  }\n}\n\n// Form the complete command line to invoke 'make'/'grep'. Quote the command\n// using 'shellquote' and append 'shellpipe'. Echo the fully formed command.\nstatic char *make_get_fullcmd(const char_u *makecmd, const char_u *fname)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  size_t len = STRLEN(p_shq) * 2 + STRLEN(makecmd) + 1;\n  if (*p_sp != NUL) {\n    len += STRLEN(p_sp) + STRLEN(fname) + 3;\n  }\n  char *const cmd = xmalloc(len);\n  snprintf(cmd, len, \"%s%s%s\", (char *)p_shq, (char *)makecmd, (char *)p_shq);\n\n  // If 'shellpipe' empty: don't redirect to 'errorfile'.\n  if (*p_sp != NUL) {\n    append_redir(cmd, len, (char *)p_sp, (char *)fname);\n  }\n\n  // Display the fully formed command.  Output a newline if there's something\n  // else than the :make command that was typed (in which case the cursor is\n  // in column 0).\n  if (msg_col == 0) {\n    msg_didout = false;\n  }\n  msg_start();\n  MSG_PUTS(\":!\");\n  msg_outtrans((char_u *)cmd);  // show what we are doing\n\n  return cmd;\n}\n\n// Used for \":make\", \":lmake\", \":grep\", \":lgrep\", \":grepadd\", and \":lgrepadd\"\nvoid ex_make(exarg_T *eap)\n{\n  char_u      *fname;\n  win_T       *wp = NULL;\n  qf_info_T   *qi = &ql_info;\n  int res;\n  char_u *enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n  // Redirect \":grep\" to \":vimgrep\" if 'grepprg' is \"internal\".\n  if (grep_internal(eap->cmdidx)) {\n    ex_vimgrep(eap);\n    return;\n  }\n\n  char_u *const au_name = make_get_auname(eap->cmdidx);\n  if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n                                        curbuf->b_fname, true, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n\n  if (is_loclist_cmd(eap->cmdidx)) {\n    wp = curwin;\n  }\n\n  autowrite_all();\n  fname = get_mef_name();\n  if (fname == NULL)\n    return;\n  os_remove((char *)fname);  // in case it's not unique\n\n  char *const cmd = make_get_fullcmd(eap->arg, fname);\n\n  do_shell((char_u *)cmd, 0);\n\n  incr_quickfix_busy();\n\n  res = qf_init(wp, fname, (eap->cmdidx != CMD_make\n                            && eap->cmdidx != CMD_lmake) ? p_gefm : p_efm,\n                (eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd),\n                qf_cmdtitle(*eap->cmdlinep), enc);\n  if (wp != NULL) {\n    qi = GET_LOC_LIST(wp);\n    if (qi == NULL) {\n      goto cleanup;\n    }\n  }\n  if (res >= 0) {\n    qf_list_changed(qf_get_curlist(qi));\n  }\n  // Remember the current quickfix list identifier, so that we can\n  // check for autocommands changing the current quickfix list.\n  unsigned save_qfid = qf_get_curlist(qi)->qf_id;\n  if (au_name != NULL) {\n    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname, true,\n                   curbuf);\n  }\n  if (res > 0 && !eap->forceit && qflist_valid(wp, save_qfid)) {\n    // display the first error\n    qf_jump_first(qi, save_qfid, false);\n  }\n\ncleanup:\n  decr_quickfix_busy();\n  os_remove((char *)fname);\n  xfree(fname);\n  xfree(cmd);\n}\n\n// Return the name for the errorfile, in allocated memory.\n// Find a new unique name when 'makeef' contains \"##\".\n// Returns NULL for error.\nstatic char_u *get_mef_name(void)\n{\n  char_u      *p;\n  char_u      *name;\n  static int start = -1;\n  static int off = 0;\n\n  if (*p_mef == NUL) {\n    name = vim_tempname();\n    if (name == NULL)\n      EMSG(_(e_notmp));\n    return name;\n  }\n\n  for (p = p_mef; *p; ++p)\n    if (p[0] == '#' && p[1] == '#')\n      break;\n\n  if (*p == NUL)\n    return vim_strsave(p_mef);\n\n  // Keep trying until the name doesn't exist yet.\n  for (;; ) {\n    if (start == -1) {\n      start = (int)os_get_pid();\n    } else {\n      off += 19;\n    }\n    name = xmalloc(STRLEN(p_mef) + 30);\n    STRCPY(name, p_mef);\n    sprintf((char *)name + (p - p_mef), \"%d%d\", start, off);\n    STRCAT(name, p + 2);\n    // Don't accept a symbolic link, it's a security risk.\n    FileInfo file_info;\n    bool file_or_link_found = os_fileinfo_link((char *)name, &file_info);\n    if (!file_or_link_found) {\n      break;\n    }\n    xfree(name);\n  }\n  return name;\n}\n\n/// Returns the number of entries in the current quickfix/location list.\nsize_t qf_get_size(exarg_T *eap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {\n    return 0;\n  }\n  return (size_t)qf_get_curlist(qi)->qf_count;\n}\n\n/// Returns the number of valid entries in the current quickfix/location list.\nsize_t qf_get_valid_size(exarg_T *eap)\n{\n  qf_info_T *qi;\n  qf_list_T *qfl;\n\n  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {\n    return 0;\n  }\n\n  int prev_fnum = 0;\n  size_t sz = 0;\n  qfline_T *qfp;\n  int i;\n  assert(qf_get_curlist(qi)->qf_count >= 0);\n  qfl = qf_get_curlist(qi);\n  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n    if (!qfp->qf_valid) {\n      continue;\n    }\n\n    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo) {\n      // Count all valid entries.\n      sz++;\n    } else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum) {\n      // Count the number of files.\n      sz++;\n      prev_fnum = qfp->qf_fnum;\n    }\n  }\n\n  return sz;\n}\n\n/// Returns the current index of the quickfix/location list.\n/// Returns 0 if there is an error.\nsize_t qf_get_cur_idx(exarg_T *eap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {\n    return 0;\n  }\n\n  assert(qf_get_curlist(qi)->qf_index >= 0);\n  return (size_t)qf_get_curlist(qi)->qf_index;\n}\n\n/// Returns the current index in the quickfix/location list,\n/// counting only valid entries.\n/// Returns 1 if there are no valid entries.\nint qf_get_cur_valid_idx(exarg_T *eap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_info_T *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {\n    return 1;\n  }\n\n  qf_list_T *qfl = qf_get_curlist(qi);\n\n  // Check if the list has valid errors.\n  if (!qf_list_has_valid_entries(qfl)) {\n    return 1;\n  }\n\n  int prev_fnum = 0;\n  int eidx = 0;\n  qfline_T *qfp;\n  size_t i;\n  assert(qfl->qf_index >= 0);\n  for (i = 1, qfp = qfl->qf_start;\n       i <= (size_t)qfl->qf_index && qfp != NULL;\n       i++, qfp = qfp->qf_next) {\n    if (!qfp->qf_valid) {\n      continue;\n    }\n\n    if (eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo) {\n      if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum) {\n        // Count the number of files.\n        eidx++;\n        prev_fnum = qfp->qf_fnum;\n      }\n    } else {\n      eidx++;\n    }\n  }\n\n  return eidx != 0 ? eidx : 1;\n}\n\n/// Get the 'n'th valid error entry in the quickfix or location list.\n///\n/// Used by :cdo, :ldo, :cfdo and :lfdo commands.\n/// For :cdo and :ldo, returns the 'n'th valid error entry.\n/// For :cfdo and :lfdo, returns the 'n'th valid file entry.\nstatic size_t qf_get_nth_valid_entry(qf_list_T *qfl, size_t n, int fdo)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Check if the list has valid errors.\n  if (!qf_list_has_valid_entries(qfl)) {\n    return 1;\n  }\n\n  int prev_fnum = 0;\n  size_t eidx = 0;\n  int i;\n  qfline_T *qfp;\n  assert(qfl->qf_count >= 0);\n  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n    if (qfp->qf_valid) {\n      if (fdo) {\n        if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum) {\n          // Count the number of files.\n          eidx++;\n          prev_fnum = qfp->qf_fnum;\n        }\n      } else {\n        eidx++;\n      }\n    }\n\n    if (eidx == n) {\n      break;\n    }\n  }\n\n  return i <= qfl->qf_count ? (size_t)i : 1;\n}\n\n/// \":cc\", \":crewind\", \":cfirst\" and \":clast\".\n/// \":ll\", \":lrewind\", \":lfirst\" and \":llast\".\n/// \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\".\nvoid ex_cc(exarg_T *eap)\n{\n  qf_info_T   *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  int errornr;\n  if (eap->addr_count > 0) {\n    errornr = (int)eap->line2;\n  } else {\n    switch (eap->cmdidx) {\n      case CMD_cc:\n      case CMD_ll:\n        errornr = 0;\n        break;\n      case CMD_crewind:\n      case CMD_lrewind:\n      case CMD_cfirst:\n      case CMD_lfirst:\n        errornr = 1;\n        break;\n      default:\n        errornr = 32767;\n        break;\n    }\n  }\n\n  // For cdo and ldo commands, jump to the nth valid error.\n  // For cfdo and lfdo commands, jump to the nth valid file entry.\n  if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo\n      || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo) {\n    size_t n;\n    if (eap->addr_count > 0) {\n      assert(eap->line1 >= 0);\n      n = (size_t)eap->line1;\n    } else {\n      n = 1;\n    }\n    size_t valid_entry = qf_get_nth_valid_entry(\n        qf_get_curlist(qi), n,\n        eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo);\n    assert(valid_entry <= INT_MAX);\n    errornr = (int)valid_entry;\n  }\n\n  qf_jump(qi, 0, errornr, eap->forceit);\n}\n\n/// \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n/// \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n/// \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\".\nvoid ex_cnext(exarg_T *eap)\n{\n  qf_info_T   *qi;\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  int errornr;\n  if (eap->addr_count > 0\n      && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n          && eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo)) {\n    errornr = (int)eap->line2;\n  } else {\n    errornr = 1;\n  }\n\n  // Depending on the command jump to either next or previous entry/file.\n  Direction dir;\n  switch (eap->cmdidx) {\n    case CMD_cprevious:\n    case CMD_lprevious:\n    case CMD_cNext:\n    case CMD_lNext:\n      dir = BACKWARD;\n      break;\n    case CMD_cnfile:\n    case CMD_lnfile:\n    case CMD_cfdo:\n    case CMD_lfdo:\n      dir = FORWARD_FILE;\n      break;\n    case CMD_cpfile:\n    case CMD_lpfile:\n    case CMD_cNfile:\n    case CMD_lNfile:\n      dir = BACKWARD_FILE;\n      break;\n    case CMD_cnext:\n    case CMD_lnext:\n    case CMD_cdo:\n    case CMD_ldo:\n    default:\n      dir = FORWARD;\n      break;\n  }\n\n  qf_jump(qi, dir, errornr, eap->forceit);\n}\n\n/// Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.\n/// The index of the entry is stored in 'errornr'.\n/// Returns NULL if an entry is not found.\nstatic qfline_T *qf_find_first_entry_in_buf(qf_list_T *qfl,\n                                            int bnr,\n                                            int *errornr)\n{\n  qfline_T *qfp = NULL;\n  int idx = 0;\n\n  // Find the first entry in this file\n  FOR_ALL_QFL_ITEMS(qfl, qfp, idx) {\n    if (qfp->qf_fnum == bnr) {\n      break;\n    }\n  }\n\n  *errornr = idx;\n  return qfp;\n}\n\n/// Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'\n/// with the error number for the first entry. Assumes the entries are sorted in\n/// the quickfix list by line number.\nstatic qfline_T * qf_find_first_entry_on_line(qfline_T *entry, int *errornr)\n{\n  while (!got_int\n         && entry->qf_prev != NULL\n         && entry->qf_fnum == entry->qf_prev->qf_fnum\n         && entry->qf_lnum == entry->qf_prev->qf_lnum) {\n    entry = entry->qf_prev;\n    (*errornr)--;\n  }\n\n  return entry;\n}\n\n/// Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'\n/// with the error number for the last entry. Assumes the entries are sorted in\n/// the quickfix list by line number.\nstatic qfline_T * qf_find_last_entry_on_line(qfline_T *entry, int *errornr)\n{\n  while (!got_int\n         && entry->qf_next != NULL\n         && entry->qf_fnum == entry->qf_next->qf_fnum\n         && entry->qf_lnum == entry->qf_next->qf_lnum) {\n    entry = entry->qf_next;\n    (*errornr)++;\n  }\n\n  return entry;\n}\n\n// Returns true if the specified quickfix entry is\n// after the given line (linewise is true)\n// or after the line and column.\nstatic bool qf_entry_after_pos(const qfline_T *qfp, const pos_T *pos,\n                               bool linewise)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (linewise) {\n    return qfp->qf_lnum > pos->lnum;\n  }\n  return qfp->qf_lnum > pos->lnum\n    || (qfp->qf_lnum == pos->lnum && qfp->qf_col > pos->col);\n}\n\n// Returns true if the specified quickfix entry is\n// before the given line (linewise is true)\n// or before the line and column.\nstatic bool qf_entry_before_pos(const qfline_T *qfp, const pos_T *pos,\n                                bool linewise)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (linewise) {\n    return qfp->qf_lnum < pos->lnum;\n  }\n  return qfp->qf_lnum < pos->lnum\n    || (qfp->qf_lnum == pos->lnum && qfp->qf_col < pos->col);\n}\n\n// Returns true if the specified quickfix entry is\n// on or after the given line (linewise is true)\n// or on or after the line and column.\nstatic bool qf_entry_on_or_after_pos(const qfline_T *qfp, const pos_T *pos,\n                                     bool linewise)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (linewise) {\n    return qfp->qf_lnum >= pos->lnum;\n  }\n  return qfp->qf_lnum > pos->lnum\n    || (qfp->qf_lnum == pos->lnum && qfp->qf_col >= pos->col);\n}\n\n// Returns true if the specified quickfix entry is\n// on or before the given line (linewise is true)\n// or on or before the line and column.\nstatic bool qf_entry_on_or_before_pos(const qfline_T *qfp, const pos_T *pos,\n                                      bool linewise)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (linewise) {\n    return qfp->qf_lnum <= pos->lnum;\n  }\n  return qfp->qf_lnum < pos->lnum\n    || (qfp->qf_lnum == pos->lnum && qfp->qf_col <= pos->col);\n}\n\n/// Find the first quickfix entry after position 'pos' in buffer 'bnr'.\n/// If 'linewise' is true, returns the entry after the specified line and treats\n/// multiple entries on a single line as one. Otherwise returns the entry after\n/// the specified line and column.\n/// 'qfp' points to the very first entry in the buffer and 'errornr' is the\n/// index of the very first entry in the quickfix list.\n/// Returns NULL if an entry is not found after 'pos'.\nstatic qfline_T *qf_find_entry_after_pos(\n    int bnr,\n    const pos_T *pos,\n    bool linewise,\n    qfline_T *qfp,\n    int *errornr\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (qf_entry_after_pos(qfp, pos, linewise)) {\n    // First entry is after position 'pos'\n    return qfp;\n  }\n\n  // Find the entry just before or at the position 'pos'\n  while (qfp->qf_next != NULL\n         && qfp->qf_next->qf_fnum == bnr\n         && qf_entry_on_or_before_pos(qfp->qf_next, pos, linewise)) {\n    qfp = qfp->qf_next;\n    (*errornr)++;\n  }\n\n  if (qfp->qf_next == NULL || qfp->qf_next->qf_fnum != bnr) {\n    // No entries found after position 'pos'\n    return NULL;\n  }\n\n  // Use the entry just after position 'pos'\n  qfp = qfp->qf_next;\n  (*errornr)++;\n\n  return qfp;\n}\n\n/// Find the first quickfix entry before position 'pos' in buffer 'bnr'.\n/// If 'linewise' is true, returns the entry before the specified line and\n/// treats multiple entries on a single line as one. Otherwise returns the entry\n/// before the specified line and column.\n/// 'qfp' points to the very first entry in the buffer and 'errornr' is the\n/// index of the very first entry in the quickfix list.\n/// Returns NULL if an entry is not found before 'pos'.\nstatic qfline_T *qf_find_entry_before_pos(\n    int bnr,\n    const pos_T *pos,\n    bool linewise,\n    qfline_T *qfp,\n    int *errornr\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Find the entry just before the position 'pos'\n  while (qfp->qf_next != NULL\n         && qfp->qf_next->qf_fnum == bnr\n         && qf_entry_before_pos(qfp->qf_next, pos, linewise)) {\n    qfp = qfp->qf_next;\n    (*errornr)++;\n  }\n\n  if (qf_entry_on_or_after_pos(qfp, pos, linewise)) {\n    return NULL;\n  }\n\n  if (linewise) {\n    // If multiple entries are on the same line, then use the first entry\n    qfp = qf_find_first_entry_on_line(qfp, errornr);\n  }\n\n  return qfp;\n}\n\n/// Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in\n/// the direction 'dir'.\nstatic qfline_T *qf_find_closest_entry(\n    qf_list_T *qfl,\n    int bnr,\n    const pos_T *pos,\n    Direction dir,\n    bool linewise,\n    int *errornr\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qfline_T *qfp;\n\n  *errornr = 0;\n\n  // Find the first entry in this file\n  qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);\n  if (qfp == NULL) {\n    return NULL;  // no entry in this file\n  }\n\n  if (dir == FORWARD) {\n    qfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);\n  } else {\n    qfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);\n  }\n\n  return qfp;\n}\n\n/// Get the nth quickfix entry below the specified entry.  Searches forward in\n/// the list. If linewise is true, then treat multiple entries on a single line\n/// as one.\nstatic void qf_get_nth_below_entry(qfline_T *entry, linenr_T n,\n                                   bool linewise, int *errornr)\n  FUNC_ATTR_NONNULL_ALL\n{\n  while (n-- > 0 && !got_int) {\n    // qfline_T *first_entry = entry;\n    int first_errornr = *errornr;\n\n    if (linewise) {\n      // Treat all the entries on the same line in this file as one\n      entry = qf_find_last_entry_on_line(entry, errornr);\n    }\n\n    if (entry->qf_next == NULL\n        || entry->qf_next->qf_fnum != entry->qf_fnum) {\n      if (linewise) {\n        // If multiple entries are on the same line, then use the first\n        // entry\n        // entry = first_entry;\n        *errornr = first_errornr;\n      }\n      break;\n    }\n\n    entry = entry->qf_next;\n    (*errornr)++;\n  }\n}\n\n/// Get the nth quickfix entry above the specified entry.  Searches backwards in\n/// the list. If linewise is TRUE, then treat multiple entries on a single line\n/// as one.\nstatic void qf_get_nth_above_entry(qfline_T *entry, linenr_T n,\n                                   bool linewise, int *errornr)\n  FUNC_ATTR_NONNULL_ALL\n{\n  while (n-- > 0 && !got_int) {\n    if (entry->qf_prev == NULL\n        || entry->qf_prev->qf_fnum != entry->qf_fnum) {\n      break;\n    }\n\n    entry = entry->qf_prev;\n    (*errornr)--;\n\n    if (linewise) {\n      entry = qf_find_first_entry_on_line(entry, errornr);\n    }\n  }\n}\n\n/// Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in\n/// the specified direction.  Returns the error number in the quickfix list or 0\n/// if an entry is not found.\nstatic int qf_find_nth_adj_entry(\n    qf_list_T *qfl,\n    int bnr,\n    pos_T *pos,\n    linenr_T n,\n    Direction dir,\n    bool linewise\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int errornr;\n\n  // Find an entry closest to the specified position\n  qfline_T *const adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir,\n                                                    linewise, &errornr);\n  if (adj_entry == NULL) {\n    return 0;\n  }\n\n  if (--n > 0) {\n    // Go to the n'th entry in the current buffer\n    if (dir == FORWARD) {\n      qf_get_nth_below_entry(adj_entry, n, linewise, &errornr);\n    } else {\n      qf_get_nth_above_entry(adj_entry, n, linewise, &errornr);\n    }\n  }\n\n  return errornr;\n}\n\n/// Jump to a quickfix entry in the current file nearest to the current line or\n/// current line/col.\n/// \":cabove\", \":cbelow\", \":labove\", \":lbelow\", \":cafter\", \":cbefore\",\n/// \":lafter\" and \":lbefore\" commands\nvoid ex_cbelow(exarg_T *eap)\n{\n  qf_info_T *qi;\n  qf_list_T *qfl;\n  int dir;\n  int buf_has_flag;\n\n  if (eap->addr_count > 0 && eap->line2 <= 0) {\n    EMSG(_(e_invrange));\n    return;\n  }\n\n  // Check whether the current buffer has any quickfix entries\n  if (eap->cmdidx == CMD_cabove || eap->cmdidx == CMD_cbelow\n      || eap->cmdidx == CMD_cbefore || eap->cmdidx == CMD_cafter) {\n    buf_has_flag = BUF_HAS_QF_ENTRY;\n  } else {\n    buf_has_flag = BUF_HAS_LL_ENTRY;\n  }\n  if (!(curbuf->b_has_qf_entry & buf_has_flag)) {\n    EMSG(_(e_quickfix));\n    return;\n  }\n\n  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {\n    return;\n  }\n\n  qfl = qf_get_curlist(qi);\n  // check if the list has valid errors\n  if (!qf_list_has_valid_entries(qfl)) {\n    EMSG(_(e_quickfix));\n    return;\n  }\n\n  if (eap->cmdidx == CMD_cbelow\n      || eap->cmdidx == CMD_lbelow\n      || eap->cmdidx == CMD_cafter\n      || eap->cmdidx == CMD_lafter) {\n    // Forward motion commands\n    dir = FORWARD;\n  } else {\n    dir = BACKWARD;\n  }\n\n  pos_T pos = curwin->w_cursor;\n  // A quickfix entry column number is 1 based whereas cursor column\n  // number is 0 based. Adjust the column number.\n  pos.col++;\n  const int errornr = qf_find_nth_adj_entry(\n      qfl,\n      curbuf->b_fnum,\n      &pos,\n      eap->addr_count > 0 ? eap->line2 : 0,\n      dir,\n      eap->cmdidx == CMD_cbelow\n      || eap->cmdidx == CMD_lbelow\n      || eap->cmdidx == CMD_cabove\n      || eap->cmdidx == CMD_labove);\n\n  if (errornr > 0) {\n    qf_jump(qi, 0, errornr, false);\n  } else {\n    EMSG(_(e_no_more_items));\n  }\n}\n\n\n/// Return the autocmd name for the :cfile Ex commands\nstatic char_u * cfile_get_auname(cmdidx_T cmdidx)\n{\n  switch (cmdidx) {\n    case CMD_cfile:    return (char_u *)\"cfile\";\n    case CMD_cgetfile: return (char_u *)\"cgetfile\";\n    case CMD_caddfile: return (char_u *)\"caddfile\";\n    case CMD_lfile:    return (char_u *)\"lfile\";\n    case CMD_lgetfile: return (char_u *)\"lgetfile\";\n    case CMD_laddfile: return (char_u *)\"laddfile\";\n    default:           return NULL;\n  }\n}\n\n\n// \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n// \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\nvoid ex_cfile(exarg_T *eap)\n{\n  win_T       *wp = NULL;\n  qf_info_T   *qi = &ql_info;\n  char_u      *au_name = NULL;\n\n  au_name = cfile_get_auname(eap->cmdidx);\n  if (au_name != NULL\n      && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name, NULL, false, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n  if (*eap->arg != NUL) {\n    set_string_option_direct(\"ef\", -1, eap->arg, OPT_FREE, 0);\n  }\n\n  char_u *enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n  if (is_loclist_cmd(eap->cmdidx)) {\n    wp = curwin;\n  }\n\n  incr_quickfix_busy();\n\n  // This function is used by the :cfile, :cgetfile and :caddfile\n  // commands.\n  // :cfile always creates a new quickfix list and jumps to the\n  // first error.\n  // :cgetfile creates a new quickfix list but doesn't jump to the\n  // first error.\n  // :caddfile adds to an existing quickfix list. If there is no\n  // quickfix list then a new list is created.\n  int res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n                                      && eap->cmdidx != CMD_laddfile),\n                    qf_cmdtitle(*eap->cmdlinep), enc);\n  if (wp != NULL) {\n    qi = GET_LOC_LIST(wp);\n    if (qi == NULL) {\n      decr_quickfix_busy();\n      return;\n    }\n  }\n  if (res >= 0) {\n    qf_list_changed(qf_get_curlist(qi));\n  }\n  unsigned save_qfid = qf_get_curlist(qi)->qf_id;\n  if (au_name != NULL) {\n    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, false, curbuf);\n  }\n  // Jump to the first error for a new list and if autocmds didn't free the\n  // list.\n  if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile)\n      && qflist_valid(wp, save_qfid)) {\n    // display the first error\n    qf_jump_first(qi, save_qfid, eap->forceit);\n  }\n\n  decr_quickfix_busy();\n}\n\n/// Return the vimgrep autocmd name.\nstatic char_u *vgr_get_auname(cmdidx_T cmdidx)\n{\n  switch (cmdidx) {\n    case CMD_vimgrep:     return (char_u *)\"vimgrep\";\n    case CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n    case CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n    case CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n    case CMD_grep:        return (char_u *)\"grep\";\n    case CMD_lgrep:       return (char_u *)\"lgrep\";\n    case CMD_grepadd:     return (char_u *)\"grepadd\";\n    case CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n    default:              return NULL;\n  }\n}\n\n/// Initialize the regmatch used by vimgrep for pattern \"s\".\nstatic void vgr_init_regmatch(regmmatch_T *regmatch, char_u *s)\n{\n  // Get the search pattern: either white-separated or enclosed in //.\n  regmatch->regprog = NULL;\n\n  if (s == NULL || *s == NUL) {\n    // Pattern is empty, use last search pattern.\n    if (last_search_pat() == NULL) {\n      EMSG(_(e_noprevre));\n      return;\n    }\n    regmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n  } else {\n    regmatch->regprog = vim_regcomp(s, RE_MAGIC);\n  }\n\n  regmatch->rmm_ic = p_ic;\n  regmatch->rmm_maxcol = 0;\n}\n\n\n/// Display a file name when vimgrep is running.\nstatic void vgr_display_fname(char_u *fname)\n{\n  msg_start();\n  char_u *p = msg_strtrunc(fname, true);\n  if (p == NULL) {\n    msg_outtrans(fname);\n  } else {\n    msg_outtrans(p);\n    xfree(p);\n  }\n  msg_clr_eos();\n  msg_didout = false;  // overwrite this message\n  msg_nowait = true;   // don't wait for this message\n  msg_col = 0;\n  ui_flush();\n}\n\n/// Load a dummy buffer to search for a pattern using vimgrep.\nstatic buf_T *vgr_load_dummy_buf(char_u *fname, char_u *dirname_start,\n                                 char_u *dirname_now)\n{\n  // Don't do Filetype autocommands to avoid loading syntax and\n  // indent scripts, a great speed improvement.\n  char_u *save_ei = au_event_disable(\",Filetype\");\n\n  long save_mls = p_mls;\n  p_mls = 0;\n\n  // Load file into a buffer, so that 'fileencoding' is detected,\n  // autocommands applied, etc.\n  buf_T *buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n  p_mls = save_mls;\n  au_event_restore(save_ei);\n\n  return buf;\n}\n\n/// Check whether a quickfix/location list is valid. Autocmds may remove or\n/// change a quickfix list when vimgrep is running. If the list is not found,\n/// create a new list.\nstatic bool vgr_qflist_valid(win_T *wp, qf_info_T *qi, unsigned qfid,\n                             char_u *title)\n{\n  // Verify that the quickfix/location list was not freed by an autocmd\n  if (!qflist_valid(wp, qfid)) {\n    if (wp != NULL) {\n      // An autocmd has freed the location list\n      EMSG(_(e_current_location_list_was_changed));\n      return false;\n    } else {\n      // Quickfix list is not found, create a new one.\n      qf_new_list(qi, title);\n      return true;\n    }\n  }\n  if (qf_restore_list(qi, qfid) == FAIL) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/// Search for a pattern in all the lines in a buffer and add the matching lines\n/// to a quickfix list.\nstatic bool vgr_match_buflines(qf_list_T *qfl, char_u *fname, buf_T *buf,\n                               regmmatch_T *regmatch, long *tomatch,\n                               int duplicate_name, int flags)\n  FUNC_ATTR_NONNULL_ARG(1, 3, 4, 5)\n{\n  bool found_match = false;\n\n  for (long lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; lnum++) {\n    colnr_T col = 0;\n    while (vim_regexec_multi(regmatch, curwin, buf, lnum, col, NULL,\n                             NULL) > 0) {\n      // Pass the buffer number so that it gets used even for a\n      // dummy buffer, unless duplicate_name is set, then the\n      // buffer will be wiped out below.\n      if (qf_add_entry(qfl,\n                       NULL,  // dir\n                       fname,\n                       NULL,\n                       duplicate_name ? 0 : buf->b_fnum,\n                       ml_get_buf(buf, regmatch->startpos[0].lnum + lnum,\n                                  false),\n                       regmatch->startpos[0].lnum + lnum,\n                       regmatch->endpos[0].lnum + lnum,\n                       regmatch->startpos[0].col + 1,\n                       regmatch->endpos[0].col + 1,\n                       false,  // vis_col\n                       NULL,   // search pattern\n                       0,      // nr\n                       0,      // type\n                       true)    // valid\n          == QF_FAIL) {\n        got_int = true;\n        break;\n      }\n      found_match = true;\n      if (--*tomatch == 0) {\n        break;\n      }\n      if ((flags & VGR_GLOBAL) == 0 || regmatch->endpos[0].lnum > 0) {\n        break;\n      }\n      col = regmatch->endpos[0].col + (col == regmatch->endpos[0].col);\n      if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, false))) {\n        break;\n      }\n    }\n    line_breakcheck();\n    if (got_int) {\n      break;\n    }\n  }\n\n  return found_match;\n}\n\n/// Jump to the first match and update the directory.\nstatic void vgr_jump_to_match(qf_info_T *qi, int forceit, int *redraw_for_dummy,\n                              buf_T *first_match_buf, char_u *target_dir)\n{\n  buf_T *buf = curbuf;\n  qf_jump(qi, 0, 0, forceit);\n  if (buf != curbuf) {\n    // If we jumped to another buffer redrawing will already be\n    // taken care of.\n    *redraw_for_dummy = false;\n  }\n\n  // Jump to the directory used after loading the buffer.\n  if (curbuf == first_match_buf && target_dir != NULL) {\n    exarg_T ea = {\n      .arg = target_dir,\n      .cmdidx = CMD_lcd,\n    };\n    ex_cd(&ea);\n  }\n}\n\n// Return true if \"buf\" had an existing swap file, the current swap file does\n// not end in \".swp\".\nstatic bool existing_swapfile(const buf_T *buf)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL) {\n    const char_u *const fname = buf->b_ml.ml_mfp->mf_fname;\n    const size_t len = STRLEN(fname);\n\n    return fname[len - 1] != 'p' || fname[len - 2] != 'w';\n  }\n  return false;\n}\n\n// \":vimgrep {pattern} file(s)\"\n// \":vimgrepadd {pattern} file(s)\"\n// \":lvimgrep {pattern} file(s)\"\n// \":lvimgrepadd {pattern} file(s)\"\nvoid ex_vimgrep(exarg_T *eap)\n{\n  regmmatch_T regmatch;\n  int fcount;\n  char_u      **fnames;\n  char_u      *fname;\n  char_u      *s;\n  char_u      *p;\n  int fi;\n  qf_list_T   *qfl;\n  win_T *wp = NULL;\n  buf_T       *buf;\n  int duplicate_name = FALSE;\n  int using_dummy;\n  int redraw_for_dummy = FALSE;\n  int found_match;\n  buf_T       *first_match_buf = NULL;\n  time_t seconds = 0;\n  aco_save_T aco;\n  int flags = 0;\n  long tomatch;\n  char_u      *dirname_start = NULL;\n  char_u      *dirname_now = NULL;\n  char_u      *target_dir = NULL;\n  char_u      *au_name =  NULL;\n\n  au_name = vgr_get_auname(eap->cmdidx);\n  if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n                                        curbuf->b_fname, true, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n\n  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n\n  if (eap->addr_count > 0)\n    tomatch = eap->line2;\n  else\n    tomatch = MAXLNUM;\n\n  // Get the search pattern: either white-separated or enclosed in //\n  regmatch.regprog = NULL;\n  char_u *title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));\n  p = skip_vimgrep_pat(eap->arg, &s, &flags);\n  if (p == NULL) {\n    EMSG(_(e_invalpat));\n    goto theend;\n  }\n\n  vgr_init_regmatch(&regmatch, s);\n  if (regmatch.regprog == NULL) {\n    goto theend;\n  }\n\n  p = skipwhite(p);\n  if (*p == NUL) {\n    EMSG(_(\"E683: File name missing or invalid pattern\"));\n    goto theend;\n  }\n\n  if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd\n       && eap->cmdidx != CMD_vimgrepadd && eap->cmdidx != CMD_lvimgrepadd)\n      || qf_stack_empty(qi)) {\n    // make place for a new list\n    qf_new_list(qi, title);\n  }\n\n  // Parse the list of arguments, wildcards have already been expanded.\n  if (get_arglist_exp(p, &fcount, &fnames, true) == FAIL) {\n    goto theend;\n  }\n  if (fcount == 0) {\n    EMSG(_(e_nomatch));\n    goto theend;\n  }\n\n  dirname_start = xmalloc(MAXPATHL);\n  dirname_now = xmalloc(MAXPATHL);\n\n  // Remember the current directory, because a BufRead autocommand that does\n  // \":lcd %:p:h\" changes the meaning of short path names.\n  os_dirname(dirname_start, MAXPATHL);\n\n  incr_quickfix_busy();\n\n  // Remember the current quickfix list identifier, so that we can check for\n  // autocommands changing the current quickfix list.\n  unsigned save_qfid = qf_get_curlist(qi)->qf_id;\n\n  seconds = (time_t)0;\n  for (fi = 0; fi < fcount && !got_int && tomatch > 0; fi++) {\n    fname = path_try_shorten_fname(fnames[fi]);\n    if (time(NULL) > seconds) {\n      // Display the file name every second or so, show the user we are\n      // working on it.\n      seconds = time(NULL);\n      vgr_display_fname(fname);\n    }\n\n    buf = buflist_findname_exp(fnames[fi]);\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL) {\n      // Remember that a buffer with this name already exists.\n      duplicate_name = (buf != NULL);\n      using_dummy = TRUE;\n      redraw_for_dummy = TRUE;\n\n      buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);\n    } else {\n      // Use existing, loaded buffer.\n      using_dummy = false;\n    }\n\n    // Check whether the quickfix list is still valid. When loading a\n    // buffer above, autocommands might have changed the quickfix list.\n    if (!vgr_qflist_valid(wp, qi, save_qfid, *eap->cmdlinep)) {\n      FreeWild(fcount, fnames);\n      decr_quickfix_busy();\n      goto theend;\n    }\n    save_qfid = qf_get_curlist(qi)->qf_id;\n\n    if (buf == NULL) {\n      if (!got_int)\n        smsg(_(\"Cannot open file \\\"%s\\\"\"), fname);\n    } else {\n      // Try for a match in all lines of the buffer.\n      // For \":1vimgrep\" look for first match only.\n      found_match = vgr_match_buflines(qf_get_curlist(qi),\n                                       fname, buf, &regmatch, &tomatch,\n                                       duplicate_name, flags);\n\n      if (using_dummy) {\n        if (found_match && first_match_buf == NULL)\n          first_match_buf = buf;\n        if (duplicate_name) {\n          // Never keep a dummy buffer if there is another buffer\n          // with the same name.\n          wipe_dummy_buffer(buf, dirname_start);\n          buf = NULL;\n        } else if (!cmdmod.hide\n                   || buf->b_p_bh[0] == 'u'             // \"unload\"\n                   || buf->b_p_bh[0] == 'w'             // \"wipe\"\n                   || buf->b_p_bh[0] == 'd') {          // \"delete\"\n          // When no match was found we don't need to remember the\n          // buffer, wipe it out.  If there was a match and it\n          // wasn't the first one or we won't jump there: only\n          // unload the buffer.\n          // Ignore 'hidden' here, because it may lead to having too\n          // many swap files.\n          if (!found_match) {\n            wipe_dummy_buffer(buf, dirname_start);\n            buf = NULL;\n          } else if (buf != first_match_buf\n                     || (flags & VGR_NOJUMP)\n                     || existing_swapfile(buf)) {\n            unload_dummy_buffer(buf, dirname_start);\n            // Keeping the buffer, remove the dummy flag.\n            buf->b_flags &= ~BF_DUMMY;\n            buf = NULL;\n          }\n        }\n\n        if (buf != NULL) {\n          // Keeping the buffer, remove the dummy flag.\n          buf->b_flags &= ~BF_DUMMY;\n\n          // If the buffer is still loaded we need to use the\n          // directory we jumped to below.\n          if (buf == first_match_buf\n              && target_dir == NULL\n              && STRCMP(dirname_start, dirname_now) != 0) {\n            target_dir = vim_strsave(dirname_now);\n          }\n\n          // The buffer is still loaded, the Filetype autocommands\n          // need to be done now, in that buffer.  And the modelines\n          // need to be done (again).  But not the window-local\n          // options!\n          aucmd_prepbuf(&aco, buf);\n          apply_autocmds(EVENT_FILETYPE, buf->b_p_ft, buf->b_fname, true, buf);\n          do_modelines(OPT_NOWIN);\n          aucmd_restbuf(&aco);\n        }\n      }\n    }\n  }\n\n  FreeWild(fcount, fnames);\n\n  qfl = qf_get_curlist(qi);\n  qfl->qf_nonevalid = false;\n  qfl->qf_ptr = qfl->qf_start;\n  qfl->qf_index = 1;\n  qf_list_changed(qfl);\n\n  qf_update_buffer(qi, NULL);\n\n  if (au_name != NULL) {\n    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname, true, curbuf);\n  }\n\n  // The QuickFixCmdPost autocmd may free the quickfix list. Check the list\n  // is still valid.\n  if (!qflist_valid(wp, save_qfid)\n      || qf_restore_list(qi, save_qfid) == FAIL) {\n    decr_quickfix_busy();\n    goto theend;\n  }\n\n  // Jump to first match.\n  if (!qf_list_empty(qf_get_curlist(qi))) {\n    if ((flags & VGR_NOJUMP) == 0) {\n      vgr_jump_to_match(qi, eap->forceit, &redraw_for_dummy, first_match_buf,\n                        target_dir);\n    }\n  } else\n    EMSG2(_(e_nomatch2), s);\n\n  decr_quickfix_busy();\n\n  // If we loaded a dummy buffer into the current window, the autocommands\n  // may have messed up things, need to redraw and recompute folds.\n  if (redraw_for_dummy) {\n    foldUpdateAll(curwin);\n  }\n\ntheend:\n  xfree(title);\n  xfree(dirname_now);\n  xfree(dirname_start);\n  xfree(target_dir);\n  vim_regfree(regmatch.regprog);\n}\n\n// Restore current working directory to \"dirname_start\" if they differ, taking\n// into account whether it is set locally or globally.\nstatic void restore_start_dir(char_u *dirname_start)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *dirname_now = xmalloc(MAXPATHL);\n\n  os_dirname(dirname_now, MAXPATHL);\n  if (STRCMP(dirname_start, dirname_now) != 0) {\n    // If the directory has changed, change it back by building up an\n    // appropriate ex command and executing it.\n    exarg_T ea = {\n      .arg = dirname_start,\n      .cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd,\n    };\n    ex_cd(&ea);\n  }\n  xfree(dirname_now);\n}\n\n// Load file \"fname\" into a dummy buffer and return the buffer pointer,\n// placing the directory resulting from the buffer load into the\n// \"resulting_dir\" pointer. \"resulting_dir\" must be allocated by the caller\n// prior to calling this function. Restores directory to \"dirname_start\" prior\n// to returning, if autocmds or the 'autochdir' option have changed it.\n//\n// If creating the dummy buffer does not fail, must call unload_dummy_buffer()\n// or wipe_dummy_buffer() later!\n//\n// Returns NULL if it fails.\nstatic buf_T *\nload_dummy_buffer (\n    char_u *fname,\n    char_u *dirname_start,      // in: old directory\n    char_u *resulting_dir       // out: new directory\n)\n{\n  buf_T       *newbuf;\n  bufref_T newbufref;\n  bufref_T newbuf_to_wipe;\n  int failed = true;\n  aco_save_T aco;\n  int readfile_result;\n\n  // Allocate a buffer without putting it in the buffer list.\n  newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n  if (newbuf == NULL) {\n    return NULL;\n  }\n  set_bufref(&newbufref, newbuf);\n\n  // Init the options.\n  buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);\n\n  // need to open the memfile before putting the buffer in a window\n  if (ml_open(newbuf) == OK) {\n    // Make sure this buffer isn't wiped out by autocommands.\n    newbuf->b_locked++;\n    // set curwin/curbuf to buf and save a few things\n    aucmd_prepbuf(&aco, newbuf);\n\n    // Need to set the filename for autocommands.\n    (void)setfname(curbuf, fname, NULL, false);\n\n    // Create swap file now to avoid the ATTENTION message.\n    check_need_swap(true);\n\n    // Remove the \"dummy\" flag, otherwise autocommands may not\n    // work.\n    curbuf->b_flags &= ~BF_DUMMY;\n\n    newbuf_to_wipe.br_buf = NULL;\n    readfile_result = readfile(fname, NULL, (linenr_T)0, (linenr_T)0,\n                               (linenr_T)MAXLNUM, NULL,\n                               READ_NEW | READ_DUMMY);\n    newbuf->b_locked--;\n    if (readfile_result == OK\n        && !got_int\n        && !(curbuf->b_flags & BF_NEW)) {\n      failed = FALSE;\n      if (curbuf != newbuf) {\n        // Bloody autocommands changed the buffer!  Can happen when\n        // using netrw and editing a remote file.  Use the current\n        // buffer instead, delete the dummy one after restoring the\n        // window stuff.\n        set_bufref(&newbuf_to_wipe, newbuf);\n        newbuf = curbuf;\n      }\n    }\n\n    // Restore curwin/curbuf and a few other things.\n    aucmd_restbuf(&aco);\n    if (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe)) {\n      wipe_buffer(newbuf_to_wipe.br_buf, false);\n    }\n\n    // Add back the \"dummy\" flag, otherwise buflist_findname_file_id()\n    // won't skip it.\n    newbuf->b_flags |= BF_DUMMY;\n  }\n\n  // When autocommands/'autochdir' option changed directory: go back.\n  // Let the caller know what the resulting dir was first, in case it is\n  // important.\n  os_dirname(resulting_dir, MAXPATHL);\n  restore_start_dir(dirname_start);\n\n  if (!bufref_valid(&newbufref)) {\n    return NULL;\n  }\n  if (failed) {\n    wipe_dummy_buffer(newbuf, dirname_start);\n    return NULL;\n  }\n  return newbuf;\n}\n\n// Wipe out the dummy buffer that load_dummy_buffer() created. Restores\n// directory to \"dirname_start\" prior to returning, if autocmds or the\n// 'autochdir' option have changed it.\nstatic void wipe_dummy_buffer(buf_T *buf, char_u *dirname_start)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // If any autocommand opened a window on the dummy buffer, close that\n  // window.  If we can't close them all then give up.\n  while (buf->b_nwindows > 0) {\n    bool did_one = false;\n\n    if (firstwin->w_next != NULL) {\n      for (win_T *wp = firstwin; wp != NULL; wp = wp->w_next) {\n        if (wp->w_buffer == buf) {\n          if (win_close(wp, false) == OK) {\n            did_one = true;\n          }\n          break;\n        }\n      }\n    }\n    if (!did_one) {\n      return;\n    }\n  }\n\n  if (curbuf != buf && buf->b_nwindows == 0) {  // safety check\n    cleanup_T cs;\n\n    // Reset the error/interrupt/exception state here so that aborting()\n    // returns FALSE when wiping out the buffer.  Otherwise it doesn't\n    // work when got_int is set.\n    enter_cleanup(&cs);\n\n    wipe_buffer(buf, true);\n\n    // Restore the error/interrupt/exception state if not discarded by a\n    // new aborting error, interrupt, or uncaught exception.\n    leave_cleanup(&cs);\n    // When autocommands/'autochdir' option changed directory: go back.\n    restore_start_dir(dirname_start);\n  }\n}\n\n// Unload the dummy buffer that load_dummy_buffer() created. Restores\n// directory to \"dirname_start\" prior to returning, if autocmds or the\n// 'autochdir' option have changed it.\nstatic void unload_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n  if (curbuf != buf) {          // safety check\n    close_buffer(NULL, buf, DOBUF_UNLOAD, false);\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    restore_start_dir(dirname_start);\n  }\n}\n\n/// Copy the specified quickfix entry items into a new dict and append the dict\n/// to 'list'.  Returns OK on success.\nstatic int get_qfline_items(qfline_T *qfp, list_T *list)\n{\n  char_u buf[2];\n  int bufnum;\n\n  // Handle entries with a non-existing buffer number.\n  bufnum = qfp->qf_fnum;\n  if (bufnum != 0 && (buflist_findnr(bufnum) == NULL)) {\n    bufnum = 0;\n  }\n\n  dict_T *const dict = tv_dict_alloc();\n  tv_list_append_dict(list, dict);\n\n  buf[0] = qfp->qf_type;\n  buf[1] = NUL;\n  if (tv_dict_add_nr(dict, S_LEN(\"bufnr\"), (varnumber_T)bufnum) == FAIL\n      || (tv_dict_add_nr(dict, S_LEN(\"lnum\"), (varnumber_T)qfp->qf_lnum)\n          == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"end_lnum\"), (varnumber_T)qfp->qf_end_lnum)\n          == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"col\"), (varnumber_T)qfp->qf_col) == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"end_col\"), (varnumber_T)qfp->qf_end_col)\n          == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"vcol\"), (varnumber_T)qfp->qf_viscol)\n          == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"nr\"), (varnumber_T)qfp->qf_nr) == FAIL)\n      || (tv_dict_add_str(\n          dict, S_LEN(\"module\"),\n          (qfp->qf_module == NULL ? \"\" : (const char *)qfp->qf_module))\n          == FAIL)\n      || (tv_dict_add_str(\n          dict, S_LEN(\"pattern\"),\n          (qfp->qf_pattern == NULL ? \"\" : (const char *)qfp->qf_pattern))\n          == FAIL)\n      || (tv_dict_add_str(\n          dict, S_LEN(\"text\"),\n          (qfp->qf_text == NULL ? \"\" : (const char *)qfp->qf_text))\n          == FAIL)\n      || (tv_dict_add_str(dict, S_LEN(\"type\"), (const char *)buf) == FAIL)\n      || (tv_dict_add_nr(dict, S_LEN(\"valid\"), (varnumber_T)qfp->qf_valid)\n          == FAIL)) {\n    // tv_dict_add* fail only if key already exist, but this is a newly\n    // allocated dictionary which is thus guaranteed to have no existing keys.\n    abort();\n  }\n\n  return OK;\n}\n\n/// Add each quickfix error to list \"list\" as a dictionary.\n/// If qf_idx is -1, use the current list. Otherwise, use the specified list.\n/// If eidx is not 0, then return only the specified entry. Otherwise return\n/// all the entries.\nint get_errorlist(qf_info_T *qi_arg, win_T *wp, int qf_idx, int eidx,\n                  list_T *list)\n{\n  qf_info_T *qi = qi_arg;\n  qf_list_T *qfl;\n  qfline_T    *qfp;\n  int i;\n\n  if (qi == NULL) {\n    qi = &ql_info;\n    if (wp != NULL) {\n      qi = GET_LOC_LIST(wp);\n      if (qi == NULL) {\n        return FAIL;\n      }\n    }\n  }\n\n  if (eidx < 0) {\n    return OK;\n  }\n\n  if (qf_idx == INVALID_QFIDX) {\n    qf_idx = qi->qf_curlist;\n  }\n\n  if (qf_idx >= qi->qf_listcount) {\n    return FAIL;\n  }\n\n  qfl = qf_get_list(qi, qf_idx);\n  if (qf_list_empty(qfl)) {\n    return FAIL;\n  }\n\n  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {\n    if (eidx > 0) {\n      if (eidx == i) {\n        return get_qfline_items(qfp, list);\n      }\n    } else if (get_qfline_items(qfp, list) == FAIL) {\n        return FAIL;\n    }\n  }\n\n  return OK;\n}\n\n/// Flags used by getqflist()/getloclist() to determine which fields to return.\nenum {\n  QF_GETLIST_NONE = 0x0,\n  QF_GETLIST_TITLE = 0x1,\n  QF_GETLIST_ITEMS = 0x2,\n  QF_GETLIST_NR = 0x4,\n  QF_GETLIST_WINID = 0x8,\n  QF_GETLIST_CONTEXT = 0x10,\n  QF_GETLIST_ID = 0x20,\n  QF_GETLIST_IDX = 0x40,\n  QF_GETLIST_SIZE = 0x80,\n  QF_GETLIST_TICK = 0x100,\n  QF_GETLIST_FILEWINID = 0x200,\n  QF_GETLIST_QFBUFNR = 0x400,\n  QF_GETLIST_QFTF = 0x800,\n  QF_GETLIST_ALL = 0xFFF,\n};\n\n/// Parse text from 'di' and return the quickfix list items.\n/// Existing quickfix lists are not modified.\nstatic int qf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)\n{\n  int status = FAIL;\n  char_u *errorformat = p_efm;\n  dictitem_T *efm_di;\n\n  // Only a List value is supported\n  if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL) {\n    // If errorformat is supplied then use it, otherwise use the 'efm'\n    // option setting\n    if ((efm_di = tv_dict_find(what, S_LEN(\"efm\"))) != NULL) {\n      if (efm_di->di_tv.v_type != VAR_STRING\n          || efm_di->di_tv.vval.v_string == NULL) {\n        return FAIL;\n      }\n      errorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    list_T *l = tv_list_alloc(kListLenMayKnow);\n    qf_info_T *const qi = qf_alloc_stack(QFLT_INTERNAL);\n\n    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,\n                    true, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0) {\n      (void)get_errorlist(qi, NULL, 0, 0, l);\n      qf_free(&qi->qf_lists[0]);\n    }\n    xfree(qi);\n\n    tv_dict_add_list(retdict, S_LEN(\"items\"), l);\n    status = OK;\n  }\n\n  return status;\n}\n\n/// Return the quickfix/location list window identifier in the current tabpage.\nstatic int qf_winid(qf_info_T *qi)\n{\n  // The quickfix window can be opened even if the quickfix list is not set\n  // using \":copen\". This is not true for location lists.\n  if (qi == NULL) {\n    return 0;\n  }\n  win_T *win = qf_find_win(qi);\n  if (win != NULL) {\n    return win->handle;\n  }\n  return 0;\n}\n\n/// Convert the keys in 'what' to quickfix list property flags.\nstatic int qf_getprop_keys2flags(const dict_T *what, bool loclist)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int flags = QF_GETLIST_NONE;\n\n  if (tv_dict_find(what, S_LEN(\"all\")) != NULL) {\n    flags |= QF_GETLIST_ALL;\n    if (!loclist) {\n      // File window ID is applicable only to location list windows\n      flags &= ~QF_GETLIST_FILEWINID;\n    }\n  }\n  if (tv_dict_find(what, S_LEN(\"title\")) != NULL) {\n    flags |= QF_GETLIST_TITLE;\n  }\n  if (tv_dict_find(what, S_LEN(\"nr\")) != NULL) {\n    flags |= QF_GETLIST_NR;\n  }\n  if (tv_dict_find(what, S_LEN(\"winid\")) != NULL) {\n    flags |= QF_GETLIST_WINID;\n  }\n  if (tv_dict_find(what, S_LEN(\"context\")) != NULL) {\n    flags |= QF_GETLIST_CONTEXT;\n  }\n  if (tv_dict_find(what, S_LEN(\"id\")) != NULL) {\n    flags |= QF_GETLIST_ID;\n  }\n  if (tv_dict_find(what, S_LEN(\"items\")) != NULL) {\n    flags |= QF_GETLIST_ITEMS;\n  }\n  if (tv_dict_find(what, S_LEN(\"idx\")) != NULL) {\n    flags |= QF_GETLIST_IDX;\n  }\n  if (tv_dict_find(what, S_LEN(\"size\")) != NULL) {\n    flags |= QF_GETLIST_SIZE;\n  }\n  if (tv_dict_find(what, S_LEN(\"changedtick\")) != NULL) {\n    flags |= QF_GETLIST_TICK;\n  }\n  if (loclist && tv_dict_find(what, S_LEN(\"filewinid\")) != NULL) {\n    flags |= QF_GETLIST_FILEWINID;\n  }\n  if (tv_dict_find(what, S_LEN(\"quickfixtextfunc\")) != NULL) {\n    flags |= QF_GETLIST_QFTF;\n  }\n\n  return flags;\n}\n\n/// Return the quickfix list index based on 'nr' or 'id' in 'what'.\n///\n/// If 'nr' and 'id' are not present in 'what' then return the current\n/// quickfix list index.\n/// If 'nr' is zero then return the current quickfix list index.\n/// If 'nr' is '$' then return the last quickfix list index.\n/// If 'id' is present then return the index of the quickfix list with that id.\n/// If 'id' is zero then return the quickfix list index specified by 'nr'.\n/// Return -1, if quickfix list is not present or if the stack is empty.\nstatic int qf_getprop_qfidx(qf_info_T *qi, dict_T *what)\n{\n  dictitem_T *di = NULL;\n\n  int qf_idx = qi->qf_curlist;  // default is the current list\n  if ((di = tv_dict_find(what, S_LEN(\"nr\"))) != NULL) {\n    // Use the specified quickfix/location list\n    if (di->di_tv.v_type == VAR_NUMBER) {\n      // for zero use the current list\n      if (di->di_tv.vval.v_number != 0) {\n        qf_idx = (int)di->di_tv.vval.v_number - 1;\n        if (qf_idx < 0 || qf_idx >= qi->qf_listcount) {\n          qf_idx = INVALID_QFIDX;\n        }\n      }\n    } else if (di->di_tv.v_type == VAR_STRING\n               && strequal((const char *)di->di_tv.vval.v_string, \"$\")) {\n      // Get the last quickfix list number\n      qf_idx = qi->qf_listcount - 1;\n    } else {\n      qf_idx = INVALID_QFIDX;\n    }\n  }\n\n  if ((di = tv_dict_find(what, S_LEN(\"id\"))) != NULL) {\n    // Look for a list with the specified id\n    if (di->di_tv.v_type == VAR_NUMBER) {\n      // For zero, use the current list or the list specified by 'nr'\n      if (di->di_tv.vval.v_number != 0) {\n        qf_idx = qf_id2nr(qi, (unsigned)di->di_tv.vval.v_number);\n      }\n    } else {\n      qf_idx = INVALID_QFIDX;\n    }\n  }\n\n  return qf_idx;\n}\n\n/// Return default values for quickfix list properties in retdict.\nstatic int qf_getprop_defaults(qf_info_T *qi,\n                               int flags,\n                               int locstack,\n                               dict_T *retdict)\n{\n  int status = OK;\n\n  if (flags & QF_GETLIST_TITLE) {\n    status = tv_dict_add_str(retdict, S_LEN(\"title\"), (const char *)\"\");\n  }\n  if ((status == OK) && (flags & QF_GETLIST_ITEMS)) {\n    list_T *l = tv_list_alloc(kListLenMayKnow);\n    status = tv_dict_add_list(retdict, S_LEN(\"items\"), l);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_NR)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"nr\"), 0);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_WINID)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"winid\"), qf_winid(qi));\n  }\n  if ((status == OK) && (flags & QF_GETLIST_CONTEXT)) {\n    status = tv_dict_add_str(retdict, S_LEN(\"context\"), (const char *)\"\");\n  }\n  if ((status == OK) && (flags & QF_GETLIST_ID)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"id\"), 0);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_IDX)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"idx\"), 0);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_SIZE)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"size\"), 0);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_TICK)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"changedtick\"), 0);\n  }\n  if ((status == OK) && locstack && (flags & QF_GETLIST_FILEWINID)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"filewinid\"), 0);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_QFTF)) {\n    status = tv_dict_add_str(retdict, S_LEN(\"quickfixtextfunc\"), \"\");\n  }\n\n  return status;\n}\n\n/// Return the quickfix list title as 'title' in retdict\nstatic int qf_getprop_title(qf_list_T *qfl, dict_T *retdict)\n{\n    return tv_dict_add_str(retdict, S_LEN(\"title\"),\n                           (const char *)qfl->qf_title);\n}\n\n// Returns the identifier of the window used to display files from a location\n// list.  If there is no associated window, then returns 0. Useful only when\n// called from a location list window.\nstatic int qf_getprop_filewinid(const win_T *wp, const qf_info_T *qi,\n                                dict_T *retdict)\n  FUNC_ATTR_NONNULL_ARG(3)\n{\n  handle_T winid = 0;\n\n  if (wp != NULL && IS_LL_WINDOW(wp)) {\n    win_T *ll_wp = qf_find_win_with_loclist(qi);\n    if (ll_wp != NULL) {\n      winid = ll_wp->handle;\n    }\n  }\n\n  return tv_dict_add_nr(retdict, S_LEN(\"filewinid\"), winid);\n}\n\n/// Return the quickfix list items/entries as 'items' in retdict.\n/// If eidx is not 0, then return the item at the specified index.\nstatic int qf_getprop_items(qf_info_T *qi, int qf_idx, int eidx,\n                            dict_T *retdict)\n{\n  list_T *l = tv_list_alloc(kListLenMayKnow);\n  get_errorlist(qi, NULL, qf_idx, eidx, l);\n  tv_dict_add_list(retdict, S_LEN(\"items\"), l);\n\n  return OK;\n}\n\n/// Return the quickfix list context (if any) as 'context' in retdict.\nstatic int qf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)\n{\n  int status;\n\n  if (qfl->qf_ctx != NULL) {\n    dictitem_T *di = tv_dict_item_alloc_len(S_LEN(\"context\"));\n    tv_copy(qfl->qf_ctx, &di->di_tv);\n    status = tv_dict_add(retdict, di);\n    if (status == FAIL) {\n      tv_dict_item_free(di);\n    }\n  } else {\n    status = tv_dict_add_str(retdict, S_LEN(\"context\"), \"\");\n  }\n\n  return status;\n}\n\n/// Return the current quickfix list index as 'idx' in retdict.\n/// If a specific entry index (eidx) is supplied, then use that.\nstatic int qf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)\n{\n  if (eidx == 0) {\n    eidx = qfl->qf_index;\n    if (qf_list_empty(qfl)) {\n      // For empty lists, current index is set to 0\n      eidx = 0;\n    }\n  }\n  return tv_dict_add_nr(retdict, S_LEN(\"idx\"), eidx);\n}\n\n/// Return the 'quickfixtextfunc' function of a quickfix/location list\n/// @return OK or FAIL\nstatic int qf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int status;\n\n  if (qfl->qftf_cb.type != kCallbackNone) {\n    typval_T tv;\n\n    callback_put(&qfl->qftf_cb, &tv);\n    status = tv_dict_add_tv(retdict, S_LEN(\"quickfixtextfunc\"), &tv);\n    tv_clear(&tv);\n  } else {\n    status = tv_dict_add_str(retdict, S_LEN(\"quickfixtextfunc\"), \"\");\n  }\n\n  return status;\n}\n\n/// Return quickfix/location list details (title) as a dictionary.\n/// 'what' contains the details to return. If 'list_idx' is -1,\n/// then current list is used. Otherwise the specified list is used.\nint qf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)\n{\n  qf_info_T *qi = &ql_info;\n  qf_list_T *qfl;\n  dictitem_T *di = NULL;\n  int status = OK;\n  int qf_idx = INVALID_QFIDX;\n  int eidx = 0;\n\n  if ((di = tv_dict_find(what, S_LEN(\"lines\"))) != NULL) {\n    return qf_get_list_from_lines(what, di, retdict);\n  }\n\n  if (wp != NULL) {\n    qi = GET_LOC_LIST(wp);\n  }\n\n  const int flags = qf_getprop_keys2flags(what, wp != NULL);\n\n  if (!qf_stack_empty(qi)) {\n    qf_idx = qf_getprop_qfidx(qi, what);\n  }\n\n  // List is not present or is empty\n  if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX) {\n    return qf_getprop_defaults(qi, flags, wp != NULL, retdict);\n  }\n\n  qfl = qf_get_list(qi, qf_idx);\n\n  // If an entry index is specified, use that\n  if ((di = tv_dict_find(what, S_LEN(\"idx\"))) != NULL) {\n    if (di->di_tv.v_type != VAR_NUMBER) {\n      return FAIL;\n    }\n    eidx = (int)di->di_tv.vval.v_number;\n  }\n\n  if (flags & QF_GETLIST_TITLE) {\n    status = qf_getprop_title(qfl, retdict);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_NR)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"nr\"), qf_idx + 1);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_WINID)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"winid\"), qf_winid(qi));\n  }\n  if ((status == OK) && (flags & QF_GETLIST_ITEMS)) {\n    status = qf_getprop_items(qi, qf_idx, eidx, retdict);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_CONTEXT)) {\n    status = qf_getprop_ctx(qfl, retdict);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_ID)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"id\"), qfl->qf_id);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_IDX)) {\n    status = qf_getprop_idx(qfl, eidx, retdict);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_SIZE)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"size\"),\n                            qfl->qf_count);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_TICK)) {\n    status = tv_dict_add_nr(retdict, S_LEN(\"changedtick\"),\n                            qfl->qf_changedtick);\n  }\n  if ((status == OK) && (wp != NULL) && (flags & QF_GETLIST_FILEWINID)) {\n    status = qf_getprop_filewinid(wp, qi, retdict);\n  }\n  if ((status == OK) && (flags & QF_GETLIST_QFTF)) {\n    status = qf_getprop_qftf(qfl, retdict);\n  }\n\n  return status;\n}\n\n/// Set the current index in the specified quickfix list\n/// @return OK\nstatic int qf_setprop_qftf(qf_list_T *qfl, dictitem_T *di)\n  FUNC_ATTR_NONNULL_ALL\n{\n  Callback cb;\n\n  callback_free(&qfl->qftf_cb);\n  if (callback_from_typval(&cb, &di->di_tv)) {\n    qfl->qftf_cb = cb;\n  }\n  return OK;\n}\n\n/// Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the\n/// items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'\n/// to true.\nstatic int qf_add_entry_from_dict(\n    qf_list_T *qfl,\n    const dict_T *d,\n    bool first_entry,\n    bool *valid_entry)\n  FUNC_ATTR_NONNULL_ALL\n{\n  static bool did_bufnr_emsg;\n\n  if (first_entry) {\n    did_bufnr_emsg = false;\n  }\n\n  char *const filename = tv_dict_get_string(d, \"filename\", true);\n  char *const module = tv_dict_get_string(d, \"module\", true);\n  int bufnum = (int)tv_dict_get_number(d, \"bufnr\");\n  const long lnum = (long)tv_dict_get_number(d, \"lnum\");\n  const long end_lnum = (long)tv_dict_get_number(d, \"end_lnum\");\n  const int col = (int)tv_dict_get_number(d, \"col\");\n  const int end_col = (int)tv_dict_get_number(d, \"end_col\");\n  const char_u vcol = (char_u)tv_dict_get_number(d, \"vcol\");\n  const int nr = (int)tv_dict_get_number(d, \"nr\");\n  const char *const type = tv_dict_get_string(d, \"type\", false);\n  char *const pattern = tv_dict_get_string(d, \"pattern\", true);\n  char *text = tv_dict_get_string(d, \"text\", true);\n  if (text == NULL) {\n    text = xcalloc(1, 1);\n  }\n  bool valid = true;\n  if ((filename == NULL && bufnum == 0)\n      || (lnum == 0 && pattern == NULL)) {\n    valid = false;\n  }\n\n  // Mark entries with non-existing buffer number as not valid. Give the\n  // error message only once.\n  if (bufnum != 0 && (buflist_findnr(bufnum) == NULL)) {\n    if (!did_bufnr_emsg) {\n      did_bufnr_emsg = true;\n      EMSGN(_(\"E92: Buffer %\" PRId64 \" not found\"), bufnum);\n    }\n    valid = false;\n    bufnum = 0;\n  }\n\n  // If the 'valid' field is present it overrules the detected value.\n  if (tv_dict_find(d, \"valid\", -1) != NULL) {\n    valid = tv_dict_get_number(d, \"valid\");\n  }\n\n  const int status = qf_add_entry(qfl,\n                                  NULL,      // dir\n                                  (char_u *)filename,\n                                  (char_u *)module,\n                                  bufnum,\n                                  (char_u *)text,\n                                  lnum,\n                                  end_lnum,\n                                  col,\n                                  end_col,\n                                  vcol,      // vis_col\n                                  (char_u *)pattern,   // search pattern\n                                  nr,\n                                  (char_u)(type == NULL ? NUL : *type),\n                                  valid);\n\n  xfree(filename);\n  xfree(module);\n  xfree(pattern);\n  xfree(text);\n\n  if (valid) {\n    *valid_entry = true;\n  }\n\n  return status;\n}\n\n/// Add list of entries to quickfix/location list. Each list entry is\n/// a dictionary with item information.\nstatic int qf_add_entries(qf_info_T *qi, int qf_idx, list_T *list,\n                          char_u *title, int action)\n{\n  qf_list_T *qfl = qf_get_list(qi, qf_idx);\n  qfline_T *old_last = NULL;\n  int retval = OK;\n  bool valid_entry = false;\n\n  if (action == ' ' || qf_idx == qi->qf_listcount) {\n    // make place for a new list\n    qf_new_list(qi, title);\n    qf_idx = qi->qf_curlist;\n    qfl = qf_get_list(qi, qf_idx);\n  } else if (action == 'a' && !qf_list_empty(qfl)) {\n    // Adding to existing list, use last entry.\n    old_last = qfl->qf_last;\n  } else if (action == 'r') {\n    qf_free_items(qfl);\n    qf_store_title(qfl, title);\n  }\n\n  TV_LIST_ITER_CONST(list, li, {\n    if (TV_LIST_ITEM_TV(li)->v_type != VAR_DICT) {\n      continue;  // Skip non-dict items.\n    }\n\n    const dict_T *const d = TV_LIST_ITEM_TV(li)->vval.v_dict;\n    if (d == NULL) {\n      continue;\n    }\n\n    retval = qf_add_entry_from_dict(qfl, d, li == tv_list_first(list),\n                                    &valid_entry);\n    if (retval == QF_FAIL) {\n      break;\n    }\n  });\n\n  // Check if any valid error entries are added to the list.\n  if (valid_entry) {\n    qfl->qf_nonevalid = false;\n  } else if (qfl->qf_index == 0) {\n    qfl->qf_nonevalid = true;\n  }\n\n  // If not appending to the list, set the current error to the first entry\n  if (action != 'a') {\n    qfl->qf_ptr = qfl->qf_start;\n  }\n\n  // Update the current error index if not appending to the list or if the\n  // list was empty before and it is not empty now.\n  if ((action != 'a' || qfl->qf_index == 0)\n      && !qf_list_empty(qfl)) {\n    qfl->qf_index = 1;\n  }\n\n  // Don't update the cursor in quickfix window when appending entries\n  qf_update_buffer(qi, old_last);\n\n  return retval;\n}\n\n/// Get the quickfix list index from 'nr' or 'id'\nstatic int qf_setprop_get_qfidx(\n    const qf_info_T *qi,\n    const dict_T *what,\n    int action,\n    bool *newlist)\n  FUNC_ATTR_NONNULL_ALL\n{\n  dictitem_T *di;\n  int qf_idx = qi->qf_curlist;  // default is the current list\n\n  if ((di = tv_dict_find(what, S_LEN(\"nr\"))) != NULL) {\n    // Use the specified quickfix/location list\n    if (di->di_tv.v_type == VAR_NUMBER) {\n      // for zero use the current list\n      if (di->di_tv.vval.v_number != 0) {\n        qf_idx = (int)di->di_tv.vval.v_number - 1;\n      }\n\n      if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount) {\n        // When creating a new list, accept qf_idx pointing to the next\n        // non-available list and add the new list at the end of the\n        // stack.\n        *newlist = true;\n        qf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;\n      } else if (qf_idx < 0 || qf_idx >= qi->qf_listcount) {\n        return INVALID_QFIDX;\n      } else if (action != ' ') {\n        *newlist = false;  // use the specified list\n      }\n    } else if (di->di_tv.v_type == VAR_STRING\n               && strequal((const char *)di->di_tv.vval.v_string, \"$\")) {\n      if (!qf_stack_empty(qi)) {\n        qf_idx = qi->qf_listcount - 1;\n      } else if (*newlist) {\n        qf_idx = 0;\n      } else {\n        return INVALID_QFIDX;\n      }\n    } else {\n      return INVALID_QFIDX;\n    }\n  }\n\n  if (!*newlist && (di = tv_dict_find(what, S_LEN(\"id\"))) != NULL) {\n    // Use the quickfix/location list with the specified id\n    if (di->di_tv.v_type != VAR_NUMBER) {\n      return INVALID_QFIDX;\n    }\n    return qf_id2nr(qi, (unsigned)di->di_tv.vval.v_number);\n  }\n\n  return qf_idx;\n}\n\n// Set the quickfix list title.\nstatic int qf_setprop_title(qf_info_T *qi, int qf_idx, const dict_T *what,\n                            const dictitem_T *di)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_list_T *qfl = qf_get_list(qi, qf_idx);\n  if (di->di_tv.v_type != VAR_STRING) {\n    return FAIL;\n  }\n\n  xfree(qfl->qf_title);\n  qfl->qf_title = (char_u *)tv_dict_get_string(what, \"title\", true);\n  if (qf_idx == qi->qf_curlist) {\n    qf_update_win_titlevar(qi);\n  }\n\n  return OK;\n}\n\n// Set quickfix list items/entries.\nstatic int qf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di,\n                            int action)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (di->di_tv.v_type != VAR_LIST) {\n    return FAIL;\n  }\n\n  char_u *title_save = vim_strsave(qi->qf_lists[qf_idx].qf_title);\n  const int retval = qf_add_entries(qi, qf_idx, di->di_tv.vval.v_list,\n                                    title_save,\n                                    action == ' ' ? 'a' : action);\n  xfree(title_save);\n\n  return retval;\n}\n\n// Set quickfix list items/entries from a list of lines.\nstatic int qf_setprop_items_from_lines(\n    qf_info_T *qi,\n    int qf_idx,\n    const dict_T *what,\n    dictitem_T *di,\n    int action)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *errorformat = p_efm;\n  dictitem_T *efm_di;\n  int  retval = FAIL;\n\n  // Use the user supplied errorformat settings (if present)\n  if ((efm_di = tv_dict_find(what, S_LEN(\"efm\"))) != NULL) {\n    if (efm_di->di_tv.v_type != VAR_STRING\n        || efm_di->di_tv.vval.v_string == NULL) {\n      return FAIL;\n    }\n    errorformat = efm_di->di_tv.vval.v_string;\n  }\n\n  // Only a List value is supported\n  if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL) {\n    return FAIL;\n  }\n\n  if (action == 'r') {\n    qf_free_items(&qi->qf_lists[qf_idx]);\n  }\n  if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,\n                  false, (linenr_T)0, (linenr_T)0, NULL, NULL) >= 0) {\n    retval = OK;\n  }\n\n  return retval;\n}\n\n// Set quickfix list context.\nstatic int qf_setprop_context(qf_list_T *qfl, dictitem_T *di)\n  FUNC_ATTR_NONNULL_ALL\n{\n  tv_free(qfl->qf_ctx);\n  typval_T *ctx = xcalloc(1, sizeof(typval_T));\n  tv_copy(&di->di_tv, ctx);\n  qfl->qf_ctx = ctx;\n\n  return OK;\n}\n\n// Set the current index in the specified quickfix list\nstatic int qf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl,\n                             const dictitem_T *di)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int  newidx;\n\n  // If the specified index is '$', then use the last entry\n  if (di->di_tv.v_type == VAR_STRING\n      && di->di_tv.vval.v_string != NULL\n      && STRCMP(di->di_tv.vval.v_string, \"$\") == 0) {\n    newidx = qfl->qf_count;\n  } else {\n    // Otherwise use the specified index\n    bool denote = false;\n    newidx = (int)tv_get_number_chk(&di->di_tv, &denote);\n    if (denote) {\n      return FAIL;\n    }\n  }\n\n  if (newidx < 1) {  // sanity check\n    return FAIL;\n  }\n  if (newidx > qfl->qf_count) {\n    newidx = qfl->qf_count;\n  }\n  const int old_qfidx = qfl->qf_index;\n  qfline_T *const qf_ptr = get_nth_entry(qfl, newidx, &newidx);\n  if (qf_ptr == NULL) {\n    return FAIL;\n  }\n  qfl->qf_ptr = qf_ptr;\n  qfl->qf_index = newidx;\n\n  // If the current list is modified and it is displayed in the quickfix\n  // window, then Update it.\n  if (qi->qf_lists[qi->qf_curlist].qf_id == qfl->qf_id) {\n    qf_win_pos_update(qi, old_qfidx);\n  }\n  return OK;\n}\n\n/// Set quickfix/location list properties (title, items, context).\n/// Also used to add items from parsing a list of lines.\n/// Used by the setqflist() and setloclist() Vim script functions.\nstatic int qf_set_properties(qf_info_T *qi, const dict_T *what, int action,\n                             char_u *title)\n  FUNC_ATTR_NONNULL_ALL\n{\n  qf_list_T *qfl;\n  dictitem_T *di;\n  int  retval = FAIL;\n  bool newlist = action == ' ' || qf_stack_empty(qi);\n  int qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);\n  if (qf_idx == INVALID_QFIDX) {  // List not found\n    return FAIL;\n  }\n\n  if (newlist) {\n    qi->qf_curlist = qf_idx;\n    qf_new_list(qi, title);\n    qf_idx = qi->qf_curlist;\n  }\n\n  qfl = qf_get_list(qi, qf_idx);\n  if ((di = tv_dict_find(what, S_LEN(\"title\"))) != NULL) {\n    retval = qf_setprop_title(qi, qf_idx, what, di);\n  }\n  if ((di = tv_dict_find(what, S_LEN(\"items\"))) != NULL) {\n    retval = qf_setprop_items(qi, qf_idx, di, action);\n  }\n  if ((di = tv_dict_find(what, S_LEN(\"lines\"))) != NULL) {\n    retval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);\n  }\n  if ((di = tv_dict_find(what, S_LEN(\"context\"))) != NULL) {\n    retval = qf_setprop_context(qfl, di);\n  }\n  if ((di = tv_dict_find(what, S_LEN(\"idx\"))) != NULL) {\n    retval = qf_setprop_curidx(qi, qfl, di);\n  }\n  if ((di = tv_dict_find(what, S_LEN(\"quickfixtextfunc\"))) != NULL) {\n    retval = qf_setprop_qftf(qfl, di);\n  }\n\n  if (newlist || retval == OK) {\n    qf_list_changed(qfl);\n  }\n  if (newlist) {\n    qf_update_buffer(qi, NULL);\n  }\n\n  return retval;\n}\n\n/// Find the non-location list window with the specified location list stack in\n/// the current tabpage.\nstatic win_T *find_win_with_ll(const qf_info_T *qi)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n    if ((wp->w_llist == qi) && !bt_quickfix(wp->w_buffer)) {\n      return wp;\n    }\n  }\n\n  return NULL;\n}\n\n// Free the entire quickfix/location list stack.\n// If the quickfix/location list window is open, then clear it.\nstatic void qf_free_stack(win_T *wp, qf_info_T *qi)\n{\n  win_T *qfwin = qf_find_win(qi);\n\n  if (qfwin != NULL) {\n    // If the quickfix/location list window is open, then clear it\n    if (qi->qf_curlist < qi->qf_listcount) {\n      qf_free(qf_get_curlist(qi));\n    }\n    qf_update_buffer(qi, NULL);\n  }\n\n  win_T *llwin = NULL;\n  win_T *orig_wp = wp;\n  if (wp != NULL && IS_LL_WINDOW(wp)) {\n    // If in the location list window, then use the non-location list\n    // window with this location list (if present)\n    llwin = find_win_with_ll(qi);\n    if (llwin != NULL) {\n      wp = llwin;\n    }\n  }\n\n  qf_free_all(wp);\n  if (wp == NULL) {\n    // quickfix list\n    qi->qf_curlist = 0;\n    qi->qf_listcount = 0;\n  } else if (IS_LL_WINDOW(orig_wp)) {\n    // If the location list window is open, then create a new empty location\n    // list\n    qf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);\n\n    // first free the list reference in the location list window\n    ll_free_all(&orig_wp->w_llist_ref);\n\n    orig_wp->w_llist_ref = new_ll;\n    if (llwin != NULL) {\n      win_set_loclist(wp, new_ll);\n    }\n  }\n}\n\n// Populate the quickfix list with the items supplied in the list\n// of dictionaries. \"title\" will be copied to w:quickfix_title\n// \"action\" is 'a' for add, 'r' for replace.  Otherwise create a new list.\n// When \"what\" is not NULL then only set some properties.\nint set_errorlist(win_T *wp, list_T *list, int action, char_u *title,\n                  dict_T *what)\n{\n  qf_info_T *qi = &ql_info;\n  int retval = OK;\n\n  if (wp != NULL) {\n    qi = ll_get_or_alloc_list(wp);\n  }\n\n  if (action == 'f') {\n    // Free the entire quickfix or location list stack\n    qf_free_stack(wp, qi);\n    return OK;\n  }\n\n  // A dict argument cannot be specified with a non-empty list argument\n  if (list != NULL && tv_list_len(list) != 0 && what != NULL) {\n    EMSG2(_(e_invarg2), _(\"cannot have both a list and a \\\"what\\\" argument\"));\n    return FAIL;\n  }\n\n  incr_quickfix_busy();\n\n  if (what != NULL) {\n    retval = qf_set_properties(qi, what, action, title);\n  } else {\n    retval = qf_add_entries(qi, qi->qf_curlist, list, title, action);\n    if (retval == OK) {\n      qf_list_changed(qf_get_curlist(qi));\n    }\n  }\n\n  decr_quickfix_busy();\n\n  return retval;\n}\n\n/// Mark the context as in use for all the lists in a quickfix stack.\nstatic bool mark_quickfix_ctx(qf_info_T *qi, int copyID)\n{\n  bool abort = false;\n\n  for (int i = 0; i < LISTCOUNT && !abort; i++) {\n    typval_T *ctx = qi->qf_lists[i].qf_ctx;\n    if (ctx != NULL && ctx->v_type != VAR_NUMBER\n        && ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT) {\n      abort = set_ref_in_item(ctx, copyID, NULL, NULL);\n    }\n  }\n\n  return abort;\n}\n\n/// Mark the context of the quickfix list and the location lists (if present) as\n/// \"in use\". So that garbage collection doesn't free the context.\nbool set_ref_in_quickfix(int copyID)\n{\n  bool abort = mark_quickfix_ctx(&ql_info, copyID);\n  if (abort) {\n    return abort;\n  }\n\n  FOR_ALL_TAB_WINDOWS(tp, win) {\n    if (win->w_llist != NULL) {\n      abort = mark_quickfix_ctx(win->w_llist, copyID);\n      if (abort) {\n        return abort;\n      }\n    }\n\n    if (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1)) {\n      // In a location list window and none of the other windows is\n      // referring to this location list. Mark the location list\n      // context as still in use.\n      abort = mark_quickfix_ctx(win->w_llist_ref, copyID);\n      if (abort) {\n        return abort;\n      }\n    }\n  }\n\n  return abort;\n}\n\n/// Return the autocmd name for the :cbuffer Ex commands\nstatic char_u * cbuffer_get_auname(cmdidx_T cmdidx)\n{\n  switch (cmdidx) {\n    case CMD_cbuffer:    return (char_u *)\"cbuffer\";\n    case CMD_cgetbuffer: return (char_u *)\"cgetbuffer\";\n    case CMD_caddbuffer: return (char_u *)\"caddbuffer\";\n    case CMD_lbuffer:    return (char_u *)\"lbuffer\";\n    case CMD_lgetbuffer: return (char_u *)\"lgetbuffer\";\n    case CMD_laddbuffer: return (char_u *)\"laddbuffer\";\n    default:             return NULL;\n  }\n}\n\n/// Process and validate the arguments passed to the :cbuffer, :caddbuffer,\n/// :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.\nstatic int cbuffer_process_args(exarg_T *eap,\n                                buf_T **bufp,\n                                linenr_T *line1,\n                                linenr_T *line2)\n{\n  buf_T *buf = NULL;\n\n  if (*eap->arg == NUL)\n    buf = curbuf;\n  else if (*skipwhite(skipdigits(eap->arg)) == NUL)\n    buf = buflist_findnr(atoi((char *)eap->arg));\n\n  if (buf == NULL) {\n    EMSG(_(e_invarg));\n    return FAIL;\n  }\n\n  if (buf->b_ml.ml_mfp == NULL) {\n    EMSG(_(\"E681: Buffer is not loaded\"));\n    return FAIL;\n  }\n\n  if (eap->addr_count == 0) {\n    eap->line1 = 1;\n    eap->line2 = buf->b_ml.ml_line_count;\n  }\n\n  if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count\n      || eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count) {\n    EMSG(_(e_invrange));\n    return FAIL;\n  }\n\n  *line1 = eap->line1;\n  *line2 = eap->line2;\n  *bufp = buf;\n\n  return OK;\n}\n\n// \":[range]cbuffer [bufnr]\" command.\n// \":[range]caddbuffer [bufnr]\" command.\n// \":[range]cgetbuffer [bufnr]\" command.\n// \":[range]lbuffer [bufnr]\" command.\n// \":[range]laddbuffer [bufnr]\" command.\n// \":[range]lgetbuffer [bufnr]\" command.\nvoid ex_cbuffer(exarg_T *eap)\n{\n  buf_T *buf = NULL;\n  char_u *au_name = NULL;\n  win_T *wp = NULL;\n  char_u *qf_title;\n  linenr_T line1;\n  linenr_T line2;\n\n  au_name = cbuffer_get_auname(eap->cmdidx);\n  if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n                                        curbuf->b_fname, true, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n\n  // Must come after autocommands.\n  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n\n  if (cbuffer_process_args(eap, &buf, &line1, &line2) == FAIL) {\n    return;\n  }\n\n  qf_title = qf_cmdtitle(*eap->cmdlinep);\n\n  if (buf->b_sfname) {\n    vim_snprintf((char *)IObuff, IOSIZE, \"%s (%s)\",\n                 (char *)qf_title, (char *)buf->b_sfname);\n    qf_title = IObuff;\n  }\n\n  incr_quickfix_busy();\n\n  int res = qf_init_ext(qi, qi->qf_curlist, NULL, buf, NULL, p_efm,\n                        (eap->cmdidx != CMD_caddbuffer\n                         && eap->cmdidx != CMD_laddbuffer),\n                        eap->line1, eap->line2, qf_title, NULL);\n  if (qf_stack_empty(qi)) {\n    decr_quickfix_busy();\n    return;\n  }\n  if (res >= 0) {\n    qf_list_changed(qf_get_curlist(qi));\n  }\n  // Remember the current quickfix list identifier, so that we can\n  // check for autocommands changing the current quickfix list.\n  unsigned save_qfid = qf_get_curlist(qi)->qf_id;\n  if (au_name != NULL) {\n    const buf_T *const curbuf_old = curbuf;\n    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n                   curbuf->b_fname, true, curbuf);\n    if (curbuf != curbuf_old) {\n      // Autocommands changed buffer, don't jump now, \"qi\" may\n      // be invalid.\n      res = 0;\n    }\n  }\n  // Jump to the first error for new list and if autocmds didn't\n  // free the list.\n  if (res > 0 && (eap->cmdidx == CMD_cbuffer || eap->cmdidx == CMD_lbuffer)\n      && qflist_valid(wp, save_qfid)) {\n    // display the first error\n    qf_jump_first(qi, save_qfid, eap->forceit);\n  }\n\n  decr_quickfix_busy();\n}\n\n/// Return the autocmd name for the :cexpr Ex commands.\nstatic char_u * cexpr_get_auname(cmdidx_T cmdidx)\n{\n  switch (cmdidx) {\n    case CMD_cexpr:    return (char_u *)\"cexpr\";\n    case CMD_cgetexpr: return (char_u *)\"cgetexpr\";\n    case CMD_caddexpr: return (char_u *)\"caddexpr\";\n    case CMD_lexpr:    return (char_u *)\"lexpr\";\n    case CMD_lgetexpr: return (char_u *)\"lgetexpr\";\n    case CMD_laddexpr: return (char_u *)\"laddexpr\";\n    default:           return NULL;\n  }\n}\n\n/// \":cexpr {expr}\", \":cgetexpr {expr}\", \":caddexpr {expr}\" command.\n/// \":lexpr {expr}\", \":lgetexpr {expr}\", \":laddexpr {expr}\" command.\nvoid ex_cexpr(exarg_T *eap)\n{\n  char_u *au_name = NULL;\n  win_T *wp = NULL;\n\n  au_name = cexpr_get_auname(eap->cmdidx);\n  if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n                                        curbuf->b_fname, true, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n\n  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n\n  // Evaluate the expression.  When the result is a string or a list we can\n  // use it to fill the errorlist.\n  typval_T tv;\n  if (eval0(eap->arg, &tv, &eap->nextcmd, true) != FAIL) {\n    if ((tv.v_type == VAR_STRING && tv.vval.v_string != NULL)\n        || tv.v_type == VAR_LIST) {\n      incr_quickfix_busy();\n      int res = qf_init_ext(qi, qi->qf_curlist, NULL, NULL, &tv, p_efm,\n                            (eap->cmdidx != CMD_caddexpr\n                             && eap->cmdidx != CMD_laddexpr),\n                            (linenr_T)0, (linenr_T)0,\n                            qf_cmdtitle(*eap->cmdlinep), NULL);\n      if (qf_stack_empty(qi)) {\n        decr_quickfix_busy();\n        goto cleanup;\n      }\n      if (res >= 0) {\n        qf_list_changed(qf_get_curlist(qi));\n      }\n      // Remember the current quickfix list identifier, so that we can\n      // check for autocommands changing the current quickfix list.\n      unsigned save_qfid = qf_get_curlist(qi)->qf_id;\n      if (au_name != NULL) {\n        apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n                       curbuf->b_fname, true, curbuf);\n      }\n      // Jump to the first error for a new list and if autocmds didn't\n      // free the list.\n      if (res > 0\n          && (eap->cmdidx == CMD_cexpr || eap->cmdidx == CMD_lexpr)\n          && qflist_valid(wp, save_qfid)) {\n        // display the first error\n        qf_jump_first(qi, save_qfid, eap->forceit);\n      }\n      decr_quickfix_busy();\n    } else {\n      EMSG(_(\"E777: String or List expected\"));\n    }\ncleanup:\n    tv_clear(&tv);\n  }\n}\n\n// Get the location list for \":lhelpgrep\"\nstatic qf_info_T *hgr_get_ll(bool *new_ll)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET\n{\n  win_T *wp;\n  qf_info_T *qi;\n\n  // If the current window is a help window, then use it\n  if (bt_help(curwin->w_buffer)) {\n    wp = curwin;\n  } else {\n    // Find an existing help window\n    wp = qf_find_help_win();\n  }\n\n  if (wp == NULL) {   // Help window not found\n    qi = NULL;\n  } else {\n    qi = wp->w_llist;\n  }\n  if (qi == NULL) {\n    // Allocate a new location list for help text matches\n    qi = qf_alloc_stack(QFLT_LOCATION);\n    *new_ll = true;\n  }\n\n  return qi;\n}\n\n// Search for a pattern in a help file.\nstatic void hgr_search_file(\n    qf_list_T *qfl,\n    char_u *fname,\n    regmatch_T *p_regmatch)\n  FUNC_ATTR_NONNULL_ARG(1, 3)\n{\n  FILE *const fd = os_fopen((char *)fname, \"r\");\n  if (fd == NULL) {\n    return;\n  }\n\n  long lnum = 1;\n  while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int) {\n    char_u *line = IObuff;\n\n    if (vim_regexec(p_regmatch, line, (colnr_T)0)) {\n      int l = (int)STRLEN(line);\n\n      // remove trailing CR, LF, spaces, etc.\n      while (l > 0 && line[l - 1] <= ' ') {\n        line[--l] = NUL;\n      }\n\n      if (qf_add_entry(qfl,\n                       NULL,   // dir\n                       fname,\n                       NULL,\n                       0,\n                       line,\n                       lnum,\n                       0,\n                       (int)(p_regmatch->startp[0] - line) + 1,  // col\n                       (int)(p_regmatch->endp[0] - line)\n                       + 1,    // end_col\n                       false,  // vis_col\n                       NULL,   // search pattern\n                       0,      // nr\n                       1,      // type\n                       true)    // valid\n          == QF_FAIL) {\n        got_int = true;\n        if (line != IObuff) {\n          xfree(line);\n        }\n        break;\n      }\n    }\n    if (line != IObuff) {\n      xfree(line);\n    }\n    lnum++;\n    line_breakcheck();\n  }\n  fclose(fd);\n}\n\n// Search for a pattern in all the help files in the doc directory under\n// the given directory.\nstatic void hgr_search_files_in_dir(\n    qf_list_T *qfl,\n    char_u *dirname,\n    regmatch_T *p_regmatch,\n    const char_u *lang)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 3)\n{\n  int fcount;\n  char_u **fnames;\n\n  // Find all \"*.txt\" and \"*.??x\" files in the \"doc\" directory.\n  add_pathsep((char *)dirname);\n  STRCAT(dirname, \"doc/*.\\\\(txt\\\\|??x\\\\)\");  // NOLINT\n  if (gen_expand_wildcards(1, &dirname, &fcount,\n                           &fnames, EW_FILE|EW_SILENT) == OK\n      && fcount > 0) {\n    for (int fi = 0; fi < fcount && !got_int; fi++) {\n      // Skip files for a different language.\n      if (lang != NULL\n          && STRNICMP(lang, fnames[fi] + STRLEN(fnames[fi]) - 3, 2) != 0\n          && !(STRNICMP(lang, \"en\", 2) == 0\n               && STRNICMP(\"txt\", fnames[fi] + STRLEN(fnames[fi]) - 3, 3)\n               == 0)) {\n        continue;\n      }\n\n      hgr_search_file(qfl, fnames[fi], p_regmatch);\n    }\n    FreeWild(fcount, fnames);\n  }\n}\n\n// Search for a pattern in all the help files in the 'runtimepath'\n// and add the matches to a quickfix list.\n// 'lang' is the language specifier.  If supplied, then only matches in the\n// specified language are found.\nstatic void hgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch,\n                              const char_u *lang)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  // Go through all directories in 'runtimepath'\n  char_u *p = p_rtp;\n  while (*p != NUL && !got_int) {\n    copy_option_part(&p, NameBuff, MAXPATHL, \",\");\n\n    hgr_search_files_in_dir(qfl, NameBuff, p_regmatch, lang);\n  }\n}\n\n// \":helpgrep {pattern}\"\nvoid ex_helpgrep(exarg_T *eap)\n{\n  qf_info_T *qi = &ql_info;\n  bool new_qi = false;\n  char_u *au_name =  NULL;\n\n  switch (eap->cmdidx) {\n  case CMD_helpgrep:  au_name = (char_u *)\"helpgrep\"; break;\n  case CMD_lhelpgrep: au_name = (char_u *)\"lhelpgrep\"; break;\n  default: break;\n  }\n  if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n                                        curbuf->b_fname, true, curbuf)) {\n    if (aborting()) {\n      return;\n    }\n  }\n\n  // Make 'cpoptions' empty, the 'l' flag should not be used here.\n  char_u *const save_cpo = p_cpo;\n  p_cpo = empty_option;\n\n  if (is_loclist_cmd(eap->cmdidx)) {\n    qi = hgr_get_ll(&new_qi);\n  }\n\n  incr_quickfix_busy();\n\n  // Check for a specified language\n  char_u *const lang = check_help_lang(eap->arg);\n  regmatch_T regmatch = {\n    .regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING),\n    .rm_ic = false,\n  };\n  if (regmatch.regprog != NULL) {\n    // Create a new quickfix list.\n    qf_new_list(qi, qf_cmdtitle(*eap->cmdlinep));\n    qf_list_T *const qfl = qf_get_curlist(qi);\n\n    hgr_search_in_rtp(qfl, &regmatch, lang);\n\n    vim_regfree(regmatch.regprog);\n\n    qfl->qf_nonevalid = false;\n    qfl->qf_ptr = qfl->qf_start;\n    qfl->qf_index = 1;\n    qf_list_changed(qfl);\n    qf_update_buffer(qi, NULL);\n  }\n\n  if (p_cpo == empty_option) {\n    p_cpo = save_cpo;\n  } else {\n    // Darn, some plugin changed the value.\n    free_string_option(save_cpo);\n  }\n\n  if (au_name != NULL) {\n    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n                   curbuf->b_fname, true, curbuf);\n    // When adding a location list to an existing location list stack,\n    // if the autocmd made the stack invalid, then just return.\n    if (!new_qi && IS_LL_STACK(qi) && qf_find_win_with_loclist(qi) == NULL) {\n      decr_quickfix_busy();\n      return;\n    }\n  }\n\n  // Jump to first match.\n  if (!qf_list_empty(qf_get_curlist(qi))) {\n    qf_jump(qi, 0, 0, false);\n  } else {\n    EMSG2(_(e_nomatch2), eap->arg);\n  }\n\n  decr_quickfix_busy();\n\n  if (eap->cmdidx == CMD_lhelpgrep) {\n    // If the help window is not opened or if it already points to the\n    // correct location list, then free the new location list.\n    if (!bt_help(curwin->w_buffer) || curwin->w_llist == qi) {\n      if (new_qi) {\n        ll_free_all(&qi);\n      }\n    } else if (curwin->w_llist == NULL) {\n      curwin->w_llist = qi;\n    }\n  }\n}\n\n\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 85}, "message": "kQfltInternal (fixit)"}, {"location": {"col": 3, "file": 0, "line": 85}, "message": "invalid case style for enum constant 'QFLT_INTERNAL'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a6a4527cecc889f89b18ef8c9fa7776c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 171}, "message": "kQfFail (fixit)"}, {"location": {"col": 3, "file": 0, "line": 171}, "message": "invalid case style for enum constant 'QF_FAIL'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "126761ac9b58bcbb20a3bec0c792abb8", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 172}, "message": "kQfOk (fixit)"}, {"location": {"col": 3, "file": 0, "line": 172}, "message": "invalid case style for enum constant 'QF_OK'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "7b9306d3d5ecf4472466adf0389b9a74", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 173}, "message": "kQfEndOfInput (fixit)"}, {"location": {"col": 3, "file": 0, "line": 173}, "message": "invalid case style for enum constant 'QF_END_OF_INPUT'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "7b0f17e7a49701f74a7a8bbf301d4ac2", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 174}, "message": "kQfNomem (fixit)"}, {"location": {"col": 3, "file": 0, "line": 174}, "message": "invalid case style for enum constant 'QF_NOMEM'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "8757a4177f96835cf5432169c8d3ba04", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 175}, "message": "kQfIgnoreLine (fixit)"}, {"location": {"col": 3, "file": 0, "line": 175}, "message": "invalid case style for enum constant 'QF_IGNORE_LINE'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "711e4b2f2b325912e0e47e8eec2f3d30", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 176}, "message": "kQfMultiscan (fixit)"}, {"location": {"col": 3, "file": 0, "line": 176}, "message": "invalid case style for enum constant 'QF_MULTISCAN'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "5cc516d9de423f8606a20b0f1d1d31f1", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 220}, "message": "( ) (fixit)"}, {"location": {"col": 39, "file": 0, "line": 220}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "5ba7365ba936f5bee5e6f30ac9768e35", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 56, "file": 0, "line": 220}, "message": "( ) (fixit)"}, {"location": {"col": 56, "file": 0, "line": 220}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "601208cc75788fc56bfdd7732a15b4c2", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 0, "line": 222}, "message": "( ) (fixit)"}, {"location": {"col": 39, "file": 0, "line": 222}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "f969cc8d8884836fb8a7531d9f24f947", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 56, "file": 0, "line": 222}, "message": "( ) (fixit)"}, {"location": {"col": 56, "file": 0, "line": 222}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d3355f1e080d9b7c5a17f31001137821", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 0, "line": 225}, "message": "( ) (fixit)"}, {"location": {"col": 32, "file": 0, "line": 225}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "b0fddc37deddb7f7ca953de701b910cf", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 0, "line": 226}, "message": "( ) (fixit)"}, {"location": {"col": 32, "file": 0, "line": 226}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c93712249c961f2c2566bc8c7556d37b", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 0, "line": 227}, "message": "(  ) (fixit)"}, {"location": {"col": 32, "file": 0, "line": 227}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a49caad14834438954872b147767bab8", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 0, "line": 228}, "message": "(  ) (fixit)"}, {"location": {"col": 32, "file": 0, "line": 228}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e847fd0855d3153f7a6e12d56324dda1", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 46, "file": 0, "line": 234}, "message": "( ) (fixit)"}, {"location": {"col": 46, "file": 0, "line": 234}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "cea26bd3400c588c3e939aa47f4a04fe", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 0, "line": 234}, "message": "( ) (fixit)"}, {"location": {"col": 64, "file": 0, "line": 234}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "98256e405519441aa7a4c9af0839d588", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 0, "line": 239}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 0, "line": 239}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "89658b30d6c763b3f81081a3b17617bf", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 0, "line": 239}, "message": "(  ) (fixit)"}, {"location": {"col": 15, "file": 0, "line": 239}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "3d89f3a80d68a5124852f33c999dbbb0", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 0, "line": 239}, "message": "(  ) (fixit)"}, {"location": {"col": 21, "file": 0, "line": 239}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "bf6c6ba56143aa6505efac9a4f2390fa", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 0, "line": 240}, "message": "() (fixit)"}, {"location": {"col": 20, "file": 0, "line": 240}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "74d13af92ae715d971214e62b19b968c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 0, "line": 240}, "message": "(  ) (fixit)"}, {"location": {"col": 25, "file": 0, "line": 240}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "720b2ec0fda855d8024d3dc63ad11157", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 42, "file": 0, "line": 240}, "message": "(  ) (fixit)"}, {"location": {"col": 42, "file": 0, "line": 240}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "1e6c1a12a1afbcfcb794783865e6a184", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 0, "line": 241}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 0, "line": 241}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a905e404e45634fc420427e2249fd203", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 0, "line": 241}, "message": "(  ) (fixit)"}, {"location": {"col": 13, "file": 0, "line": 241}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "377aa3edcd4c7bb90a09f84ef39176d7", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 19, "file": 0, "line": 241}, "message": "(  ) (fixit)"}, {"location": {"col": 19, "file": 0, "line": 241}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "cef66fd237937bdf5e3614dbd599af4a", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 0, "line": 326}, "message": "kLineMaxlen (fixit)"}, {"location": {"col": 21, "file": 0, "line": 326}, "message": "invalid case style for global constant 'LINE_MAXLEN'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d8f10c2a2f00a63b5d2ec743c325c2ed", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 396}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 396}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c2e16601a7c49b62c4fb5c3d0cddc501", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 401}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 401}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "ff07b33b04aa1e7aaa97a2fd3feb685d", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 0, "line": 585}, "message": "const (fixit)"}, {"location": {"col": 40, "file": 0, "line": 585}, "message": "pointer parameter 'efm' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "bcdc0753d98ef44dadcb87ab2745d14b", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1279}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1279}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "14379f996fe69bc9d5fdfae3964580a8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1279}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1279}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "3d7c42fe26167def36ab34355b693a35", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 1454}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 1454}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "06e2b3220dbd5f1e72e4c04e9bb79c35", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1669}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 1669}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "21043e85e8372175f0a144dc684be3aa", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1720}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1720}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "52fc7192bd62a1855d1f66ea09c0223e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1720}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1720}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "06f22cdd2d55caef0087b1ea96710f0f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1861}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "05232c074f135fa948afbd68df75483a", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2169}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2169}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "18d16e3ec65012fc3673dbf39b0c54b8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 2169}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 2169}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "4027aaea1abf1449e5d1ced752c865f0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2190}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "12b77e4108e63e91d2a84b07862e79f0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2190}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2190}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e484082535de3b79a4b0635d888f6b93", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2192}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "938cb078a37ed16c9e14ec1d5ec161da", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2754}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d85450eb583b021de60b08ae0eb97192", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 2991}, "message": "old_key_typed (fixit)"}, {"location": {"col": 14, "file": 0, "line": 2991}, "message": "invalid case style for variable 'old_KeyTyped'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d7b269fec2ffc18664bd07a4e850d760", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2994}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2994}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "52fc7192bd62a1855d1f66ea09c0223e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2994}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2994}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "06f22cdd2d55caef0087b1ea96710f0f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3067}, "message": "qf_file_attr (fixit)"}, {"location": {"col": 12, "file": 0, "line": 3067}, "message": "invalid case style for variable 'qfFileAttr'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "765c200d768b4dbde40c77a7a6552c71", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3068}, "message": "qf_sep_attr (fixit)"}, {"location": {"col": 12, "file": 0, "line": 3068}, "message": "invalid case style for variable 'qfSepAttr'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "8473b741b545a1a9d088ef7ab572853f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3069}, "message": "qf_line_attr (fixit)"}, {"location": {"col": 12, "file": 0, "line": 3069}, "message": "invalid case style for variable 'qfLineAttr'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "00a2d26be604e3c50cbe853824f38f2f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 3240}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 3240}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "97b980b008d89c2238441d1890f72a6c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 3240}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 3240}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "63c1004b9fa0359ad2f2e749f6814422", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 3241}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 3241}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "4b5c8eafe2365b86fc7b3ae65d81361f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 3241}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 3241}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e5558d2e2a2afeb441cce41b0a9e1a42", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3243}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 3243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "97b3fa3bebce2ced623bb14ec2592e41", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3243}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 3243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "cdc12c8fcd0b061ac67cb7b8ec0d5dee", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 3460}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 3460}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "58800fead2d7fd7031bf50c315d06297", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 3460}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 3460}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a343db712deb3dcce6f9cc80233c65d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 3462}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 3462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a28f91a38e4a0f4c410bf736915352fb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 3462}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 3462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "fc6278b547bb34f9cdeece9d0a3ef404", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 0, "line": 3464}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 0, "line": 3464}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a2c996d9d8bec376f5d0dae82ac9b052", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 60, "file": 0, "line": 3464}, "message": "{ (fixit)"}, {"location": {"col": 59, "file": 0, "line": 3464}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "9007a4418d5a6a5c391d091157394723", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 3512}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 3512}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d2e81417718d4f026218545cb68897ab", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 3512}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 3512}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "5b4ee8f4dd6fd8e492efe4e2590fed94", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 4135}, "message": "old_key_typed (fixit)"}, {"location": {"col": 14, "file": 0, "line": 4135}, "message": "invalid case style for variable 'old_KeyTyped'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d25e317ff11b6db4dee8a87d18fcebed", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 4378}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 4378}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "680a7b7c8905e3a11a9080d00f0b2e84", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 4378}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 4378}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "63ac964a545819fbbd587252bf3b990d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4432}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4432}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "6d22c9688b612a9508e41b5480c20991", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 0, "line": 4432}, "message": "{ (fixit)"}, {"location": {"col": 22, "file": 0, "line": 4432}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "8b7cb9a04bc6f38faeb145fc1089d5ad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4437}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4437}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "67ce820656fda797d520fe294a80a137", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4437}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4437}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "5e498b6d9b3efd216e0cb1f8c9d07777", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 4438}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 4438}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "2dc1cec91f7e32b81377af1d588c14dd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 4438}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 4438}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "8043650abbcae3a39d3e44464cc5ebcf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4441}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "fddcd5c5ac270f3d42ce38fbec425149", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4441}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4441}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "b02b16248b5582a44b5b738b15d6b4c7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 4452}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 4452}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e93b028d858c89e885eecf0860746803", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 4454}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 4454}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "f2472be890f75f0b7e765db5c7d68dd4", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 5261}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "d85450eb583b021de60b08ae0eb97192", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 55, "file": 0, "line": 5334}, "message": "const (fixit)"}, {"location": {"col": 63, "file": 0, "line": 5334}, "message": "pointer parameter 'target_dir' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e820c67a667511eaf1d4c9d074edfd5d", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5408}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5408}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "451d5e92fe91ff9784da58096de68ea6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5408}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5408}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "479505fcccd440b39b26b5b2aa537415", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 5410}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 5410}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "aa2edbcb732fd964ea1bd1d3c66207cd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 5410}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 5410}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "7aa9672f3246f7c1141459539d956dc0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5495}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5495}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "663140b138bf63dbe78fdf92d6094410", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 5495}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 5495}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "ce0e06f1ae825e729a61e29c87cf46e2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 5505}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 5505}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "6bd1df7b0888980bc6ba2b347068a9a0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 5505}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 5505}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "a2c474903ee47f94912e578af388175b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 5588}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 5588}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "14379f996fe69bc9d5fdfae3964580a8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 5588}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 5588}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "3d7c42fe26167def36ab34355b693a35", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5887}, "message": "kQfGetlistNone (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5887}, "message": "invalid case style for enum constant 'QF_GETLIST_NONE'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "1e524a7782650558fd8b576abf4e0e94", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5888}, "message": "kQfGetlistTitle (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5888}, "message": "invalid case style for enum constant 'QF_GETLIST_TITLE'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "4bcda72b5f277fe25c7855fbcbfc78e0", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5889}, "message": "kQfGetlistItems (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5889}, "message": "invalid case style for enum constant 'QF_GETLIST_ITEMS'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c8a4ea857d032da2992b97521b24d82f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5890}, "message": "kQfGetlistNr (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5890}, "message": "invalid case style for enum constant 'QF_GETLIST_NR'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "04d311f18b6a37e82fff22d8de3a85e2", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5891}, "message": "kQfGetlistWinid (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5891}, "message": "invalid case style for enum constant 'QF_GETLIST_WINID'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "53bda11dd811d2890bc5c698f06c4086", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5892}, "message": "kQfGetlistContext (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5892}, "message": "invalid case style for enum constant 'QF_GETLIST_CONTEXT'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c9f7238e88849ab99d3bfadb4f8f7fd3", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5893}, "message": "kQfGetlistId (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5893}, "message": "invalid case style for enum constant 'QF_GETLIST_ID'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "e973fe8a685fa2f4caf749066c48444b", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5894}, "message": "kQfGetlistIdx (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5894}, "message": "invalid case style for enum constant 'QF_GETLIST_IDX'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "ddd638568581eb4a610ed7793f14ccb0", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5895}, "message": "kQfGetlistSize (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5895}, "message": "invalid case style for enum constant 'QF_GETLIST_SIZE'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "25ff89714b3268c7e3405f26d87ad928", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5896}, "message": "kQfGetlistTick (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5896}, "message": "invalid case style for enum constant 'QF_GETLIST_TICK'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c62ba53b556b2848908863e356917425", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5897}, "message": "kQfGetlistFilewinid (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5897}, "message": "invalid case style for enum constant 'QF_GETLIST_FILEWINID'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "db29dabad62818f135b19355b669594c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5898}, "message": "kQfGetlistQfbufnr (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5898}, "message": "invalid case style for enum constant 'QF_GETLIST_QFBUFNR'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "8f0747b62ab3c497dc9c17f43336e19f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5899}, "message": "kQfGetlistQftf (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5899}, "message": "invalid case style for enum constant 'QF_GETLIST_QFTF'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "813dfb9920d281ed6b11b17d82688956", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5900}, "message": "kQfGetlistAll (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5900}, "message": "invalid case style for enum constant 'QF_GETLIST_ALL'"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "03de33a7779a82fe0833f969b10b5904", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6838}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6838}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "f07105857ad609a1e2b6ce1610a49df5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6838}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6838}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "227ef73ab26004c9e4f87390122cc0ab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 6840}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 6840}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "c967747624c8fffa7afa431fb11a0d46", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 6840}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 6840}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/quickfix.c", "reportHash": "292ba153e20e0c70b353ad2ec587948c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
