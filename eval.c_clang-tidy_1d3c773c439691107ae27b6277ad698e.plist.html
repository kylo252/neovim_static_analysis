<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/eval.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * eval.c: Expression evaluation.\n */\n\n#include <math.h>\n\n#include \"auto/config.h\"\n\n#ifdef HAVE_LOCALE_H\n# include <locale.h>\n#endif\n\n#include \"nvim/ascii.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/change.h\"\n#include \"nvim/channel.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/encode.h\"\n#include \"nvim/eval/executor.h\"\n#include \"nvim/eval/gc.h\"\n#include \"nvim/eval/typval.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/ex_session.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/lua/executor.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/move.h\"\n#include \"nvim/ops.h\"\n#include \"nvim/option.h\"\n#include \"nvim/os/input.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/shell.h\"\n#include \"nvim/path.h\"\n#include \"nvim/quickfix.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/search.h\"\n#include \"nvim/sign.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/version.h\"\n#include \"nvim/window.h\"\n\n\n// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead\n\n#define DICT_MAXNEST 100        // maximum nesting of lists and dicts\n\n\nstatic char *e_letunexp = N_(\"E18: Unexpected characters in :let\");\nstatic char *e_missbrac = N_(\"E111: Missing ']'\");\nstatic char *e_dictrange = N_(\"E719: Cannot use [:] with a Dictionary\");\nstatic char *e_illvar = N_(\"E461: Illegal variable name: %s\");\nstatic char *e_cannot_mod = N_(\"E995: Cannot modify existing variable\");\nstatic char *e_nowhitespace\n  = N_(\"E274: No white space allowed before parenthesis\");\nstatic char *e_invalwindow = N_(\"E957: Invalid window number\");\nstatic char *e_lock_unlock = N_(\"E940: Cannot lock or unlock variable %s\");\nstatic char *e_write2 = N_(\"E80: Error while writing: %s\");\n\n// TODO(ZyX-I): move to eval/executor\nstatic char *e_letwrong = N_(\"E734: Wrong variable type for %s=\");\n\nstatic char_u * const namespace_char = (char_u *)\"abglstvw\";\n\n/// Variable used for g:\nstatic ScopeDictDictItem globvars_var;\n\n/*\n * Old Vim variables such as \"v:version\" are also available without the \"v:\".\n * Also in functions.  We need a special hashtable for them.\n */\nstatic hashtab_T compat_hashtab;\n\n/// Used for checking if local variables or arguments used in a lambda.\nbool *eval_lavars_used = NULL;\n\n/*\n * Array to hold the hashtab with variables local to each sourced script.\n * Each item holds a variable (nameless) that points to the dict_T.\n */\ntypedef struct {\n  ScopeDictDictItem sv_var;\n  dict_T sv_dict;\n} scriptvar_T;\n\nstatic garray_T ga_scripts = { 0, 0, sizeof(scriptvar_T *), 4, NULL };\n#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])\n#define SCRIPT_VARS(id) (SCRIPT_SV(id)->sv_dict.dv_hashtab)\n\nstatic int echo_attr = 0;   // attributes used for \":echo\"\n\n// The names of packages that once were loaded are remembered.\nstatic garray_T ga_loaded = { 0, 0, sizeof(char_u *), 4, NULL };\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct {\n  int fi_semicolon;             // TRUE if ending in '; var]'\n  int fi_varcount;              // nr of variables in the list\n  listwatch_T fi_lw;            // keep an eye on the item used.\n  list_T *fi_list;         // list being used\n  int fi_bi;                    // index of blob\n  blob_T *fi_blob;              // blob being used\n} forinfo_T;\n\n// values for vv_flags:\n#define VV_COMPAT       1       // compatible, also used without \"v:\"\n#define VV_RO           2       // read-only\n#define VV_RO_SBX       4       // read-only in the sandbox\n\n#define VV(idx, name, type, flags) \\\n  [idx] = { \\\n    .vv_name = name, \\\n    .vv_di = { \\\n      .di_tv = { .v_type = type }, \\\n      .di_flags = 0, \\\n      .di_key = { 0 }, \\\n    }, \\\n    .vv_flags = flags, \\\n  }\n\n// Array to hold the value of v: variables.\n// The value is in a dictitem, so that it can also be used in the v: scope.\n// The reason to use this table anyway is for very quick access to the\n// variables with the VV_ defines.\nstatic struct vimvar {\n  char *vv_name;  ///< Name of the variable, without v:.\n  TV_DICTITEM_STRUCT(17) vv_di;  ///< Value and name for key (max 16 chars).\n  char vv_flags;  ///< Flags: #VV_COMPAT, #VV_RO, #VV_RO_SBX.\n} vimvars[] =\n{\n  // VV_ tails differing from upcased string literals:\n  // VV_CC_FROM \"charconvert_from\"\n  // VV_CC_TO \"charconvert_to\"\n  // VV_SEND_SERVER \"servername\"\n  // VV_REG \"register\"\n  // VV_OP \"operator\"\n  VV(VV_COUNT,          \"count\",            VAR_NUMBER, VV_RO),\n  VV(VV_COUNT1,         \"count1\",           VAR_NUMBER, VV_RO),\n  VV(VV_PREVCOUNT,      \"prevcount\",        VAR_NUMBER, VV_RO),\n  VV(VV_ERRMSG,         \"errmsg\",           VAR_STRING, 0),\n  VV(VV_WARNINGMSG,     \"warningmsg\",       VAR_STRING, 0),\n  VV(VV_STATUSMSG,      \"statusmsg\",        VAR_STRING, 0),\n  VV(VV_SHELL_ERROR,    \"shell_error\",      VAR_NUMBER, VV_RO),\n  VV(VV_THIS_SESSION,   \"this_session\",     VAR_STRING, 0),\n  VV(VV_VERSION,        \"version\",          VAR_NUMBER, VV_COMPAT+VV_RO),\n  VV(VV_LNUM,           \"lnum\",             VAR_NUMBER, VV_RO_SBX),\n  VV(VV_TERMRESPONSE,   \"termresponse\",     VAR_STRING, VV_RO),\n  VV(VV_FNAME,          \"fname\",            VAR_STRING, VV_RO),\n  VV(VV_LANG,           \"lang\",             VAR_STRING, VV_RO),\n  VV(VV_LC_TIME,        \"lc_time\",          VAR_STRING, VV_RO),\n  VV(VV_CTYPE,          \"ctype\",            VAR_STRING, VV_RO),\n  VV(VV_CC_FROM,        \"charconvert_from\", VAR_STRING, VV_RO),\n  VV(VV_CC_TO,          \"charconvert_to\",   VAR_STRING, VV_RO),\n  VV(VV_FNAME_IN,       \"fname_in\",         VAR_STRING, VV_RO),\n  VV(VV_FNAME_OUT,      \"fname_out\",        VAR_STRING, VV_RO),\n  VV(VV_FNAME_NEW,      \"fname_new\",        VAR_STRING, VV_RO),\n  VV(VV_FNAME_DIFF,     \"fname_diff\",       VAR_STRING, VV_RO),\n  VV(VV_CMDARG,         \"cmdarg\",           VAR_STRING, VV_RO),\n  VV(VV_FOLDSTART,      \"foldstart\",        VAR_NUMBER, VV_RO_SBX),\n  VV(VV_FOLDEND,        \"foldend\",          VAR_NUMBER, VV_RO_SBX),\n  VV(VV_FOLDDASHES,     \"folddashes\",       VAR_STRING, VV_RO_SBX),\n  VV(VV_FOLDLEVEL,      \"foldlevel\",        VAR_NUMBER, VV_RO_SBX),\n  VV(VV_PROGNAME,       \"progname\",         VAR_STRING, VV_RO),\n  VV(VV_SEND_SERVER,    \"servername\",       VAR_STRING, VV_RO),\n  VV(VV_DYING,          \"dying\",            VAR_NUMBER, VV_RO),\n  VV(VV_EXCEPTION,      \"exception\",        VAR_STRING, VV_RO),\n  VV(VV_THROWPOINT,     \"throwpoint\",       VAR_STRING, VV_RO),\n  VV(VV_REG,            \"register\",         VAR_STRING, VV_RO),\n  VV(VV_CMDBANG,        \"cmdbang\",          VAR_NUMBER, VV_RO),\n  VV(VV_INSERTMODE,     \"insertmode\",       VAR_STRING, VV_RO),\n  VV(VV_VAL,            \"val\",              VAR_UNKNOWN, VV_RO),\n  VV(VV_KEY,            \"key\",              VAR_UNKNOWN, VV_RO),\n  VV(VV_PROFILING,      \"profiling\",        VAR_NUMBER, VV_RO),\n  VV(VV_FCS_REASON,     \"fcs_reason\",       VAR_STRING, VV_RO),\n  VV(VV_FCS_CHOICE,     \"fcs_choice\",       VAR_STRING, 0),\n  VV(VV_BEVAL_BUFNR,    \"beval_bufnr\",      VAR_NUMBER, VV_RO),\n  VV(VV_BEVAL_WINNR,    \"beval_winnr\",      VAR_NUMBER, VV_RO),\n  VV(VV_BEVAL_WINID,    \"beval_winid\",      VAR_NUMBER, VV_RO),\n  VV(VV_BEVAL_LNUM,     \"beval_lnum\",       VAR_NUMBER, VV_RO),\n  VV(VV_BEVAL_COL,      \"beval_col\",        VAR_NUMBER, VV_RO),\n  VV(VV_BEVAL_TEXT,     \"beval_text\",       VAR_STRING, VV_RO),\n  VV(VV_SCROLLSTART,    \"scrollstart\",      VAR_STRING, 0),\n  VV(VV_SWAPNAME,       \"swapname\",         VAR_STRING, VV_RO),\n  VV(VV_SWAPCHOICE,     \"swapchoice\",       VAR_STRING, 0),\n  VV(VV_SWAPCOMMAND,    \"swapcommand\",      VAR_STRING, VV_RO),\n  VV(VV_CHAR,           \"char\",             VAR_STRING, 0),\n  VV(VV_MOUSE_WIN,      \"mouse_win\",        VAR_NUMBER, 0),\n  VV(VV_MOUSE_WINID,    \"mouse_winid\",      VAR_NUMBER, 0),\n  VV(VV_MOUSE_LNUM,     \"mouse_lnum\",       VAR_NUMBER, 0),\n  VV(VV_MOUSE_COL,      \"mouse_col\",        VAR_NUMBER, 0),\n  VV(VV_OP,             \"operator\",         VAR_STRING, VV_RO),\n  VV(VV_SEARCHFORWARD,  \"searchforward\",    VAR_NUMBER, 0),\n  VV(VV_HLSEARCH,       \"hlsearch\",         VAR_NUMBER, 0),\n  VV(VV_OLDFILES,       \"oldfiles\",         VAR_LIST, 0),\n  VV(VV_WINDOWID,       \"windowid\",         VAR_NUMBER, VV_RO_SBX),\n  VV(VV_PROGPATH,       \"progpath\",         VAR_STRING, VV_RO),\n  VV(VV_COMPLETED_ITEM, \"completed_item\",   VAR_DICT, VV_RO),\n  VV(VV_OPTION_NEW,     \"option_new\",       VAR_STRING, VV_RO),\n  VV(VV_OPTION_OLD,     \"option_old\",       VAR_STRING, VV_RO),\n  VV(VV_OPTION_TYPE,    \"option_type\",      VAR_STRING, VV_RO),\n  VV(VV_ERRORS,         \"errors\",           VAR_LIST, 0),\n  VV(VV_FALSE,          \"false\",            VAR_BOOL, VV_RO),\n  VV(VV_TRUE,           \"true\",             VAR_BOOL, VV_RO),\n  VV(VV_NULL,           \"null\",             VAR_SPECIAL, VV_RO),\n  VV(VV_NUMBERMAX,      \"numbermax\",        VAR_NUMBER, VV_RO),\n  VV(VV_NUMBERMIN,      \"numbermin\",        VAR_NUMBER, VV_RO),\n  VV(VV_NUMBERSIZE,     \"numbersize\",       VAR_NUMBER, VV_RO),\n  VV(VV_VIM_DID_ENTER,  \"vim_did_enter\",    VAR_NUMBER, VV_RO),\n  VV(VV_TESTING,        \"testing\",          VAR_NUMBER, 0),\n  VV(VV_TYPE_NUMBER,    \"t_number\",         VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_STRING,    \"t_string\",         VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_FUNC,      \"t_func\",           VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_LIST,      \"t_list\",           VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_DICT,      \"t_dict\",           VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_FLOAT,     \"t_float\",          VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_BOOL,      \"t_bool\",           VAR_NUMBER, VV_RO),\n  VV(VV_TYPE_BLOB,      \"t_blob\",           VAR_NUMBER, VV_RO),\n  VV(VV_EVENT,          \"event\",            VAR_DICT, VV_RO),\n  VV(VV_ECHOSPACE,      \"echospace\",        VAR_NUMBER, VV_RO),\n  VV(VV_ARGV,           \"argv\",             VAR_LIST, VV_RO),\n  VV(VV_COLLATE,        \"collate\",          VAR_STRING, VV_RO),\n  VV(VV_EXITING,        \"exiting\",          VAR_NUMBER, VV_RO),\n  // Neovim\n  VV(VV_STDERR,         \"stderr\",           VAR_NUMBER, VV_RO),\n  VV(VV_MSGPACK_TYPES,  \"msgpack_types\",    VAR_DICT, VV_RO),\n  VV(VV__NULL_STRING,   \"_null_string\",     VAR_STRING, VV_RO),\n  VV(VV__NULL_LIST,     \"_null_list\",       VAR_LIST, VV_RO),\n  VV(VV__NULL_DICT,     \"_null_dict\",       VAR_DICT, VV_RO),\n  VV(VV__NULL_BLOB,     \"_null_blob\",       VAR_BLOB, VV_RO),\n  VV(VV_LUA,            \"lua\",              VAR_PARTIAL, VV_RO),\n};\n#undef VV\n\n// shorthand\n#define vv_type         vv_di.di_tv.v_type\n#define vv_nr           vv_di.di_tv.vval.v_number\n#define vv_bool         vv_di.di_tv.vval.v_bool\n#define vv_special      vv_di.di_tv.vval.v_special\n#define vv_float        vv_di.di_tv.vval.v_float\n#define vv_str          vv_di.di_tv.vval.v_string\n#define vv_list         vv_di.di_tv.vval.v_list\n#define vv_dict         vv_di.di_tv.vval.v_dict\n#define vv_blob         vv_di.di_tv.vval.v_blob\n#define vv_partial      vv_di.di_tv.vval.v_partial\n#define vv_tv           vv_di.di_tv\n\n/// Variable used for v:\nstatic ScopeDictDictItem vimvars_var;\n\nstatic partial_T *vvlua_partial;\n\n/// v: hashtab\n#define vimvarht  vimvardict.dv_hashtab\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"eval.c.generated.h\"\n#endif\n\nstatic uint64_t last_timer_id = 1;\nstatic PMap(uint64_t) timers = MAP_INIT;\n\nstatic const char *const msgpack_type_names[] = {\n  [kMPNil] = \"nil\",\n  [kMPBoolean] = \"boolean\",\n  [kMPInteger] = \"integer\",\n  [kMPFloat] = \"float\",\n  [kMPString] = \"string\",\n  [kMPBinary] = \"binary\",\n  [kMPArray] = \"array\",\n  [kMPMap] = \"map\",\n  [kMPExt] = \"ext\",\n};\nconst list_T *eval_msgpack_type_lists[] = {\n  [kMPNil] = NULL,\n  [kMPBoolean] = NULL,\n  [kMPInteger] = NULL,\n  [kMPFloat] = NULL,\n  [kMPString] = NULL,\n  [kMPBinary] = NULL,\n  [kMPArray] = NULL,\n  [kMPMap] = NULL,\n  [kMPExt] = NULL,\n};\n\n// Return \"n1\" divided by \"n2\", taking care of dividing by zero.\nvarnumber_T num_divide(varnumber_T n1, varnumber_T n2)\n  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  varnumber_T result;\n\n  if (n2 == 0) {  // give an error message?\n    if (n1 == 0) {\n      result = VARNUMBER_MIN;  // similar to NaN\n    } else if (n1 < 0) {\n      result = -VARNUMBER_MAX;\n    } else {\n      result = VARNUMBER_MAX;\n    }\n  } else {\n    result = n1 / n2;\n  }\n\n  return result;\n}\n\n// Return \"n1\" modulus \"n2\", taking care of dividing by zero.\nvarnumber_T num_modulus(varnumber_T n1, varnumber_T n2)\n  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Give an error when n2 is 0?\n  return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\nvoid eval_init(void)\n{\n  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;\n\n  struct vimvar *p;\n\n  init_var_dict(&globvardict, &globvars_var, VAR_DEF_SCOPE);\n  init_var_dict(&vimvardict, &vimvars_var, VAR_SCOPE);\n  vimvardict.dv_lock = VAR_FIXED;\n  hash_init(&compat_hashtab);\n  func_init();\n\n  for (size_t i = 0; i < ARRAY_SIZE(vimvars); i++) {\n    p = &vimvars[i];\n    assert(STRLEN(p->vv_name) <= 16);\n    STRCPY(p->vv_di.di_key, p->vv_name);\n    if (p->vv_flags & VV_RO) {\n      p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    } else if (p->vv_flags & VV_RO_SBX) {\n      p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;\n    } else {\n      p->vv_di.di_flags = DI_FLAGS_FIX;\n    }\n\n    // add to v: scope dict, unless the value is not always available\n    if (p->vv_type != VAR_UNKNOWN) {\n      hash_add(&vimvarht, p->vv_di.di_key);\n    }\n    if (p->vv_flags & VV_COMPAT) {\n      // add to compat scope dict\n      hash_add(&compat_hashtab, p->vv_di.di_key);\n    }\n  }\n  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;\n\n  dict_T *const msgpack_types_dict = tv_dict_alloc();\n  for (size_t i = 0; i < ARRAY_SIZE(msgpack_type_names); i++) {\n    list_T *const type_list = tv_list_alloc(0);\n    tv_list_set_lock(type_list, VAR_FIXED);\n    tv_list_ref(type_list);\n    dictitem_T *const di = tv_dict_item_alloc(msgpack_type_names[i]);\n    di->di_flags |= DI_FLAGS_RO|DI_FLAGS_FIX;\n    di->di_tv = (typval_T) {\n      .v_type = VAR_LIST,\n      .vval = { .v_list = type_list, },\n    };\n    eval_msgpack_type_lists[i] = type_list;\n    if (tv_dict_add(msgpack_types_dict, di) == FAIL) {\n      // There must not be duplicate items in this dictionary by definition.\n      abort();\n    }\n  }\n  msgpack_types_dict->dv_lock = VAR_FIXED;\n\n  set_vim_var_dict(VV_MSGPACK_TYPES, msgpack_types_dict);\n  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));\n\n  set_vim_var_dict(VV_EVENT, tv_dict_alloc_lock(VAR_FIXED));\n  set_vim_var_list(VV_ERRORS, tv_list_alloc(kListLenUnknown));\n  set_vim_var_nr(VV_STDERR,   CHAN_STDERR);\n  set_vim_var_nr(VV_SEARCHFORWARD, 1L);\n  set_vim_var_nr(VV_HLSEARCH, 1L);\n  set_vim_var_nr(VV_COUNT1, 1);\n  set_vim_var_nr(VV_TYPE_NUMBER, VAR_TYPE_NUMBER);\n  set_vim_var_nr(VV_TYPE_STRING, VAR_TYPE_STRING);\n  set_vim_var_nr(VV_TYPE_FUNC,   VAR_TYPE_FUNC);\n  set_vim_var_nr(VV_TYPE_LIST,   VAR_TYPE_LIST);\n  set_vim_var_nr(VV_TYPE_DICT,   VAR_TYPE_DICT);\n  set_vim_var_nr(VV_TYPE_FLOAT,  VAR_TYPE_FLOAT);\n  set_vim_var_nr(VV_TYPE_BOOL,   VAR_TYPE_BOOL);\n  set_vim_var_nr(VV_TYPE_BLOB,   VAR_TYPE_BLOB);\n\n  set_vim_var_bool(VV_FALSE, kBoolVarFalse);\n  set_vim_var_bool(VV_TRUE, kBoolVarTrue);\n  set_vim_var_special(VV_NULL, kSpecialVarNull);\n  set_vim_var_nr(VV_NUMBERMAX, VARNUMBER_MAX);\n  set_vim_var_nr(VV_NUMBERMIN, VARNUMBER_MIN);\n  set_vim_var_nr(VV_NUMBERSIZE, sizeof(varnumber_T) * 8);\n  set_vim_var_special(VV_EXITING, kSpecialVarNull);\n\n  set_vim_var_nr(VV_ECHOSPACE,    sc_col - 1);\n\n  vimvars[VV_LUA].vv_type = VAR_PARTIAL;\n  vvlua_partial = xcalloc(1, sizeof(partial_T));\n  vimvars[VV_LUA].vv_partial = vvlua_partial;\n  // this value shouldn't be printed, but if it is, do not crash\n  vvlua_partial->pt_name = xmallocz(0);\n  vvlua_partial->pt_refcount++;\n\n  set_reg_var(0);  // default for v:register is not 0 but '\"'\n}\n\n#if defined(EXITFREE)\nvoid eval_clear(void)\n{\n  struct vimvar *p;\n\n  for (size_t i = 0; i < ARRAY_SIZE(vimvars); i++) {\n    p = &vimvars[i];\n    if (p->vv_di.di_tv.v_type == VAR_STRING) {\n      XFREE_CLEAR(p->vv_str);\n    } else if (p->vv_di.di_tv.v_type == VAR_LIST) {\n      tv_list_unref(p->vv_list);\n      p->vv_list = NULL;\n    }\n  }\n  hash_clear(&vimvarht);\n  hash_init(&vimvarht);    // garbage_collect() will access it\n  hash_clear(&compat_hashtab);\n\n  free_scriptnames();\n  free_locales();\n\n  // global variables\n  vars_clear(&globvarht);\n\n  // autoloaded script names\n  ga_clear_strings(&ga_loaded);\n\n  /* Script-local variables. First clear all the variables and in a second\n   * loop free the scriptvar_T, because a variable in one script might hold\n   * a reference to the whole scope of another script. */\n  for (int i = 1; i <= ga_scripts.ga_len; ++i) {\n    vars_clear(&SCRIPT_VARS(i));\n  }\n  for (int i = 1; i <= ga_scripts.ga_len; ++i) {\n    xfree(SCRIPT_SV(i));\n  }\n  ga_clear(&ga_scripts);\n\n  // unreferenced lists and dicts\n  (void)garbage_collect(false);\n\n  // functions not garbage collected\n  free_all_functions();\n}\n\n#endif\n\n/*\n * Set an internal variable to a string value. Creates the variable if it does\n * not already exist.\n */\nvoid set_internal_string_var(const char *name, char_u *value)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  typval_T tv = {\n    .v_type = VAR_STRING,\n    .vval.v_string = value,\n  };\n\n  set_var(name, strlen(name), &tv, true);\n}\n\nstatic lval_T *redir_lval = NULL;\nstatic garray_T redir_ga;  // Only valid when redir_lval is not NULL.\nstatic char_u *redir_endp = NULL;\nstatic char_u *redir_varname = NULL;\n\n/// Start recording command output to a variable\n/// Returns OK if successfully completed the setup.  FAIL otherwise.\n///\n/// @param append  append to an existing variable\nint var_redir_start(char_u *name, int append)\n{\n  int save_emsg;\n  int err;\n  typval_T tv;\n\n  // Catch a bad name early.\n  if (!eval_isnamec1(*name)) {\n    EMSG(_(e_invarg));\n    return FAIL;\n  }\n\n  // Make a copy of the name, it is used in redir_lval until redir ends.\n  redir_varname = vim_strsave(name);\n\n  redir_lval = xcalloc(1, sizeof(lval_T));\n\n  // The output is stored in growarray \"redir_ga\" until redirection ends.\n  ga_init(&redir_ga, (int)sizeof(char), 500);\n\n  // Parse the variable name (can be a dict or list entry).\n  redir_endp = (char_u *)get_lval(redir_varname, NULL, redir_lval, false, false,\n                                  0, FNE_CHECK_START);\n  if (redir_endp == NULL || redir_lval->ll_name == NULL\n      || *redir_endp != NUL) {\n    clear_lval(redir_lval);\n    if (redir_endp != NULL && *redir_endp != NUL) {\n      // Trailing characters are present after the variable name\n      EMSG(_(e_trailing));\n    } else {\n      EMSG(_(e_invarg));\n    }\n    redir_endp = NULL;      // don't store a value, only cleanup\n    var_redir_stop();\n    return FAIL;\n  }\n\n  /* check if we can write to the variable: set it to or append an empty\n   * string */\n  save_emsg = did_emsg;\n  did_emsg = FALSE;\n  tv.v_type = VAR_STRING;\n  tv.vval.v_string = (char_u *)\"\";\n  if (append) {\n    set_var_lval(redir_lval, redir_endp, &tv, true, false, \".\");\n  } else {\n    set_var_lval(redir_lval, redir_endp, &tv, true, false, \"=\");\n  }\n  clear_lval(redir_lval);\n  err = did_emsg;\n  did_emsg |= save_emsg;\n  if (err) {\n    redir_endp = NULL;      // don't store a value, only cleanup\n    var_redir_stop();\n    return FAIL;\n  }\n\n  return OK;\n}\n\n/*\n * Append \"value[value_len]\" to the variable set by var_redir_start().\n * The actual appending is postponed until redirection ends, because the value\n * appended may in fact be the string we write to, changing it may cause freed\n * memory to be used:\n *   :redir => foo\n *   :let foo\n *   :redir END\n */\nvoid var_redir_str(char_u *value, int value_len)\n{\n  int len;\n\n  if (redir_lval == NULL) {\n    return;\n  }\n\n  if (value_len == -1) {\n    len = (int)STRLEN(value);           // Append the entire string\n  } else {\n    len = value_len;                    // Append only \"value_len\" characters\n  }\n\n  ga_grow(&redir_ga, len);\n  memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);\n  redir_ga.ga_len += len;\n}\n\n/*\n * Stop redirecting command output to a variable.\n * Frees the allocated memory.\n */\nvoid var_redir_stop(void)\n{\n  typval_T tv;\n\n  if (redir_lval != NULL) {\n    // If there was no error: assign the text to the variable.\n    if (redir_endp != NULL) {\n      ga_append(&redir_ga, NUL);        // Append the trailing NUL.\n      tv.v_type = VAR_STRING;\n      tv.vval.v_string = redir_ga.ga_data;\n      // Call get_lval() again, if it's inside a Dict or List it may\n      // have changed.\n      redir_endp = (char_u *)get_lval(redir_varname, NULL, redir_lval,\n                                      false, false, 0, FNE_CHECK_START);\n      if (redir_endp != NULL && redir_lval->ll_name != NULL) {\n        set_var_lval(redir_lval, redir_endp, &tv, false, false, \".\");\n      }\n      clear_lval(redir_lval);\n    }\n\n    // free the collected output\n    XFREE_CLEAR(redir_ga.ga_data);\n\n    XFREE_CLEAR(redir_lval);\n  }\n  XFREE_CLEAR(redir_varname);\n}\n\nint eval_charconvert(const char *const enc_from, const char *const enc_to,\n                     const char *const fname_from, const char *const fname_to)\n{\n  bool err = false;\n\n  set_vim_var_string(VV_CC_FROM, enc_from, -1);\n  set_vim_var_string(VV_CC_TO, enc_to, -1);\n  set_vim_var_string(VV_FNAME_IN, fname_from, -1);\n  set_vim_var_string(VV_FNAME_OUT, fname_to, -1);\n  if (eval_to_bool(p_ccv, &err, NULL, false)) {\n    err = true;\n  }\n  set_vim_var_string(VV_CC_FROM, NULL, -1);\n  set_vim_var_string(VV_CC_TO, NULL, -1);\n  set_vim_var_string(VV_FNAME_IN, NULL, -1);\n  set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n\n  if (err) {\n    return FAIL;\n  }\n  return OK;\n}\n\nint eval_printexpr(const char *const fname, const char *const args)\n{\n  bool err = false;\n\n  set_vim_var_string(VV_FNAME_IN, fname, -1);\n  set_vim_var_string(VV_CMDARG, args, -1);\n  if (eval_to_bool(p_pexpr, &err, NULL, false)) {\n    err = true;\n  }\n  set_vim_var_string(VV_FNAME_IN, NULL, -1);\n  set_vim_var_string(VV_CMDARG, NULL, -1);\n\n  if (err) {\n    os_remove(fname);\n    return FAIL;\n  }\n  return OK;\n}\n\nvoid eval_diff(const char *const origfile, const char *const newfile, const char *const outfile)\n{\n  bool err = false;\n\n  set_vim_var_string(VV_FNAME_IN, origfile, -1);\n  set_vim_var_string(VV_FNAME_NEW, newfile, -1);\n  set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n  (void)eval_to_bool(p_dex, &err, NULL, FALSE);\n  set_vim_var_string(VV_FNAME_IN, NULL, -1);\n  set_vim_var_string(VV_FNAME_NEW, NULL, -1);\n  set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n}\n\nvoid eval_patch(const char *const origfile, const char *const difffile, const char *const outfile)\n{\n  bool err = false;\n\n  set_vim_var_string(VV_FNAME_IN, origfile, -1);\n  set_vim_var_string(VV_FNAME_DIFF, difffile, -1);\n  set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n  (void)eval_to_bool(p_pex, &err, NULL, FALSE);\n  set_vim_var_string(VV_FNAME_IN, NULL, -1);\n  set_vim_var_string(VV_FNAME_DIFF, NULL, -1);\n  set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n}\n\n/// Top level evaluation function, returning a boolean.\n/// Sets \"error\" to TRUE if there was an error.\n///\n/// @param skip  only parse, don't execute\n///\n/// @return  TRUE or FALSE.\nint eval_to_bool(char_u *arg, bool *error, char_u **nextcmd, int skip)\n{\n  typval_T tv;\n  bool retval = false;\n\n  if (skip) {\n    emsg_skip++;\n  }\n  if (eval0(arg, &tv, nextcmd, !skip) == FAIL) {\n    *error = true;\n  } else {\n    *error = false;\n    if (!skip) {\n      retval = (tv_get_number_chk(&tv, error) != 0);\n      tv_clear(&tv);\n    }\n  }\n  if (skip) {\n    emsg_skip--;\n  }\n\n  return retval;\n}\n\n// Call eval1() and give an error message if not done at a lower level.\nstatic int eval1_emsg(char_u **arg, typval_T *rettv, bool evaluate)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  const char_u *const start = *arg;\n  const int did_emsg_before = did_emsg;\n  const int called_emsg_before = called_emsg;\n\n  const int ret = eval1(arg, rettv, evaluate);\n  if (ret == FAIL) {\n    // Report the invalid expression unless the expression evaluation has\n    // been cancelled due to an aborting error, an interrupt, or an\n    // exception, or we already gave a more specific error.\n    // Also check called_emsg for when using assert_fails().\n    if (!aborting()\n        && did_emsg == did_emsg_before\n        && called_emsg == called_emsg_before) {\n      emsgf(_(e_invexpr2), start);\n    }\n  }\n  return ret;\n}\n\nint eval_expr_typval(const typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 4)\n{\n  funcexe_T funcexe = FUNCEXE_INIT;\n\n  if (expr->v_type == VAR_FUNC) {\n    const char_u *const s = expr->vval.v_string;\n    if (s == NULL || *s == NUL) {\n      return FAIL;\n    }\n    funcexe.evaluate = true;\n    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL) {\n      return FAIL;\n    }\n  } else if (expr->v_type == VAR_PARTIAL) {\n    partial_T *const partial = expr->vval.v_partial;\n    const char_u *const s = partial_name(partial);\n    if (s == NULL || *s == NUL) {\n      return FAIL;\n    }\n    funcexe.evaluate = true;\n    funcexe.partial = partial;\n    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL) {\n      return FAIL;\n    }\n  } else {\n    char buf[NUMBUFLEN];\n    char_u *s = (char_u *)tv_get_string_buf_chk(expr, buf);\n    if (s == NULL) {\n      return FAIL;\n    }\n    s = skipwhite(s);\n    if (eval1_emsg(&s, rettv, true) == FAIL) {\n      return FAIL;\n    }\n    if (*skipwhite(s) != NUL) {  // check for trailing chars after expr\n      tv_clear(rettv);\n      emsgf(_(e_invexpr2), s);\n      return FAIL;\n    }\n  }\n  return OK;\n}\n\n/// Like eval_to_bool() but using a typval_T instead of a string.\n/// Works for string, funcref and partial.\nbool eval_expr_to_bool(const typval_T *expr, bool *error)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  typval_T argv, rettv;\n\n  if (eval_expr_typval(expr, &argv, 0, &rettv) == FAIL) {\n    *error = true;\n    return false;\n  }\n  const bool res = (tv_get_number_chk(&rettv, error) != 0);\n  tv_clear(&rettv);\n  return res;\n}\n\n/// Top level evaluation function, returning a string\n///\n/// @param[in]  arg  String to evaluate.\n/// @param  nextcmd  Pointer to the start of the next Ex command.\n/// @param[in]  skip  If true, only do parsing to nextcmd without reporting\n///                   errors or actually evaluating anything.\n///\n/// @return [allocated] string result of evaluation or NULL in case of error or\n///                     when skipping.\nchar *eval_to_string_skip(const char *arg, const char **nextcmd, const bool skip)\n  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  typval_T tv;\n  char *retval;\n\n  if (skip) {\n    emsg_skip++;\n  }\n  if (eval0((char_u *)arg, &tv, (char_u **)nextcmd, !skip) == FAIL || skip) {\n    retval = NULL;\n  } else {\n    retval = xstrdup(tv_get_string(&tv));\n    tv_clear(&tv);\n  }\n  if (skip) {\n    emsg_skip--;\n  }\n\n  return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\nint skip_expr(char_u **pp)\n{\n  typval_T rettv;\n\n  *pp = skipwhite(*pp);\n  return eval1(pp, &rettv, FALSE);\n}\n\n/// Top level evaluation function, returning a string.\n///\n/// @param convert  when true convert a List into a sequence of lines and convert\n///                 a Float to a String.\n///\n/// @return         pointer to allocated memory, or NULL for failure.\nchar_u *eval_to_string(char_u *arg, char_u **nextcmd, bool convert)\n{\n  typval_T tv;\n  char *retval;\n  garray_T ga;\n\n  if (eval0(arg, &tv, nextcmd, true) == FAIL) {\n    retval = NULL;\n  } else {\n    if (convert && tv.v_type == VAR_LIST) {\n      ga_init(&ga, (int)sizeof(char), 80);\n      if (tv.vval.v_list != NULL) {\n        tv_list_join(&ga, tv.vval.v_list, \"\\n\");\n        if (tv_list_len(tv.vval.v_list) > 0) {\n          ga_append(&ga, NL);\n        }\n      }\n      ga_append(&ga, NUL);\n      retval = (char *)ga.ga_data;\n    } else if (convert && tv.v_type == VAR_FLOAT) {\n      char numbuf[NUMBUFLEN];\n      vim_snprintf(numbuf, NUMBUFLEN, \"%g\", tv.vval.v_float);\n      retval = xstrdup(numbuf);\n    } else {\n      retval = xstrdup(tv_get_string(&tv));\n    }\n    tv_clear(&tv);\n  }\n\n  return (char_u *)retval;\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textlock.  When \"use_sandbox\" is TRUE use the sandbox.\n */\nchar_u *eval_to_string_safe(char_u *arg, char_u **nextcmd, int use_sandbox)\n{\n  char_u *retval;\n  funccal_entry_T funccal_entry;\n\n  save_funccal(&funccal_entry);\n  if (use_sandbox) {\n    sandbox++;\n  }\n  textlock++;\n  retval = eval_to_string(arg, nextcmd, false);\n  if (use_sandbox) {\n    sandbox--;\n  }\n  textlock--;\n  restore_funccal();\n  return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\nvarnumber_T eval_to_number(char_u *expr)\n{\n  typval_T rettv;\n  varnumber_T retval;\n  char_u *p = skipwhite(expr);\n\n  ++emsg_off;\n\n  if (eval1(&p, &rettv, true) == FAIL) {\n    retval = -1;\n  } else {\n    retval = tv_get_number_chk(&rettv, NULL);\n    tv_clear(&rettv);\n  }\n  --emsg_off;\n\n  return retval;\n}\n\n// Top level evaluation function.\n// Returns an allocated typval_T with the result.\n// Returns NULL when there is an error.\ntypval_T *eval_expr(char_u *arg)\n{\n  typval_T *tv = xmalloc(sizeof(*tv));\n  if (eval0(arg, tv, NULL, true) == FAIL) {\n    XFREE_CLEAR(tv);\n  }\n  return tv;\n}\n\n/*\n * Prepare v: variable \"idx\" to be used.\n * Save the current typeval in \"save_tv\".\n * When not used yet add the variable to the v: hashtable.\n */\nvoid prepare_vimvar(int idx, typval_T *save_tv)\n{\n  *save_tv = vimvars[idx].vv_tv;\n  if (vimvars[idx].vv_type == VAR_UNKNOWN) {\n    hash_add(&vimvarht, vimvars[idx].vv_di.di_key);\n  }\n}\n\n/*\n * Restore v: variable \"idx\" to typeval \"save_tv\".\n * When no longer defined, remove the variable from the v: hashtable.\n */\nvoid restore_vimvar(int idx, typval_T *save_tv)\n{\n  hashitem_T *hi;\n\n  vimvars[idx].vv_tv = *save_tv;\n  if (vimvars[idx].vv_type == VAR_UNKNOWN) {\n    hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);\n    if (HASHITEM_EMPTY(hi)) {\n      internal_error(\"restore_vimvar()\");\n    } else {\n      hash_remove(&vimvarht, hi);\n    }\n  }\n}\n\n/// If there is a window for \"curbuf\", make it the current window.\nvoid find_win_for_curbuf(void)\n{\n  for (wininfo_T *wip = curbuf->b_wininfo; wip != NULL; wip = wip->wi_next) {\n    if (wip->wi_win != NULL) {\n      curwin = wip->wi_win;\n      break;\n    }\n  }\n}\n\n/*\n * Evaluate an expression to a list with suggestions.\n * For the \"expr:\" part of 'spellsuggest'.\n * Returns NULL when there is an error.\n */\nlist_T *eval_spell_expr(char_u *badword, char_u *expr)\n{\n  typval_T save_val;\n  typval_T rettv;\n  list_T *list = NULL;\n  char_u *p = skipwhite(expr);\n\n  // Set \"v:val\" to the bad word.\n  prepare_vimvar(VV_VAL, &save_val);\n  vimvars[VV_VAL].vv_type = VAR_STRING;\n  vimvars[VV_VAL].vv_str = badword;\n  if (p_verbose == 0) {\n    ++emsg_off;\n  }\n\n  if (eval1(&p, &rettv, true) == OK) {\n    if (rettv.v_type != VAR_LIST) {\n      tv_clear(&rettv);\n    } else {\n      list = rettv.vval.v_list;\n    }\n  }\n\n  if (p_verbose == 0) {\n    --emsg_off;\n  }\n  restore_vimvar(VV_VAL, &save_val);\n\n  return list;\n}\n\n/// Get spell word from an entry from spellsuggest=expr:\n///\n/// Entry in question is supposed to be a list (to be checked by the caller)\n/// with two items: a word and a score represented as an unsigned number\n/// (whether it actually is unsigned is not checked).\n///\n/// Used to get the good word and score from the eval_spell_expr() result.\n///\n/// @param[in]  list  List to get values from.\n/// @param[out]  ret_word  Suggested word. Not initialized if return value is\n///                        -1.\n///\n/// @return -1 in case of error, score otherwise.\nint get_spellword(list_T *const list, const char **ret_word)\n{\n  if (tv_list_len(list) != 2) {\n    EMSG(_(\"E5700: Expression from 'spellsuggest' must yield lists with \"\n           \"exactly two values\"));\n    return -1;\n  }\n  *ret_word = tv_list_find_str(list, 0);\n  if (*ret_word == NULL) {\n    return -1;\n  }\n  return tv_list_find_nr(list, -1, NULL);\n}\n\n\n// Call some vim script function and return the result in \"*rettv\".\n// Uses argv[0] to argv[argc-1] for the function arguments. argv[argc]\n// should have type VAR_UNKNOWN.\n//\n// Return OK or FAIL.\nint call_vim_function(const char_u *func, int argc, typval_T *argv, typval_T *rettv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int ret;\n  int len = (int)STRLEN(func);\n  partial_T *pt = NULL;\n\n  if (len >= 6 && !memcmp(func, \"v:lua.\", 6)) {\n    func += 6;\n    len = check_luafunc_name((const char *)func, false);\n    if (len == 0) {\n      ret = FAIL;\n      goto fail;\n    }\n    pt = vvlua_partial;\n  }\n\n  rettv->v_type = VAR_UNKNOWN;  // tv_clear() uses this.\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = true;\n  funcexe.partial = pt;\n  ret = call_func(func, len, rettv, argc, argv, &funcexe);\n\nfail:\n  if (ret == FAIL) {\n    tv_clear(rettv);\n  }\n\n  return ret;\n}\n/// Call Vim script function and return the result as a number\n///\n/// @param[in]  func  Function name.\n/// @param[in]  argc  Number of arguments.\n/// @param[in]  argv  Array with typval_T arguments.\n///\n/// @return -1 when calling function fails, result of function otherwise.\nvarnumber_T call_func_retnr(const char_u *func, int argc, typval_T *argv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  typval_T rettv;\n  varnumber_T retval;\n\n  if (call_vim_function(func, argc, argv, &rettv) == FAIL) {\n    return -1;\n  }\n  retval = tv_get_number_chk(&rettv, NULL);\n  tv_clear(&rettv);\n  return retval;\n}\n/// Call Vim script function and return the result as a string\n///\n/// @param[in]  func  Function name.\n/// @param[in]  argc  Number of arguments.\n/// @param[in]  argv  Array with typval_T arguments.\n///\n/// @return [allocated] NULL when calling function fails, allocated string\n///                     otherwise.\nchar *call_func_retstr(const char *const func, int argc, typval_T *argv)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC\n{\n  typval_T rettv;\n  // All arguments are passed as strings, no conversion to number.\n  if (call_vim_function((const char_u *)func, argc, argv, &rettv)\n      == FAIL) {\n    return NULL;\n  }\n\n  char *const retval = xstrdup(tv_get_string(&rettv));\n  tv_clear(&rettv);\n  return retval;\n}\n/// Call Vim script function and return the result as a List\n///\n/// @param[in]  func  Function name.\n/// @param[in]  argc  Number of arguments.\n/// @param[in]  argv  Array with typval_T arguments.\n///\n/// @return [allocated] NULL when calling function fails or return tv is not a\n///                     List, allocated List otherwise.\nvoid *call_func_retlist(const char_u *func, int argc, typval_T *argv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  typval_T rettv;\n\n  // All arguments are passed as strings, no conversion to number.\n  if (call_vim_function(func, argc, argv, &rettv) == FAIL) {\n    return NULL;\n  }\n\n  if (rettv.v_type != VAR_LIST) {\n    tv_clear(&rettv);\n    return NULL;\n  }\n\n  return rettv.vval.v_list;\n}\n\n/// Prepare profiling for entering a child or something else that is not\n/// counted for the script/function itself.\n/// Should always be called in pair with prof_child_exit().\n///\n/// @param tm  place to store waittime\nvoid prof_child_enter(proftime_T *tm)\n{\n  funccall_T *fc = get_current_funccal();\n\n  if (fc != NULL && fc->func->uf_profiling) {\n    fc->prof_child = profile_start();\n  }\n\n  script_prof_save(tm);\n}\n\n/// Take care of time spent in a child.\n/// Should always be called after prof_child_enter().\n///\n/// @param tm  where waittime was stored\nvoid prof_child_exit(proftime_T *tm)\n{\n  funccall_T *fc = get_current_funccal();\n\n  if (fc != NULL && fc->func->uf_profiling) {\n    fc->prof_child = profile_end(fc->prof_child);\n    // don't count waiting time\n    fc->prof_child = profile_sub_wait(*tm, fc->prof_child);\n    fc->func->uf_tm_children =\n      profile_add(fc->func->uf_tm_children, fc->prof_child);\n    fc->func->uf_tml_children =\n      profile_add(fc->func->uf_tml_children, fc->prof_child);\n  }\n  script_prof_restore(tm);\n}\n\n\n/*\n * Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding\n * it in \"*cp\".  Doesn't give error messages.\n */\nint eval_foldexpr(char_u *arg, int *cp)\n{\n  typval_T tv;\n  varnumber_T retval;\n  int use_sandbox = was_set_insecurely(curwin, (char_u *)\"foldexpr\", OPT_LOCAL);\n\n  ++emsg_off;\n  if (use_sandbox) {\n    ++sandbox;\n  }\n  ++textlock;\n  *cp = NUL;\n  if (eval0(arg, &tv, NULL, true) == FAIL) {\n    retval = 0;\n  } else {\n    // If the result is a number, just return the number.\n    if (tv.v_type == VAR_NUMBER) {\n      retval = tv.vval.v_number;\n    } else if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL) {\n      retval = 0;\n    } else {\n      // If the result is a string, check if there is a non-digit before\n      // the number.\n      char_u *s = tv.vval.v_string;\n      if (!ascii_isdigit(*s) && *s != '-') {\n        *cp = *s++;\n      }\n      retval = atol((char *)s);\n    }\n    tv_clear(&tv);\n  }\n  --emsg_off;\n  if (use_sandbox) {\n    --sandbox;\n  }\n  --textlock;\n\n  return (int)retval;\n}\n\n// \":cons[t] var = expr1\" define constant\n// \":cons[t] [name1, name2, ...] = expr1\" define constants unpacking list\n// \":cons[t] [name, ..., ; lastname] = expr\" define constants unpacking list\nvoid ex_const(exarg_T *eap)\n{\n  ex_let_const(eap, true);\n}\n\n// Get a list of lines from a HERE document. The here document is a list of\n// lines surrounded by a marker.\n//     cmd << {marker}\n//       {line1}\n//       {line2}\n//       ....\n//     {marker}\n//\n// The {marker} is a string. If the optional 'trim' word is supplied before the\n// marker, then the leading indentation before the lines (matching the\n// indentation in the 'cmd' line) is stripped.\n// Returns a List with {lines} or NULL.\nstatic list_T *heredoc_get(exarg_T *eap, char_u *cmd)\n{\n  char_u *marker;\n  char_u *p;\n  int marker_indent_len = 0;\n  int text_indent_len = 0;\n  char_u *text_indent = NULL;\n\n  if (eap->getline == NULL) {\n    EMSG(_(\"E991: cannot use =<< here\"));\n    return NULL;\n  }\n\n  // Check for the optional 'trim' word before the marker\n  cmd = skipwhite(cmd);\n  if (STRNCMP(cmd, \"trim\", 4) == 0\n      && (cmd[4] == NUL || ascii_iswhite(cmd[4]))) {\n    cmd = skipwhite(cmd + 4);\n\n    // Trim the indentation from all the lines in the here document.\n    // The amount of indentation trimmed is the same as the indentation of\n    // the first line after the :let command line.  To find the end marker\n    // the indent of the :let command line is trimmed.\n    p = *eap->cmdlinep;\n    while (ascii_iswhite(*p)) {\n      p++;\n      marker_indent_len++;\n    }\n    text_indent_len = -1;\n  }\n\n  // The marker is the next word.\n  if (*cmd != NUL && *cmd != '\"') {\n    marker = skipwhite(cmd);\n    p = skiptowhite(marker);\n    if (*skipwhite(p) != NUL && *skipwhite(p) != '\"') {\n      EMSG(_(e_trailing));\n      return NULL;\n    }\n    *p = NUL;\n    if (islower(*marker)) {\n      EMSG(_(\"E221: Marker cannot start with lower case letter\"));\n      return NULL;\n    }\n  } else {\n    EMSG(_(\"E172: Missing marker\"));\n    return NULL;\n  }\n\n  list_T *l = tv_list_alloc(0);\n  for (;;) {\n    int mi = 0;\n    int ti = 0;\n\n    char_u *theline = eap->getline(NUL, eap->cookie, 0, false);\n    if (theline == NULL) {\n      EMSG2(_(\"E990: Missing end marker '%s'\"), marker);\n      break;\n    }\n\n    // with \"trim\": skip the indent matching the :let line to find the\n    // marker\n    if (marker_indent_len > 0\n        && STRNCMP(theline, *eap->cmdlinep, marker_indent_len) == 0) {\n      mi = marker_indent_len;\n    }\n    if (STRCMP(marker, theline + mi) == 0) {\n      xfree(theline);\n      break;\n    }\n    if (text_indent_len == -1 && *theline != NUL) {\n      // set the text indent from the first line.\n      p = theline;\n      text_indent_len = 0;\n      while (ascii_iswhite(*p)) {\n        p++;\n        text_indent_len++;\n      }\n      text_indent = vim_strnsave(theline, text_indent_len);\n    }\n    // with \"trim\": skip the indent matching the first line\n    if (text_indent != NULL) {\n      for (ti = 0; ti < text_indent_len; ti++) {\n        if (theline[ti] != text_indent[ti]) {\n          break;\n        }\n      }\n    }\n\n    tv_list_append_string(l, (char *)(theline + ti), -1);\n    xfree(theline);\n  }\n  xfree(text_indent);\n\n  return l;\n}\n\n// \":let\" list all variable values\n// \":let var1 var2\" list variable values\n// \":let var = expr\" assignment command.\n// \":let var += expr\" assignment command.\n// \":let var -= expr\" assignment command.\n// \":let var *= expr\" assignment command.\n// \":let var /= expr\" assignment command.\n// \":let var %= expr\" assignment command.\n// \":let var .= expr\" assignment command.\n// \":let var ..= expr\" assignment command.\n// \":let [var1, var2] = expr\" unpack list.\n// \":let [name, ..., ; lastname] = expr\" unpack list.\nvoid ex_let(exarg_T *eap)\n{\n  ex_let_const(eap, false);\n}\n\nstatic void ex_let_const(exarg_T *eap, const bool is_const)\n{\n  char_u *arg = eap->arg;\n  char_u *expr = NULL;\n  typval_T rettv;\n  int i;\n  int var_count = 0;\n  int semicolon = 0;\n  char_u op[2];\n  char_u *argend;\n  int first = TRUE;\n\n  argend = (char_u *)skip_var_list(arg, &var_count, &semicolon);\n  if (argend == NULL) {\n    return;\n  }\n  if (argend > arg && argend[-1] == '.') {  // For var.='str'.\n    argend--;\n  }\n  expr = skipwhite(argend);\n  if (*expr != '=' && !((vim_strchr((char_u *)\"+-*/%.\", *expr) != NULL\n                         && expr[1] == '=') || STRNCMP(expr, \"..=\", 3) == 0)) {\n    // \":let\" without \"=\": list variables\n    if (*arg == '[') {\n      EMSG(_(e_invarg));\n    } else if (!ends_excmd(*arg)) {\n      // \":let var1 var2\"\n      arg = (char_u *)list_arg_vars(eap, (const char *)arg, &first);\n    } else if (!eap->skip) {\n      // \":let\"\n      list_glob_vars(&first);\n      list_buf_vars(&first);\n      list_win_vars(&first);\n      list_tab_vars(&first);\n      list_script_vars(&first);\n      list_func_vars(&first);\n      list_vim_vars(&first);\n    }\n    eap->nextcmd = check_nextcmd(arg);\n  } else if (expr[0] == '=' && expr[1] == '<' && expr[2] == '<') {\n    // HERE document\n    list_T *l = heredoc_get(eap, expr + 3);\n    if (l != NULL) {\n      tv_list_set_ret(&rettv, l);\n      if (!eap->skip) {\n        op[0] = '=';\n        op[1] = NUL;\n        (void)ex_let_vars(eap->arg, &rettv, false, semicolon, var_count,\n                          is_const, op);\n      }\n      tv_clear(&rettv);\n    }\n  } else {\n    op[0] = '=';\n    op[1] = NUL;\n    if (*expr != '=') {\n      if (vim_strchr((char_u *)\"+-*/%.\", *expr) != NULL) {\n        op[0] = *expr;  // +=, -=, *=, /=, %= or .=\n        if (expr[0] == '.' && expr[1] == '.') {  // ..=\n          expr++;\n        }\n      }\n      expr = skipwhite(expr + 2);\n    } else {\n      expr = skipwhite(expr + 1);\n    }\n\n    if (eap->skip) {\n      ++emsg_skip;\n    }\n    i = eval0(expr, &rettv, &eap->nextcmd, !eap->skip);\n    if (eap->skip) {\n      if (i != FAIL) {\n        tv_clear(&rettv);\n      }\n      emsg_skip--;\n    } else if (i != FAIL) {\n      (void)ex_let_vars(eap->arg, &rettv, false, semicolon, var_count,\n                        is_const, op);\n      tv_clear(&rettv);\n    }\n  }\n}\n\n/// Assign the typevalue \"tv\" to the variable or variables at \"arg_start\".\n/// Handles both \"var\" with any type and \"[var, var; var]\" with a list type.\n/// When \"op\" is not NULL it points to a string with characters that\n/// must appear after the variable(s).  Use \"+\", \"-\" or \".\" for add, subtract\n/// or concatenate.\n///\n/// @param copy  copy values from \"tv\", don't move\n/// @param semicolon  from skip_var_list()\n/// @param var_count  from skip_var_list()\n/// @param is_const  lock variables for :const\n///\n/// @return  OK or FAIL;\nstatic int ex_let_vars(char_u *arg_start, typval_T *tv, int copy, int semicolon, int var_count,\n                       int is_const, char_u *op)\n{\n  char_u *arg = arg_start;\n  typval_T ltv;\n\n  if (*arg != '[') {\n    /*\n     * \":let var = expr\" or \":for var in list\"\n     */\n    if (ex_let_one(arg, tv, copy, is_const, op, op) == NULL) {\n      return FAIL;\n    }\n    return OK;\n  }\n\n  // \":let [v1, v2] = list\" or \":for [v1, v2] in listlist\"\n  if (tv->v_type != VAR_LIST) {\n    EMSG(_(e_listreq));\n    return FAIL;\n  }\n  list_T *const l = tv->vval.v_list;\n\n  const int len = tv_list_len(l);\n  if (semicolon == 0 && var_count < len) {\n    EMSG(_(\"E687: Less targets than List items\"));\n    return FAIL;\n  }\n  if (var_count - semicolon > len) {\n    EMSG(_(\"E688: More targets than List items\"));\n    return FAIL;\n  }\n  // List l may actually be NULL, but it should fail with E688 or even earlier\n  // if you try to do \":let [] = v:_null_list\".\n  assert(l != NULL);\n\n  listitem_T *item = tv_list_first(l);\n  size_t rest_len = tv_list_len(l);\n  while (*arg != ']') {\n    arg = skipwhite(arg + 1);\n    arg = ex_let_one(arg, TV_LIST_ITEM_TV(item), true, is_const,\n                     (const char_u *)\",;]\", op);\n    if (arg == NULL) {\n      return FAIL;\n    }\n    rest_len--;\n\n    item = TV_LIST_ITEM_NEXT(l, item);\n    arg = skipwhite(arg);\n    if (*arg == ';') {\n      /* Put the rest of the list (may be empty) in the var after ';'.\n       * Create a new list for this. */\n      list_T *const rest_list = tv_list_alloc(rest_len);\n      while (item != NULL) {\n        tv_list_append_tv(rest_list, TV_LIST_ITEM_TV(item));\n        item = TV_LIST_ITEM_NEXT(l, item);\n      }\n\n      ltv.v_type = VAR_LIST;\n      ltv.v_lock = VAR_UNLOCKED;\n      ltv.vval.v_list = rest_list;\n      tv_list_ref(rest_list);\n\n      arg = ex_let_one(skipwhite(arg + 1), &ltv, false, is_const, (char_u *)\"]\",\n                       op);\n      tv_clear(&ltv);\n      if (arg == NULL) {\n        return FAIL;\n      }\n      break;\n    } else if (*arg != ',' && *arg != ']') {\n      internal_error(\"ex_let_vars()\");\n      return FAIL;\n    }\n  }\n\n  return OK;\n}\n\n/*\n * Skip over assignable variable \"var\" or list of variables \"[var, var]\".\n * Used for \":let varvar = expr\" and \":for varvar in expr\".\n * For \"[var, var]\" increment \"*var_count\" for each variable.\n * for \"[var, var; var]\" set \"semicolon\".\n * Return NULL for an error.\n */\nstatic const char_u *skip_var_list(const char_u *arg, int *var_count, int *semicolon)\n{\n  const char_u *p;\n  const char_u *s;\n\n  if (*arg == '[') {\n    // \"[var, var]\": find the matching ']'.\n    p = arg;\n    for (;; ) {\n      p = skipwhite(p + 1);             // skip whites after '[', ';' or ','\n      s = skip_var_one(p);\n      if (s == p) {\n        EMSG2(_(e_invarg2), p);\n        return NULL;\n      }\n      ++*var_count;\n\n      p = skipwhite(s);\n      if (*p == ']') {\n        break;\n      } else if (*p == ';') {\n        if (*semicolon == 1) {\n          EMSG(_(\"E452: Double ; in list of variables\"));\n          return NULL;\n        }\n        *semicolon = 1;\n      } else if (*p != ',') {\n        EMSG2(_(e_invarg2), p);\n        return NULL;\n      }\n    }\n    return p + 1;\n  } else {\n    return skip_var_one(arg);\n  }\n}\n\n/*\n * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,\n * l[idx].\n */\nstatic const char_u *skip_var_one(const char_u *arg)\n{\n  if (*arg == '@' && arg[1] != NUL) {\n    return arg + 2;\n  }\n  return find_name_end(*arg == '$' || *arg == '&' ? arg + 1 : arg,\n                       NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);\n}\n\n/*\n * List variables for hashtab \"ht\" with prefix \"prefix\".\n * If \"empty\" is TRUE also list NULL strings as empty strings.\n */\nvoid list_hashtable_vars(hashtab_T *ht, const char *prefix, int empty, int *first)\n{\n  hashitem_T *hi;\n  dictitem_T *di;\n  int todo;\n\n  todo = (int)ht->ht_used;\n  for (hi = ht->ht_array; todo > 0 && !got_int; ++hi) {\n    if (!HASHITEM_EMPTY(hi)) {\n      todo--;\n      di = TV_DICT_HI2DI(hi);\n      char buf[IOSIZE];\n\n      // apply :filter /pat/ to variable name\n      xstrlcpy(buf, prefix, IOSIZE);\n      xstrlcat(buf, (char *)di->di_key, IOSIZE);\n      if (message_filtered((char_u *)buf)) {\n        continue;\n      }\n\n      if (empty || di->di_tv.v_type != VAR_STRING\n          || di->di_tv.vval.v_string != NULL) {\n        list_one_var(di, prefix, first);\n      }\n    }\n  }\n}\n\n/*\n * List global variables.\n */\nstatic void list_glob_vars(int *first)\n{\n  list_hashtable_vars(&globvarht, \"\", true, first);\n}\n\n/*\n * List buffer variables.\n */\nstatic void list_buf_vars(int *first)\n{\n  list_hashtable_vars(&curbuf->b_vars->dv_hashtab, \"b:\", true, first);\n}\n\n/*\n * List window variables.\n */\nstatic void list_win_vars(int *first)\n{\n  list_hashtable_vars(&curwin->w_vars->dv_hashtab, \"w:\", true, first);\n}\n\n/*\n * List tab page variables.\n */\nstatic void list_tab_vars(int *first)\n{\n  list_hashtable_vars(&curtab->tp_vars->dv_hashtab, \"t:\", true, first);\n}\n\n/*\n * List Vim variables.\n */\nstatic void list_vim_vars(int *first)\n{\n  list_hashtable_vars(&vimvarht, \"v:\", false, first);\n}\n\n// List script-local variables, if there is a script.\nstatic void list_script_vars(int *first)\n{\n  if (current_sctx.sc_sid > 0 && current_sctx.sc_sid <= ga_scripts.ga_len) {\n    list_hashtable_vars(&SCRIPT_VARS(current_sctx.sc_sid), \"s:\", false, first);\n  }\n}\n\n/*\n * List variables in \"arg\".\n */\nstatic const char *list_arg_vars(exarg_T *eap, const char *arg, int *first)\n{\n  int error = FALSE;\n  int len;\n  const char *name;\n  const char *name_start;\n  typval_T tv;\n\n  while (!ends_excmd(*arg) && !got_int) {\n    if (error || eap->skip) {\n      arg = (const char *)find_name_end((char_u *)arg, NULL, NULL,\n                                        FNE_INCL_BR | FNE_CHECK_START);\n      if (!ascii_iswhite(*arg) && !ends_excmd(*arg)) {\n        emsg_severe = true;\n        EMSG(_(e_trailing));\n        break;\n      }\n    } else {\n      // get_name_len() takes care of expanding curly braces\n      name_start = name = arg;\n      char *tofree;\n      len = get_name_len(&arg, &tofree, true, true);\n      if (len <= 0) {\n        /* This is mainly to keep test 49 working: when expanding\n         * curly braces fails overrule the exception error message. */\n        if (len < 0 && !aborting()) {\n          emsg_severe = true;\n          EMSG2(_(e_invarg2), arg);\n          break;\n        }\n        error = TRUE;\n      } else {\n        if (tofree != NULL) {\n          name = tofree;\n        }\n        if (get_var_tv((const char *)name, len, &tv, NULL, true, false)\n            == FAIL) {\n          error = true;\n        } else {\n          // handle d.key, l[idx], f(expr)\n          const char *const arg_subsc = arg;\n          if (handle_subscript(&arg, &tv, true, true, (const char_u *)name,\n                               (const char_u **)&name)\n              == FAIL) {\n            error = true;\n          } else {\n            if (arg == arg_subsc && len == 2 && name[1] == ':') {\n              switch (*name) {\n              case 'g':\n                list_glob_vars(first); break;\n              case 'b':\n                list_buf_vars(first); break;\n              case 'w':\n                list_win_vars(first); break;\n              case 't':\n                list_tab_vars(first); break;\n              case 'v':\n                list_vim_vars(first); break;\n              case 's':\n                list_script_vars(first); break;\n              case 'l':\n                list_func_vars(first); break;\n              default:\n                EMSG2(_(\"E738: Can't list variables for %s\"), name);\n              }\n            } else {\n              char *const s = encode_tv2echo(&tv, NULL);\n              const char *const used_name = (arg == arg_subsc\n                                             ? name\n                                             : name_start);\n              const ptrdiff_t name_size = (used_name == tofree\n                                           ? (ptrdiff_t)strlen(used_name)\n                                           : (arg - used_name));\n              list_one_var_a(\"\", used_name, name_size,\n                             tv.v_type, s == NULL ? \"\" : s, first);\n              xfree(s);\n            }\n            tv_clear(&tv);\n          }\n        }\n      }\n\n      xfree(tofree);\n    }\n\n    arg = (const char *)skipwhite((const char_u *)arg);\n  }\n\n  return arg;\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// Set one item of `:let var = expr` or `:let [v1, v2] = list` to its value\n///\n/// @param[in]  arg  Start of the variable name.\n/// @param[in]  tv  Value to assign to the variable.\n/// @param[in]  copy  If true, copy value from `tv`.\n/// @param[in]  endchars  Valid characters after variable name or NULL.\n/// @param[in]  op  Operation performed: *op is `+`, `-`, `.` for `+=`, etc.\n///                 NULL for `=`.\n///\n/// @return a pointer to the char just after the var name or NULL in case of\n///         error.\nstatic char_u *ex_let_one(char_u *arg, typval_T *const tv, const bool copy, const bool is_const,\n                          const char_u *const endchars, const char_u *const op)\n  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  char_u *arg_end = NULL;\n  int len;\n  int opt_flags;\n  char_u *tofree = NULL;\n\n  /*\n   * \":let $VAR = expr\": Set environment variable.\n   */\n  if (*arg == '$') {\n    if (is_const) {\n      EMSG(_(\"E996: Cannot lock an environment variable\"));\n      return NULL;\n    }\n    // Find the end of the name.\n    arg++;\n    char *name = (char *)arg;\n    len = get_env_len((const char_u **)&arg);\n    if (len == 0) {\n      EMSG2(_(e_invarg2), name - 1);\n    } else {\n      if (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL) {\n        EMSG2(_(e_letwrong), op);\n      } else if (endchars != NULL\n                 && vim_strchr(endchars, *skipwhite(arg)) == NULL) {\n        EMSG(_(e_letunexp));\n      } else if (!check_secure()) {\n        const char c1 = name[len];\n        name[len] = NUL;\n        const char *p = tv_get_string_chk(tv);\n        if (p != NULL && op != NULL && *op == '.') {\n          char *s = vim_getenv(name);\n\n          if (s != NULL) {\n            tofree = concat_str((const char_u *)s, (const char_u *)p);\n            p = (const char *)tofree;\n            xfree(s);\n          }\n        }\n        if (p != NULL) {\n          os_setenv(name, p, 1);\n          if (STRICMP(name, \"HOME\") == 0) {\n            init_homedir();\n          } else if (didset_vim && STRICMP(name, \"VIM\") == 0) {\n            didset_vim = false;\n          } else if (didset_vimruntime\n                     && STRICMP(name, \"VIMRUNTIME\") == 0) {\n            didset_vimruntime = false;\n          }\n          arg_end = arg;\n        }\n        name[len] = c1;\n        xfree(tofree);\n      }\n    }\n    // \":let &option = expr\": Set option value.\n    // \":let &l:option = expr\": Set local option value.\n    // \":let &g:option = expr\": Set global option value.\n  } else if (*arg == '&') {\n    if (is_const) {\n      EMSG(_(\"E996: Cannot lock an option\"));\n      return NULL;\n    }\n    // Find the end of the name.\n    char *const p = (char *)find_option_end((const char **)&arg, &opt_flags);\n    if (p == NULL\n        || (endchars != NULL\n            && vim_strchr(endchars, *skipwhite((const char_u *)p)) == NULL)) {\n      EMSG(_(e_letunexp));\n    } else {\n      int opt_type;\n      long numval;\n      char *stringval = NULL;\n      const char *s = NULL;\n\n      const char c1 = *p;\n      *p = NUL;\n\n      varnumber_T n = tv_get_number(tv);\n      if (tv->v_type != VAR_BOOL && tv->v_type != VAR_SPECIAL) {\n        s = tv_get_string_chk(tv);  // != NULL if number or string.\n      }\n      if (s != NULL && op != NULL && *op != '=') {\n        opt_type = get_option_value((char *)arg, &numval, (char_u **)&stringval,\n                                    opt_flags);\n        if ((opt_type == 1 && *op == '.')\n            || (opt_type == 0 && *op != '.')) {\n          EMSG2(_(e_letwrong), op);\n          s = NULL;  // don't set the value\n        } else {\n          if (opt_type == 1) {  // number\n            switch (*op) {\n            case '+':\n              n = numval + n; break;\n            case '-':\n              n = numval - n; break;\n            case '*':\n              n = numval * n; break;\n            case '/':\n              n = num_divide(numval, n); break;\n            case '%':\n              n = num_modulus(numval, n); break;\n            }\n          } else if (opt_type == 0 && stringval != NULL) {  // string\n            char *const oldstringval = stringval;\n            stringval = (char *)concat_str((const char_u *)stringval,\n                                           (const char_u *)s);\n            xfree(oldstringval);\n            s = stringval;\n          }\n        }\n      }\n      if (s != NULL || tv->v_type == VAR_BOOL\n          || tv->v_type == VAR_SPECIAL) {\n        set_option_value((const char *)arg, n, s, opt_flags);\n        arg_end = (char_u *)p;\n      }\n      *p = c1;\n      xfree(stringval);\n    }\n    // \":let @r = expr\": Set register contents.\n  } else if (*arg == '@') {\n    if (is_const) {\n      EMSG(_(\"E996: Cannot lock a register\"));\n      return NULL;\n    }\n    arg++;\n    if (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL) {\n      emsgf(_(e_letwrong), op);\n    } else if (endchars != NULL\n               && vim_strchr(endchars, *skipwhite(arg + 1)) == NULL) {\n      EMSG(_(e_letunexp));\n    } else {\n      char_u *s;\n\n      char_u *ptofree = NULL;\n      const char *p = tv_get_string_chk(tv);\n      if (p != NULL && op != NULL && *op == '.') {\n        s = get_reg_contents(*arg == '@' ? '\"' : *arg, kGRegExprSrc);\n        if (s != NULL) {\n          ptofree = concat_str(s, (const char_u *)p);\n          p = (const char *)ptofree;\n          xfree(s);\n        }\n      }\n      if (p != NULL) {\n        write_reg_contents(*arg == '@' ? '\"' : *arg,\n                           (const char_u *)p, STRLEN(p), false);\n        arg_end = arg + 1;\n      }\n      xfree(ptofree);\n    }\n  }\n  /*\n   * \":let var = expr\": Set internal variable.\n   * \":let {expr} = expr\": Idem, name made with curly braces\n   */\n  else if (eval_isnamec1(*arg) || *arg == '{') {\n    lval_T lv;\n\n    char_u *const p = get_lval(arg, tv, &lv, false, false, 0, FNE_CHECK_START);\n    if (p != NULL && lv.ll_name != NULL) {\n      if (endchars != NULL && vim_strchr(endchars, *skipwhite(p)) == NULL) {\n        EMSG(_(e_letunexp));\n      } else {\n        set_var_lval(&lv, p, tv, copy, is_const, (const char *)op);\n        arg_end = p;\n      }\n    }\n    clear_lval(&lv);\n  } else {\n    EMSG2(_(e_invarg2), arg);\n  }\n\n  return arg_end;\n}\n\n// TODO(ZyX-I): move to eval/executor\n\n/// Get an lvalue\n///\n/// Lvalue may be\n/// - variable: \"name\", \"na{me}\"\n/// - dictionary item: \"dict.key\", \"dict['key']\"\n/// - list item: \"list[expr]\"\n/// - list slice: \"list[expr:expr]\"\n///\n/// Indexing only works if trying to use it with an existing List or Dictionary.\n///\n/// @param[in]  name  Name to parse.\n/// @param  rettv  Pointer to the value to be assigned or NULL.\n/// @param[out]  lp  Lvalue definition. When evaluation errors occur `->ll_name`\n///                  is NULL.\n/// @param[in]  unlet  True if using `:unlet`. This results in slightly\n///                    different behaviour when something is wrong; must end in\n///                    space or cmd separator.\n/// @param[in]  skip  True when skipping.\n/// @param[in]  flags  @see GetLvalFlags.\n/// @param[in]  fne_flags  Flags for find_name_end().\n///\n/// @return A pointer to just after the name, including indexes. Returns NULL\n///         for a parsing error, but it is still needed to free items in lp.\nchar_u *get_lval(char_u *const name, typval_T *const rettv, lval_T *const lp, const bool unlet,\n                 const bool skip, const int flags, const int fne_flags)\n  FUNC_ATTR_NONNULL_ARG(1, 3)\n{\n  dictitem_T *v;\n  typval_T var1;\n  typval_T var2;\n  int empty1 = FALSE;\n  listitem_T *ni;\n  hashtab_T *ht = NULL;\n  int quiet = flags & GLV_QUIET;\n\n  // Clear everything in \"lp\".\n  memset(lp, 0, sizeof(lval_T));\n\n  if (skip) {\n    // When skipping just find the end of the name.\n    lp->ll_name = (const char *)name;\n    return (char_u *)find_name_end((const char_u *)name, NULL, NULL,\n                                   FNE_INCL_BR | fne_flags);\n  }\n\n  // Find the end of the name.\n  char_u *expr_start;\n  char_u *expr_end;\n  char_u *p = (char_u *)find_name_end(name,\n                                      (const char_u **)&expr_start,\n                                      (const char_u **)&expr_end,\n                                      fne_flags);\n  if (expr_start != NULL) {\n    // Don't expand the name when we already know there is an error.\n    if (unlet && !ascii_iswhite(*p) && !ends_excmd(*p)\n        && *p != '[' && *p != '.') {\n      EMSG(_(e_trailing));\n      return NULL;\n    }\n\n    lp->ll_exp_name = (char *)make_expanded_name(name, expr_start, expr_end,\n                                                 (char_u *)p);\n    lp->ll_name = lp->ll_exp_name;\n    if (lp->ll_exp_name == NULL) {\n      /* Report an invalid expression in braces, unless the\n       * expression evaluation has been cancelled due to an\n       * aborting error, an interrupt, or an exception. */\n      if (!aborting() && !quiet) {\n        emsg_severe = true;\n        EMSG2(_(e_invarg2), name);\n        return NULL;\n      }\n      lp->ll_name_len = 0;\n    } else {\n      lp->ll_name_len = strlen(lp->ll_name);\n    }\n  } else {\n    lp->ll_name = (const char *)name;\n    lp->ll_name_len = (size_t)((const char *)p - lp->ll_name);\n  }\n\n  // Without [idx] or .key we are done.\n  if ((*p != '[' && *p != '.') || lp->ll_name == NULL) {\n    return p;\n  }\n\n  // Only pass &ht when we would write to the variable, it prevents autoload\n  // as well.\n  v = find_var(lp->ll_name, lp->ll_name_len,\n               (flags & GLV_READ_ONLY) ? NULL : &ht,\n               flags & GLV_NO_AUTOLOAD);\n  if (v == NULL && !quiet) {\n    emsgf(_(\"E121: Undefined variable: %.*s\"),\n          (int)lp->ll_name_len, lp->ll_name);\n  }\n  if (v == NULL) {\n    return NULL;\n  }\n\n  // Loop until no more [idx] or .key is following.\n  lp->ll_tv = &v->di_tv;\n  var1.v_type = VAR_UNKNOWN;\n  var2.v_type = VAR_UNKNOWN;\n  while (*p == '[' || (*p == '.' && lp->ll_tv->v_type == VAR_DICT)) {\n    if (!(lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list != NULL)\n        && !(lp->ll_tv->v_type == VAR_DICT && lp->ll_tv->vval.v_dict != NULL)\n        && !(lp->ll_tv->v_type == VAR_BLOB && lp->ll_tv->vval.v_blob != NULL)) {\n      if (!quiet) {\n        EMSG(_(\"E689: Can only index a List, Dictionary or Blob\"));\n      }\n      return NULL;\n    }\n    if (lp->ll_range) {\n      if (!quiet) {\n        EMSG(_(\"E708: [:] must come last\"));\n      }\n      return NULL;\n    }\n\n    int len = -1;\n    char_u *key = NULL;\n    if (*p == '.') {\n      key = p + 1;\n      for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; len++) {\n      }\n      if (len == 0) {\n        if (!quiet) {\n          EMSG(_(\"E713: Cannot use empty key after .\"));\n        }\n        return NULL;\n      }\n      p = key + len;\n    } else {\n      // Get the index [expr] or the first index [expr: ].\n      p = skipwhite(p + 1);\n      if (*p == ':') {\n        empty1 = true;\n      } else {\n        empty1 = false;\n        if (eval1(&p, &var1, true) == FAIL) {  // Recursive!\n          return NULL;\n        }\n        if (!tv_check_str(&var1)) {\n          // Not a number or string.\n          tv_clear(&var1);\n          return NULL;\n        }\n        p = skipwhite(p);\n      }\n\n      // Optionally get the second index [ :expr].\n      if (*p == ':') {\n        if (lp->ll_tv->v_type == VAR_DICT) {\n          if (!quiet) {\n            EMSG(_(e_dictrange));\n          }\n          tv_clear(&var1);\n          return NULL;\n        }\n        if (rettv != NULL\n            && !(rettv->v_type == VAR_LIST && rettv->vval.v_list != NULL)\n            && !(rettv->v_type == VAR_BLOB && rettv->vval.v_blob != NULL)) {\n          if (!quiet) {\n            EMSG(_(\"E709: [:] requires a List or Blob value\"));\n          }\n          tv_clear(&var1);\n          return NULL;\n        }\n        p = skipwhite(p + 1);\n        if (*p == ']') {\n          lp->ll_empty2 = true;\n        } else {\n          lp->ll_empty2 = false;\n          if (eval1(&p, &var2, true) == FAIL) {  // Recursive!\n            tv_clear(&var1);\n            return NULL;\n          }\n          if (!tv_check_str(&var2)) {\n            // Not a number or string.\n            tv_clear(&var1);\n            tv_clear(&var2);\n            return NULL;\n          }\n        }\n        lp->ll_range = true;\n      } else {\n        lp->ll_range = false;\n      }\n\n      if (*p != ']') {\n        if (!quiet) {\n          EMSG(_(e_missbrac));\n        }\n        tv_clear(&var1);\n        tv_clear(&var2);\n        return NULL;\n      }\n\n      // Skip to past ']'.\n      p++;\n    }\n\n    if (lp->ll_tv->v_type == VAR_DICT) {\n      if (len == -1) {\n        // \"[key]\": get key from \"var1\"\n        key = (char_u *)tv_get_string(&var1);  // is number or string\n      }\n      lp->ll_list = NULL;\n      lp->ll_dict = lp->ll_tv->vval.v_dict;\n      lp->ll_di = tv_dict_find(lp->ll_dict, (const char *)key, len);\n\n      /* When assigning to a scope dictionary check that a function and\n       * variable name is valid (only variable name unless it is l: or\n       * g: dictionary). Disallow overwriting a builtin function. */\n      if (rettv != NULL && lp->ll_dict->dv_scope != 0) {\n        int prevval;\n        int wrong;\n\n        if (len != -1) {\n          prevval = key[len];\n          key[len] = NUL;\n        } else {\n          prevval = 0;  // Avoid compiler warning.\n        }\n        wrong = ((lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n                  && tv_is_func(*rettv)\n                  && !var_check_func_name((const char *)key, lp->ll_di == NULL))\n                 || !valid_varname((const char *)key));\n        if (len != -1) {\n          key[len] = prevval;\n        }\n        if (wrong) {\n          return NULL;\n        }\n      }\n\n      if (lp->ll_di != NULL && tv_is_luafunc(&lp->ll_di->di_tv)\n          && len == -1 && rettv == NULL) {\n        tv_clear(&var1);\n        EMSG2(e_illvar, \"v:['lua']\");\n        return NULL;\n      }\n\n      if (lp->ll_di == NULL) {\n        // Can't add \"v:\" or \"a:\" variable.\n        if (lp->ll_dict == &vimvardict\n            || &lp->ll_dict->dv_hashtab == get_funccal_args_ht()) {\n          EMSG2(_(e_illvar), name);\n          tv_clear(&var1);\n          return NULL;\n        }\n\n        // Key does not exist in dict: may need to add it.\n        if (*p == '[' || *p == '.' || unlet) {\n          if (!quiet) {\n            emsgf(_(e_dictkey), key);\n          }\n          tv_clear(&var1);\n          return NULL;\n        }\n        if (len == -1) {\n          lp->ll_newkey = vim_strsave(key);\n        } else {\n          lp->ll_newkey = vim_strnsave(key, len);\n        }\n        tv_clear(&var1);\n        break;\n        // existing variable, need to check if it can be changed\n      } else if (!(flags & GLV_READ_ONLY) && var_check_ro(lp->ll_di->di_flags,\n                                                          (const char *)name,\n                                                          (size_t)(p - name))) {\n        tv_clear(&var1);\n        return NULL;\n      }\n\n      tv_clear(&var1);\n      lp->ll_tv = &lp->ll_di->di_tv;\n    } else if (lp->ll_tv->v_type == VAR_BLOB) {\n      // Get the number and item for the only or first index of the List.\n      if (empty1) {\n        lp->ll_n1 = 0;\n      } else {\n        // Is number or string.\n        lp->ll_n1 = (long)tv_get_number(&var1);\n      }\n      tv_clear(&var1);\n\n      const int bloblen = tv_blob_len(lp->ll_tv->vval.v_blob);\n      if (lp->ll_n1 < 0 || lp->ll_n1 > bloblen\n          || (lp->ll_range && lp->ll_n1 == bloblen)) {\n        if (!quiet) {\n          EMSGN(_(e_blobidx), lp->ll_n1);\n        }\n        tv_clear(&var2);\n        return NULL;\n      }\n      if (lp->ll_range && !lp->ll_empty2) {\n        lp->ll_n2 = (long)tv_get_number(&var2);\n        tv_clear(&var2);\n        if (lp->ll_n2 < 0 || lp->ll_n2 >= bloblen || lp->ll_n2 < lp->ll_n1) {\n          if (!quiet) {\n            EMSGN(_(e_blobidx), lp->ll_n2);\n          }\n          return NULL;\n        }\n      }\n      lp->ll_blob = lp->ll_tv->vval.v_blob;\n      lp->ll_tv = NULL;\n      break;\n    } else {\n      // Get the number and item for the only or first index of the List.\n      if (empty1) {\n        lp->ll_n1 = 0;\n      } else {\n        // Is number or string.\n        lp->ll_n1 = (long)tv_get_number(&var1);\n      }\n      tv_clear(&var1);\n\n      lp->ll_dict = NULL;\n      lp->ll_list = lp->ll_tv->vval.v_list;\n      lp->ll_li = tv_list_find(lp->ll_list, lp->ll_n1);\n      if (lp->ll_li == NULL) {\n        if (lp->ll_n1 < 0) {\n          lp->ll_n1 = 0;\n          lp->ll_li = tv_list_find(lp->ll_list, lp->ll_n1);\n        }\n      }\n      if (lp->ll_li == NULL) {\n        tv_clear(&var2);\n        if (!quiet) {\n          EMSGN(_(e_listidx), lp->ll_n1);\n        }\n        return NULL;\n      }\n\n      // May need to find the item or absolute index for the second\n      // index of a range.\n      // When no index given: \"lp->ll_empty2\" is true.\n      // Otherwise \"lp->ll_n2\" is set to the second index.\n      if (lp->ll_range && !lp->ll_empty2) {\n        lp->ll_n2 = (long)tv_get_number(&var2);  // Is number or string.\n        tv_clear(&var2);\n        if (lp->ll_n2 < 0) {\n          ni = tv_list_find(lp->ll_list, lp->ll_n2);\n          if (ni == NULL) {\n            if (!quiet) {\n              EMSGN(_(e_listidx), lp->ll_n2);\n            }\n            return NULL;\n          }\n          lp->ll_n2 = tv_list_idx_of_item(lp->ll_list, ni);\n        }\n\n        // Check that lp->ll_n2 isn't before lp->ll_n1.\n        if (lp->ll_n1 < 0) {\n          lp->ll_n1 = tv_list_idx_of_item(lp->ll_list, lp->ll_li);\n        }\n        if (lp->ll_n2 < lp->ll_n1) {\n          if (!quiet) {\n            EMSGN(_(e_listidx), lp->ll_n2);\n          }\n          return NULL;\n        }\n      }\n\n      lp->ll_tv = TV_LIST_ITEM_TV(lp->ll_li);\n    }\n  }\n\n  tv_clear(&var1);\n  return p;\n}\n\n// TODO(ZyX-I): move to eval/executor\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\nvoid clear_lval(lval_T *lp)\n{\n  xfree(lp->ll_exp_name);\n  xfree(lp->ll_newkey);\n}\n\n// TODO(ZyX-I): move to eval/executor\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\nstatic void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, const bool is_const,\n                         const char *op)\n{\n  int cc;\n  listitem_T *ri;\n  dictitem_T *di;\n\n  if (lp->ll_tv == NULL) {\n    cc = *endp;\n    *endp = NUL;\n    if (lp->ll_blob != NULL) {\n      if (op != NULL && *op != '=') {\n        EMSG2(_(e_letwrong), op);\n        return;\n      }\n      if (var_check_lock(lp->ll_blob->bv_lock, lp->ll_name, TV_CSTRING)) {\n        return;\n      }\n\n      if (lp->ll_range && rettv->v_type == VAR_BLOB) {\n        if (lp->ll_empty2) {\n          lp->ll_n2 = tv_blob_len(lp->ll_blob) - 1;\n        }\n\n        if (lp->ll_n2 - lp->ll_n1 + 1 != tv_blob_len(rettv->vval.v_blob)) {\n          EMSG(_(\"E972: Blob value does not have the right number of bytes\"));\n          return;\n        }\n        if (lp->ll_empty2) {\n          lp->ll_n2 = tv_blob_len(lp->ll_blob);\n        }\n\n        for (int il = lp->ll_n1, ir = 0; il <= lp->ll_n2; il++) {\n          tv_blob_set(lp->ll_blob, il, tv_blob_get(rettv->vval.v_blob, ir++));\n        }\n      } else {\n        bool error = false;\n        const char_u val = tv_get_number_chk(rettv, &error);\n        if (!error) {\n          garray_T *const gap = &lp->ll_blob->bv_ga;\n\n          // Allow for appending a byte.  Setting a byte beyond\n          // the end is an error otherwise.\n          if (lp->ll_n1 < gap->ga_len || lp->ll_n1 == gap->ga_len) {\n            ga_grow(&lp->ll_blob->bv_ga, 1);\n            tv_blob_set(lp->ll_blob, lp->ll_n1, val);\n            if (lp->ll_n1 == gap->ga_len) {\n              gap->ga_len++;\n            }\n          }\n          // error for invalid range was already given in get_lval()\n        }\n      }\n    } else if (op != NULL && *op != '=') {\n      typval_T tv;\n\n      if (is_const) {\n        EMSG(_(e_cannot_mod));\n        *endp = cc;\n        return;\n      }\n\n      // handle +=, -=, *=, /=, %= and .=\n      di = NULL;\n      if (get_var_tv((const char *)lp->ll_name, (int)STRLEN(lp->ll_name),\n                     &tv, &di, true, false) == OK) {\n        if ((di == NULL\n             || (!var_check_ro(di->di_flags, lp->ll_name, TV_CSTRING)\n                 && !tv_check_lock(&di->di_tv, lp->ll_name, TV_CSTRING)))\n            && eexe_mod_op(&tv, rettv, op) == OK) {\n          set_var(lp->ll_name, lp->ll_name_len, &tv, false);\n        }\n        tv_clear(&tv);\n      }\n    } else {\n      set_var_const(lp->ll_name, lp->ll_name_len, rettv, copy, is_const);\n    }\n    *endp = cc;\n  } else if (var_check_lock(lp->ll_newkey == NULL\n                            ? lp->ll_tv->v_lock\n                            : lp->ll_tv->vval.v_dict->dv_lock,\n                            lp->ll_name, TV_CSTRING)) {\n  } else if (lp->ll_range) {\n    listitem_T *ll_li = lp->ll_li;\n    int ll_n1 = lp->ll_n1;\n\n    if (is_const) {\n      EMSG(_(\"E996: Cannot lock a range\"));\n      return;\n    }\n\n    // Check whether any of the list items is locked\n    for (ri = tv_list_first(rettv->vval.v_list);\n         ri != NULL && ll_li != NULL; ) {\n      if (var_check_lock(TV_LIST_ITEM_TV(ll_li)->v_lock, lp->ll_name,\n                         TV_CSTRING)) {\n        return;\n      }\n      ri = TV_LIST_ITEM_NEXT(rettv->vval.v_list, ri);\n      if (ri == NULL || (!lp->ll_empty2 && lp->ll_n2 == ll_n1)) {\n        break;\n      }\n      ll_li = TV_LIST_ITEM_NEXT(lp->ll_list, ll_li);\n      ll_n1++;\n    }\n\n    /*\n     * Assign the List values to the list items.\n     */\n    for (ri = tv_list_first(rettv->vval.v_list); ri != NULL; ) {\n      if (op != NULL && *op != '=') {\n        eexe_mod_op(TV_LIST_ITEM_TV(lp->ll_li), TV_LIST_ITEM_TV(ri), op);\n      } else {\n        tv_clear(TV_LIST_ITEM_TV(lp->ll_li));\n        tv_copy(TV_LIST_ITEM_TV(ri), TV_LIST_ITEM_TV(lp->ll_li));\n      }\n      ri = TV_LIST_ITEM_NEXT(rettv->vval.v_list, ri);\n      if (ri == NULL || (!lp->ll_empty2 && lp->ll_n2 == lp->ll_n1)) {\n        break;\n      }\n      assert(lp->ll_li != NULL);\n      if (TV_LIST_ITEM_NEXT(lp->ll_list, lp->ll_li) == NULL) {\n        // Need to add an empty item.\n        tv_list_append_number(lp->ll_list, 0);\n        // ll_li may have become invalid after append, don\u2019t use it.\n        lp->ll_li = tv_list_last(lp->ll_list);  // Valid again.\n      } else {\n        lp->ll_li = TV_LIST_ITEM_NEXT(lp->ll_list, lp->ll_li);\n      }\n      lp->ll_n1++;\n    }\n    if (ri != NULL) {\n      EMSG(_(\"E710: List value has more items than target\"));\n    } else if (lp->ll_empty2\n               ? (lp->ll_li != NULL\n                  && TV_LIST_ITEM_NEXT(lp->ll_list, lp->ll_li) != NULL)\n               : lp->ll_n1 != lp->ll_n2) {\n      EMSG(_(\"E711: List value has not enough items\"));\n    }\n  } else {\n    typval_T oldtv = TV_INITIAL_VALUE;\n    dict_T *dict = lp->ll_dict;\n    bool watched = tv_dict_is_watched(dict);\n\n    if (is_const) {\n      EMSG(_(\"E996: Cannot lock a list or dict\"));\n      return;\n    }\n\n    // Assign to a List or Dictionary item.\n    if (lp->ll_newkey != NULL) {\n      if (op != NULL && *op != '=') {\n        EMSG2(_(e_letwrong), op);\n        return;\n      }\n\n      // Need to add an item to the Dictionary.\n      di = tv_dict_item_alloc((const char *)lp->ll_newkey);\n      if (tv_dict_add(lp->ll_tv->vval.v_dict, di) == FAIL) {\n        xfree(di);\n        return;\n      }\n      lp->ll_tv = &di->di_tv;\n    } else {\n      if (watched) {\n        tv_copy(lp->ll_tv, &oldtv);\n      }\n\n      if (op != NULL && *op != '=') {\n        eexe_mod_op(lp->ll_tv, rettv, op);\n        goto notify;\n      } else {\n        tv_clear(lp->ll_tv);\n      }\n    }\n\n    // Assign the value to the variable or list item.\n    if (copy) {\n      tv_copy(rettv, lp->ll_tv);\n    } else {\n      *lp->ll_tv = *rettv;\n      lp->ll_tv->v_lock = VAR_UNLOCKED;\n      tv_init(rettv);\n    }\n\nnotify:\n    if (watched) {\n      if (oldtv.v_type == VAR_UNKNOWN) {\n        assert(lp->ll_newkey != NULL);\n        tv_dict_watcher_notify(dict, (char *)lp->ll_newkey, lp->ll_tv, NULL);\n      } else {\n        dictitem_T *di_ = lp->ll_di;\n        assert(di_->di_key != NULL);\n        tv_dict_watcher_notify(dict, (char *)di_->di_key, lp->ll_tv, &oldtv);\n        tv_clear(&oldtv);\n      }\n    }\n  }\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\nvoid *eval_for_line(const char_u *arg, bool *errp, char_u **nextcmdp, int skip)\n{\n  forinfo_T *fi = xcalloc(1, sizeof(forinfo_T));\n  const char_u *expr;\n  typval_T tv;\n  list_T *l;\n\n  *errp = true;  // Default: there is an error.\n\n  expr = skip_var_list(arg, &fi->fi_varcount, &fi->fi_semicolon);\n  if (expr == NULL) {\n    return fi;\n  }\n\n  expr = skipwhite(expr);\n  if (expr[0] != 'i' || expr[1] != 'n' || !ascii_iswhite(expr[2])) {\n    EMSG(_(\"E690: Missing \\\"in\\\" after :for\"));\n    return fi;\n  }\n\n  if (skip) {\n    ++emsg_skip;\n  }\n  if (eval0(skipwhite(expr + 2), &tv, nextcmdp, !skip) == OK) {\n    *errp = false;\n    if (!skip) {\n      if (tv.v_type == VAR_LIST) {\n        l = tv.vval.v_list;\n        if (l == NULL) {\n          // a null list is like an empty list: do nothing\n          tv_clear(&tv);\n        } else {\n          // No need to increment the refcount, it's already set for\n          // the list being used in \"tv\".\n          fi->fi_list = l;\n          tv_list_watch_add(l, &fi->fi_lw);\n          fi->fi_lw.lw_item = tv_list_first(l);\n        }\n      } else if (tv.v_type == VAR_BLOB) {\n        fi->fi_bi = 0;\n        if (tv.vval.v_blob != NULL) {\n          typval_T btv;\n\n          // Make a copy, so that the iteration still works when the\n          // blob is changed.\n          tv_blob_copy(&tv, &btv);\n          fi->fi_blob = btv.vval.v_blob;\n        }\n        tv_clear(&tv);\n      } else {\n        EMSG(_(e_listblobreq));\n        tv_clear(&tv);\n      }\n    }\n  }\n  if (skip) {\n    --emsg_skip;\n  }\n\n  return fi;\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\nbool next_for_item(void *fi_void, char_u *arg)\n{\n  forinfo_T *fi = (forinfo_T *)fi_void;\n\n  if (fi->fi_blob != NULL) {\n    if (fi->fi_bi >= tv_blob_len(fi->fi_blob)) {\n      return false;\n    }\n    typval_T tv;\n    tv.v_type = VAR_NUMBER;\n    tv.v_lock = VAR_FIXED;\n    tv.vval.v_number = tv_blob_get(fi->fi_blob, fi->fi_bi);\n    fi->fi_bi++;\n    return ex_let_vars(arg, &tv, true,\n                       fi->fi_semicolon, fi->fi_varcount, false, NULL) == OK;\n  }\n\n  listitem_T *item = fi->fi_lw.lw_item;\n  if (item == NULL) {\n    return false;\n  } else {\n    fi->fi_lw.lw_item = TV_LIST_ITEM_NEXT(fi->fi_list, item);\n    return (ex_let_vars(arg, TV_LIST_ITEM_TV(item), true,\n                        fi->fi_semicolon, fi->fi_varcount, false, NULL) == OK);\n  }\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/*\n * Free the structure used to store info used by \":for\".\n */\nvoid free_for_info(void *fi_void)\n{\n  forinfo_T *fi = (forinfo_T *)fi_void;\n\n  if (fi != NULL && fi->fi_list != NULL) {\n    tv_list_watch_remove(fi->fi_list, &fi->fi_lw);\n    tv_list_unref(fi->fi_list);\n  }\n  if (fi != NULL && fi->fi_blob != NULL) {\n    tv_blob_unref(fi->fi_blob);\n  }\n  xfree(fi);\n}\n\n\nvoid set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int got_eq = FALSE;\n  int c;\n  char_u *p;\n\n  if (cmdidx == CMD_let || cmdidx == CMD_const) {\n    xp->xp_context = EXPAND_USER_VARS;\n    if (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL) {\n      // \":let var1 var2 ...\": find last space.\n      for (p = arg + STRLEN(arg); p >= arg; ) {\n        xp->xp_pattern = p;\n        MB_PTR_BACK(arg, p);\n        if (ascii_iswhite(*p)) {\n          break;\n        }\n      }\n      return;\n    }\n  } else {\n    xp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n                                        : EXPAND_EXPRESSION;\n  }\n  while ((xp->xp_pattern = vim_strpbrk(arg,\n                                       (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL) {\n    c = *xp->xp_pattern;\n    if (c == '&') {\n      c = xp->xp_pattern[1];\n      if (c == '&') {\n        ++xp->xp_pattern;\n        xp->xp_context = cmdidx != CMD_let || got_eq\n                         ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n      } else if (c != ' ') {\n        xp->xp_context = EXPAND_SETTINGS;\n        if ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':') {\n          xp->xp_pattern += 2;\n        }\n      }\n    } else if (c == '$') {\n      // environment variable\n      xp->xp_context = EXPAND_ENV_VARS;\n    } else if (c == '=') {\n      got_eq = TRUE;\n      xp->xp_context = EXPAND_EXPRESSION;\n    } else if (c == '#'\n               && xp->xp_context == EXPAND_EXPRESSION) {\n      // Autoload function/variable contains '#'\n      break;\n    } else if ((c == '<' || c == '#')\n               && xp->xp_context == EXPAND_FUNCTIONS\n               && vim_strchr(xp->xp_pattern, '(') == NULL) {\n      // Function name can start with \"<SNR>\" and contain '#'.\n      break;\n    } else if (cmdidx != CMD_let || got_eq) {\n      if (c == '\"') {               // string\n        while ((c = *++xp->xp_pattern) != NUL && c != '\"') {\n          if (c == '\\\\' && xp->xp_pattern[1] != NUL) {\n            xp->xp_pattern++;\n          }\n        }\n        xp->xp_context = EXPAND_NOTHING;\n      } else if (c == '\\'') {     // literal string\n        // Trick: '' is like stopping and starting a literal string.\n        while ((c = *++xp->xp_pattern) != NUL && c != '\\'') {\n        }\n        xp->xp_context = EXPAND_NOTHING;\n      } else if (c == '|') {\n        if (xp->xp_pattern[1] == '|') {\n          ++xp->xp_pattern;\n          xp->xp_context = EXPAND_EXPRESSION;\n        } else {\n          xp->xp_context = EXPAND_COMMANDS;\n        }\n      } else {\n        xp->xp_context = EXPAND_EXPRESSION;\n      }\n    } else {\n      /* Doesn't look like something valid, expand as an expression\n       * anyway. */\n      xp->xp_context = EXPAND_EXPRESSION;\n    }\n    arg = xp->xp_pattern;\n    if (*arg != NUL) {\n      while ((c = *++arg) != NUL && (c == ' ' || c == '\\t')) {\n      }\n    }\n  }\n\n  // \":exe one two\" completes \"two\"\n  if ((cmdidx == CMD_execute\n       || cmdidx == CMD_echo\n       || cmdidx == CMD_echon\n       || cmdidx == CMD_echomsg)\n      && xp->xp_context == EXPAND_EXPRESSION) {\n    for (;;) {\n      char_u *const n = skiptowhite(arg);\n\n      if (n == arg || ascii_iswhite_or_nul(*skipwhite(n))) {\n        break;\n      }\n      arg = skipwhite(n);\n    }\n  }\n\n  xp->xp_pattern = arg;\n}\n\n/// \":unlet[!] var1 ... \" command.\nvoid ex_unlet(exarg_T *eap)\n{\n  ex_unletlock(eap, eap->arg, 0, do_unlet_var);\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// \":lockvar\" and \":unlockvar\" commands\nvoid ex_lockvar(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  int deep = 2;\n\n  if (eap->forceit) {\n    deep = -1;\n  } else if (ascii_isdigit(*arg)) {\n    deep = getdigits_int(&arg, false, -1);\n    arg = skipwhite(arg);\n  }\n\n  ex_unletlock(eap, arg, deep, do_lock_var);\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// Common parsing logic for :unlet, :lockvar and :unlockvar.\n///\n/// Invokes `callback` afterwards if successful and `eap->skip == false`.\n///\n/// @param[in]  eap  Ex command arguments for the command.\n/// @param[in]  argstart  Start of the string argument for the command.\n/// @param[in]  deep  Levels to (un)lock for :(un)lockvar, -1 to (un)lock\n///                   everything.\n/// @param[in]  callback  Appropriate handler for the command.\nstatic void ex_unletlock(exarg_T *eap, char_u *argstart, int deep, ex_unletlock_callback callback)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *arg = argstart;\n  char_u *name_end;\n  bool error = false;\n  lval_T lv;\n\n  do {\n    if (*arg == '$') {\n      lv.ll_name = (const char *)arg;\n      lv.ll_tv = NULL;\n      arg++;\n      if (get_env_len((const char_u **)&arg) == 0) {\n        EMSG2(_(e_invarg2), arg - 1);\n        return;\n      }\n      if (!error && !eap->skip && callback(&lv, arg, eap, deep) == FAIL) {\n        error = true;\n      }\n      name_end = arg;\n    } else {\n      // Parse the name and find the end.\n      name_end = get_lval(arg, NULL, &lv, true, eap->skip || error,\n                          0, FNE_CHECK_START);\n      if (lv.ll_name == NULL) {\n        error = true;  // error, but continue parsing.\n      }\n      if (name_end == NULL\n          || (!ascii_iswhite(*name_end) && !ends_excmd(*name_end))) {\n        if (name_end != NULL) {\n          emsg_severe = true;\n          EMSG(_(e_trailing));\n        }\n        if (!(eap->skip || error)) {\n          clear_lval(&lv);\n        }\n        break;\n      }\n\n      if (!error && !eap->skip && callback(&lv, name_end, eap, deep) == FAIL) {\n        error = true;\n      }\n\n      if (!eap->skip) {\n        clear_lval(&lv);\n      }\n    }\n    arg = skipwhite(name_end);\n  } while (!ends_excmd(*arg));\n\n  eap->nextcmd = check_nextcmd(arg);\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// Unlet a variable indicated by `lp`.\n///\n/// @param[in]  lp  The lvalue.\n/// @param[in]  name_end  End of the string argument for the command.\n/// @param[in]  eap  Ex command arguments for :unlet.\n/// @param[in]  deep  Unused.\n///\n/// @return OK on success, or FAIL on failure.\nstatic int do_unlet_var(lval_T *lp, char_u *name_end, exarg_T *eap, int deep FUNC_ATTR_UNUSED)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int forceit = eap->forceit;\n  int ret = OK;\n  int cc;\n\n  if (lp->ll_tv == NULL) {\n    cc = *name_end;\n    *name_end = NUL;\n\n    // Environment variable, normal name or expanded name.\n    if (*lp->ll_name == '$') {\n      os_unsetenv(lp->ll_name + 1);\n    } else if (do_unlet(lp->ll_name, lp->ll_name_len, forceit) == FAIL) {\n      ret = FAIL;\n    }\n    *name_end = cc;\n  } else if ((lp->ll_list != NULL\n              // ll_list is not NULL when lvalue is not in a list, NULL lists\n              // yield E689.\n              && var_check_lock(tv_list_locked(lp->ll_list),\n                                lp->ll_name,\n                                lp->ll_name_len))\n             || (lp->ll_dict != NULL\n                 && var_check_lock(lp->ll_dict->dv_lock,\n                                   lp->ll_name,\n                                   lp->ll_name_len))) {\n    return FAIL;\n  } else if (lp->ll_range) {\n    assert(lp->ll_list != NULL);\n    // Delete a range of List items.\n    listitem_T *const first_li = lp->ll_li;\n    listitem_T *last_li = first_li;\n    for (;;) {\n      listitem_T *const li = TV_LIST_ITEM_NEXT(lp->ll_list, lp->ll_li);\n      if (var_check_lock(TV_LIST_ITEM_TV(lp->ll_li)->v_lock,\n                         lp->ll_name,\n                         lp->ll_name_len)) {\n        return false;\n      }\n      lp->ll_li = li;\n      lp->ll_n1++;\n      if (lp->ll_li == NULL || (!lp->ll_empty2 && lp->ll_n2 < lp->ll_n1)) {\n        break;\n      } else {\n        last_li = lp->ll_li;\n      }\n    }\n    tv_list_remove_items(lp->ll_list, first_li, last_li);\n  } else {\n    if (lp->ll_list != NULL) {\n      // unlet a List item.\n      tv_list_item_remove(lp->ll_list, lp->ll_li);\n    } else {\n      // unlet a Dictionary item.\n      dict_T *d = lp->ll_dict;\n      assert(d != NULL);\n      dictitem_T *di = lp->ll_di;\n      bool watched = tv_dict_is_watched(d);\n      char *key = NULL;\n      typval_T oldtv;\n\n      if (watched) {\n        tv_copy(&di->di_tv, &oldtv);\n        // need to save key because dictitem_remove will free it\n        key = xstrdup((char *)di->di_key);\n      }\n\n      tv_dict_item_remove(d, di);\n\n      if (watched) {\n        tv_dict_watcher_notify(d, key, NULL, &oldtv);\n        tv_clear(&oldtv);\n        xfree(key);\n      }\n    }\n  }\n\n  return ret;\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// unlet a variable\n///\n/// @param[in]  name  Variable name to unlet.\n/// @param[in]  name_len  Variable name length.\n/// @param[in]  forceit  If true, do not complain if variable doesn\u2019t exist.\n///\n/// @return OK if it existed, FAIL otherwise.\nint do_unlet(const char *const name, const size_t name_len, const bool forceit)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char *varname;\n  dict_T *dict;\n  hashtab_T *ht = find_var_ht_dict(name, name_len, &varname, &dict);\n\n  if (ht != NULL && *varname != NUL) {\n    dict_T *d = get_current_funccal_dict(ht);\n    if (d == NULL) {\n      if (ht == &globvarht) {\n        d = &globvardict;\n      } else if (ht == &compat_hashtab) {\n        d = &vimvardict;\n      } else {\n        dictitem_T *const di = find_var_in_ht(ht, *name, \"\", 0, false);\n        d = di->di_tv.vval.v_dict;\n      }\n      if (d == NULL) {\n        internal_error(\"do_unlet()\");\n        return FAIL;\n      }\n    }\n\n    hashitem_T *hi = hash_find(ht, (const char_u *)varname);\n    if (HASHITEM_EMPTY(hi)) {\n      hi = find_hi_in_scoped_ht((const char *)name, &ht);\n    }\n    if (hi != NULL && !HASHITEM_EMPTY(hi)) {\n      dictitem_T *const di = TV_DICT_HI2DI(hi);\n      if (var_check_fixed(di->di_flags, (const char *)name, TV_CSTRING)\n          || var_check_ro(di->di_flags, (const char *)name, TV_CSTRING)\n          || var_check_lock(d->dv_lock, name, TV_CSTRING)) {\n        return FAIL;\n      }\n\n      if (var_check_lock(d->dv_lock, name, TV_CSTRING)) {\n        return FAIL;\n      }\n\n      typval_T oldtv;\n      bool watched = tv_dict_is_watched(dict);\n\n      if (watched) {\n        tv_copy(&di->di_tv, &oldtv);\n      }\n\n      delete_var(ht, hi);\n\n      if (watched) {\n        tv_dict_watcher_notify(dict, varname, NULL, &oldtv);\n        tv_clear(&oldtv);\n      }\n      return OK;\n    }\n  }\n  if (forceit) {\n    return OK;\n  }\n  EMSG2(_(\"E108: No such variable: \\\"%s\\\"\"), name);\n  return FAIL;\n}\n\n// TODO(ZyX-I): move to eval/ex_cmds\n\n/// Lock or unlock variable indicated by `lp`.\n///\n/// Locks if `eap->cmdidx == CMD_lockvar`, unlocks otherwise.\n///\n/// @param[in]  lp  The lvalue.\n/// @param[in]  name_end  Unused.\n/// @param[in]  eap  Ex command arguments for :(un)lockvar.\n/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.\n///\n/// @return OK on success, or FAIL on failure.\nstatic int do_lock_var(lval_T *lp, char_u *name_end FUNC_ATTR_UNUSED, exarg_T *eap, int deep)\n  FUNC_ATTR_NONNULL_ARG(1, 3)\n{\n  bool lock = eap->cmdidx == CMD_lockvar;\n  int ret = OK;\n\n  if (deep == 0) {  // Nothing to do.\n    return OK;\n  }\n\n  if (lp->ll_tv == NULL) {\n    if (*lp->ll_name == '$') {\n      EMSG2(_(e_lock_unlock), lp->ll_name);\n      ret = FAIL;\n    } else {\n      // Normal name or expanded name.\n      dictitem_T *const di = find_var((const char *)lp->ll_name, lp->ll_name_len, NULL,\n                                      true);\n      if (di == NULL) {\n        ret = FAIL;\n      } else if ((di->di_flags & DI_FLAGS_FIX)\n                 && di->di_tv.v_type != VAR_DICT\n                 && di->di_tv.v_type != VAR_LIST) {\n        // For historical reasons this error is not given for Lists and\n        // Dictionaries. E.g. b: dictionary may be locked/unlocked.\n        EMSG2(_(e_lock_unlock), lp->ll_name);\n        ret = FAIL;\n      } else {\n        if (lock) {\n          di->di_flags |= DI_FLAGS_LOCK;\n        } else {\n          di->di_flags &= ~DI_FLAGS_LOCK;\n        }\n        tv_item_lock(&di->di_tv, deep, lock, false);\n      }\n    }\n  } else if (lp->ll_range) {\n    listitem_T *li = lp->ll_li;\n\n    // (un)lock a range of List items.\n    while (li != NULL && (lp->ll_empty2 || lp->ll_n2 >= lp->ll_n1)) {\n      tv_item_lock(TV_LIST_ITEM_TV(li), deep, lock, false);\n      li = TV_LIST_ITEM_NEXT(lp->ll_list, li);\n      lp->ll_n1++;\n    }\n  } else if (lp->ll_list != NULL) {\n    // (un)lock a List item.\n    tv_item_lock(TV_LIST_ITEM_TV(lp->ll_li), deep, lock, false);\n  } else {\n    // (un)lock a Dictionary item.\n    tv_item_lock(&lp->ll_di->di_tv, deep, lock, false);\n  }\n\n  return ret;\n}\n\n/*\n * Delete all \"menutrans_\" variables.\n */\nvoid del_menutrans_vars(void)\n{\n  hash_lock(&globvarht);\n  HASHTAB_ITER(&globvarht, hi, {\n    if (STRNCMP(hi->hi_key, \"menutrans_\", 10) == 0) {\n      delete_var(&globvarht, hi);\n    }\n  });\n  hash_unlock(&globvarht);\n}\n\n/*\n * Local string buffer for the next two functions to store a variable name\n * with its prefix. Allocated in cat_prefix_varname(), freed later in\n * get_user_var_name().\n */\n\n\nstatic char_u *varnamebuf = NULL;\nstatic size_t varnamebuflen = 0;\n\n/*\n * Function to concatenate a prefix and a variable name.\n */\nchar_u *cat_prefix_varname(int prefix, const char_u *name)\n  FUNC_ATTR_NONNULL_ALL\n{\n  size_t len = STRLEN(name) + 3;\n\n  if (len > varnamebuflen) {\n    xfree(varnamebuf);\n    len += 10;                          // some additional space\n    varnamebuf = xmalloc(len);\n    varnamebuflen = len;\n  }\n  *varnamebuf = prefix;\n  varnamebuf[1] = ':';\n  STRCPY(varnamebuf + 2, name);\n  return varnamebuf;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * (global/buffer/window/built-in) variable names.\n */\nchar_u *get_user_var_name(expand_T *xp, int idx)\n{\n  static size_t gdone;\n  static size_t bdone;\n  static size_t wdone;\n  static size_t tdone;\n  static size_t vidx;\n  static hashitem_T *hi;\n\n  if (idx == 0) {\n    gdone = bdone = wdone = vidx = 0;\n    tdone = 0;\n  }\n\n  // Global variables\n  if (gdone < globvarht.ht_used) {\n    if (gdone++ == 0) {\n      hi = globvarht.ht_array;\n    } else {\n      ++hi;\n    }\n    while (HASHITEM_EMPTY(hi)) {\n      ++hi;\n    }\n    if (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0) {\n      return cat_prefix_varname('g', hi->hi_key);\n    }\n    return hi->hi_key;\n  }\n\n  // b: variables\n  // In cmdwin, the alternative buffer should be used.\n  hashtab_T *ht = (cmdwin_type != 0 && get_cmdline_type() == NUL)\n    ? &prevwin->w_buffer->b_vars->dv_hashtab\n    : &curbuf->b_vars->dv_hashtab;\n  if (bdone < ht->ht_used) {\n    if (bdone++ == 0) {\n      hi = ht->ht_array;\n    } else {\n      ++hi;\n    }\n    while (HASHITEM_EMPTY(hi)) {\n      ++hi;\n    }\n    return cat_prefix_varname('b', hi->hi_key);\n  }\n\n  // w: variables\n  // In cmdwin, the alternative window should be used.\n  ht = (cmdwin_type != 0 && get_cmdline_type() == NUL)\n    ? &prevwin->w_vars->dv_hashtab\n    : &curwin->w_vars->dv_hashtab;\n  if (wdone < ht->ht_used) {\n    if (wdone++ == 0) {\n      hi = ht->ht_array;\n    } else {\n      ++hi;\n    }\n    while (HASHITEM_EMPTY(hi)) {\n      ++hi;\n    }\n    return cat_prefix_varname('w', hi->hi_key);\n  }\n\n  // t: variables\n  ht = &curtab->tp_vars->dv_hashtab;\n  if (tdone < ht->ht_used) {\n    if (tdone++ == 0) {\n      hi = ht->ht_array;\n    } else {\n      ++hi;\n    }\n    while (HASHITEM_EMPTY(hi)) {\n      ++hi;\n    }\n    return cat_prefix_varname('t', hi->hi_key);\n  }\n\n  // v: variables\n  if (vidx < ARRAY_SIZE(vimvars)) {\n    return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);\n  }\n\n  XFREE_CLEAR(varnamebuf);\n  varnamebuflen = 0;\n  return NULL;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Return TRUE if \"pat\" matches \"text\".\n/// Does not use 'cpo' and always uses 'magic'.\nstatic int pattern_match(char_u *pat, char_u *text, bool ic)\n{\n  int matches = 0;\n  regmatch_T regmatch;\n\n  // avoid 'l' flag in 'cpoptions'\n  char_u *save_cpo = p_cpo;\n  p_cpo = (char_u *)\"\";\n  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n  if (regmatch.regprog != NULL) {\n    regmatch.rm_ic = ic;\n    matches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n    vim_regfree(regmatch.regprog);\n  }\n  p_cpo = save_cpo;\n  return matches;\n}\n\n/// Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n/// \"expr->name(arg)\".\n//\n/// @param arg  Points to \"(\", will be advanced\n/// @param basetv  \"expr\" for \"expr->name(arg)\"\n//\n/// @return OK or FAIL.\nstatic int eval_func(char_u **const arg, char_u *const name, const int name_len,\n                     typval_T *const rettv, const bool evaluate, typval_T *const basetv)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 4)\n{\n  char_u *s = name;\n  int len = name_len;\n\n  if (!evaluate) {\n    check_vars((const char *)s, len);\n  }\n\n  // If \"s\" is the name of a variable of type VAR_FUNC\n  // use its contents.\n  partial_T *partial;\n  s = deref_func_name((const char *)s, &len, &partial, !evaluate);\n\n  // Need to make a copy, in case evaluating the arguments makes\n  // the name invalid.\n  s = xmemdupz(s, len);\n\n  // Invoke the function.\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = evaluate;\n  funcexe.partial = partial;\n  funcexe.basetv = basetv;\n  int ret = get_func_tv(s, len, rettv, arg, &funcexe);\n\n  xfree(s);\n\n  // If evaluate is false rettv->v_type was not set in\n  // get_func_tv, but it's needed in handle_subscript() to parse\n  // what follows. So set it here.\n  if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(') {\n    rettv->vval.v_string = (char_u *)tv_empty_string;\n    rettv->v_type = VAR_FUNC;\n  }\n\n  // Stop the expression evaluation when immediately\n  // aborting on error, or when an interrupt occurred or\n  // an exception was thrown but not caught.\n  if (evaluate && aborting()) {\n    if (ret == OK) {\n      tv_clear(rettv);\n    }\n    ret = FAIL;\n  }\n  return ret;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * Return OK or FAIL.\n */\nint eval0(char_u *arg, typval_T *rettv, char_u **nextcmd, int evaluate)\n{\n  int ret;\n  char_u *p;\n  const int did_emsg_before = did_emsg;\n  const int called_emsg_before = called_emsg;\n\n  p = skipwhite(arg);\n  ret = eval1(&p, rettv, evaluate);\n  if (ret == FAIL || !ends_excmd(*p)) {\n    if (ret != FAIL) {\n      tv_clear(rettv);\n    }\n    // Report the invalid expression unless the expression evaluation has\n    // been cancelled due to an aborting error, an interrupt, or an\n    // exception, or we already gave a more specific error.\n    // Also check called_emsg for when using assert_fails().\n    if (!aborting() && did_emsg == did_emsg_before\n        && called_emsg == called_emsg_before) {\n      emsgf(_(e_invexpr2), arg);\n    }\n    ret = FAIL;\n  }\n  if (nextcmd != NULL) {\n    *nextcmd = check_nextcmd(p);\n  }\n\n  return ret;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * Handle top level expression:\n *      expr2 ? expr1 : expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to the next non-white after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\nint eval1(char_u **arg, typval_T *rettv, int evaluate)\n{\n  int result;\n  typval_T var2;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval2(arg, rettv, evaluate) == FAIL) {\n    return FAIL;\n  }\n\n  if ((*arg)[0] == '?') {\n    result = FALSE;\n    if (evaluate) {\n      bool error = false;\n\n      if (tv_get_number_chk(rettv, &error) != 0) {\n        result = true;\n      }\n      tv_clear(rettv);\n      if (error) {\n        return FAIL;\n      }\n    }\n\n    /*\n     * Get the second variable.\n     */\n    *arg = skipwhite(*arg + 1);\n    if (eval1(arg, rettv, evaluate && result) == FAIL) {  // recursive!\n      return FAIL;\n    }\n\n    /*\n     * Check for the \":\".\n     */\n    if ((*arg)[0] != ':') {\n      EMSG(_(\"E109: Missing ':' after '?'\"));\n      if (evaluate && result) {\n        tv_clear(rettv);\n      }\n      return FAIL;\n    }\n\n    /*\n     * Get the third variable.\n     */\n    *arg = skipwhite(*arg + 1);\n    if (eval1(arg, &var2, evaluate && !result) == FAIL) {  // Recursive!\n      if (evaluate && result) {\n        tv_clear(rettv);\n      }\n      return FAIL;\n    }\n    if (evaluate && !result) {\n      *rettv = var2;\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * Handle first level expression:\n *      expr2 || expr2 || expr2     logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to the next non-white after the recognized expression.\n *\n * Return OK or FAIL.\n */\nstatic int eval2(char_u **arg, typval_T *rettv, int evaluate)\n{\n  typval_T var2;\n  long result;\n  int first;\n  bool error = false;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval3(arg, rettv, evaluate) == FAIL) {\n    return FAIL;\n  }\n\n  /*\n   * Repeat until there is no following \"||\".\n   */\n  first = TRUE;\n  result = FALSE;\n  while ((*arg)[0] == '|' && (*arg)[1] == '|') {\n    if (evaluate && first) {\n      if (tv_get_number_chk(rettv, &error) != 0) {\n        result = true;\n      }\n      tv_clear(rettv);\n      if (error) {\n        return FAIL;\n      }\n      first = false;\n    }\n\n    /*\n     * Get the second variable.\n     */\n    *arg = skipwhite(*arg + 2);\n    if (eval3(arg, &var2, evaluate && !result) == FAIL) {\n      return FAIL;\n    }\n\n    /*\n     * Compute the result.\n     */\n    if (evaluate && !result) {\n      if (tv_get_number_chk(&var2, &error) != 0) {\n        result = true;\n      }\n      tv_clear(&var2);\n      if (error) {\n        return FAIL;\n      }\n    }\n    if (evaluate) {\n      rettv->v_type = VAR_NUMBER;\n      rettv->vval.v_number = result;\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * Handle second level expression:\n *      expr3 && expr3 && expr3     logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to the next non-white after the recognized expression.\n *\n * Return OK or FAIL.\n */\nstatic int eval3(char_u **arg, typval_T *rettv, int evaluate)\n{\n  typval_T var2;\n  long result;\n  int first;\n  bool error = false;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval4(arg, rettv, evaluate) == FAIL) {\n    return FAIL;\n  }\n\n  /*\n   * Repeat until there is no following \"&&\".\n   */\n  first = TRUE;\n  result = TRUE;\n  while ((*arg)[0] == '&' && (*arg)[1] == '&') {\n    if (evaluate && first) {\n      if (tv_get_number_chk(rettv, &error) == 0) {\n        result = false;\n      }\n      tv_clear(rettv);\n      if (error) {\n        return FAIL;\n      }\n      first = false;\n    }\n\n    /*\n     * Get the second variable.\n     */\n    *arg = skipwhite(*arg + 2);\n    if (eval4(arg, &var2, evaluate && result) == FAIL) {\n      return FAIL;\n    }\n\n    /*\n     * Compute the result.\n     */\n    if (evaluate && result) {\n      if (tv_get_number_chk(&var2, &error) == 0) {\n        result = false;\n      }\n      tv_clear(&var2);\n      if (error) {\n        return FAIL;\n      }\n    }\n    if (evaluate) {\n      rettv->v_type = VAR_NUMBER;\n      rettv->vval.v_number = result;\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * Handle third level expression:\n *      var1 == var2\n *      var1 =~ var2\n *      var1 != var2\n *      var1 !~ var2\n *      var1 > var2\n *      var1 >= var2\n *      var1 < var2\n *      var1 <= var2\n *      var1 is var2\n *      var1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to the next non-white after the recognized expression.\n *\n * Return OK or FAIL.\n */\nstatic int eval4(char_u **arg, typval_T *rettv, int evaluate)\n{\n  typval_T var2;\n  char_u *p;\n  exprtype_T type = EXPR_UNKNOWN;\n  int len = 2;\n  bool ic;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval5(arg, rettv, evaluate) == FAIL) {\n    return FAIL;\n  }\n\n  p = *arg;\n  switch (p[0]) {\n  case '=':\n    if (p[1] == '=') {\n      type = EXPR_EQUAL;\n    } else if (p[1] == '~') {\n      type = EXPR_MATCH;\n    }\n    break;\n  case '!':\n    if (p[1] == '=') {\n      type = EXPR_NEQUAL;\n    } else if (p[1] == '~') {\n      type = EXPR_NOMATCH;\n    }\n    break;\n  case '>':\n    if (p[1] != '=') {\n      type = EXPR_GREATER;\n      len = 1;\n    } else {\n      type = EXPR_GEQUAL;\n    }\n    break;\n  case '<':\n    if (p[1] != '=') {\n      type = EXPR_SMALLER;\n      len = 1;\n    } else {\n      type = EXPR_SEQUAL;\n    }\n    break;\n  case 'i':\n    if (p[1] == 's') {\n      if (p[2] == 'n' && p[3] == 'o' && p[4] == 't') {\n        len = 5;\n      }\n      if (!isalnum(p[len]) && p[len] != '_') {\n        type = len == 2 ? EXPR_IS : EXPR_ISNOT;\n      }\n    }\n    break;\n  }\n\n  /*\n   * If there is a comparative operator, use it.\n   */\n  if (type != EXPR_UNKNOWN) {\n    // extra question mark appended: ignore case\n    if (p[len] == '?') {\n      ic = true;\n      len++;\n    } else if (p[len] == '#') {  // extra '#' appended: match case\n      ic = false;\n      len++;\n    } else {  // nothing appended: use 'ignorecase'\n      ic = p_ic;\n    }\n\n    // Get the second variable.\n    *arg = skipwhite(p + len);\n    if (eval5(arg, &var2, evaluate) == FAIL) {\n      tv_clear(rettv);\n      return FAIL;\n    }\n    if (evaluate) {\n      const int ret = typval_compare(rettv, &var2, type, ic);\n\n      tv_clear(&var2);\n      return ret;\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/*\n * Handle fourth level expression:\n *      +       number addition\n *      -       number subtraction\n *      .       string concatenation\n *      ..      string concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to the next non-white after the recognized expression.\n *\n * Return OK or FAIL.\n */\nstatic int eval5(char_u **arg, typval_T *rettv, int evaluate)\n{\n  typval_T var2;\n  typval_T var3;\n  int op;\n  varnumber_T n1, n2;\n  float_T f1 = 0, f2 = 0;\n  char_u *p;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval6(arg, rettv, evaluate, FALSE) == FAIL) {\n    return FAIL;\n  }\n\n  /*\n   * Repeat computing, until no '+', '-' or '.' is following.\n   */\n  for (;; ) {\n    op = **arg;\n    if (op != '+' && op != '-' && op != '.') {\n      break;\n    }\n\n    if ((op != '+' || (rettv->v_type != VAR_LIST && rettv->v_type != VAR_BLOB))\n        && (op == '.' || rettv->v_type != VAR_FLOAT)) {\n      // For \"list + ...\", an illegal use of the first operand as\n      // a number cannot be determined before evaluating the 2nd\n      // operand: if this is also a list, all is ok.\n      // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n      // we know that the first operand needs to be a string or number\n      // without evaluating the 2nd operand.  So check before to avoid\n      // side effects after an error.\n      if (evaluate && !tv_check_str(rettv)) {\n        tv_clear(rettv);\n        return FAIL;\n      }\n    }\n\n    /*\n     * Get the second variable.\n     */\n    if (op == '.' && *(*arg + 1) == '.') {  // ..string concatenation\n      (*arg)++;\n    }\n    *arg = skipwhite(*arg + 1);\n    if (eval6(arg, &var2, evaluate, op == '.') == FAIL) {\n      tv_clear(rettv);\n      return FAIL;\n    }\n\n    if (evaluate) {\n      /*\n       * Compute the result.\n       */\n      if (op == '.') {\n        char buf1[NUMBUFLEN];\n        char buf2[NUMBUFLEN];\n        // s1 already checked\n        const char *const s1 = tv_get_string_buf(rettv, buf1);\n        const char *const s2 = tv_get_string_buf_chk(&var2, buf2);\n        if (s2 == NULL) {  // Type error?\n          tv_clear(rettv);\n          tv_clear(&var2);\n          return FAIL;\n        }\n        p = concat_str((const char_u *)s1, (const char_u *)s2);\n        tv_clear(rettv);\n        rettv->v_type = VAR_STRING;\n        rettv->vval.v_string = p;\n      } else if (op == '+' && rettv->v_type == VAR_BLOB\n                 && var2.v_type == VAR_BLOB) {\n        const blob_T *const b1 = rettv->vval.v_blob;\n        const blob_T *const b2 = var2.vval.v_blob;\n        blob_T *const b = tv_blob_alloc();\n\n        for (int i = 0; i < tv_blob_len(b1); i++) {\n          ga_append(&b->bv_ga, tv_blob_get(b1, i));\n        }\n        for (int i = 0; i < tv_blob_len(b2); i++) {\n          ga_append(&b->bv_ga, tv_blob_get(b2, i));\n        }\n\n        tv_clear(rettv);\n        tv_blob_set_ret(rettv, b);\n      } else if (op == '+' && rettv->v_type == VAR_LIST\n                 && var2.v_type == VAR_LIST) {\n        // Concatenate Lists.\n        if (tv_list_concat(rettv->vval.v_list, var2.vval.v_list, &var3)\n            == FAIL) {\n          tv_clear(rettv);\n          tv_clear(&var2);\n          return FAIL;\n        }\n        tv_clear(rettv);\n        *rettv = var3;\n      } else {\n        bool error = false;\n\n        if (rettv->v_type == VAR_FLOAT) {\n          f1 = rettv->vval.v_float;\n          n1 = 0;\n        } else {\n          n1 = tv_get_number_chk(rettv, &error);\n          if (error) {\n            // This can only happen for \"list + non-list\" or\n            // \"blob + non-blob\".  For \"non-list + ...\" or\n            // \"something - ...\", we returned before evaluating the\n            // 2nd operand.\n            tv_clear(rettv);\n            tv_clear(&var2);\n            return FAIL;\n          }\n          if (var2.v_type == VAR_FLOAT) {\n            f1 = n1;\n          }\n        }\n        if (var2.v_type == VAR_FLOAT) {\n          f2 = var2.vval.v_float;\n          n2 = 0;\n        } else {\n          n2 = tv_get_number_chk(&var2, &error);\n          if (error) {\n            tv_clear(rettv);\n            tv_clear(&var2);\n            return FAIL;\n          }\n          if (rettv->v_type == VAR_FLOAT) {\n            f2 = n2;\n          }\n        }\n        tv_clear(rettv);\n\n        // If there is a float on either side the result is a float.\n        if (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT) {\n          if (op == '+') {\n            f1 = f1 + f2;\n          } else {\n            f1 = f1 - f2;\n          }\n          rettv->v_type = VAR_FLOAT;\n          rettv->vval.v_float = f1;\n        } else {\n          if (op == '+') {\n            n1 = n1 + n2;\n          } else {\n            n1 = n1 - n2;\n          }\n          rettv->v_type = VAR_NUMBER;\n          rettv->vval.v_number = n1;\n        }\n      }\n      tv_clear(&var2);\n    }\n  }\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Handle fifth level expression:\n///  - *  number multiplication\n///  - /  number division\n///  - %  number modulo\n///\n/// @param[in,out]  arg  Points to the first non-whitespace character of the\n///                      expression.  Is advanced to the next non-whitespace\n///                      character after the recognized expression.\n/// @param[out]  rettv  Location where result is saved.\n/// @param[in]  evaluate  If not true, rettv is not populated.\n/// @param[in]  want_string  True if \".\" is string_concatenation, otherwise\n///                          float\n/// @return  OK or FAIL.\nstatic int eval6(char_u **arg, typval_T *rettv, int evaluate, int want_string)\n  FUNC_ATTR_NO_SANITIZE_UNDEFINED\n{\n  typval_T var2;\n  int op;\n  varnumber_T n1, n2;\n  bool use_float = false;\n  float_T f1 = 0, f2 = 0;\n  bool error = false;\n\n  /*\n   * Get the first variable.\n   */\n  if (eval7(arg, rettv, evaluate, want_string) == FAIL) {\n    return FAIL;\n  }\n\n  /*\n   * Repeat computing, until no '*', '/' or '%' is following.\n   */\n  for (;; ) {\n    op = **arg;\n    if (op != '*' && op != '/' && op != '%') {\n      break;\n    }\n\n    if (evaluate) {\n      if (rettv->v_type == VAR_FLOAT) {\n        f1 = rettv->vval.v_float;\n        use_float = true;\n        n1 = 0;\n      } else {\n        n1 = tv_get_number_chk(rettv, &error);\n      }\n      tv_clear(rettv);\n      if (error) {\n        return FAIL;\n      }\n    } else {\n      n1 = 0;\n    }\n\n    /*\n     * Get the second variable.\n     */\n    *arg = skipwhite(*arg + 1);\n    if (eval7(arg, &var2, evaluate, FALSE) == FAIL) {\n      return FAIL;\n    }\n\n    if (evaluate) {\n      if (var2.v_type == VAR_FLOAT) {\n        if (!use_float) {\n          f1 = n1;\n          use_float = true;\n        }\n        f2 = var2.vval.v_float;\n        n2 = 0;\n      } else {\n        n2 = tv_get_number_chk(&var2, &error);\n        tv_clear(&var2);\n        if (error) {\n          return FAIL;\n        }\n        if (use_float) {\n          f2 = n2;\n        }\n      }\n\n      /*\n       * Compute the result.\n       * When either side is a float the result is a float.\n       */\n      if (use_float) {\n        if (op == '*') {\n          f1 = f1 * f2;\n        } else if (op == '/') {\n          // Division by zero triggers error from AddressSanitizer\n          f1 = (f2 == 0\n                ? (\n#ifdef NAN\n                   f1 == 0\n                    ? NAN\n                    :\n#endif\n                   (f1 > 0\n                     ? INFINITY\n                     : -INFINITY)\n                   )\n                     : f1 / f2);\n        } else {\n          EMSG(_(\"E804: Cannot use '%' with Float\"));\n          return FAIL;\n        }\n        rettv->v_type = VAR_FLOAT;\n        rettv->vval.v_float = f1;\n      } else {\n        if (op == '*') {\n          n1 = n1 * n2;\n        } else if (op == '/') {\n          n1 = num_divide(n1, n2);\n        } else {\n          n1 = num_modulus(n1, n2);\n        }\n        rettv->v_type = VAR_NUMBER;\n        rettv->vval.v_number = n1;\n      }\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Handle sixth level expression:\n///  number  number constant\n///  0zFFFFFFFF  Blob constant\n///  \"string\"  string constant\n///  'string'  literal string constant\n///  &option-name option value\n///  @r   register contents\n///  identifier  variable value\n///  function()  function call\n///  $VAR  environment variable\n///  (expression) nested expression\n///  [expr, expr] List\n///  {key: val, key: val}  Dictionary\n///  #{key: val, key: val}  Dictionary with literal keys\n///\n///  Also handle:\n///  ! in front  logical NOT\n///  - in front  unary minus\n///  + in front  unary plus (ignored)\n///  trailing []  subscript in String or List\n///  trailing .name entry in Dictionary\n///  trailing ->name()  method call\n///\n/// \"arg\" must point to the first non-white of the expression.\n/// \"arg\" is advanced to the next non-white after the recognized expression.\n///\n/// @param want_string  after \".\" operator\n///\n/// @return  OK or FAIL.\nstatic int eval7(char_u **arg, typval_T *rettv, int evaluate, int want_string)\n{\n  varnumber_T n;\n  int len;\n  char_u *s;\n  const char_u *start_leader, *end_leader;\n  int ret = OK;\n  char_u *alias;\n\n  // Initialise variable so that tv_clear() can't mistake this for a\n  // string and free a string that isn't there.\n  rettv->v_type = VAR_UNKNOWN;\n\n  // Skip '!', '-' and '+' characters.  They are handled later.\n  start_leader = *arg;\n  while (**arg == '!' || **arg == '-' || **arg == '+') {\n    *arg = skipwhite(*arg + 1);\n  }\n  end_leader = *arg;\n\n  switch (**arg) {\n  // Number constant.\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9': {\n    char_u *p = skipdigits(*arg + 1);\n    int get_float = false;\n\n    // We accept a float when the format matches\n    // \"[0-9]\\+\\.[0-9]\\+\\([eE][+-]\\?[0-9]\\+\\)\\?\".  This is very\n    // strict to avoid backwards compatibility problems.\n    // Don't look for a float after the \".\" operator, so that\n    // \":let vers = 1.2.3\" doesn't fail.\n    if (!want_string && p[0] == '.' && ascii_isdigit(p[1])) {\n      get_float = true;\n      p = skipdigits(p + 2);\n      if (*p == 'e' || *p == 'E') {\n        ++p;\n        if (*p == '-' || *p == '+') {\n          ++p;\n        }\n        if (!ascii_isdigit(*p)) {\n          get_float = false;\n        } else {\n          p = skipdigits(p + 1);\n        }\n      }\n      if (ASCII_ISALPHA(*p) || *p == '.') {\n        get_float = false;\n      }\n    }\n    if (get_float) {\n      float_T f;\n\n      *arg += string2float((char *)*arg, &f);\n      if (evaluate) {\n        rettv->v_type = VAR_FLOAT;\n        rettv->vval.v_float = f;\n      }\n    } else if (**arg == '0' && ((*arg)[1] == 'z' || (*arg)[1] == 'Z')) {\n      blob_T *blob = NULL;\n      // Blob constant: 0z0123456789abcdef\n      if (evaluate) {\n        blob = tv_blob_alloc();\n      }\n      char_u *bp;\n      for (bp = *arg + 2; ascii_isxdigit(bp[0]); bp += 2) {\n        if (!ascii_isxdigit(bp[1])) {\n          if (blob != NULL) {\n            EMSG(_(\"E973: Blob literal should have an even number of hex \"\n                   \"characters\"));\n            ga_clear(&blob->bv_ga);\n            XFREE_CLEAR(blob);\n          }\n          ret = FAIL;\n          break;\n        }\n        if (blob != NULL) {\n          ga_append(&blob->bv_ga, (hex2nr(*bp) << 4) + hex2nr(*(bp + 1)));\n        }\n        if (bp[2] == '.' && ascii_isxdigit(bp[3])) {\n          bp++;\n        }\n      }\n      if (blob != NULL) {\n        tv_blob_set_ret(rettv, blob);\n      }\n      *arg = bp;\n    } else {\n      // decimal, hex or octal number\n      vim_str2nr(*arg, NULL, &len, STR2NR_ALL, &n, NULL, 0, true);\n      if (len == 0) {\n        EMSG2(_(e_invexpr2), *arg);\n        ret = FAIL;\n        break;\n      }\n      *arg += len;\n      if (evaluate) {\n        rettv->v_type = VAR_NUMBER;\n        rettv->vval.v_number = n;\n      }\n    }\n    break;\n  }\n\n  // String constant: \"string\".\n  case '\"':\n    ret = get_string_tv(arg, rettv, evaluate);\n    break;\n\n  // Literal string constant: 'str''ing'.\n  case '\\'':\n    ret = get_lit_string_tv(arg, rettv, evaluate);\n    break;\n\n  // List: [expr, expr]\n  case '[':\n    ret = get_list_tv(arg, rettv, evaluate);\n    break;\n\n  // Dictionary: #{key: val, key: val}\n  case '#':\n    if ((*arg)[1] == '{') {\n      (*arg)++;\n      ret = dict_get_tv(arg, rettv, evaluate, true);\n    } else {\n      ret = NOTDONE;\n    }\n    break;\n\n  // Lambda: {arg, arg -> expr}\n  // Dictionary: {'key': val, 'key': val}\n  case '{':\n    ret = get_lambda_tv(arg, rettv, evaluate);\n    if (ret == NOTDONE) {\n      ret = dict_get_tv(arg, rettv, evaluate, false);\n    }\n    break;\n\n  // Option value: &name\n  case '&':\n    ret = get_option_tv((const char **)arg, rettv, evaluate);\n    break;\n  // Environment variable: $VAR.\n  case '$':\n    ret = get_env_tv(arg, rettv, evaluate);\n    break;\n\n  // Register contents: @r.\n  case '@':\n    ++*arg;\n    if (evaluate) {\n      rettv->v_type = VAR_STRING;\n      rettv->vval.v_string = get_reg_contents(**arg, kGRegExprSrc);\n    }\n    if (**arg != NUL) {\n      ++*arg;\n    }\n    break;\n\n  // nested expression: (expression).\n  case '(':\n    *arg = skipwhite(*arg + 1);\n    ret = eval1(arg, rettv, evaluate);                  // recursive!\n    if (**arg == ')') {\n      ++*arg;\n    } else if (ret == OK) {\n      EMSG(_(\"E110: Missing ')'\"));\n      tv_clear(rettv);\n      ret = FAIL;\n    }\n    break;\n\n  default:\n    ret = NOTDONE;\n    break;\n  }\n\n  if (ret == NOTDONE) {\n    // Must be a variable or function name.\n    // Can also be a curly-braces kind of name: {expr}.\n    s = *arg;\n    len = get_name_len((const char **)arg, (char **)&alias, evaluate, true);\n    if (alias != NULL) {\n      s = alias;\n    }\n\n    if (len <= 0) {\n      ret = FAIL;\n    } else {\n      if (**arg == '(') {               // recursive!\n        ret = eval_func(arg, s, len, rettv, evaluate, NULL);\n      } else if (evaluate) {\n        ret = get_var_tv((const char *)s, len, rettv, NULL, true, false);\n      } else {\n        check_vars((const char *)s, len);\n        ret = OK;\n      }\n    }\n    xfree(alias);\n  }\n\n  *arg = skipwhite(*arg);\n\n  // Handle following '[', '(' and '.' for expr[expr], expr.name,\n  // expr(expr), expr->name(expr)\n  if (ret == OK) {\n    ret = handle_subscript((const char **)arg, rettv, evaluate, true,\n                           start_leader, &end_leader);\n  }\n\n  // Apply logical NOT and unary '-', from right to left, ignore '+'.\n  if (ret == OK && evaluate && end_leader > start_leader) {\n    ret = eval7_leader(rettv, start_leader, &end_leader);\n  }\n  return ret;\n}\n\n/// Apply the leading \"!\" and \"-\" before an eval7 expression to \"rettv\".\n/// Adjusts \"end_leaderp\" until it is at \"start_leader\".\n/// @return OK on success, FAIL on failure.\nstatic int eval7_leader(typval_T *const rettv, const char_u *const start_leader,\n                        const char_u **const end_leaderp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char_u *end_leader = *end_leaderp;\n  int ret = OK;\n  bool error = false;\n  varnumber_T val = 0;\n  float_T f = 0.0;\n\n  if (rettv->v_type == VAR_FLOAT) {\n    f = rettv->vval.v_float;\n  } else {\n    val = tv_get_number_chk(rettv, &error);\n  }\n  if (error) {\n    tv_clear(rettv);\n    ret = FAIL;\n  } else {\n    while (end_leader > start_leader) {\n      end_leader--;\n      if (*end_leader == '!') {\n        if (rettv->v_type == VAR_FLOAT) {\n          f = !f;\n        } else {\n          val = !val;\n        }\n      } else if (*end_leader == '-') {\n        if (rettv->v_type == VAR_FLOAT) {\n          f = -f;\n        } else {\n          val = -val;\n        }\n      }\n    }\n    if (rettv->v_type == VAR_FLOAT) {\n      tv_clear(rettv);\n      rettv->vval.v_float = f;\n    } else {\n      tv_clear(rettv);\n      rettv->v_type = VAR_NUMBER;\n      rettv->vval.v_number = val;\n    }\n  }\n\n  *end_leaderp = end_leader;\n  return ret;\n}\n\n/// Call the function referred to in \"rettv\".\n/// @param lua_funcname  If `rettv` refers to a v:lua function, this must point\n///                      to the name of the Lua function to call (after the\n///                      \"v:lua.\" prefix).\n/// @return OK on success, FAIL on failure.\nstatic int call_func_rettv(char_u **const arg, typval_T *const rettv, const bool evaluate,\n                           dict_T *const selfdict, typval_T *const basetv,\n                           const char_u *const lua_funcname)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  partial_T *pt = NULL;\n  typval_T functv;\n  const char_u *funcname;\n  bool is_lua = false;\n\n  // need to copy the funcref so that we can clear rettv\n  if (evaluate) {\n    functv = *rettv;\n    rettv->v_type = VAR_UNKNOWN;\n\n    // Invoke the function.  Recursive!\n    if (functv.v_type == VAR_PARTIAL) {\n      pt = functv.vval.v_partial;\n      is_lua = is_luafunc(pt);\n      funcname = is_lua ? lua_funcname : partial_name(pt);\n    } else {\n      funcname = functv.vval.v_string;\n    }\n  } else {\n    funcname = (char_u *)\"\";\n  }\n\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = evaluate;\n  funcexe.partial = pt;\n  funcexe.selfdict = selfdict;\n  funcexe.basetv = basetv;\n  const int ret = get_func_tv(funcname, is_lua ? *arg - funcname : -1, rettv,\n                              (char_u **)arg, &funcexe);\n\n  // Clear the funcref afterwards, so that deleting it while\n  // evaluating the arguments is possible (see test55).\n  if (evaluate) {\n    tv_clear(&functv);\n  }\n\n  return ret;\n}\n\n/// Evaluate \"->method()\".\n/// @param verbose  if true, give error messages.\n/// @note \"*arg\" points to the '-'.\n/// @return FAIL or OK. @note \"*arg\" is advanced to after the ')'.\nstatic int eval_lambda(char_u **const arg, typval_T *const rettv, const bool evaluate,\n                       const bool verbose)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Skip over the ->.\n  *arg += 2;\n  typval_T base = *rettv;\n  rettv->v_type = VAR_UNKNOWN;\n\n  int ret = get_lambda_tv(arg, rettv, evaluate);\n  if (ret == NOTDONE) {\n    return FAIL;\n  } else if (**arg != '(') {\n    if (verbose) {\n      if (*skipwhite(*arg) == '(') {\n        EMSG(_(e_nowhitespace));\n      } else {\n        EMSG2(_(e_missingparen), \"lambda\");\n      }\n    }\n    tv_clear(rettv);\n    ret = FAIL;\n  } else {\n    ret = call_func_rettv(arg, rettv, evaluate, NULL, &base, NULL);\n  }\n\n  // Clear the funcref afterwards, so that deleting it while\n  // evaluating the arguments is possible (see test55).\n  if (evaluate) {\n    tv_clear(&base);\n  }\n\n  return ret;\n}\n\n/// Evaluate \"->method()\" or \"->v:lua.method()\".\n/// @note \"*arg\" points to the '-'.\n/// @return FAIL or OK. \"*arg\" is advanced to after the ')'.\nstatic int eval_method(char_u **const arg, typval_T *const rettv, const bool evaluate,\n                       const bool verbose)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Skip over the ->.\n  *arg += 2;\n  typval_T base = *rettv;\n  rettv->v_type = VAR_UNKNOWN;\n\n  // Locate the method name.\n  int len;\n  char_u *name = *arg;\n  char_u *lua_funcname = NULL;\n  if (STRNCMP(name, \"v:lua.\", 6) == 0) {\n    lua_funcname = name + 6;\n    *arg = (char_u *)skip_luafunc_name((const char *)lua_funcname);\n    *arg = skipwhite(*arg);  // to detect trailing whitespace later\n    len = *arg - lua_funcname;\n  } else {\n    char_u *alias;\n    len = get_name_len((const char **)arg, (char **)&alias, evaluate, true);\n    if (alias != NULL) {\n      name = alias;\n    }\n  }\n\n  int ret;\n  if (len <= 0) {\n    if (verbose) {\n      if (lua_funcname == NULL) {\n        EMSG(_(\"E260: Missing name after ->\"));\n      } else {\n        EMSG2(_(e_invexpr2), name);\n      }\n    }\n    ret = FAIL;\n  } else {\n    if (**arg != '(') {\n      if (verbose) {\n        EMSG2(_(e_missingparen), name);\n      }\n      ret = FAIL;\n    } else if (ascii_iswhite((*arg)[-1])) {\n      if (verbose) {\n        EMSG(_(e_nowhitespace));\n      }\n      ret = FAIL;\n    } else if (lua_funcname != NULL) {\n      if (evaluate) {\n        rettv->v_type = VAR_PARTIAL;\n        rettv->vval.v_partial = vvlua_partial;\n        rettv->vval.v_partial->pt_refcount++;\n      }\n      ret = call_func_rettv(arg, rettv, evaluate, NULL, &base, lua_funcname);\n    } else {\n      ret = eval_func(arg, name, len, rettv, evaluate, &base);\n    }\n  }\n\n  // Clear the funcref afterwards, so that deleting it while\n  // evaluating the arguments is possible (see test55).\n  if (evaluate) {\n    tv_clear(&base);\n  }\n\n  return ret;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n/// \"*arg\" points to the '[' or '.'.\n/// Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n///\n/// @param verbose  give error messages\nstatic int eval_index(char_u **arg, typval_T *rettv, int evaluate, int verbose)\n{\n  bool empty1 = false;\n  bool empty2 = false;\n  long n1, n2 = 0;\n  ptrdiff_t len = -1;\n  int range = false;\n  char_u *key = NULL;\n\n  switch (rettv->v_type) {\n  case VAR_FUNC:\n  case VAR_PARTIAL:\n    if (verbose) {\n      EMSG(_(\"E695: Cannot index a Funcref\"));\n    }\n    return FAIL;\n  case VAR_FLOAT:\n    if (verbose) {\n      EMSG(_(e_float_as_string));\n    }\n    return FAIL;\n  case VAR_BOOL:\n  case VAR_SPECIAL:\n    if (verbose) {\n      EMSG(_(\"E909: Cannot index a special variable\"));\n    }\n    return FAIL;\n  case VAR_UNKNOWN:\n    if (evaluate) {\n      return FAIL;\n    }\n    FALLTHROUGH;\n  case VAR_STRING:\n  case VAR_NUMBER:\n  case VAR_LIST:\n  case VAR_DICT:\n  case VAR_BLOB:\n    break;\n  }\n\n  typval_T var1 = TV_INITIAL_VALUE;\n  typval_T var2 = TV_INITIAL_VALUE;\n  if (**arg == '.') {\n    /*\n     * dict.name\n     */\n    key = *arg + 1;\n    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len) {\n      ;\n    }\n    if (len == 0) {\n      return FAIL;\n    }\n    *arg = skipwhite(key + len);\n  } else {\n    /*\n     * something[idx]\n     *\n     * Get the (first) variable from inside the [].\n     */\n    *arg = skipwhite(*arg + 1);\n    if (**arg == ':') {\n      empty1 = true;\n    } else if (eval1(arg, &var1, evaluate) == FAIL) {  // Recursive!\n      return FAIL;\n    } else if (evaluate && !tv_check_str(&var1)) {\n      // Not a number or string.\n      tv_clear(&var1);\n      return FAIL;\n    }\n\n    /*\n     * Get the second variable from inside the [:].\n     */\n    if (**arg == ':') {\n      range = TRUE;\n      *arg = skipwhite(*arg + 1);\n      if (**arg == ']') {\n        empty2 = true;\n      } else if (eval1(arg, &var2, evaluate) == FAIL) {  // Recursive!\n        if (!empty1) {\n          tv_clear(&var1);\n        }\n        return FAIL;\n      } else if (evaluate && !tv_check_str(&var2)) {\n        // Not a number or string.\n        if (!empty1) {\n          tv_clear(&var1);\n        }\n        tv_clear(&var2);\n        return FAIL;\n      }\n    }\n\n    // Check for the ']'.\n    if (**arg != ']') {\n      if (verbose) {\n        EMSG(_(e_missbrac));\n      }\n      tv_clear(&var1);\n      if (range) {\n        tv_clear(&var2);\n      }\n      return FAIL;\n    }\n    *arg = skipwhite(*arg + 1);         // skip the ']'\n  }\n\n  if (evaluate) {\n    n1 = 0;\n    if (!empty1 && rettv->v_type != VAR_DICT && !tv_is_luafunc(rettv)) {\n      n1 = tv_get_number(&var1);\n      tv_clear(&var1);\n    }\n    if (range) {\n      if (empty2) {\n        n2 = -1;\n      } else {\n        n2 = tv_get_number(&var2);\n        tv_clear(&var2);\n      }\n    }\n\n    switch (rettv->v_type) {\n    case VAR_NUMBER:\n    case VAR_STRING: {\n      const char *const s = tv_get_string(rettv);\n      char *v;\n      len = (ptrdiff_t)strlen(s);\n      if (range) {\n        // The resulting variable is a substring.  If the indexes\n        // are out of range the result is empty.\n        if (n1 < 0) {\n          n1 = len + n1;\n          if (n1 < 0) {\n            n1 = 0;\n          }\n        }\n        if (n2 < 0) {\n          n2 = len + n2;\n        } else if (n2 >= len) {\n          n2 = len;\n        }\n        if (n1 >= len || n2 < 0 || n1 > n2) {\n          v = NULL;\n        } else {\n          v = xmemdupz(s + n1, (size_t)(n2 - n1 + 1));\n        }\n      } else {\n        // The resulting variable is a string of a single\n        // character.  If the index is too big or negative the\n        // result is empty.\n        if (n1 >= len || n1 < 0) {\n          v = NULL;\n        } else {\n          v = xmemdupz(s + n1, 1);\n        }\n      }\n      tv_clear(rettv);\n      rettv->v_type = VAR_STRING;\n      rettv->vval.v_string = (char_u *)v;\n      break;\n    }\n    case VAR_BLOB:\n      len = tv_blob_len(rettv->vval.v_blob);\n      if (range) {\n        // The resulting variable is a sub-blob.  If the indexes\n        // are out of range the result is empty.\n        if (n1 < 0) {\n          n1 = len + n1;\n          if (n1 < 0) {\n            n1 = 0;\n          }\n        }\n        if (n2 < 0) {\n          n2 = len + n2;\n        } else if (n2 >= len) {\n          n2 = len - 1;\n        }\n        if (n1 >= len || n2 < 0 || n1 > n2) {\n          tv_clear(rettv);\n          rettv->v_type = VAR_BLOB;\n          rettv->vval.v_blob = NULL;\n        } else {\n          blob_T *const blob = tv_blob_alloc();\n          ga_grow(&blob->bv_ga, n2 - n1 + 1);\n          blob->bv_ga.ga_len = n2 - n1 + 1;\n          for (long i = n1; i <= n2; i++) {\n            tv_blob_set(blob, i - n1, tv_blob_get(rettv->vval.v_blob, i));\n          }\n          tv_clear(rettv);\n          tv_blob_set_ret(rettv, blob);\n        }\n      } else {\n        // The resulting variable is a byte value.\n        // If the index is too big or negative that is an error.\n        if (n1 < 0) {\n          n1 = len + n1;\n        }\n        if (n1 < len && n1 >= 0) {\n          const int v = (int)tv_blob_get(rettv->vval.v_blob, n1);\n          tv_clear(rettv);\n          rettv->v_type = VAR_NUMBER;\n          rettv->vval.v_number = v;\n        } else {\n          EMSGN(_(e_blobidx), n1);\n        }\n      }\n      break;\n    case VAR_LIST:\n      len = tv_list_len(rettv->vval.v_list);\n      if (n1 < 0) {\n        n1 = len + n1;\n      }\n      if (!empty1 && (n1 < 0 || n1 >= len)) {\n        // For a range we allow invalid values and return an empty\n        // list.  A list index out of range is an error.\n        if (!range) {\n          if (verbose) {\n            EMSGN(_(e_listidx), n1);\n          }\n          return FAIL;\n        }\n        n1 = len;\n      }\n      if (range) {\n        list_T *l;\n        listitem_T *item;\n\n        if (n2 < 0) {\n          n2 = len + n2;\n        } else if (n2 >= len) {\n          n2 = len - 1;\n        }\n        if (!empty2 && (n2 < 0 || n2 + 1 < n1)) {\n          n2 = -1;\n        }\n        l = tv_list_alloc(n2 - n1 + 1);\n        item = tv_list_find(rettv->vval.v_list, n1);\n        while (n1++ <= n2) {\n          tv_list_append_tv(l, TV_LIST_ITEM_TV(item));\n          item = TV_LIST_ITEM_NEXT(rettv->vval.v_list, item);\n        }\n        tv_clear(rettv);\n        tv_list_set_ret(rettv, l);\n      } else {\n        tv_copy(TV_LIST_ITEM_TV(tv_list_find(rettv->vval.v_list, n1)), &var1);\n        tv_clear(rettv);\n        *rettv = var1;\n      }\n      break;\n    case VAR_DICT: {\n      if (range) {\n        if (verbose) {\n          EMSG(_(e_dictrange));\n        }\n        if (len == -1) {\n          tv_clear(&var1);\n        }\n        return FAIL;\n      }\n\n      if (len == -1) {\n        key = (char_u *)tv_get_string_chk(&var1);\n        if (key == NULL) {\n          tv_clear(&var1);\n          return FAIL;\n        }\n      }\n\n      dictitem_T *const item = tv_dict_find(rettv->vval.v_dict,\n                                            (const char *)key, len);\n\n      if (item == NULL && verbose) {\n        emsgf(_(e_dictkey), key);\n      }\n      if (len == -1) {\n        tv_clear(&var1);\n      }\n      if (item == NULL || tv_is_luafunc(&item->di_tv)) {\n        return FAIL;\n      }\n\n      tv_copy(&item->di_tv, &var1);\n      tv_clear(rettv);\n      *rettv = var1;\n      break;\n    }\n    case VAR_BOOL:\n    case VAR_SPECIAL:\n    case VAR_FUNC:\n    case VAR_FLOAT:\n    case VAR_PARTIAL:\n    case VAR_UNKNOWN:\n      break;  // Not evaluating, skipping over subscript\n    }\n  }\n\n  return OK;\n}\n\n// TODO(ZyX-I): move to eval/executor\n\n/// Get an option value\n///\n/// @param[in,out]  arg  Points to the '&' or '+' before the option name. Is\n///                      advanced to the character after the option name.\n/// @param[out]  rettv  Location where result is saved.\n/// @param[in]  evaluate  If not true, rettv is not populated.\n///\n/// @return OK or FAIL.\nint get_option_tv(const char **const arg, typval_T *const rettv, const bool evaluate)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  long numval;\n  char_u *stringval;\n  int opt_type;\n  int c;\n  bool working = (**arg == '+');  // has(\"+option\")\n  int ret = OK;\n  int opt_flags;\n\n  // Isolate the option name and find its value.\n  char *option_end = (char *)find_option_end(arg, &opt_flags);\n  if (option_end == NULL) {\n    if (rettv != NULL) {\n      EMSG2(_(\"E112: Option name missing: %s\"), *arg);\n    }\n    return FAIL;\n  }\n\n  if (!evaluate) {\n    *arg = option_end;\n    return OK;\n  }\n\n  c = *option_end;\n  *option_end = NUL;\n  opt_type = get_option_value(*arg, &numval,\n                              rettv == NULL ? NULL : &stringval, opt_flags);\n\n  if (opt_type == -3) {                 // invalid name\n    if (rettv != NULL) {\n      EMSG2(_(\"E113: Unknown option: %s\"), *arg);\n    }\n    ret = FAIL;\n  } else if (rettv != NULL) {\n    if (opt_type == -2) {               // hidden string option\n      rettv->v_type = VAR_STRING;\n      rettv->vval.v_string = NULL;\n    } else if (opt_type == -1) {      // hidden number option\n      rettv->v_type = VAR_NUMBER;\n      rettv->vval.v_number = 0;\n    } else if (opt_type == 1) {       // number option\n      rettv->v_type = VAR_NUMBER;\n      rettv->vval.v_number = numval;\n    } else {                          // string option\n      rettv->v_type = VAR_STRING;\n      rettv->vval.v_string = stringval;\n    }\n  } else if (working && (opt_type == -2 || opt_type == -1)) {\n    ret = FAIL;\n  }\n\n  *option_end = c;                  // put back for error messages\n  *arg = option_end;\n\n  return ret;\n}\n\n/*\n * Allocate a variable for a string constant.\n * Return OK or FAIL.\n */\nstatic int get_string_tv(char_u **arg, typval_T *rettv, int evaluate)\n{\n  char_u *p;\n  unsigned int extra = 0;\n\n  /*\n   * Find the end of the string, skipping backslashed characters.\n   */\n  for (p = *arg + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p)) {\n    if (*p == '\\\\' && p[1] != NUL) {\n      p++;\n      // A \"\\<x>\" form occupies at least 4 characters, and produces up\n      // to 21 characters (3 * 6 for the char and 3 for a modifier):\n      // reserve space for 18 extra.\n      // Each byte in the char could be encoded as K_SPECIAL K_EXTRA x.\n      if (*p == '<') {\n        extra += 18;\n      }\n    }\n  }\n\n  if (*p != '\"') {\n    EMSG2(_(\"E114: Missing quote: %s\"), *arg);\n    return FAIL;\n  }\n\n  // If only parsing, set *arg and return here\n  if (!evaluate) {\n    *arg = p + 1;\n    return OK;\n  }\n\n  /*\n   * Copy the string into allocated memory, handling backslashed\n   * characters.\n   */\n  const int len = (int)(p - *arg + extra);\n  char_u *name = xmalloc(len);\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = name;\n\n  for (p = *arg + 1; *p != NUL && *p != '\"'; ) {\n    if (*p == '\\\\') {\n      switch (*++p) {\n      case 'b':\n        *name++ = BS; ++p; break;\n      case 'e':\n        *name++ = ESC; ++p; break;\n      case 'f':\n        *name++ = FF; ++p; break;\n      case 'n':\n        *name++ = NL; ++p; break;\n      case 'r':\n        *name++ = CAR; ++p; break;\n      case 't':\n        *name++ = TAB; ++p; break;\n\n      case 'X':           // hex: \"\\x1\", \"\\x12\"\n      case 'x':\n      case 'u':           // Unicode: \"\\u0023\"\n      case 'U':\n        if (ascii_isxdigit(p[1])) {\n          int n, nr;\n          int c = toupper(*p);\n\n          if (c == 'X') {\n            n = 2;\n          } else if (*p == 'u') {\n            n = 4;\n          } else {\n            n = 8;\n          }\n          nr = 0;\n          while (--n >= 0 && ascii_isxdigit(p[1])) {\n            ++p;\n            nr = (nr << 4) + hex2nr(*p);\n          }\n          ++p;\n          /* For \"\\u\" store the number according to\n           * 'encoding'. */\n          if (c != 'X') {\n            name += utf_char2bytes(nr, name);\n          } else {\n            *name++ = nr;\n          }\n        }\n        break;\n\n      // octal: \"\\1\", \"\\12\", \"\\123\"\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n        *name = *p++ - '0';\n        if (*p >= '0' && *p <= '7') {\n          *name = (*name << 3) + *p++ - '0';\n          if (*p >= '0' && *p <= '7') {\n            *name = (*name << 3) + *p++ - '0';\n          }\n        }\n        ++name;\n        break;\n\n      // Special key, e.g.: \"\\<C-W>\"\n      case '<':\n        extra = trans_special((const char_u **)&p, STRLEN(p), name, true, true);\n        if (extra != 0) {\n          name += extra;\n          if (name >= rettv->vval.v_string + len) {\n            iemsg(\"get_string_tv() used more space than allocated\");\n          }\n          break;\n        }\n        FALLTHROUGH;\n\n      default:\n        MB_COPY_CHAR(p, name);\n        break;\n      }\n    } else {\n      MB_COPY_CHAR(p, name);\n    }\n  }\n  *name = NUL;\n  if (*p != NUL) {  // just in case\n    p++;\n  }\n  *arg = p;\n\n  return OK;\n}\n\n/*\n * Allocate a variable for a 'str''ing' constant.\n * Return OK or FAIL.\n */\nstatic int get_lit_string_tv(char_u **arg, typval_T *rettv, int evaluate)\n{\n  char_u *p;\n  char_u *str;\n  int reduce = 0;\n\n  /*\n   * Find the end of the string, skipping ''.\n   */\n  for (p = *arg + 1; *p != NUL; MB_PTR_ADV(p)) {\n    if (*p == '\\'') {\n      if (p[1] != '\\'') {\n        break;\n      }\n      ++reduce;\n      ++p;\n    }\n  }\n\n  if (*p != '\\'') {\n    EMSG2(_(\"E115: Missing quote: %s\"), *arg);\n    return FAIL;\n  }\n\n  // If only parsing return after setting \"*arg\"\n  if (!evaluate) {\n    *arg = p + 1;\n    return OK;\n  }\n\n  /*\n   * Copy the string into allocated memory, handling '' to ' reduction.\n   */\n  str = xmalloc((p - *arg) - reduce);\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = str;\n\n  for (p = *arg + 1; *p != NUL; ) {\n    if (*p == '\\'') {\n      if (p[1] != '\\'') {\n        break;\n      }\n      ++p;\n    }\n    MB_COPY_CHAR(p, str);\n  }\n  *str = NUL;\n  *arg = p + 1;\n\n  return OK;\n}\n\n/// @return the function name of the partial.\nchar_u *partial_name(partial_T *pt)\n{\n  if (pt->pt_name != NULL) {\n    return pt->pt_name;\n  }\n  return pt->pt_func->uf_name;\n}\n\n// TODO(ZyX-I): Move to eval/typval.h\n\nstatic void partial_free(partial_T *pt)\n{\n  for (int i = 0; i < pt->pt_argc; i++) {\n    tv_clear(&pt->pt_argv[i]);\n  }\n  xfree(pt->pt_argv);\n  tv_dict_unref(pt->pt_dict);\n  if (pt->pt_name != NULL) {\n    func_unref(pt->pt_name);\n    xfree(pt->pt_name);\n  } else {\n    func_ptr_unref(pt->pt_func);\n  }\n  xfree(pt);\n}\n\n// TODO(ZyX-I): Move to eval/typval.h\n\n/// Unreference a closure: decrement the reference count and free it when it\n/// becomes zero.\nvoid partial_unref(partial_T *pt)\n{\n  if (pt != NULL && --pt->pt_refcount <= 0) {\n    partial_free(pt);\n  }\n}\n\n/// Allocate a variable for a List and fill it from \"*arg\".\n/// Return OK or FAIL.\nstatic int get_list_tv(char_u **arg, typval_T *rettv, int evaluate)\n{\n  list_T *l = NULL;\n\n  if (evaluate) {\n    l = tv_list_alloc(kListLenShouldKnow);\n  }\n\n  *arg = skipwhite(*arg + 1);\n  while (**arg != ']' && **arg != NUL) {\n    typval_T tv;\n    if (eval1(arg, &tv, evaluate) == FAIL) {  // Recursive!\n      goto failret;\n    }\n    if (evaluate) {\n      tv.v_lock = VAR_UNLOCKED;\n      tv_list_append_owned_tv(l, tv);\n    }\n\n    if (**arg == ']') {\n      break;\n    }\n    if (**arg != ',') {\n      emsgf(_(\"E696: Missing comma in List: %s\"), *arg);\n      goto failret;\n    }\n    *arg = skipwhite(*arg + 1);\n  }\n\n  if (**arg != ']') {\n    emsgf(_(\"E697: Missing end of List ']': %s\"), *arg);\nfailret:\n    if (evaluate) {\n      tv_list_free(l);\n    }\n    return FAIL;\n  }\n\n  *arg = skipwhite(*arg + 1);\n  if (evaluate) {\n    tv_list_set_ret(rettv, l);\n  }\n\n  return OK;\n}\n\n/// @param ic  ignore case\nbool func_equal(typval_T *tv1, typval_T *tv2, bool ic) {\n  char_u *s1, *s2;\n  dict_T *d1, *d2;\n  int a1, a2;\n\n  // empty and NULL function name considered the same\n  s1 = tv1->v_type == VAR_FUNC ? tv1->vval.v_string\n                               : partial_name(tv1->vval.v_partial);\n  if (s1 != NULL && *s1 == NUL) {\n    s1 = NULL;\n  }\n  s2 = tv2->v_type == VAR_FUNC ? tv2->vval.v_string\n                               : partial_name(tv2->vval.v_partial);\n  if (s2 != NULL && *s2 == NUL) {\n    s2 = NULL;\n  }\n  if (s1 == NULL || s2 == NULL) {\n    if (s1 != s2) {\n      return false;\n    }\n  } else if (STRCMP(s1, s2) != 0) {\n    return false;\n  }\n\n  // empty dict and NULL dict is different\n  d1 = tv1->v_type == VAR_FUNC ? NULL : tv1->vval.v_partial->pt_dict;\n  d2 = tv2->v_type == VAR_FUNC ? NULL : tv2->vval.v_partial->pt_dict;\n  if (d1 == NULL || d2 == NULL) {\n    if (d1 != d2) {\n      return false;\n    }\n  } else if (!tv_dict_equal(d1, d2, ic, true)) {\n    return false;\n  }\n\n  // empty list and no list considered the same\n  a1 = tv1->v_type == VAR_FUNC ? 0 : tv1->vval.v_partial->pt_argc;\n  a2 = tv2->v_type == VAR_FUNC ? 0 : tv2->vval.v_partial->pt_argc;\n  if (a1 != a2) {\n    return false;\n  }\n  for (int i = 0; i < a1; i++) {\n    if (!tv_equal(tv1->vval.v_partial->pt_argv + i,\n                  tv2->vval.v_partial->pt_argv + i, ic, true)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Get next (unique) copy ID\n///\n/// Used for traversing nested structures e.g. when serializing them or garbage\n/// collecting.\nint get_copyID(void)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // CopyID for recursively traversing lists and dicts\n  //\n  // This value is needed to avoid endless recursiveness. Last bit is used for\n  // previous_funccal and normally ignored when comparing.\n  static int current_copyID = 0;\n  current_copyID += COPYID_INC;\n  return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *      :let l = [1, 2, 3]\n *      :let d = {9: l}\n *      :let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *      http://python.ca/nas/python/gc/\n */\n\n/// Do garbage collection for lists and dicts.\n///\n/// @param testing  true if called from test_garbagecollect_now().\n/// @returns        true if some memory was freed.\nbool garbage_collect(bool testing)\n{\n  bool abort = false;\n#define ABORTING(func) abort = abort || func\n\n  if (!testing) {\n    // Only do this once.\n    want_garbage_collect = false;\n    may_garbage_collect = false;\n    garbage_collect_at_exit = false;\n  }\n\n  // We advance by two (COPYID_INC) because we add one for items referenced\n  // through previous_funccal.\n  const int copyID = get_copyID();\n\n  // 1. Go through all accessible variables and mark all lists and dicts\n  // with copyID.\n\n  // Don't free variables in the previous_funccal list unless they are only\n  // referenced through previous_funccal.  This must be first, because if\n  // the item is referenced elsewhere the funccal must not be freed.\n  ABORTING(set_ref_in_previous_funccal)(copyID);\n\n  // script-local variables\n  for (int i = 1; i <= ga_scripts.ga_len; ++i) {\n    ABORTING(set_ref_in_ht)(&SCRIPT_VARS(i), copyID, NULL);\n  }\n\n  FOR_ALL_BUFFERS(buf) {\n    // buffer-local variables\n    ABORTING(set_ref_in_item)(&buf->b_bufvar.di_tv, copyID, NULL, NULL);\n    // buffer marks (ShaDa additional data)\n    ABORTING(set_ref_in_fmark)(buf->b_last_cursor, copyID);\n    ABORTING(set_ref_in_fmark)(buf->b_last_insert, copyID);\n    ABORTING(set_ref_in_fmark)(buf->b_last_change, copyID);\n    for (size_t i = 0; i < NMARKS; i++) {\n      ABORTING(set_ref_in_fmark)(buf->b_namedm[i], copyID);\n    }\n    // buffer change list (ShaDa additional data)\n    for (int i = 0; i < buf->b_changelistlen; i++) {\n      ABORTING(set_ref_in_fmark)(buf->b_changelist[i], copyID);\n    }\n    // buffer ShaDa additional data\n    ABORTING(set_ref_dict)(buf->additional_data, copyID);\n\n    // buffer callback functions\n    set_ref_in_callback(&buf->b_prompt_callback, copyID, NULL, NULL);\n    set_ref_in_callback(&buf->b_prompt_interrupt, copyID, NULL, NULL);\n  }\n\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    // window-local variables\n    ABORTING(set_ref_in_item)(&wp->w_winvar.di_tv, copyID, NULL, NULL);\n    // window jump list (ShaDa additional data)\n    for (int i = 0; i < wp->w_jumplistlen; i++) {\n      ABORTING(set_ref_in_fmark)(wp->w_jumplist[i].fmark, copyID);\n    }\n  }\n  if (aucmd_win != NULL) {\n    ABORTING(set_ref_in_item)(&aucmd_win->w_winvar.di_tv, copyID, NULL, NULL);\n  }\n\n  // registers (ShaDa additional data)\n  {\n    const void *reg_iter = NULL;\n    do {\n      yankreg_T reg;\n      char name = NUL;\n      bool is_unnamed = false;\n      reg_iter = op_global_reg_iter(reg_iter, &name, &reg, &is_unnamed);\n      if (name != NUL) {\n        ABORTING(set_ref_dict)(reg.additional_data, copyID);\n      }\n    } while (reg_iter != NULL);\n  }\n\n  // global marks (ShaDa additional data)\n  {\n    const void *mark_iter = NULL;\n    do {\n      xfmark_T fm;\n      char name = NUL;\n      mark_iter = mark_global_iter(mark_iter, &name, &fm);\n      if (name != NUL) {\n        ABORTING(set_ref_dict)(fm.fmark.additional_data, copyID);\n      }\n    } while (mark_iter != NULL);\n  }\n\n  // tabpage-local variables\n  FOR_ALL_TABS(tp) {\n    ABORTING(set_ref_in_item)(&tp->tp_winvar.di_tv, copyID, NULL, NULL);\n  }\n\n  // global variables\n  ABORTING(set_ref_in_ht)(&globvarht, copyID, NULL);\n\n  // function-local variables\n  ABORTING(set_ref_in_call_stack)(copyID);\n\n  // named functions (matters for closures)\n  ABORTING(set_ref_in_functions)(copyID);\n\n  // Channels\n  {\n    Channel *data;\n    map_foreach_value(&channels, data, {\n      set_ref_in_callback_reader(&data->on_data, copyID, NULL, NULL);\n      set_ref_in_callback_reader(&data->on_stderr, copyID, NULL, NULL);\n      set_ref_in_callback(&data->on_exit, copyID, NULL, NULL);\n    })\n  }\n\n  // Timers\n  {\n    timer_T *timer;\n    map_foreach_value(&timers, timer, {\n      set_ref_in_callback(&timer->callback, copyID, NULL, NULL);\n    })\n  }\n\n  // function call arguments, if v:testing is set.\n  ABORTING(set_ref_in_func_args)(copyID);\n\n  // v: vars\n  ABORTING(set_ref_in_ht)(&vimvarht, copyID, NULL);\n\n  // history items (ShaDa additional elements)\n  if (p_hi) {\n    for (uint8_t i = 0; i < HIST_COUNT; i++) {\n      const void *iter = NULL;\n      do {\n        histentry_T hist;\n        iter = hist_iter(iter, i, false, &hist);\n        if (hist.hisstr != NULL) {\n          ABORTING(set_ref_list)(hist.additional_elements, copyID);\n        }\n      } while (iter != NULL);\n    }\n  }\n\n  // previously used search/substitute patterns (ShaDa additional data)\n  {\n    SearchPattern pat;\n    get_search_pattern(&pat);\n    ABORTING(set_ref_dict)(pat.additional_data, copyID);\n    get_substitute_pattern(&pat);\n    ABORTING(set_ref_dict)(pat.additional_data, copyID);\n  }\n\n  // previously used replacement string\n  {\n    SubReplacementString sub;\n    sub_get_replacement(&sub);\n    ABORTING(set_ref_list)(sub.additional_elements, copyID);\n  }\n\n  ABORTING(set_ref_in_quickfix)(copyID);\n\n  bool did_free = false;\n  if (!abort) {\n    // 2. Free lists and dictionaries that are not referenced.\n    did_free = free_unref_items(copyID);\n\n    // 3. Check if any funccal can be freed now.\n    //    This may call us back recursively.\n    did_free = free_unref_funccal(copyID, testing) || did_free;\n  } else if (p_verbose > 0) {\n    verb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n  }\n#undef ABORTING\n  return did_free;\n}\n\n/// Free lists and dictionaries that are no longer referenced.\n///\n/// @note This function may only be called from garbage_collect().\n///\n/// @param copyID Free lists/dictionaries that don't have this ID.\n/// @return true, if something was freed.\nstatic int free_unref_items(int copyID)\n{\n  bool did_free = false;\n\n  // Let all \"free\" functions know that we are here. This means no\n  // dictionaries, lists, or jobs are to be freed, because we will\n  // do that here.\n  tv_in_free_unref_items = true;\n\n  // PASS 1: free the contents of the items. We don't free the items\n  // themselves yet, so that it is possible to decrement refcount counters.\n\n  // Go through the list of dicts and free items without the copyID.\n  // Don't free dicts that are referenced internally.\n  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd->dv_used_next) {\n    if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)) {\n      // Free the Dictionary and ordinary items it contains, but don't\n      // recurse into Lists and Dictionaries, they will be in the list\n      // of dicts or list of lists.\n      tv_dict_free_contents(dd);\n      did_free = true;\n    }\n  }\n\n  // Go through the list of lists and free items without the copyID.\n  // But don't free a list that has a watcher (used in a for loop), these\n  // are not referenced anywhere.\n  for (list_T *ll = gc_first_list; ll != NULL; ll = ll->lv_used_next) {\n    if ((tv_list_copyid(ll) & COPYID_MASK) != (copyID & COPYID_MASK)\n        && !tv_list_has_watchers(ll)) {\n      // Free the List and ordinary items it contains, but don't recurse\n      // into Lists and Dictionaries, they will be in the list of dicts\n      // or list of lists.\n      tv_list_free_contents(ll);\n      did_free = true;\n    }\n  }\n\n  // PASS 2: free the items themselves.\n  dict_T *dd_next;\n  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd_next) {\n    dd_next = dd->dv_used_next;\n    if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)) {\n      tv_dict_free_dict(dd);\n    }\n  }\n\n  list_T *ll_next;\n  for (list_T *ll = gc_first_list; ll != NULL; ll = ll_next) {\n    ll_next = ll->lv_used_next;\n    if ((ll->lv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)\n        && !tv_list_has_watchers(ll)) {\n      // Free the List and ordinary items it contains, but don't recurse\n      // into Lists and Dictionaries, they will be in the list of dicts\n      // or list of lists.\n      tv_list_free_list(ll);\n    }\n  }\n  tv_in_free_unref_items = false;\n  return did_free;\n}\n\n/// Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n///\n/// @param ht            Hashtab content will be marked.\n/// @param copyID        New mark for lists and dicts.\n/// @param list_stack    Used to add lists to be marked. Can be NULL.\n///\n/// @returns             true if setting references failed somehow.\nbool set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  bool abort = false;\n  ht_stack_T *ht_stack = NULL;\n\n  hashtab_T *cur_ht = ht;\n  for (;;) {\n    if (!abort) {\n      // Mark each item in the hashtab.  If the item contains a hashtab\n      // it is added to ht_stack, if it contains a list it is added to\n      // list_stack.\n      HASHTAB_ITER(cur_ht, hi, {\n        abort = abort || set_ref_in_item(&TV_DICT_HI2DI(hi)->di_tv, copyID, &ht_stack, list_stack);\n      });\n    }\n\n    if (ht_stack == NULL) {\n      break;\n    }\n\n    // take an item from the stack\n    cur_ht = ht_stack->ht;\n    ht_stack_T *tempitem = ht_stack;\n    ht_stack = ht_stack->prev;\n    xfree(tempitem);\n  }\n\n  return abort;\n}\n\n/// Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n///\n/// @param l             List content will be marked.\n/// @param copyID        New mark for lists and dicts.\n/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.\n///\n/// @returns             true if setting references failed somehow.\nbool set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  bool abort = false;\n  list_stack_T *list_stack = NULL;\n\n  list_T *cur_l = l;\n  for (;;) {\n    // Mark each item in the list.  If the item contains a hashtab\n    // it is added to ht_stack, if it contains a list it is added to\n    // list_stack.\n    TV_LIST_ITER(cur_l, li, {\n      if (abort) {\n        break;\n      }\n      abort = set_ref_in_item(TV_LIST_ITEM_TV(li), copyID, ht_stack,\n                              &list_stack);\n    });\n\n    if (list_stack == NULL) {\n      break;\n    }\n\n    // take an item from the stack\n    cur_l = list_stack->list;\n    list_stack_T *tempitem = list_stack;\n    list_stack = list_stack->prev;\n    xfree(tempitem);\n  }\n\n  return abort;\n}\n\n/// Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n///\n/// @param tv            Typval content will be marked.\n/// @param copyID        New mark for lists and dicts.\n/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.\n/// @param list_stack    Used to add lists to be marked. Can be NULL.\n///\n/// @returns             true if setting references failed somehow.\nbool set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  bool abort = false;\n\n  switch (tv->v_type) {\n  case VAR_DICT: {\n    dict_T *dd = tv->vval.v_dict;\n    if (dd != NULL && dd->dv_copyID != copyID) {\n      // Didn't see this dict yet.\n      dd->dv_copyID = copyID;\n      if (ht_stack == NULL) {\n        abort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n      } else {\n        ht_stack_T *const newitem = xmalloc(sizeof(ht_stack_T));\n        newitem->ht = &dd->dv_hashtab;\n        newitem->prev = *ht_stack;\n        *ht_stack = newitem;\n      }\n\n      QUEUE *w = NULL;\n      DictWatcher *watcher = NULL;\n      QUEUE_FOREACH(w, &dd->watchers, {\n          watcher = tv_dict_watcher_node_data(w);\n          set_ref_in_callback(&watcher->callback, copyID, ht_stack, list_stack);\n        })\n    }\n    break;\n  }\n\n  case VAR_LIST: {\n    list_T *ll = tv->vval.v_list;\n    if (ll != NULL && ll->lv_copyID != copyID) {\n      // Didn't see this list yet.\n      ll->lv_copyID = copyID;\n      if (list_stack == NULL) {\n        abort = set_ref_in_list(ll, copyID, ht_stack);\n      } else {\n        list_stack_T *const newitem = xmalloc(sizeof(list_stack_T));\n        newitem->list = ll;\n        newitem->prev = *list_stack;\n        *list_stack = newitem;\n      }\n    }\n    break;\n  }\n\n  case VAR_PARTIAL: {\n    partial_T *pt = tv->vval.v_partial;\n\n    // A partial does not have a copyID, because it cannot contain itself.\n    if (pt != NULL) {\n      abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n      if (pt->pt_dict != NULL) {\n        typval_T dtv;\n\n        dtv.v_type = VAR_DICT;\n        dtv.vval.v_dict = pt->pt_dict;\n        abort = abort || set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n      }\n\n      for (int i = 0; i < pt->pt_argc; i++) {\n        abort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n                                         ht_stack, list_stack);\n      }\n    }\n    break;\n  }\n  case VAR_FUNC:\n    abort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    break;\n  case VAR_UNKNOWN:\n  case VAR_BOOL:\n  case VAR_SPECIAL:\n  case VAR_FLOAT:\n  case VAR_NUMBER:\n  case VAR_STRING:\n  case VAR_BLOB:\n    break;\n  }\n  return abort;\n}\n\n\n\n/// Mark all lists and dicts referenced in given mark\n///\n/// @returns true if setting references failed somehow.\nstatic inline bool set_ref_in_fmark(fmark_T fm, int copyID)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (fm.additional_data != NULL\n      && fm.additional_data->dv_copyID != copyID) {\n    fm.additional_data->dv_copyID = copyID;\n    return set_ref_in_ht(&fm.additional_data->dv_hashtab, copyID, NULL);\n  }\n  return false;\n}\n\n/// Mark all lists and dicts referenced in given list and the list itself\n///\n/// @returns true if setting references failed somehow.\nstatic inline bool set_ref_list(list_T *list, int copyID)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (list != NULL) {\n    typval_T tv = (typval_T) {\n      .v_type = VAR_LIST,\n      .vval = { .v_list = list }\n    };\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n  }\n  return false;\n}\n\n/// Mark all lists and dicts referenced in given dict and the dict itself\n///\n/// @returns true if setting references failed somehow.\nstatic inline bool set_ref_dict(dict_T *dict, int copyID)\n  FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (dict != NULL) {\n    typval_T tv = (typval_T) {\n      .v_type = VAR_DICT,\n      .vval = { .v_dict = dict }\n    };\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n  }\n  return false;\n}\n\n\n// Get the key for *{key: val} into \"tv\" and advance \"arg\".\n// Return FAIL when there is no valid key.\nstatic int get_literal_key(char_u **arg, typval_T *tv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u *p;\n\n  if (!ASCII_ISALNUM(**arg) && **arg != '_' && **arg != '-') {\n    return FAIL;\n  }\n  for (p = *arg; ASCII_ISALNUM(*p) || *p == '_' || *p == '-'; p++) {\n  }\n  tv->v_type = VAR_STRING;\n  tv->vval.v_string = vim_strnsave(*arg, p - *arg);\n\n  *arg = skipwhite(p);\n  return OK;\n}\n\n// Allocate a variable for a Dictionary and fill it from \"*arg\".\n// \"literal\" is true for *{key: val}\n// Return OK or FAIL.  Returns NOTDONE for {expr}.\nstatic int dict_get_tv(char_u **arg, typval_T *rettv, int evaluate, bool literal)\n{\n  dict_T *d = NULL;\n  typval_T tvkey;\n  typval_T tv;\n  char_u *key = NULL;\n  dictitem_T *item;\n  char_u *start = skipwhite(*arg + 1);\n  char buf[NUMBUFLEN];\n\n  /*\n   * First check if it's not a curly-braces thing: {expr}.\n   * Must do this without evaluating, otherwise a function may be called\n   * twice.  Unfortunately this means we need to call eval1() twice for the\n   * first item.\n   * But {} is an empty Dictionary.\n   */\n  if (*start != '}') {\n    if (eval1(&start, &tv, false) == FAIL) {    // recursive!\n      return FAIL;\n    }\n    if (*skipwhite(start) == '}') {\n      return NOTDONE;\n    }\n  }\n\n  if (evaluate) {\n    d = tv_dict_alloc();\n  }\n  tvkey.v_type = VAR_UNKNOWN;\n  tv.v_type = VAR_UNKNOWN;\n\n  *arg = skipwhite(*arg + 1);\n  while (**arg != '}' && **arg != NUL) {\n    if ((literal\n         ? get_literal_key(arg, &tvkey)\n         : eval1(arg, &tvkey, evaluate)) == FAIL) {  // recursive!\n      goto failret;\n    }\n    if (**arg != ':') {\n      EMSG2(_(\"E720: Missing colon in Dictionary: %s\"), *arg);\n      tv_clear(&tvkey);\n      goto failret;\n    }\n    if (evaluate) {\n      key = (char_u *)tv_get_string_buf_chk(&tvkey, buf);\n      if (key == NULL) {\n        // \"key\" is NULL when tv_get_string_buf_chk() gave an errmsg\n        tv_clear(&tvkey);\n        goto failret;\n      }\n    }\n\n    *arg = skipwhite(*arg + 1);\n    if (eval1(arg, &tv, evaluate) == FAIL) {  // Recursive!\n      if (evaluate) {\n        tv_clear(&tvkey);\n      }\n      goto failret;\n    }\n    if (evaluate) {\n      item = tv_dict_find(d, (const char *)key, -1);\n      if (item != NULL) {\n        EMSG2(_(\"E721: Duplicate key in Dictionary: \\\"%s\\\"\"), key);\n        tv_clear(&tvkey);\n        tv_clear(&tv);\n        goto failret;\n      }\n      item = tv_dict_item_alloc((const char *)key);\n      item->di_tv = tv;\n      item->di_tv.v_lock = VAR_UNLOCKED;\n      if (tv_dict_add(d, item) == FAIL) {\n        tv_dict_item_free(item);\n      }\n    }\n    tv_clear(&tvkey);\n\n    if (**arg == '}') {\n      break;\n    }\n    if (**arg != ',') {\n      EMSG2(_(\"E722: Missing comma in Dictionary: %s\"), *arg);\n      goto failret;\n    }\n    *arg = skipwhite(*arg + 1);\n  }\n\n  if (**arg != '}') {\n    EMSG2(_(\"E723: Missing end of Dictionary '}': %s\"), *arg);\nfailret:\n    if (d != NULL) {\n      tv_dict_free(d);\n    }\n    return FAIL;\n  }\n\n  *arg = skipwhite(*arg + 1);\n  if (evaluate) {\n    tv_dict_set_ret(rettv, d);\n  }\n\n  return OK;\n}\n\n/// Convert the string to a floating point number\n///\n/// This uses strtod().  setlocale(LC_NUMERIC, \"C\") has been used earlier to\n/// make sure this always uses a decimal point.\n///\n/// @param[in]  text  String to convert.\n/// @param[out]  ret_value  Location where conversion result is saved.\n///\n/// @return Length of the text that was consumed.\nsize_t string2float(const char *const text, float_T *const ret_value)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char *s = NULL;\n\n  // MS-Windows does not deal with \"inf\" and \"nan\" properly\n  if (STRNICMP(text, \"inf\", 3) == 0) {\n    *ret_value = INFINITY;\n    return 3;\n  }\n  if (STRNICMP(text, \"-inf\", 3) == 0) {\n    *ret_value = -INFINITY;\n    return 4;\n  }\n  if (STRNICMP(text, \"nan\", 3) == 0) {\n    *ret_value = NAN;\n    return 3;\n  }\n  *ret_value = strtod(text, &s);\n  return (size_t)(s - text);\n}\n\n/// Get the value of an environment variable.\n///\n/// If the environment variable was not set, silently assume it is empty.\n///\n/// @param arg Points to the '$'.  It is advanced to after the name.\n/// @return FAIL if the name is invalid.\n///\nstatic int get_env_tv(char_u **arg, typval_T *rettv, int evaluate)\n{\n  char_u *name;\n  char_u *string = NULL;\n  int     len;\n  int     cc;\n\n  ++*arg;\n  name = *arg;\n  len = get_env_len((const char_u **)arg);\n\n  if (evaluate) {\n    if (len == 0) {\n      return FAIL;  // Invalid empty name.\n    }\n    cc = name[len];\n    name[len] = NUL;\n    // First try vim_getenv(), fast for normal environment vars.\n    string = (char_u *)vim_getenv((char *)name);\n    if (string == NULL || *string == NUL) {\n      xfree(string);\n\n      // Next try expanding things like $VIM and ${HOME}.\n      string = expand_env_save(name - 1);\n      if (string != NULL && *string == '$') {\n        XFREE_CLEAR(string);\n      }\n    }\n    name[len] = cc;\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = string;\n  }\n\n  return OK;\n}\n\n/// Get the argument list for a given window\nvoid get_arglist_as_rettv(aentry_T *arglist, int argcount, typval_T *rettv)\n{\n  tv_list_alloc_ret(rettv, argcount);\n  if (arglist != NULL) {\n    for (int idx = 0; idx < argcount; idx++) {\n      tv_list_append_string(rettv->vval.v_list,\n                            (const char *)alist_name(&arglist[idx]), -1);\n    }\n  }\n}\n\n// Prepare \"gap\" for an assert error and add the sourcing position.\nvoid prepare_assert_error(garray_T *gap)\n{\n  char buf[NUMBUFLEN];\n\n  ga_init(gap, 1, 100);\n  if (sourcing_name != NULL) {\n    ga_concat(gap, sourcing_name);\n    if (sourcing_lnum > 0) {\n      ga_concat(gap, (char_u *)\" \");\n    }\n  }\n  if (sourcing_lnum > 0) {\n    vim_snprintf(buf, ARRAY_SIZE(buf), \"line %\" PRId64, (int64_t)sourcing_lnum);\n    ga_concat(gap, (char_u *)buf);\n  }\n  if (sourcing_name != NULL || sourcing_lnum > 0) {\n    ga_concat(gap, (char_u *)\": \");\n  }\n}\n\n// Append \"p[clen]\" to \"gap\", escaping unprintable characters.\n// Changes NL to \\n, CR to \\r, etc.\nstatic void ga_concat_esc(garray_T *gap, const char_u *p, int clen)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char_u buf[NUMBUFLEN];\n\n  if (clen > 1) {\n    memmove(buf, p, clen);\n    buf[clen] = NUL;\n    ga_concat(gap, buf);\n  } else {\n    switch (*p) {\n    case BS:\n      ga_concat(gap, (char_u *)\"\\\\b\"); break;\n    case ESC:\n      ga_concat(gap, (char_u *)\"\\\\e\"); break;\n    case FF:\n      ga_concat(gap, (char_u *)\"\\\\f\"); break;\n    case NL:\n      ga_concat(gap, (char_u *)\"\\\\n\"); break;\n    case TAB:\n      ga_concat(gap, (char_u *)\"\\\\t\"); break;\n    case CAR:\n      ga_concat(gap, (char_u *)\"\\\\r\"); break;\n    case '\\\\':\n      ga_concat(gap, (char_u *)\"\\\\\\\\\"); break;\n    default:\n      if (*p < ' ') {\n        vim_snprintf((char *)buf, NUMBUFLEN, \"\\\\x%02x\", *p);\n        ga_concat(gap, buf);\n      } else {\n        ga_append(gap, *p);\n      }\n      break;\n    }\n  }\n}\n\n// Append \"str\" to \"gap\", escaping unprintable characters.\n// Changes NL to \\n, CR to \\r, etc.\nstatic void ga_concat_shorten_esc(garray_T *gap, const char_u *str)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  char_u buf[NUMBUFLEN];\n\n  if (str == NULL) {\n    ga_concat(gap, (char_u *)\"NULL\");\n    return;\n  }\n\n  for (const char_u *p = str; *p != NUL; p++) {\n    int same_len = 1;\n    const char_u *s = p;\n    const int c = mb_ptr2char_adv(&s);\n    const int clen = s - p;\n    while (*s != NUL && c == utf_ptr2char(s)) {\n      same_len++;\n      s += clen;\n    }\n    if (same_len > 20) {\n      ga_concat(gap, (char_u *)\"\\\\[\");\n      ga_concat_esc(gap, p, clen);\n      ga_concat(gap, (char_u *)\" occurs \");\n      vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n      ga_concat(gap, buf);\n      ga_concat(gap, (char_u *)\" times]\");\n      p = s - 1;\n    } else {\n      ga_concat_esc(gap, p, clen);\n    }\n  }\n}\n\n// Fill \"gap\" with information about an assert error.\nvoid fill_assert_error(garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv,\n                       typval_T *got_tv, assert_type_T atype)\n{\n  char_u *tofree;\n\n  if (opt_msg_tv->v_type != VAR_UNKNOWN) {\n    tofree = (char_u *)encode_tv2echo(opt_msg_tv, NULL);\n    ga_concat(gap, tofree);\n    xfree(tofree);\n    ga_concat(gap, (char_u *)\": \");\n  }\n\n  if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH) {\n    ga_concat(gap, (char_u *)\"Pattern \");\n  } else if (atype == ASSERT_NOTEQUAL) {\n    ga_concat(gap, (char_u *)\"Expected not equal to \");\n  } else {\n    ga_concat(gap, (char_u *)\"Expected \");\n  }\n\n  if (exp_str == NULL) {\n    tofree = (char_u *)encode_tv2string(exp_tv, NULL);\n    ga_concat_shorten_esc(gap, tofree);\n    xfree(tofree);\n  } else {\n    ga_concat_shorten_esc(gap, exp_str);\n  }\n\n  if (atype != ASSERT_NOTEQUAL) {\n    if (atype == ASSERT_MATCH) {\n      ga_concat(gap, (char_u *)\" does not match \");\n    } else if (atype == ASSERT_NOTMATCH) {\n      ga_concat(gap, (char_u *)\" does match \");\n    } else {\n      ga_concat(gap, (char_u *)\" but got \");\n    }\n    tofree = (char_u *)encode_tv2string(got_tv, NULL);\n    ga_concat_shorten_esc(gap, tofree);\n    xfree(tofree);\n  }\n}\n\n// Add an assert error to v:errors.\nvoid assert_error(garray_T *gap)\n{\n  struct vimvar *vp = &vimvars[VV_ERRORS];\n\n  if (vp->vv_type != VAR_LIST || vimvars[VV_ERRORS].vv_list == NULL) {\n    // Make sure v:errors is a list.\n    set_vim_var_list(VV_ERRORS, tv_list_alloc(1));\n  }\n  tv_list_append_string(vimvars[VV_ERRORS].vv_list,\n                        (const char *)gap->ga_data, (ptrdiff_t)gap->ga_len);\n}\n\nint assert_equal_common(typval_T *argvars, assert_type_T atype)\n  FUNC_ATTR_NONNULL_ALL\n{\n  garray_T ga;\n\n  if (tv_equal(&argvars[0], &argvars[1], false, false)\n      != (atype == ASSERT_EQUAL)) {\n    prepare_assert_error(&ga);\n    fill_assert_error(&ga, &argvars[2], NULL,\n                      &argvars[0], &argvars[1], atype);\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  }\n  return 0;\n}\n\nint assert_equalfile(typval_T *argvars)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char buf1[NUMBUFLEN];\n  char buf2[NUMBUFLEN];\n  const char *const fname1 = tv_get_string_buf_chk(&argvars[0], buf1);\n  const char *const fname2 = tv_get_string_buf_chk(&argvars[1], buf2);\n  garray_T ga;\n\n  if (fname1 == NULL || fname2 == NULL) {\n    return 0;\n  }\n\n  IObuff[0] = NUL;\n  FILE *const fd1 = os_fopen(fname1, READBIN);\n  char line1[200];\n  char line2[200];\n  ptrdiff_t lineidx = 0;\n  if (fd1 == NULL) {\n    snprintf((char *)IObuff, IOSIZE, (char *)e_notread, fname1);\n  } else {\n    FILE *const fd2 = os_fopen(fname2, READBIN);\n    if (fd2 == NULL) {\n      fclose(fd1);\n      snprintf((char *)IObuff, IOSIZE, (char *)e_notread, fname2);\n    } else {\n      int64_t linecount = 1;\n      for (int64_t count = 0; ; count++) {\n        const int c1 = fgetc(fd1);\n        const int c2 = fgetc(fd2);\n        if (c1 == EOF) {\n          if (c2 != EOF) {\n            STRCPY(IObuff, \"first file is shorter\");\n          }\n          break;\n        } else if (c2 == EOF) {\n          STRCPY(IObuff, \"second file is shorter\");\n          break;\n        } else {\n          line1[lineidx] = c1;\n          line2[lineidx] = c2;\n          lineidx++;\n          if (c1 != c2) {\n            snprintf((char *)IObuff, IOSIZE,\n                     \"difference at byte %\" PRId64 \", line %\" PRId64,\n                     count, linecount);\n            break;\n          }\n        }\n        if (c1 == NL) {\n          linecount++;\n          lineidx = 0;\n        } else if (lineidx + 2 == (ptrdiff_t)sizeof(line1)) {\n          memmove(line1, line1 + 100, lineidx - 100);\n          memmove(line2, line2 + 100, lineidx - 100);\n          lineidx -= 100;\n        }\n      }\n      fclose(fd1);\n      fclose(fd2);\n    }\n  }\n  if (IObuff[0] != NUL) {\n    prepare_assert_error(&ga);\n    if (argvars[2].v_type != VAR_UNKNOWN) {\n      char *const tofree = encode_tv2echo(&argvars[2], NULL);\n      ga_concat(&ga, (char_u *)tofree);\n      xfree(tofree);\n      ga_concat(&ga, (char_u *)\": \");\n    }\n    ga_concat(&ga, IObuff);\n    if (lineidx > 0) {\n      line1[lineidx] = NUL;\n      line2[lineidx] = NUL;\n      ga_concat(&ga, (char_u *)\" after \\\"\");\n      ga_concat(&ga, (char_u *)line1);\n      if (STRCMP(line1, line2) != 0) {\n        ga_concat(&ga, (char_u *)\"\\\" vs \\\"\");\n        ga_concat(&ga, (char_u *)line2);\n      }\n      ga_concat(&ga, (char_u *)\"\\\"\");\n    }\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  }\n  return 0;\n}\n\nint assert_inrange(typval_T *argvars)\n  FUNC_ATTR_NONNULL_ALL\n{\n  bool error = false;\n\n  if (argvars[0].v_type == VAR_FLOAT\n      || argvars[1].v_type == VAR_FLOAT\n      || argvars[2].v_type == VAR_FLOAT) {\n    const float_T flower = tv_get_float(&argvars[0]);\n    const float_T fupper = tv_get_float(&argvars[1]);\n    const float_T factual = tv_get_float(&argvars[2]);\n\n    if (factual < flower || factual > fupper) {\n      garray_T ga;\n      prepare_assert_error(&ga);\n      if (argvars[3].v_type != VAR_UNKNOWN) {\n        char_u *const tofree = (char_u *)encode_tv2string(&argvars[3], NULL);\n        ga_concat(&ga, tofree);\n        xfree(tofree);\n      } else {\n        char msg[80];\n        vim_snprintf(msg, sizeof(msg), \"Expected range %g - %g, but got %g\",\n                     flower, fupper, factual);\n        ga_concat(&ga, (char_u *)msg);\n      }\n      assert_error(&ga);\n      ga_clear(&ga);\n      return 1;\n    }\n  } else {\n    const varnumber_T lower = tv_get_number_chk(&argvars[0], &error);\n    const varnumber_T upper = tv_get_number_chk(&argvars[1], &error);\n    const varnumber_T actual = tv_get_number_chk(&argvars[2], &error);\n\n    if (error) {\n      return 0;\n    }\n    if (actual < lower || actual > upper) {\n      garray_T ga;\n      prepare_assert_error(&ga);\n\n      char msg[55];\n      vim_snprintf(msg, sizeof(msg),\n                   \"range %\" PRIdVARNUMBER \" - %\" PRIdVARNUMBER \",\",\n                   lower, upper);\n      fill_assert_error(&ga, &argvars[3], (char_u *)msg, NULL, &argvars[2],\n                        ASSERT_INRANGE);\n      assert_error(&ga);\n      ga_clear(&ga);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n// Common for assert_true() and assert_false().\nint assert_bool(typval_T *argvars, bool is_true)\n  FUNC_ATTR_NONNULL_ALL\n{\n  bool error = false;\n  garray_T ga;\n\n  if ((argvars[0].v_type != VAR_NUMBER\n       || (tv_get_number_chk(&argvars[0], &error) == 0) == is_true\n       || error)\n      && (argvars[0].v_type != VAR_BOOL\n          || (argvars[0].vval.v_bool\n              != (BoolVarValue)(is_true\n                                ? kBoolVarTrue\n                                : kBoolVarFalse)))) {\n    prepare_assert_error(&ga);\n    fill_assert_error(&ga, &argvars[1],\n                      (char_u *)(is_true ? \"True\" : \"False\"),\n                      NULL, &argvars[0], ASSERT_OTHER);\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  }\n  return 0;\n}\n\nint assert_exception(typval_T *argvars)\n  FUNC_ATTR_NONNULL_ALL\n{\n  garray_T ga;\n\n  const char *const error = tv_get_string_chk(&argvars[0]);\n  if (vimvars[VV_EXCEPTION].vv_str == NULL) {\n    prepare_assert_error(&ga);\n    ga_concat(&ga, (char_u *)\"v:exception is not set\");\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  } else if (error != NULL\n             && strstr((char *)vimvars[VV_EXCEPTION].vv_str, error) == NULL) {\n    prepare_assert_error(&ga);\n    fill_assert_error(&ga, &argvars[1], NULL, &argvars[0],\n                      &vimvars[VV_EXCEPTION].vv_tv, ASSERT_OTHER);\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  }\n  return 0;\n}\n\nstatic void assert_append_cmd_or_arg(garray_T *gap, typval_T *argvars, const char *cmd)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN) {\n    char *const tofree = encode_tv2echo(&argvars[2], NULL);\n    ga_concat(gap, (char_u *)tofree);\n    xfree(tofree);\n  } else {\n    ga_concat(gap, (char_u *)cmd);\n  }\n}\n\nint assert_beeps(typval_T *argvars, bool no_beep)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char *const cmd = tv_get_string_chk(&argvars[0]);\n  int ret = 0;\n\n  called_vim_beep = false;\n  suppress_errthrow = true;\n  emsg_silent = false;\n  do_cmdline_cmd(cmd);\n  if (no_beep ? called_vim_beep : !called_vim_beep) {\n    garray_T ga;\n    prepare_assert_error(&ga);\n    if (no_beep) {\n      ga_concat(&ga, (const char_u *)\"command did beep: \");\n    } else {\n      ga_concat(&ga, (const char_u *)\"command did not beep: \");\n    }\n    ga_concat(&ga, (const char_u *)cmd);\n    assert_error(&ga);\n    ga_clear(&ga);\n    ret = 1;\n  }\n\n  suppress_errthrow = false;\n  emsg_on_display = false;\n  return ret;\n}\n\nint assert_fails(typval_T *argvars)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const char *const cmd = tv_get_string_chk(&argvars[0]);\n  garray_T    ga;\n  int ret = 0;\n  int         save_trylevel = trylevel;\n\n  // trylevel must be zero for a \":throw\" command to be considered failed\n  trylevel = 0;\n  called_emsg = false;\n  suppress_errthrow = true;\n  emsg_silent = true;\n\n  do_cmdline_cmd(cmd);\n  if (!called_emsg) {\n    prepare_assert_error(&ga);\n    ga_concat(&ga, (const char_u *)\"command did not fail: \");\n    assert_append_cmd_or_arg(&ga, argvars, cmd);\n    assert_error(&ga);\n    ga_clear(&ga);\n    ret = 1;\n  } else if (argvars[1].v_type != VAR_UNKNOWN) {\n    char buf[NUMBUFLEN];\n    const char *const error = tv_get_string_buf_chk(&argvars[1], buf);\n\n    if (error == NULL\n        || strstr((char *)vimvars[VV_ERRMSG].vv_str, error) == NULL) {\n      prepare_assert_error(&ga);\n      fill_assert_error(&ga, &argvars[2], NULL, &argvars[1],\n                        &vimvars[VV_ERRMSG].vv_tv, ASSERT_OTHER);\n      ga_concat(&ga, (char_u *)\": \");\n      assert_append_cmd_or_arg(&ga, argvars, cmd);\n      assert_error(&ga);\n      ga_clear(&ga);\n      ret = 1;\n    }\n  }\n\n  trylevel = save_trylevel;\n  called_emsg = false;\n  suppress_errthrow = false;\n  emsg_silent = false;\n  emsg_on_display = false;\n  set_vim_var_string(VV_ERRMSG, NULL, 0);\n  return ret;\n}\n\nint assert_match_common(typval_T *argvars, assert_type_T atype)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char buf1[NUMBUFLEN];\n  char buf2[NUMBUFLEN];\n  const char *const pat = tv_get_string_buf_chk(&argvars[0], buf1);\n  const char *const text = tv_get_string_buf_chk(&argvars[1], buf2);\n\n  if (pat == NULL || text == NULL) {\n    EMSG(_(e_invarg));\n  } else if (pattern_match((char_u *)pat, (char_u *)text, false)\n             != (atype == ASSERT_MATCH)) {\n    garray_T ga;\n    prepare_assert_error(&ga);\n    fill_assert_error(&ga, &argvars[2], NULL, &argvars[0], &argvars[1], atype);\n    assert_error(&ga);\n    ga_clear(&ga);\n    return 1;\n  }\n  return 0;\n}\n\n/// Find a window: When using a Window ID in any tab page, when using a number\n/// in the current tab page.\nwin_T * find_win_by_nr_or_id(typval_T *vp)\n{\n  int nr = (int)tv_get_number_chk(vp, NULL);\n\n  if (nr >= LOWEST_WIN_ID) {\n    return win_id2wp(vp);\n  }\n\n  return find_win_by_nr(vp, NULL);\n}\n\n/*\n * Implementation of map() and filter().\n */\nvoid filter_map(typval_T *argvars, typval_T *rettv, int map)\n{\n  typval_T *expr;\n  list_T *l = NULL;\n  dictitem_T *di;\n  hashtab_T *ht;\n  hashitem_T *hi;\n  dict_T *d = NULL;\n  typval_T save_val;\n  typval_T save_key;\n  blob_T *b = NULL;\n  int rem = false;\n  int todo;\n  char_u *ermsg = (char_u *)(map ? \"map()\" : \"filter()\");\n  const char *const arg_errmsg = (map\n                                  ? N_(\"map() argument\")\n                                  : N_(\"filter() argument\"));\n  int save_did_emsg;\n  int idx = 0;\n\n  if (argvars[0].v_type == VAR_BLOB) {\n    tv_copy(&argvars[0], rettv);\n    if ((b = argvars[0].vval.v_blob) == NULL) {\n      return;\n    }\n  } else if (argvars[0].v_type == VAR_LIST) {\n    tv_copy(&argvars[0], rettv);\n    if ((l = argvars[0].vval.v_list) == NULL\n        || (!map\n            && var_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE))) {\n      return;\n    }\n  } else if (argvars[0].v_type == VAR_DICT) {\n    tv_copy(&argvars[0], rettv);\n    if ((d = argvars[0].vval.v_dict) == NULL\n        || (!map && var_check_lock(d->dv_lock, arg_errmsg, TV_TRANSLATE))) {\n      return;\n    }\n  } else {\n    EMSG2(_(e_listdictblobarg), ermsg);\n    return;\n  }\n\n  expr = &argvars[1];\n  // On type errors, the preceding call has already displayed an error\n  // message.  Avoid a misleading error message for an empty string that\n  // was not passed as argument.\n  if (expr->v_type != VAR_UNKNOWN) {\n    prepare_vimvar(VV_VAL, &save_val);\n\n    // We reset \"did_emsg\" to be able to detect whether an error\n    // occurred during evaluation of the expression.\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    prepare_vimvar(VV_KEY, &save_key);\n    if (argvars[0].v_type == VAR_DICT) {\n      vimvars[VV_KEY].vv_type = VAR_STRING;\n\n      ht = &d->dv_hashtab;\n      hash_lock(ht);\n      todo = (int)ht->ht_used;\n      for (hi = ht->ht_array; todo > 0; ++hi) {\n        if (!HASHITEM_EMPTY(hi)) {\n          --todo;\n\n          di = TV_DICT_HI2DI(hi);\n          if (map\n              && (var_check_lock(di->di_tv.v_lock, arg_errmsg, TV_TRANSLATE)\n                  || var_check_ro(di->di_flags, arg_errmsg, TV_TRANSLATE))) {\n            break;\n          }\n\n          vimvars[VV_KEY].vv_str = vim_strsave(di->di_key);\n          int r = filter_map_one(&di->di_tv, expr, map, &rem);\n          tv_clear(&vimvars[VV_KEY].vv_tv);\n          if (r == FAIL || did_emsg) {\n            break;\n          }\n          if (!map && rem) {\n            if (var_check_fixed(di->di_flags, arg_errmsg, TV_TRANSLATE)\n                || var_check_ro(di->di_flags, arg_errmsg, TV_TRANSLATE)) {\n              break;\n            }\n            tv_dict_item_remove(d, di);\n          }\n        }\n      }\n      hash_unlock(ht);\n    } else if (argvars[0].v_type == VAR_BLOB) {\n      vimvars[VV_KEY].vv_type = VAR_NUMBER;\n\n      for (int i = 0; i < b->bv_ga.ga_len; i++) {\n        typval_T tv;\n        tv.v_type = VAR_NUMBER;\n        const varnumber_T val = tv_blob_get(b, i);\n        tv.vval.v_number = val;\n        vimvars[VV_KEY].vv_nr = idx;\n        if (filter_map_one(&tv, expr, map, &rem) == FAIL || did_emsg) {\n          break;\n        }\n        if (tv.v_type != VAR_NUMBER) {\n          EMSG(_(e_invalblob));\n          return;\n        }\n        if (map) {\n          if (tv.vval.v_number != val) {\n            tv_blob_set(b, i, tv.vval.v_number);\n          }\n        } else if (rem) {\n          char_u *const p = (char_u *)argvars[0].vval.v_blob->bv_ga.ga_data;\n          memmove(p + i, p + i + 1, (size_t)b->bv_ga.ga_len - i - 1);\n          b->bv_ga.ga_len--;\n          i--;\n        }\n        idx++;\n      }\n    } else {\n      assert(argvars[0].v_type == VAR_LIST);\n      vimvars[VV_KEY].vv_type = VAR_NUMBER;\n\n      for (listitem_T *li = tv_list_first(l); li != NULL;) {\n        if (map\n            && var_check_lock(TV_LIST_ITEM_TV(li)->v_lock, arg_errmsg,\n                              TV_TRANSLATE)) {\n          break;\n        }\n        vimvars[VV_KEY].vv_nr = idx;\n        if (filter_map_one(TV_LIST_ITEM_TV(li), expr, map, &rem) == FAIL\n            || did_emsg) {\n          break;\n        }\n        if (!map && rem) {\n          li = tv_list_item_remove(l, li);\n        } else {\n          li = TV_LIST_ITEM_NEXT(l, li);\n        }\n        idx++;\n      }\n    }\n\n    restore_vimvar(VV_KEY, &save_key);\n    restore_vimvar(VV_VAL, &save_val);\n\n    did_emsg |= save_did_emsg;\n  }\n}\n\nstatic int filter_map_one(typval_T *tv, typval_T *expr, int map, int *remp)\n  FUNC_ATTR_NONNULL_ARG(1, 2)\n{\n  typval_T rettv;\n  typval_T argv[3];\n  int retval = FAIL;\n\n  tv_copy(tv, &vimvars[VV_VAL].vv_tv);\n  argv[0] = vimvars[VV_KEY].vv_tv;\n  argv[1] = vimvars[VV_VAL].vv_tv;\n  if (eval_expr_typval(expr, argv, 2, &rettv) == FAIL) {\n    goto theend;\n  }\n  if (map) {\n    // map(): replace the list item value.\n    tv_clear(tv);\n    rettv.v_lock = VAR_UNLOCKED;\n    *tv = rettv;\n  } else {\n    bool error = false;\n\n    // filter(): when expr is zero remove the item\n    *remp = (tv_get_number_chk(&rettv, &error) == 0);\n    tv_clear(&rettv);\n    // On type error, nothing has been removed; return FAIL to stop the\n    // loop.  The error message was given by tv_get_number_chk().\n    if (error) {\n      goto theend;\n    }\n  }\n  retval = OK;\ntheend:\n  tv_clear(&vimvars[VV_VAL].vv_tv);\n  return retval;\n}\n\nvoid common_function(typval_T *argvars, typval_T *rettv, bool is_funcref, FunPtr fptr)\n{\n  char_u *s;\n  char_u *name;\n  bool use_string = false;\n  partial_T *arg_pt = NULL;\n  char_u *trans_name = NULL;\n\n  if (argvars[0].v_type == VAR_FUNC) {\n    // function(MyFunc, [arg], dict)\n    s = argvars[0].vval.v_string;\n  } else if (argvars[0].v_type == VAR_PARTIAL\n             && argvars[0].vval.v_partial != NULL) {\n    // function(dict.MyFunc, [arg])\n    arg_pt = argvars[0].vval.v_partial;\n    s = partial_name(arg_pt);\n    // TODO(bfredl): do the entire nlua_is_table_from_lua dance\n  } else {\n    // function('MyFunc', [arg], dict)\n    s = (char_u *)tv_get_string(&argvars[0]);\n    use_string = true;\n  }\n\n  if ((use_string && vim_strchr(s, AUTOLOAD_CHAR) == NULL) || is_funcref) {\n    name = s;\n    trans_name = trans_function_name(&name, false,\n                                     TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD\n                                     | TFN_NO_DEREF, NULL, NULL);\n    if (*name != NUL) {\n      s = NULL;\n    }\n  }\n  if (s == NULL || *s == NUL || (use_string && ascii_isdigit(*s))\n      || (is_funcref && trans_name == NULL)) {\n    emsgf(_(e_invarg2), (use_string\n                         ? tv_get_string(&argvars[0])\n                         : (const char *)s));\n    // Don't check an autoload name for existence here.\n  } else if (trans_name != NULL\n             && (is_funcref ? find_func(trans_name) == NULL\n                            : !translated_function_exists((const char *)trans_name))) {\n    emsgf(_(\"E700: Unknown function: %s\"), s);\n  } else {\n    int dict_idx = 0;\n    int arg_idx = 0;\n    list_T *list = NULL;\n    if (STRNCMP(s, \"s:\", 2) == 0 || STRNCMP(s, \"<SID>\", 5) == 0) {\n      char sid_buf[25];\n      int off = *s == 's' ? 2 : 5;\n\n      // Expand s: and <SID> into <SNR>nr_, so that the function can\n      // also be called from another script. Using trans_function_name()\n      // would also work, but some plugins depend on the name being\n      // printable text.\n      snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%\" PRId64 \"_\",\n               (int64_t)current_sctx.sc_sid);\n      name = xmalloc(STRLEN(sid_buf) + STRLEN(s + off) + 1);\n      STRCPY(name, sid_buf);\n      STRCAT(name, s + off);\n    } else {\n      name = vim_strsave(s);\n    }\n\n    if (argvars[1].v_type != VAR_UNKNOWN) {\n      if (argvars[2].v_type != VAR_UNKNOWN) {\n        // function(name, [args], dict)\n        arg_idx = 1;\n        dict_idx = 2;\n      } else if (argvars[1].v_type == VAR_DICT) {\n        // function(name, dict)\n        dict_idx = 1;\n      } else {\n        // function(name, [args])\n        arg_idx = 1;\n      }\n      if (dict_idx > 0) {\n        if (argvars[dict_idx].v_type != VAR_DICT) {\n          EMSG(_(\"E922: expected a dict\"));\n          xfree(name);\n          goto theend;\n        }\n        if (argvars[dict_idx].vval.v_dict == NULL) {\n          dict_idx = 0;\n        }\n      }\n      if (arg_idx > 0) {\n        if (argvars[arg_idx].v_type != VAR_LIST) {\n          EMSG(_(\"E923: Second argument of function() must be \"\n                 \"a list or a dict\"));\n          xfree(name);\n          goto theend;\n        }\n        list = argvars[arg_idx].vval.v_list;\n        if (tv_list_len(list) == 0) {\n          arg_idx = 0;\n        } else if (tv_list_len(list) > MAX_FUNC_ARGS) {\n          emsg_funcname((char *)e_toomanyarg, s);\n          xfree(name);\n          goto theend;\n        }\n      }\n    }\n    if (dict_idx > 0 || arg_idx > 0 || arg_pt != NULL || is_funcref) {\n      partial_T *const pt = xcalloc(1, sizeof(*pt));\n\n      // result is a VAR_PARTIAL\n      if (arg_idx > 0 || (arg_pt != NULL && arg_pt->pt_argc > 0)) {\n        const int arg_len = (arg_pt == NULL ? 0 : arg_pt->pt_argc);\n        const int lv_len = tv_list_len(list);\n\n        pt->pt_argc = arg_len + lv_len;\n        pt->pt_argv = xmalloc(sizeof(pt->pt_argv[0]) * pt->pt_argc);\n        int i = 0;\n        for (; i < arg_len; i++) {\n          tv_copy(&arg_pt->pt_argv[i], &pt->pt_argv[i]);\n        }\n        if (lv_len > 0) {\n          TV_LIST_ITER(list, li, {\n            tv_copy(TV_LIST_ITEM_TV(li), &pt->pt_argv[i++]);\n          });\n        }\n      }\n\n      // For \"function(dict.func, [], dict)\" and \"func\" is a partial\n      // use \"dict\". That is backwards compatible.\n      if (dict_idx > 0) {\n        // The dict is bound explicitly, pt_auto is false\n        pt->pt_dict = argvars[dict_idx].vval.v_dict;\n        (pt->pt_dict->dv_refcount)++;\n      } else if (arg_pt != NULL) {\n        // If the dict was bound automatically the result is also\n        // bound automatically.\n        pt->pt_dict = arg_pt->pt_dict;\n        pt->pt_auto = arg_pt->pt_auto;\n        if (pt->pt_dict != NULL) {\n          (pt->pt_dict->dv_refcount)++;\n        }\n      }\n\n      pt->pt_refcount = 1;\n      if (arg_pt != NULL && arg_pt->pt_func != NULL) {\n        pt->pt_func = arg_pt->pt_func;\n        func_ptr_ref(pt->pt_func);\n        xfree(name);\n      } else if (is_funcref) {\n        pt->pt_func = find_func(trans_name);\n        func_ptr_ref(pt->pt_func);\n        xfree(name);\n      } else {\n        pt->pt_name = name;\n        func_ref(name);\n      }\n\n      rettv->v_type = VAR_PARTIAL;\n      rettv->vval.v_partial = pt;\n    } else {\n      // result is a VAR_FUNC\n      rettv->v_type = VAR_FUNC;\n      rettv->vval.v_string = name;\n      func_ref(name);\n    }\n  }\ntheend:\n  xfree(trans_name);\n}\n\n/// Returns buffer options, variables and other attributes in a dictionary.\ndict_T *get_buffer_info(buf_T *buf)\n{\n  dict_T *const dict = tv_dict_alloc();\n\n  tv_dict_add_nr(dict, S_LEN(\"bufnr\"), buf->b_fnum);\n  tv_dict_add_str(dict, S_LEN(\"name\"),\n                  buf->b_ffname != NULL ? (const char *)buf->b_ffname : \"\");\n  tv_dict_add_nr(dict, S_LEN(\"lnum\"),\n                 buf == curbuf ? curwin->w_cursor.lnum : buflist_findlnum(buf));\n  tv_dict_add_nr(dict, S_LEN(\"linecount\"), buf->b_ml.ml_line_count);\n  tv_dict_add_nr(dict, S_LEN(\"loaded\"), buf->b_ml.ml_mfp != NULL);\n  tv_dict_add_nr(dict, S_LEN(\"listed\"), buf->b_p_bl);\n  tv_dict_add_nr(dict, S_LEN(\"changed\"), bufIsChanged(buf));\n  tv_dict_add_nr(dict, S_LEN(\"changedtick\"), buf_get_changedtick(buf));\n  tv_dict_add_nr(dict, S_LEN(\"hidden\"),\n                 buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0);\n\n  // Get a reference to buffer variables\n  tv_dict_add_dict(dict, S_LEN(\"variables\"), buf->b_vars);\n\n  // List of windows displaying this buffer\n  list_T *const windows = tv_list_alloc(kListLenMayKnow);\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    if (wp->w_buffer == buf) {\n      tv_list_append_number(windows, (varnumber_T)wp->handle);\n    }\n  }\n  tv_dict_add_list(dict, S_LEN(\"windows\"), windows);\n\n  if (buf->b_signlist != NULL) {\n    // List of signs placed in this buffer\n    tv_dict_add_list(dict, S_LEN(\"signs\"), get_buffer_signs(buf));\n  }\n\n  tv_dict_add_nr(dict, S_LEN(\"lastused\"), buf->b_last_used);\n\n  return dict;\n}\n\n/// Get the line number from VimL object\n///\n/// @note Unlike tv_get_lnum(), this one supports only \"$\" special string.\n///\n/// @param[in]  tv  Object to get value from. Is expected to be a number or\n///                 a special string \"$\".\n/// @param[in]  buf  Buffer to take last line number from in case tv is \"$\". May\n///                  be NULL, in this case \"$\" results in zero return.\n///\n/// @return Line number or 0 in case of error.\nlinenr_T tv_get_lnum_buf(const typval_T *const tv, const buf_T *const buf)\n  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (tv->v_type == VAR_STRING\n      && tv->vval.v_string != NULL\n      && tv->vval.v_string[0] == '$'\n      && buf != NULL) {\n    return buf->b_ml.ml_line_count;\n  }\n  return tv_get_number_chk(tv, NULL);\n}\n\nvoid get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)\n{\n  if (what_arg->v_type == VAR_UNKNOWN) {\n    tv_list_alloc_ret(rettv, kListLenMayKnow);\n    if (is_qf || wp != NULL) {\n      (void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);\n    }\n  } else {\n    tv_dict_alloc_ret(rettv);\n    if (is_qf || wp != NULL) {\n      if (what_arg->v_type == VAR_DICT) {\n        dict_T *d = what_arg->vval.v_dict;\n\n        if (d != NULL) {\n          qf_get_properties(wp, d, rettv->vval.v_dict);\n        }\n      } else {\n        EMSG(_(e_dictreq));\n      }\n    }\n  }\n}\n\n/// Returns information (variables, options, etc.) about a tab page\n/// as a dictionary.\ndict_T *get_tabpage_info(tabpage_T *tp, int tp_idx)\n{\n  dict_T *const dict = tv_dict_alloc();\n\n  tv_dict_add_nr(dict, S_LEN(\"tabnr\"), tp_idx);\n\n  list_T *const l = tv_list_alloc(kListLenMayKnow);\n  FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n    tv_list_append_number(l, (varnumber_T)wp->handle);\n  }\n  tv_dict_add_list(dict, S_LEN(\"windows\"), l);\n\n  // Make a reference to tabpage variables\n  tv_dict_add_dict(dict, S_LEN(\"variables\"), tp->tp_vars);\n\n  return dict;\n}\n\n/// Returns information about a window as a dictionary.\ndict_T *get_win_info(win_T *wp, int16_t tpnr, int16_t winnr)\n{\n  dict_T *const dict = tv_dict_alloc();\n\n  tv_dict_add_nr(dict, S_LEN(\"tabnr\"), tpnr);\n  tv_dict_add_nr(dict, S_LEN(\"winnr\"), winnr);\n  tv_dict_add_nr(dict, S_LEN(\"winid\"), wp->handle);\n  tv_dict_add_nr(dict, S_LEN(\"height\"), wp->w_height);\n  tv_dict_add_nr(dict, S_LEN(\"winrow\"), wp->w_winrow + 1);\n  tv_dict_add_nr(dict, S_LEN(\"topline\"), wp->w_topline);\n  tv_dict_add_nr(dict, S_LEN(\"botline\"), wp->w_botline - 1);\n  tv_dict_add_nr(dict, S_LEN(\"winbar\"), 0);\n  tv_dict_add_nr(dict, S_LEN(\"width\"), wp->w_width);\n  tv_dict_add_nr(dict, S_LEN(\"bufnr\"), wp->w_buffer->b_fnum);\n  tv_dict_add_nr(dict, S_LEN(\"wincol\"), wp->w_wincol + 1);\n\n  tv_dict_add_nr(dict, S_LEN(\"terminal\"), bt_terminal(wp->w_buffer));\n  tv_dict_add_nr(dict, S_LEN(\"quickfix\"), bt_quickfix(wp->w_buffer));\n  tv_dict_add_nr(dict, S_LEN(\"loclist\"),\n                 (bt_quickfix(wp->w_buffer) && wp->w_llist_ref != NULL));\n\n  // Add a reference to window variables\n  tv_dict_add_dict(dict, S_LEN(\"variables\"), wp->w_vars);\n\n  return dict;\n}\n\n/// Find window specified by \"vp\" in tabpage \"tp\".\n///\n/// @param tp  NULL for current tab page\nwin_T *find_win_by_nr(typval_T *vp, tabpage_T *tp)\n{\n  int nr = (int)tv_get_number_chk(vp, NULL);\n\n  if (nr < 0) {\n    return NULL;\n  }\n\n  if (nr == 0) {\n    return curwin;\n  }\n\n  // This method accepts NULL as an alias for curtab.\n  if (tp == NULL) {\n    tp = curtab;\n  }\n\n  FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\n    if (nr >= LOWEST_WIN_ID) {\n      if (wp->handle == nr) {\n        return wp;\n      }\n    } else if (--nr <= 0) {\n      return wp;\n    }\n  }\n  return NULL;\n}\n\n/// Find window specified by \"wvp\" in tabpage \"tvp\".\nwin_T *find_tabwin(typval_T *wvp, typval_T *tvp)\n{\n  win_T *wp = NULL;\n  tabpage_T *tp = NULL;\n\n  if (wvp->v_type != VAR_UNKNOWN) {\n    if (tvp->v_type != VAR_UNKNOWN) {\n      long n = tv_get_number(tvp);\n      if (n >= 0) {\n        tp = find_tabpage(n);\n      }\n    } else {\n      tp = curtab;\n    }\n\n    if (tp != NULL) {\n      wp = find_win_by_nr(wvp, tp);\n    }\n  } else {\n    wp = curwin;\n  }\n\n  return wp;\n}\n\n/// getwinvar() and gettabwinvar()\n///\n/// @param off  1 for gettabwinvar()\nvoid getwinvar(typval_T *argvars, typval_T *rettv, int off)\n{\n  win_T *win, *oldcurwin;\n  dictitem_T *v;\n  tabpage_T *tp = NULL;\n  tabpage_T *oldtabpage = NULL;\n  bool done = false;\n\n  if (off == 1) {\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n  } else {\n    tp = curtab;\n  }\n  win = find_win_by_nr(&argvars[off], tp);\n  const char *varname = tv_get_string_chk(&argvars[off + 1]);\n\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = NULL;\n\n  emsg_off++;\n  if (win != NULL && varname != NULL) {\n    // Set curwin to be our win, temporarily.  Also set the tabpage,\n    // otherwise the window is not valid. Only do this when needed,\n    // autocommands get blocked.\n    bool need_switch_win = tp != curtab || win != curwin;\n    if (!need_switch_win\n        || switch_win(&oldcurwin, &oldtabpage, win, tp, true) == OK) {\n      if (*varname == '&') {\n        if (varname[1] == NUL) {\n          // get all window-local options in a dict\n          dict_T *opts = get_winbuf_options(false);\n\n          if (opts != NULL) {\n            tv_dict_set_ret(rettv, opts);\n            done = true;\n          }\n        } else if (get_option_tv(&varname, rettv, 1) == OK) {\n          // window-local-option\n          done = true;\n        }\n      } else {\n        // Look up the variable.\n        // Let getwinvar({nr}, \"\") return the \"w:\" dictionary.\n        v = find_var_in_ht(&win->w_vars->dv_hashtab, 'w', varname,\n                           strlen(varname), false);\n        if (v != NULL) {\n          tv_copy(&v->di_tv, rettv);\n          done = true;\n        }\n      }\n    }\n\n    if (need_switch_win) {\n      // restore previous notion of curwin\n      restore_win(oldcurwin, oldtabpage, true);\n    }\n  }\n  emsg_off--;\n\n  if (!done && argvars[off + 2].v_type != VAR_UNKNOWN) {\n    // use the default return value\n    tv_copy(&argvars[off + 2], rettv);\n  }\n}\n\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\nvoid get_user_input(const typval_T *const argvars, typval_T *const rettv, const bool inputdialog,\n                    const bool secret)\n  FUNC_ATTR_NONNULL_ALL\n{\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = NULL;\n\n  const char *prompt = \"\";\n  const char *defstr = \"\";\n  const char *cancelreturn = NULL;\n  const char *xp_name = NULL;\n  Callback input_callback = { .type = kCallbackNone };\n  char prompt_buf[NUMBUFLEN];\n  char defstr_buf[NUMBUFLEN];\n  char cancelreturn_buf[NUMBUFLEN];\n  char xp_name_buf[NUMBUFLEN];\n  char def[1] = { 0 };\n  if (argvars[0].v_type == VAR_DICT) {\n    if (argvars[1].v_type != VAR_UNKNOWN) {\n      EMSG(_(\"E5050: {opts} must be the only argument\"));\n      return;\n    }\n    dict_T *const dict = argvars[0].vval.v_dict;\n    prompt = tv_dict_get_string_buf_chk(dict, S_LEN(\"prompt\"), prompt_buf, \"\");\n    if (prompt == NULL) {\n      return;\n    }\n    defstr = tv_dict_get_string_buf_chk(dict, S_LEN(\"default\"), defstr_buf, \"\");\n    if (defstr == NULL) {\n      return;\n    }\n    cancelreturn = tv_dict_get_string_buf_chk(dict, S_LEN(\"cancelreturn\"),\n                                              cancelreturn_buf, def);\n    if (cancelreturn == NULL) {  // error\n      return;\n    }\n    if (*cancelreturn == NUL) {\n      cancelreturn = NULL;\n    }\n    xp_name = tv_dict_get_string_buf_chk(dict, S_LEN(\"completion\"),\n                                         xp_name_buf, def);\n    if (xp_name == NULL) {  // error\n      return;\n    }\n    if (xp_name == def) {  // default to NULL\n      xp_name = NULL;\n    }\n    if (!tv_dict_get_callback(dict, S_LEN(\"highlight\"), &input_callback)) {\n      return;\n    }\n  } else {\n    prompt = tv_get_string_buf_chk(&argvars[0], prompt_buf);\n    if (prompt == NULL) {\n      return;\n    }\n    if (argvars[1].v_type != VAR_UNKNOWN) {\n      defstr = tv_get_string_buf_chk(&argvars[1], defstr_buf);\n      if (defstr == NULL) {\n        return;\n      }\n      if (argvars[2].v_type != VAR_UNKNOWN) {\n        const char *const arg2 = tv_get_string_buf_chk(&argvars[2],\n                                                       cancelreturn_buf);\n        if (arg2 == NULL) {\n          return;\n        }\n        if (inputdialog) {\n          cancelreturn = arg2;\n        } else {\n          xp_name = arg2;\n        }\n      }\n    }\n  }\n\n  int xp_type = EXPAND_NOTHING;\n  char *xp_arg = NULL;\n  if (xp_name != NULL) {\n    // input() with a third argument: completion\n    const int xp_namelen = (int)strlen(xp_name);\n\n    uint32_t argt;\n    if (parse_compl_arg((char_u *)xp_name, xp_namelen, &xp_type,\n                        &argt, (char_u **)&xp_arg) == FAIL) {\n      return;\n    }\n  }\n\n  const bool cmd_silent_save = cmd_silent;\n\n  cmd_silent = false;  // Want to see the prompt.\n  // Only the part of the message after the last NL is considered as\n  // prompt for the command line, unlsess cmdline is externalized\n  const char *p = prompt;\n  if (!ui_has(kUICmdline)) {\n    const char *lastnl = strrchr(prompt, '\\n');\n    if (lastnl != NULL) {\n      p = lastnl+1;\n      msg_start();\n      msg_clr_eos();\n      msg_puts_attr_len(prompt, p - prompt, echo_attr);\n      msg_didout = false;\n      msg_starthere();\n    }\n  }\n  cmdline_row = msg_row;\n\n  stuffReadbuffSpec(defstr);\n\n  const int save_ex_normal_busy = ex_normal_busy;\n  ex_normal_busy = 0;\n  rettv->vval.v_string =\n    (char_u *)getcmdline_prompt(secret ? NUL : '@', p, echo_attr,\n                                xp_type, xp_arg, input_callback);\n  ex_normal_busy = save_ex_normal_busy;\n  callback_free(&input_callback);\n\n  if (rettv->vval.v_string == NULL && cancelreturn != NULL) {\n    rettv->vval.v_string = (char_u *)xstrdup(cancelreturn);\n  }\n\n  xfree(xp_arg);\n\n  // Since the user typed this, no need to wait for return.\n  need_wait_return = false;\n  msg_didout = false;\n  cmd_silent = cmd_silent_save;\n}\n\n/// Turn a dictionary into a list\n///\n/// @param[in]  tv  Dictionary to convert. Is checked for actually being\n///                 a dictionary, will give an error if not.\n/// @param[out]  rettv  Location where result will be saved.\n/// @param[in]  what  What to save in rettv.\nvoid dict_list(typval_T *const tv, typval_T *const rettv, const DictListType what)\n{\n  if (tv->v_type != VAR_DICT) {\n    EMSG(_(e_dictreq));\n    return;\n  }\n  if (tv->vval.v_dict == NULL) {\n    return;\n  }\n\n  tv_list_alloc_ret(rettv, tv_dict_len(tv->vval.v_dict));\n\n  TV_DICT_ITER(tv->vval.v_dict, di, {\n    typval_T tv_item = { .v_lock = VAR_UNLOCKED };\n\n    switch (what) {\n    case kDictListKeys:\n      tv_item.v_type = VAR_STRING;\n      tv_item.vval.v_string = vim_strsave(di->di_key);\n      break;\n    case kDictListValues:\n      tv_copy(&di->di_tv, &tv_item);\n      break;\n    case kDictListItems: {\n      // items()\n      list_T *const sub_l = tv_list_alloc(2);\n      tv_item.v_type = VAR_LIST;\n      tv_item.vval.v_list = sub_l;\n      tv_list_ref(sub_l);\n\n      tv_list_append_owned_tv(sub_l, (typval_T) {\n          .v_type = VAR_STRING,\n          .v_lock = VAR_UNLOCKED,\n          .vval.v_string = (char_u *)xstrdup((const char *)di->di_key),\n        });\n\n      tv_list_append_tv(sub_l, &di->di_tv);\n\n      break;\n    }\n    }\n\n    tv_list_append_owned_tv(rettv->vval.v_list, tv_item);\n  });\n}\n\n/// Builds a process argument vector from a VimL object (typval_T).\n///\n/// @param[in]  cmd_tv      VimL object\n/// @param[out] cmd         Returns the command or executable name.\n/// @param[out] executable  Returns `false` if argv[0] is not executable.\n///\n/// @returns Result of `shell_build_argv()` if `cmd_tv` is a String.\n///          Else, string values of `cmd_tv` copied to a (char **) list with\n///          argv[0] resolved to full path ($PATHEXT-resolved on Windows).\nchar **tv_to_argv(typval_T *cmd_tv, const char **cmd, bool *executable)\n{\n  if (cmd_tv->v_type == VAR_STRING) {  // String => \"shell semantics\".\n    const char *cmd_str = tv_get_string(cmd_tv);\n    if (cmd) {\n      *cmd = cmd_str;\n    }\n    return shell_build_argv(cmd_str, NULL);\n  }\n\n  if (cmd_tv->v_type != VAR_LIST) {\n    EMSG2(_(e_invarg2), \"expected String or List\");\n    return NULL;\n  }\n\n  list_T *argl = cmd_tv->vval.v_list;\n  int argc = tv_list_len(argl);\n  if (!argc) {\n    EMSG(_(e_invarg));  // List must have at least one item.\n    return NULL;\n  }\n\n  const char *arg0 = tv_get_string_chk(TV_LIST_ITEM_TV(tv_list_first(argl)));\n  char *exe_resolved = NULL;\n  if (!arg0 || !os_can_exe(arg0, &exe_resolved, true)) {\n    if (arg0 && executable) {\n      char buf[IOSIZE];\n      snprintf(buf, sizeof(buf), \"'%s' is not executable\", arg0);\n      EMSG3(_(e_invargNval), \"cmd\", buf);\n      *executable = false;\n    }\n    return NULL;\n  }\n\n  if (cmd) {\n    *cmd = exe_resolved;\n  }\n\n  // Build the argument vector\n  int i = 0;\n  char **argv = xcalloc(argc + 1, sizeof(char *));\n  TV_LIST_ITER_CONST(argl, arg, {\n    const char *a = tv_get_string_chk(TV_LIST_ITEM_TV(arg));\n    if (!a) {\n      // Did emsg in tv_get_string_chk; just deallocate argv.\n      shell_free_argv(argv);\n      xfree(exe_resolved);\n      return NULL;\n    }\n    argv[i++] = xstrdup(a);\n  });\n  // Replace argv[0] with absolute path. The only reason for this is to make\n  // $PATHEXT work on Windows with jobstart([\u2026]). #9569\n  xfree(argv[0]);\n  argv[0] = exe_resolved;\n\n  return argv;\n}\n\n/// Fill a dictionary with all applicable maparg() like dictionaries\n///\n/// @param  dict  The dictionary to be filled\n/// @param  mp  The maphash that contains the mapping information\n/// @param  buffer_value  The \"buffer\" value\n/// @param  compatible  True for compatible with old maparg() dict\nvoid mapblock_fill_dict(dict_T *const dict, const mapblock_T *const mp, long buffer_value,\n                        bool compatible)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char *const lhs = str2special_save((const char *)mp->m_keys,\n                                     compatible, !compatible);\n  char *const mapmode = map_mode_to_chars(mp->m_mode);\n  varnumber_T noremap_value;\n\n  if (compatible) {\n    // Keep old compatible behavior\n    // This is unable to determine whether a mapping is a <script> mapping\n    noremap_value = !!mp->m_noremap;\n  } else {\n    // Distinguish between <script> mapping\n    // If it's not a <script> mapping, check if it's a noremap\n    noremap_value = mp->m_noremap == REMAP_SCRIPT ? 2 : !!mp->m_noremap;\n  }\n\n  if (compatible) {\n    tv_dict_add_str(dict, S_LEN(\"rhs\"), (const char *)mp->m_orig_str);\n  } else {\n    tv_dict_add_allocated_str(dict, S_LEN(\"rhs\"),\n                              str2special_save((const char *)mp->m_str, false,\n                                               true));\n  }\n  tv_dict_add_allocated_str(dict, S_LEN(\"lhs\"), lhs);\n  tv_dict_add_nr(dict, S_LEN(\"noremap\"), noremap_value);\n  tv_dict_add_nr(dict, S_LEN(\"script\"), mp->m_noremap == REMAP_SCRIPT ? 1 : 0);\n  tv_dict_add_nr(dict, S_LEN(\"expr\"),  mp->m_expr ? 1 : 0);\n  tv_dict_add_nr(dict, S_LEN(\"silent\"), mp->m_silent ? 1 : 0);\n  tv_dict_add_nr(dict, S_LEN(\"sid\"), (varnumber_T)mp->m_script_ctx.sc_sid);\n  tv_dict_add_nr(dict, S_LEN(\"lnum\"), (varnumber_T)mp->m_script_ctx.sc_lnum);\n  tv_dict_add_nr(dict, S_LEN(\"buffer\"), (varnumber_T)buffer_value);\n  tv_dict_add_nr(dict, S_LEN(\"nowait\"), mp->m_nowait ? 1 : 0);\n  tv_dict_add_allocated_str(dict, S_LEN(\"mode\"), mapmode);\n}\n\nint matchadd_dict_arg(typval_T *tv, const char **conceal_char, win_T **win)\n{\n  dictitem_T *di;\n\n  if (tv->v_type != VAR_DICT) {\n    EMSG(_(e_dictreq));\n    return FAIL;\n  }\n\n  if ((di = tv_dict_find(tv->vval.v_dict, S_LEN(\"conceal\"))) != NULL) {\n    *conceal_char = tv_get_string(&di->di_tv);\n  }\n\n  if ((di = tv_dict_find(tv->vval.v_dict, S_LEN(\"window\"))) != NULL) {\n    *win = find_win_by_nr_or_id(&di->di_tv);\n    if (*win == NULL) {\n      EMSG(_(e_invalwindow));\n      return FAIL;\n    }\n  }\n\n  return OK;\n}\n\nvoid return_register(int regname, typval_T *rettv)\n{\n  char_u buf[2] = { regname, 0 };\n\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = vim_strsave(buf);\n}\n\nvoid screenchar_adjust_grid(ScreenGrid **grid, int *row, int *col)\n{\n  // TODO(bfredl): this is a hack for legacy tests which use screenchar()\n  // to check printed messages on the screen (but not floats etc\n  // as these are not legacy features). If the compositor is refactored to\n  // have its own buffer, this should just read from it instead.\n  msg_scroll_flush();\n  if (msg_grid.chars && msg_grid.comp_index > 0 && *row >= msg_grid.comp_row\n      && *row < (msg_grid.Rows + msg_grid.comp_row)\n      && *col < msg_grid.Columns) {\n    *grid = &msg_grid;\n    *row -= msg_grid.comp_row;\n  }\n}\n\n/// Set line or list of lines in buffer \"buf\".\nvoid set_buffer_lines(buf_T *buf, linenr_T lnum_arg, bool append, const typval_T *lines,\n                      typval_T *rettv)\n  FUNC_ATTR_NONNULL_ARG(4, 5)\n{\n  linenr_T lnum = lnum_arg + (append ? 1 : 0);\n  const char *line = NULL;\n  list_T *l = NULL;\n  listitem_T *li = NULL;\n  long        added = 0;\n  linenr_T append_lnum;\n  buf_T *curbuf_save = NULL;\n  win_T *curwin_save = NULL;\n  const bool is_curbuf = buf == curbuf;\n\n  // When using the current buffer ml_mfp will be set if needed.  Useful when\n  // setline() is used on startup.  For other buffers the buffer must be\n  // loaded.\n  if (buf == NULL || (!is_curbuf && buf->b_ml.ml_mfp == NULL) || lnum < 1) {\n    rettv->vval.v_number = 1;  // FAIL\n    return;\n  }\n\n  if (!is_curbuf) {\n    curbuf_save = curbuf;\n    curwin_save = curwin;\n    curbuf = buf;\n    find_win_for_curbuf();\n  }\n\n  if (append) {\n    // appendbufline() uses the line number below which we insert\n    append_lnum = lnum - 1;\n  } else {\n    // setbufline() uses the line number above which we insert, we only\n    // append if it's below the last line\n    append_lnum = curbuf->b_ml.ml_line_count;\n  }\n\n  if (lines->v_type == VAR_LIST) {\n    l = lines->vval.v_list;\n    li = tv_list_first(l);\n  } else {\n    line = tv_get_string_chk(lines);\n  }\n\n  // Default result is zero == OK.\n  for (;; ) {\n    if (lines->v_type == VAR_LIST) {\n      // List argument, get next string.\n      if (li == NULL) {\n        break;\n      }\n      line = tv_get_string_chk(TV_LIST_ITEM_TV(li));\n      li = TV_LIST_ITEM_NEXT(l, li);\n    }\n\n    rettv->vval.v_number = 1;  // FAIL\n    if (line == NULL || lnum > curbuf->b_ml.ml_line_count + 1) {\n      break;\n    }\n\n    // When coming here from Insert mode, sync undo, so that this can be\n    // undone separately from what was previously inserted.\n    if (u_sync_once == 2) {\n      u_sync_once = 1;  // notify that u_sync() was called\n      u_sync(true);\n    }\n\n    if (!append && lnum <= curbuf->b_ml.ml_line_count) {\n      // Existing line, replace it.\n      int old_len = (int)STRLEN(ml_get(lnum));\n      if (u_savesub(lnum) == OK\n          && ml_replace(lnum, (char_u *)line, true) == OK) {\n        inserted_bytes(lnum, 0, old_len, STRLEN(line));\n        if (is_curbuf && lnum == curwin->w_cursor.lnum) {\n          check_cursor_col();\n        }\n        rettv->vval.v_number = 0;  // OK\n      }\n    } else if (added > 0 || u_save(lnum - 1, lnum) == OK) {\n      // append the line.\n      added++;\n      if (ml_append(lnum - 1, (char_u *)line, 0, false) == OK) {\n        rettv->vval.v_number = 0;  // OK\n      }\n    }\n\n    if (l == NULL) {  // only one string argument\n      break;\n    }\n    lnum++;\n  }\n\n  if (added > 0) {\n    appended_lines_mark(append_lnum, added);\n\n    // Only adjust the cursor for buffers other than the current, unless it\n    // is the current window. For curbuf and other windows it has been done\n    // in mark_adjust_internal().\n    FOR_ALL_TAB_WINDOWS(tp, wp) {\n      if (wp->w_buffer == buf\n          && (wp->w_buffer != curbuf || wp == curwin)\n          && wp->w_cursor.lnum > append_lnum) {\n        wp->w_cursor.lnum += added;\n      }\n    }\n    check_cursor_col();\n    update_topline(curwin);\n  }\n\n  if (!is_curbuf) {\n    curbuf = curbuf_save;\n    curwin = curwin_save;\n  }\n}\n\n/*\n * \"setwinvar()\" and \"settabwinvar()\" functions\n */\n\nvoid setwinvar(typval_T *argvars, typval_T *rettv, int off)\n{\n  if (check_secure()) {\n    return;\n  }\n\n  tabpage_T *tp = NULL;\n  if (off == 1) {\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n  } else {\n    tp = curtab;\n  }\n  win_T *const win = find_win_by_nr(&argvars[off], tp);\n  const char *varname = tv_get_string_chk(&argvars[off + 1]);\n  typval_T *varp = &argvars[off + 2];\n\n  if (win != NULL && varname != NULL && varp != NULL) {\n    win_T *save_curwin;\n    tabpage_T *save_curtab;\n    bool need_switch_win = tp != curtab || win != curwin;\n    if (!need_switch_win\n        || switch_win(&save_curwin, &save_curtab, win, tp, true) == OK) {\n      if (*varname == '&') {\n        long numval;\n        bool error = false;\n\n        varname++;\n        numval = tv_get_number_chk(varp, &error);\n        char nbuf[NUMBUFLEN];\n        const char *const strval = tv_get_string_buf_chk(varp, nbuf);\n        if (!error && strval != NULL) {\n          set_option_value(varname, numval, strval, OPT_LOCAL);\n        }\n      } else {\n        const size_t varname_len = strlen(varname);\n        char *const winvarname = xmalloc(varname_len + 3);\n        memcpy(winvarname, \"w:\", 2);\n        memcpy(winvarname + 2, varname, varname_len + 1);\n        set_var(winvarname, varname_len + 2, varp, true);\n        xfree(winvarname);\n      }\n    }\n    if (need_switch_win) {\n      restore_win(save_curwin, save_curtab, true);\n    }\n  }\n}\n\n/// \"stdpath()\" helper for list results\nvoid get_xdg_var_list(const XDGVarType xdg, typval_T *rettv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const void *iter = NULL;\n  list_T *const list = tv_list_alloc(kListLenShouldKnow);\n  rettv->v_type = VAR_LIST;\n  rettv->vval.v_list = list;\n  tv_list_ref(list);\n  char *const dirs = stdpaths_get_xdg_var(xdg);\n  if (dirs == NULL) {\n    return;\n  }\n  do {\n    size_t dir_len;\n    const char *dir;\n    iter = vim_env_iter(ENV_SEPCHAR, dirs, iter, &dir, &dir_len);\n    if (dir != NULL && dir_len > 0) {\n      char *dir_with_nvim = xmemdupz(dir, dir_len);\n      dir_with_nvim = concat_fnames_realloc(dir_with_nvim, \"nvim\", true);\n      tv_list_append_string(list, dir_with_nvim, strlen(dir_with_nvim));\n      xfree(dir_with_nvim);\n    }\n  } while (iter != NULL);\n  xfree(dirs);\n}\n\nstatic list_T *string_to_list(const char *str, size_t len, const bool keepempty)\n{\n  if (!keepempty && str[len - 1] == NL) {\n    len--;\n  }\n  list_T *const list = tv_list_alloc(kListLenMayKnow);\n  encode_list_write(list, str, len);\n  return list;\n}\n\n// os_system wrapper. Handles 'verbose', :profile, and v:shell_error.\nvoid get_system_output_as_rettv(typval_T *argvars, typval_T *rettv, bool retlist)\n{\n  proftime_T wait_time;\n  bool profiling = do_profiling == PROF_YES;\n\n  rettv->v_type = VAR_STRING;\n  rettv->vval.v_string = NULL;\n\n  if (check_secure()) {\n    return;\n  }\n\n  // get input to the shell command (if any), and its length\n  ptrdiff_t input_len;\n  char *input = save_tv_as_string(&argvars[1], &input_len, false);\n  if (input_len < 0) {\n    assert(input == NULL);\n    return;\n  }\n\n  // get shell command to execute\n  bool executable = true;\n  char **argv = tv_to_argv(&argvars[0], NULL, &executable);\n  if (!argv) {\n    if (!executable) {\n      set_vim_var_nr(VV_SHELL_ERROR, (long)-1);\n    }\n    xfree(input);\n    return;  // Already did emsg.\n  }\n\n  if (p_verbose > 3) {\n    char *cmdstr = shell_argv_to_str(argv);\n    verbose_enter_scroll();\n    smsg(_(\"Executing command: \\\"%s\\\"\"), cmdstr);\n    msg_puts(\"\\n\\n\");\n    verbose_leave_scroll();\n    xfree(cmdstr);\n  }\n\n  if (profiling) {\n    prof_child_enter(&wait_time);\n  }\n\n  // execute the command\n  size_t nread = 0;\n  char *res = NULL;\n  int status = os_system(argv, input, input_len, &res, &nread);\n\n  if (profiling) {\n    prof_child_exit(&wait_time);\n  }\n\n  xfree(input);\n\n  set_vim_var_nr(VV_SHELL_ERROR, (long)status);\n\n  if (res == NULL) {\n    if (retlist) {\n      // return an empty list when there's no output\n      tv_list_alloc_ret(rettv, 0);\n    } else {\n      rettv->vval.v_string = (char_u *)xstrdup(\"\");\n    }\n    return;\n  }\n\n  if (retlist) {\n    int keepempty = 0;\n    if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN) {\n      keepempty = tv_get_number(&argvars[2]);\n    }\n    rettv->vval.v_list = string_to_list(res, nread, (bool)keepempty);\n    tv_list_ref(rettv->vval.v_list);\n    rettv->v_type = VAR_LIST;\n\n    xfree(res);\n  } else {\n    // res may contain several NULs before the final terminating one.\n    // Replace them with SOH (1) like in get_cmd_output() to avoid truncation.\n    memchrsub(res, NUL, 1, nread);\n#ifdef USE_CRNL\n    // translate <CR><NL> into <NL>\n    char *d = res;\n    for (char *s = res; *s; ++s) {\n      if (s[0] == CAR && s[1] == NL) {\n        ++s;\n      }\n\n      *d++ = *s;\n    }\n\n    *d = NUL;\n#endif\n    rettv->vval.v_string = (char_u *)res;\n  }\n}\n\nbool callback_from_typval(Callback *const callback, typval_T *const arg)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int r = OK;\n\n  if (arg->v_type == VAR_PARTIAL && arg->vval.v_partial != NULL) {\n    callback->data.partial = arg->vval.v_partial;\n    callback->data.partial->pt_refcount++;\n    callback->type = kCallbackPartial;\n  } else if (arg->v_type == VAR_STRING\n             && arg->vval.v_string != NULL\n             && ascii_isdigit(*arg->vval.v_string)) {\n    r = FAIL;\n  } else if (arg->v_type == VAR_FUNC || arg->v_type == VAR_STRING) {\n    char_u *name = arg->vval.v_string;\n    if (name == NULL) {\n      r = FAIL;\n    } else if (*name == NUL) {\n      callback->type = kCallbackNone;\n      callback->data.funcref = NULL;\n    } else {\n      func_ref(name);\n      callback->data.funcref = vim_strsave(name);\n      callback->type = kCallbackFuncref;\n    }\n  } else if (nlua_is_table_from_lua(arg)) {\n    char_u *name = nlua_register_table_as_callable(arg);\n\n    if (name != NULL) {\n      callback->data.funcref = vim_strsave(name);\n      callback->type = kCallbackFuncref;\n    } else {\n      r = FAIL;\n    }\n  } else if (arg->v_type == VAR_SPECIAL\n             || (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)) {\n    callback->type = kCallbackNone;\n    callback->data.funcref = NULL;\n  } else {\n    r = FAIL;\n  }\n\n  if (r == FAIL) {\n    EMSG(_(\"E921: Invalid callback argument\"));\n    return false;\n  }\n  return true;\n}\n\nbool callback_call(Callback *const callback, const int argcount_in, typval_T *const argvars_in,\n                   typval_T *const rettv)\n  FUNC_ATTR_NONNULL_ALL\n{\n  partial_T *partial;\n  char_u *name;\n  switch (callback->type) {\n  case kCallbackFuncref:\n    name = callback->data.funcref;\n    partial = NULL;\n    break;\n\n  case kCallbackPartial:\n    partial = callback->data.partial;\n    name = partial_name(partial);\n    break;\n\n  case kCallbackNone:\n    return false;\n    break;\n\n  default:\n    abort();\n  }\n\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = true;\n  funcexe.partial = partial;\n  return call_func(name, -1, rettv, argcount_in, argvars_in, &funcexe);\n}\n\nstatic bool set_ref_in_callback(Callback *callback, int copyID, ht_stack_T **ht_stack,\n                                list_stack_T **list_stack)\n{\n  typval_T tv;\n  switch (callback->type) {\n  case kCallbackFuncref:\n  case kCallbackNone:\n    break;\n\n  case kCallbackPartial:\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = callback->data.partial;\n    return set_ref_in_item(&tv, copyID, ht_stack, list_stack);\n    break;\n\n\n  default:\n    abort();\n  }\n  return false;\n}\n\nstatic bool set_ref_in_callback_reader(CallbackReader *reader, int copyID, ht_stack_T **ht_stack,\n                                       list_stack_T **list_stack)\n{\n  if (set_ref_in_callback(&reader->cb, copyID, ht_stack, list_stack)) {\n    return true;\n  }\n\n  if (reader->self) {\n    typval_T tv;\n    tv.v_type = VAR_DICT;\n    tv.vval.v_dict = reader->self;\n    return set_ref_in_item(&tv, copyID, ht_stack, list_stack);\n  }\n  return false;\n}\n\ntimer_T *find_timer_by_nr(varnumber_T xx)\n{\n  return pmap_get(uint64_t)(&timers, xx);\n}\n\nvoid add_timer_info(typval_T *rettv, timer_T *timer)\n{\n  list_T *list = rettv->vval.v_list;\n  dict_T *dict = tv_dict_alloc();\n\n  tv_list_append_dict(list, dict);\n  tv_dict_add_nr(dict, S_LEN(\"id\"), timer->timer_id);\n  tv_dict_add_nr(dict, S_LEN(\"time\"), timer->timeout);\n  tv_dict_add_nr(dict, S_LEN(\"paused\"), timer->paused);\n\n  tv_dict_add_nr(dict, S_LEN(\"repeat\"),\n                 (timer->repeat_count < 0 ? -1 : timer->repeat_count));\n\n  dictitem_T *di = tv_dict_item_alloc(\"callback\");\n  if (tv_dict_add(dict, di) == FAIL) {\n    xfree(di);\n    return;\n  }\n\n  callback_put(&timer->callback, &di->di_tv);\n}\n\nvoid add_timer_info_all(typval_T *rettv)\n{\n  tv_list_alloc_ret(rettv, map_size(&timers));\n  timer_T *timer;\n  map_foreach_value(&timers, timer, {\n    if (!timer->stopped) {\n      add_timer_info(rettv, timer);\n    }\n  })\n}\n\n// invoked on the main loop\nvoid timer_due_cb(TimeWatcher *tw, void *data)\n{\n  timer_T *timer = (timer_T *)data;\n  int save_did_emsg = did_emsg;\n  int save_called_emsg = called_emsg;\n  const bool save_ex_pressedreturn = get_pressedreturn();\n\n  if (timer->stopped || timer->paused) {\n    return;\n  }\n\n  timer->refcount++;\n  // if repeat was negative repeat forever\n  if (timer->repeat_count >= 0 && --timer->repeat_count == 0) {\n    timer_stop(timer);\n  }\n\n  typval_T argv[2] = { TV_INITIAL_VALUE, TV_INITIAL_VALUE };\n  argv[0].v_type = VAR_NUMBER;\n  argv[0].vval.v_number = timer->timer_id;\n  typval_T rettv = TV_INITIAL_VALUE;\n  called_emsg = false;\n\n  callback_call(&timer->callback, 1, argv, &rettv);\n\n  // Handle error message\n  if (called_emsg && did_emsg) {\n    timer->emsg_count++;\n    if (current_exception != NULL) {\n      discard_current_exception();\n    }\n  }\n  did_emsg = save_did_emsg;\n  called_emsg = save_called_emsg;\n  set_pressedreturn(save_ex_pressedreturn);\n\n  if (timer->emsg_count >= 3) {\n    timer_stop(timer);\n  }\n\n  tv_clear(&rettv);\n\n  if (!timer->stopped && timer->timeout == 0) {\n    // special case: timeout=0 means the callback will be\n    // invoked again on the next event loop tick.\n    // we don't use uv_idle_t to not spin the event loop\n    // when the main loop is blocked.\n    time_watcher_start(&timer->tw, timer_due_cb, 0, 0);\n  }\n  timer_decref(timer);\n}\n\nuint64_t timer_start(const long timeout, const int repeat_count, const Callback *const callback)\n{\n  timer_T *timer = xmalloc(sizeof *timer);\n  timer->refcount = 1;\n  timer->stopped = false;\n  timer->paused = false;\n  timer->emsg_count = 0;\n  timer->repeat_count = repeat_count;\n  timer->timeout = timeout;\n  timer->timer_id = last_timer_id++;\n  timer->callback = *callback;\n\n  time_watcher_init(&main_loop, &timer->tw, timer);\n  timer->tw.events = multiqueue_new_child(main_loop.events);\n  // if main loop is blocked, don't queue up multiple events\n  timer->tw.blockable = true;\n  time_watcher_start(&timer->tw, timer_due_cb, timeout, timeout);\n\n  pmap_put(uint64_t)(&timers, timer->timer_id, timer);\n  return timer->timer_id;\n}\n\nvoid timer_stop(timer_T *timer)\n{\n  if (timer->stopped) {\n    // avoid double free\n    return;\n  }\n  timer->stopped = true;\n  time_watcher_stop(&timer->tw);\n  time_watcher_close(&timer->tw, timer_close_cb);\n}\n\n// This will be run on the main loop after the last timer_due_cb, so at this\n// point it is safe to free the callback.\nstatic void timer_close_cb(TimeWatcher *tw, void *data)\n{\n  timer_T *timer = (timer_T *)data;\n  multiqueue_free(timer->tw.events);\n  callback_free(&timer->callback);\n  pmap_del(uint64_t)(&timers, timer->timer_id);\n  timer_decref(timer);\n}\n\nstatic void timer_decref(timer_T *timer)\n{\n  if (--timer->refcount == 0) {\n    xfree(timer);\n  }\n}\n\nvoid timer_stop_all(void)\n{\n  timer_T *timer;\n  map_foreach_value(&timers, timer, {\n    timer_stop(timer);\n  })\n}\n\nvoid timer_teardown(void)\n{\n  timer_stop_all();\n}\n\n/// Write \"list\" of strings to file \"fd\".\n///\n/// @param  fp  File to write to.\n/// @param[in]  list  List to write.\n/// @param[in]  binary  Whether to write in binary mode.\n///\n/// @return true in case of success, false otherwise.\nbool write_list(FileDescriptor *const fp, const list_T *const list, const bool binary)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  int error = 0;\n  TV_LIST_ITER_CONST(list, li, {\n    const char *const s = tv_get_string_chk(TV_LIST_ITEM_TV(li));\n    if (s == NULL) {\n      return false;\n    }\n    const char *hunk_start = s;\n    for (const char *p = hunk_start;; p++) {\n      if (*p == NUL || *p == NL) {\n        if (p != hunk_start) {\n          const ptrdiff_t written = file_write(fp, hunk_start,\n                                               (size_t)(p - hunk_start));\n          if (written < 0) {\n            error = (int)written;\n            goto write_list_error;\n          }\n        }\n        if (*p == NUL) {\n          break;\n        } else {\n          hunk_start = p + 1;\n          const ptrdiff_t written = file_write(fp, (char[]){ NUL }, 1);\n          if (written < 0) {\n            error = (int)written;\n            break;\n          }\n        }\n      }\n    }\n    if (!binary || TV_LIST_ITEM_NEXT(list, li) != NULL) {\n      const ptrdiff_t written = file_write(fp, \"\\n\", 1);\n      if (written < 0) {\n        error = (int)written;\n        goto write_list_error;\n      }\n    }\n  });\n  if ((error = file_flush(fp)) != 0) {\n    goto write_list_error;\n  }\n  return true;\nwrite_list_error:\n  emsgf(_(e_write2), os_strerror(error));\n  return false;\n}\n\n/// Write a blob to file with descriptor `fp`.\n///\n/// @param[in]  fp  File to write to.\n/// @param[in]  blob  Blob to write.\n///\n/// @return true on success, or false on failure.\nbool write_blob(FileDescriptor *const fp, const blob_T *const blob)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  int error = 0;\n  const int len = tv_blob_len(blob);\n  if (len > 0) {\n    const ptrdiff_t written = file_write(fp, blob->bv_ga.ga_data, (size_t)len);\n    if (written < (ptrdiff_t)len) {\n      error = (int)written;\n      goto write_blob_error;\n    }\n  }\n  error = file_flush(fp);\n  if (error != 0) {\n    goto write_blob_error;\n  }\n  return true;\nwrite_blob_error:\n  EMSG2(_(e_write2), os_strerror(error));\n  return false;\n}\n\n/// Read a blob from a file `fd`.\n///\n/// @param[in]  fd  File to read from.\n/// @param[in,out]  blob  Blob to write to.\n///\n/// @return true on success, or false on failure.\nbool read_blob(FILE *const fd, blob_T *const blob)\n  FUNC_ATTR_NONNULL_ALL\n{\n  FileInfo file_info;\n  if (!os_fileinfo_fd(fileno(fd), &file_info)) {\n    return false;\n  }\n  const int size = (int)os_fileinfo_size(&file_info);\n  ga_grow(&blob->bv_ga, size);\n  blob->bv_ga.ga_len = size;\n  if (fread(blob->bv_ga.ga_data, 1, blob->bv_ga.ga_len, fd)\n      < (size_t)blob->bv_ga.ga_len) {\n    return false;\n  }\n  return true;\n}\n\n/// Saves a typval_T as a string.\n///\n/// For lists or buffers, replaces NLs with NUL and separates items with NLs.\n///\n/// @param[in]  tv   Value to store as a string.\n/// @param[out] len  Length of the resulting string or -1 on error.\n/// @param[in]  endnl If true, the output will end in a newline (if a list).\n/// @returns an allocated string if `tv` represents a VimL string, list, or\n///          number; NULL otherwise.\nchar *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)\n  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL\n{\n  *len = 0;\n  if (tv->v_type == VAR_UNKNOWN) {\n    return NULL;\n  }\n\n  // For other types, let tv_get_string_buf_chk() get the value or\n  // print an error.\n  if (tv->v_type != VAR_LIST && tv->v_type != VAR_NUMBER) {\n    const char *ret = tv_get_string_chk(tv);\n    if (ret) {\n      *len = strlen(ret);\n      return xmemdupz(ret, (size_t)(*len));\n    } else {\n      *len = -1;\n      return NULL;\n    }\n  }\n\n  if (tv->v_type == VAR_NUMBER) {  // Treat number as a buffer-id.\n    buf_T *buf = buflist_findnr(tv->vval.v_number);\n    if (buf) {\n      for (linenr_T lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++) {\n        for (char_u *p = ml_get_buf(buf, lnum, false); *p != NUL; p++) {\n          *len += 1;\n        }\n        *len += 1;\n      }\n    } else {\n      EMSGN(_(e_nobufnr), tv->vval.v_number);\n      *len = -1;\n      return NULL;\n    }\n\n    if (*len == 0) {\n      return NULL;\n    }\n\n    char *ret = xmalloc(*len + 1);\n    char *end = ret;\n    for (linenr_T lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++) {\n      for (char_u *p = ml_get_buf(buf, lnum, false); *p != NUL; p++) {\n        *end++ = (*p == '\\n') ? NUL : *p;\n      }\n      *end++ = '\\n';\n    }\n    *end = NUL;\n    *len = end - ret;\n    return ret;\n  }\n\n  assert(tv->v_type == VAR_LIST);\n  // Pre-calculate the resulting length.\n  list_T *list = tv->vval.v_list;\n  TV_LIST_ITER_CONST(list, li, {\n    *len += strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + 1;\n  });\n\n  if (*len == 0) {\n    return NULL;\n  }\n\n  char *ret = xmalloc(*len + endnl);\n  char *end = ret;\n  TV_LIST_ITER_CONST(list, li, {\n    for (const char *s = tv_get_string(TV_LIST_ITEM_TV(li)); *s != NUL; s++) {\n      *end++ = (*s == '\\n') ? NUL : *s;\n    }\n    if (endnl || TV_LIST_ITEM_NEXT(list, li) != NULL) {\n      *end++ = '\\n';\n    }\n  });\n  *end = NUL;\n  *len = end - ret;\n  return ret;\n}\n\n/// Translate a VimL object into a position\n///\n/// Accepts VAR_LIST and VAR_STRING objects. Does not give an error for invalid\n/// type.\n///\n/// @param[in]  tv  Object to translate.\n/// @param[in]  dollar_lnum  True when \"$\" is last line.\n/// @param[out]  ret_fnum  Set to fnum for marks.\n///\n/// @return Pointer to position or NULL in case of error (e.g. invalid type).\npos_T *var2fpos(const typval_T *const tv, const bool dollar_lnum, int *const ret_fnum)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  static pos_T pos;\n  pos_T *pp;\n\n  // Argument can be [lnum, col, coladd].\n  if (tv->v_type == VAR_LIST) {\n    list_T *l;\n    int len;\n    bool error = false;\n    listitem_T *li;\n\n    l = tv->vval.v_list;\n    if (l == NULL) {\n      return NULL;\n    }\n\n    // Get the line number.\n    pos.lnum = tv_list_find_nr(l, 0L, &error);\n    if (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count) {\n      // Invalid line number.\n      return NULL;\n    }\n\n    // Get the column number.\n    pos.col = tv_list_find_nr(l, 1L, &error);\n    if (error) {\n      return NULL;\n    }\n    len = (long)STRLEN(ml_get(pos.lnum));\n\n    // We accept \"$\" for the column number: last column.\n    li = tv_list_find(l, 1L);\n    if (li != NULL && TV_LIST_ITEM_TV(li)->v_type == VAR_STRING\n        && TV_LIST_ITEM_TV(li)->vval.v_string != NULL\n        && STRCMP(TV_LIST_ITEM_TV(li)->vval.v_string, \"$\") == 0) {\n      pos.col = len + 1;\n    }\n\n    // Accept a position up to the NUL after the line.\n    if (pos.col == 0 || (int)pos.col > len + 1) {\n      // Invalid column number.\n      return NULL;\n    }\n    pos.col--;\n\n    // Get the virtual offset.  Defaults to zero.\n    pos.coladd = tv_list_find_nr(l, 2L, &error);\n    if (error) {\n      pos.coladd = 0;\n    }\n\n    return &pos;\n  }\n\n  const char *const name = tv_get_string_chk(tv);\n  if (name == NULL) {\n    return NULL;\n  }\n  if (name[0] == '.') {  // Cursor.\n    return &curwin->w_cursor;\n  }\n  if (name[0] == 'v' && name[1] == NUL) {  // Visual start.\n    if (VIsual_active) {\n      return &VIsual;\n    }\n    return &curwin->w_cursor;\n  }\n  if (name[0] == '\\'') {  // Mark.\n    pp = getmark_buf_fnum(curbuf, (uint8_t)name[1], false, ret_fnum);\n    if (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0) {\n      return NULL;\n    }\n    return pp;\n  }\n\n  pos.coladd = 0;\n\n  if (name[0] == 'w' && dollar_lnum) {\n    pos.col = 0;\n    if (name[1] == '0') {               // \"w0\": first visible line\n      update_topline(curwin);\n      // In silent Ex mode topline is zero, but that's not a valid line\n      // number; use one instead.\n      pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n      return &pos;\n    } else if (name[1] == '$') {      // \"w$\": last visible line\n      validate_botline(curwin);\n      // In silent Ex mode botline is zero, return zero then.\n      pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n      return &pos;\n    }\n  } else if (name[0] == '$') {        // last column or line\n    if (dollar_lnum) {\n      pos.lnum = curbuf->b_ml.ml_line_count;\n      pos.col = 0;\n    } else {\n      pos.lnum = curwin->w_cursor.lnum;\n      pos.col = (colnr_T)STRLEN(get_cursor_line_ptr());\n    }\n    return &pos;\n  }\n  return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\nint list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp)\n{\n  list_T *l;\n  long i = 0;\n  long n;\n\n  // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n  // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n  if (arg->v_type != VAR_LIST\n      || (l = arg->vval.v_list) == NULL\n      || tv_list_len(l) < (fnump == NULL ? 2 : 3)\n      || tv_list_len(l) > (fnump == NULL ? 4 : 5)) {\n    return FAIL;\n  }\n\n  if (fnump != NULL) {\n    n = tv_list_find_nr(l, i++, NULL);  // fnum\n    if (n < 0) {\n      return FAIL;\n    }\n    if (n == 0) {\n      n = curbuf->b_fnum;  // Current buffer.\n    }\n    *fnump = n;\n  }\n\n  n = tv_list_find_nr(l, i++, NULL);  // lnum\n  if (n < 0) {\n    return FAIL;\n  }\n  posp->lnum = n;\n\n  n = tv_list_find_nr(l, i++, NULL);  // col\n  if (n < 0) {\n    return FAIL;\n  }\n  posp->col = n;\n\n  n = tv_list_find_nr(l, i, NULL);  // off\n  if (n < 0) {\n    posp->coladd = 0;\n  } else {\n    posp->coladd = n;\n  }\n\n  if (curswantp != NULL) {\n    *curswantp = tv_list_find_nr(l, i + 1, NULL);  // curswant\n  }\n\n  return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\nstatic int get_env_len(const char_u **arg)\n{\n  int len;\n\n  const char_u *p;\n  for (p = *arg; vim_isIDc(*p); p++) {\n  }\n  if (p == *arg) {  // No name found.\n    return 0;\n  }\n\n  len = (int)(p - *arg);\n  *arg = p;\n  return len;\n}\n\n// Get the length of the name of a function or internal variable.\n// \"arg\" is advanced to the first non-white character after the name.\n// Return 0 if something is wrong.\nint get_id_len(const char **const arg)\n{\n  int len;\n\n  // Find the end of the name.\n  const char *p;\n  for (p = *arg; eval_isnamec(*p); p++) {\n    if (*p == ':') {\n      // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n      // slice \"[n:]\". Also \"xx:\" is not a namespace.\n      len = (int)(p - *arg);\n      if (len > 1\n          || (len == 1 && vim_strchr(namespace_char, **arg) == NULL)) {\n        break;\n      }\n    }\n  }\n  if (p == *arg) {  // no name found\n    return 0;\n  }\n\n  len = (int)(p - *arg);\n  *arg = (const char *)skipwhite((const char_u *)p);\n\n  return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\nint get_name_len(const char **const arg, char **alias, bool evaluate, bool verbose)\n{\n  int len;\n\n  *alias = NULL;    // default to no alias\n\n  if ((*arg)[0] == (char)K_SPECIAL && (*arg)[1] == (char)KS_EXTRA\n      && (*arg)[2] == (char)KE_SNR) {\n    // Hard coded <SNR>, already translated.\n    *arg += 3;\n    return get_id_len(arg) + 3;\n  }\n  len = eval_fname_script(*arg);\n  if (len > 0) {\n    // literal \"<SID>\", \"s:\" or \"<SNR>\"\n    *arg += len;\n  }\n\n  // Find the end of the name; check for {} construction.\n  char_u *expr_start;\n  char_u *expr_end;\n  const char *p = (const char *)find_name_end((char_u *)(*arg),\n                                              (const char_u **)&expr_start,\n                                              (const char_u **)&expr_end,\n                                              len > 0 ? 0 : FNE_CHECK_START);\n  if (expr_start != NULL) {\n    if (!evaluate) {\n      len += (int)(p - *arg);\n      *arg = (const char *)skipwhite((const char_u *)p);\n      return len;\n    }\n\n    /*\n     * Include any <SID> etc in the expanded string:\n     * Thus the -len here.\n     */\n    char_u *temp_string = make_expanded_name((char_u *)(*arg) - len, expr_start,\n                                             expr_end, (char_u *)p);\n    if (temp_string == NULL) {\n      return -1;\n    }\n    *alias = (char *)temp_string;\n    *arg = (const char *)skipwhite((const char_u *)p);\n    return (int)STRLEN(temp_string);\n  }\n\n  len += get_id_len(arg);\n  // Only give an error when there is something, otherwise it will be\n  // reported at a higher level.\n  if (len == 0 && verbose && **arg != NUL) {\n    EMSG2(_(e_invexpr2), *arg);\n  }\n\n  return len;\n}\n\n// Find the end of a variable or function name, taking care of magic braces.\n// If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n// start and end of the first magic braces item.\n// \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n// Return a pointer to just after the name.  Equal to \"arg\" if there is no\n// valid name.\nconst char_u *find_name_end(const char_u *arg, const char_u **expr_start, const char_u **expr_end,\n                            int flags)\n{\n  int mb_nest = 0;\n  int br_nest = 0;\n  int len;\n\n  if (expr_start != NULL) {\n    *expr_start = NULL;\n    *expr_end = NULL;\n  }\n\n  // Quick check for valid starting character.\n  if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg) && *arg != '{') {\n    return arg;\n  }\n\n  const char_u *p;\n  for (p = arg; *p != NUL\n       && (eval_isnamec(*p)\n           || *p == '{'\n           || ((flags & FNE_INCL_BR) && (*p == '[' || *p == '.'))\n           || mb_nest != 0\n           || br_nest != 0); MB_PTR_ADV(p)) {\n    if (*p == '\\'') {\n      // skip over 'string' to avoid counting [ and ] inside it.\n      for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p)) {\n      }\n      if (*p == NUL) {\n        break;\n      }\n    } else if (*p == '\"') {\n      // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n      for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p)) {\n        if (*p == '\\\\' && p[1] != NUL) {\n          ++p;\n        }\n      }\n      if (*p == NUL) {\n        break;\n      }\n    } else if (br_nest == 0 && mb_nest == 0 && *p == ':') {\n      // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n      // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is. */\n      len = (int)(p - arg);\n      if ((len > 1 && p[-1] != '}')\n          || (len == 1 && vim_strchr(namespace_char, *arg) == NULL)) {\n        break;\n      }\n    }\n\n    if (mb_nest == 0) {\n      if (*p == '[') {\n        ++br_nest;\n      } else if (*p == ']') {\n        --br_nest;\n      }\n    }\n\n    if (br_nest == 0) {\n      if (*p == '{') {\n        mb_nest++;\n        if (expr_start != NULL && *expr_start == NULL) {\n          *expr_start = p;\n        }\n      } else if (*p == '}') {\n        mb_nest--;\n        if (expr_start != NULL && mb_nest == 0 && *expr_end == NULL) {\n          *expr_end = p;\n        }\n      }\n    }\n  }\n\n  return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *                      \"in_start\"      ^\n *                      \"expr_start\"       ^\n *                      \"expr_end\"               ^\n *                      \"in_end\"                            ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\nstatic char_u *make_expanded_name(const char_u *in_start, char_u *expr_start, char_u *expr_end,\n                                  char_u *in_end)\n{\n  char_u c1;\n  char_u *retval = NULL;\n  char_u *temp_result;\n  char_u *nextcmd = NULL;\n\n  if (expr_end == NULL || in_end == NULL) {\n    return NULL;\n  }\n  *expr_start = NUL;\n  *expr_end = NUL;\n  c1 = *in_end;\n  *in_end = NUL;\n\n  temp_result = eval_to_string(expr_start + 1, &nextcmd, false);\n  if (temp_result != NULL && nextcmd == NULL) {\n    retval = xmalloc(STRLEN(temp_result) + (expr_start - in_start)\n                     + (in_end - expr_end) + 1);\n    STRCPY(retval, in_start);\n    STRCAT(retval, temp_result);\n    STRCAT(retval, expr_end + 1);\n  }\n  xfree(temp_result);\n\n  *in_end = c1;                 // put char back for error messages\n  *expr_start = '{';\n  *expr_end = '}';\n\n  if (retval != NULL) {\n    temp_result = (char_u *)find_name_end(retval,\n                                          (const char_u **)&expr_start,\n                                          (const char_u **)&expr_end, 0);\n    if (expr_start != NULL) {\n      // Further expansion!\n      temp_result = make_expanded_name(retval, expr_start,\n                                       expr_end, temp_result);\n      xfree(retval);\n      retval = temp_result;\n    }\n  }\n\n  return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\nint eval_isnamec(int c)\n{\n  return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\nint eval_isnamec1(int c)\n{\n  return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Get number v: variable value.\n */\nvarnumber_T get_vim_var_nr(int idx) FUNC_ATTR_PURE\n{\n  return vimvars[idx].vv_nr;\n}\n\n// Get string v: variable value.  Uses a static buffer, can only be used once.\n// If the String variable has never been set, return an empty string.\n// Never returns NULL;\nchar_u *get_vim_var_str(int idx) FUNC_ATTR_PURE FUNC_ATTR_NONNULL_RET\n{\n  return (char_u *)tv_get_string(&vimvars[idx].vv_tv);\n}\n\n/*\n * Get List v: variable value.  Caller must take care of reference count when\n * needed.\n */\nlist_T *get_vim_var_list(int idx) FUNC_ATTR_PURE\n{\n  return vimvars[idx].vv_list;\n}\n\n/// Get Dictionary v: variable value.  Caller must take care of reference count\n/// when needed.\ndict_T *get_vim_var_dict(int idx) FUNC_ATTR_PURE\n{\n  return vimvars[idx].vv_dict;\n}\n\n/*\n * Set v:char to character \"c\".\n */\nvoid set_vim_var_char(int c)\n{\n  char buf[MB_MAXBYTES + 1];\n\n  buf[utf_char2bytes(c, (char_u *)buf)] = NUL;\n  set_vim_var_string(VV_CHAR, buf, -1);\n}\n\n/*\n * Set v:count to \"count\" and v:count1 to \"count1\".\n * When \"set_prevcount\" is TRUE first set v:prevcount from v:count.\n */\nvoid set_vcount(long count, long count1, int set_prevcount)\n{\n  if (set_prevcount) {\n    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;\n  }\n  vimvars[VV_COUNT].vv_nr = count;\n  vimvars[VV_COUNT1].vv_nr = count1;\n}\n\n/// Set number v: variable to the given value\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in]  val  Value to set to.\nvoid set_vim_var_nr(const VimVarIndex idx, const varnumber_T val)\n{\n  tv_clear(&vimvars[idx].vv_tv);\n  vimvars[idx].vv_type = VAR_NUMBER;\n  vimvars[idx].vv_nr = val;\n}\n\n/// Set boolean v: {true, false} to the given value\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in]  val  Value to set to.\nvoid set_vim_var_bool(const VimVarIndex idx, const BoolVarValue val)\n{\n  tv_clear(&vimvars[idx].vv_tv);\n  vimvars[idx].vv_type = VAR_BOOL;\n  vimvars[idx].vv_bool = val;\n}\n\n/// Set special v: variable to the given value\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in]  val  Value to set to.\nvoid set_vim_var_special(const VimVarIndex idx, const SpecialVarValue val)\n{\n  tv_clear(&vimvars[idx].vv_tv);\n  vimvars[idx].vv_type = VAR_SPECIAL;\n  vimvars[idx].vv_special = val;\n}\n\n/// Set string v: variable to the given string\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in]  val  Value to set to. Will be copied.\n/// @param[in]  len  Length of that value or -1 in which case strlen() will be\n///                  used.\nvoid set_vim_var_string(const VimVarIndex idx, const char *const val, const ptrdiff_t len)\n{\n  tv_clear(&vimvars[idx].vv_di.di_tv);\n  vimvars[idx].vv_type = VAR_STRING;\n  if (val == NULL) {\n    vimvars[idx].vv_str = NULL;\n  } else if (len == -1) {\n    vimvars[idx].vv_str = (char_u *)xstrdup(val);\n  } else {\n    vimvars[idx].vv_str = (char_u *)xstrndup(val, (size_t)len);\n  }\n}\n\n/// Set list v: variable to the given list\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in,out]  val  Value to set to. Reference count will be incremented.\nvoid set_vim_var_list(const VimVarIndex idx, list_T *const val)\n{\n  tv_clear(&vimvars[idx].vv_di.di_tv);\n  vimvars[idx].vv_type = VAR_LIST;\n  vimvars[idx].vv_list = val;\n  if (val != NULL) {\n    tv_list_ref(val);\n  }\n}\n\n/// Set Dictionary v: variable to the given dictionary\n///\n/// @param[in]  idx  Index of variable to set.\n/// @param[in,out]  val  Value to set to. Reference count will be incremented.\n///                      Also keys of the dictionary will be made read-only.\nvoid set_vim_var_dict(const VimVarIndex idx, dict_T *const val)\n{\n  tv_clear(&vimvars[idx].vv_di.di_tv);\n  vimvars[idx].vv_type = VAR_DICT;\n  vimvars[idx].vv_dict = val;\n\n  if (val != NULL) {\n    val->dv_refcount++;\n    // Set readonly\n    tv_dict_set_keys_readonly(val);\n  }\n}\n\n/// Set the v:argv list.\nvoid set_argv_var(char **argv, int argc)\n{\n  list_T *l = tv_list_alloc(argc);\n  int i;\n\n  tv_list_set_lock(l, VAR_FIXED);\n  for (i = 0; i < argc; i++) {\n    tv_list_append_string(l, (const char *const)argv[i], -1);\n    TV_LIST_ITEM_TV(tv_list_last(l))->v_lock = VAR_FIXED;\n  }\n  set_vim_var_list(VV_ARGV, l);\n}\n\n/*\n * Set v:register if needed.\n */\nvoid set_reg_var(int c)\n{\n  char regname;\n\n  if (c == 0 || c == ' ') {\n    regname = '\"';\n  } else {\n    regname = c;\n  }\n  // Avoid free/alloc when the value is already right.\n  if (vimvars[VV_REG].vv_str == NULL || vimvars[VV_REG].vv_str[0] != c) {\n    set_vim_var_string(VV_REG, &regname, 1);\n  }\n}\n\n/*\n * Get or set v:exception.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:exception!  Does not\n * take care of memory allocations.\n */\nchar_u *v_exception(char_u *oldval)\n{\n  if (oldval == NULL) {\n    return vimvars[VV_EXCEPTION].vv_str;\n  }\n\n  vimvars[VV_EXCEPTION].vv_str = oldval;\n  return NULL;\n}\n\n/*\n * Get or set v:throwpoint.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:throwpoint!  Does not\n * take care of memory allocations.\n */\nchar_u *v_throwpoint(char_u *oldval)\n{\n  if (oldval == NULL) {\n    return vimvars[VV_THROWPOINT].vv_str;\n  }\n\n  vimvars[VV_THROWPOINT].vv_str = oldval;\n  return NULL;\n}\n\n/*\n * Set v:cmdarg.\n * If \"eap\" != NULL, use \"eap\" to generate the value and return the old value.\n * If \"oldarg\" != NULL, restore the value to \"oldarg\" and return NULL.\n * Must always be called in pairs!\n */\nchar_u *set_cmdarg(exarg_T *eap, char_u *oldarg)\n{\n  char_u *oldval = vimvars[VV_CMDARG].vv_str;\n  if (eap == NULL) {\n    xfree(oldval);\n    vimvars[VV_CMDARG].vv_str = oldarg;\n    return NULL;\n  }\n\n  size_t len = 0;\n  if (eap->force_bin == FORCE_BIN) {\n    len = 6;\n  } else if (eap->force_bin == FORCE_NOBIN) {\n    len = 8;\n  }\n\n  if (eap->read_edit) {\n    len += 7;\n  }\n\n  if (eap->force_ff != 0) {\n    len += 10;  // \" ++ff=unix\"\n  }\n  if (eap->force_enc != 0) {\n    len += STRLEN(eap->cmd + eap->force_enc) + 7;\n  }\n  if (eap->bad_char != 0) {\n    len += 7 + 4;  // \" ++bad=\" + \"keep\" or \"drop\"\n  }\n\n  const size_t newval_len = len + 1;\n  char_u *newval = xmalloc(newval_len);\n\n  if (eap->force_bin == FORCE_BIN) {\n    sprintf((char *)newval, \" ++bin\");\n  } else if (eap->force_bin == FORCE_NOBIN) {\n    sprintf((char *)newval, \" ++nobin\");\n  } else {\n    *newval = NUL;\n  }\n\n  if (eap->read_edit) {\n    STRCAT(newval, \" ++edit\");\n  }\n\n  if (eap->force_ff != 0) {\n    snprintf((char *)newval + STRLEN(newval), newval_len, \" ++ff=%s\",\n             eap->force_ff == 'u' ? \"unix\" :\n             eap->force_ff == 'd' ? \"dos\" : \"mac\");\n  }\n  if (eap->force_enc != 0) {\n    snprintf((char *)newval + STRLEN(newval), newval_len, \" ++enc=%s\",\n             eap->cmd + eap->force_enc);\n  }\n  if (eap->bad_char == BAD_KEEP) {\n    STRCPY(newval + STRLEN(newval), \" ++bad=keep\");\n  } else if (eap->bad_char == BAD_DROP) {\n    STRCPY(newval + STRLEN(newval), \" ++bad=drop\");\n  } else if (eap->bad_char != 0) {\n    snprintf((char *)newval + STRLEN(newval), newval_len, \" ++bad=%c\",\n             eap->bad_char);\n  }\n  vimvars[VV_CMDARG].vv_str = newval;\n  return oldval;\n}\n\n/// Get the value of internal variable \"name\".\n/// Return OK or FAIL.  If OK is returned \"rettv\" must be cleared.\n///\n/// @param len  length of \"name\"\n/// @param rettv  NULL when only checking existence\n/// @param dip  non-NULL when typval's dict item is needed\n/// @param verbose  may give error message\n/// @param no_autoload  do not use script autoloading\nint get_var_tv(const char *name, int len, typval_T *rettv, dictitem_T **dip, int verbose,\n               int no_autoload)\n{\n  int ret = OK;\n  typval_T *tv = NULL;\n  dictitem_T *v;\n\n  v = find_var(name, (size_t)len, NULL, no_autoload);\n  if (v != NULL) {\n    tv = &v->di_tv;\n    if (dip != NULL) {\n      *dip = v;\n    }\n  }\n\n  if (tv == NULL) {\n    if (rettv != NULL && verbose) {\n      emsgf(_(\"E121: Undefined variable: %.*s\"), len, name);\n    }\n    ret = FAIL;\n  } else if (rettv != NULL) {\n    tv_copy(tv, rettv);\n  }\n\n  return ret;\n}\n\n/// Check if variable \"name[len]\" is a local variable or an argument.\n/// If so, \"*eval_lavars_used\" is set to true.\nstatic void check_vars(const char *name, size_t len)\n{\n  if (eval_lavars_used == NULL) {\n    return;\n  }\n\n  const char *varname;\n  hashtab_T *ht = find_var_ht(name, len, &varname);\n\n  if (ht == get_funccal_local_ht() || ht == get_funccal_args_ht()) {\n    if (find_var(name, len, NULL, true) != NULL) {\n      *eval_lavars_used = true;\n    }\n  }\n}\n\n/// check if special v:lua value for calling lua functions\nbool is_luafunc(partial_T *partial)\n{\n  return partial == vvlua_partial;\n}\n\n/// check if special v:lua value for calling lua functions\nstatic bool tv_is_luafunc(typval_T *tv)\n{\n  return tv->v_type == VAR_PARTIAL && is_luafunc(tv->vval.v_partial);\n}\n\n/// Skips one character past the end of the name of a v:lua function.\n/// @param p  Pointer to the char AFTER the \"v:lua.\" prefix.\n/// @return Pointer to the char one past the end of the function's name.\nconst char *skip_luafunc_name(const char *p)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  while (ASCII_ISALNUM(*p) || *p == '_' || *p == '.' || *p == '\\'') {\n    p++;\n  }\n  return p;\n}\n\n/// check the function name after \"v:lua.\"\nint check_luafunc_name(const char *const str, const bool paren)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  const char *const p = skip_luafunc_name(str);\n  if (*p != (paren ? '(' : NUL)) {\n    return 0;\n  } else {\n    return (int)(p-str);\n  }\n}\n\n/// Handle:\n/// - expr[expr], expr[expr:expr] subscript\n/// - \".name\" lookup\n/// - function call with Funcref variable: func(expr)\n/// - method call: var->method()\n///\n/// Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n///\n/// @param evaluate  do more than finding the end\n/// @param verbose  give error messages\n/// @param start_leader  start of '!' and '-' prefixes\n/// @param end_leaderp  end of '!' and '-' prefixes\nint handle_subscript(const char **const arg, typval_T *rettv, int evaluate, int verbose,\n                     const char_u *const start_leader, const char_u **const end_leaderp)\n{\n  int ret = OK;\n  dict_T *selfdict = NULL;\n  const char_u *lua_funcname = NULL;\n\n  if (tv_is_luafunc(rettv)) {\n    if (**arg != '.') {\n      tv_clear(rettv);\n      ret = FAIL;\n    } else {\n      (*arg)++;\n\n      lua_funcname = (char_u *)(*arg);\n      const int len = check_luafunc_name(*arg, true);\n      if (len == 0) {\n        tv_clear(rettv);\n        ret = FAIL;\n      }\n      (*arg) += len;\n    }\n  }\n\n  // \".\" is \".name\" lookup when we found a dict.\n  while (ret == OK\n         && (((**arg == '[' || (**arg == '.' && rettv->v_type == VAR_DICT)\n               || (**arg == '(' && (!evaluate || tv_is_func(*rettv))))\n              && !ascii_iswhite(*(*arg - 1)))\n             || (**arg == '-' && (*arg)[1] == '>'))) {\n    if (**arg == '(') {\n      ret = call_func_rettv((char_u **)arg, rettv, evaluate, selfdict, NULL,\n                            lua_funcname);\n\n      // Stop the expression evaluation when immediately aborting on\n      // error, or when an interrupt occurred or an exception was thrown\n      // but not caught.\n      if (aborting()) {\n        if (ret == OK) {\n          tv_clear(rettv);\n        }\n        ret = FAIL;\n      }\n      tv_dict_unref(selfdict);\n      selfdict = NULL;\n    } else if (**arg == '-') {\n      // Expression \"-1.0->method()\" applies the leader \"-\" before\n      // applying ->.\n      if (evaluate && *end_leaderp > start_leader) {\n        ret = eval7_leader(rettv, start_leader, end_leaderp);\n      }\n      if (ret == OK) {\n        if ((*arg)[2] == '{') {\n          // expr->{lambda}()\n          ret = eval_lambda((char_u **)arg, rettv, evaluate, verbose);\n        } else {\n          // expr->name()\n          ret = eval_method((char_u **)arg, rettv, evaluate, verbose);\n        }\n      }\n    } else {  // **arg == '[' || **arg == '.'\n      tv_dict_unref(selfdict);\n      if (rettv->v_type == VAR_DICT) {\n        selfdict = rettv->vval.v_dict;\n        if (selfdict != NULL) {\n          ++selfdict->dv_refcount;\n        }\n      } else {\n        selfdict = NULL;\n      }\n      if (eval_index((char_u **)arg, rettv, evaluate, verbose) == FAIL) {\n        tv_clear(rettv);\n        ret = FAIL;\n      }\n    }\n  }\n\n  // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n  if (selfdict != NULL && tv_is_func(*rettv)) {\n    set_selfdict(rettv, selfdict);\n  }\n\n  tv_dict_unref(selfdict);\n  return ret;\n}\n\nvoid set_selfdict(typval_T *const rettv, dict_T *const selfdict)\n{\n  // Don't do this when \"dict.Func\" is already a partial that was bound\n  // explicitly (pt_auto is false).\n  if (rettv->v_type == VAR_PARTIAL && !rettv->vval.v_partial->pt_auto\n      && rettv->vval.v_partial->pt_dict != NULL) {\n    return;\n  }\n  make_partial(selfdict, rettv);\n}\n\n// Find variable \"name\" in the list of variables.\n// Return a pointer to it if found, NULL if not found.\n// Careful: \"a:0\" variables don't have a name.\n// When \"htp\" is not NULL we are writing to the variable, set \"htp\" to the\n// hashtab_T used.\ndictitem_T *find_var(const char *const name, const size_t name_len, hashtab_T **htp,\n                     int no_autoload)\n{\n  const char *varname;\n  hashtab_T *const ht = find_var_ht(name, name_len, &varname);\n  if (htp != NULL) {\n    *htp = ht;\n  }\n  if (ht == NULL) {\n    return NULL;\n  }\n  dictitem_T *const ret = find_var_in_ht(ht, *name,\n                                         varname,\n                                         name_len - (size_t)(varname - name),\n                                         no_autoload || htp != NULL);\n  if (ret != NULL) {\n    return ret;\n  }\n\n  // Search in parent scope for lambda\n  return find_var_in_scoped_ht(name, name_len, no_autoload || htp != NULL);\n}\n\n/// Find variable in hashtab.\n/// When \"varname\" is empty returns curwin/curtab/etc vars dictionary.\n///\n/// @param[in]  ht  Hashtab to find variable in.\n/// @param[in]  htname  Hashtab name (first character).\n/// @param[in]  varname  Variable name.\n/// @param[in]  varname_len  Variable name length.\n/// @param[in]  no_autoload  If true then autoload scripts will not be sourced\n///                          if autoload variable was not found.\n///\n/// @return pointer to the dictionary item with the found variable or NULL if it\n///         was not found.\ndictitem_T *find_var_in_ht(hashtab_T *const ht, int htname, const char *const varname,\n                           const size_t varname_len, int no_autoload)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  hashitem_T *hi;\n\n  if (varname_len == 0) {\n    // Must be something like \"s:\", otherwise \"ht\" would be NULL.\n    switch (htname) {\n    case 's':\n      return (dictitem_T *)&SCRIPT_SV(current_sctx.sc_sid)->sv_var;\n    case 'g':\n      return (dictitem_T *)&globvars_var;\n    case 'v':\n      return (dictitem_T *)&vimvars_var;\n    case 'b':\n      return (dictitem_T *)&curbuf->b_bufvar;\n    case 'w':\n      return (dictitem_T *)&curwin->w_winvar;\n    case 't':\n      return (dictitem_T *)&curtab->tp_winvar;\n    case 'l':\n      return get_funccal_local_var();\n    case 'a':\n      return get_funccal_args_var();\n    }\n    return NULL;\n  }\n\n  hi = hash_find_len(ht, varname, varname_len);\n  if (HASHITEM_EMPTY(hi)) {\n    // For global variables we may try auto-loading the script.  If it\n    // worked find the variable again.  Don't auto-load a script if it was\n    // loaded already, otherwise it would be loaded every time when\n    // checking if a function name is a Funcref variable.\n    if (ht == &globvarht && !no_autoload) {\n      // Note: script_autoload() may make \"hi\" invalid. It must either\n      // be obtained again or not used.\n      if (!script_autoload(varname, varname_len, false) || aborting()) {\n        return NULL;\n      }\n      hi = hash_find_len(ht, varname, varname_len);\n    }\n    if (HASHITEM_EMPTY(hi)) {\n      return NULL;\n    }\n  }\n  return TV_DICT_HI2DI(hi);\n}\n\n/// Finds the dict (g:, l:, s:, \u2026) and hashtable used for a variable.\n///\n/// @param[in]  name  Variable name, possibly with scope prefix.\n/// @param[in]  name_len  Variable name length.\n/// @param[out]  varname  Will be set to the start of the name without scope\n///                       prefix.\n/// @param[out]  d  Scope dictionary.\n///\n/// @return Scope hashtab, NULL if name is not valid.\nstatic hashtab_T *find_var_ht_dict(const char *name, const size_t name_len, const char **varname,\n                                   dict_T **d)\n{\n  hashitem_T *hi;\n  funccall_T *funccal = get_funccal();\n  *d = NULL;\n\n  if (name_len == 0) {\n    return NULL;\n  }\n  if (name_len == 1 || name[1] != ':') {\n    // name has implicit scope\n    if (name[0] == ':' || name[0] == AUTOLOAD_CHAR) {\n      // The name must not start with a colon or #.\n      return NULL;\n    }\n    *varname = name;\n\n    // \"version\" is \"v:version\" in all scopes\n    hi = hash_find_len(&compat_hashtab, name, name_len);\n    if (!HASHITEM_EMPTY(hi)) {\n      return &compat_hashtab;\n    }\n\n    if (funccal == NULL) {  // global variable\n      *d = &globvardict;\n    } else {  // l: variable\n      *d = &funccal->l_vars;\n    }\n    goto end;\n  }\n\n  *varname = name + 2;\n  if (*name == 'g') {  // global variable\n    *d = &globvardict;\n  } else if (name_len > 2\n             && (memchr(name + 2, ':', name_len - 2) != NULL\n                 || memchr(name + 2, AUTOLOAD_CHAR, name_len - 2) != NULL)) {\n    // There must be no ':' or '#' in the rest of the name if g: was not used\n    return NULL;\n  }\n\n  if (*name == 'b') {  // buffer variable\n    *d = curbuf->b_vars;\n  } else if (*name == 'w') {  // window variable\n    *d = curwin->w_vars;\n  } else if (*name == 't') {  // tab page variable\n    *d = curtab->tp_vars;\n  } else if (*name == 'v') {  // v: variable\n    *d = &vimvardict;\n  } else if (*name == 'a' && funccal != NULL) {  // function argument\n    *d = &funccal->l_avars;\n  } else if (*name == 'l' && funccal != NULL) {  // local variable\n    *d = &funccal->l_vars;\n  } else if (*name == 's'  // script variable\n             && current_sctx.sc_sid > 0\n             && current_sctx.sc_sid <= ga_scripts.ga_len) {\n    *d = &SCRIPT_SV(current_sctx.sc_sid)->sv_dict;\n  }\n\nend:\n  return *d ? &(*d)->dv_hashtab : NULL;\n}\n\n/// Find the hashtable used for a variable\n///\n/// @param[in]  name  Variable name, possibly with scope prefix.\n/// @param[in]  name_len  Variable name length.\n/// @param[out]  varname  Will be set to the start of the name without scope\n///                       prefix.\n///\n/// @return Scope hashtab, NULL if name is not valid.\nhashtab_T *find_var_ht(const char *name, const size_t name_len, const char **varname)\n{\n  dict_T *d;\n  return find_var_ht_dict(name, name_len, varname, &d);\n}\n\n/*\n * Get the string value of a (global/local) variable.\n * Note: see tv_get_string() for how long the pointer remains valid.\n * Returns NULL when it doesn't exist.\n */\nchar_u *get_var_value(const char *const name)\n{\n  dictitem_T *v;\n\n  v = find_var(name, strlen(name), NULL, false);\n  if (v == NULL) {\n    return NULL;\n  }\n  return (char_u *)tv_get_string(&v->di_tv);\n}\n\n/*\n * Allocate a new hashtab for a sourced script.  It will be used while\n * sourcing this script and when executing functions defined in the script.\n */\nvoid new_script_vars(scid_T id)\n{\n  hashtab_T *ht;\n  scriptvar_T *sv;\n\n  ga_grow(&ga_scripts, (int)(id - ga_scripts.ga_len));\n  {\n    /* Re-allocating ga_data means that an ht_array pointing to\n     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is\n     * at its init value.  Also reset \"v_dict\", it's always the same. */\n    for (int i = 1; i <= ga_scripts.ga_len; ++i) {\n      ht = &SCRIPT_VARS(i);\n      if (ht->ht_mask == HT_INIT_SIZE - 1) {\n        ht->ht_array = ht->ht_smallarray;\n      }\n      sv = SCRIPT_SV(i);\n      sv->sv_var.di_tv.vval.v_dict = &sv->sv_dict;\n    }\n\n    while (ga_scripts.ga_len < id) {\n      sv = SCRIPT_SV(ga_scripts.ga_len + 1) = xcalloc(1, sizeof(scriptvar_T));\n      init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);\n      ++ga_scripts.ga_len;\n    }\n  }\n}\n\n/*\n * Initialize dictionary \"dict\" as a scope and set variable \"dict_var\" to\n * point to it.\n */\nvoid init_var_dict(dict_T *dict, ScopeDictDictItem *dict_var, int scope)\n{\n  hash_init(&dict->dv_hashtab);\n  dict->dv_lock = VAR_UNLOCKED;\n  dict->dv_scope = scope;\n  dict->dv_refcount = DO_NOT_FREE_CNT;\n  dict->dv_copyID = 0;\n  dict_var->di_tv.vval.v_dict = dict;\n  dict_var->di_tv.v_type = VAR_DICT;\n  dict_var->di_tv.v_lock = VAR_FIXED;\n  dict_var->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n  dict_var->di_key[0] = NUL;\n  QUEUE_INIT(&dict->watchers);\n}\n\n/*\n * Unreference a dictionary initialized by init_var_dict().\n */\nvoid unref_var_dict(dict_T *dict)\n{\n  /* Now the dict needs to be freed if no one else is using it, go back to\n   * normal reference counting. */\n  dict->dv_refcount -= DO_NOT_FREE_CNT - 1;\n  tv_dict_unref(dict);\n}\n\n/*\n * Clean up a list of internal variables.\n * Frees all allocated variables and the value they contain.\n * Clears hashtab \"ht\", does not free it.\n */\nvoid vars_clear(hashtab_T *ht)\n{\n  vars_clear_ext(ht, TRUE);\n}\n\n/*\n * Like vars_clear(), but only free the value if \"free_val\" is TRUE.\n */\nvoid vars_clear_ext(hashtab_T *ht, int free_val)\n{\n  int todo;\n  hashitem_T *hi;\n  dictitem_T *v;\n\n  hash_lock(ht);\n  todo = (int)ht->ht_used;\n  for (hi = ht->ht_array; todo > 0; ++hi) {\n    if (!HASHITEM_EMPTY(hi)) {\n      --todo;\n\n      // Free the variable.  Don't remove it from the hashtab,\n      // ht_array might change then.  hash_clear() takes care of it\n      // later.\n      v = TV_DICT_HI2DI(hi);\n      if (free_val) {\n        tv_clear(&v->di_tv);\n      }\n      if (v->di_flags & DI_FLAGS_ALLOC) {\n        xfree(v);\n      }\n    }\n  }\n  hash_clear(ht);\n  ht->ht_used = 0;\n}\n\n/*\n * Delete a variable from hashtab \"ht\" at item \"hi\".\n * Clear the variable value and free the dictitem.\n */\nstatic void delete_var(hashtab_T *ht, hashitem_T *hi)\n{\n  dictitem_T *di = TV_DICT_HI2DI(hi);\n\n  hash_remove(ht, hi);\n  tv_clear(&di->di_tv);\n  xfree(di);\n}\n\n/*\n * List the value of one internal variable.\n */\nstatic void list_one_var(dictitem_T *v, const char *prefix, int *first)\n{\n  char *const s = encode_tv2echo(&v->di_tv, NULL);\n  list_one_var_a(prefix, (const char *)v->di_key, STRLEN(v->di_key),\n                 v->di_tv.v_type, (s == NULL ? \"\" : s), first);\n  xfree(s);\n}\n\n/// @param[in]  name_len  Length of the name. May be -1, in this case strlen()\n///                       will be used.\n/// @param[in,out]  first  When true clear rest of screen and set to false.\nstatic void list_one_var_a(const char *prefix, const char *name, const ptrdiff_t name_len,\n                           const int type, const char *string, int *first)\n{\n  // don't use msg() or msg_attr() to avoid overwriting \"v:statusmsg\"\n  msg_start();\n  msg_puts(prefix);\n  if (name != NULL) {  // \"a:\" vars don't have a name stored\n    msg_puts_attr_len(name, name_len, 0);\n  }\n  msg_putchar(' ');\n  msg_advance(22);\n  if (type == VAR_NUMBER) {\n    msg_putchar('#');\n  } else if (type == VAR_FUNC || type == VAR_PARTIAL) {\n    msg_putchar('*');\n  } else if (type == VAR_LIST) {\n    msg_putchar('[');\n    if (*string == '[') {\n      ++string;\n    }\n  } else if (type == VAR_DICT) {\n    msg_putchar('{');\n    if (*string == '{') {\n      ++string;\n    }\n  } else {\n    msg_putchar(' ');\n  }\n\n  msg_outtrans((char_u *)string);\n\n  if (type == VAR_FUNC || type == VAR_PARTIAL) {\n    msg_puts(\"()\");\n  }\n  if (*first) {\n    msg_clr_eos();\n    *first = FALSE;\n  }\n}\n\n/// Set variable to the given value\n///\n/// If the variable already exists, the value is updated. Otherwise the variable\n/// is created.\n///\n/// @param[in]  name  Variable name to set.\n/// @param[in]  name_len  Length of the variable name.\n/// @param  tv  Variable value.\n/// @param[in]  copy  True if value in tv is to be copied.\nvoid set_var(const char *name, const size_t name_len, typval_T *const tv, const bool copy)\n  FUNC_ATTR_NONNULL_ALL\n{\n  set_var_const(name, name_len, tv, copy, false);\n}\n\n/// Set variable to the given value\n///\n/// If the variable already exists, the value is updated. Otherwise the variable\n/// is created.\n///\n/// @param[in]  name  Variable name to set.\n/// @param[in]  name_len  Length of the variable name.\n/// @param  tv  Variable value.\n/// @param[in]  copy  True if value in tv is to be copied.\n/// @param[in]  is_const  True if value in tv is to be locked.\nstatic void set_var_const(const char *name, const size_t name_len, typval_T *const tv,\n                          const bool copy, const bool is_const)\n  FUNC_ATTR_NONNULL_ALL\n{\n  dictitem_T *v;\n  hashtab_T *ht;\n  dict_T *dict;\n\n  const char *varname;\n  ht = find_var_ht_dict(name, name_len, &varname, &dict);\n  const bool watched = tv_dict_is_watched(dict);\n\n  if (ht == NULL || *varname == NUL) {\n    EMSG2(_(e_illvar), name);\n    return;\n  }\n  v = find_var_in_ht(ht, 0, varname, name_len - (size_t)(varname - name), true);\n\n  // Search in parent scope which is possible to reference from lambda\n  if (v == NULL) {\n    v = find_var_in_scoped_ht((const char *)name, name_len, true);\n  }\n\n  if (tv_is_func(*tv) && !var_check_func_name(name, v == NULL)) {\n    return;\n  }\n\n  typval_T oldtv = TV_INITIAL_VALUE;\n  if (v != NULL) {\n    if (is_const) {\n      EMSG(_(e_cannot_mod));\n      return;\n    }\n\n    // existing variable, need to clear the value\n    if (var_check_ro(v->di_flags, name, name_len)\n        || var_check_lock(v->di_tv.v_lock, name, name_len)) {\n      return;\n    }\n\n    // Handle setting internal v: variables separately where needed to\n    // prevent changing the type.\n    if (ht == &vimvarht) {\n      if (v->di_tv.v_type == VAR_STRING) {\n        XFREE_CLEAR(v->di_tv.vval.v_string);\n        if (copy || tv->v_type != VAR_STRING) {\n          const char *const val = tv_get_string(tv);\n\n          // Careful: when assigning to v:errmsg and tv_get_string()\n          // causes an error message the variable will already be set.\n          if (v->di_tv.vval.v_string == NULL) {\n            v->di_tv.vval.v_string = (char_u *)xstrdup(val);\n          }\n        } else {\n          // Take over the string to avoid an extra alloc/free.\n          v->di_tv.vval.v_string = tv->vval.v_string;\n          tv->vval.v_string = NULL;\n        }\n        return;\n      } else if (v->di_tv.v_type == VAR_NUMBER) {\n        v->di_tv.vval.v_number = tv_get_number(tv);\n        if (strcmp(varname, \"searchforward\") == 0) {\n          set_search_direction(v->di_tv.vval.v_number ? '/' : '?');\n        } else if (strcmp(varname, \"hlsearch\") == 0) {\n          no_hlsearch = !v->di_tv.vval.v_number;\n          redraw_all_later(SOME_VALID);\n        }\n        return;\n      } else if (v->di_tv.v_type != tv->v_type) {\n        EMSG2(_(\"E963: setting %s to value with wrong type\"), name);\n        return;\n      }\n    }\n\n    if (watched) {\n      tv_copy(&v->di_tv, &oldtv);\n    }\n    tv_clear(&v->di_tv);\n  } else {  // Add a new variable.\n    // Can't add \"v:\" or \"a:\" variable.\n    if (ht == &vimvarht || ht == get_funccal_args_ht()) {\n      emsgf(_(e_illvar), name);\n      return;\n    }\n\n    // Make sure the variable name is valid.\n    if (!valid_varname(varname)) {\n      return;\n    }\n\n    // Make sure dict is valid\n    assert(dict != NULL);\n\n    v = xmalloc(sizeof(dictitem_T) + strlen(varname));\n    STRCPY(v->di_key, varname);\n    if (tv_dict_add(dict, v) == FAIL) {\n      xfree(v);\n      return;\n    }\n    v->di_flags = DI_FLAGS_ALLOC;\n    if (is_const) {\n      v->di_flags |= DI_FLAGS_LOCK;\n    }\n  }\n\n  if (copy || tv->v_type == VAR_NUMBER || tv->v_type == VAR_FLOAT) {\n    tv_copy(tv, &v->di_tv);\n  } else {\n    v->di_tv = *tv;\n    v->di_tv.v_lock = VAR_UNLOCKED;\n    tv_init(tv);\n  }\n\n  if (watched) {\n    if (oldtv.v_type == VAR_UNKNOWN) {\n      tv_dict_watcher_notify(dict, (char *)v->di_key, &v->di_tv, NULL);\n    } else {\n      tv_dict_watcher_notify(dict, (char *)v->di_key, &v->di_tv, &oldtv);\n      tv_clear(&oldtv);\n    }\n  }\n\n  if (is_const) {\n    // Like :lockvar! name: lock the value and what it contains, but only\n    // if the reference count is up to one.  That locks only literal\n    // values.\n    tv_item_lock(&v->di_tv, DICT_MAXNEST, true, true);\n  }\n}\n\n/// Check whether variable is read-only (DI_FLAGS_RO, DI_FLAGS_RO_SBX)\n///\n/// Also gives an error message.\n///\n/// @param[in]  flags  di_flags attribute value.\n/// @param[in]  name  Variable name, for use in error message.\n/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate\n///                       variable name and compute the length. Use #TV_CSTRING\n///                       to compute the length with strlen() without\n///                       translating.\n///\n///                       Both #TV_\u2026 values are used for optimization purposes:\n///                       variable name with its length is needed only in case\n///                       of error, when no error occurs computing them is\n///                       a waste of CPU resources. This especially applies to\n///                       gettext.\n///\n/// @return True if variable is read-only: either always or in sandbox when\n///         sandbox is enabled, false otherwise.\nbool var_check_ro(const int flags, const char *name, size_t name_len)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  const char *error_message = NULL;\n  if (flags & DI_FLAGS_RO) {\n    error_message = _(e_readonlyvar);\n  } else if ((flags & DI_FLAGS_RO_SBX) && sandbox) {\n    error_message = N_(\"E794: Cannot set variable in the sandbox: \\\"%.*s\\\"\");\n  }\n\n  if (error_message == NULL) {\n    return false;\n  }\n  if (name_len == TV_TRANSLATE) {\n    name = _(name);\n    name_len = strlen(name);\n  } else if (name_len == TV_CSTRING) {\n    name_len = strlen(name);\n  }\n\n  emsgf(_(error_message), (int)name_len, name);\n\n  return true;\n}\n\n/// Check whether variable is fixed (DI_FLAGS_FIX)\n///\n/// Also gives an error message.\n///\n/// @param[in]  flags  di_flags attribute value.\n/// @param[in]  name  Variable name, for use in error message.\n/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate\n///                       variable name and compute the length. Use #TV_CSTRING\n///                       to compute the length with strlen() without\n///                       translating.\n///\n///                       Both #TV_\u2026 values are used for optimization purposes:\n///                       variable name with its length is needed only in case\n///                       of error, when no error occurs computing them is\n///                       a waste of CPU resources. This especially applies to\n///                       gettext.\n///\n/// @return True if variable is fixed, false otherwise.\nbool var_check_fixed(const int flags, const char *name, size_t name_len)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n{\n  if (flags & DI_FLAGS_FIX) {\n    if (name_len == TV_TRANSLATE) {\n      name = _(name);\n      name_len = strlen(name);\n    } else if (name_len == TV_CSTRING) {\n      name_len = strlen(name);\n    }\n    EMSG3(_(\"E795: Cannot delete variable %.*s\"), (int)name_len, name);\n    return true;\n  }\n  return false;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Check if name is a valid name to assign funcref to\n///\n/// @param[in]  name  Possible function/funcref name.\n/// @param[in]  new_var  True if it is a name for a variable.\n///\n/// @return false in case of error, true in case of success. Also gives an\n///         error message if appropriate.\nbool var_check_func_name(const char *const name, const bool new_var)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Allow for w: b: s: and t:.\n  if (!(vim_strchr((char_u *)\"wbst\", name[0]) != NULL && name[1] == ':')\n      && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':') ? name[2]\n                                                           : name[0])) {\n    EMSG2(_(\"E704: Funcref variable name must start with a capital: %s\"), name);\n    return false;\n  }\n  // Don't allow hiding a function.  When \"v\" is not NULL we might be\n  // assigning another function to the same var, the type is checked\n  // below.\n  if (new_var && function_exists((const char *)name, false)) {\n    EMSG2(_(\"E705: Variable name conflicts with existing function: %s\"),\n          name);\n    return false;\n  }\n  return true;\n}\n\n// TODO(ZyX-I): move to eval/expressions\n\n/// Check if a variable name is valid\n///\n/// @param[in]  varname  Variable name to check.\n///\n/// @return false when variable name is not valid, true when it is. Also gives\n///         an error message if appropriate.\nbool valid_varname(const char *varname)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  for (const char *p = varname; *p != NUL; p++) {\n    if (!eval_isnamec1((int)(uint8_t)(*p))\n        && (p == varname || !ascii_isdigit(*p))\n        && *p != AUTOLOAD_CHAR) {\n      emsgf(_(e_illvar), varname);\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Make a copy of an item\n///\n/// Lists and Dictionaries are also copied.\n///\n/// @param[in]  conv  If not NULL, convert all copied strings.\n/// @param[in]  from  Value to copy.\n/// @param[out]  to  Location where to copy to.\n/// @param[in]  deep  If true, use copy the container and all of the contained\n///                   containers (nested).\n/// @param[in]  copyID  If non-zero then when container is referenced more then\n///                     once then copy of it that was already done is used. E.g.\n///                     when copying list `list = [list2, list2]` (`list[0] is\n///                     list[1]`) var_item_copy with zero copyID will emit\n///                     a copy with (`copy[0] isnot copy[1]`), with non-zero it\n///                     will emit a copy with (`copy[0] is copy[1]`) like in the\n///                     original list. Not used when deep is false.\nint var_item_copy(const vimconv_T *const conv, typval_T *const from, typval_T *const to,\n                  const bool deep, const int copyID)\n  FUNC_ATTR_NONNULL_ARG(2, 3)\n{\n  static int recurse = 0;\n  int ret = OK;\n\n  if (recurse >= DICT_MAXNEST) {\n    EMSG(_(\"E698: variable nested too deep for making a copy\"));\n    return FAIL;\n  }\n  ++recurse;\n\n  switch (from->v_type) {\n  case VAR_NUMBER:\n  case VAR_FLOAT:\n  case VAR_FUNC:\n  case VAR_PARTIAL:\n  case VAR_BOOL:\n  case VAR_SPECIAL:\n    tv_copy(from, to);\n    break;\n  case VAR_STRING:\n    if (conv == NULL || conv->vc_type == CONV_NONE\n        || from->vval.v_string == NULL) {\n      tv_copy(from, to);\n    } else {\n      to->v_type = VAR_STRING;\n      to->v_lock = VAR_UNLOCKED;\n      if ((to->vval.v_string = string_convert((vimconv_T *)conv,\n                                              from->vval.v_string,\n                                              NULL))\n          == NULL) {\n        to->vval.v_string = (char_u *)xstrdup((char *)from->vval.v_string);\n      }\n    }\n    break;\n  case VAR_LIST:\n    to->v_type = VAR_LIST;\n    to->v_lock = VAR_UNLOCKED;\n    if (from->vval.v_list == NULL) {\n      to->vval.v_list = NULL;\n    } else if (copyID != 0 && tv_list_copyid(from->vval.v_list) == copyID) {\n      // Use the copy made earlier.\n      to->vval.v_list = tv_list_latest_copy(from->vval.v_list);\n      tv_list_ref(to->vval.v_list);\n    } else {\n      to->vval.v_list = tv_list_copy(conv, from->vval.v_list, deep, copyID);\n    }\n    if (to->vval.v_list == NULL && from->vval.v_list != NULL) {\n      ret = FAIL;\n    }\n    break;\n  case VAR_BLOB:\n    tv_blob_copy(from, to);\n    break;\n  case VAR_DICT:\n    to->v_type = VAR_DICT;\n    to->v_lock = VAR_UNLOCKED;\n    if (from->vval.v_dict == NULL) {\n      to->vval.v_dict = NULL;\n    } else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID) {\n      // use the copy made earlier\n      to->vval.v_dict = from->vval.v_dict->dv_copydict;\n      ++to->vval.v_dict->dv_refcount;\n    } else {\n      to->vval.v_dict = tv_dict_copy(conv, from->vval.v_dict, deep, copyID);\n    }\n    if (to->vval.v_dict == NULL && from->vval.v_dict != NULL) {\n      ret = FAIL;\n    }\n    break;\n  case VAR_UNKNOWN:\n    internal_error(\"var_item_copy(UNKNOWN)\");\n    ret = FAIL;\n  }\n  --recurse;\n  return ret;\n}\n\n/*\n * \":echo expr1 ...\"    print each argument separated with a space, add a\n *                      newline at the end.\n * \":echon expr1 ...\"   print each argument plain.\n */\nvoid ex_echo(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  typval_T rettv;\n  bool atstart = true;\n  bool need_clear = true;\n  const int did_emsg_before = did_emsg;\n  const int called_emsg_before = called_emsg;\n\n  if (eap->skip) {\n    ++emsg_skip;\n  }\n  while (*arg != NUL && *arg != '|' && *arg != '\\n' && !got_int) {\n    // If eval1() causes an error message the text from the command may\n    // still need to be cleared. E.g., \"echo 22,44\".\n    need_clr_eos = true;\n\n    {\n      char_u *p = arg;\n      if (eval1(&arg, &rettv, !eap->skip) == FAIL) {\n        // Report the invalid expression unless the expression evaluation\n        // has been cancelled due to an aborting error, an interrupt, or an\n        // exception.\n        if (!aborting() && did_emsg == did_emsg_before\n            && called_emsg == called_emsg_before) {\n          EMSG2(_(e_invexpr2), p);\n        }\n        need_clr_eos = false;\n        break;\n      }\n      need_clr_eos = false;\n    }\n\n    if (!eap->skip) {\n      if (atstart) {\n        atstart = false;\n        /* Call msg_start() after eval1(), evaluating the expression\n         * may cause a message to appear. */\n        if (eap->cmdidx == CMD_echo) {\n          /* Mark the saved text as finishing the line, so that what\n           * follows is displayed on a new line when scrolling back\n           * at the more prompt. */\n          msg_sb_eol();\n          msg_start();\n        }\n      } else if (eap->cmdidx == CMD_echo) {\n        msg_puts_attr(\" \", echo_attr);\n      }\n      char *tofree = encode_tv2echo(&rettv, NULL);\n      if (*tofree != NUL) {\n        msg_ext_set_kind(\"echo\");\n        msg_multiline_attr(tofree, echo_attr, true, &need_clear);\n      }\n      xfree(tofree);\n    }\n    tv_clear(&rettv);\n    arg = skipwhite(arg);\n  }\n  eap->nextcmd = check_nextcmd(arg);\n\n  if (eap->skip) {\n    emsg_skip--;\n  } else {\n    // remove text that may still be there from the command\n    if (need_clear) {\n      msg_clr_eos();\n    }\n    if (eap->cmdidx == CMD_echo) {\n      msg_end();\n    }\n  }\n}\n\n/*\n * \":echohl {name}\".\n */\nvoid ex_echohl(exarg_T *eap)\n{\n  echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * \":execute expr1 ...\" execute the result of an expression.\n * \":echomsg expr1 ...\" Print a message\n * \":echoerr expr1 ...\" Print an error\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\nvoid ex_execute(exarg_T *eap)\n{\n  char_u *arg = eap->arg;\n  typval_T rettv;\n  int ret = OK;\n  garray_T ga;\n  int save_did_emsg;\n\n  ga_init(&ga, 1, 80);\n\n  if (eap->skip) {\n    ++emsg_skip;\n  }\n  while (*arg != NUL && *arg != '|' && *arg != '\\n') {\n    ret = eval1_emsg(&arg, &rettv, !eap->skip);\n    if (ret == FAIL) {\n      break;\n    }\n\n    if (!eap->skip) {\n      const char *const argstr = eap->cmdidx == CMD_execute\n        ? tv_get_string(&rettv)\n        : rettv.v_type == VAR_STRING\n        ? encode_tv2echo(&rettv, NULL)\n        : encode_tv2string(&rettv, NULL);\n      const size_t len = strlen(argstr);\n      ga_grow(&ga, len + 2);\n      if (!GA_EMPTY(&ga)) {\n        ((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n      }\n      memcpy((char_u *)(ga.ga_data) + ga.ga_len, argstr, len + 1);\n      if (eap->cmdidx != CMD_execute) {\n        xfree((void *)argstr);\n      }\n      ga.ga_len += len;\n    }\n\n    tv_clear(&rettv);\n    arg = skipwhite(arg);\n  }\n\n  if (ret != FAIL && ga.ga_data != NULL) {\n    if (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr) {\n      // Mark the already saved text as finishing the line, so that what\n      // follows is displayed on a new line when scrolling back at the\n      // more prompt.\n      msg_sb_eol();\n    }\n\n    if (eap->cmdidx == CMD_echomsg) {\n      msg_ext_set_kind(\"echomsg\");\n      MSG_ATTR(ga.ga_data, echo_attr);\n      ui_flush();\n    } else if (eap->cmdidx == CMD_echoerr) {\n      // We don't want to abort following commands, restore did_emsg.\n      save_did_emsg = did_emsg;\n      msg_ext_set_kind(\"echoerr\");\n      EMSG((char_u *)ga.ga_data);\n      if (!force_abort) {\n        did_emsg = save_did_emsg;\n      }\n    } else if (eap->cmdidx == CMD_execute) {\n      do_cmdline((char_u *)ga.ga_data,\n                 eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n    }\n  }\n\n  ga_clear(&ga);\n\n  if (eap->skip) {\n    --emsg_skip;\n  }\n\n  eap->nextcmd = check_nextcmd(arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\nstatic const char *find_option_end(const char **const arg, int *const opt_flags)\n{\n  const char *p = *arg;\n\n  ++p;\n  if (*p == 'g' && p[1] == ':') {\n    *opt_flags = OPT_GLOBAL;\n    p += 2;\n  } else if (*p == 'l' && p[1] == ':') {\n    *opt_flags = OPT_LOCAL;\n    p += 2;\n  } else {\n    *opt_flags = 0;\n  }\n\n  if (!ASCII_ISALPHA(*p)) {\n    return NULL;\n  }\n  *arg = p;\n\n  if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL) {\n    p += 4;  // t_xx/termcap option\n  } else {\n    while (ASCII_ISALPHA(*p)) {\n      p++;\n    }\n  }\n  return p;\n}\n\n/// Start profiling function \"fp\".\nvoid func_do_profile(ufunc_T *fp)\n{\n  int len = fp->uf_lines.ga_len;\n\n  if (!fp->uf_prof_initialized) {\n    if (len == 0) {\n      len = 1;  // avoid getting error for allocating zero bytes\n    }\n    fp->uf_tm_count = 0;\n    fp->uf_tm_self = profile_zero();\n    fp->uf_tm_total = profile_zero();\n\n    if (fp->uf_tml_count == NULL) {\n      fp->uf_tml_count = xcalloc(len, sizeof(int));\n    }\n\n    if (fp->uf_tml_total == NULL) {\n      fp->uf_tml_total = xcalloc(len, sizeof(proftime_T));\n    }\n\n    if (fp->uf_tml_self == NULL) {\n      fp->uf_tml_self = xcalloc(len, sizeof(proftime_T));\n    }\n\n    fp->uf_tml_idx = -1;\n    fp->uf_prof_initialized = true;\n  }\n\n  fp->uf_profiling = TRUE;\n}\n\n/*\n * Dump the profiling results for all functions in file \"fd\".\n */\nvoid func_dump_profile(FILE *fd)\n{\n  hashitem_T *hi;\n  int todo;\n  ufunc_T *fp;\n  ufunc_T **sorttab;\n  int st_len = 0;\n\n  todo = (int)func_hashtab.ht_used;\n  if (todo == 0) {\n    return;         // nothing to dump\n  }\n\n  sorttab = xmalloc(sizeof(ufunc_T *) * todo);\n\n  for (hi = func_hashtab.ht_array; todo > 0; ++hi) {\n    if (!HASHITEM_EMPTY(hi)) {\n      --todo;\n      fp = HI2UF(hi);\n      if (fp->uf_prof_initialized) {\n        sorttab[st_len++] = fp;\n\n        if (fp->uf_name[0] == K_SPECIAL) {\n          fprintf(fd, \"FUNCTION  <SNR>%s()\\n\", fp->uf_name + 3);\n        } else {\n          fprintf(fd, \"FUNCTION  %s()\\n\", fp->uf_name);\n        }\n        if (fp->uf_script_ctx.sc_sid != 0) {\n          bool should_free;\n          const LastSet last_set = (LastSet){\n            .script_ctx = fp->uf_script_ctx,\n            .channel_id = 0,\n          };\n          char_u *p = get_scriptname(last_set, &should_free);\n          fprintf(fd, \"    Defined: %s:%\" PRIdLINENR \"\\n\",\n                  p, fp->uf_script_ctx.sc_lnum);\n          if (should_free) {\n            xfree(p);\n          }\n        }\n        if (fp->uf_tm_count == 1) {\n          fprintf(fd, \"Called 1 time\\n\");\n        } else {\n          fprintf(fd, \"Called %d times\\n\", fp->uf_tm_count);\n        }\n        fprintf(fd, \"Total time: %s\\n\", profile_msg(fp->uf_tm_total));\n        fprintf(fd, \" Self time: %s\\n\", profile_msg(fp->uf_tm_self));\n        fprintf(fd, \"\\n\");\n        fprintf(fd, \"count  total (s)   self (s)\\n\");\n\n        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {\n          if (FUNCLINE(fp, i) == NULL) {\n            continue;\n          }\n          prof_func_line(fd, fp->uf_tml_count[i],\n                         &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);\n          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));\n        }\n        fprintf(fd, \"\\n\");\n      }\n    }\n  }\n\n  if (st_len > 0) {\n    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),\n          prof_total_cmp);\n    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);\n    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),\n          prof_self_cmp);\n    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);\n  }\n\n  xfree(sorttab);\n}\n\n/// @param prefer_self  when equal print only self time\nstatic void prof_sort_list(FILE *fd, ufunc_T **sorttab, int st_len, char *title, int prefer_self)\n{\n  int i;\n  ufunc_T *fp;\n\n  fprintf(fd, \"FUNCTIONS SORTED ON %s TIME\\n\", title);\n  fprintf(fd, \"count  total (s)   self (s)  function\\n\");\n  for (i = 0; i < 20 && i < st_len; ++i) {\n    fp = sorttab[i];\n    prof_func_line(fd, fp->uf_tm_count, &fp->uf_tm_total, &fp->uf_tm_self,\n                   prefer_self);\n    if (fp->uf_name[0] == K_SPECIAL) {\n      fprintf(fd, \" <SNR>%s()\\n\", fp->uf_name + 3);\n    } else {\n      fprintf(fd, \" %s()\\n\", fp->uf_name);\n    }\n  }\n  fprintf(fd, \"\\n\");\n}\n\n/// Print the count and times for one function or function line.\n///\n/// @param prefer_self  when equal print only self time\nstatic void prof_func_line(FILE *fd, int count, proftime_T *total, proftime_T *self,\n                           int prefer_self)\n{\n  if (count > 0) {\n    fprintf(fd, \"%5d \", count);\n    if (prefer_self && profile_equal(*total, *self)) {\n      fprintf(fd, \"           \");\n    } else {\n      fprintf(fd, \"%s \", profile_msg(*total));\n    }\n    if (!prefer_self && profile_equal(*total, *self)) {\n      fprintf(fd, \"           \");\n    } else {\n      fprintf(fd, \"%s \", profile_msg(*self));\n    }\n  } else {\n    fprintf(fd, \"                            \");\n  }\n}\n\n/*\n * Compare function for total time sorting.\n */\nstatic int prof_total_cmp(const void *s1, const void *s2)\n{\n  ufunc_T *p1 = *(ufunc_T **)s1;\n  ufunc_T *p2 = *(ufunc_T **)s2;\n  return profile_cmp(p1->uf_tm_total, p2->uf_tm_total);\n}\n\n/*\n * Compare function for self time sorting.\n */\nstatic int prof_self_cmp(const void *s1, const void *s2)\n{\n  ufunc_T *p1 = *(ufunc_T **)s1;\n  ufunc_T *p2 = *(ufunc_T **)s2;\n  return profile_cmp(p1->uf_tm_self, p2->uf_tm_self);\n}\n\n/// Return the autoload script name for a function or variable name\n/// Caller must make sure that \"name\" contains AUTOLOAD_CHAR.\n///\n/// @param[in]  name  Variable/function name.\n/// @param[in]  name_len  Name length.\n///\n/// @return [allocated] autoload script name.\nchar *autoload_name(const char *const name, const size_t name_len)\n  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  // Get the script file name: replace '#' with '/', append \".vim\".\n  char *const scriptname = xmalloc(name_len + sizeof(\"autoload/.vim\"));\n  memcpy(scriptname, \"autoload/\", sizeof(\"autoload/\") - 1);\n  memcpy(scriptname + sizeof(\"autoload/\") - 1, name, name_len);\n  size_t auchar_idx = 0;\n  for (size_t i = sizeof(\"autoload/\") - 1;\n       i - sizeof(\"autoload/\") + 1 < name_len;\n       i++) {\n    if (scriptname[i] == AUTOLOAD_CHAR) {\n      scriptname[i] = '/';\n      auchar_idx = i;\n    }\n  }\n  memcpy(scriptname + auchar_idx, \".vim\", sizeof(\".vim\"));\n\n  return scriptname;\n}\n\n/// If name has a package name try autoloading the script for it\n///\n/// @param[in]  name  Variable/function name.\n/// @param[in]  name_len  Name length.\n/// @param[in]  reload  If true, load script again when already loaded.\n///\n/// @return true if a package was loaded.\nbool script_autoload(const char *const name, const size_t name_len, const bool reload)\n{\n  // If there is no '#' after name[0] there is no package name.\n  const char *p = memchr(name, AUTOLOAD_CHAR, name_len);\n  if (p == NULL || p == name) {\n    return false;\n  }\n\n  bool ret = false;\n  char *tofree = autoload_name(name, name_len);\n  char *scriptname = tofree;\n\n  // Find the name in the list of previously loaded package names.  Skip\n  // \"autoload/\", it's always the same.\n  int i = 0;\n  for (; i < ga_loaded.ga_len; i++) {\n    if (STRCMP(((char **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0) {\n      break;\n    }\n  }\n  if (!reload && i < ga_loaded.ga_len) {\n    ret = false;  // Was loaded already.\n  } else {\n    // Remember the name if it wasn't loaded already.\n    if (i == ga_loaded.ga_len) {\n      GA_APPEND(char *, &ga_loaded, scriptname);\n      tofree = NULL;\n    }\n\n    // Try loading the package from $VIMRUNTIME/autoload/<name>.vim\n    if (source_runtime((char_u *)scriptname, 0) == OK) {\n      ret = true;\n    }\n  }\n\n  xfree(tofree);\n  return ret;\n}\n\n/*\n * Called when starting to read a function line.\n * \"sourcing_lnum\" must be correct!\n * When skipping lines it may not actually be executed, but we won't find out\n * until later and we need to store the time now.\n */\nvoid func_line_start(void *cookie)\n{\n  funccall_T *fcp = (funccall_T *)cookie;\n  ufunc_T *fp = fcp->func;\n\n  if (fp->uf_profiling && sourcing_lnum >= 1\n      && sourcing_lnum <= fp->uf_lines.ga_len) {\n    fp->uf_tml_idx = sourcing_lnum - 1;\n    // Skip continuation lines.\n    while (fp->uf_tml_idx > 0 && FUNCLINE(fp, fp->uf_tml_idx) == NULL) {\n      fp->uf_tml_idx--;\n    }\n    fp->uf_tml_execed = false;\n    fp->uf_tml_start = profile_start();\n    fp->uf_tml_children = profile_zero();\n    fp->uf_tml_wait = profile_get_wait();\n  }\n}\n\n/*\n * Called when actually executing a function line.\n */\nvoid func_line_exec(void *cookie)\n{\n  funccall_T *fcp = (funccall_T *)cookie;\n  ufunc_T *fp = fcp->func;\n\n  if (fp->uf_profiling && fp->uf_tml_idx >= 0) {\n    fp->uf_tml_execed = TRUE;\n  }\n}\n\n/*\n * Called when done with a function line.\n */\nvoid func_line_end(void *cookie)\n{\n  funccall_T *fcp = (funccall_T *)cookie;\n  ufunc_T *fp = fcp->func;\n\n  if (fp->uf_profiling && fp->uf_tml_idx >= 0) {\n    if (fp->uf_tml_execed) {\n      ++fp->uf_tml_count[fp->uf_tml_idx];\n      fp->uf_tml_start = profile_end(fp->uf_tml_start);\n      fp->uf_tml_start = profile_sub_wait(fp->uf_tml_wait, fp->uf_tml_start);\n      fp->uf_tml_total[fp->uf_tml_idx] =\n        profile_add(fp->uf_tml_total[fp->uf_tml_idx], fp->uf_tml_start);\n      fp->uf_tml_self[fp->uf_tml_idx] =\n        profile_self(fp->uf_tml_self[fp->uf_tml_idx], fp->uf_tml_start,\n                     fp->uf_tml_children);\n    }\n    fp->uf_tml_idx = -1;\n  }\n}\n\nstatic var_flavour_T var_flavour(char_u *varname)\n{\n  char_u *p = varname;\n\n  if (ASCII_ISUPPER(*p)) {\n    while (*(++p)) {\n      if (ASCII_ISLOWER(*p)) {\n        return VAR_FLAVOUR_SESSION;\n      }\n    }\n    return VAR_FLAVOUR_SHADA;\n  } else {\n    return VAR_FLAVOUR_DEFAULT;\n  }\n}\n\n/// Iterate over global variables\n///\n/// @warning No modifications to global variable dictionary must be performed\n///          while iteration is in progress.\n///\n/// @param[in]   iter   Iterator. Pass NULL to start iteration.\n/// @param[out]  name   Variable name.\n/// @param[out]  rettv  Variable value.\n///\n/// @return Pointer that needs to be passed to next `var_shada_iter` invocation\n///         or NULL to indicate that iteration is over.\nconst void *var_shada_iter(const void *const iter, const char **const name, typval_T *rettv,\n                           var_flavour_T flavour)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(2, 3)\n{\n  const hashitem_T *hi;\n  const hashitem_T *hifirst = globvarht.ht_array;\n  const size_t hinum = (size_t)globvarht.ht_mask + 1;\n  *name = NULL;\n  if (iter == NULL) {\n    hi = globvarht.ht_array;\n    while ((size_t)(hi - hifirst) < hinum\n           && (HASHITEM_EMPTY(hi)\n               || !(var_flavour(hi->hi_key) & flavour))) {\n      hi++;\n    }\n    if ((size_t)(hi - hifirst) == hinum) {\n      return NULL;\n    }\n  } else {\n    hi = (const hashitem_T *)iter;\n  }\n  *name = (char *)TV_DICT_HI2DI(hi)->di_key;\n  tv_copy(&TV_DICT_HI2DI(hi)->di_tv, rettv);\n  while ((size_t)(++hi - hifirst) < hinum) {\n    if (!HASHITEM_EMPTY(hi) && (var_flavour(hi->hi_key) & flavour)) {\n      return hi;\n    }\n  }\n  return NULL;\n}\n\nvoid var_set_global(const char *const name, typval_T vartv)\n{\n  funccal_entry_T funccall_entry;\n\n  save_funccal(&funccall_entry);\n  set_var(name, strlen(name), &vartv, false);\n  restore_funccal();\n}\n\nint store_session_globals(FILE *fd)\n{\n  TV_DICT_ITER(&globvardict, this_var, {\n    if ((this_var->di_tv.v_type == VAR_NUMBER\n         || this_var->di_tv.v_type == VAR_STRING)\n        && var_flavour(this_var->di_key) == VAR_FLAVOUR_SESSION) {\n      // Escape special characters with a backslash.  Turn a LF and\n      // CR into \\n and \\r.\n      char_u *const p = vim_strsave_escaped((const char_u *)tv_get_string(&this_var->di_tv),\n                                            (const char_u *)\"\\\\\\\"\\n\\r\");\n      for (char_u *t = p; *t != NUL; t++) {\n        if (*t == '\\n') {\n          *t = 'n';\n        } else if (*t == '\\r') {\n          *t = 'r';\n        }\n      }\n      if ((fprintf(fd, \"let %s = %c%s%c\",\n                   this_var->di_key,\n                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'\n                                                           : ' '),\n                   p,\n                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'\n                                                           : ' ')) < 0)\n          || put_eol(fd) == FAIL) {\n        xfree(p);\n        return FAIL;\n      }\n      xfree(p);\n    } else if (this_var->di_tv.v_type == VAR_FLOAT\n               && var_flavour(this_var->di_key) == VAR_FLAVOUR_SESSION) {\n      float_T f = this_var->di_tv.vval.v_float;\n      int sign = ' ';\n\n      if (f < 0) {\n        f = -f;\n        sign = '-';\n      }\n      if ((fprintf(fd, \"let %s = %c%f\", this_var->di_key, sign, f) < 0)\n          || put_eol(fd) == FAIL) {\n        return FAIL;\n      }\n    }\n  });\n  return OK;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\nvoid last_set_msg(sctx_T script_ctx)\n{\n  const LastSet last_set = (LastSet){\n    .script_ctx = script_ctx,\n    .channel_id = 0,\n  };\n  option_last_set_msg(last_set);\n}\n\n/// Displays where an option was last set.\n///\n/// Should only be invoked when 'verbose' is non-zero.\nvoid option_last_set_msg(LastSet last_set)\n{\n  if (last_set.script_ctx.sc_sid != 0) {\n    bool should_free;\n    char_u *p = get_scriptname(last_set, &should_free);\n    verbose_enter();\n    MSG_PUTS(_(\"\\n\\tLast set from \"));\n    MSG_PUTS(p);\n    if (last_set.script_ctx.sc_lnum > 0) {\n      MSG_PUTS(_(line_msg));\n      msg_outnum((long)last_set.script_ctx.sc_lnum);\n    }\n    if (should_free) {\n      xfree(p);\n    }\n    verbose_leave();\n  }\n}\n\n// reset v:option_new, v:option_old and v:option_type\nvoid reset_v_option_vars(void)\n{\n  set_vim_var_string(VV_OPTION_NEW,  NULL, -1);\n  set_vim_var_string(VV_OPTION_OLD,  NULL, -1);\n  set_vim_var_string(VV_OPTION_TYPE, NULL, -1);\n}\n\n/// Adjust a filename, according to a string of modifiers.\n/// *fnamep must be NUL terminated when called.  When returning, the length is\n/// determined by *fnamelen.\n/// Returns VALID_ flags or -1 for failure.\n/// When there is an error, *fnamep is set to NULL.\n///\n/// @param src  string with modifiers\n/// @param tilde_file  \"~\" is a file name, not $HOME\n/// @param usedlen  characters after src that are used\n/// @param fnamep  file name so far\n/// @param bufp  buffer for allocated file name or NULL\n/// @param fnamelen  length of fnamep\nint modify_fname(char_u *src, bool tilde_file, size_t *usedlen, char_u **fnamep, char_u **bufp,\n                 size_t *fnamelen)\n{\n  int valid = 0;\n  char_u *tail;\n  char_u *s, *p, *pbuf;\n  char_u dirname[MAXPATHL];\n  int c;\n  int has_fullname = 0;\n\nrepeat:\n  // \":p\" - full path/file_name\n  if (src[*usedlen] == ':' && src[*usedlen + 1] == 'p') {\n    has_fullname = 1;\n\n    valid |= VALID_PATH;\n    *usedlen += 2;\n\n    // Expand \"~/path\" for all systems and \"~user/path\" for Unix\n    if ((*fnamep)[0] == '~'\n#if !defined(UNIX)\n        && ((*fnamep)[1] == '/'\n# ifdef BACKSLASH_IN_FILENAME\n            || (*fnamep)[1] == '\\\\'\n# endif\n            || (*fnamep)[1] == NUL)\n#endif\n        && !(tilde_file && (*fnamep)[1] == NUL)) {\n      *fnamep = expand_env_save(*fnamep);\n      xfree(*bufp);          // free any allocated file name\n      *bufp = *fnamep;\n      if (*fnamep == NULL) {\n        return -1;\n      }\n    }\n\n    // When \"/.\" or \"/..\" is used: force expansion to get rid of it.\n    for (p = *fnamep; *p != NUL; MB_PTR_ADV(p)) {\n      if (vim_ispathsep(*p)\n          && p[1] == '.'\n          && (p[2] == NUL\n              || vim_ispathsep(p[2])\n              || (p[2] == '.'\n                  && (p[3] == NUL || vim_ispathsep(p[3]))))) {\n        break;\n      }\n    }\n\n    // FullName_save() is slow, don't use it when not needed.\n    if (*p != NUL || !vim_isAbsName(*fnamep)) {\n      *fnamep = (char_u *)FullName_save((char *)(*fnamep), *p != NUL);\n      xfree(*bufp);          // free any allocated file name\n      *bufp = *fnamep;\n      if (*fnamep == NULL) {\n        return -1;\n      }\n    }\n\n    // Append a path separator to a directory.\n    if (os_isdir(*fnamep)) {\n      // Make room for one or two extra characters.\n      *fnamep = vim_strnsave(*fnamep, STRLEN(*fnamep) + 2);\n      xfree(*bufp);          // free any allocated file name\n      *bufp = *fnamep;\n      if (*fnamep == NULL) {\n        return -1;\n      }\n      add_pathsep((char *)*fnamep);\n    }\n  }\n\n  // \":.\" - path relative to the current directory\n  // \":~\" - path relative to the home directory\n  // \":8\" - shortname path - postponed till after\n  while (src[*usedlen] == ':'\n         && ((c = src[*usedlen + 1]) == '.' || c == '~' || c == '8')) {\n    *usedlen += 2;\n    if (c == '8') {\n      continue;\n    }\n    pbuf = NULL;\n    // Need full path first (use expand_env() to remove a \"~/\")\n    if (!has_fullname) {\n      if (c == '.' && **fnamep == '~') {\n        p = pbuf = expand_env_save(*fnamep);\n      } else {\n        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);\n      }\n    } else {\n      p = *fnamep;\n    }\n\n    has_fullname = 0;\n\n    if (p != NULL) {\n      if (c == '.') {\n        os_dirname(dirname, MAXPATHL);\n        s = path_shorten_fname(p, dirname);\n        if (s != NULL) {\n          *fnamep = s;\n          if (pbuf != NULL) {\n            xfree(*bufp);               // free any allocated file name\n            *bufp = pbuf;\n            pbuf = NULL;\n          }\n        }\n      } else {\n        home_replace(NULL, p, dirname, MAXPATHL, true);\n        // Only replace it when it starts with '~'\n        if (*dirname == '~') {\n          s = vim_strsave(dirname);\n          *fnamep = s;\n          xfree(*bufp);\n          *bufp = s;\n        }\n      }\n      xfree(pbuf);\n    }\n  }\n\n  tail = path_tail(*fnamep);\n  *fnamelen = STRLEN(*fnamep);\n\n  // \":h\" - head, remove \"/file_name\", can be repeated\n  // Don't remove the first \"/\" or \"c:\\\"\n  while (src[*usedlen] == ':' && src[*usedlen + 1] == 'h') {\n    valid |= VALID_HEAD;\n    *usedlen += 2;\n    s = get_past_head(*fnamep);\n    while (tail > s && after_pathsep((char *)s, (char *)tail)) {\n      MB_PTR_BACK(*fnamep, tail);\n    }\n    *fnamelen = (size_t)(tail - *fnamep);\n    if (*fnamelen == 0) {\n      // Result is empty.  Turn it into \".\" to make \":cd %:h\" work.\n      xfree(*bufp);\n      *bufp = *fnamep = tail = vim_strsave((char_u *)\".\");\n      *fnamelen = 1;\n    } else {\n      while (tail > s && !after_pathsep((char *)s, (char *)tail)) {\n        MB_PTR_BACK(*fnamep, tail);\n      }\n    }\n  }\n\n  // \":8\" - shortname\n  if (src[*usedlen] == ':' && src[*usedlen + 1] == '8') {\n    *usedlen += 2;\n  }\n\n\n  // \":t\" - tail, just the basename\n  if (src[*usedlen] == ':' && src[*usedlen + 1] == 't') {\n    *usedlen += 2;\n    *fnamelen -= (size_t)(tail - *fnamep);\n    *fnamep = tail;\n  }\n\n  // \":e\" - extension, can be repeated\n  // \":r\" - root, without extension, can be repeated\n  while (src[*usedlen] == ':'\n         && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {\n    /* find a '.' in the tail:\n     * - for second :e: before the current fname\n     * - otherwise: The last '.'\n     */\n    const bool is_second_e = *fnamep > tail;\n    if (src[*usedlen + 1] == 'e' && is_second_e) {\n      s = *fnamep - 2;\n    } else {\n      s = *fnamep + *fnamelen - 1;\n    }\n\n    for (; s > tail; s--) {\n      if (s[0] == '.') {\n        break;\n      }\n    }\n    if (src[*usedlen + 1] == 'e') {\n      if (s > tail || (0 && is_second_e && s == tail)) {\n        // we stopped at a '.' (so anchor to &'.' + 1)\n        char_u *newstart = s + 1;\n        size_t distance_stepped_back = *fnamep - newstart;\n        *fnamelen += distance_stepped_back;\n        *fnamep = newstart;\n      } else if (*fnamep <= tail) {\n        *fnamelen = 0;\n      }\n    } else {\n      // :r - Remove one extension\n      //\n      // Ensure that `s` doesn't go before `*fnamep`,\n      // since then we're taking too many roots:\n      //\n      // \"path/to/this.file.ext\" :e:e:r:r\n      //          ^    ^-------- *fnamep\n      //          +------------- tail\n      //\n      // Also ensure `s` doesn't go before `tail`,\n      // since then we're taking too many roots again:\n      //\n      // \"path/to/this.file.ext\" :r:r:r\n      //  ^       ^------------- tail\n      //  +--------------------- *fnamep\n      if (s > MAX(tail, *fnamep)) {\n        *fnamelen = (size_t)(s - *fnamep);\n      }\n    }\n    *usedlen += 2;\n  }\n\n  // \":s?pat?foo?\" - substitute\n  // \":gs?pat?foo?\" - global substitute\n  if (src[*usedlen] == ':'\n      && (src[*usedlen + 1] == 's'\n          || (src[*usedlen + 1] == 'g' && src[*usedlen + 2] == 's'))) {\n    int sep;\n    char_u *flags;\n    int didit = FALSE;\n\n    flags = (char_u *)\"\";\n    s = src + *usedlen + 2;\n    if (src[*usedlen + 1] == 'g') {\n      flags = (char_u *)\"g\";\n      ++s;\n    }\n\n    sep = *s++;\n    if (sep) {\n      // find end of pattern\n      p = vim_strchr(s, sep);\n      if (p != NULL) {\n        char_u *const pat = vim_strnsave(s, p - s);\n        s = p + 1;\n        // find end of substitution\n        p = vim_strchr(s, sep);\n        if (p != NULL) {\n          char_u *const sub = vim_strnsave(s, p - s);\n          char_u *const str = vim_strnsave(*fnamep, *fnamelen);\n          *usedlen = (size_t)(p + 1 - src);\n          s = do_string_sub(str, pat, sub, NULL, flags);\n          *fnamep = s;\n          *fnamelen = STRLEN(s);\n          xfree(*bufp);\n          *bufp = s;\n          didit = TRUE;\n          xfree(sub);\n          xfree(str);\n        }\n        xfree(pat);\n      }\n      // after using \":s\", repeat all the modifiers\n      if (didit) {\n        goto repeat;\n      }\n    }\n  }\n\n  if (src[*usedlen] == ':' && src[*usedlen + 1] == 'S') {\n    // vim_strsave_shellescape() needs a NUL terminated string.\n    c = (*fnamep)[*fnamelen];\n    if (c != NUL) {\n      (*fnamep)[*fnamelen] = NUL;\n    }\n    p = vim_strsave_shellescape(*fnamep, false, false);\n    if (c != NUL) {\n      (*fnamep)[*fnamelen] = c;\n    }\n    xfree(*bufp);\n    *bufp = *fnamep = p;\n    *fnamelen = STRLEN(p);\n    *usedlen += 2;\n  }\n\n  return valid;\n}\n\n/// Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n/// When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n/// \"flags\" can be \"g\" to do a global substitute.\n/// Returns an allocated string, NULL for error.\nchar_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, typval_T *expr, char_u *flags)\n{\n  int sublen;\n  regmatch_T regmatch;\n  int do_all;\n  char_u *tail;\n  char_u *end;\n  garray_T ga;\n  char_u *save_cpo;\n  char_u *zero_width = NULL;\n\n  // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n  save_cpo = p_cpo;\n  p_cpo = empty_option;\n\n  ga_init(&ga, 1, 200);\n\n  do_all = (flags[0] == 'g');\n\n  regmatch.rm_ic = p_ic;\n  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n  if (regmatch.regprog != NULL) {\n    tail = str;\n    end = str + STRLEN(str);\n    while (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str))) {\n      // Skip empty match except for first match.\n      if (regmatch.startp[0] == regmatch.endp[0]) {\n        if (zero_width == regmatch.startp[0]) {\n          // avoid getting stuck on a match with an empty string\n          int i = utfc_ptr2len(tail);\n          memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n          ga.ga_len += i;\n          tail += i;\n          continue;\n        }\n        zero_width = regmatch.startp[0];\n      }\n\n      // Get some space for a temporary buffer to do the substitution\n      // into.  It will contain:\n      // - The text up to where the match is.\n      // - The substituted text.\n      // - The text after the match.\n      sublen = vim_regsub(&regmatch, sub, expr, tail, false, true, false);\n      ga_grow(&ga, (int)((end - tail) + sublen -\n                         (regmatch.endp[0] - regmatch.startp[0])));\n\n      // copy the text up to where the match is\n      int i = (int)(regmatch.startp[0] - tail);\n      memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n      // add the substituted text\n      (void)vim_regsub(&regmatch, sub, expr, (char_u *)ga.ga_data\n                       + ga.ga_len + i, true, true, false);\n      ga.ga_len += i + sublen - 1;\n      tail = regmatch.endp[0];\n      if (*tail == NUL) {\n        break;\n      }\n      if (!do_all) {\n        break;\n      }\n    }\n\n    if (ga.ga_data != NULL) {\n      STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n    }\n\n    vim_regfree(regmatch.regprog);\n  }\n\n  char_u *ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n  ga_clear(&ga);\n  if (p_cpo == empty_option) {\n    p_cpo = save_cpo;\n  } else {\n    // Darn, evaluating {sub} expression or {expr} changed the value.\n    free_string_option(save_cpo);\n  }\n\n  return ret;\n}\n\n/// common code for getting job callbacks for jobstart, termopen and rpcstart\n///\n/// @return true/false on success/failure.\nbool common_job_callbacks(dict_T *vopts, CallbackReader *on_stdout, CallbackReader *on_stderr,\n                          Callback *on_exit)\n{\n  if (tv_dict_get_callback(vopts, S_LEN(\"on_stdout\"), &on_stdout->cb)\n      &&tv_dict_get_callback(vopts, S_LEN(\"on_stderr\"), &on_stderr->cb)\n      && tv_dict_get_callback(vopts, S_LEN(\"on_exit\"), on_exit)) {\n    on_stdout->buffered = tv_dict_get_number(vopts, \"stdout_buffered\");\n    on_stderr->buffered = tv_dict_get_number(vopts, \"stderr_buffered\");\n    if (on_stdout->buffered && on_stdout->cb.type == kCallbackNone) {\n      on_stdout->self = vopts;\n    }\n    if (on_stderr->buffered && on_stderr->cb.type == kCallbackNone) {\n      on_stderr->self = vopts;\n    }\n    vopts->dv_refcount++;\n    return true;\n  }\n\n  callback_reader_free(on_stdout);\n  callback_reader_free(on_stderr);\n  callback_free(on_exit);\n  return false;\n}\n\n\nChannel *find_job(uint64_t id, bool show_error)\n{\n  Channel *data = find_channel(id);\n  if (!data || data->streamtype != kChannelStreamProc\n      || process_is_stopped(&data->stream.proc)) {\n    if (show_error) {\n      if (data && data->streamtype != kChannelStreamProc) {\n        EMSG(_(e_invchanjob));\n      } else {\n        EMSG(_(e_invchan));\n      }\n    }\n    return NULL;\n  }\n  return data;\n}\n\n\nvoid script_host_eval(char *name, typval_T *argvars, typval_T *rettv)\n{\n  if (check_secure()) {\n    return;\n  }\n\n  if (argvars[0].v_type != VAR_STRING) {\n    EMSG(_(e_invarg));\n    return;\n  }\n\n  list_T *args = tv_list_alloc(1);\n  tv_list_append_string(args, (const char *)argvars[0].vval.v_string, -1);\n  *rettv = eval_call_provider(name, \"eval\", args, false);\n}\n\n/// @param discard  Clears the value returned by the provider and returns\n///                 an empty typval_T.\ntypval_T eval_call_provider(char *provider, char *method, list_T *arguments, bool discard)\n{\n  if (!eval_has_provider(provider)) {\n    emsgf(\"E319: No \\\"%s\\\" provider found. Run \\\":checkhealth provider\\\"\",\n          provider);\n    return (typval_T){\n      .v_type = VAR_NUMBER,\n      .v_lock = VAR_UNLOCKED,\n      .vval.v_number = (varnumber_T)0\n    };\n  }\n\n  char func[256];\n  int name_len = snprintf(func, sizeof(func), \"provider#%s#Call\", provider);\n\n  // Save caller scope information\n  struct caller_scope saved_provider_caller_scope = provider_caller_scope;\n  provider_caller_scope = (struct caller_scope) {\n    .script_ctx = current_sctx,\n    .sourcing_name = sourcing_name,\n    .sourcing_lnum = sourcing_lnum,\n    .autocmd_fname = autocmd_fname,\n    .autocmd_match = autocmd_match,\n    .autocmd_bufnr = autocmd_bufnr,\n    .funccalp = (void *)get_current_funccal()\n  };\n  funccal_entry_T funccal_entry;\n  save_funccal(&funccal_entry);\n  provider_call_nesting++;\n\n  typval_T argvars[3] = {\n    { .v_type = VAR_STRING, .vval.v_string = (char_u *)method,\n      .v_lock = VAR_UNLOCKED },\n    { .v_type = VAR_LIST, .vval.v_list = arguments, .v_lock = VAR_UNLOCKED },\n    { .v_type = VAR_UNKNOWN }\n  };\n  typval_T rettv = { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED };\n  tv_list_ref(arguments);\n\n  funcexe_T funcexe = FUNCEXE_INIT;\n  funcexe.firstline = curwin->w_cursor.lnum;\n  funcexe.lastline = curwin->w_cursor.lnum;\n  funcexe.evaluate = true;\n  (void)call_func((const char_u *)func, name_len, &rettv, 2, argvars, &funcexe);\n\n  tv_list_unref(arguments);\n  // Restore caller scope information\n  restore_funccal();\n  provider_caller_scope = saved_provider_caller_scope;\n  provider_call_nesting--;\n  assert(provider_call_nesting >= 0);\n\n  if (discard) {\n    tv_clear(&rettv);\n  }\n\n  return rettv;\n}\n\n/// Checks if provider for feature `feat` is enabled.\nbool eval_has_provider(const char *feat)\n{\n  if (!strequal(feat, \"clipboard\")\n      && !strequal(feat, \"python\")\n      && !strequal(feat, \"python3\")\n      && !strequal(feat, \"python_compiled\")\n      && !strequal(feat, \"python_dynamic\")\n      && !strequal(feat, \"python3_compiled\")\n      && !strequal(feat, \"python3_dynamic\")\n      && !strequal(feat, \"perl\")\n      && !strequal(feat, \"ruby\")\n      && !strequal(feat, \"node\")) {\n    // Avoid autoload for non-provider has() features.\n    return false;\n  }\n\n  char name[32];  // Normalized: \"python_compiled\" => \"python\".\n  snprintf(name, sizeof(name), \"%s\", feat);\n  strchrsub(name, '_', '\\0');  // Chop any \"_xx\" suffix.\n\n  char buf[256];\n  typval_T tv;\n  // Get the g:loaded_xx_provider variable.\n  int len = snprintf(buf, sizeof(buf), \"g:loaded_%s_provider\", name);\n  if (get_var_tv(buf, len, &tv, NULL, false, true) == FAIL) {\n    // Trigger autoload once.\n    len = snprintf(buf, sizeof(buf), \"provider#%s#bogus\", name);\n    script_autoload(buf, len, false);\n\n    // Retry the (non-autoload-style) variable.\n    len = snprintf(buf, sizeof(buf), \"g:loaded_%s_provider\", name);\n    if (get_var_tv(buf, len, &tv, NULL, false, true) == FAIL) {\n      // Show a hint if Call() is defined but g:loaded_xx_provider is missing.\n      snprintf(buf, sizeof(buf), \"provider#%s#Call\", name);\n      if (!!find_func((char_u *)buf) && p_lpl) {\n        emsgf(\"provider: %s: missing required variable g:loaded_%s_provider\",\n              name, name);\n      }\n      return false;\n    }\n  }\n\n  bool ok = (tv.v_type == VAR_NUMBER)\n    ? 2 == tv.vval.v_number  // Value of 2 means \"loaded and working\".\n    : false;\n\n  if (ok) {\n    // Call() must be defined if provider claims to be working.\n    snprintf(buf, sizeof(buf), \"provider#%s#Call\", name);\n    if (!find_func((char_u *)buf)) {\n      emsgf(\"provider: %s: g:loaded_%s_provider=2 but %s is not defined\",\n            name, name, buf);\n      ok = false;\n    }\n  }\n\n  return ok;\n}\n\n/// Writes \"<sourcing_name>:<sourcing_lnum>\" to `buf[bufsize]`.\nvoid eval_fmt_source_name_line(char *buf, size_t bufsize)\n{\n  if (sourcing_name) {\n    snprintf(buf, bufsize, \"%s:%\" PRIdLINENR, sourcing_name, sourcing_lnum);\n  } else {\n    snprintf(buf, bufsize, \"?\");\n  }\n}\n\n/// \":checkhealth [plugins]\"\nvoid ex_checkhealth(exarg_T *eap)\n{\n  bool found = !!find_func((char_u *)\"health#check\");\n  if (!found\n      && script_autoload(\"health#check\", sizeof(\"health#check\") - 1, false)) {\n    found = !!find_func((char_u *)\"health#check\");\n  }\n  if (!found) {\n    const char *vimruntime_env = os_getenv(\"VIMRUNTIME\");\n    if (vimruntime_env == NULL) {\n      EMSG(_(\"E5009: $VIMRUNTIME is empty or unset\"));\n    } else {\n      bool rtp_ok = NULL != strstr((char *)p_rtp, vimruntime_env);\n      if (rtp_ok) {\n        EMSG2(_(\"E5009: Invalid $VIMRUNTIME: %s\"), vimruntime_env);\n      } else {\n        EMSG(_(\"E5009: Invalid 'runtimepath'\"));\n      }\n    }\n    return;\n  }\n\n  size_t bufsize = STRLEN(eap->arg) + sizeof(\"call health#check('')\");\n  char *buf = xmalloc(bufsize);\n  snprintf(buf, bufsize, \"call health#check('%s')\", eap->arg);\n\n  do_cmdline_cmd(buf);\n\n  xfree(buf);\n}\n\nvoid invoke_prompt_callback(void)\n{\n  typval_T rettv;\n  typval_T argv[2];\n  char_u *text;\n  char_u *prompt;\n  linenr_T lnum = curbuf->b_ml.ml_line_count;\n\n  // Add a new line for the prompt before invoking the callback, so that\n  // text can always be inserted above the last line.\n  ml_append(lnum, (char_u *)\"\", 0, false);\n  curwin->w_cursor.lnum = lnum + 1;\n  curwin->w_cursor.col = 0;\n\n  if (curbuf->b_prompt_callback.type == kCallbackNone) {\n    return;\n  }\n  text = ml_get(lnum);\n  prompt = prompt_text();\n  if (STRLEN(text) >= STRLEN(prompt)) {\n    text += STRLEN(prompt);\n  }\n  argv[0].v_type = VAR_STRING;\n  argv[0].vval.v_string = vim_strsave(text);\n  argv[1].v_type = VAR_UNKNOWN;\n\n  callback_call(&curbuf->b_prompt_callback, 1, argv, &rettv);\n  tv_clear(&argv[0]);\n  tv_clear(&rettv);\n}\n\n// Return true When the interrupt callback was invoked.\nbool invoke_prompt_interrupt(void)\n{\n  typval_T rettv;\n  typval_T argv[1];\n\n  if (curbuf->b_prompt_interrupt.type == kCallbackNone) {\n    return false;\n  }\n  argv[0].v_type = VAR_UNKNOWN;\n\n  got_int = false;  // don't skip executing commands\n  callback_call(&curbuf->b_prompt_interrupt, 0, argv, &rettv);\n  tv_clear(&rettv);\n  return true;\n}\n\n/// Compare \"typ1\" and \"typ2\".  Put the result in \"typ1\".\n///\n/// @param typ1  first operand\n/// @param typ2  second operand\n/// @param type  operator\n/// @param ic  ignore case\nint typval_compare(typval_T *typ1, typval_T *typ2, exprtype_T type, bool ic)\n  FUNC_ATTR_NONNULL_ALL\n{\n  varnumber_T n1, n2;\n  const bool type_is = type == EXPR_IS || type == EXPR_ISNOT;\n\n  if (type_is && typ1->v_type != typ2->v_type) {\n    // For \"is\" a different type always means false, for \"notis\"\n    // it means true.\n    n1 = type == EXPR_ISNOT;\n  } else if (typ1->v_type == VAR_BLOB || typ2->v_type == VAR_BLOB) {\n    if (type_is) {\n      n1 = typ1->v_type == typ2->v_type\n           && typ1->vval.v_blob == typ2->vval.v_blob;\n      if (type == EXPR_ISNOT) {\n        n1 = !n1;\n      }\n    } else if (typ1->v_type != typ2->v_type\n               || (type != EXPR_EQUAL && type != EXPR_NEQUAL)) {\n      if (typ1->v_type != typ2->v_type) {\n        EMSG(_(\"E977: Can only compare Blob with Blob\"));\n      } else {\n        EMSG(_(e_invalblob));\n      }\n      tv_clear(typ1);\n      return FAIL;\n    } else {\n      // Compare two Blobs for being equal or unequal.\n      n1 = tv_blob_equal(typ1->vval.v_blob, typ2->vval.v_blob);\n      if (type == EXPR_NEQUAL) {\n        n1 = !n1;\n      }\n    }\n  } else if (typ1->v_type == VAR_LIST || typ2->v_type == VAR_LIST) {\n    if (type_is) {\n      n1 = typ1->v_type == typ2->v_type\n           && typ1->vval.v_list == typ2->vval.v_list;\n      if (type == EXPR_ISNOT) {\n        n1 = !n1;\n      }\n    } else if (typ1->v_type != typ2->v_type\n               || (type != EXPR_EQUAL && type != EXPR_NEQUAL)) {\n      if (typ1->v_type != typ2->v_type) {\n        EMSG(_(\"E691: Can only compare List with List\"));\n      } else {\n        EMSG(_(\"E692: Invalid operation for List\"));\n      }\n      tv_clear(typ1);\n      return FAIL;\n    } else {\n      // Compare two Lists for being equal or unequal.\n      n1 = tv_list_equal(typ1->vval.v_list, typ2->vval.v_list, ic, false);\n      if (type == EXPR_NEQUAL) {\n        n1 = !n1;\n      }\n    }\n  } else if (typ1->v_type == VAR_DICT || typ2->v_type == VAR_DICT) {\n    if (type_is) {\n      n1 = typ1->v_type == typ2->v_type\n           && typ1->vval.v_dict == typ2->vval.v_dict;\n      if (type == EXPR_ISNOT) {\n        n1 = !n1;\n      }\n    } else if (typ1->v_type != typ2->v_type\n               || (type != EXPR_EQUAL && type != EXPR_NEQUAL)) {\n      if (typ1->v_type != typ2->v_type) {\n        EMSG(_(\"E735: Can only compare Dictionary with Dictionary\"));\n      } else {\n        EMSG(_(\"E736: Invalid operation for Dictionary\"));\n      }\n      tv_clear(typ1);\n      return FAIL;\n    } else {\n      // Compare two Dictionaries for being equal or unequal.\n      n1 = tv_dict_equal(typ1->vval.v_dict, typ2->vval.v_dict, ic, false);\n      if (type == EXPR_NEQUAL) {\n        n1 = !n1;\n      }\n    }\n  } else if (tv_is_func(*typ1) || tv_is_func(*typ2)) {\n    if (type != EXPR_EQUAL && type != EXPR_NEQUAL\n        && type != EXPR_IS && type != EXPR_ISNOT) {\n      EMSG(_(\"E694: Invalid operation for Funcrefs\"));\n      tv_clear(typ1);\n      return FAIL;\n    }\n    if ((typ1->v_type == VAR_PARTIAL && typ1->vval.v_partial == NULL)\n        || (typ2->v_type == VAR_PARTIAL && typ2->vval.v_partial == NULL)) {\n      // when a partial is NULL assume not equal\n      n1 = false;\n    } else if (type_is) {\n      if (typ1->v_type == VAR_FUNC && typ2->v_type == VAR_FUNC) {\n        // strings are considered the same if their value is\n        // the same\n        n1 = tv_equal(typ1, typ2, ic, false);\n      } else if (typ1->v_type == VAR_PARTIAL && typ2->v_type == VAR_PARTIAL) {\n        n1 = typ1->vval.v_partial == typ2->vval.v_partial;\n      } else {\n        n1 = false;\n      }\n    } else {\n      n1 = tv_equal(typ1, typ2, ic, false);\n    }\n    if (type == EXPR_NEQUAL || type == EXPR_ISNOT) {\n      n1 = !n1;\n    }\n  } else if ((typ1->v_type == VAR_FLOAT || typ2->v_type == VAR_FLOAT)\n             && type != EXPR_MATCH && type != EXPR_NOMATCH) {\n    // If one of the two variables is a float, compare as a float.\n    // When using \"=~\" or \"!~\", always compare as string.\n    const float_T f1 = tv_get_float(typ1);\n    const float_T f2 = tv_get_float(typ2);\n    n1 = false;\n    switch (type) {\n    case EXPR_IS:\n    case EXPR_EQUAL:\n      n1 = f1 == f2; break;\n    case EXPR_ISNOT:\n    case EXPR_NEQUAL:\n      n1 = f1 != f2; break;\n    case EXPR_GREATER:\n      n1 = f1 > f2; break;\n    case EXPR_GEQUAL:\n      n1 = f1 >= f2; break;\n    case EXPR_SMALLER:\n      n1 = f1 < f2; break;\n    case EXPR_SEQUAL:\n      n1 = f1 <= f2; break;\n    case EXPR_UNKNOWN:\n    case EXPR_MATCH:\n    case EXPR_NOMATCH:\n      break;  // avoid gcc warning\n    }\n  } else if ((typ1->v_type == VAR_NUMBER || typ2->v_type == VAR_NUMBER)\n             && type != EXPR_MATCH && type != EXPR_NOMATCH) {\n    // If one of the two variables is a number, compare as a number.\n    // When using \"=~\" or \"!~\", always compare as string.\n    n1 = tv_get_number(typ1);\n    n2 = tv_get_number(typ2);\n    switch (type) {\n    case EXPR_IS:\n    case EXPR_EQUAL:\n      n1 = n1 == n2; break;\n    case EXPR_ISNOT:\n    case EXPR_NEQUAL:\n      n1 = n1 != n2; break;\n    case EXPR_GREATER:\n      n1 = n1 > n2; break;\n    case EXPR_GEQUAL:\n      n1 = n1 >= n2; break;\n    case EXPR_SMALLER:\n      n1 = n1 < n2; break;\n    case EXPR_SEQUAL:\n      n1 = n1 <= n2; break;\n    case EXPR_UNKNOWN:\n    case EXPR_MATCH:\n    case EXPR_NOMATCH:\n      break;  // avoid gcc warning\n    }\n  } else {\n    char buf1[NUMBUFLEN];\n    char buf2[NUMBUFLEN];\n    const char *const s1 = tv_get_string_buf(typ1, buf1);\n    const char *const s2 = tv_get_string_buf(typ2, buf2);\n    int i;\n    if (type != EXPR_MATCH && type != EXPR_NOMATCH) {\n      i = mb_strcmp_ic(ic, s1, s2);\n    } else {\n      i = 0;\n    }\n    n1 = false;\n    switch (type) {\n    case EXPR_IS:\n    case EXPR_EQUAL:\n      n1 = i == 0; break;\n    case EXPR_ISNOT:\n    case EXPR_NEQUAL:\n      n1 = i != 0; break;\n    case EXPR_GREATER:\n      n1 = i > 0; break;\n    case EXPR_GEQUAL:\n      n1 = i >= 0; break;\n    case EXPR_SMALLER:\n      n1 = i < 0; break;\n    case EXPR_SEQUAL:\n      n1 = i <= 0; break;\n\n    case EXPR_MATCH:\n    case EXPR_NOMATCH:\n      n1 = pattern_match((char_u *)s2, (char_u *)s1, ic);\n      if (type == EXPR_NOMATCH) {\n        n1 = !n1;\n      }\n      break;\n    case EXPR_UNKNOWN:\n      break;  // avoid gcc warning\n    }\n  }\n  tv_clear(typ1);\n  typ1->v_type = VAR_NUMBER;\n  typ1->vval.v_number = n1;\n  return OK;\n}\n\nchar *typval_tostring(typval_T *arg)\n{\n  if (arg == NULL) {\n    return xstrdup(\"(does not exist)\");\n  }\n  return encode_tv2string(arg, NULL);\n}\n\nbool var_exists(const char *var)\n  FUNC_ATTR_NONNULL_ALL\n{\n  char *tofree;\n  bool n = false;\n\n  // get_name_len() takes care of expanding curly braces\n  const char *name = var;\n  const int len = get_name_len((const char **)&var, &tofree, true, false);\n  if (len > 0) {\n    typval_T tv;\n\n    if (tofree != NULL) {\n      name = tofree;\n    }\n    n = get_var_tv(name, len, &tv, NULL, false, true) == OK;\n    if (n) {\n      // Handle d.key, l[idx], f(expr).\n      n = handle_subscript(&var, &tv, true, false, (const char_u *)name,\n                           (const char_u **)&name)\n          == OK;\n      if (n) {\n        tv_clear(&tv);\n      }\n    }\n  }\n  if (*var != NUL) {\n    n = false;\n  }\n\n  xfree(tofree);\n  return n;\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}, "2": {"id": 2, "path": "src/nvim/eval/typval.h", "content": "#ifndef NVIM_EVAL_TYPVAL_H\n#define NVIM_EVAL_TYPVAL_H\n\n#include <inttypes.h>\n#include <stddef.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"nvim/types.h\"\n#include \"nvim/hashtab.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/func_attr.h\"\n#include \"nvim/lib/queue.h\"\n#include \"nvim/profile.h\"  // for proftime_T\n#include \"nvim/pos.h\"      // for linenr_T\n#include \"nvim/gettext.h\"\n#include \"nvim/message.h\"\n#include \"nvim/macros.h\"\n#ifdef LOG_LIST_ACTIONS\n# include \"nvim/memory.h\"\n#endif\n\n/// Type used for VimL VAR_NUMBER values\ntypedef int64_t varnumber_T;\ntypedef uint64_t uvarnumber_T;\n\n/// Type used for VimL VAR_FLOAT values\ntypedef double float_T;\n\n/// Refcount for dict or list that should not be freed\nenum { DO_NOT_FREE_CNT = (INT_MAX / 2) };\n\n/// Additional values for tv_list_alloc() len argument\nenum ListLenSpecials {\n  /// List length is not known in advance\n  ///\n  /// To be used when there is neither a way to know how many elements will be\n  /// needed nor are any educated guesses.\n  kListLenUnknown = -1,\n  /// List length *should* be known, but is actually not\n  ///\n  /// All occurrences of this value should be eventually removed. This is for\n  /// the case when the only reason why list length is not known is that it\n  /// would be hard to code without refactoring, but refactoring is needed.\n  kListLenShouldKnow = -2,\n  /// List length may be known in advance, but it requires too much effort\n  ///\n  /// To be used when it looks impractical to determine list length.\n  kListLenMayKnow = -3,\n};\n\n/// Maximal possible value of varnumber_T variable\n#define VARNUMBER_MAX INT64_MAX\n#define UVARNUMBER_MAX UINT64_MAX\n\n/// Minimal possible value of varnumber_T variable\n#define VARNUMBER_MIN INT64_MIN\n\n/// %d printf format specifier for varnumber_T\n#define PRIdVARNUMBER PRId64\n\ntypedef struct listvar_S list_T;\ntypedef struct dictvar_S dict_T;\ntypedef struct partial_S partial_T;\ntypedef struct blobvar_S blob_T;\n\ntypedef struct ufunc ufunc_T;\n\ntypedef enum {\n  kCallbackNone = 0,\n  kCallbackFuncref,\n  kCallbackPartial,\n} CallbackType;\n\ntypedef struct {\n  union {\n    char_u *funcref;\n    partial_T *partial;\n  } data;\n  CallbackType type;\n} Callback;\n#define CALLBACK_NONE ((Callback){ .type = kCallbackNone })\n\n/// Structure holding dictionary watcher\ntypedef struct dict_watcher {\n  Callback callback;\n  char *key_pattern;\n  size_t key_pattern_len;\n  QUEUE node;\n  bool busy;  // prevent recursion if the dict is changed in the callback\n  bool needs_free;\n} DictWatcher;\n\n/// Bool variable values\ntypedef enum {\n  kBoolVarFalse,         ///< v:false\n  kBoolVarTrue,          ///< v:true\n} BoolVarValue;\n\n/// Special variable values\ntypedef enum {\n  kSpecialVarNull,   ///< v:null\n} SpecialVarValue;\n\n/// Variable lock status for typval_T.v_lock\ntypedef enum {\n  VAR_UNLOCKED = 0,  ///< Not locked.\n  VAR_LOCKED = 1,    ///< User lock, can be unlocked.\n  VAR_FIXED = 2,     ///< Locked forever.\n} VarLockStatus;\n\n/// VimL variable types, for use in typval_T.v_type\ntypedef enum {\n  VAR_UNKNOWN = 0,  ///< Unknown (unspecified) value.\n  VAR_NUMBER,       ///< Number, .v_number is used.\n  VAR_STRING,       ///< String, .v_string is used.\n  VAR_FUNC,         ///< Function reference, .v_string is used as function name.\n  VAR_LIST,         ///< List, .v_list is used.\n  VAR_DICT,         ///< Dictionary, .v_dict is used.\n  VAR_FLOAT,        ///< Floating-point value, .v_float is used.\n  VAR_BOOL,         ///< true, false\n  VAR_SPECIAL,      ///< Special value (null), .v_special\n                    ///< is used.\n  VAR_PARTIAL,      ///< Partial, .v_partial is used.\n  VAR_BLOB,         ///< Blob, .v_blob is used.\n} VarType;\n\n/// Structure that holds an internal variable value\ntypedef struct {\n  VarType v_type;  ///< Variable type.\n  VarLockStatus v_lock;  ///< Variable lock status.\n  union typval_vval_union {\n    varnumber_T v_number;  ///< Number, for VAR_NUMBER.\n    BoolVarValue v_bool;        ///< Bool value, for VAR_BOOL\n    SpecialVarValue v_special;  ///< Special value, for VAR_SPECIAL.\n    float_T v_float;  ///< Floating-point number, for VAR_FLOAT.\n    char_u *v_string;  ///< String, for VAR_STRING and VAR_FUNC, can be NULL.\n    list_T *v_list;  ///< List for VAR_LIST, can be NULL.\n    dict_T *v_dict;  ///< Dictionary for VAR_DICT, can be NULL.\n    partial_T *v_partial;  ///< Closure: function with args.\n    blob_T *v_blob;  ///< Blob for VAR_BLOB, can be NULL.\n  }           vval;  ///< Actual value.\n} typval_T;\n\n/// Values for (struct dictvar_S).dv_scope\ntypedef enum {\n  VAR_NO_SCOPE = 0,  ///< Not a scope dictionary.\n  VAR_SCOPE = 1,  ///< Scope dictionary which requires prefix (a:, v:, \u2026).\n  VAR_DEF_SCOPE = 2,  ///< Scope dictionary which may be accessed without prefix\n                      ///< (l:, g:).\n} ScopeType;\n\n/// Structure to hold an item of a list\ntypedef struct listitem_S listitem_T;\n\nstruct listitem_S {\n  listitem_T  *li_next;  ///< Next item in list.\n  listitem_T  *li_prev;  ///< Previous item in list.\n  typval_T li_tv;  ///< Item value.\n};\n\n/// Structure used by those that are using an item in a list\ntypedef struct listwatch_S listwatch_T;\n\nstruct listwatch_S {\n  listitem_T *lw_item;  ///< Item being watched.\n  listwatch_T *lw_next;  ///< Next watcher.\n};\n\n/// Structure to hold info about a list\n/// Order of members is optimized to reduce padding.\nstruct listvar_S {\n  listitem_T *lv_first;  ///< First item, NULL if none.\n  listitem_T *lv_last;  ///< Last item, NULL if none.\n  listwatch_T *lv_watch;  ///< First watcher, NULL if none.\n  listitem_T *lv_idx_item;  ///< When not NULL item at index \"lv_idx\".\n  list_T *lv_copylist;  ///< Copied list used by deepcopy().\n  list_T *lv_used_next;  ///< next list in used lists list.\n  list_T *lv_used_prev;  ///< Previous list in used lists list.\n  int lv_refcount;  ///< Reference count.\n  int lv_len;  ///< Number of items.\n  int lv_idx;  ///< Index of a cached item, used for optimising repeated l[idx].\n  int lv_copyID;  ///< ID used by deepcopy().\n  VarLockStatus lv_lock;  ///< Zero, VAR_LOCKED, VAR_FIXED.\n\n  LuaRef lua_table_ref;\n};\n\n// Static list with 10 items. Use tv_list_init_static10() to initialize.\ntypedef struct {\n  list_T sl_list;  // must be first\n  listitem_T sl_items[10];\n} staticList10_T;\n\n#define TV_LIST_STATIC10_INIT { \\\n    .sl_list = { \\\n      .lv_first = NULL, \\\n      .lv_last = NULL, \\\n      .lv_refcount = 0, \\\n      .lv_len = 0, \\\n      .lv_watch = NULL, \\\n      .lv_idx_item = NULL, \\\n      .lv_lock = VAR_FIXED, \\\n      .lv_used_next = NULL, \\\n      .lv_used_prev = NULL, \\\n    }, \\\n  }\n\n#define TV_DICTITEM_STRUCT(...) \\\n    struct { \\\n      typval_T di_tv;  /* Structure that holds scope dictionary itself. */ \\\n      uint8_t di_flags;  /* Flags. */ \\\n      char_u di_key[__VA_ARGS__];  /* Key value. */ \\\n    }\n\n/// Structure to hold a scope dictionary\n///\n/// @warning Must be compatible with dictitem_T.\n///\n/// For use in find_var_in_ht to pretend that it found dictionary item when it\n/// finds scope dictionary.\ntypedef TV_DICTITEM_STRUCT(1) ScopeDictDictItem;\n\n/// Structure to hold an item of a Dictionary\n///\n/// @warning Must be compatible with ScopeDictDictItem.\n///\n/// Also used for a variable.\ntypedef TV_DICTITEM_STRUCT() dictitem_T;\n\n/// Flags for dictitem_T.di_flags\ntypedef enum {\n  DI_FLAGS_RO = 1,  ///< Read-only value\n  DI_FLAGS_RO_SBX = 2,  ///< Value, read-only in the sandbox\n  DI_FLAGS_FIX = 4,  ///< Fixed value: cannot be :unlet or remove()d.\n  DI_FLAGS_LOCK = 8,  ///< Locked value.\n  DI_FLAGS_ALLOC = 16,  ///< Separately allocated.\n} DictItemFlags;\n\n/// Structure representing a Dictionary\nstruct dictvar_S {\n  VarLockStatus dv_lock;  ///< Whole dictionary lock status.\n  ScopeType dv_scope;     ///< Non-zero (#VAR_SCOPE, #VAR_DEF_SCOPE) if\n                          ///< dictionary represents a scope (i.e. g:, l: \u2026).\n  int dv_refcount;        ///< Reference count.\n  int dv_copyID;          ///< ID used when recursivery traversing a value.\n  hashtab_T dv_hashtab;   ///< Hashtab containing all items.\n  dict_T *dv_copydict;    ///< Copied dict used by deepcopy().\n  dict_T *dv_used_next;   ///< Next dictionary in used dictionaries list.\n  dict_T *dv_used_prev;   ///< Previous dictionary in used dictionaries list.\n  QUEUE watchers;         ///< Dictionary key watchers set by user code.\n\n  LuaRef lua_table_ref;\n};\n\n/// Structure to hold info about a Blob\nstruct blobvar_S {\n  garray_T bv_ga;         ///< Growarray with the data.\n  int bv_refcount;        ///< Reference count.\n  VarLockStatus bv_lock;  ///< VAR_UNLOCKED, VAR_LOCKED, VAR_FIXED.\n};\n\n/// Type used for script ID\ntypedef int scid_T;\n/// Format argument for scid_T\n#define PRIdSCID \"d\"\n\n// SCript ConteXt (SCTX): identifies a script line.\n// When sourcing a script \"sc_lnum\" is zero, \"sourcing_lnum\" is the current\n// line number. When executing a user function \"sc_lnum\" is the line where the\n// function was defined, \"sourcing_lnum\" is the line number inside the\n// function.  When stored with a function, mapping, option, etc. \"sc_lnum\" is\n// the line number in the script \"sc_sid\".\ntypedef struct {\n  scid_T sc_sid;     // script ID\n  int sc_seq;        // sourcing sequence number\n  linenr_T sc_lnum;  // line number\n} sctx_T;\n\n/// Maximum number of function arguments\n#define MAX_FUNC_ARGS   20\n/// Short variable name length\n#define VAR_SHORT_LEN 20\n/// Number of fixed variables used for arguments\n#define FIXVAR_CNT 12\n\n/// Callback interface for C function reference>\n///     Used for managing functions that were registered with |register_cfunc|\ntypedef int (*cfunc_T)(int argcount, typval_T *argvars, typval_T *rettv, void *state);  // NOLINT\n/// Callback to clear cfunc_T and any associated state.\ntypedef void (*cfunc_free_T)(void *state);\n\n// Structure to hold info for a function that is currently being executed.\ntypedef struct funccall_S funccall_T;\n\nstruct funccall_S {\n  ufunc_T *func;  ///< Function being called.\n  int linenr;  ///< Next line to be executed.\n  int returned;  ///< \":return\" used.\n  /// Fixed variables for arguments.\n  TV_DICTITEM_STRUCT(VAR_SHORT_LEN + 1) fixvar[FIXVAR_CNT];\n  dict_T l_vars;  ///< l: local function variables.\n  ScopeDictDictItem l_vars_var;  ///< Variable for l: scope.\n  dict_T l_avars;  ///< a: argument variables.\n  ScopeDictDictItem l_avars_var;  ///< Variable for a: scope.\n  list_T l_varlist;  ///< List for a:000.\n  listitem_T l_listitems[MAX_FUNC_ARGS];  ///< List items for a:000.\n  typval_T *rettv;  ///< Return value.\n  linenr_T breakpoint;  ///< Next line with breakpoint or zero.\n  int dbg_tick;  ///< Debug_tick when breakpoint was set.\n  int level;  ///< Top nesting level of executed function.\n  proftime_T prof_child;  ///< Time spent in a child.\n  funccall_T *caller;  ///< Calling function or NULL; or next funccal in\n                       ///< list pointed to by previous_funccal.\n  int fc_refcount;  ///< Number of user functions that reference this funccall.\n  int fc_copyID;  ///< CopyID used for garbage collection.\n  garray_T fc_funcs;  ///< List of ufunc_T* which keep a reference to \"func\".\n};\n\n/// Structure to hold info for a user function.\nstruct ufunc {\n  int          uf_varargs;       ///< variable nr of arguments\n  int          uf_flags;\n  int          uf_calls;         ///< nr of active calls\n  bool         uf_cleared;       ///< func_clear() was already called\n  garray_T     uf_args;          ///< arguments\n  garray_T     uf_def_args;      ///< default argument expressions\n  garray_T     uf_lines;         ///< function lines\n  int          uf_profiling;     ///< true when func is being profiled\n  int          uf_prof_initialized;\n  // Managing cfuncs\n  cfunc_T      uf_cb;            ///< C function extension callback\n  cfunc_free_T uf_cb_free;       ///< C function extension free callback\n  void        *uf_cb_state;      ///< State of C function extension.\n  // Profiling the function as a whole.\n  int          uf_tm_count;      ///< nr of calls\n  proftime_T   uf_tm_total;      ///< time spent in function + children\n  proftime_T   uf_tm_self;       ///< time spent in function itself\n  proftime_T   uf_tm_children;   ///< time spent in children this call\n  // Profiling the function per line.\n  int         *uf_tml_count;     ///< nr of times line was executed\n  proftime_T  *uf_tml_total;     ///< time spent in a line + children\n  proftime_T  *uf_tml_self;      ///< time spent in a line itself\n  proftime_T   uf_tml_start;     ///< start time for current line\n  proftime_T   uf_tml_children;  ///< time spent in children for this line\n  proftime_T   uf_tml_wait;      ///< start wait time for current line\n  int          uf_tml_idx;       ///< index of line being timed; -1 if none\n  int          uf_tml_execed;    ///< line being timed was executed\n  sctx_T       uf_script_ctx;    ///< SCTX where function was defined,\n                                 ///< used for s: variables\n  int          uf_refcount;      ///< reference count, see func_name_refcount()\n  funccall_T   *uf_scoped;       ///< l: local variables for closure\n  char_u       uf_name[];  ///< Name of function (actual size equals name);\n                           ///< can start with <SNR>123_\n                           ///< (<SNR> is K_SPECIAL KS_EXTRA KE_SNR)\n};\n\nstruct partial_S {\n  int pt_refcount;  ///< Reference count.\n  char_u *pt_name;  ///< Function name; when NULL use pt_func->name.\n  ufunc_T *pt_func;  ///< Function pointer; when NULL lookup function with\n                     ///< pt_name.\n  bool pt_auto;  ///< When true the partial was created by using dict.member\n                 ///< in handle_subscript().\n  int pt_argc;  ///< Number of arguments.\n  typval_T *pt_argv;  ///< Arguments in allocated array.\n  dict_T *pt_dict;  ///< Dict for \"self\".\n};\n\n/// Structure used for explicit stack while garbage collecting hash tables\ntypedef struct ht_stack_S {\n  hashtab_T *ht;\n  struct ht_stack_S *prev;\n} ht_stack_T;\n\n/// Structure used for explicit stack while garbage collecting lists\ntypedef struct list_stack_S {\n  list_T *list;\n  struct list_stack_S *prev;\n} list_stack_T;\n\n/// Structure representing one list item, used for sort array.\ntypedef struct {\n  listitem_T *item;  ///< Sorted list item.\n  int idx;  ///< Sorted list item index.\n} ListSortItem;\n\ntypedef int (*ListSorter)(const void *, const void *);\n\n#ifdef LOG_LIST_ACTIONS\n\n/// List actions log entry\ntypedef struct {\n  uintptr_t l;  ///< List log entry belongs to.\n  uintptr_t li1;  ///< First list item log entry belongs to, if applicable.\n  uintptr_t li2;  ///< Second list item log entry belongs to, if applicable.\n  int len;  ///< List length when log entry was created.\n  const char *action;  ///< Logged action.\n} ListLogEntry;\n\ntypedef struct list_log ListLog;\n\n/// List actions log\nstruct list_log {\n  ListLog *next;  ///< Next chunk or NULL.\n  size_t capacity;  ///< Number of entries in current chunk.\n  size_t size;  ///< Current chunk size.\n  ListLogEntry entries[];  ///< Actual log entries.\n};\n\nextern ListLog *list_log_first;  ///< First list log chunk, NULL if missing\nextern ListLog *list_log_last;  ///< Last list log chunk\n\nstatic inline ListLog *list_log_alloc(const size_t size)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Allocate a new log chunk and update globals\n///\n/// @param[in]  size  Number of entries in a new chunk.\n///\n/// @return [allocated] Newly allocated chunk.\nstatic inline ListLog *list_log_new(const size_t size)\n{\n  ListLog *ret = xmalloc(offsetof(ListLog, entries)\n                         + size * sizeof(ret->entries[0]));\n  ret->size = 0;\n  ret->capacity = size;\n  ret->next = NULL;\n  if (list_log_first == NULL) {\n    list_log_first = ret;\n  } else {\n    list_log_last->next = ret;\n  }\n  list_log_last = ret;\n  return ret;\n}\n\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Add new entry to log\n///\n/// If last chunk was filled it uses twice as much memory to allocate the next\n/// chunk.\n///\n/// @param[in]  l  List to which entry belongs.\n/// @param[in]  li1  List item 1.\n/// @param[in]  li2  List item 2, often used for integers and not list items.\n/// @param[in]  action  Logged action.\nstatic inline void list_log(const list_T *const l,\n                            const listitem_T *const li1,\n                            const listitem_T *const li2,\n                            const char *const action)\n{\n  ListLog *tgt;\n  if (list_log_first == NULL) {\n    tgt = list_log_new(128);\n  } else if (list_log_last->size == list_log_last->capacity) {\n    tgt = list_log_new(list_log_last->capacity * 2);\n  } else {\n    tgt = list_log_last;\n  }\n  tgt->entries[tgt->size++] = (ListLogEntry) {\n    .l = (uintptr_t)l,\n    .li1 = (uintptr_t)li1,\n    .li2 = (uintptr_t)li2,\n    .len = (l == NULL ? 0 : l->lv_len),\n    .action = action,\n  };\n}\n#else\n# define list_log(...)\n# define list_write_log(...)\n# define list_free_log()\n#endif\n\n// In a hashtab item \"hi_key\" points to \"di_key\" in a dictitem.\n// This avoids adding a pointer to the hashtab item.\n\n/// Convert a hashitem pointer to a dictitem pointer\n#define TV_DICT_HI2DI(hi) \\\n    ((dictitem_T *)((hi)->hi_key - offsetof(dictitem_T, di_key)))\n\nstatic inline void tv_list_ref(list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE;\n\n/// Increase reference count for a given list\n///\n/// Does nothing for NULL lists.\n///\n/// @param[in,out]  l  List to modify.\nstatic inline void tv_list_ref(list_T *const l)\n{\n  if (l == NULL) {\n    return;\n  }\n  l->lv_refcount++;\n}\n\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a list as the return value.  Increments the reference count.\n///\n/// @param[out]  tv  Object to receive the list\n/// @param[in,out]  l  List to pass to the object\nstatic inline void tv_list_set_ret(typval_T *const tv, list_T *const l)\n{\n  tv->v_type = VAR_LIST;\n  tv->vval.v_list = l;\n  tv_list_ref(l);\n}\n\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get list lock status\n///\n/// Returns VAR_FIXED for NULL lists.\n///\n/// @param[in]  l  List to check.\nstatic inline VarLockStatus tv_list_locked(const list_T *const l)\n{\n  if (l == NULL) {\n    return VAR_FIXED;\n  }\n  return l->lv_lock;\n}\n\n/// Set list lock status\n///\n/// May only \u201cset\u201d VAR_FIXED for NULL lists.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  lock  New lock status.\nstatic inline void tv_list_set_lock(list_T *const l,\n                                    const VarLockStatus lock)\n{\n  if (l == NULL) {\n    assert(lock == VAR_FIXED);\n    return;\n  }\n  l->lv_lock = lock;\n}\n\n/// Set list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[out]  l  List to modify.\n/// @param[in]  copyid  New copyID.\nstatic inline void tv_list_set_copyid(list_T *const l,\n                                      const int copyid)\n  FUNC_ATTR_NONNULL_ALL\n{\n  l->lv_copyID = copyid;\n}\n\nstatic inline int tv_list_len(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a list\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_len(const list_T *const l)\n{\n  list_log(l, NULL, NULL, \"len\");\n  if (l == NULL) {\n    return 0;\n  }\n  return l->lv_len;\n}\n\nstatic inline int tv_list_copyid(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get list copyID\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline int tv_list_copyid(const list_T *const l)\n{\n  return l->lv_copyID;\n}\n\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_NONNULL_ALL;\n\n/// Get latest list copy\n///\n/// Gets lv_copylist field assigned by tv_list_copy() earlier.\n///\n/// Does not expect NULL list, be careful.\n///\n/// @param[in]  l  List to check.\nstatic inline list_T *tv_list_latest_copy(const list_T *const l)\n{\n  return l->lv_copylist;\n}\n\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Normalize index: that is, return either -1 or non-negative index\n///\n/// @param[in]  l  List to index. Used to get length.\n/// @param[in]  n  List index, possibly negative.\n///\n/// @return -1 or list index in range [0, tv_list_len(l)).\nstatic inline int tv_list_uidx(const list_T *const l, int n)\n{\n  // Negative index is relative to the end.\n  if (n < 0) {\n    n += tv_list_len(l);\n  }\n\n  // Check for index out of range.\n  if (n < 0 || n >= tv_list_len(l)) {\n    return -1;\n  }\n  return n;\n}\n\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check whether list has watchers\n///\n/// E.g. is referenced by a :for loop.\n///\n/// @param[in]  l  List to check.\n///\n/// @return true if there are watchers, false otherwise.\nstatic inline bool tv_list_has_watchers(const list_T *const l)\n{\n  return l && l->lv_watch;\n}\n\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get first list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_first(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"first\");\n    return NULL;\n  }\n  list_log(l, l->lv_first, NULL, \"first\");\n  return l->lv_first;\n}\n\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get last list item\n///\n/// @param[in]  l  List to get item from.\n///\n/// @return List item or NULL in case of an empty list.\nstatic inline listitem_T *tv_list_last(const list_T *const l)\n{\n  if (l == NULL) {\n    list_log(l, NULL, NULL, \"last\");\n    return NULL;\n  }\n  list_log(l, l->lv_last, NULL, \"last\");\n  return l->lv_last;\n}\n\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a dictionary as the return value\n///\n/// @param[out]  tv  Object to receive the dictionary\n/// @param[in,out]  d  Dictionary to pass to the object\nstatic inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)\n{\n  tv->v_type = VAR_DICT;\n  tv->vval.v_dict = d;\n  if (d != NULL) {\n    d->dv_refcount++;\n  }\n}\n\nstatic inline long tv_dict_len(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the number of items in a Dictionary\n///\n/// @param[in]  d  Dictionary to check.\nstatic inline long tv_dict_len(const dict_T *const d)\n{\n  if (d == NULL) {\n    return 0L;\n  }\n  return (long)d->dv_hashtab.ht_used;\n}\n\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Check if dictionary is watched\n///\n/// @param[in]  d  Dictionary to check.\n///\n/// @return true if there is at least one watcher.\nstatic inline bool tv_dict_is_watched(const dict_T *const d)\n{\n  return d && !QUEUE_EMPTY(&d->watchers);\n}\n\nstatic inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);\n\n/// Set a blob as the return value.\n///\n/// Increments the reference count.\n///\n/// @param[out]  tv  Object to receive the blob.\n/// @param[in,out]  b  Blob to pass to the object.\nstatic inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)\n{\n  tv->v_type = VAR_BLOB;\n  tv->vval.v_blob = b;\n  if (b != NULL) {\n    b->bv_refcount++;\n  }\n}\n\nstatic inline int tv_blob_len(const blob_T *const b)\n  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the length of the data in the blob, in bytes.\n///\n/// @param[in]  b  Blob to check.\nstatic inline int tv_blob_len(const blob_T *const b)\n{\n  if (b == NULL) {\n    return 0;\n  }\n  return b->bv_ga.ga_len;\n}\n\nstatic inline char_u tv_blob_get(const blob_T *const b, int idx)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n/// Get the byte at index `idx` in the blob.\n///\n/// @param[in]  b  Blob to index. Cannot be NULL.\n/// @param[in]  idx  Index in a blob. Must be valid.\n///\n/// @return Byte value at the given index.\nstatic inline char_u tv_blob_get(const blob_T *const b, int idx)\n{\n  return ((char_u *)b->bv_ga.ga_data)[idx];\n}\n\nstatic inline void tv_blob_set(blob_T *const b, int idx, char_u c)\n  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL;\n\n/// Store the byte `c` at index `idx` in the blob.\n///\n/// @param[in]  b  Blob to index. Cannot be NULL.\n/// @param[in]  idx  Index in a blob. Must be valid.\n/// @param[in]  c  Value to store.\nstatic inline void tv_blob_set(blob_T *const b, int idx, char_u c)\n{\n  ((char_u *)b->bv_ga.ga_data)[idx] = c;\n}\n\n/// Initialize VimL object\n///\n/// Initializes to unlocked VAR_UNKNOWN object.\n///\n/// @param[out]  tv  Object to initialize.\nstatic inline void tv_init(typval_T *const tv)\n{\n  if (tv != NULL) {\n    memset(tv, 0, sizeof(*tv));\n  }\n}\n\n#define TV_INITIAL_VALUE \\\n    ((typval_T) { \\\n      .v_type = VAR_UNKNOWN, \\\n      .v_lock = VAR_UNLOCKED, \\\n    })\n\n/// Empty string\n///\n/// Needed for hack which allows not allocating empty string and still not\n/// crashing when freeing it.\nextern const char *const tv_empty_string;\n\n/// Specifies that free_unref_items() function has (not) been entered\nextern bool tv_in_free_unref_items;\n\n/// Iterate over a list\n///\n/// @param  modifier  Modifier: expected to be const or nothing, volatile should\n///                   also work if you have any uses for the volatile list.\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define _TV_LIST_ITER_MOD(modifier, l, li, code) \\\n    do { \\\n      modifier list_T *const l_ = (l); \\\n      list_log(l_, NULL, NULL, \"iter\" #modifier); \\\n      if (l_ != NULL) { \\\n        for (modifier listitem_T *li = l_->lv_first; \\\n             li != NULL; li = li->li_next) { \\\n          code \\\n        } \\\n      } \\\n    } while (0)\n\n/// Iterate over a list\n///\n/// To be used when you need to modify list or values you iterate over, use\n/// #TV_LIST_ITER_CONST if you don\u2019t.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER(l, li, code) \\\n    _TV_LIST_ITER_MOD(, l, li, code)\n\n/// Iterate over a list\n///\n/// To be used when you don\u2019t need to modify list or values you iterate over,\n/// use #TV_LIST_ITER if you do.\n///\n/// @param[in]  l  List to iterate over.\n/// @param  li  Name of the variable with current listitem_T entry.\n/// @param  code  Cycle body.\n#define TV_LIST_ITER_CONST(l, li, code) \\\n    _TV_LIST_ITER_MOD(const, l, li, code)\n\n// Below macros are macros to avoid duplicating code for functionally identical\n// const and non-const function variants.\n\n/// Get typval_T out of list item\n///\n/// @param[in]  li  List item to get typval_T from, must not be NULL.\n///\n/// @return Pointer to typval_T.\n#define TV_LIST_ITEM_TV(li) (&(li)->li_tv)\n\n/// Get next list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the next item or NULL.\n#define TV_LIST_ITEM_NEXT(l, li) ((li)->li_next)\n\n/// Get previous list item given the current one\n///\n/// @param[in]  l  List to get item from.\n/// @param[in]  li  List item to get typval_T from.\n///\n/// @return Pointer to the previous item or NULL.\n#define TV_LIST_ITEM_PREV(l, li) ((li)->li_prev)\n// List argument is not used currently, but it is a must for lists implemented\n// as a pair (size(in list), array) without terminator - basically for lists on\n// top of kvec.\n\n/// Iterate over a dictionary\n///\n/// @param[in]  d  Dictionary to iterate over.\n/// @param  di  Name of the variable with current dictitem_T entry.\n/// @param  code  Cycle body.\n#define TV_DICT_ITER(d, di, code) \\\n    HASHTAB_ITER(&(d)->dv_hashtab, di##hi_, { \\\n      { \\\n        dictitem_T *const di = TV_DICT_HI2DI(di##hi_); \\\n        { \\\n          code \\\n        } \\\n      } \\\n    })\n\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;\n\n// FIXME circular dependency, cannot import message.h.\nbool emsgf(const char *const fmt, ...);\n\n/// Get the float value\n///\n/// Raises an error if object is not number or floating-point.\n///\n/// @param[in]  tv  VimL object to get value from.\n/// @param[out]  ret_f  Location where resulting float is stored.\n///\n/// @return true in case of success, false if tv is not a number or float.\nstatic inline bool tv_get_float_chk(const typval_T *const tv,\n                                    float_T *const ret_f)\n{\n  if (tv->v_type == VAR_FLOAT) {\n    *ret_f = tv->vval.v_float;\n    return true;\n  }\n  if (tv->v_type == VAR_NUMBER) {\n    *ret_f = (float_T)tv->vval.v_number;\n    return true;\n  }\n  emsgf(\"%s\", _(\"E808: Number or Float required\"));\n  return false;\n}\n\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n  REAL_FATTR_NONNULL_ALL REAL_FATTR_NONNULL_RET REAL_FATTR_PURE\n  REAL_FATTR_WARN_UNUSED_RESULT REAL_FATTR_ALWAYS_INLINE;\n\n/// Compute the `DictWatcher` address from a QUEUE node.\n///\n/// This only exists for .asan-blacklist (ASAN doesn't handle QUEUE_DATA pointer\n/// arithmetic).\nstatic inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)\n{\n  return QUEUE_DATA(q, DictWatcher, node);\n}\n\nstatic inline bool tv_is_func(const typval_T tv)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;\n\n/// Check whether given typval_T contains a function\n///\n/// That is, whether it contains VAR_FUNC or VAR_PARTIAL.\n///\n/// @param[in]  tv  Typval to check.\n///\n/// @return True if it is a function or a partial, false otherwise.\nstatic inline bool tv_is_func(const typval_T tv)\n{\n  return tv.v_type == VAR_FUNC || tv.v_type == VAR_PARTIAL;\n}\n\n/// Specify that argument needs to be translated\n///\n/// Used for size_t length arguments to avoid calling gettext() and strlen()\n/// unless needed.\n#define TV_TRANSLATE (SIZE_MAX)\n\n/// Specify that argument is a NUL-terminated C string\n///\n/// Used for size_t length arguments to avoid calling strlen() unless needed.\n#define TV_CSTRING (SIZE_MAX - 1)\n\n#ifdef UNIT_TESTING\n// Do not use enum constants, see commit message.\nEXTERN const size_t kTVCstring INIT(= TV_CSTRING);\nEXTERN const size_t kTVTranslate INIT(= TV_TRANSLATE);\n#endif\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"eval/typval.h.generated.h\"\n#endif\n#endif  // NVIM_EVAL_TYPVAL_H\n"}}, "reports": [{"events": [{"location": {"col": 23, "file": 0, "line": 77}, "message": "kNamespaceChar (fixit)"}, {"location": {"col": 23, "file": 0, "line": 77}, "message": "invalid case style for global constant 'namespace_char'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "9e35b0584c7e160dc12714f9321a12ad", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 128}, "message": "(   ) (fixit)"}, {"location": {"col": 16, "file": 0, "line": 128}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "84330a7930f63a5d5ae96912bb7e4f03", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 0, "line": 130}, "message": "(   ) (fixit)"}, {"location": {"col": 28, "file": 0, "line": 130}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8808a6b0487138c2a38e6cdc24a59ee9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 0, "line": 134}, "message": "(    ) (fixit)"}, {"location": {"col": 17, "file": 0, "line": 134}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "eae291ee82ea0ad7473e98d48ec36503", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 278}, "message": "kMsgpackTypeNames (fixit)"}, {"location": {"col": 26, "file": 0, "line": 278}, "message": "invalid case style for global constant 'msgpack_type_names'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "1349e91faa885082b2e0dfdcf9d98894", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 348}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 348}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "6ec477e6b980e3d9239ea2f62597c822", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 48, "file": 0, "line": 476}, "message": "const (fixit)"}, {"location": {"col": 56, "file": 0, "line": 476}, "message": "pointer parameter 'value' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "f9fd5ec25724ffc3e3a4bec35800a347", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 517}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "b9b7453042ccd1f820db38a1af2f6b58", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 0, "line": 600}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d69c949a3e153dfef93cea9c5b376391", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 786}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "6f26d347e373a84b7e55b68cbfc92e4b", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 846}, "message": "function 'eval_to_string' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "556cf4aead8594b5ddad7d2a6e3df456", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 0, "line": 1530}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "7ea532aa0c617f97a34fcf2a16f8328e", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1566}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8e6e0f09026bcc3aa8eb32b74becd195", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 1578}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "60ddb3a1a33e54a2e3c67690ff12869d", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1714}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "0d90ecfce2a43788f101653306008d19", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1235}, "message": "Calling 'ex_let_const'"}, {"location": {"col": 7, "file": 0, "line": 1377}, "message": "Assuming 'argend' is not equal to NULL"}, {"location": {"col": 3, "file": 0, "line": 1377}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1380}, "message": "Assuming 'argend' is <= 'arg'"}, {"location": {"col": 20, "file": 0, "line": 1380}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 1384}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 1384}, "message": "Left side of '&&' is true"}, {"location": {"col": 26, "file": 0, "line": 1384}, "message": "Assuming the condition is false"}, {"location": {"col": 26, "file": 0, "line": 1385}, "message": "Left side of '&&' is false"}, {"location": {"col": 48, "file": 0, "line": 1385}, "message": "Assuming the condition is false"}, {"location": {"col": 29, "file": 1, "line": 224}, "message": "expanded from macro 'STRNCMP'"}, {"location": {"col": 3, "file": 0, "line": 1384}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 1387}, "message": "Assuming the condition is false"}, {"location": {"col": 5, "file": 0, "line": 1387}, "message": "Taking false branch"}, {"location": {"col": 16, "file": 0, "line": 1389}, "message": "Assuming the condition is true"}, {"location": {"col": 12, "file": 0, "line": 1389}, "message": "Taking true branch"}, {"location": {"col": 23, "file": 0, "line": 1391}, "message": "Calling 'list_arg_vars'"}, {"location": {"col": 10, "file": 0, "line": 1687}, "message": "Assuming the condition is true"}, {"location": {"col": 10, "file": 0, "line": 1687}, "message": "Left side of '&&' is true"}, {"location": {"col": 31, "file": 0, "line": 1687}, "message": "Assuming 'got_int' is 0"}, {"location": {"col": 3, "file": 0, "line": 1687}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 9, "file": 0, "line": 1688}, "message": "'error' is 0"}, {"location": {"col": 9, "file": 0, "line": 1688}, "message": "Left side of '||' is false"}, {"location": {"col": 18, "file": 0, "line": 1688}, "message": "Assuming field 'skip' is 0"}, {"location": {"col": 5, "file": 0, "line": 1688}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 1701}, "message": "Assuming 'len' is > 0"}, {"location": {"col": 7, "file": 0, "line": 1701}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 1711}, "message": "Assuming 'tofree' is equal to NULL"}, {"location": {"col": 9, "file": 0, "line": 1711}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 1714}, "message": "Taking false branch"}, {"location": {"col": 15, "file": 0, "line": 1720}, "message": "Value assigned to 'name'"}, {"location": {"col": 15, "file": 0, "line": 1720}, "message": "Assuming the condition is false"}, {"location": {"col": 11, "file": 0, "line": 1720}, "message": "Taking false branch"}, {"location": {"col": 17, "file": 0, "line": 1725}, "message": "Assuming 'arg' is equal to 'arg_subsc'"}, {"location": {"col": 17, "file": 0, "line": 1725}, "message": "Left side of '&&' is true"}, {"location": {"col": 37, "file": 0, "line": 1725}, "message": "Assuming 'len' is not equal to 2"}, {"location": {"col": 46, "file": 0, "line": 1725}, "message": "Left side of '&&' is false"}, {"location": {"col": 46, "file": 0, "line": 1746}, "message": "'arg' is equal to 'arg_subsc'"}, {"location": {"col": 46, "file": 0, "line": 1746}, "message": "'?' condition is true"}, {"location": {"col": 15, "file": 0, "line": 1746}, "message": "'used_name' initialized here"}, {"location": {"col": 44, "file": 0, "line": 1749}, "message": "Assuming 'used_name' is equal to 'tofree'"}, {"location": {"col": 44, "file": 0, "line": 1749}, "message": "Assuming pointer value is null"}, {"location": {"col": 44, "file": 0, "line": 1749}, "message": "'?' condition is true"}, {"location": {"col": 57, "file": 0, "line": 1750}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}, {"location": {"col": 57, "file": 0, "line": 1750}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "109645e650d6e98f144eab759500e87b", "checkerName": "clang-analyzer-core.NonNullParamChecker", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 0, "line": 2026}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "fb3e0eb043a8659a9f9f91e20df19c88", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 0, "line": 2233}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "9037c0ef6042116e9745afc23705936a", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2422}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "1a45d0edc4d97a9f99e4717f15248df6", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2365}, "message": "Assuming field 'll_tv' is not equal to NULL"}, {"location": {"col": 3, "file": 0, "line": 2365}, "message": "Taking false branch"}, {"location": {"col": 29, "file": 0, "line": 2436}, "message": "Assuming field 'll_newkey' is equal to NULL"}, {"location": {"col": 29, "file": 0, "line": 2436}, "message": "'?' condition is true"}, {"location": {"col": 14, "file": 0, "line": 2436}, "message": "Assuming the condition is false"}, {"location": {"col": 10, "file": 0, "line": 2436}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 2440}, "message": "Assuming field 'll_range' is true"}, {"location": {"col": 10, "file": 0, "line": 2440}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 2444}, "message": "Assuming 'is_const' is false"}, {"location": {"col": 5, "file": 0, "line": 2444}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 2451}, "message": "Assuming 'ri' is not equal to NULL"}, {"location": {"col": 10, "file": 0, "line": 2451}, "message": "Left side of '&&' is true"}, {"location": {"col": 24, "file": 0, "line": 2451}, "message": "Assuming 'll_li' is equal to NULL"}, {"location": {"col": 5, "file": 0, "line": 2450}, "message": "Loop condition is false. Execution continues on line 2467"}, {"location": {"col": 50, "file": 0, "line": 2467}, "message": "'ri' is not equal to NULL"}, {"location": {"col": 5, "file": 0, "line": 2467}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 11, "file": 0, "line": 2468}, "message": "Assuming 'op' is not equal to NULL"}, {"location": {"col": 11, "file": 0, "line": 2468}, "message": "Left side of '&&' is true"}, {"location": {"col": 25, "file": 0, "line": 2468}, "message": "Assuming the condition is true"}, {"location": {"col": 7, "file": 0, "line": 2468}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 2469}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}, {"location": {"col": 9, "file": 0, "line": 2469}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "bdbb839987397cbcd550664703595fa1", "checkerName": "clang-analyzer-core.NonNullParamChecker", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 0, "line": 2549}, "message": "di (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2549}, "message": "invalid case style for variable 'di_'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "175ac8ff6144cff3ec73c6464e33e9c9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 2656}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "60ddb3a1a33e54a2e3c67690ff12869d", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 6, "file": 0, "line": 2732}, "message": "end of the original"}, {"location": {"col": 60, "file": 0, "line": 2734}, "message": "clone 1 starts here"}, {"location": {"col": 56, "file": 0, "line": 2729}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "1499eefb27c9136206683e95edcdf90e", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 0, "line": 2935}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "0853dbef030c902701c9688b68ddd1f6", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 3007}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "efaab3dde0540f3ddfe53301960ea86e", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3011}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "ebe8fedd27e360b32a2784a323878c5a", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 0, "line": 3012}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d53461bd8aaf990b533b252fa40740b4", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 0, "line": 2805}, "message": "Assuming field 'forceit' is 0"}, {"location": {"col": 3, "file": 0, "line": 2805}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 2807}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 2812}, "message": "Calling 'ex_unletlock'"}, {"location": {"col": 9, "file": 0, "line": 2835}, "message": "Assuming the condition is true"}, {"location": {"col": 5, "file": 0, "line": 2835}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 2839}, "message": "Taking false branch"}, {"location": {"col": 12, "file": 0, "line": 2843}, "message": "'error' is false"}, {"location": {"col": 11, "file": 0, "line": 2843}, "message": "Left side of '&&' is true"}, {"location": {"col": 21, "file": 0, "line": 2843}, "message": "Assuming field 'skip' is 0"}, {"location": {"col": 11, "file": 0, "line": 2843}, "message": "Left side of '&&' is true"}, {"location": {"col": 35, "file": 0, "line": 2843}, "message": "Calling 'do_lock_var'"}, {"location": {"col": 15, "file": 0, "line": 3059}, "message": "Assuming field 'cmdidx' is not equal to CMD_lockvar"}, {"location": {"col": 7, "file": 0, "line": 3062}, "message": "'deep' is not equal to 0"}, {"location": {"col": 3, "file": 0, "line": 3062}, "message": "Taking false branch"}, {"location": {"col": 11, "file": 0, "line": 3066}, "message": "Field 'll_tv' is equal to NULL"}, {"location": {"col": 3, "file": 0, "line": 3066}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 0, "line": 3067}, "message": "Assuming the condition is false"}, {"location": {"col": 5, "file": 0, "line": 3067}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 0, "line": 3072}, "message": "2nd function call argument is an uninitialized value"}, {"location": {"col": 30, "file": 0, "line": 3072}, "message": "2nd function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "a133c4f9709a68b597c4bc86274be19c", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 0, "line": 3072}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8aeb7bf049baa987770802a8fb666d46", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3152}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 3, "file": 0, "line": 3152}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "0c57fe096157af72caadce1368acd16e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 3343}, "message": "function 'eval0' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "faf5f2412529b78e7ca46d49331ce5cf", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 0, "line": 3386}, "message": "function 'eval1' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "69f60e045c7819d804a0bec9eeb03256", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3460}, "message": "function 'eval2' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "343394880aa0d5353a11f214b87d9f0c", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3531}, "message": "function 'eval3' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "cab9473f6528dfc7c0c1d5b59ee13ade", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3611}, "message": "function 'eval4' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "ea365f9b59eb96682ce25ec3c4d75344", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3716}, "message": "function 'eval5' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "015793581d15e221d0db8a3f149b0862", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3721}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d5dda4124edd6633b30e7c1656aeac05", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3722}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "180a4a2e085e37b68b108feaed1970ce", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 3890}, "message": "function 'eval6' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "e4967e26381ed3b253d64b615c8ae1ca", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3895}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d5dda4124edd6633b30e7c1656aeac05", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3897}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "180a4a2e085e37b68b108feaed1970ce", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4034}, "message": "function 'eval7' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "c12ad5737d04c4848b04fe9e23e99b19", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 4039}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "23e9222621b179558a65aec068ea34bd", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4351}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "64a665be9475c683866eca2bb451d6c4", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 0, "line": 4378}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "83b2307ac318adb2e6a07ede8fcca329", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4404}, "message": "function 'eval_method' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "57a940551cf8761f99c4e27d75eb1ed9", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 4479}, "message": "function 'eval_index' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "c1de6ce3182e178e1efffc82de751740", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 4483}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "f8935df0b25003225ad90e69b89cb5c7", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 4815}, "message": "'signed char' to 'int' conversion; consider casting to 'unsigned char' first."}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "638a53c707a7b910153fe3c8d4c9ef1e", "checkerName": "bugprone-signed-char-misuse", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 0, "line": 4915}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "7417568de3bd5d666f9ac5897697fdc5", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5085}, "message": "function 'get_list_tv' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "41e4b4e292115c29a5fb7dcca279905f", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5133}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "50c7e1b211db9f56ec4c31b65cff3db5", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5134}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d8416f8f08280dc1f044999b2943cf02", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 5135}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "a63ef4578775b45d9b41d19d16e91b93", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 5193}, "message": "current_copy_id (fixit)"}, {"location": {"col": 14, "file": 0, "line": 5193}, "message": "invalid case style for variable 'current_copyID'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "84e48b2f038eb06e039ee0e074476325", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 5236}, "message": "copy_id (fixit)"}, {"location": {"col": 13, "file": 0, "line": 5236}, "message": "invalid case style for variable 'copyID'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "2d2ade324e573c19d21aa14d227cb68e", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 5352}, "message": "loop variable has narrower type 'uint8_t' (aka 'unsigned char') than iteration's upper bound 'int'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "130315558849bccb300fe7613dfdfc0b", "checkerName": "bugprone-too-small-loop-variable", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 6, "file": 0, "line": 5551}, "message": "example recursive call chain, starting from function 'set_ref_in_item'"}, {"location": {"col": 17, "file": 0, "line": 5563}, "message": "Frame #1: function 'set_ref_in_item' calls function 'set_ref_in_ht' here:"}, {"location": {"col": 26, "file": 0, "line": 5485}, "message": "Frame #2: function 'set_ref_in_ht' calls function 'set_ref_in_item' here:"}, {"location": {"col": 26, "file": 0, "line": 5485}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 6, "file": 0, "line": 5472}, "message": "function 'set_ref_in_ht' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "992080ba0c1dc7353dfa90282071eb20", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 0, "line": 5510}, "message": "function 'set_ref_in_list' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "550891bc6ff83a8f749bf085d8dbfdfc", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 6, "file": 0, "line": 5551}, "message": "function 'set_ref_in_item' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "466b4a2c51963d7fd6e18d286a818be3", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 12, "file": 0, "line": 5705}, "message": "function 'dict_get_tv' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "7448036329eb626e3d4fd7345f691e09", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 6095}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 6095}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "22cc88e34a652c112383c2046142be1e", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 6098}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "ab850e2834439bb342e3bafbde25f680", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 6099}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 6099}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "e78fbb41dc5f18a9759252322a062f6c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 6245}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "05a978cc539c20bafd57ac87e7015511", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6625}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 6625}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "0be18605848fef30aee47f2db2acfa48", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 6626}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 7, "file": 0, "line": 6626}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d381496192d83af948498d3bbcd3cf39", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 6930}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "6cea40eaa92a293425d6795002511f02", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 58, "file": 0, "line": 7324}, "message": "const (fixit)"}, {"location": {"col": 63, "file": 0, "line": 7324}, "message": "pointer parameter 'col' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "ea7fd00c3c24b1a364ec920dd08f044e", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 7496}, "message": "strcpy (fixit)"}, {"location": {"col": 9, "file": 0, "line": 7496}, "message": "the result from calling 'memcpy' is not null-terminated"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "46a8e22b8645be47d3228bb29eb6ae3d", "checkerName": "bugprone-not-null-terminated-result", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 4, "file": 0, "line": 7657}, "message": "end of the original"}, {"location": {"col": 10, "file": 0, "line": 7682}, "message": "clone 1 starts here"}, {"location": {"col": 53, "file": 0, "line": 7655}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "728beec9779d3b0affdfa459bc029a2b", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 7726}, "message": "function 'set_ref_in_callback' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "f057621fd75b7fa941a6c4e5974715fe", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 37, "file": 2, "line": 849}, "message": "expanded from macro 'TV_LIST_ITER_CONST'"}, {"location": {"col": 11, "file": 2, "line": 824}, "message": "expanded from macro '_TV_LIST_ITER_MOD'"}, {"location": {"col": 11, "file": 0, "line": 7948}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "1b6622a1503591c8c9e1e18b2e72ed47", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 8050}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "e457117a90e42d1962ca9c323fef1adf", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 8195}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "019507c23b00a8bcbe34aae8a014a71f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 7, "file": 0, "line": 8211}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "22c3c45e0bba709890eb48bcfc4e678c", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8350}, "message": "function 'get_name_len' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "3bf0e7be441fadf366b95b8571289646", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 0, "line": 3386}, "message": "example recursive call chain, starting from function 'eval1'"}, {"location": {"col": 7, "file": 0, "line": 3394}, "message": "Frame #1: function 'eval1' calls function 'eval2' here:"}, {"location": {"col": 7, "file": 0, "line": 3470}, "message": "Frame #2: function 'eval2' calls function 'eval3' here:"}, {"location": {"col": 7, "file": 0, "line": 3541}, "message": "Frame #3: function 'eval3' calls function 'eval4' here:"}, {"location": {"col": 7, "file": 0, "line": 3622}, "message": "Frame #4: function 'eval4' calls function 'eval5' here:"}, {"location": {"col": 7, "file": 0, "line": 3728}, "message": "Frame #5: function 'eval5' calls function 'eval6' here:"}, {"location": {"col": 7, "file": 0, "line": 3903}, "message": "Frame #6: function 'eval6' calls function 'eval7' here:"}, {"location": {"col": 11, "file": 0, "line": 4158}, "message": "Frame #7: function 'eval7' calls function 'get_list_tv' here:"}, {"location": {"col": 9, "file": 0, "line": 5096}, "message": "Frame #8: function 'get_list_tv' calls function 'eval1' here:"}, {"location": {"col": 9, "file": 0, "line": 5096}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 16, "file": 0, "line": 8502}, "message": "function 'make_expanded_name' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "b4843d96e2282f156114f96f8bdd6789", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8522}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8522}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "2cb2d3012ddb74983d63d419fb79fa10", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8523}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8523}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "6e1f6d4ad9d98d49eea1e4713e407c98", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8524}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8524}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "4c35dbcb33431e6910a79dd5b986df3c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8818}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 250}, "message": "expanded from macro 'STRCAT'"}, {"location": {"col": 5, "file": 0, "line": 8818}, "message": "Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "f80bc69c97d45f37ed6ca30a2e25336c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8831}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8831}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "099c3fa7566dca2dad78343ef2eaaced", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8833}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 8833}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8b3f6c3c2b024d75f40dbc03ab054e5c", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8926}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "60ddb3a1a33e54a2e3c67690ff12869d", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 8943}, "message": "function 'handle_subscript' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "91cdc202e79f6bb3709bd4713b6a2c41", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 24, "file": 0, "line": 9242}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "79e61ba4b0104dbde914fbe5e379a5a8", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 31, "file": 0, "line": 9447}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "3fb1b6b3cde41d05564f1cee7e191796", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 0, "line": 9486}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "5068d63aa86125775e1cab47f41ce110", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 9521}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 5, "file": 0, "line": 9521}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "3a7fd8695f4e75f27a2eee7c908999d2", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 0, "line": 9657}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8b54f8746b5119e7646cefddc0ae5b3c", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 49, "file": 0, "line": 10122}, "message": "const (fixit)"}, {"location": {"col": 61, "file": 0, "line": 10122}, "message": "pointer parameter 'total' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "66e0b459130f257351fff6c58fe6ad07", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 68, "file": 0, "line": 10122}, "message": "const (fixit)"}, {"location": {"col": 80, "file": 0, "line": 10122}, "message": "pointer parameter 'self' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "cb52efd847ef07587a8de6ab20484830", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 10308}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "60ddb3a1a33e54a2e3c67690ff12869d", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 10471}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "a952a1ba276dc77923603391d9c33a88", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 78, "file": 0, "line": 10747}, "message": "const (fixit)"}, {"location": {"col": 86, "file": 0, "line": 10747}, "message": "pointer parameter 'flags' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "2c8cf93683c8f6141b98fc5449b6c21e", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 10811}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 10811}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "8547f5821f95f5971a5a05b4adc2c289", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 11111}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "d5dda4124edd6633b30e7c1656aeac05", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 11328}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/eval.c", "reportHash": "bb8fce835bc5934e214f345f49cd366d", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
